cscope 15 $HOME/priv-code-lock/freedom/rocket-chip/src               0001424036
	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Bundles.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
GíîicP¨amëîizedBundÀ


8 
ab°ø˘
 cœs†
	cAHBBundÀBa£
(
∑øms
: 
AHBBundÀP¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

11 ˛as†
	cAHBBundÀ
(
∑øms
: 
AHBBundÀP¨amëîs
Ë
exãnds
 
	$AHBBundÀBa£
(
∑øms
)

14 
vÆ
 
hma°lock
 = 
	$Boﬁ
(
OUTPUT
)

15 
vÆ
 
hå™s
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
å™sBôs
)

16 
vÆ
 
h£l
 = 
	$Boﬁ
(
OUTPUT
)

17 
vÆ
 
hªady
 = 
	$Boﬁ
(
OUTPUT
)

20 
vÆ
 
hwrôe
 = 
	$Boﬁ
(
OUTPUT
)

21 
vÆ
 
haddr
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
addrBôs
)

22 
vÆ
 
hsize
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
sizeBôs
)

23 
vÆ
 
hbur°
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
bur°Bôs
)

24 
vÆ
 
h¥Ÿ
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
¥ŸBôs
)

25 
vÆ
 
hwd©a
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
d©aBôs
)

27 
vÆ
 
hªadyout
 = 
	$Boﬁ
(
INPUT
)

28 
vÆ
 
hª•
 = 
	$Boﬁ
(
INPUT
)

29 
vÆ
 
hrd©a
 = 
	$UI¡
(
INPUT
, 
width
 = 
∑øms
.
d©aBôs
)

31 
def
 
	$tõoff
() {

32 
hªadyout
.
dú
 
m©ch
 {

33 
INPUT
 =>

34 
hªadyout
 :
	`Boﬁ
(
Ál£
)

35 
hª•
 :
AHBP¨amëîs
.
RESP_OKAY


36 
hrd©a
 :
	`UI¡
(0)

37 
OUTPUT
 =>

38 
hma°lock
 :
	`Boﬁ
(
Ál£
)

39 
hå™s
 :
AHBP¨amëîs
.
TRANS_IDLE


40 
h£l
 :
	`Boﬁ
(
Ál£
)

41 
hªady
 :
	`Boﬁ
(
Ál£
)

42 
hwrôe
 :
	`Boﬁ
(
Ál£
)

43 
haddr
 :
	`UI¡
(0)

44 
hsize
 :
	`UI¡
(0)

45 
hbur°
 :
AHBP¨amëîs
.
BURST_SINGLE


46 
h¥Ÿ
 :
AHBP¨amëîs
.
PROT_DEFAULT


47 
hwd©a
 :
	`UI¡
(0)

48 
_
 =>

51 
	}
}

53 
obje˘
 
AHBBundÀ


55 
def
 
≠∂y
(
∑øms
: 
AHBBundÀP¨amëîs
Ë
√w
 
AHBBundÀ
(params)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Nodes.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
obje˘
 
AHBImp
 
exãnds
 
	gSim∂eNodeImp
[
AHBMa°îP‹tP¨amëîs
, 
AHBSœveP‹tP¨amëîs
, 
AHBEdgeP¨amëîs
, 
AHBBundÀ
]

12 
def
 
edge
(
pd
: 
AHBMa°îP‹tP¨amëîs
, 
pu
: 
AHBSœveP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
AHBEdgeP¨amëîs
(pd,Öu,Ö, sourceInfo)

13 
def
 
bundÀ
(
e
: 
AHBEdgeP¨amëîs
Ë
AHBBundÀ
(e.bundle)

14 
def
 
ªndî
(
e
: 
AHBEdgeP¨amëîs
Ë
RídîedEdge
(
cﬁour
 = "#00ccff" , 
œbñ
 = (e.
¶ave
.
bótByãs
 * 8).
toSåög
)

16 
ovîride
 
def
 
mixO
(
pd
: 
AHBMa°îP‹tP¨amëîs
, 
node
: 
Outw¨dNode
[AHBMa°îP‹tP¨amëîs, 
AHBSœveP‹tP¨amëîs
, 
AHBBundÀ
]): AHBMasterPortParameters =

17 
pd
.
c›y
(
ma°îs
 =Öd.ma°îs.
m≠
 { 
c
 => c.c›y (
nodeP©h
 = 
node
 +: c.nodePath) })

18 
ovîride
 
def
 
mixI
(
pu
: 
AHBSœveP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
AHBMa°îP‹tP¨amëîs
, AHBSœveP‹tP¨amëîs, 
AHBBundÀ
]): AHBSlavePortParameters =

19 
pu
.
c›y
(
¶aves
 =Öu.¶aves.
m≠
 { 
m
 => m.c›y (
nodeP©h
 = 
node
 +: m.nodePath) })

23 
˛ass
 
	$AHBMa°îNode
(
p‹tP¨ams
: 
Seq
[
AHBMa°îP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$Sour˚Node
(
AHBImp
)(
p‹tP¨ams
)

24 
˛ass
 
	$AHBSœveNode
(
p‹tP¨ams
: 
Seq
[
AHBSœveP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$SökNode
(
AHBImp
)(
p‹tP¨ams
)

25 
˛ass
 
	`AHBNexusNode
(

26 
ma°îFn
: 
Seq
[
AHBMa°îP‹tP¨amëîs
] => AHBMasterPortParameters,

27 
¶aveFn
: 
Seq
[
AHBSœveP‹tP¨amëîs
] => AHBSlavePortParameters)(

28 
im∂icô
 
vÆName
: 
VÆName
)

29 
exãnds
 
	$NexusNode
(
AHBImp
)(
ma°îFn
, 
¶aveFn
)

31 
˛ass
 
	$AHBIdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	`IdítôyNode
(
AHBImp
)()

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Parameters.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.
max


11 
˛ass
 
AHBSœveP¨amëîs
(

12 
addªss
: 
Seq
[
AddªssSë
],

13 
ªsour˚s
: 
Seq
[
Resour˚
] = 
Nû
,

14 
ªgi⁄Ty≥
: 
Regi⁄Ty≥
.
T
 = Regi⁄Ty≥.
GET_EFFECTS
,

15 
execuèbÀ
: 
Boﬁón
 = 
Ál£
,

16 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

17 
suµ‹tsWrôe
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

18 
suµ‹tsRód
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
)

20 
addªss
.
f‹óch
 { 
a
 => 
ªquúe
 (a.
föôe
) }

21 
addªss
.
combö©i⁄s
(2).
f‹óch
 { 
Seq
(
x
,
y
Ë=> 
ªquúe
 (!x.
ovîœps
(y)) }

23 
vÆ
 
	g«me
 = 
nodeP©h
.
œ°O±i⁄
.
m≠
(
_
.
œzyModuÀ
.
«me
).
gëOrEl£
("disconnected")

24 
vÆ
 
maxTøns„r
 = 
max
(
suµ‹tsWrôe
.max, 
suµ‹tsRód
.max)

25 
vÆ
 
	gmaxAddªss
 = 
addªss
.
m≠
(
_
.
max
).max

26 
vÆ
 
möAlignmít
 = 
addªss
.
m≠
(
_
.
Æignmít
).
mö


29 
ªquúe
 (
möAlignmít
 >
maxTøns„r
)

32 
˛ass
 
	$AHBSœveP‹tP¨amëîs
(

33 
¶aves
: 
Seq
[
AHBSœveP¨amëîs
],

34 
bótByãs
: 
I¡
)

36 
	`ªquúe
 (!
¶aves
.
isEm±y
)

37 
	`ªquúe
 (
	`isPow2
(
bótByãs
))

39 
vÆ
 
maxTøns„r
 = 
¶aves
.
	`m≠
(
_
.maxTøns„r).
max


40 
vÆ
 
maxAddªss
 = 
¶aves
.
	`m≠
(
_
.maxAddªss).
max


43 
	`ªquúe
 (
maxTøns„r
 >
bótByãs
)

45 
	`ªquúe
 (
maxTøns„r
 <
bótByãs
 * 
AHBP¨amëîs
.maxTransfer)

48 
¶aves
.
	`combö©i⁄s
(2).
f‹óch
 { 
	`Seq
(
x
,
y
) =>

49 
x
.
addªss
.
f‹óch
 { 
a
 => 
y
.addªss.f‹óch { 
b
 =>

50 
	`ªquúe
 (!
a
.
	`ovîœps
(
b
))

53 
	}
}

55 
˛ass
 
AHBMa°îP¨amëîs
(

56 
«me
: 
Såög
,

57 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

59 
˛ass
 
	$AHBMa°îP‹tP¨amëîs
(

60 
ma°îs
: 
Seq
[
AHBMa°îP¨amëîs
])

62 
˛ass
 
	$AHBBundÀP¨amëîs
(

63 
addrBôs
: 
I¡
,

64 
d©aBôs
: 
I¡
)

66 
	`ªquúe
 (
d©aBôs
 >= 8)

67 
	`ªquúe
 (
addrBôs
 >= 1)

68 
	`ªquúe
 (
	`isPow2
(
d©aBôs
))

71 
vÆ
 
å™sBôs
 = 
AHBP¨amëîs
.transBits

72 
vÆ
 
bur°Bôs
 = 
AHBP¨amëîs
.burstBits

73 
vÆ
 
¥ŸBôs
 = 
AHBP¨amëîs
.protBits

74 
vÆ
 
sizeBôs
 = 
AHBP¨amëîs
.sizeBits

76 
def
 (
x
: 
AHBBundÀP¨amëîs
) =

77 
	`AHBBundÀP¨amëîs
(

78 
	`max
(
addrBôs
, 
x
.addrBits),

79 
	`max
(
d©aBôs
, 
x
.dataBits))

80 
	}
}

82 
obje˘
 
	gAHBBundÀP¨amëîs


84 
vÆ
 
	gem±yBundÀP¨ams
 = 
AHBBundÀP¨amëîs
(
addrBôs
 = 1, 
d©aBôs
 = 8)

85 
def
 (
x
: 
Seq
[
AHBBundÀP¨amëîs
]Ëx.
fﬁdLe·
(
em±yBundÀP¨ams
)((x,
	gy
Ë=> x.(
y
))

87 
def
 
≠∂y
(
ma°î
: 
AHBMa°îP‹tP¨amëîs
, 
¶ave
: 
AHBSœveP‹tP¨amëîs
) =

88 
√w
 
AHBBundÀP¨amëîs
(

89 
addrBôs
 = 
log2Up
(
¶ave
.
maxAddªss
+1),

90 
d©aBôs
 = 
¶ave
.
bótByãs
 * 8)

93 
˛ass
 
	$AHBEdgeP¨amëîs
(

94 
ma°î
: 
AHBMa°îP‹tP¨amëîs
,

95 
¶ave
: 
AHBSœveP‹tP¨amëîs
,

96 
∑øms
: 
P¨amëîs
,

97 
sour˚Info
: 
Sour˚Info
)

99 
vÆ
 
bundÀ
 = 
	`AHBBundÀP¨amëîs
(
ma°î
, 
¶ave
)

100 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Protocol.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


7 
obje˘
 
	gAHBP¨amëîs


10 
vÆ
 
	gå™sBôs
 = 2

11 
vÆ
 
bur°Bôs
 = 3

12 
vÆ
 
¥ŸBôs
 = 4

13 
vÆ
 
sizeBôs
 = 3

15 
def
 
TRANS_IDLE
 = 
UI¡
(0, 
width
 = 
å™sBôs
)

16 
def
 
TRANS_BUSY
 = 
UI¡
(1, 
width
 = 
å™sBôs
)

17 
def
 
TRANS_NONSEQ
 = 
UI¡
(2, 
width
 = 
å™sBôs
)

18 
def
 
TRANS_SEQ
 = 
UI¡
(3, 
width
 = 
å™sBôs
)

20 
def
 
BURST_SINGLE
 = 
UI¡
(0, 
width
 = 
bur°Bôs
)

21 
def
 
BURST_INCR
 = 
UI¡
(1, 
width
 = 
bur°Bôs
)

22 
def
 
BURST_WRAP4
 = 
UI¡
(2, 
width
 = 
bur°Bôs
)

23 
def
 
BURST_INCR4
 = 
UI¡
(3, 
width
 = 
bur°Bôs
)

24 
def
 
BURST_WRAP8
 = 
UI¡
(4, 
width
 = 
bur°Bôs
)

25 
def
 
BURST_INCR8
 = 
UI¡
(5, 
width
 = 
bur°Bôs
)

26 
def
 
BURST_WRAP16
 = 
UI¡
(6, 
width
 = 
bur°Bôs
)

27 
def
 
BURST_INCR16
 = 
UI¡
(7, 
width
 = 
bur°Bôs
)

29 
vÆ
 
maxTøns„r
 = 16

31 
def
 
RESP_OKAY
 = 
Boﬁ
(
Ál£
)

32 
def
 
RESP_ERROR
 = 
Boﬁ
(
åue
)

34 
def
 
PROT_DATA
 = 
UI¡
(1, 
width
 = 
¥ŸBôs
)

35 
def
 
PROT_PRIVILEDGED
 = 
UI¡
(2, 
width
 = 
¥ŸBôs
)

36 
def
 
PROT_BUFFERABLE
 = 
UI¡
(4, 
width
 = 
¥ŸBôs
)

37 
def
 
PROT_CACHEABLE
 = 
UI¡
(8, 
width
 = 
¥ŸBôs
)

38 
def
 
PROT_DEFAULT
 = 
PROT_DATA
 | 
PROT_PRIVILEDGED


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/RegisterRouter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.{
	gI¡Sour˚Node
, 
	gI¡Sour˚P‹tSim∂e
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gHëîogíeousBag
, 
	gMaskGí
}

11 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

13 
˛ass
 
	$AHBRegi°îNode
(
addªss
: 
AddªssSë
, 
c⁄cuºícy
: 
I¡
 = 0, 
bótByãs
: I¡ = 4, 
undefZîo
: 
Boﬁón
 = 
åue
, 
execuèbÀ
: Boﬁó¿
Ál£
)(
im∂icô
 
vÆName
: 
VÆName
)

14 
exãnds
 
	$SökNode
(
AHBImp
)(
	`Seq
(
	`AHBSœveP‹tP¨amëîs
(

15 
	`Seq
(
	`AHBSœveP¨amëîs
(

16 
addªss
 = 
	`Seq
(address),

17 
execuèbÀ
 =Éxecutable,

18 
suµ‹tsWrôe
 = 
	`Tøns„rSizes
(1, 
	`mö
(
addªss
.
Æignmít
.
toI¡
, 
bótByãs
 * 
AHBP¨amëîs
.
maxTøns„r
)),

19 
suµ‹tsRód
 = 
	`Tøns„rSizes
(1, 
	`mö
(
addªss
.
Æignmít
.
toI¡
, 
bótByãs
 * 
AHBP¨amëîs
.
maxTøns„r
)))),

20 
bótByãs
 = beatBytes)))

22 
	`ªquúe
 (
addªss
.
c⁄tiguous
)

26 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*) = {

27 
	`vÆ
 (
ahb
, 
_
Ë
this
.
	`ö
(0)

29 
vÆ
 
ödexBôs
 = 
	`log2Up
((
addªss
.
mask
+1)/
bótByãs
)

30 
vÆ
 
∑øms
 = 
	`RegM≠≥rP¨ams
(
ödexBôs
, 
bótByãs
, 1)

31 
vÆ
 
ö
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`RegM≠≥rI≈ut
(
∑øms
)))

32 
vÆ
 
out
 = 
	`RegM≠≥r
(
bótByãs
, 
c⁄cuºícy
, 
undefZîo
, 
ö
, 
m≠pög
:
_
*)

34 
vÆ
 
d_pha£
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

35 
vÆ
 
d_èkí
 = 
	`Reg
(
	`Boﬁ
())

36 
vÆ
 
d_ªad
 = 
	`Reg
(
	`Boﬁ
())

37 
vÆ
 
d_ödex
 = 
	`Reg
(
	`UI¡
(
width
 = 
ödexBôs
))

38 
vÆ
 
d_mask
 = 
	`Reg
(
	`UI¡
(
width
 = 
bótByãs
))

41 
d_èkí
 :
d_pha£
 && 
ö
.
ªady


42 
ö
.
vÆid
 :
d_pha£
 && !
d_èkí


44 
ö
.
bôs
.
ªad
 :
d_ªad


45 
ö
.
bôs
.
ödex
 :
d_ödex


46 
ö
.
bôs
.
d©a
 :
ahb
.
hwd©a


47 
ö
.
bôs
.
mask
 :
d_mask


48 
ö
.
bôs
.
exåa
 :
	`UI¡
(0)

50 
	`whí
 (
ahb
.
hªady
Ë{ 
d_pha£
 :
	`Boﬁ
(
Ál£
) }

51 
ahb
.
hªadyout
 :!
d_pha£
 || 
out
.
vÆid


52 
ahb
.
hª•
 :
AHBP¨amëîs
.
RESP_OKAY


53 
ahb
.
hrd©a
 :
out
.
bôs
.
d©a


55 
vÆ
 
ªque°
 = 
ahb
.
hå™s
 ==
AHBP¨amëîs
.
TRANS_NONSEQ
 ||áhb.hå™†==AHBP¨amëîs.
TRANS_SEQ


56 
	`whí
 (
ahb
.
hªady
 &&áhb.
h£l
 && 
ªque°
) {

57 
	`as£π
 (!
ö
.
vÆid
 || in.
ªady
)

58 
d_pha£
 :
	`Boﬁ
(
åue
)

59 
d_èkí
 :
	`Boﬁ
(
Ál£
)

60 
d_ªad
 :!
ahb
.
hwrôe


61 
d_ödex
 :
ahb
.
haddr
 >> 
	`log2Ceû
(
bótByãs
)

62 
d_mask
 :
	`MaskGí
(
ahb
.
haddr
,áhb.
hsize
, 
bótByãs
)

65 
out
.
ªady
 :
	`Boﬁ
(
åue
)

66 
	`as£π
 (
d_pha£
 || !
out
.
vÆid
)

68 
	}
}

73 
ab°ø˘
 
˛ass
 
	$AHBRegi°îRouãrBa£
(
addªss
: 
AddªssSë
, 
öãºu±s
: 
I¡
, 
c⁄cuºícy
: I¡, 
bótByãs
: I¡, 
undefZîo
: 
Boﬁón
, 
execuèbÀ
: Boﬁón)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


75 
vÆ
 
node
 = 
	`AHBRegi°îNode
(
addªss
, 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

76 
vÆ
 
öäode
 = 
	`I¡Sour˚Node
(
	`I¡Sour˚P‹tSim∂e
(
num
 = 
öãºu±s
))

77 
	}
}

79 ˛as†
	cAHBRegBundÀArg
()(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
)

81 ˛as†
	cAHBRegBundÀBa£
(
¨g
: 
AHBRegBundÀArg
Ë
exãnds
 
BundÀ


83 
im∂icô
 
vÆ
 
p
 = 
¨g
.p

86 
˛ass
 
AHBRegBundÀ
[
P
](
vÆ
 
∑øms
: P, 
¨g
: 
AHBRegBundÀArg
Ë
exãnds
 
	$AHBRegBundÀBa£
(
¨g
)

88 
˛ass
 
AHBRegModuÀ
[
P
, 
B
 <: 
AHBRegBundÀBa£
](
vÆ
 
∑øms
: P, 
bundÀBuûdî
: => B, 
rouãr
: 
AHBRegi°îRouãrBa£
)

89 
exãnds
 
	$LazyModuÀImp
(
rouãr
Ë
wôh
 
HasRegM≠


91 
vÆ
 
io
 = 
	`IO
(
bundÀBuûdî
)

92 
vÆ
 
öãºu±s
 = i‡(
rouãr
.
öäode
.
out
.
isEm±y
Ë
	`Vec
(0, 
	`Boﬁ
()Ërouãr.öäode.
	`out
(0).
_1


93 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*Ë
rouãr
.
node
.ªgm≠(m≠pög:
_
*)

94 
	}
}

96 
˛ass
 
AHBRegi°îRouãr
[
B
 <: 
AHBRegBundÀBa£
, 
M
 <: 
LazyModuÀImp
]

97 (
vÆ
 
ba£
: 
BigI¡
, vÆ 
	göãºu±s
: 
I¡
 = 0, vÆ 
	gsize
: BigI¡ = 4096, vÆ 
	gc⁄cuºícy
: I¡ = 0, vÆ 
	gbótByãs
: I¡ = 4, 
	gundefZîo
: 
Boﬁón
 = 
åue
, 
	gexecuèbÀ
: Boﬁó¿
Ál£
)

98 (
bundÀBuûdî
: 
AHBRegBundÀArg
 => 
B
)

99 (
moduÀBuûdî
: (=> 
B
, 
	gAHBRegi°îRouãrBa£
Ë=> 
M
)(
im∂icô
 
p
: 
P¨amëîs
)

100 
exãnds
 
AHBRegi°îRouãrBa£
(
AddªssSë
(
ba£
, 
size
-1), 
öãºu±s
, 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

102 
ªquúe
 (
isPow2
(
size
))

105 
œzy
 
vÆ
 
	gmoduÀ
 = 
moduÀBuûdî
(
bundÀBuûdî
(
AHBRegBundÀArg
()), 
this
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/SRAM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
LFSRNoi£Makî


11 
˛ass
 
	$AHBRAM
(

12 
addªss
: 
AddªssSë
,

13 
execuèbÀ
: 
Boﬁón
 = 
åue
,

14 
bótByãs
: 
I¡
 = 4,

15 
fuzzHªadyout
: 
Boﬁón
 = 
Ál£
,

16 
devName
: 
O±i⁄
[
Såög
] = 
N⁄e
,

17 
îr‹s
: 
Seq
[
AddªssSë
] = 
Nû
)

18 (
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$Dùlom©icSRAM
(
addªss
, 
bótByãs
, 
devName
)

20 
vÆ
 
node
 = 
	`AHBSœveNode
(
	`Seq
(
	`AHBSœveP‹tP¨amëîs
(

21 
	`Seq
(
	`AHBSœveP¨amëîs
(

22 
addªss
 = 
	`Li°
◊ddªssË++ 
îr‹s
,

23 
ªsour˚s
 =Ñesources,

24 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

25 
execuèbÀ
 =Éxecutable,

26 
suµ‹tsRód
 = 
	`Tøns„rSizes
(1, 
bótByãs
 * 
AHBP¨amëîs
.
maxTøns„r
),

27 
suµ‹tsWrôe
 = 
	`Tøns„rSizes
(1, 
bótByãs
 * 
AHBP¨amëîs
.
maxTøns„r
))),

28 
bótByãs
 = beatBytes)))

30 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

31 
	`vÆ
 (
ö
, 
_
Ë
node
.
	`ö
(0)

32 
vÆ
 
mem
 = 
	`makeSögÀP‹ãdByãWrôeSeqMem
(1 << 
mask
.
	`fûãr
(
b
=>b).
size
)

35 
vÆ
 
a_ac˚ss
 = 
ö
.
hå™s
 ==
AHBP¨amëîs
.
TRANS_NONSEQ
 || in.hå™†==AHBP¨amëîs.
TRANS_SEQ


36 
vÆ
 
a_ªque°
 = 
ö
.
hªady
 && in.
h£l
 && 
a_ac˚ss


37 
vÆ
 
a_mask
 = 
	`MaskGí
(
ö
.
haddr
, in.
hsize
, 
bótByãs
)

38 
vÆ
 
a_addªss
 = 
	`C©
((
mask
 
	`zù
 (
ö
.
haddr
 >> 
	`log2Ceû
(
bótByãs
)).
toBoﬁs
).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
).
ªvî£
)

39 
vÆ
 
a_wrôe
 = 
ö
.
hwrôe


40 
vÆ
 
a_ÀgÆ
 = 
addªss
.
	`c⁄èös
(
ö
.
haddr
)

43 
vÆ
 
d_wd©a
 = 
Vec
.
	`èbuœã
(
bótByãs
Ë{ 
i
 => 
ö
.
	`hwd©a
(8*(i+1)-1, 8*i) }

57 
vÆ
 
p_vÆid
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

58 
vÆ
 
p_addªss
 = 
	`Reg
(
a_addªss
)

59 
vÆ
 
p_mask
 = 
	`Reg
(
a_mask
)

60 
vÆ
 
p_œtch_d
 = 
	`Reg
(
	`Boﬁ
())

61 
vÆ
 
p_wd©a
 = 
d_wd©a
 
hﬁdU∆ess
 
p_œtch_d


64 
vÆ
 
ªad
 = 
a_ªque°
 && !
a_wrôe


66 
vÆ
 
d_rd©a
 = 
mem
.
	`ªadAndHﬁd
(
a_addªss
, 
ªad
)

67 
vÆ
 
d_ÀgÆ
 = 
	`RegE«bÀ
(
a_ÀgÆ
, 
ö
.
hªadyout
)

69 
	`whí
 (!
ªad
 && 
p_vÆid
) {

70 
p_vÆid
 :
	`Boﬁ
(
Ál£
)

71 
mem
.
	`wrôe
(
p_addªss
, 
p_wd©a
, 
p_mask
.
toBoﬁs
)

75 
p_œtch_d
 :
a_ªque°
 && 
a_wrôe


76 
	`whí
 (
a_ªque°
 && 
a_wrôe
 && 
a_ÀgÆ
) {

77 
p_vÆid
 :
	`Boﬁ
(
åue
)

78 
p_addªss
 :
a_addªss


79 
p_mask
 :
a_mask


83 
vÆ
 
a_by∑ss
 = 
a_addªss
 ==
p_addªss
 && 
p_vÆid


84 
vÆ
 
d_by∑ss
 = 
	`RegE«bÀ
(
a_by∑ss
, 
a_ªque°
)

87 
vÆ
 
muxd©a
 = 
	`Vec
((
p_mask
.
toBoﬁs
 
	`zù
 (
p_wd©a
 
zù
 
d_rd©a
))

88 
m≠
 { (
m
, (
p
, 
r
)Ë=> 
	`Mux
(
d_by∑ss
 && m,Ö,Ñ) })

91 
vÆ
 
d_ªque°
 = 
	`Reg
(
	`Boﬁ
(
Ál£
))

92 
	`whí
 (
ö
.
hªady
Ë{ 
d_ªque°
 :
	`Boﬁ
(
Ál£
) }

93 
	`whí
 (
a_ªque°
Ë{ 
d_ªque°
 :
	`Boﬁ
(
åue
) }

96 
ö
.
hªadyout
 :(if(
fuzzHªadyout
Ë{ !
d_ªque°
 || 
	`LFSRNoi£Makî
(1)(0Ë} { 
	`Boﬁ
(
åue
) })

97 
ö
.
hª•
 :
	`Mux
(
d_ÀgÆ
 || !ö.
hªadyout
, 
AHBP¨amëîs
.
RESP_OKAY
, AHBP¨amëîs.
RESP_ERROR
)

98 
ö
.
hrd©a
 :
	`Mux
(ö.
hªadyout
, 
muxd©a
.
asUI¡
, 
	`UI¡
(0))

100 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Test.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
TLTe°RAM


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


12 
˛ass
 
	$RRTe°0
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$AHBRegi°îRouãr
(
addªss
, 0, 32, 0, 4)(

13 
√w
 
	`AHBRegBundÀ
((), 
_
Ë
wôh
 
RRTe°0BundÀ
)(

14 
√w
 
	`AHBRegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°0ModuÀ
)

16 
˛ass
 
	$RRTe°1
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$AHBRegi°îRouãr
(
addªss
, 0, 32, 1, 4, 
Ál£
)(

17 
√w
 
	`AHBRegBundÀ
((), 
_
Ë
wôh
 
RRTe°1BundÀ
)(

18 
√w
 
	`AHBRegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°1ModuÀ
)

20 
˛ass
 
	$AHBFuzzN©ive
(
aFlow
: 
Boﬁón
, 
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


22 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

23 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AHBFuzzNative"))

24 
vÆ
 
xb¨
 = 
	`LazyModuÀ
(
√w
 
AHBF™out
)

25 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`AHBRAM
(
	`AddªssSë
(0x0, 0xff)))

26 
vÆ
 
gpio
 = 
	`LazyModuÀ
(
√w
 
	`RRTe°0
(0x100))

28 
xb¨
.
node
 :
	`TLToAHB
(
aFlow
Ë:
	`TLDñayî
(0.1Ë:
modñ
.nodê:
fuzz
.node

29 
øm
.
node
 :
xb¨
.node

30 
gpio
.
node
 :
xb¨
.node

32 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

33 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

35 
	}
}

37 
˛ass
 
	$AHBN©iveTe°
(
aFlow
: 
Boﬁón
, 
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

38 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AHBFuzzN©ive
(
aFlow
, 
txns
)).
moduÀ
)

39 
io
.
föished
 :
dut
.io.finished

40 
	}
}

42 
åaô
 
HasFuzzT¨gë
 {

43 
vÆ
 
fuzzAddr
 = 
AddªssSë
(0x0, 0xfff)

44 
vÆ
 
	g∑âîn
 = 
Seq
(
AddªssSë
(0x8, ~0x808),

45 
AddªssSë
(0x900, ~0x900))

48 
˛ass
 
	$AHBFuzzMa°î
(
aFlow
: 
Boﬁón
, 
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 
wôh
 
HasFuzzT¨gë


50 
vÆ
 
node
 = 
	`AHBIdítôyNode
()

51 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
, 
ovîrideAddªss
 = 
	`Some
(
fuzzAddr
)))

52 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AHBFuzzMa°î", 
ign‹eC‹ru±D©a
=
åue
))

54 (
node


55 :
	`TLToAHB
(
aFlow
)

56 :
	`TLDñayî
(0.2)

57 :
	`TLBuf„r
(
Buf„rP¨ams
.
Êow
)

58 :
	`TLDñayî
(0.2)

59 :
	`TLEº‹EvÆu©‹
(
∑âîn
, 
ã°On
=
åue
, 
ã°Off
=true)

60 :
modñ
.
node


61 :
fuzz
.
node
)

63 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

64 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

65 
vÆ
 
föished
 = 
	`Boﬁ
(
OUTPUT
)

68 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

70 
	}
}

72 ˛as†
	cAHBFuzzSœve
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
Sim∂eLazyModuÀ
 
wôh
 
HasFuzzT¨gë


74 
vÆ
 
node
 = 
	$AHBIdítôyNode
()

75 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	$TLTe°RAM
(
fuzzAddr
, 
åackC‹ru±i⁄
=
Ál£
))

77 (
øm
.
node


78 :
	$TLEº‹EvÆu©‹
(
∑âîn
)

79 :
	$TLFøgmíãr
(4, 16)

80 :
	$TLDñayî
(0.2)

81 :
	$TLBuf„r
(
Buf„rP¨ams
.
Êow
)

82 :
	$TLDñayî
(0.2)

83 :
	$AHBToTL
()

84 :
node
)

87 
˛ass
 
	$AHBFuzzBridge
(
aFlow
: 
Boﬁón
, 
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


89 
vÆ
 
ma°î
 = 
	`LazyModuÀ
(
√w
 
	`AHBFuzzMa°î
(
aFlow
, 
txns
))

90 
vÆ
 
¶ave
 = 
	`LazyModuÀ
(
√w
 
AHBFuzzSœve
)

92 
¶ave
.
node
 :
ma°î
.node

94 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

95 
io
.
föished
 :
ma°î
.
moduÀ
.io.finished

97 
	}
}

99 
˛ass
 
	$AHBBridgeTe°
(
aFlow
: 
Boﬁón
, 
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

100 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AHBFuzzBridge
(
aFlow
, 
txns
)).
moduÀ
)

101 
io
.
föished
 :
dut
.io.finished

102 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/ToTL.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
MaskGí


11 
˛ass
 
	$AHBToTLNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$MixedAd≠ãrNode
(
AHBImp
, 
TLImp
)(

12 
dFn
 = { 
	`AHBMa°îP‹tP¨amëîs
(
ma°îs
) =>

13 
	`TLClõ¡P‹tP¨amëîs
(
˛õ¡s
 = 
ma°îs
.
m≠
 { 
m
 =>

14 
	`TLClõ¡P¨amëîs
(
«me
 = 
m
.«me, 
nodeP©h
 = m.nodePath)

16 
	}
},

17 
	guFn
 = { 
mp
 => 
AHBSœveP‹tP¨amëîs
(

18 
¶aves
 = 
mp
.
m™agîs
.
m≠
 { 
m
 =>

19 
def
 
adju°
(
x
: 
Tøns„rSizes
) = {

20 i‡(
x
.
c⁄èös
(
mp
.
bótByãs
)) {

21 
Tøns„rSizes
(
x
.
mö
, 
m
.
möAlignmít
.mö(
mp
.
bótByãs
 * 
AHBP¨amëîs
.
maxTøns„r
).
toI¡
)

23 
x
.
öãr£˘
(
Tøns„rSizes
(1, 
mp
.
bótByãs
))

27 
AHBSœveP¨amëîs
(

28 
addªss
 = 
m
.address,

29 
ªsour˚s
 = 
m
.resources,

30 
ªgi⁄Ty≥
 = 
m
.regionType,

31 
execuèbÀ
 = 
m
.executable,

32 
nodeP©h
 = 
m
.nodePath,

33 
suµ‹tsWrôe
 = 
adju°
(
m
.
suµ‹tsPutFuŒ
),

34 
suµ‹tsRód
 = 
adju°
(
m
.
suµ‹tsGë
))},

35 
bótByãs
 = 
mp
.beatBytes)

38 ˛as†
	cAHBToTL
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


40 
vÆ
 
node
 = 
	$AHBToTLNode
()

42 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

43 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

44 
vÆ
 
bótByãs
 = 
edgeOut
.
m™agî
.beatBytes

46 
vÆ
 
d_£nd
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

47 
vÆ
 
d_ªcv
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

48 
vÆ
 
d_∑u£
 = 
	`RegInô
(
	`Boﬁ
(
åue
))

49 
vÆ
 
d_Áû
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

50 
vÆ
 
d_wrôe
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

51 
vÆ
 
d_addr
 = 
	`Reg
(
ö
.
haddr
)

52 
vÆ
 
d_size
 = 
	`Reg
(
ö
.
hsize
)

54 
	`whí
 (
out
.
d
.
vÆid
Ë{ 
d_ªcv
 :
	`Boﬁ
(
Ál£
) }

55 
	`whí
 (
out
.
a
.
ªady
Ë{ 
d_£nd
 :
	`Boﬁ
(
Ál£
) }

56 
	`whí
 (
ö
.
hª•
Ë{ 
d_∑u£
 :
	`Boﬁ
(
Ál£
) }

58 
vÆ
 
a_cou¡
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 4))

59 
vÆ
 
a_fú°
 = 
a_cou¡
 ==
	`UI¡
(0)

60 
vÆ
 
d_œ°
 = 
a_fú°


62 
vÆ
 
bur°_sizes
 = 
	`Seq
(1, 1, 4, 4, 8, 8, 16, 16)

63 
vÆ
 
a_bur°_size
 = 
	`Vec
(
bur°_sizes
.
	`m≠
(
bóts
 => 
	`UI¡
(
	`log2Ceû
(bót†* 
bótByãs
))))(
ö
.
hbur°
)

64 
vÆ
 
a_bur°_mask
 = 
	`Vec
(
bur°_sizes
.
	`m≠
(
bóts
 => 
	`UI¡
(bót†* 
bótByãs
 - 1)))(
ö
.
hbur°
)

66 
vÆ
 
a_bur°_ok
 =

67 
ö
.
hå™s
 ==
AHBP¨amëîs
.
TRANS_NONSEQ
 &&

68 
ö
.
hsize
 ==
	`UI¡
(
	`log2Ceû
(
bótByãs
)) &&

69 (
ö
.
haddr
 & 
a_bur°_mask
Ë==
	`UI¡
(0) &&

70 
ö
.
hbur°
 =/
AHBP¨amëîs
.
BURST_INCR
 &&

71 
	`Mux
(
ö
.
hwrôe
,

72 
edgeOut
.
m™agî
.
	`suµ‹tsPutFuŒSa„
(
ö
.
haddr
, 
a_bur°_size
),

73 
edgeOut
.
m™agî
.
	`suµ‹tsGëSa„
 (
ö
.
haddr
, 
a_bur°_size
))

75 
vÆ
 
bót
 = 
	`Tøns„rSizes
(1, 
bótByãs
)

76 
vÆ
 
a_ÀgÆ
 =

77 
	`Mux
(
ö
.
hwrôe
,

78 
edgeOut
.
m™agî
.
	`suµ‹tsPutFuŒSa„
(
ö
.
haddr
, in.
hsize
, 
	`Some
(
bót
)),

79 
edgeOut
.
m™agî
.
	`suµ‹tsGëSa„
 (
ö
.
haddr
, in.
hsize
, 
	`Some
(
bót
)))

81 
vÆ
 
a_ac˚ss
 = 
ö
.
hå™s
 ==
AHBP¨amëîs
.
TRANS_NONSEQ
 || in.hå™†==AHBP¨amëîs.
TRANS_SEQ


82 
vÆ
 
a_ac˚±
 = 
ö
.
hªady
 && in.
h£l
 && 
a_ac˚ss


84 
	`whí
 (
a_ac˚±
) {

85 
a_cou¡
 :a_cou¡ - 
	`UI¡
(1)

86 
	`whí
 ( 
ö
.
hwrôe
Ë{ 
d_£nd
 :
	`Boﬁ
(
åue
) }

87 
	`whí
 (!
ö
.
hwrôe
Ë{ 
d_ªcv
 :
	`Boﬁ
(
åue
) }

88 
	`whí
 (
a_fú°
) {

89 
a_cou¡
 :
	`Mux
(
a_bur°_ok
, 
a_bur°_mask
 >> 
	`log2Ceû
(
bótByãs
), 
	`UI¡
(0))

90 
d_£nd
 :
a_ÀgÆ


91 
d_ªcv
 :
a_ÀgÆ


92 
d_∑u£
 :
	`Boﬁ
(
åue
)

93 
d_wrôe
 :
ö
.
hwrôe


94 
d_addr
 :
ö
.
haddr


95 
d_size
 :
	`Mux
(
a_bur°_ok
, 
a_bur°_size
, 
ö
.
hsize
)

99 
out
.
a
.
vÆid
 :
d_£nd


100 
out
.
a
.
bôs
.
›code
 :
	`Mux
(
d_wrôe
, 
TLMesßges
.
PutFuŒD©a
, TLMesßges.
Gë
)

101 
out
.
a
.
bôs
.
∑øm
 :
	`UI¡
(0)

102 
out
.
a
.
bôs
.
size
 :
d_size


103 
out
.
a
.
bôs
.
sour˚
 :
	`UI¡
(0)

104 
out
.
a
.
bôs
.
addªss
 :
d_addr


105 
out
.
a
.
bôs
.
d©a
 :
ö
.
hwd©a


106 
out
.
a
.
bôs
.
mask
 :
	`MaskGí
(
d_addr
, 
d_size
, 
bótByãs
)

107 
out
.
a
.
bôs
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

109 
out
.
d
.
ªady
 :
d_ªcv


117 
ö
.
hrd©a
 :
out
.
d
.
bôs
.
d©a


120 
vÆ
 
hª•
 = 
d_Áû
 || (
out
.
d
.
vÆid
 && (out.d.
bôs
.
díõd
 || out.d.bôs.
c‹ru±
))

121 
vÆ
 
hªadyout
 = 
	`Mux
(
d_wrôe
, (!
d_£nd
 || 
out
.
a
.
ªady
Ë&& (!
d_œ°
 || !
d_ªcv
 || out.
d
.
vÆid
), out.d.valid || !d_recv)

124 
d_Áû
 :=

125 (
hª•
 && !(
a_fú°
 && 
ö
.
hªady
)) ||

126 (
a_ac˚±
 && !
a_ÀgÆ
)

129 
ö
.
hª•
 :
hªadyout
 && (hª• && 
d_œ°
)

130 
ö
.
hªadyout
 :hªadyouà&& !(
hª•
 && 
d_œ°
 && 
d_∑u£
)

133 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

134 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

135 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

138 
	}
}

140 
obje˘
 
AHBToTL


142 
def
 
≠∂y
()(
im∂icô
 
p
: 
P¨amëîs
) =

144 
vÆ
 
ahb2é
 = 
LazyModuÀ
(
√w
 
AHBToTL
)

145 
ahb2é
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Xbar.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
ahb


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

11 ˛as†
	cAHBF™out
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

12 
vÆ
 
node
 = 
	`AHBNexusNode
(

13 
ma°îFn
 = { 
	`Seq
(
m
) => m },

14 
¶aveFn
 = { 
£q
 => 
	`£q
(0).
	`c›y
(
¶aves
 = seq.
	`Ê©M≠
(
_
.¶aves)Ë
	}
})

16 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

17 i‡(
node
.
edges
.
ö
.
size
 >= 1) {

18 
	`ªquúe
 (
node
.
edges
.
ö
.
size
 == 1, "AHBFanout doesÇot support multiple masters")

19 
	`ªquúe
 (
node
.
edges
.
out
.
size
 > 0, "AHBFanoutÑequiresátÜeast one slave")

22 
	`vÆ
 (
io_out
, 
edgesOut
Ë
node
.
out
.
unzù


23 
vÆ
 
p‹t0
 = 
	`edgesOut
(0).
¶ave


24 
edgesOut
.
f‹óch
 { 
edge
 =>

25 
vÆ
 
p‹t
 = 
edge
.
¶ave


26 
	`ªquúe
 (
p‹t
.
bótByãs
 =
p‹t0
.beatBytes,

27 
s
"${port.slaves.map(_.name)} ${port.beatBytes} vs ${port0.slaves.map(_.name)} ${port0.beatBytes}")

30 
vÆ
 
p‹t_addrs
 = 
edgesOut
.
	`m≠
(
_
.
¶ave
.
¶aves
.m≠(_.
addªss
).
Ê©ãn
)

31 
vÆ
 
routögMask
 = 
	`AddªssDecodî
(
p‹t_addrs
)

32 
vÆ
 
rouã_addrs
 = 
p‹t_addrs
.
	`m≠
(
_
.m≠(_.
	`widí
(~
routögMask
)).
di°ö˘
)

34 
	`vÆ
 (
ö
, 
_
Ë
node
.
	`ö
(0)

35 
vÆ
 
a_£l
 = 
	`Vec
(
rouã_addrs
.
	`m≠
(
£q
 => seq.m≠(
_
.
	`c⁄èös
(
ö
.
haddr
)).
	`ªdu˚
(_ || _)))

36 
vÆ
 
d_£l
 = 
	`Reg
(
a_£l
)

38 
	`whí
 (
ö
.
hªady
Ë{ 
d_£l
 :
a_£l
 }

39 (
a_£l
 
zù
 
io_out
Ë
f‹óch
 { (
£l
, 
out
) =>

40 
out
 :
ö


41 
out
.
h£l
 :
ö
.h£»&& 
£l


44 
ö
.
hªadyout
 :!
	`Mux1H
(
d_£l
, 
io_out
.
	`m≠
(!
_
.hreadyout))

45 
ö
.
hª•
 :
	`Mux1H
(
d_£l
, 
io_out
.
	`m≠
(
_
.hresp))

46 
ö
.
hrd©a
 :
	`Mux1H
(
d_£l
, 
io_out
.
	`m≠
(
_
.hrdata))

48 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/package.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
amba


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
∑ckage
 
obje˘
 
	gahb


10 
ty≥
 
	gAHBOutw¨dNode
 = 
Outw¨dNodeH™dÀ
[
AHBMa°îP‹tP¨amëîs
, 
AHBSœveP‹tP¨amëîs
, 
AHBEdgeP¨amëîs
, 
AHBBundÀ
]

11 
ty≥
 
	gAHBInw¨dNode
 = 
Inw¨dNodeH™dÀ
[
AHBMa°îP‹tP¨amëîs
, 
AHBSœveP‹tP¨amëîs
, 
AHBEdgeP¨amëîs
, 
AHBBundÀ
]

12 
ty≥
 
	gAHBNode
 = 
Sim∂eNodeH™dÀ
[
AHBMa°îP‹tP¨amëîs
, 
AHBSœveP‹tP¨amëîs
, 
AHBEdgeP¨amëîs
, 
AHBBundÀ
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Bundles.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
GíîicP¨amëîizedBundÀ


8 
ab°ø˘
 cœs†
	cAPBBundÀBa£
(
∑øms
: 
APBBundÀP¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

11 ˛as†
	cAPBBundÀ
(
∑øms
: 
APBBundÀP¨amëîs
Ë
exãnds
 
	$APBBundÀBa£
(
∑øms
)

14 
vÆ
 
p£l
 = 
	$Boﬁ
(
OUTPUT
)

15 
vÆ
 
≥«bÀ
 = 
	$Boﬁ
(
OUTPUT
)

18 
vÆ
 
pwrôe
 = 
	$Boﬁ
(
OUTPUT
)

19 
vÆ
 
∑ddr
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
addrBôs
)

20 
vÆ
 
µrŸ
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
¥ŸBôs
)

21 
vÆ
 
pwd©a
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
d©aBôs
)

22 
vÆ
 
p°rb
 = 
	`UI¡
(
OUTPUT
, 
width
 = 
∑øms
.
d©aBôs
/8)

24 
vÆ
 
¥ódy
 = 
	$Boﬁ
(
INPUT
)

25 
vÆ
 
p¶vîr
 = 
	$Boﬁ
(
INPUT
)

26 
vÆ
 
¥d©a
 = 
	$UI¡
(
INPUT
, 
width
 = 
∑øms
.
d©aBôs
)

28 
def
 
	$tõoff
() {

29 
¥ódy
.
dú
 
m©ch
 {

30 
INPUT
 =>

31 
¥ódy
 :
	`Boﬁ
(
Ál£
)

32 
p¶vîr
 :
	`Boﬁ
(
Ál£
)

33 
¥d©a
 :
	`UI¡
(0)

34 
OUTPUT
 =>

35 
pwrôe
 :
	`Boﬁ
(
Ál£
)

36 
∑ddr
 :
	`UI¡
(0)

37 
µrŸ
 :
APBP¨amëîs
.
PROT_DEFAULT


38 
pwd©a
 :
	`UI¡
(0)

39 
p°rb
 :
	`UI¡
(0)

40 
_
 =>

43 
	}
}

45 
obje˘
 
APBBundÀ


47 
def
 
≠∂y
(
∑øms
: 
APBBundÀP¨amëîs
Ë
√w
 
APBBundÀ
(params)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Nodes.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
obje˘
 
APBImp
 
exãnds
 
	gSim∂eNodeImp
[
APBMa°îP‹tP¨amëîs
, 
APBSœveP‹tP¨amëîs
, 
APBEdgeP¨amëîs
, 
APBBundÀ
]

12 
def
 
edge
(
pd
: 
APBMa°îP‹tP¨amëîs
, 
pu
: 
APBSœveP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
APBEdgeP¨amëîs
(pd,Öu,Ö, sourceInfo)

13 
def
 
bundÀ
(
e
: 
APBEdgeP¨amëîs
Ë
APBBundÀ
(e.bundle)

14 
def
 
ªndî
(
e
: 
APBEdgeP¨amëîs
Ë
RídîedEdge
(
cﬁour
 = "#00ccff" , (e.
¶ave
.
bótByãs
 * 8).
toSåög
)

16 
ovîride
 
def
 
mixO
(
pd
: 
APBMa°îP‹tP¨amëîs
, 
node
: 
Outw¨dNode
[APBMa°îP‹tP¨amëîs, 
APBSœveP‹tP¨amëîs
, 
APBBundÀ
]): APBMasterPortParameters =

17 
pd
.
c›y
(
ma°îs
 =Öd.ma°îs.
m≠
 { 
c
 => c.c›y (
nodeP©h
 = 
node
 +: c.nodePath) })

18 
ovîride
 
def
 
mixI
(
pu
: 
APBSœveP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
APBMa°îP‹tP¨amëîs
, APBSœveP‹tP¨amëîs, 
APBBundÀ
]): APBSlavePortParameters =

19 
pu
.
c›y
(
¶aves
 =Öu.¶aves.
m≠
 { 
m
 => m.c›y (
nodeP©h
 = 
node
 +: m.nodePath) })

22 
˛ass
 
	$APBMa°îNode
(
p‹tP¨ams
: 
Seq
[
APBMa°îP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$Sour˚Node
(
APBImp
)(
p‹tP¨ams
)

23 
˛ass
 
	$APBSœveNode
(
p‹tP¨ams
: 
Seq
[
APBSœveP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$SökNode
(
APBImp
)(
p‹tP¨ams
)

24 
˛ass
 
	`APBNexusNode
(

25 
ma°îFn
: 
Seq
[
APBMa°îP‹tP¨amëîs
] => APBMasterPortParameters,

26 
¶aveFn
: 
Seq
[
APBSœveP‹tP¨amëîs
] => APBSlavePortParameters)(

27 
im∂icô
 
vÆName
: 
VÆName
)

28 
exãnds
 
	$NexusNode
(
APBImp
)(
ma°îFn
, 
¶aveFn
)

30 
˛ass
 
	$APBIdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	`IdítôyNode
(
APBImp
)()

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Parameters.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.
max


11 
˛ass
 
APBSœveP¨amëîs
(

12 
addªss
: 
Seq
[
AddªssSë
],

13 
ªsour˚s
: 
Seq
[
Resour˚
] = 
Nû
,

14 
ªgi⁄Ty≥
: 
Regi⁄Ty≥
.
T
 = Regi⁄Ty≥.
GET_EFFECTS
,

15 
execuèbÀ
: 
Boﬁón
 = 
Ál£
,

16 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

17 
suµ‹tsWrôe
: 
Boﬁón
 = 
åue
,

18 
suµ‹tsRód
: 
Boﬁón
 = 
åue
)

20 
addªss
.
f‹óch
 { 
a
 => 
ªquúe
 (a.
föôe
) }

21 
addªss
.
combö©i⁄s
(2).
f‹óch
 { 
Seq
(
x
,
y
Ë=> 
ªquúe
 (!x.
ovîœps
(y)) }

23 
vÆ
 
	g«me
 = 
nodeP©h
.
œ°O±i⁄
.
m≠
(
_
.
œzyModuÀ
.
«me
).
gëOrEl£
("disconnected")

24 
vÆ
 
maxAddªss
 = 
addªss
.
m≠
(
_
.
max
).max

25 
vÆ
 
möAlignmít
 = 
addªss
.
m≠
(
_
.
Æignmít
).
mö


28 
˛ass
 
	$APBSœveP‹tP¨amëîs
(

29 
¶aves
: 
Seq
[
APBSœveP¨amëîs
],

30 
bótByãs
: 
I¡
)

32 
	`ªquúe
 (!
¶aves
.
isEm±y
)

33 
	`ªquúe
 (
	`isPow2
(
bótByãs
))

35 
vÆ
 
maxAddªss
 = 
¶aves
.
	`m≠
(
_
.maxAddªss).
max


38 
¶aves
.
	`combö©i⁄s
(2).
f‹óch
 { 
	`Seq
(
x
,
y
) =>

39 
x
.
addªss
.
f‹óch
 { 
a
 => 
y
.addªss.f‹óch { 
b
 =>

40 
	`ªquúe
 (!
a
.
	`ovîœps
(
b
))

43 
	}
}

45 
˛ass
 
APBMa°îP¨amëîs
(

46 
«me
: 
Såög
,

47 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

49 
˛ass
 
	$APBMa°îP‹tP¨amëîs
(

50 
ma°îs
: 
Seq
[
APBMa°îP¨amëîs
])

52 
˛ass
 
	$APBBundÀP¨amëîs
(

53 
addrBôs
: 
I¡
,

54 
d©aBôs
: 
I¡
)

56 
	`ªquúe
 (
d©aBôs
 >= 8)

57 
	`ªquúe
 (
addrBôs
 >= 1)

58 
	`ªquúe
 (
	`isPow2
(
d©aBôs
))

61 
vÆ
 
¥ŸBôs
 = 
APBP¨amëîs
.protBits

63 
def
 (
x
: 
APBBundÀP¨amëîs
) =

64 
	`APBBundÀP¨amëîs
(

65 
	`max
(
addrBôs
, 
x
.addrBits),

66 
	`max
(
d©aBôs
, 
x
.dataBits))

67 
	}
}

69 
obje˘
 
	gAPBBundÀP¨amëîs


71 
vÆ
 
	gem±yBundÀP¨ams
 = 
APBBundÀP¨amëîs
(
addrBôs
 = 1, 
d©aBôs
 = 8)

72 
def
 (
x
: 
Seq
[
APBBundÀP¨amëîs
]Ëx.
fﬁdLe·
(
em±yBundÀP¨ams
)((x,
	gy
Ë=> x.(
y
))

74 
def
 
≠∂y
(
ma°î
: 
APBMa°îP‹tP¨amëîs
, 
¶ave
: 
APBSœveP‹tP¨amëîs
) =

75 
√w
 
APBBundÀP¨amëîs
(

76 
addrBôs
 = 
log2Up
(
¶ave
.
maxAddªss
+1),

77 
d©aBôs
 = 
¶ave
.
bótByãs
 * 8)

80 
˛ass
 
	$APBEdgeP¨amëîs
(

81 
ma°î
: 
APBMa°îP‹tP¨amëîs
,

82 
¶ave
: 
APBSœveP‹tP¨amëîs
,

83 
∑øms
: 
P¨amëîs
,

84 
sour˚Info
: 
Sour˚Info
)

86 
vÆ
 
bundÀ
 = 
	`APBBundÀP¨amëîs
(
ma°î
, 
¶ave
)

87 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Protocol.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


7 
obje˘
 
	gAPBP¨amëîs


10 
vÆ
 
	g¥ŸBôs
 = 3

12 
def
 
PROT_PRIVILEDGED
 = 
UI¡
(1, 
width
 = 
¥ŸBôs
)

13 
def
 
PROT_NONSECURE
 = 
UI¡
(2, 
width
 = 
¥ŸBôs
)

14 
def
 
PROT_INSTRUCTION
 = 
UI¡
(4, 
width
 = 
¥ŸBôs
)

15 
def
 
PROT_DEFAULT
 = 
PROT_PRIVILEDGED


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/RegisterRouter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.{
	gI¡Sour˚Node
, 
	gI¡Sour˚P‹tSim∂e
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
HëîogíeousBag


11 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

13 
˛ass
 
	$APBRegi°îNode
(
addªss
: 
AddªssSë
, 
c⁄cuºícy
: 
I¡
 = 0, 
bótByãs
: I¡ = 4, 
undefZîo
: 
Boﬁón
 = 
åue
, 
execuèbÀ
: Boﬁó¿
Ál£
)(
im∂icô
 
vÆName
: 
VÆName
)

14 
exãnds
 
	$SökNode
(
APBImp
)(
	`Seq
(
	`APBSœveP‹tP¨amëîs
(

15 
	`Seq
(
	`APBSœveP¨amëîs
(

16 
addªss
 = 
	`Seq
(address),

17 
execuèbÀ
 =Éxecutable,

18 
suµ‹tsWrôe
 = 
åue
,

19 
suµ‹tsRód
 = 
åue
)),

20 
bótByãs
 = beatBytes)))

22 
	`ªquúe
 (
addªss
.
c⁄tiguous
)

26 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*) = {

27 
	`vÆ
 (
≠b
, 
_
Ë
this
.
	`ö
(0)

29 
vÆ
 
ödexBôs
 = 
	`log2Up
((
addªss
.
mask
+1)/
bótByãs
)

30 
vÆ
 
∑øms
 = 
	`RegM≠≥rP¨ams
(
ödexBôs
, 
bótByãs
, 1)

31 
vÆ
 
ö
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`RegM≠≥rI≈ut
(
∑øms
)))

32 
vÆ
 
out
 = 
	`RegM≠≥r
(
bótByãs
, 
c⁄cuºícy
, 
undefZîo
, 
ö
, 
m≠pög
:
_
*)

35 
vÆ
 
èkí
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

36 
	`whí
 (
ö
.
	`fúe
()Ë{ 
èkí
 :
	`Boﬁ
(
åue
) }

37 
	`whí
 (
out
.
	`fúe
()Ë{ 
èkí
 :
	`Boﬁ
(
Ál£
) }

39 
ö
.
bôs
.
ªad
 :!
≠b
.
pwrôe


40 
ö
.
bôs
.
ödex
 :
≠b
.
∑ddr
 >> 
	`log2Ceû
(
bótByãs
)

41 
ö
.
bôs
.
d©a
 :
≠b
.
pwd©a


42 
ö
.
bôs
.
mask
 :
	`Mux
(
≠b
.
pwrôe
,ápb.
p°rb
, 
	`UI¡
((1<<
bótByãs
) - 1))

43 
ö
.
bôs
.
exåa
 :
	`UI¡
(0)

45 
ö
.
vÆid
 :
≠b
.
p£l
 && !
èkí


46 
out
.
ªady
 :
≠b
.
≥«bÀ


48 
≠b
.
¥ódy
 :
out
.
vÆid


49 
≠b
.
p¶vîr
 :
	`Boﬁ
(
Ál£
)

50 
≠b
.
¥d©a
 :
out
.
bôs
.
d©a


52 
	}
}

57 
ab°ø˘
 
˛ass
 
	$APBRegi°îRouãrBa£
(
addªss
: 
AddªssSë
, 
öãºu±s
: 
I¡
, 
c⁄cuºícy
: I¡, 
bótByãs
: I¡, 
undefZîo
: 
Boﬁón
, 
execuèbÀ
: Boﬁón)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


59 
vÆ
 
node
 = 
	`APBRegi°îNode
(
addªss
, 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

60 
vÆ
 
öäode
 = 
	`I¡Sour˚Node
(
	`I¡Sour˚P‹tSim∂e
(
num
 = 
öãºu±s
))

61 
	}
}

63 ˛as†
	cAPBRegBundÀArg
()(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
)

65 ˛as†
	cAPBRegBundÀBa£
(
¨g
: 
APBRegBundÀArg
Ë
exãnds
 
BundÀ


67 
im∂icô
 
vÆ
 
p
 = 
¨g
.p

70 
˛ass
 
APBRegBundÀ
[
P
](
vÆ
 
∑øms
: P, 
¨g
: 
APBRegBundÀArg
Ë
exãnds
 
	$APBRegBundÀBa£
(
¨g
)

72 
˛ass
 
APBRegModuÀ
[
P
, 
B
 <: 
APBRegBundÀBa£
](
vÆ
 
∑øms
: P, 
bundÀBuûdî
: => B, 
rouãr
: 
APBRegi°îRouãrBa£
)

73 
exãnds
 
	$LazyModuÀImp
(
rouãr
Ë
wôh
 
HasRegM≠


75 
vÆ
 
io
 = 
	`IO
(
bundÀBuûdî
)

76 
vÆ
 
öãºu±s
 = i‡(
rouãr
.
öäode
.
out
.
isEm±y
Ë
	`Vec
(0, 
	`Boﬁ
()Ërouãr.öäode.
	`out
(0).
_1


77 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*Ë
rouãr
.
node
.ªgm≠(m≠pög:
_
*)

78 
	}
}

80 
˛ass
 
APBRegi°îRouãr
[
B
 <: 
APBRegBundÀBa£
, 
M
 <: 
LazyModuÀImp
]

81 (
vÆ
 
ba£
: 
BigI¡
, vÆ 
	göãºu±s
: 
I¡
 = 0, vÆ 
	gsize
: BigI¡ = 4096, vÆ 
	gc⁄cuºícy
: I¡ = 0, vÆ 
	gbótByãs
: I¡ = 4, 
	gundefZîo
: 
Boﬁón
 = 
åue
, 
	gexecuèbÀ
: Boﬁó¿
Ál£
)

82 (
bundÀBuûdî
: 
APBRegBundÀArg
 => 
B
)

83 (
moduÀBuûdî
: (=> 
B
, 
	gAPBRegi°îRouãrBa£
Ë=> 
M
)(
im∂icô
 
p
: 
P¨amëîs
)

84 
exãnds
 
APBRegi°îRouãrBa£
(
AddªssSë
(
ba£
, 
size
-1), 
öãºu±s
, 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

86 
ªquúe
 (
isPow2
(
size
))

89 
œzy
 
vÆ
 
	gmoduÀ
 = 
moduÀBuûdî
(
bundÀBuûdî
(
APBRegBundÀArg
()), 
this
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/SRAM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
LFSRNoi£Makî


11 
˛ass
 
	$APBRAM
(

12 
addªss
: 
AddªssSë
,

13 
execuèbÀ
: 
Boﬁón
 = 
åue
,

14 
bótByãs
: 
I¡
 = 4,

15 
devName
: 
O±i⁄
[
Såög
] = 
N⁄e
,

16 
îr‹s
: 
Seq
[
AddªssSë
] = 
Nû
,

17 
fuzzRódy
: 
Boﬁón
 = 
Ál£
,

18 
fuzzEº‹
: 
Boﬁón
 = 
Ál£
)

19 (
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$Dùlom©icSRAM
(
addªss
, 
bótByãs
, 
devName
)

21 
vÆ
 
node
 = 
	`APBSœveNode
(
	`Seq
(
	`APBSœveP‹tP¨amëîs
(

22 
	`Seq
(
	`APBSœveP¨amëîs
(

23 
addªss
 = 
	`Li°
◊ddªssË++ 
îr‹s
,

24 
ªsour˚s
 =Ñesources,

25 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

26 
execuèbÀ
 =Éxecutable,

27 
suµ‹tsRód
 = 
åue
,

28 
suµ‹tsWrôe
 = 
åue
)),

29 
bótByãs
 = beatBytes)))

31 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

32 
	`vÆ
 (
ö
, 
_
Ë
node
.
	`ö
(0)

33 
vÆ
 
mem
 = 
	`makeSögÀP‹ãdByãWrôeSeqMem
(1 << 
mask
.
	`fûãr
(
b
=>b).
size
)

35 
vÆ
 
∑ddr
 = 
	`C©
((
mask
 
	`zù
 (
ö
.∑dd∏>> 
	`log2Ceû
(
bótByãs
)).
toBoﬁs
).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
).
ªvî£
)

36 
vÆ
 
ÀgÆ
 = 
addªss
.
	`c⁄èös
(
ö
.
∑ddr
)

38 
vÆ
 
ªad
 = 
ö
.
p£l
 && !ö.
≥«bÀ
 && !ö.
pwrôe


39 
	`whí
 (
ö
.
p£l
 && !ö.
≥«bÀ
 && in.
pwrôe
 && 
ÀgÆ
) {

40 
mem
.
	`wrôe
(
∑ddr
, 
Vec
.
	`èbuœã
(
bótByãs
Ë{ 
i
 => 
ö
.
	`pwd©a
(8*(i+1)-1, 8*iË}, in.
p°rb
.
toBoﬁs
)

43 
ö
.
¥ódy
 :
	`Boﬁ
(!
fuzzRódy
Ë|| 
	`LFSRNoi£Makî
(1)(0)

44 
ö
.
p¶vîr
 :
	`RegE«bÀ
(!
ÀgÆ
, !ö.
≥«bÀ
Ë|| (
	`Boﬁ
(
fuzzEº‹
Ë&& 
	`LFSRNoi£Makî
(1)(0))

45 
ö
.
¥d©a
 :
mem
.
	`ªadAndHﬁd
(
∑ddr
, 
ªad
).
asUI¡


47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Test.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


11 
˛ass
 
	$RRTe°0
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$APBRegi°îRouãr
(
addªss
, 0, 32, 0, 4)(

12 
√w
 
	`APBRegBundÀ
((), 
_
Ë
wôh
 
RRTe°0BundÀ
)(

13 
√w
 
	`APBRegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°0ModuÀ
)

15 
˛ass
 
	$RRTe°1
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$APBRegi°îRouãr
(
addªss
, 0, 32, 1, 4, 
Ál£
)(

16 
√w
 
	`APBRegBundÀ
((), 
_
Ë
wôh
 
RRTe°1BundÀ
)(

17 
√w
 
	`APBRegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°1ModuÀ
)

19 
˛ass
 
	$APBFuzzBridge
(
aFlow
: 
Boﬁón
, 
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


21 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

22 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("APBFuzzMaster"))

23 
vÆ
 
xb¨
 = 
	`LazyModuÀ
(
√w
 
APBF™out
)

24 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`APBRAM
(
	`AddªssSë
(0x0, 0xff), 
fuzzRódy
 = 
åue
, 
fuzzEº‹
 =Årue))

25 
vÆ
 
gpio
 = 
	`LazyModuÀ
(
√w
 
	`RRTe°0
(0x100))

27 
øm
.
node
 :
xb¨
.node

28 
gpio
.
node
 :
xb¨
.node

29 (
xb¨
.
node


30 :
	`TLToAPB
(
aFlow
)

31 :
	`TLDñayî
(0.2)

32 :
	`TLBuf„r
(
Buf„rP¨ams
.
Êow
)

33 :
	`TLDñayî
(0.2)

34 :
	`TLFøgmíãr
(4, 8)

35 :
modñ
.
node


36 :
fuzz
.
node
)

38 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

39 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

41 
	}
}

43 
˛ass
 
	$APBBridgeTe°
(
aFlow
: 
Boﬁón
, 
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

44 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`APBFuzzBridge
(
aFlow
, 
txns
)).
moduÀ
)

45 
io
.
föished
 :
dut
.io.finished

46 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Xbar.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
≠b


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

11 ˛as†
	cAPBF™out
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

12 
vÆ
 
node
 = 
	`APBNexusNode
(

13 
ma°îFn
 = { 
	`Seq
(
m
) => m },

14 
¶aveFn
 = { 
£q
 => 
	`£q
(0).
	`c›y
(
¶aves
 = seq.
	`Ê©M≠
(
_
.¶aves)Ë
	}
})

16 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

17 i‡(
node
.
edges
.
ö
.
size
 >= 1) {

18 
	`ªquúe
 (
node
.
edges
.
ö
.
size
 == 1, "APBFanout doesÇot support multiple masters")

19 
	`ªquúe
 (
node
.
edges
.
out
.
size
 > 0, "APBFanoutÑequiresátÜeast one slave")

21 
	`vÆ
 (
ö
, 
_
Ë
node
.
	`ö
(0)

24 
	`vÆ
 (
io_out
, 
edgesOut
Ë
node
.
out
.
unzù


25 
vÆ
 
p‹t0
 = 
	`edgesOut
(0).
¶ave


26 
edgesOut
.
f‹óch
 { 
edge
 =>

27 
vÆ
 
p‹t
 = 
edge
.
¶ave


28 
	`ªquúe
 (
p‹t
.
bótByãs
 =
p‹t0
.beatBytes,

29 
s
"${port.slaves.map(_.name)} ${port.beatBytes} vs ${port0.slaves.map(_.name)} ${port0.beatBytes}")

32 
vÆ
 
p‹t_addrs
 = 
edgesOut
.
	`m≠
(
_
.
¶ave
.
¶aves
.m≠(_.
addªss
).
Ê©ãn
)

33 
vÆ
 
routögMask
 = 
	`AddªssDecodî
(
p‹t_addrs
)

34 
vÆ
 
rouã_addrs
 = 
p‹t_addrs
.
	`m≠
(
_
.m≠(_.
	`widí
(~
routögMask
)).
di°ö˘
)

36 
vÆ
 
£l
 = 
	`Vec
(
rouã_addrs
.
	`m≠
(
£q
 => seq.m≠(
_
.
	`c⁄èös
(
ö
.
∑ddr
)).
	`ªdu˚
(_ || _)))

37 (
£l
 
zù
 
io_out
Ë
f‹óch
 { (£l, 
out
) =>

38 
out
 :
ö


39 
out
.
p£l
 :
£l
 && 
ö
.psel

40 
out
.
≥«bÀ
 :
£l
 && 
ö
.penable

43 
ö
.
¥ódy
 :!
	`Mux1H
(
£l
, 
io_out
.
	`m≠
(!
_
.pready))

44 
ö
.
p¶vîr
 :
	`Mux1H
(
£l
, 
io_out
.
	`m≠
(
_
.pslverr))

45 
ö
.
¥d©a
 :
	`Mux1H
(
£l
, 
io_out
.
	`m≠
(
_
.prdata))

47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/package.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
amba


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
∑ckage
 
obje˘
 
	g≠b


10 
ty≥
 
	gAPBOutw¨dNode
 = 
Outw¨dNodeH™dÀ
[
APBMa°îP‹tP¨amëîs
, 
APBSœveP‹tP¨amëîs
, 
APBEdgeP¨amëîs
, 
APBBundÀ
]

11 
ty≥
 
	gAPBInw¨dNode
 = 
Inw¨dNodeH™dÀ
[
APBMa°îP‹tP¨amëîs
, 
APBSœveP‹tP¨amëîs
, 
APBEdgeP¨amëîs
, 
APBBundÀ
]

12 
ty≥
 
	gAPBNode
 = 
Sim∂eNodeH™dÀ
[
APBMa°îP‹tP¨amëîs
, 
APBSœveP‹tP¨amëîs
, 
APBEdgeP¨amëîs
, 
APBBundÀ
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/AsyncCrossing.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
CrossögWøµî


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
˛ass
 
	$AXI4AsyncCrossögSour˚
(
sync
: 
O±i⁄
[
I¡
])(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
def
 
	`this
(
x
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ëthis(
	`Some
(x))

15 
def
 
	`this
()(
im∂icô
 
p
: 
P¨amëîs
Ëthis(
N⁄e
)

17 
vÆ
 
node
 = 
	`AXI4AsyncSour˚Node
(
sync
)

19 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

20 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

21 
vÆ
 
psync
 = 
sync
.
	`gëOrEl£
(
edgeOut
.
¶ave
.
async
.sync)

22 
vÆ
 
∑øms
 = 
edgeOut
.
¶ave
.
async
.
	`c›y
(
sync
 = 
psync
)

23 
out
.
¨
 <> 
	`ToAsyncBundÀ
(
ö
.¨, 
∑øms
)

24 
out
.
aw
 <> 
	`ToAsyncBundÀ
(
ö
.aw, 
∑øms
)

25 
out
. 
w
 <> 
	`ToAsyncBundÀ
(
ö
. w, 
∑øms
)

26 
ö
 .
r
 <> 
	`FromAsyncBundÀ
(
out
.r, 
psync
)

27 
ö
 .
b
 <> 
	`FromAsyncBundÀ
(
out
.b, 
psync
)

30 
	}
}

32 
˛ass
 
AXI4AsyncCrossögSök
(
∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
())(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


34 
vÆ
 
node
 = 
	`AXI4AsyncSökNode
(
∑øms
)

36 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

37 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

38 
out
.
¨
 <> 
	`FromAsyncBundÀ
(
ö
.¨, 
∑øms
.
sync
)

39 
out
.
aw
 <> 
	`FromAsyncBundÀ
(
ö
.aw, 
∑øms
.
sync
)

40 
out
. 
w
 <> 
	`FromAsyncBundÀ
(
ö
. w, 
∑øms
.
sync
)

41 
ö
 .
r
 <> 
	`ToAsyncBundÀ
(
out
.r, 
∑øms
)

42 
ö
 .
b
 <> 
	`ToAsyncBundÀ
(
out
.b, 
∑øms
)

45 
	}
}

47 
obje˘
 
	gAXI4AsyncCrossögSour˚


49 
def
 
≠∂y
()(
im∂icô
 
	gp
: 
P¨amëîs
): 
AXI4AsyncSour˚Node
 =áµly(
N⁄e
)

50 
def
 
≠∂y
(
sync
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4AsyncSour˚Node
 =áµly(
Some
(sync))

51 
def
 
≠∂y
(
sync
: 
O±i⁄
[
I¡
])(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4AsyncSour˚Node
 = {

52 
vÆ
 
axi4asour˚
 = 
LazyModuÀ
(
√w
 
AXI4AsyncCrossögSour˚
(
sync
))

53 
axi4asour˚
.
node


57 
obje˘
 
AXI4AsyncCrossögSök


59 
def
 
≠∂y
(
∑øms
: 
AsyncQueueP¨ams
 = AsyncQueueP¨ams())(
im∂icô
 
p
: 
P¨amëîs
) = {

60 
vÆ
 
axi4asök
 = 
LazyModuÀ
(
√w
 
AXI4AsyncCrossögSök
(
∑øms
))

61 
axi4asök
.
node


65 @
dïªˇãd
("AXI4AsyncCrossing is fragile. Use AXI4AsyncCrossingSourceánd AXI4AsyncCrossingSink", "rocket-chip 1.2")

66 
˛ass
 
AXI4AsyncCrossög
(
∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
())(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


68 
vÆ
 
sour˚
 = 
	`LazyModuÀ
(
√w
 
	`AXI4AsyncCrossögSour˚
())

69 
vÆ
 
sök
 = 
	`LazyModuÀ
(
√w
 
	`AXI4AsyncCrossögSök
(
∑øms
))

70 
vÆ
 
node
 = 
	`NodeH™dÀ
(
sour˚
.node, 
sök
.node)

72 
sök
.
node
 :
sour˚
.node

74 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

75 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

76 
vÆ
 
ö_˛ock
 = 
	`Clock
(
INPUT
)

77 
vÆ
 
ö_ª£t
 = 
	`Boﬁ
(
INPUT
)

78 
vÆ
 
out_˛ock
 = 
	`Clock
(
INPUT
)

79 
vÆ
 
out_ª£t
 = 
	`Boﬁ
(
INPUT
)

82 
sour˚
.
moduÀ
.
˛ock
 :
io
.
ö_˛ock


83 
sour˚
.
moduÀ
.
ª£t
 :
io
.
ö_ª£t


84 
sök
.
moduÀ
.
˛ock
 :
io
.
out_˛ock


85 
sök
.
moduÀ
.
ª£t
 :
io
.
out_ª£t


87 
	}
}

90 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


92 ˛as†
	cAXI4RAMAsyncCrossög
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

93 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AsyncCrossing"))

94 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

95 
vÆ
 
tﬂxi
 = 
	$LazyModuÀ
(
√w
 
TLToAXI4
)

96 
vÆ
 
i¶™d
 = 
	`LazyModuÀ
(
√w
 
	`CrossögWøµî
(
	$Asynchr⁄ousCrossög
()))

97 
vÆ
 
øm
 = 
i¶™d
 { 
	`LazyModuÀ
(
√w
 
	`AXI4RAM
(
	`AddªssSë
(0x0, 0x3ff))) }

99 
modñ
.
node
 :
fuzz
.node

100 
tﬂxi
.
node
 :
modñ
.node

101 
i¶™d
.
	$¸ossAXI4In
(
øm
.
node
Ë:
tﬂxi
.node

103 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

104 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

107 
vÆ
 
˛ocks
 = 
	`ModuÀ
(
√w
 
	`Pow2ClockDividî
(2))

108 
i¶™d
.
moduÀ
.
˛ock
 :
˛ocks
.
io
.
˛ock_out


109 
	}
}

112 
˛ass
 
	$AXI4RAMAsyncCrossögTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

113 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AXI4RAMAsyncCrossög
(
txns
)).
moduÀ
)

114 
io
.
föished
 :
dut
.io.finished

115 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Buffer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
IºevoˇbÀIO


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

12 
˛ass
 
	$AXI4Buf„r
(

13 
aw
: 
Buf„rP¨ams
,

14 
w
: 
Buf„rP¨ams
,

15 
b
: 
Buf„rP¨ams
,

16 
¨
: 
Buf„rP¨ams
,

17 
r
: 
Buf„rP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


19 
def
 
	`this
(
aw
: 
Buf„rP¨ams
, 
br
: Buf„rP¨ams)(
im∂icô
 
p
: 
P¨amëîs
) =Åhis(aw,áw, br,áw, br)

20 
def
 
	`this
(
x
: 
Buf„rP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
) =Åhis(x, x)

21 
def
 
	`this
()(
im∂icô
 
p
: 
P¨amëîs
Ëthis(
Buf„rP¨ams
.)

23 
vÆ
 
node
 = 
	`AXI4Ad≠ãrNode
(

24 
ma°îFn
 = { 
p
 =>Ö },

25 
¶aveFn
 = { 
p
 =>Ö.
	`c›y
(
möL©ícy
 =Ö.möL©ícy + 
	`mö
(
aw
.
œãncy
,
¨
.œãncyË+ mö(
r
.œãncy,
b
.latency)) })

27 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

28 
def
 
buf„r
[
T
 <: 
D©a
](
c⁄fig
: 
Buf„rP¨ams
, 
d©a
: 
IºevoˇbÀIO
[T]): IrrevocableIO[T] = {

29 i‡(
c⁄fig
.
isDeföed
) {

30 
Queue
.
	`úªvoˇbÀ
(
d©a
, 
c⁄fig
.
dïth
, 
pùe
=c⁄fig.pùe, 
Êow
=config.flow)

32 
d©a


36 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

37 
out
.
aw
 <> 
	`buf„r
◊w, 
ö
 .aw)

38 
out
.
w
 <> 
	`buf„r
(w, 
ö
 .w)

39 
ö
 .
b
 <> 
	`buf„r
(b, 
out
.b)

40 
out
.
¨
 <> 
	`buf„r
◊r, 
ö
 .ar)

41 
ö
 .
r
 <> 
	`buf„r
‘, 
out
.r)

44 
	}
}

46 
obje˘
 
	gAXI4Buf„r


48 
def
 
≠∂y
(Ë(
im∂icô
 
	gp
: 
P¨amëîs
): 
AXI4Node
 =áµly(
Buf„rP¨ams
.)

49 
def
 
≠∂y
(
z
: 
Buf„rP¨ams
Ë(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =ápply(z, z)

50 
def
 
≠∂y
(
aw
: 
Buf„rP¨ams
, 
br
: Buf„rP¨ams)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =ápply(aw,áw, br,áw, br)

51 
def
 
≠∂y
(

52 
aw
: 
Buf„rP¨ams
,

53 
w
: 
Buf„rP¨ams
,

54 
b
: 
Buf„rP¨ams
,

55 
¨
: 
Buf„rP¨ams
,

56 
r
: 
Buf„rP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =

58 
vÆ
 
axi4buf
 = 
LazyModuÀ
(
√w
 
AXI4Buf„r
(
aw
, 
w
, 
b
, 
¨
, 
r
))

59 
	gaxi4buf
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Bundles.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
IºevoˇbÀ


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
ab°ø˘
 cœs†
	cAXI4BundÀBa£
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

11 
ab°ø˘
 cœs†
	cAXI4BundÀA
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀBa£
(
∑øms
)

13 
vÆ
 
id
 = 
	$UI¡
(
width
 = 
∑øms
.
idBôs
)

14 
vÆ
 
addr
 = 
	$UI¡
(
width
 = 
∑øms
.
addrBôs
)

15 
vÆ
 
Àn
 = 
	$UI¡
(
width
 = 
∑øms
.
ÀnBôs
)

16 
vÆ
 
size
 = 
	$UI¡
(
width
 = 
∑øms
.
sizeBôs
)

17 
vÆ
 
bur°
 = 
	$UI¡
(
width
 = 
∑øms
.
bur°Bôs
)

18 
vÆ
 
lock
 = 
	$UI¡
(
width
 = 
∑øms
.
lockBôs
)

19 
vÆ
 
ˇche
 = 
	$UI¡
(
width
 = 
∑øms
.
ˇcheBôs
)

20 
vÆ
 
¥Ÿ
 = 
	$UI¡
(
width
 = 
∑øms
.
¥ŸBôs
)

21 
vÆ
 
qos
 = 
	$UI¡
(
width
 = 
∑øms
.
qosBôs
)

22 
vÆ
 
u£r
 = i‡(
∑øms
.
u£rBôs
 > 0Ë
	`Some
(
	$UI¡
(
width
 = 
∑øms
.
u£rBôs
)Ë
N⁄e


26 
def
 
	`byãs1
(
x
:
I¡
=0) = {

27 
vÆ
 
maxShi·
 = 1 << 
∑øms
.
sizeBôs


28 
vÆ
 
èû
 = 
	`UI¡
((
	`BigI¡
(1Ë<< 
maxShi·
) - 1)

29 (
	`C©
(
Àn
, 
èû
Ë<< 
size
Ë>> 
maxShi·


31 
	}
}

34 ˛as†
	cAXI4BundÀARW
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀA
(
∑øms
)

36 
vÆ
 
wí
 = 
	`Boﬁ
()

39 ˛as†
	cAXI4BundÀAW
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀA
(
∑øms
)

40 ˛as†
	cAXI4BundÀAR
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀA
(
∑øms
)

42 ˛as†
	cAXI4BundÀW
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀBa£
(
∑øms
)

45 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
d©aBôs
)

46 
vÆ
 
°rb
 = 
	`UI¡
(
width
 = 
∑øms
.
d©aBôs
/8)

47 
vÆ
 
œ°
 = 
	$Boﬁ
()

48 
vÆ
 
c‹ru±
 = i‡(
∑øms
.
wc‹ru±
Ë
	`Some
(
	$Boﬁ
()Ë
N⁄e


51 ˛as†
	cAXI4BundÀR
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀBa£
(
∑øms
)

53 
vÆ
 
id
 = 
	$UI¡
(
width
 = 
∑øms
.
idBôs
)

54 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
d©aBôs
)

55 
vÆ
 
ª•
 = 
	$UI¡
(
width
 = 
∑øms
.
ª•Bôs
)

56 
vÆ
 
u£r
 = i‡(
∑øms
.
u£rBôs
 > 0Ë
	`Some
(
	$UI¡
(
width
 = 
∑øms
.
u£rBôs
)Ë
N⁄e


57 
vÆ
 
œ°
 = 
	`Boﬁ
()

60 ˛as†
	cAXI4BundÀB
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀBa£
(
∑øms
)

62 
vÆ
 
id
 = 
	$UI¡
(
width
 = 
∑øms
.
idBôs
)

63 
vÆ
 
ª•
 = 
	$UI¡
(
width
 = 
∑øms
.
ª•Bôs
)

64 
vÆ
 
u£r
 = i‡(
∑øms
.
u£rBôs
 > 0Ë
	`Some
(
	$UI¡
(
width
 = 
∑øms
.
u£rBôs
)Ë
N⁄e


67 ˛as†
	cAXI4BundÀ
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀBa£
(
∑øms
)

69 
vÆ
 
aw
 = 
	`IºevoˇbÀ
(
√w
 
	$AXI4BundÀAW
(
∑øms
))

70 
vÆ
 
w
 = 
	`IºevoˇbÀ
(
√w
 
	$AXI4BundÀW
 (
∑øms
))

71 
vÆ
 
b
 = 
	`IºevoˇbÀ
(
√w
 
	`AXI4BundÀB
 (
∑øms
)).
Êù


72 
vÆ
 
¨
 = 
	`IºevoˇbÀ
(
√w
 
	$AXI4BundÀAR
(
∑øms
))

73 
vÆ
 
r
 = 
	`IºevoˇbÀ
(
√w
 
	`AXI4BundÀR
 (
∑øms
)).
Êù


75 
def
 
	$tõoff
() {

76 
¨
.
ªady
.
dú
 
m©ch
 {

77 
INPUT
 =>

78 
¨
.
ªady
 :
	`Boﬁ
(
Ál£
)

79 
aw
.
ªady
 :
	`Boﬁ
(
Ál£
)

80 
w
.
ªady
 :
	`Boﬁ
(
Ál£
)

81 
r
.
vÆid
 :
	`Boﬁ
(
Ál£
)

82 
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

83 
OUTPUT
 =>

84 
¨
.
vÆid
 :
	`Boﬁ
(
Ál£
)

85 
aw
.
vÆid
 :
	`Boﬁ
(
Ál£
)

86 
w
.
vÆid
 :
	`Boﬁ
(
Ál£
)

87 
r
.
ªady
 :
	`Boﬁ
(
Ál£
)

88 
b
.
ªady
 :
	`Boﬁ
(
Ál£
)

89 
_
 =>

92 
	}
}

94 
obje˘
 
AXI4BundÀ


96 
def
 
≠∂y
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
√w
 
AXI4BundÀ
(params)

99 ˛as†
	cAXI4AsyncBundÀBa£
(
∑øms
: 
AXI4AsyncBundÀP¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

101 ˛as†
	cAXI4AsyncBundÀ
(
∑øms
: 
AXI4AsyncBundÀP¨amëîs
Ë
exãnds
 
	$AXI4AsyncBundÀBa£
(
∑øms
)

103 
vÆ
 
aw
 = 
√w
 
	`AsyncBundÀ
“ew 
	`AXI4BundÀAW
(
∑øms
.
ba£
),Ö¨ams.
async
)

104 
vÆ
 
w
 = 
√w
 
	`AsyncBundÀ
“ew 
	`AXI4BundÀW
 (
∑øms
.
ba£
),Ö¨ams.
async
)

105 
vÆ
 
b
 = 
√w
 
	`AsyncBundÀ
“ew 
	`AXI4BundÀB
 (
∑øms
.
ba£
),Ö¨ams.
async
).
Êù


106 
vÆ
 
¨
 = 
√w
 
	`AsyncBundÀ
“ew 
	`AXI4BundÀAR
(
∑øms
.
ba£
),Ö¨ams.
async
)

107 
vÆ
 
r
 = 
√w
 
	`AsyncBundÀ
“ew 
	`AXI4BundÀR
 (
∑øms
.
ba£
),Ö¨ams.
async
).
Êù


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/CrossingHelper.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
˛ass
 
	$AXI4Inw¨dCrossögHñ≥r
(
«me
: 
Såög
, 
sc›e
: 
LazySc›e
, 
node
: 
AXI4Inw¨dNode
) {

9 
def
 
	`≠∂y
(
xög
: 
ClockCrossögTy≥
 = 
NoCrossög
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Inw¨dNode
 = {

10 
xög
 
m©ch
 {

11 
x
: 
Asynchr⁄ousCrossög
 =>

12 
node
 :*=* 
sc›e
 { 
	`AXI4AsyncCrossögSök
(
x
.
asSökP¨ams
Ë:*=* 
	`AXI4AsyncNameNode
(
«me
Ë} :*=* AXI4AsyncNameNode“ameË:*=* 
	`AXI4AsyncCrossögSour˚
(x.
sour˚Sync
)

13 
	`R©i⁄ÆCrossög
(
dúe˘i⁄
) =>

14 
throw
 
√w
 
	`IŒegÆArgumítEx˚±i⁄
("AXI4 Rational crossing unimplemented")

15 
	`Synchr⁄ousCrossög
(
buf„r
) =>

16 
node
 :*=* 
sc›e
 { 
	`AXI4Buf„r
(
buf„r
Ë:*=* 
	`AXI4NameNode
(
«me
) } :*=* AXI4NameNode(name)

19 
	}
}

21 
˛ass
 
	$AXI4Outw¨dCrossögHñ≥r
(
«me
: 
Såög
, 
sc›e
: 
LazySc›e
, 
node
: 
AXI4Outw¨dNode
) {

22 
def
 
	`≠∂y
(
xög
: 
ClockCrossögTy≥
 = 
NoCrossög
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Outw¨dNode
 = {

23 
xög
 
m©ch
 {

24 
x
: 
Asynchr⁄ousCrossög
 =>

25 
	`AXI4AsyncCrossögSök
(
x
.
asSökP¨ams
Ë:*=* 
	`AXI4AsyncNameNode
(
«me
Ë:*=* 
sc›e
 { AXI4AsyncNameNode“ameË:*=* 
	`AXI4AsyncCrossögSour˚
(x.
sour˚Sync
Ë} :*=* 
node


26 
	`R©i⁄ÆCrossög
(
dúe˘i⁄
) =>

27 
throw
 
√w
 
	`IŒegÆArgumítEx˚±i⁄
("AXI4 Rational crossing unimplemented")

28 
	`Synchr⁄ousCrossög
(
buf„r
) =>

29 
	`AXI4NameNode
(
«me
Ë:*=* 
sc›e
 { AXI4NameNode“ameË:*=* 
	`AXI4Buf„r
(
buf„r
Ë} :*=* 
node


32 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Deinterleaver.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
IºevoˇbÀIO


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gÀ·OR
, 
	grightOR
, 
	gUI¡ToOH1
, 
	gOH1ToOH
}

10 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

12 ˛as†
	cAXI4Deöãæóvî
(
maxRódByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
	`ªquúe
 (
maxRódByãs
 >1 && 
	$isPow2
(
maxRódByãs
))

16 
vÆ
 
node
 = 
	`AXI4Ad≠ãrNode
(

17 
ma°îFn
 = { 
mp
 => mp },

18 
¶aveFn
 = { 
•
 => sp.
	`c›y
(
¶aves
 = sp.¶aves.
	`m≠
(
s
 => s.copy(

19 
suµ‹tsRód
 = 
s
.suµ‹tsRód.
	`öãr£˘
(
	`Tøns„rSizes
(1, 
maxRódByãs
)),

20 
öãæóvedId
 = 
	`Some
(0))))

21 
	}
})

23 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

24 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

25 
vÆ
 
ídId
 = 
edgeOut
.
ma°î
.endId

26 
vÆ
 
bótByãs
 = 
edgeOut
.
¶ave
.beatBytes

27 
vÆ
 
bóts
 = (
maxRódByãs
+
bótByãs
-1) / beatBytes

30 
out
.
¨
 <> 
ö
.ar

31 
out
.
aw
 <> 
ö
.aw

32 
out
.
w
 <> 
ö
.w

33 
ö
.
b
 <> 
out
.b

35 i‡(
bóts
 <= 1) {

37 
ö
.
r
 <> 
out
.r

40 
vÆ
 
qs
 = 
Seq
.
	`èbuœã
(
ídId
Ë{ 
i
 =>

41 
vÆ
 
dïth
 = 
edgeOut
.
ma°î
.
ma°îs
.
	`föd
(
_
.
id
.
	`c⁄èös
(
i
)).
	`Ê©M≠
(_.
maxFlight
).
	`gëOrEl£
(0)

42 i‡(
dïth
 > 0) {

43 
	`ModuÀ
(
√w
 
	`Queue
(
out
.
r
.
bôs
.
˛⁄eTy≥
, 
bóts
)).
io


45 
	`Wúe
(
√w
 
	`QueueIO
(
out
.
r
.
bôs
.
˛⁄eTy≥
, 
bóts
))

50 
vÆ
 
locked
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

51 
vÆ
 
deq_id
 = 
	`Reg
(
	`UI¡
(
width
=
	`log2Up
(
ídId
)))

52 
vÆ
 
íq_id
 = 
out
.
r
.
bôs
.
id


53 
vÆ
 
deq_OH
 = 
	`UI¡ToOH
(
deq_id
, 
ídId
)

54 
vÆ
 
íq_OH
 = 
	`UI¡ToOH
(
íq_id
, 
ídId
)

57 
vÆ
 
≥ndög
 = 
	`C©
(
Seq
.
	`èbuœã
(
ídId
Ë{ 
i
 =>

58 
vÆ
 
dïth
 = 
edgeOut
.
ma°î
.
ma°îs
.
	`föd
(
_
.
id
.
	`c⁄èös
(
i
)).
	`Ê©M≠
(_.
maxFlight
).
	`gëOrEl£
(0)

59 i‡(
dïth
 == 0) {

60 
	`Boﬁ
(
Ál£
)

62 
vÆ
 
cou¡
 = 
	`RegInô
(
	`UI¡
(0, 
width
=
	`log2Ceû
(
bóts
+1)))

63 
vÆ
 
√xt
 = 
	`Wúe
(
cou¡
)

64 
vÆ
 
öc
 = 
	`íq_OH
(
i
Ë&& 
out
.
r
.
	`fúe
(Ë&& out.r.
bôs
.
œ°


65 
vÆ
 
dec
 = 
	`deq_OH
(
i
Ë&& 
ö
.
r
.
	`fúe
(Ë&& in.r.
bôs
.
œ°


66 
√xt
 :
cou¡
 + 
öc
.
asUI¡
 - 
dec
.asUInt

67 
cou¡
 :
√xt


69 
	`as£π
 (!
dec
 || 
cou¡
 =/
	`UI¡
(0))

70 
	`as£π
 (!
öc
 || 
cou¡
 =/
	`UI¡
(
bóts
))

71 
√xt
 =/
	`UI¡
(0)

73 }.
ªvî£
)

76 
vÆ
 
wö√r
 = 
≥ndög
 & ~(
	`À·OR
(pending) << 1)

77 
	`whí
 (!
locked
 || (
ö
.
r
.
	`fúe
(Ë&& in.r.
bôs
.
œ°
)) {

78 
locked
 :
≥ndög
.
‹R


79 
deq_id
 :
	`OHToUI¡
(
wö√r
)

83 
ö
.
r
.
vÆid
 :
locked


84 
ö
.
r
.
bôs
 :
	`Vec
(
qs
.
	`m≠
(
_
.
deq
.bôs))(
deq_id
)

85 (
deq_OH
.
toBoﬁs
 
zù
 
qs
Ë
f‹óch
 { (
s
, 
q
) =>

86 
q
.
deq
.
ªady
 :
s
 && 
ö
.
r
.
	`fúe
()

90 
out
.
r
.
ªady
 :
	`Vec
(
qs
.
	`m≠
(
_
.
íq
.ªady))(
íq_id
)

91 (
íq_OH
.
toBoﬁs
 
zù
 
qs
Ë
f‹óch
 { (
s
, 
q
) =>

92 
q
.
íq
.
vÆid
 :
s
 && 
out
.
r
.valid

93 
q
.
íq
.
bôs
 :
out
.
r
.bits

97 
	}
}

100 
obje˘
 
AXI4Deöãæóvî


102 
def
 
≠∂y
(
maxRódByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =

104 
vÆ
 
axi4deöt
 = 
LazyModuÀ
(
√w
 
AXI4Deöãæóvî
(
maxRódByãs
))

105 
axi4deöt
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Delayer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
IºevoˇbÀIO


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
LFSRNoi£Makî


12 ˛as†
	cAXI4Dñayî
(
q
: 
DoubÀ
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
node
 = 
	$AXI4Ad≠ãrNode
()

15 
	`ªquúe
 (0.0 <
q
 && q < 1)

17 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

18 
def
 
„ed
[
T
 <: 
D©a
](
sök
: 
IºevoˇbÀIO
[T], 
sour˚
: IºevoˇbÀIO[T], 
noi£
: T) {

20 
vÆ
 
hﬁd
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

21 
	`whí
 (
sök
.
vÆid
Ë{ 
hﬁd
 :
	`Boﬁ
(
åue
) }

22 
	`whí
 (
sök
.
	`fúe
()Ë{ 
hﬁd
 :
	`Boﬁ
(
Ál£
) }

24 
vÆ
 
Ælow
 = 
hﬁd
 || 
	`UI¡
((
q
 * 65535.0).
toI¡
Ë<
	`LFSRNoi£Makî
(16, 
sour˚
.
vÆid
)

25 
sök
.
vÆid
 :
sour˚
.vÆid && 
Ælow


26 
sour˚
.
ªady
 :
sök
.ªady && 
Ælow


27 
sök
.
bôs
 :
sour˚
.bits

28 
	`whí
 (!
sök
.
vÆid
Ë{ sök.
bôs
 :
noi£
 }

31 
def
 
™oi£
[
T
 <: 
AXI4BundÀA
](
bôs
: T) {

32 
bôs
.
id
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
idBôs
)

33 
bôs
.
addr
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
addrBôs
)

34 
bôs
.
Àn
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
ÀnBôs
)

35 
bôs
.
size
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
sizeBôs
)

36 
bôs
.
bur°
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
bur°Bôs
)

37 
bôs
.
lock
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
lockBôs
)

38 
bôs
.
ˇche
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
ˇcheBôs
)

39 
bôs
.
¥Ÿ
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
¥ŸBôs
)

40 
bôs
.
qos
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
qosBôs
)

41 i‡(
bôs
.
∑øms
.
u£rBôs
 > 0)

42 
bôs
.
u£r
.
gë
 :
	`LFSRNoi£Makî
(bôs.
∑øms
.
u£rBôs
)

45 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
_
), (out, _)) =>

46 
vÆ
 
¨noi£
 = 
	`Wúe
(
ö
.
¨
.
bôs
)

47 
vÆ
 
awnoi£
 = 
	`Wúe
(
ö
.
aw
.
bôs
)

48 
vÆ
 
wnoi£
 = 
	`Wúe
(
ö
.
w
 .
bôs
)

49 
vÆ
 
∫oi£
 = 
	`Wúe
(
ö
.
r
 .
bôs
)

50 
vÆ
 
bnoi£
 = 
	`Wúe
(
ö
.
b
 .
bôs
)

52 
	`™oi£
(
¨noi£
)

53 
	`™oi£
(
awnoi£
)

55 
wnoi£
.
d©a
 :
	`LFSRNoi£Makî
(wnoi£.
∑øms
.
d©aBôs
)

56 
wnoi£
.
°rb
 :
	`LFSRNoi£Makî
(wnoi£.
∑øms
.
d©aBôs
/8)

57 
wnoi£
.
œ°
 :
	`LFSRNoi£Makî
(1)(0)

59 
∫oi£
.
id
 :
	`LFSRNoi£Makî
‘noi£.
∑øms
.
idBôs
)

60 
∫oi£
.
d©a
 :
	`LFSRNoi£Makî
‘noi£.
∑øms
.
d©aBôs
)

61 
∫oi£
.
ª•
 :
	`LFSRNoi£Makî
‘noi£.
∑øms
.
ª•Bôs
)

62 
∫oi£
.
œ°
 :
	`LFSRNoi£Makî
(1)(0)

63 i‡(
∫oi£
.
∑øms
.
u£rBôs
 > 0)

64 
∫oi£
.
u£r
.
gë
 :
	`LFSRNoi£Makî
‘noi£.
∑øms
.
u£rBôs
)

66 
bnoi£
.
id
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
idBôs
)

67 
bnoi£
.
ª•
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
ª•Bôs
)

68 i‡(
bnoi£
.
∑øms
.
u£rBôs
 > 0)

69 
bnoi£
.
u£r
.
gë
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
u£rBôs
)

71 
	`„ed
(
out
.
¨
, 
ö
.¨, 
¨noi£
)

72 
	`„ed
(
out
.
aw
, 
ö
.aw, 
awnoi£
)

73 
	`„ed
(
out
.
w
, 
ö
.w, 
wnoi£
)

74 
	`„ed
(
ö
.
b
, 
out
.b, 
bnoi£
)

75 
	`„ed
(
ö
.
r
, 
out
.r, 
∫oi£
)

78 
	}
}

80 
obje˘
 
	gAXI4Dñayî


82 
def
 
≠∂y
(
q
: 
DoubÀ
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =

84 
vÆ
 
axi4dñay
 = 
LazyModuÀ
(
√w
 
AXI4Dñayî
(
q
))

85 
axi4dñay
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Filter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
˛ass
 
AXI4Fûãr
(

10 
Sfûãr
: 
AXI4SœveP¨amëîs
 => 
O±i⁄
[AXI4SœveP¨amëîs] = 
AXI4Fûãr
.
Sidítôy
,

11 
Mfûãr
: 
AXI4Ma°îP¨amëîs
 => 
O±i⁄
[AXI4Ma°îP¨amëîs] = 
AXI4Fûãr
.
Midítôy


12 )(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
node
 = 
AXI4Ad≠ãrNode
(

15 
¶aveFn
 = { 
•
 => sp.
c›y
(
¶aves
 = sp.¶aves.
Ê©M≠
 { 
s
 =>

16 
vÆ
 
out
 = 
Sfûãr
(
s
)

17 
out
.
f‹óch
 { 
o
 =>

18 
o
.
addªss
.
f‹óch
 { 
a
 => 
ªquúe
 (
s
.addªss.
m≠
(
_
.
c⁄èös
◊)).
ªdu˚
(_||_)) }

19 
ªquúe
 (
o
.
ªgi⁄Ty≥
 <
s
.regionType)

21 
ªquúe
 (
s
.
suµ‹tsWrôe
.
c⁄èös
(
o
.supportsWrite))

22 
ªquúe
 (
s
.
suµ‹tsRód
 .
c⁄èös
(
o
.supportsRead))

23 
ªquúe
 (!
o
.
öãæóvedId
.
isDeföed
 || 
s
.interleavedId == o.interleavedId)

25 
out


27 
ma°îFn
 = { 
mp
 => mp.
c›y
(
ma°îs
 = mp.ma°îs.
Ê©M≠
 { 
m
 =>

28 
vÆ
 
out
 = 
Mfûãr
(
m
)

29 
out
.
f‹óch
 { 
o
 => 
ªquúe
 (
m
.
id
.
c⁄èös
(o.id)) }

30 
out


33 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

34 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

35 
out
 <> 
ö


40 
obje˘
 
	gAXI4Fûãr


42 
def
 
	gMidítôy
: 
AXI4Ma°îP¨amëîs
 => 
O±i⁄
[AXI4Ma°îP¨amëîs] = { 
m
 => 
Some
(m) }

43 
def
 
Sidítôy
: 
AXI4SœveP¨amëîs
 => 
O±i⁄
[AXI4SœveP¨amëîs] = { 
s
 => 
Some
(s) }

44 
def
 
Smask
(
£À˘
: 
AddªssSë
): 
AXI4SœveP¨amëîs
 => 
O±i⁄
[AXI4SœveP¨amëîs] = { 
s
 =>

45 
vÆ
 
fûãªd
 = 
s
.
addªss
.
m≠
(
_
.
öãr£˘
(
£À˘
)).
Ê©ãn


46 
vÆ
 
Æignmít
 = 
£À˘
.alignment

47 
vÆ
 
maxTøns„r
 = 1 << 30

48 
vÆ
 
ˇpTøns„r
 = i‡(
Æignmít
 =0 ||álignmíà> 
maxTøns„r
ËmaxTøns„∏Æignmít.
toI¡


49 
vÆ
 
ˇp
 = 
Tøns„rSizes
(1, 
ˇpTøns„r
)

50 i‡(
	gfûãªd
.
	gisEm±y
Ë{ 
	gN⁄e
 } {

51 
Some
(
s
.
c›y
(

52 
addªss
 = 
fûãªd
,

53 
suµ‹tsWrôe
 = 
s
.suµ‹tsWrôe.
öãr£˘
(
ˇp
),

54 
suµ‹tsRód
 = 
s
.suµ‹tsRód .
öãr£˘
(
ˇp
)))

58 
def
 
≠∂y
(

59 
Sfûãr
: 
AXI4SœveP¨amëîs
 => 
O±i⁄
[AXI4SœveP¨amëîs] = 
AXI4Fûãr
.
Sidítôy
,

60 
Mfûãr
: 
AXI4Ma°îP¨amëîs
 => 
O±i⁄
[AXI4Ma°îP¨amëîs] = 
AXI4Fûãr
.
Midítôy


61 )(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =

63 
vÆ
 
axi4fût
 = 
LazyModuÀ
(
√w
 
AXI4Fûãr
(
Sfûãr
, 
Mfûãr
))

64 
	gaxi4fût
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Fragmenter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
IºevoˇbÀIO


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gÀ·OR
, 
	grightOR
, 
	gUI¡ToOH1
, 
	gOH1ToOH
}

10 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

12 ˛as†
	cAXI4Føgmíãr
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
maxBóts
 = 1 << 
AXI4P¨amëîs
.
ÀnBôs


15 
def
 
	`ex∑ndTøns„r
(
x
: 
Tøns„rSizes
, 
bótByãs
: 
I¡
, 
Æignmít
: 
BigI¡
) =

16 i‡(!
x
Ëx 
	`Tøns„rSizes
(x.
mö
, 
Æignmít
.
	`mö
(
maxBóts
*
bótByãs
).
ötVÆue
)

17 
def
 
	`m≠Sœve
(
s
: 
AXI4SœveP¨amëîs
, 
bótByãs
: 
I¡
Ës.
	`c›y
(

18 
suµ‹tsWrôe
 = 
	`ex∑ndTøns„r
(
s
.suµ‹tsWrôe, 
bótByãs
, s.
möAlignmít
),

19 
suµ‹tsRód
 = 
	`ex∑ndTøns„r
(
s
.suµ‹tsRód, 
bótByãs
, s.
möAlignmít
),

20 
öãæóvedId
 = 
N⁄e
)

21 
def
 
	`m≠Ma°î
(
m
: 
AXI4Ma°îP¨amëîs
Ëm.
	$c›y
(
Æig√d
 = 
åue
)

23 
vÆ
 
node
 = 
	`AXI4Ad≠ãrNode
(

24 
ma°îFn
 = { 
mp
 => mp.
	`c›y
(
ma°îs
 = mp.ma°îs.
	`m≠
(
m
 => 
	`m≠Ma°î
(m)), 
u£rBôs
 = mp.userBits + 1) },

25 
¶aveFn
 = { 
•
 => sp.
	`c›y
(
¶aves
 = sp.¶ave†.
	`m≠
(
s
 => 
	`m≠Sœve
(s, sp.
bótByãs
))Ë
	}
})

27 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

28 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

29 
vÆ
 
¶ave
 = 
edgeOut
.slave

30 
vÆ
 
¶aves
 = 
¶ave
.slaves

31 
vÆ
 
bótByãs
 = 
¶ave
.beatBytes

32 
vÆ
 
lgByãs
 = 
	`log2Ceû
(
bótByãs
)

33 
vÆ
 
ma°î
 = 
edgeIn
.master

34 
vÆ
 
ma°îs
 = 
ma°î
.masters

37 
¶aves
.
f‹óch
 { 
s
 =>

38 
	`ªquúe
 (!
s
.
suµ‹tsRód
 || s.suµ‹tsRód.
	`c⁄èös
(
bótByãs
))

39 
	`ªquúe
 (!
s
.
suµ‹tsWrôe
 || s.suµ‹tsWrôe.
	`c⁄èös
(
bótByãs
))

55 
def
 
	`‰agmít
(
a
: 
IºevoˇbÀIO
[
AXI4BundÀA
], 
suµ‹ãdSizes1
: 
Seq
[
I¡
]): (IºevoˇbÀIO[AXI4BundÀA], 
Boﬁ
, 
UI¡
) = {

56 
vÆ
 
out
 = 
	`Wúe
(
a
)

58 
vÆ
 
busy
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

59 
vÆ
 
r_addr
 = 
	`Reg
(
	`UI¡
(
width
 = 
a
.
bôs
.
∑øms
.
addrBôs
))

60 
vÆ
 
r_Àn
 = 
	`Reg
(
	`UI¡
(
width
 = 
AXI4P¨amëîs
.
ÀnBôs
))

62 
vÆ
 
Àn
 = 
	`Mux
(
busy
, 
r_Àn
, 
a
.
bôs
.len)

63 
vÆ
 
addr
 = 
	`Mux
(
busy
, 
r_addr
, 
a
.
bôs
.addr)

65 
vÆ
 
lo
 = i‡(
lgByãs
 =0Ë
	`UI¡
(0Ë
	`addr
(lgBytes-1, 0)

66 
vÆ
 
hi
 = 
addr
 >> 
lgByãs


67 
vÆ
 
Æignmít
 = 
	`hi
(
AXI4P¨amëîs
.
ÀnBôs
-1,0)

71 
vÆ
 
sizes1
 = (
suµ‹ãdSizes1
 
zù
 
¶ave
.
¶aves
.
	`m≠
(
_
.
addªss
)).
	`fûãr
(_.
_1
 >0).
	`groupBy
(_._1).
	`m≠VÆues
(_.
	`Ê©M≠
(_.
_2
))

72 
vÆ
 
ªdu˘i⁄Mask
 = 
	`AddªssDecodî
(
sizes1
.
vÆues
.
toLi°
)

73 
vÆ
 
suµ‹t1
 = 
	`Mux1H
(
sizes1
.
toLi°
.
m≠
 { (
v
, 
a
) =>

74 (
AddªssSë
.
	`unify
(
a
.
	`m≠
(
_
.
	`widí
(~
ªdu˘i⁄Mask
)).
di°ö˘
).m≠(_.
	`c⁄èös
(
addr
)).
	`ªdu˚
(_||_), 
	`UI¡
(
v
))

83 
vÆ
 
fûlLow
 = 
	`rightOR
(
Àn
) >> 1

84 
vÆ
 
wùeHigh
 = ~
	`À·OR
(~
Àn
)

85 
vÆ
 
ªmaö1
 = 
fûlLow
 | 
wùeHigh


86 
vÆ
 
Æign1
 = ~
	`À·OR
(
Æignmít
)

87 
vÆ
 
maxSuµ‹ãd1
 = 
ªmaö1
 & 
Æign1
 & 
suµ‹t1


90 
vÆ
 
fixed
 = 
a
.
bôs
.
bur°
 ==
AXI4P¨amëîs
.
BURST_FIXED


91 
vÆ
 
«ºow
 = 
a
.
bôs
.
size
 =/
	`UI¡
(
lgByãs
)

92 
vÆ
 
bad
 = 
fixed
 || 
«ºow


95 
vÆ
 
bóts1
 = 
	`Mux
(
bad
, 
	`UI¡
(0), 
maxSuµ‹ãd1
)

96 
vÆ
 
bóts
 = 
	`OH1ToOH
(
bóts1
)

98 
vÆ
 
öc_addr
 = 
addr
 + (
bóts
 << 
a
.
bôs
.
size
)

99 
vÆ
 
wøpMask
 = 
a
.
bôs
.
	`byãs1
()

100 
vÆ
 
mux_addr
 = 
	`Wúe
(
öô
 = 
öc_addr
)

101 
	`whí
 (
a
.
bôs
.
bur°
 ==
AXI4P¨amëîs
.
BURST_WRAP
) {

102 
mux_addr
 :(
öc_addr
 & 
wøpMask
Ë| ~(~
a
.
bôs
.
addr
 | wrapMask)

104 
	`whí
 (
a
.
bôs
.
bur°
 ==
AXI4P¨amëîs
.
BURST_FIXED
) {

105 
mux_addr
 :
a
.
bôs
.
addr


108 
vÆ
 
œ°
 = 
bóts1
 ==
Àn


109 
a
.
ªady
 :
out
.ªady && 
œ°


110 
out
.
vÆid
 :
a
.valid

112 
out
.
bôs
 :
a
.bits

113 
out
.
bôs
.
Àn
 :
bóts1


120 
out
.
bôs
.
addr
 :~(~add∏| 
	`UI¡ToOH1
(
a
.bôs.
size
, 
lgByãs
))

122 
	`whí
 (
out
.
	`fúe
()) {

123 
busy
 :!
œ°


124 
r_addr
 :
mux_addr


125 
r_Àn
 :
Àn
 - 
bóts


128 (
out
, 
œ°
, 
bóts
)

132 
vÆ
 
ªadSizes1
 = 
¶aves
.
	`m≠
(
s
 => s.
suµ‹tsRód
 .
max
/
bótByãs
-1)

133 
vÆ
 
wrôeSizes1
 = 
¶aves
.
	`m≠
(
s
 => s.
suµ‹tsWrôe
.
max
/
bótByãs
-1)

136 
	`vÆ
 (
ö_¨
, 
¨_œ°
, 
_
Ë
	`‰agmít
(
Queue
.
	`úªvoˇbÀ
(
ö
.
¨
, 1, 
Êow
=
åue
), 
ªadSizes1
)

137 
	`vÆ
 (
ö_aw
, 
aw_œ°
, 
w_bóts
Ë
	`‰agmít
(
Queue
.
	`úªvoˇbÀ
(
ö
.
aw
, 1, 
Êow
=
åue
), 
wrôeSizes1
)

141 
vÆ
 
ö_w
 = 
Queue
.
	`úªvoˇbÀ
(
ö
.
w
, 1, 
Êow
=
åue
)

144 
out
.
¨
 <> 
ö_¨


145 
out
.
¨
.
bôs
.
u£r
.
gë
 :
	`C©
(
ö_¨
.bôs.u£r.
toLi°
 ++ 
	`Seq
(
¨_œ°
))

148 
vÆ
 
wbóts_œtched
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

149 
vÆ
 
wbóts_ªady
 = 
	`Wúe
(
	`Boﬁ
())

150 
vÆ
 
wbóts_vÆid
 = 
	`Wúe
(
	`Boﬁ
())

151 
	`whí
 (
wbóts_vÆid
 && 
wbóts_ªady
Ë{ 
wbóts_œtched
 :
	`Boﬁ
(
åue
) }

152 
	`whí
 (
out
.
aw
.
	`fúe
()Ë{ 
wbóts_œtched
 :
	`Boﬁ
(
Ál£
) }

155 
out
.
aw
.
vÆid
 :
ö_aw
.vÆid && (
wbóts_ªady
 || 
wbóts_œtched
)

156 
ö_aw
.
ªady
 :
out
.
aw
.ªady && (
wbóts_ªady
 || 
wbóts_œtched
)

157 
wbóts_vÆid
 :
ö_aw
.
vÆid
 && !
wbóts_œtched


158 
out
.
aw
.
bôs
 :
ö_aw
.bits

159 
out
.
aw
.
bôs
.
u£r
.
gë
 :
	`C©
(
ö_aw
.bôs.u£r.
toLi°
 ++ 
	`Seq
(
aw_œ°
))

162 
vÆ
 
w_cou¡î
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
AXI4P¨amëîs
.
ÀnBôs
+1))

163 
vÆ
 
w_idÀ
 = 
w_cou¡î
 ==
	`UI¡
(0)

164 
vÆ
 
w_todo
 = 
	`Mux
(
w_idÀ
, Mux(
wbóts_vÆid
, 
w_bóts
, 
	`UI¡
(0)), 
w_cou¡î
)

165 
vÆ
 
w_œ°
 = 
w_todo
 ==
	`UI¡
(1)

166 
w_cou¡î
 :
w_todo
 - 
out
.
w
.
	`fúe
()

167 
	`as£π
 (!
out
.
w
.
	`fúe
(Ë|| 
w_todo
 =/
	`UI¡
(0))

170 
wbóts_ªady
 :
w_idÀ


171 
out
.
w
.
vÆid
 :
ö_w
.vÆid && (!
wbóts_ªady
 || 
wbóts_vÆid
)

172 
ö_w
.
ªady
 :
out
.
w
.ªady && (!
wbóts_ªady
 || 
wbóts_vÆid
)

173 
out
.
w
.
bôs
 :
ö_w
.bits

174 
out
.
w
.
bôs
.
œ°
 :
w_œ°


176 
	`as£π
 (!
out
.
w
.
vÆid
 || !
ö_w
.
bôs
.
œ°
 || 
w_œ°
)

179 
vÆ
 
r_œ°
 = 
out
.
r
.
bôs
.
u£r
.
	`gë
(0)

180 
ö
.
r
 <> 
out
.r

181 
ö
.
r
.
bôs
.
œ°
 :
out
.r.bôs.œ° && 
r_œ°


182 
ö
.
r
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
out
.r.bôs.u£r.
gë
 >> 1 }

185 
vÆ
 
b_œ°
 = 
out
.
b
.
bôs
.
u£r
.
	`gë
(0)

186 
ö
.
b
 <> 
out
.b

187 
ö
.
b
.
vÆid
 :
out
.b.vÆid && 
b_œ°


188 
out
.
b
.
ªady
 :
ö
.b.ªady || !
b_œ°


189 
ö
.
b
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
out
.b.bôs.u£r.
gë
 >> 1 }

192 
vÆ
 
îr‹
 = 
	`RegInô
(
Vec
.
	`fûl
(
edgeIn
.
ma°î
.
ídId
Ë{ 
	`UI¡
(0, 
width
 = 
AXI4P¨amëîs
.
ª•Bôs
)})

193 
ö
.
b
.
bôs
.
ª•
 :
out
.b.bôs.ª• | 
	`îr‹
(out.b.bôs.
id
)

194 (
îr‹
 
zù
 
	`UI¡ToOH
(
out
.
b
.
bôs
.
id
, 
edgeIn
.
ma°î
.
ídId
).
toBoﬁs
Ë
f‹óch
 { (
ªg
, 
£l
) =>

195 
	`whí
 (
£l
 && 
out
.
b
.
	`fúe
()Ë{ 
ªg
 :
	`Mux
(
b_œ°
, 
	`UI¡
(0),Ñeg | out.b.
bôs
.
ª•
) }

198 
	}
}

201 
obje˘
 
	gAXI4Føgmíãr


203 
def
 
≠∂y
()(
im∂icô
 
	gp
: 
P¨amëîs
): 
AXI4Node
 =

205 
vÆ
 
axi4‰ag
 = 
LazyModuÀ
(
√w
 
AXI4Føgmíãr
)

206 
axi4‰ag
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/IdIndexer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

10 ˛as†
	cAXI4IdIndexî
(
idBôs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


12 
	`ªquúe
 (
idBôs
 >= 0)

14 
vÆ
 
node
 = 
	`AXI4Ad≠ãrNode
(

15 
ma°îFn
 = { 
mp
 =>

17 
vÆ
 
ma°îs
 = 
Aºay
.
	`èbuœã
(1 << 
idBôs
Ë{ 
i
 => 
	`AXI4Ma°îP¨amëîs
(

18 
«me
 = "",

19 
id
 = 
	`IdR™ge
(
i
, i+1),

20 
Æig√d
 = 
åue
,

21 
maxFlight
 = 
	`Some
(0))

24 
vÆ
 
«mes
 = 
Aºay
.
	`fûl
(1 << 
idBôs
Ë{ 
√w
 
sˇœ
.
cﬁÀ˘i⁄
.
muèbÀ
.
HashSë
[
Såög
]() }

26 
mp
.
ma°îs
.
f‹óch
 { 
m
 =>

27 
i
 <- 
m
.
id
.
°¨t
 
u¡û
 m.id.
íd
) {

28 
vÆ
 
j
 = 
i
 % (1 << 
idBôs
)

29 
vÆ
 
ﬁd
 = 
	`ma°îs
(
j
)

30 
	`«mes
(
j
Ë+
m
.
«me


31 
	`ma°îs
(
j
Ë
ﬁd
.
	`c›y
(

32 
Æig√d
 = 
ﬁd
.Æig√d && 
m
.aligned,

33 
maxFlight
 = 
ﬁd
.maxFlight.
Ê©M≠
 { 
o
 => 
m
.maxFlight.
m≠
 { 
n
 => o+n } })

36 
mp
.
	`c›y
(

37 
u£rBôs
 = 
mp
.u£rBô†+ 
	`max
(0, 
	`log2Ceû
(mp.
ídId
Ë- 
idBôs
),

38 
ma°îs
 = ma°îs.
zùWôhIndex
.
m≠
 { (
m
,
i
Ë=> m.
	`c›y
(
«me
 = 
	`«mes
(i).
toLi°
.
	`mkSåög
(", "))})

40 
¶aveFn
 = { 
•
 => sp

41 
	}
})

43 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

44 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

47 
out
.
¨
 <> 
ö
.ar

48 
out
.
aw
 <> 
ö
.aw

49 
out
.
w
 <> 
ö
.w

50 
ö
.
b
 <> 
out
.b

51 
ö
.
r
 <> 
out
.r

53 
vÆ
 
bôs
 = 
	`log2Ceû
(
edgeIn
.
ma°î
.
ídId
Ë- 
idBôs


54 i‡(
bôs
 > 0) {

56 
out
.
¨
.
bôs
.
u£r
.
gë
 :
	`C©
(
ö
.¨.bôs.u£r.
toLi°
 ++ 
	`Seq
(ö.¨.bôs.
id
 >> 
idBôs
))

57 
out
.
aw
.
bôs
.
u£r
.
gë
 :
	`C©
(
ö
.aw.bôs.u£r.
toLi°
 ++ 
	`Seq
(ö.aw.bôs.
id
 >> 
idBôs
))

59 
ö
.
r
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
out
.r.bôs.u£r.
gë
 >> bits }

60 
ö
.
b
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
out
.b.bôs.u£r.
gë
 >> bits }

62 i‡(
idBôs
 == 0) {

63 
out
.
¨
.
bôs
.
id
 :
	`UI¡
(0)

64 
out
.
aw
.
bôs
.
id
 :
	`UI¡
(0)

65 
ö
.
r
.
bôs
.
id
 :
out
.r.bôs.
u£r
.
gë


66 
ö
.
b
.
bôs
.
id
 :
out
.b.bôs.
u£r
.
gë


68 
ö
.
r
.
bôs
.
id
 :
	`C©
(
out
.r.bôs.
u£r
.
gë
, out.r.bits.id)

69 
ö
.
b
.
bôs
.
id
 :
	`C©
(
out
.b.bôs.
u£r
.
gë
, out.b.bits.id)

73 
	}
}

76 
obje˘
 
	gAXI4IdIndexî


78 
def
 
≠∂y
(
idBôs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =

80 
vÆ
 
axi4ödex
 = 
LazyModuÀ
(
√w
 
AXI4IdIndexî
(
idBôs
))

81 
axi4ödex
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Nodes.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
AsyncQueueP¨ams


11 
obje˘
 
AXI4Imp
 
exãnds
 
	gSim∂eNodeImp
[
AXI4Ma°îP‹tP¨amëîs
, 
AXI4SœveP‹tP¨amëîs
, 
AXI4EdgeP¨amëîs
, 
AXI4BundÀ
]

13 
def
 
edge
(
pd
: 
AXI4Ma°îP‹tP¨amëîs
, 
pu
: 
AXI4SœveP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
AXI4EdgeP¨amëîs
(pd,Öu,Ö, sourceInfo)

14 
def
 
bundÀ
(
e
: 
AXI4EdgeP¨amëîs
Ë
AXI4BundÀ
(e.bundle)

15 
def
 
ªndî
(
e
: 
AXI4EdgeP¨amëîs
Ë
RídîedEdge
(
cﬁour
 = "#00ccff" , 
œbñ
 = (e.
¶ave
.
bótByãs
 * 8).
toSåög
)

17 
ovîride
 
def
 
mixO
(
pd
: 
AXI4Ma°îP‹tP¨amëîs
, 
node
: 
Outw¨dNode
[AXI4Ma°îP‹tP¨amëîs, 
AXI4SœveP‹tP¨amëîs
, 
AXI4BundÀ
]): AXI4MasterPortParameters =

18 
pd
.
c›y
(
ma°îs
 =Öd.ma°îs.
m≠
 { 
c
 => c.c›y (
nodeP©h
 = 
node
 +: c.nodePath) })

19 
ovîride
 
def
 
mixI
(
pu
: 
AXI4SœveP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
AXI4Ma°îP‹tP¨amëîs
, AXI4SœveP‹tP¨amëîs, 
AXI4BundÀ
]): AXI4SlavePortParameters =

20 
pu
.
c›y
(
¶aves
 =Öu.¶aves.
m≠
 { 
m
 => m.c›y (
nodeP©h
 = 
node
 +: m.nodePath) })

23 
˛ass
 
	$AXI4Ma°îNode
(
p‹tP¨ams
: 
Seq
[
AXI4Ma°îP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$Sour˚Node
(
AXI4Imp
)(
p‹tP¨ams
)

24 
˛ass
 
	$AXI4SœveNode
(
p‹tP¨ams
: 
Seq
[
AXI4SœveP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$SökNode
(
AXI4Imp
)(
p‹tP¨ams
)

25 
˛ass
 
	`AXI4NexusNode
(

26 
ma°îFn
: 
Seq
[
AXI4Ma°îP‹tP¨amëîs
] => AXI4MasterPortParameters,

27 
¶aveFn
: 
Seq
[
AXI4SœveP‹tP¨amëîs
] => AXI4SlavePortParameters)(

28 
im∂icô
 
vÆName
: 
VÆName
)

29 
exãnds
 
	$NexusNode
(
AXI4Imp
)(
ma°îFn
, 
¶aveFn
)

30 
˛ass
 
	`AXI4Ad≠ãrNode
(

31 
ma°îFn
: 
AXI4Ma°îP‹tP¨amëîs
 => AXI4Ma°îP‹tP¨amëî†{ 
m
 => m 
	}
},

32 
	g¶aveFn
: 
AXI4SœveP‹tP¨amëîs
 => AXI4SœveP‹tP¨amëî†{ 
s
 => s })(

33 
im∂icô
 
vÆName
: 
VÆName
)

34 
exãnds
 
	$Ad≠ãrNode
(
AXI4Imp
)(
ma°îFn
, 
¶aveFn
)

35 ˛as†
	cAXI4IdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$IdítôyNode
(
AXI4Imp
)()

37 
obje˘
 
AXI4NameNode
 {

38 
def
 
	`≠∂y
(
«me
: 
VÆName
Ë
	$AXI4IdítôyNode
()(
«me
)

39 
def
 
	$≠∂y
(
«me
: 
O±i⁄
[
Såög
]): 
AXI4IdítôyNode
 = 
	`≠∂y
((
	`VÆName
“ame.
	`gëOrEl£
("with_no_name"))))

40 
def
 
	$≠∂y
(
«me
: 
Såög
): 
AXI4IdítôyNode
 = 
	`≠∂y
(
	`Some
(name))

43 
obje˘
 
AXI4AsyncImp
 
exãnds
 
Sim∂eNodeImp
[
AXI4AsyncMa°îP‹tP¨amëîs
, 
AXI4AsyncSœveP‹tP¨amëîs
, 
AXI4AsyncEdgeP¨amëîs
, 
AXI4AsyncBundÀ
]

45 
def
 
	`edge
(
pd
: 
AXI4AsyncMa°îP‹tP¨amëîs
, 
pu
: 
AXI4AsyncSœveP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
	`AXI4AsyncEdgeP¨amëîs
(pd,Öu,Ö, sourceInfo)

46 
def
 
	`bundÀ
(
e
: 
AXI4AsyncEdgeP¨amëîs
Ë
√w
 
	`AXI4AsyncBundÀ
”.
bundÀ
)

47 
def
 
	`ªndî
(
e
: 
AXI4AsyncEdgeP¨amëîs
Ë
	`RídîedEdge
(
cﬁour
 = "#ff0000" , 
œbñ
 =É.
¶ave
.
async
.
dïth
.
toSåög
)

49 
ovîride
 
def
 
	`mixO
(
pd
: 
AXI4AsyncMa°îP‹tP¨amëîs
, 
node
: 
Outw¨dNode
[AXI4AsyncMa°îP‹tP¨amëîs, 
AXI4AsyncSœveP‹tP¨amëîs
, 
AXI4AsyncBundÀ
]): AXI4AsyncMasterPortParameters =

50 
pd
.
	`c›y
(
ba£
 =Öd.ba£.c›y(
ma°îs
 =Öd.ba£.ma°îs.
m≠
 { 
c
 => c.c›y (
nodeP©h
 = 
node
 +: c.nodePath) }))

51 
ovîride
 
def
 
	`mixI
(
pu
: 
AXI4AsyncSœveP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
AXI4AsyncMa°îP‹tP¨amëîs
, AXI4AsyncSœveP‹tP¨amëîs, 
AXI4AsyncBundÀ
]): AXI4AsyncSlavePortParameters =

52 
pu
.
	`c›y
(
ba£
 =Öu.ba£.c›y(
¶aves
 =Öu.ba£.¶aves.
m≠
 { 
m
 => m.c›y (
nodeP©h
 = 
node
 +: m.nodePath) }))

53 
	}
}

55 
˛ass
 
	$AXI4AsyncSour˚Node
(
sync
: 
O±i⁄
[
I¡
])(
im∂icô
 
vÆName
: 
VÆName
)

56 
exãnds
 
	$MixedAd≠ãrNode
(
AXI4Imp
, 
AXI4AsyncImp
)(

57 
dFn
 = { 
p
 => 
	`AXI4AsyncMa°îP‹tP¨amëîs
’Ë
	}
},

58 
	guFn
 = { 
p
 =>Ö.
ba£
.
c›y
(
möL©ícy
 =Ö.ba£.möL©ícy + 
sync
.
gëOrEl£
’.
async
.sync)) })

60 
˛ass
 
	$AXI4AsyncSökNode
(
async
: 
AsyncQueueP¨ams
)(
im∂icô
 
vÆName
: 
VÆName
)

61 
exãnds
 
	$MixedAd≠ãrNode
(
AXI4AsyncImp
, 
AXI4Imp
)(

62 
dFn
 = { 
p
 =>Ö.
ba£
 
	}
},

63 
	guFn
 = { 
p
 => 
AXI4AsyncSœveP‹tP¨amëîs
(
async
,Ö) })

65 ˛as†
	cAXI4AsyncIdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$IdítôyNode
(
AXI4AsyncImp
)()

67 
obje˘
 
AXI4AsyncNameNode
 {

68 
def
 
	`≠∂y
(
«me
: 
VÆName
Ë
	$AXI4AsyncIdítôyNode
()(
«me
)

69 
def
 
	$≠∂y
(
«me
: 
O±i⁄
[
Såög
]): 
AXI4AsyncIdítôyNode
 = 
	`≠∂y
((
	`VÆName
“ame.
	`gëOrEl£
("with_no_name"))))

70 
def
 
	$≠∂y
(
«me
: 
Såög
): 
AXI4AsyncIdítôyNode
 = 
	`≠∂y
(
	`Some
(name))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Parameters.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
AsyncQueueP¨ams


10 
imp‹t
 
	gsˇœ
.
	gm©h
.
max


12 
˛ass
 
AXI4SœveP¨amëîs
(

13 
addªss
: 
Seq
[
AddªssSë
],

14 
ªsour˚s
: 
Seq
[
Resour˚
] = 
Nû
,

15 
ªgi⁄Ty≥
: 
Regi⁄Ty≥
.
T
 = Regi⁄Ty≥.
GET_EFFECTS
,

16 
execuèbÀ
: 
Boﬁón
 = 
Ál£
,

17 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

18 
suµ‹tsWrôe
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

19 
suµ‹tsRód
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

20 
öãæóvedId
: 
O±i⁄
[
I¡
] = 
N⁄e
)

22 
addªss
.
f‹óch
 { 
a
 => 
ªquúe
 (a.
föôe
) }

23 
addªss
.
combö©i⁄s
(2).
f‹óch
 { 
Seq
(
x
,
y
Ë=> 
ªquúe
 (!x.
ovîœps
(y), 
s
"$xánd $y overlap") }

25 
vÆ
 
	g«me
 = 
nodeP©h
.
œ°O±i⁄
.
m≠
(
_
.
œzyModuÀ
.
«me
).
gëOrEl£
("disconnected")

26 
vÆ
 
maxTøns„r
 = 
max
(
suµ‹tsWrôe
.max, 
suµ‹tsRód
.max)

27 
vÆ
 
	gmaxAddªss
 = 
addªss
.
m≠
(
_
.
max
).max

28 
vÆ
 
möAlignmít
 = 
addªss
.
m≠
(
_
.
Æignmít
).
mö


31 
ªquúe
 (
möAlignmít
 >
maxTøns„r
,

32 
s
"minAlignment ($minAlignment) must be >= maxTransfer ($maxTransfer)")

35 
˛ass
 
	$AXI4SœveP‹tP¨amëîs
(

36 
¶aves
: 
Seq
[
AXI4SœveP¨amëîs
],

37 
bótByãs
: 
I¡
,

38 
wc‹ru±
: 
Boﬁón
 = 
Ál£
,

39 
möL©ícy
: 
I¡
 = 1)

41 
	`ªquúe
 (!
¶aves
.
isEm±y
)

42 
	`ªquúe
 (
	`isPow2
(
bótByãs
))

44 
vÆ
 
maxTøns„r
 = 
¶aves
.
	`m≠
(
_
.maxTøns„r).
max


45 
vÆ
 
maxAddªss
 = 
¶aves
.
	`m≠
(
_
.maxAddªss).
max


48 
	`ªquúe
 (
maxTøns„r
 >
bótByãs
,

49 
s
"maxTransfer ($maxTransfer) shouldÇot be smallerÅhan bus width ($beatBytes)")

51 
vÆ
 
limô
 = 
bótByãs
 * (1 << 
AXI4P¨amëîs
.
ÀnBôs
)

52 
	`ªquúe
 (
maxTøns„r
 <
limô
,

53 
s
"maxTransfer ($maxTransfer) cannot beÜargerÅhan $limit oná $beatBytes*8 width bus")

56 
¶aves
.
	`combö©i⁄s
(2).
f‹óch
 { 
	`Seq
(
x
,
y
) =>

57 
x
.
addªss
.
f‹óch
 { 
a
 => 
y
.addªss.f‹óch { 
b
 =>

58 
	`ªquúe
 (!
a
.
	`ovîœps
(
b
), 
s
"$aánd $b overlap")

61 
	}
}

63 
˛ass
 
AXI4Ma°îP¨amëîs
(

64 
«me
: 
Såög
,

65 
id
: 
IdR™ge
 = IdRange(0, 1),

66 
Æig√d
: 
Boﬁón
 = 
Ál£
,

67 
maxFlight
: 
O±i⁄
[
I¡
] = 
N⁄e
,

68 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

70 
maxFlight
.
f‹óch
 { 
m
 => 
	`ªquúe
 (m >= 0) }

71 
	}
}

73 
˛ass
 
	$AXI4Ma°îP‹tP¨amëîs
(

74 
ma°îs
: 
Seq
[
AXI4Ma°îP¨amëîs
],

75 
u£rBôs
: 
I¡
 = 0)

77 
vÆ
 
ídId
 = 
ma°îs
.
	`m≠
(
_
.
id
.
íd
).
max


78 
	`ªquúe
 (
u£rBôs
 >= 0)

81 
IdR™ge
.
	`ovîœps
(
ma°îs
.
	`m≠
(
_
.
id
)).
f‹óch
 { (
x
, 
y
) =>

82 
	`ªquúe
 (!
x
.
	`ovîœps
(
y
), 
s
"AXI4MasterParameters.id $xánd $y overlap")

84 
	}
}

86 
˛ass
 
	$AXI4BundÀP¨amëîs
(

87 
addrBôs
: 
I¡
,

88 
d©aBôs
: 
I¡
,

89 
idBôs
: 
I¡
,

90 
u£rBôs
: 
I¡
 = 0,

91 
wc‹ru±
: 
Boﬁón
 = 
Ál£
)

93 
	`ªquúe
 (
d©aBôs
 >8, 
s
"AXI4 data bits must be >= 8 (got $dataBits)")

94 
	`ªquúe
 (
addrBôs
 >1, 
s
"AXI4áddr bits must be >= 1 (got $addrBits)")

95 
	`ªquúe
 (
idBôs
 >1, 
s
"AXI4 id bits must be >= 1 (got $idBits)")

96 
	`ªquúe
 (
	`isPow2
(
d©aBôs
), 
s
"AXI4 data bits must beÖow2 (got $dataBits)")

99 
vÆ
 
ÀnBôs
 = 
AXI4P¨amëîs
.lenBits

100 
vÆ
 
sizeBôs
 = 
AXI4P¨amëîs
.sizeBits

101 
vÆ
 
bur°Bôs
 = 
AXI4P¨amëîs
.burstBits

102 
vÆ
 
lockBôs
 = 
AXI4P¨amëîs
.lockBits

103 
vÆ
 
ˇcheBôs
 = 
AXI4P¨amëîs
.cacheBits

104 
vÆ
 
¥ŸBôs
 = 
AXI4P¨amëîs
.protBits

105 
vÆ
 
qosBôs
 = 
AXI4P¨amëîs
.qosBits

106 
vÆ
 
ª•Bôs
 = 
AXI4P¨amëîs
.respBits

108 
def
 (
x
: 
AXI4BundÀP¨amëîs
) =

109 
	`AXI4BundÀP¨amëîs
(

110 
	`max
(
addrBôs
, 
x
.addrBits),

111 
	`max
(
d©aBôs
, 
x
.dataBits),

112 
	`max
(
idBôs
, 
x
.idBits),

113 
	`max
(
u£rBôs
, 
x
.userBits),

114 
wc‹ru±
 || 
x
.wcorrupt)

115 
	}
}

117 
obje˘
 
	gAXI4BundÀP¨amëîs


119 
vÆ
 
	gem±yBundÀP¨ams
 = 
AXI4BundÀP¨amëîs
(
addrBôs
=1, 
d©aBôs
=8, 
idBôs
=1, 
u£rBôs
=0, 
wc‹ru±
=
Ál£
)

120 
def
 (
x
: 
Seq
[
AXI4BundÀP¨amëîs
]Ëx.
fﬁdLe·
(
em±yBundÀP¨ams
)((x,
	gy
Ë=> x.(
y
))

122 
def
 
≠∂y
(
ma°î
: 
AXI4Ma°îP‹tP¨amëîs
, 
¶ave
: 
AXI4SœveP‹tP¨amëîs
) =

123 
√w
 
AXI4BundÀP¨amëîs
(

124 
addrBôs
 = 
log2Up
(
¶ave
.
maxAddªss
+1),

125 
d©aBôs
 = 
¶ave
.
bótByãs
 * 8,

126 
idBôs
 = 
log2Up
(
ma°î
.
ídId
),

127 
u£rBôs
 = 
ma°î
.userBits,

128 
wc‹ru±
 = 
¶ave
.wcorrupt)

131 
˛ass
 
	$AXI4EdgeP¨amëîs
(

132 
ma°î
: 
AXI4Ma°îP‹tP¨amëîs
,

133 
¶ave
: 
AXI4SœveP‹tP¨amëîs
,

134 
∑øms
: 
P¨amëîs
,

135 
sour˚Info
: 
Sour˚Info
)

137 
vÆ
 
bundÀ
 = 
	`AXI4BundÀP¨amëîs
(
ma°î
, 
¶ave
)

138 
	}
}

140 
˛ass
 
	$AXI4AsyncSœveP‹tP¨amëîs
(
async
: 
AsyncQueueP¨ams
, 
ba£
: 
AXI4SœveP‹tP¨amëîs
)

141 
˛ass
 
	$AXI4AsyncMa°îP‹tP¨amëîs
(
ba£
: 
AXI4Ma°îP‹tP¨amëîs
)

143 
˛ass
 
	$AXI4AsyncBundÀP¨amëîs
(
async
: 
AsyncQueueP¨ams
, 
ba£
: 
AXI4BundÀP¨amëîs
)

144 
˛ass
 
	$AXI4AsyncEdgeP¨amëîs
(
ma°î
: 
AXI4AsyncMa°îP‹tP¨amëîs
, 
¶ave
: 
AXI4AsyncSœveP‹tP¨amëîs
, 
∑øms
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
)

146 
vÆ
 
bundÀ
 = 
	`AXI4AsyncBundÀP¨amëîs
(
¶ave
.
async
, 
	`AXI4BundÀP¨amëîs
(
ma°î
.
ba£
, slave.base))

147 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Protocol.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.{
	gIºevoˇbÀ
, 
	gIºevoˇbÀIO
}

8 
obje˘
 
	gAXI4P¨amëîs


11 
vÆ
 
	gÀnBôs
 = 8

12 
vÆ
 
sizeBôs
 = 3

13 
vÆ
 
bur°Bôs
 = 2

14 
vÆ
 
lockBôs
 = 1

15 
vÆ
 
ˇcheBôs
 = 4

16 
vÆ
 
¥ŸBôs
 = 3

17 
vÆ
 
qosBôs
 = 4

18 
vÆ
 
ª•Bôs
 = 2

20 
def
 
CACHE_RALLOCATE
 = 
UI¡
(8, 
width
 = 
ˇcheBôs
)

21 
def
 
CACHE_WALLOCATE
 = 
UI¡
(4, 
width
 = 
ˇcheBôs
)

22 
def
 
CACHE_MODIFIABLE
 = 
UI¡
(2, 
width
 = 
ˇcheBôs
)

23 
def
 
CACHE_BUFFERABLE
 = 
UI¡
(1, 
width
 = 
ˇcheBôs
)

25 
def
 
PROT_PRIVILEDGED
 = 
UI¡
(1, 
width
 = 
¥ŸBôs
)

26 
def
 
PROT_INSECURE
 = 
UI¡
(2, 
width
 = 
¥ŸBôs
)

27 
def
 
PROT_INSTRUCTION
 = 
UI¡
(4, 
width
 = 
¥ŸBôs
)

29 
def
 
BURST_FIXED
 = 
UI¡
(0, 
width
 = 
bur°Bôs
)

30 
def
 
BURST_INCR
 = 
UI¡
(1, 
width
 = 
bur°Bôs
)

31 
def
 
BURST_WRAP
 = 
UI¡
(2, 
width
 = 
bur°Bôs
)

33 
def
 
RESP_OKAY
 = 
UI¡
(0, 
width
 = 
ª•Bôs
)

34 
def
 
RESP_EXOKAY
 = 
UI¡
(1, 
width
 = 
ª•Bôs
)

35 
def
 
RESP_SLVERR
 = 
UI¡
(2, 
width
 = 
ª•Bôs
)

36 
def
 
RESP_DECERR
 = 
UI¡
(3, 
width
 = 
ª•Bôs
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/RegisterRouter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.{
	gI¡Sour˚Node
, 
	gI¡Sour˚P‹tSim∂e
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gHëîogíeousBag
, 
	gMaskGí
}

11 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

13 
˛ass
 
	$AXI4Regi°îNode
(
addªss
: 
AddªssSë
, 
c⁄cuºícy
: 
I¡
 = 0, 
bótByãs
: I¡ = 4, 
undefZîo
: 
Boﬁón
 = 
åue
, 
execuèbÀ
: Boﬁó¿
Ál£
)(
im∂icô
 
vÆName
: 
VÆName
)

14 
exãnds
 
	$SökNode
(
AXI4Imp
)(
	`Seq
(
	`AXI4SœveP‹tP¨amëîs
(

15 
	`Seq
(
	`AXI4SœveP¨amëîs
(

16 
addªss
 = 
	`Seq
(address),

17 
execuèbÀ
 =Éxecutable,

18 
suµ‹tsWrôe
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

19 
suµ‹tsRód
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

20 
öãæóvedId
 = 
	`Some
(0))),

21 
bótByãs
 = beatBytes,

22 
möL©ícy
 = 1)))

24 
	`ªquúe
 (
addªss
.
c⁄tiguous
)

28 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*) = {

29 
	`vÆ
 (
io
, 
_
Ë
this
.
	`ö
(0)

30 
vÆ
 
¨
 = 
io
.ar

31 
vÆ
 
aw
 = 
io
.aw

32 
vÆ
 
w
 = 
io
.w

33 
vÆ
 
r
 = 
io
.r

34 
vÆ
 
b
 = 
io
.b

36 
vÆ
 
∑øms
 = 
	`RegM≠≥rP¨ams
(
	`log2Up
((
addªss
.
mask
+1)/
bótByãs
), bótByãs, 
¨
.
bôs
.∑øms.
idBôs
 +ár.bôs.∑øms.
u£rBôs
)

37 
vÆ
 
ö
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`RegM≠≥rI≈ut
(
∑øms
)))

40 
ö
.
vÆid
 :
¨
.vÆid || (
aw
.vÆid && 
w
.valid)

41 
¨
.
ªady
 :
ö
.ready

42 
aw
.
ªady
 :
ö
.ªady && !
¨
.
vÆid
 && 
w
 .valid

43 
w
 .
ªady
 :
ö
.ªady && !
¨
.
vÆid
 && 
aw
.valid

45 
vÆ
 
¨_exåa
 = 
	`C©
(
	`Seq
(
¨
.
bôs
.
id
Ë++ár.bôs.
u£r
.
toLi°
)

46 
vÆ
 
aw_exåa
 = 
	`C©
(
	`Seq
(
aw
.
bôs
.
id
Ë++áw.bôs.
u£r
.
toLi°
)

47 
vÆ
 
ö_exåa
 = 
	`Mux
(
¨
.
vÆid
, 
¨_exåa
, 
aw_exåa
)

48 
vÆ
 
addr
 = 
	`Mux
(
¨
.
vÆid
,ár.
bôs
.addr, 
aw
.bits.addr)

49 
vÆ
 
mask
 = 
	`MaskGí
(
¨
.
bôs
.
addr
,ár.bôs.
size
, 
bótByãs
)

51 
ö
.
bôs
.
ªad
 :
¨
.
vÆid


52 
ö
.
bôs
.
ödex
 :
addr
 >> 
	`log2Ceû
(
bótByãs
)

53 
ö
.
bôs
.
d©a
 :
w
.bits.data

54 
ö
.
bôs
.
mask
 :
	`Mux
(
¨
.
vÆid
, mask, 
w
.bôs.
°rb
)

55 
ö
.
bôs
.
exåa
 :
ö_exåa


58 
vÆ
 
out
 = 
Queue
.
	`úªvoˇbÀ
(

59 
	`RegM≠≥r
(
bótByãs
, 
c⁄cuºícy
, 
undefZîo
, 
ö
, 
m≠pög
:
_
*),

60 
íåõs
 = 2)

63 
out
.
ªady
 :
	`Mux
(out.
bôs
.
ªad
, 
r
.ªady, 
b
.ready)

64 
r
.
vÆid
 :
out
.vÆid && out.
bôs
.
ªad


65 
b
.
vÆid
 :
out
.vÆid && !out.
bôs
.
ªad


67 
vÆ
 
out_id
 = i‡(
r
.
bôs
.
∑øms
.
idBôs
 =0Ë
	`UI¡
(0Ë(
out
.bôs.
exåa
 >> 
¨
.bôs.∑øms.
u£rBôs
)

69 
r
.
bôs
.
id
 :
out_id


70 
r
.
bôs
.
d©a
 :
out
.bits.data

71 
r
.
bôs
.
œ°
 :
	`Boﬁ
(
åue
)

72 
r
.
bôs
.
ª•
 :
AXI4P¨amëîs
.
RESP_OKAY


73 
r
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
out
.bôs.
exåa
 }

75 
b
.
bôs
.
id
 :
out_id


76 
b
.
bôs
.
ª•
 :
AXI4P¨amëîs
.
RESP_OKAY


77 
b
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
out
.bôs.
exåa
 }

79 
	}
}

84 
ab°ø˘
 
˛ass
 
	$AXI4Regi°îRouãrBa£
(
addªss
: 
AddªssSë
, 
öãºu±s
: 
I¡
, 
c⁄cuºícy
: I¡, 
bótByãs
: I¡, 
undefZîo
: 
Boﬁón
, 
execuèbÀ
: Boﬁón)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


86 
vÆ
 
node
 = 
	`AXI4Regi°îNode
(
addªss
, 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

87 
vÆ
 
öäode
 = 
	`I¡Sour˚Node
(
	`I¡Sour˚P‹tSim∂e
(
num
 = 
öãºu±s
))

88 
	}
}

90 ˛as†
	cAXI4RegBundÀArg
()(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
)

92 ˛as†
	cAXI4RegBundÀBa£
(
¨g
: 
AXI4RegBundÀArg
Ë
exãnds
 
BundÀ


94 
im∂icô
 
vÆ
 
p
 = 
¨g
.p

97 
˛ass
 
AXI4RegBundÀ
[
P
](
vÆ
 
∑øms
: P, 
¨g
: 
AXI4RegBundÀArg
Ë
exãnds
 
	$AXI4RegBundÀBa£
(
¨g
)

99 
˛ass
 
AXI4RegModuÀ
[
P
, 
B
 <: 
AXI4RegBundÀBa£
](
vÆ
 
∑øms
: P, 
bundÀBuûdî
: => B, 
rouãr
: 
AXI4Regi°îRouãrBa£
)

100 
exãnds
 
	$LazyModuÀImp
(
rouãr
Ë
wôh
 
HasRegM≠


102 
vÆ
 
io
 = 
	`IO
(
bundÀBuûdî
)

103 
vÆ
 
öãºu±s
 = i‡(
rouãr
.
öäode
.
out
.
isEm±y
Ë
	`Vec
(0, 
	`Boﬁ
()Ërouãr.öäode.
	`out
(0).
_1


104 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*Ë
rouãr
.
node
.ªgm≠(m≠pög:
_
*)

105 
	}
}

107 
˛ass
 
AXI4Regi°îRouãr
[
B
 <: 
AXI4RegBundÀBa£
, 
M
 <: 
LazyModuÀImp
]

108 (
vÆ
 
ba£
: 
BigI¡
, vÆ 
	göãºu±s
: 
I¡
 = 0, vÆ 
	gsize
: BigI¡ = 4096, vÆ 
	gc⁄cuºícy
: I¡ = 0, vÆ 
	gbótByãs
: I¡ = 4, 
	gundefZîo
: 
Boﬁón
 = 
åue
, 
	gexecuèbÀ
: Boﬁó¿
Ál£
)

109 (
bundÀBuûdî
: 
AXI4RegBundÀArg
 => 
B
)

110 (
moduÀBuûdî
: (=> 
B
, 
	gAXI4Regi°îRouãrBa£
Ë=> 
M
)(
im∂icô
 
p
: 
P¨amëîs
)

111 
exãnds
 
AXI4Regi°îRouãrBa£
(
AddªssSë
(
ba£
, 
size
-1), 
öãºu±s
, 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

113 
ªquúe
 (
isPow2
(
size
))

116 
œzy
 
vÆ
 
	gmoduÀ
 = 
moduÀBuûdî
(
bundÀBuûdî
(
AXI4RegBundÀArg
()), 
this
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/SRAM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
˛ass
 
	$AXI4RAM
(

11 
addªss
: 
AddªssSë
,

12 
execuèbÀ
: 
Boﬁón
 = 
åue
,

13 
bótByãs
: 
I¡
 = 4,

14 
devName
: 
O±i⁄
[
Såög
] = 
N⁄e
,

15 
îr‹s
: 
Seq
[
AddªssSë
] = 
Nû
,

16 
wc‹ru±
: 
Boﬁón
 = 
Ál£
)

17 (
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$Dùlom©icSRAM
(
addªss
, 
bótByãs
, 
devName
)

19 
vÆ
 
node
 = 
	`AXI4SœveNode
(
	`Seq
(
	`AXI4SœveP‹tP¨amëîs
(

20 
	`Seq
(
	`AXI4SœveP¨amëîs
(

21 
addªss
 = 
	`Li°
◊ddªssË++ 
îr‹s
,

22 
ªsour˚s
 =Ñesources,

23 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

24 
execuèbÀ
 =Éxecutable,

25 
suµ‹tsRód
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

26 
suµ‹tsWrôe
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

27 
öãæóvedId
 = 
	`Some
(0))),

28 
bótByãs
 = beatBytes,

29 
wc‹ru±
 = wcorrupt,

30 
möL©ícy
 = 1)))

32 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

33 
	`vÆ
 (
ö
, 
_
Ë
node
.
	`ö
(0)

34 
vÆ
 
mem
 = 
	`makeSögÀP‹ãdByãWrôeSeqMem
(1 << 
mask
.
	`fûãr
(
b
=>b).
size
)

35 
vÆ
 
c‹ru±
 = i‡(
wc‹ru±
Ë
	`Some
(
	`SeqMem
(1 << 
mask
.
	`fûãr
(
b
=>b).
size
, 
	`UI¡
(
width
=2))Ë
N⁄e


37 
vÆ
 
r_addr
 = 
	`C©
((
mask
 
	`zù
 (
ö
.
¨
.
bôs
.
addr
 >> 
	`log2Ceû
(
bótByãs
)).
toBoﬁs
).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
).
ªvî£
)

38 
vÆ
 
w_addr
 = 
	`C©
((
mask
 
	`zù
 (
ö
.
aw
.
bôs
.
addr
 >> 
	`log2Ceû
(
bótByãs
)).
toBoﬁs
).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
).
ªvî£
)

39 
vÆ
 
r_£l0
 = 
addªss
.
	`c⁄èös
(
ö
.
¨
.
bôs
.
addr
)

40 
vÆ
 
w_£l0
 = 
addªss
.
	`c⁄èös
(
ö
.
aw
.
bôs
.
addr
)

42 
vÆ
 
w_fuŒ
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

43 
vÆ
 
w_id
 = 
	`Reg
(
	`UI¡
())

44 
vÆ
 
w_u£r
 = 
	`Reg
(
	`UI¡
(
width
 = 1 
max
 
ö
.
∑øms
.
u£rBôs
))

45 
vÆ
 
r_£l1
 = 
	`Reg
(
r_£l0
)

46 
vÆ
 
w_£l1
 = 
	`Reg
(
w_£l0
)

48 
	`whí
 (
ö
. 
b
.
	`fúe
()Ë{ 
w_fuŒ
 :
	`Boﬁ
(
Ál£
) }

49 
	`whí
 (
ö
.
aw
.
	`fúe
()Ë{ 
w_fuŒ
 :
	`Boﬁ
(
åue
) }

51 
	`whí
 (
ö
.
aw
.
	`fúe
()) {

52 
w_id
 :
ö
.
aw
.
bôs
.
id


53 
w_£l1
 :
w_£l0


54 
ö
.
aw
.
bôs
.
u£r
.
f‹óch
 { 
w_u£r
 :
_
 }

57 
vÆ
 
wd©a
 = 
Vec
.
	`èbuœã
(
bótByãs
Ë{ 
i
 => 
ö
.
w
.
bôs
.
	`d©a
(8*(i+1)-1, 8*i) }

58 
	`whí
 (
ö
.
aw
.
	`fúe
(Ë&& 
w_£l0
) {

59 
mem
.
	`wrôe
(
w_addr
, 
wd©a
, 
ö
.
w
.
bôs
.
°rb
.
toBoﬁs
)

60 
c‹ru±
.
f‹óch
 { 
_
.
	`wrôe
(
w_addr
, 
ö
.
w
.
bôs
.c‹ru±.
gë
.
asUI¡
) }

63 
ö
. 
b
.
vÆid
 :
w_fuŒ


64 
ö
.
aw
.
ªady
 :ö. 
w
.
vÆid
 && (ö.
b
.ªady || !
w_fuŒ
)

65 
ö
. 
w
.
ªady
 :ö.
aw
.
vÆid
 && (ö.
b
.ªady || !
w_fuŒ
)

67 
ö
.
b
.
bôs
.
id
 :
w_id


68 
ö
.
b
.
bôs
.
ª•
 :
	`Mux
(
w_£l1
, 
AXI4P¨amëîs
.
RESP_OKAY
, AXI4P¨amëîs.
RESP_DECERR
)

69 
ö
.
b
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
w_u£r
 }

71 
vÆ
 
r_fuŒ
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

72 
vÆ
 
r_id
 = 
	`Reg
(
	`UI¡
())

73 
vÆ
 
r_u£r
 = 
	`Reg
(
	`UI¡
(
width
 = 1 
max
 
ö
.
∑øms
.
u£rBôs
))

75 
	`whí
 (
ö
. 
r
.
	`fúe
()Ë{ 
r_fuŒ
 :
	`Boﬁ
(
Ál£
) }

76 
	`whí
 (
ö
.
¨
.
	`fúe
()Ë{ 
r_fuŒ
 :
	`Boﬁ
(
åue
) }

78 
	`whí
 (
ö
.
¨
.
	`fúe
()) {

79 
r_id
 :
ö
.
¨
.
bôs
.
id


80 
r_£l1
 :
r_£l0


81 
ö
.
¨
.
bôs
.
u£r
.
f‹óch
 { 
r_u£r
 :
_
 }

84 
vÆ
 
ªn
 = 
ö
.
¨
.
	`fúe
()

85 
vÆ
 
rd©a
 = 
mem
.
	`ªadAndHﬁd
(
r_addr
, 
ªn
)

86 
vÆ
 
rc‹ru±
 = 
c‹ru±
.
	`m≠
(
_
.
	`ªadAndHﬁd
(
r_addr
, 
ªn
)(0)).
	`gëOrEl£
(
	`Boﬁ
(
Ál£
))

88 
ö
. 
r
.
vÆid
 :
r_fuŒ


89 
ö
.
¨
.
ªady
 :ö.
r
.ªady || !
r_fuŒ


91 
ö
.
r
.
bôs
.
id
 :
r_id


92 
ö
.
r
.
bôs
.
ª•
 :
	`Mux
(
r_£l1
, Mux(
rc‹ru±
, 
AXI4P¨amëîs
.
RESP_SLVERR
, AXI4P¨amëîs.
RESP_OKAY
), AXI4P¨amëîs.
RESP_DECERR
)

93 
ö
.
r
.
bôs
.
d©a
 :
	`C©
(
rd©a
.
ªvî£
)

94 
ö
.
r
.
bôs
.
u£r
.
f‹óch
 { 
_
 :
r_u£r
 }

95 
ö
.
r
.
bôs
.
œ°
 :
	`Boﬁ
(
åue
)

97 
	}
}

99 
obje˘
 
AXI4RAM


101 
def
 
≠∂y
(

102 
addªss
: 
AddªssSë
,

103 
execuèbÀ
: 
Boﬁón
 = 
åue
,

104 
bótByãs
: 
I¡
 = 4,

105 
devName
: 
O±i⁄
[
Såög
] = 
N⁄e
,

106 
îr‹s
: 
Seq
[
AddªssSë
] = 
Nû
)

107 (
im∂icô
 
p
: 
P¨amëîs
) =

109 
vÆ
 
axi4øm
 = 
LazyModuÀ
(
√w
 
AXI4RAM
(
addªss
, 
execuèbÀ
, 
bótByãs
, 
devName
, 
îr‹s
))

110 
	gaxi4øm
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Test.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


12 
˛ass
 
	$RRTe°0
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$AXI4Regi°îRouãr
(
addªss
, 0, 32, 0, 4)(

13 
√w
 
	`AXI4RegBundÀ
((), 
_
Ë
wôh
 
RRTe°0BundÀ
)(

14 
√w
 
	`AXI4RegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°0ModuÀ
)

16 
˛ass
 
	$RRTe°1
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$AXI4Regi°îRouãr
(
addªss
, 0, 32, 6, 4, 
Ál£
)(

17 
√w
 
	`AXI4RegBundÀ
((), 
_
Ë
wôh
 
RRTe°1BundÀ
)(

18 
√w
 
	`AXI4RegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°1ModuÀ
)

20 ˛as†
	cAXI4LôeFuzzRAM
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


22 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

23 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AXI4LiteFuzzRAM"))

24 
vÆ
 
xb¨
 = 
	$LazyModuÀ
(
√w
 
TLXb¨
)

25 
vÆ
 
gpio
 = 
	`LazyModuÀ
(
√w
 
	$RRTe°1
(0x400))

26 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`AXI4RAM
(
	$AddªssSë
(0x0, 0x3ff)))

28 
xb¨
.
node
 :
	$TLDñayî
(0.1Ë:
	$TLBuf„r
(
Buf„rP¨ams
.
Êow
Ë:
	$TLDñayî
(0.2Ë:
modñ
.
node
 :
fuzz
.node

29 
øm
.
node
 :
	$AXI4U£rY™kî
(Ë:
	$AXI4IdIndexî
(0Ë:
	$TLToAXI4
(
åue
 ) :
	$TLFøgmíãr
(4, 16, 
hﬁdFú°Díy
=
åue
Ë:
xb¨
.
node


30 
gpio
.
node
 :
	$AXI4U£rY™kî
(Ë:
	$AXI4IdIndexî
(0Ë:
	$TLToAXI4
(
Ál£
Ë:
	$TLFøgmíãr
(4, 16, 
hﬁdFú°Díy
=
åue
Ë:
xb¨
.
node


32 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

33 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

35 
	}
}

37 
˛ass
 
	$AXI4LôeFuzzRAMTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

38 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AXI4LôeFuzzRAM
(
txns
)).
moduÀ
)

39 
io
.
föished
 :
dut
.io.finished

40 
	}
}

42 ˛as†
	cAXI4FuŒFuzzRAM
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


44 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

45 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AXI4FullFuzzRAM"))

46 
vÆ
 
xb¨
 = 
	$LazyModuÀ
(
√w
 
TLXb¨
)

47 
vÆ
 
gpio
 = 
	`LazyModuÀ
(
√w
 
	$RRTe°0
(0x400))

48 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`AXI4RAM
(
	$AddªssSë
(0x0, 0x3ff)))

50 
xb¨
.
node
 :
	$TLDñayî
(0.1Ë:
	$TLBuf„r
(
Buf„rP¨ams
.
Êow
Ë:
	$TLDñayî
(0.2Ë:
modñ
.
node
 :
fuzz
.node

51 
øm
.
node
 :
	$AXI4Føgmíãr
(Ë:
	$AXI4Deöãæóvî
(16Ë:
	$TLToAXI4
(
Ál£
Ë:
xb¨
.
node


52 
gpio
.
node
 :
	$AXI4Føgmíãr
(Ë:
	$AXI4Deöãæóvî
(16Ë:
	$TLToAXI4
(
åue
 ) :
xb¨
.
node


54 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

55 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

57 
	}
}

59 
˛ass
 
	$AXI4FuŒFuzzRAMTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

60 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AXI4FuŒFuzzRAM
(
txns
)).
moduÀ
)

61 
io
.
föished
 :
dut
.io.finished

62 
	}
}

64 
åaô
 
HasFuzzT¨gë
 {

65 
vÆ
 
fuzzAddr
 = 
AddªssSë
(0x0, 0xfff)

66 
vÆ
 
	g∑âîn
 = 
Seq
(
AddªssSë
(0x8, ~0x808),

67 
AddªssSë
(0x900, ~0x900))

70 ˛as†
	cAXI4FuzzMa°î
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 
wôh
 
HasFuzzT¨gë


72 
vÆ
 
node
 = 
	$AXI4IdítôyNode
()

73 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
, 
ovîrideAddªss
 = 
	$Some
(
fuzzAddr
)))

74 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AXI4FuzzMaster"))

76 (
node


77 :
	$AXI4U£rY™kî
()

78 :
	$AXI4Deöãæóvî
(64)

79 :
	$TLToAXI4
()

80 :
	$TLDñayî
(0.1)

81 :
	$TLBuf„r
(
Buf„rP¨ams
.
Êow
)

82 :
	$TLDñayî
(0.1)

83 :
	$TLEº‹EvÆu©‹
(
∑âîn
, 
ã°On
=
åue
, 
ã°Off
=true)

84 :
modñ
.
node


85 :
fuzz
.
node
)

87 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

88 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

89 
vÆ
 
föished
 = 
	`Boﬁ
(
OUTPUT
)

92 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

94 
	}
}

96 ˛as†
	cAXI4FuzzSœve
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
Sim∂eLazyModuÀ
 
wôh
 
HasFuzzT¨gë


98 
vÆ
 
node
 = 
	$AXI4IdítôyNode
()

99 
vÆ
 
xb¨
 = 
	$LazyModuÀ
(
√w
 
TLXb¨
)

100 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	$TLRAM
(
fuzzAddr
))

101 
vÆ
 
îr‹

	`LazyModuÀ
(
√w
 
	`TLEº‹
(
	`DevNuŒP¨ams
(
	`Seq
(
	`AddªssSë
(0x1800, 0xff)), 
maxAtomic
 = 8, 
maxTøns„r
 = 256)))

103 
øm
.
node
 :
	$TLEº‹EvÆu©‹
(
∑âîn
Ë:
	$TLFøgmíãr
(4, 16Ë:
xb¨
.
node


104 
îr‹
.
node
 :
xb¨
.node

106 (
xb¨
.
node


107 :
	$TLFIFOFixî
()

108 :
	$TLDñayî
(0.1)

109 :
	$TLBuf„r
(
Buf„rP¨ams
.
Êow
)

110 :
	$TLDñayî
(0.1)

111 :
	$AXI4ToTL
()

112 :
	`AXI4U£rY™kî
(
	$Some
(4))

113 :
	$AXI4Føgmíãr
()

114 :
	$AXI4IdIndexî
(2)

115 :
node
)

118 ˛as†
	cAXI4FuzzBridge
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


120 
vÆ
 
ma°î
 = 
	`LazyModuÀ
(
√w
 
	$AXI4FuzzMa°î
(
txns
))

121 
vÆ
 
¶ave
 = 
	$LazyModuÀ
(
√w
 
AXI4FuzzSœve
)

123 
¶ave
.
node
 :
ma°î
.node

125 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

126 
io
.
föished
 :
ma°î
.
moduÀ
.io.finished

128 
	}
}

130 
˛ass
 
	$AXI4BridgeTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

131 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AXI4FuzzBridge
(
txns
)).
moduÀ
)

132 
io
.
föished
 :
dut
.io.finished

133 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/ToTL.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
˛ass
 
	$AXI4ToTLNode
(
wc‹ru±
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$MixedAd≠ãrNode
(
AXI4Imp
, 
TLImp
)(

12 
dFn
 = { 
	`AXI4Ma°îP‹tP¨amëîs
(
ma°îs
, 
u£rBôs
) =>

13 
ma°îs
.
f‹óch
 { 
m
 => 
	`ªquúe
 (m.
maxFlight
.
isDeföed
, "AXI4 must includeáÅransaction maximumÖer IDÅo convertÅo TL") }

14 
vÆ
 
maxFlight
 = 
ma°îs
.
	`m≠
(
_
.maxFlight.
gë
).
max


15 
	`TLClõ¡P‹tP¨amëîs
(

16 
˛õ¡s
 = 
ma°îs
.
	`fûãr
(
_
.
maxFlight
 !
	`Some
(0)).
Ê©M≠
 { 
m
 =>

17 
id
 <- 
m
.id.
°¨t
 
u¡û
 m.id.
íd
)

18 
yõld
 
	`TLClõ¡P¨amëîs
(

19 
«me
 = 
s
"${m.name} ID#${id}",

20 
sour˚Id
 = 
	`IdR™ge
(
id
 * 
maxFlight
*2, (id+1) * maxFlight*2),

21 
nodeP©h
 = 
m
.nodePath,

22 
ªque°Fifo
 = 
åue
)

24 
	}
},

25 
	guFn
 = { 
mp
 => 
AXI4SœveP‹tP¨amëîs
(

26 
¶aves
 = 
mp
.
m™agîs
.
m≠
 { 
m
 =>

27 
vÆ
 
maxX„r
 = 
Tøns„rSizes
(1, 
mp
.
bótByãs
 * (1 << 
AXI4P¨amëîs
.
ÀnBôs
))

28 
AXI4SœveP¨amëîs
(

29 
addªss
 = 
m
.address,

30 
ªsour˚s
 = 
m
.resources,

31 
ªgi⁄Ty≥
 = 
m
.regionType,

32 
execuèbÀ
 = 
m
.executable,

33 
nodeP©h
 = 
m
.nodePath,

34 
suµ‹tsWrôe
 = 
m
.
suµ‹tsPutP¨tül
.
öãr£˘
(
maxX„r
),

35 
suµ‹tsRód
 = 
m
.
suµ‹tsGë
.
öãr£˘
(
maxX„r
),

36 
öãæóvedId
 = 
Some
(0))},

37 
bótByãs
 = 
mp
.beatBytes,

38 
wc‹ru±
 = wcorrupt,

39 
möL©ícy
 = 
mp
.minLatency)

42 
˛ass
 
	$AXI4ToTL
(
wc‹ru±
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


44 
vÆ
 
node
 = 
	`AXI4ToTLNode
(
wc‹ru±
)

46 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

47 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

48 
vÆ
 
numIds
 = 
edgeIn
.
ma°î
.
ídId


49 
vÆ
 
bótByãs
 = 
edgeOut
.
m™agî
.beatBytes

50 
vÆ
 
bótCou¡Bôs
 = 
AXI4P¨amëîs
.
ÀnBôs
 + (1 << AXI4P¨amëîs.
sizeBôs
) - 1

51 
vÆ
 
maxFlight
 = 
edgeIn
.
ma°î
.
ma°îs
.
	`m≠
(
_
.maxFlight.
gë
).
max


52 
vÆ
 
logFlight
 = 
	`log2Ceû
(
maxFlight
)

53 
vÆ
 
txnCou¡Bôs
 = 
	`log2Ceû
(
maxFlight
+1)

54 
vÆ
 
addedBôs
 = 
logFlight
 + 1

56 
	`ªquúe
 (
edgeIn
.
ma°î
.
u£rBôs
 == 0, "AXI4 user bits cannot beÅransported by TL")

57 
	`ªquúe
 (
edgeIn
.
ma°î
.
	`ma°îs
(0).
Æig√d
)

58 
edgeOut
.
m™agî
.
	`ªquúeFifo
()

61 
vÆ
 
îr‹Devs
 = 
edgeOut
.
m™agî
.
m™agîs
.
	`fûãr
(
_
.
nodeP©h
.
œ°
.
œzyModuÀ
.
˛assName
 == "TLError")

62 
	`ªquúe
 (!
îr‹Devs
.
isEm±y
, "There isÇo TLErrorÑeachable from AXI4ToTL. One must be instantiated.")

63 
vÆ
 
îr‹
 = 
îr‹Devs
.
hód
.
addªss
.hód.
ba£


64 
	`ªquúe
 (
îr‹Devs
.
hód
.
suµ‹tsPutP¨tül
.
	`c⁄èös
(
edgeOut
.
m™agî
.
maxTøns„r
),

65 
s
"Error device supports ${errorDevs.head.supportsPutPartial} PutPartial but must support ${edgeOut.manager.maxTransfer}")

66 
	`ªquúe
 (
îr‹Devs
.
hód
.
suµ‹tsGë
.
	`c⁄èös
(
edgeOut
.
m™agî
.
maxTøns„r
),

67 
s
"Error device supports ${errorDevs.head.supportsGet} Get but must support ${edgeOut.manager.maxTransfer}")

69 
vÆ
 
r_out
 = 
	`Wúe
(
out
.
a
)

70 
vÆ
 
r_size1
 = 
ö
.
¨
.
bôs
.
	`byãs1
()

71 
vÆ
 
r_size
 = 
	`OH1ToUI¡
(
r_size1
)

72 
vÆ
 
r_ok
 = 
edgeOut
.
m™agî
.
	`suµ‹tsGëSa„
(
ö
.
¨
.
bôs
.
addr
, 
r_size
)

73 
vÆ
 
r_addr
 = 
	`Mux
(
r_ok
, 
ö
.
¨
.
bôs
.
addr
, 
	`UI¡
(
îr‹
Ë| in.¨.bôs.
	`addr
(
	`log2Up
(
bótByãs
)-1, 0))

74 
vÆ
 
r_cou¡
 = 
	`RegInô
(
Vec
.
	`fûl
(
numIds
Ë{ 
	`UI¡
(0, 
width
 = 
txnCou¡Bôs
) })

75 
vÆ
 
r_id
 = 
	`C©
(
ö
.
¨
.
bôs
.
id
, 
	`r_cou¡
(ö.¨.bôs.id)(
logFlight
-1,0), 
	`UI¡
(0, 
width
=1))

77 
	`as£π
 (!
ö
.
¨
.
vÆid
 || 
r_size1
 ==
	`UI¡ToOH1
(
r_size
, 
bótCou¡Bôs
))

78 
ö
.
¨
.
ªady
 :
r_out
.ready

79 
r_out
.
vÆid
 :
ö
.
¨
.valid

80 
r_out
.
bôs
 :
edgeOut
.
	`Gë
(
r_id
, 
r_addr
, 
r_size
).
_2


82 
vÆ
 
r_£l
 = 
	`UI¡ToOH
(
ö
.
¨
.
bôs
.
id
, 
numIds
)

83 (
r_£l
.
toBoﬁs
 
zù
 
r_cou¡
Ë
f‹óch
 { (
s
, 
r
) =>

84 
	`whí
 (
ö
.
¨
.
	`fúe
(Ë&& 
s
Ë{ 
r
 :∏+ 
	`UI¡
(1) }

87 
vÆ
 
w_out
 = 
	`Wúe
(
out
.
a
)

88 
vÆ
 
w_size1
 = 
ö
.
aw
.
bôs
.
	`byãs1
()

89 
vÆ
 
w_size
 = 
	`OH1ToUI¡
(
w_size1
)

90 
vÆ
 
w_ok
 = 
edgeOut
.
m™agî
.
	`suµ‹tsPutP¨tülSa„
(
ö
.
aw
.
bôs
.
addr
, 
w_size
)

91 
vÆ
 
w_addr
 = 
	`Mux
(
w_ok
, 
ö
.
aw
.
bôs
.
addr
, 
	`UI¡
(
îr‹
Ë| in.aw.bôs.
	`addr
(
	`log2Up
(
bótByãs
)-1, 0))

92 
vÆ
 
w_cou¡
 = 
	`RegInô
(
Vec
.
	`fûl
(
numIds
Ë{ 
	`UI¡
(0, 
width
 = 
txnCou¡Bôs
) })

93 
vÆ
 
w_id
 = 
	`C©
(
ö
.
aw
.
bôs
.
id
, 
	`w_cou¡
(ö.aw.bôs.id)(
logFlight
-1,0), 
	`UI¡
(1, 
width
=1))

95 
	`as£π
 (!
ö
.
aw
.
vÆid
 || 
w_size1
 ==
	`UI¡ToOH1
(
w_size
, 
bótCou¡Bôs
))

96 
	`as£π
 (!
ö
.
aw
.
vÆid
 || in.aw.
bôs
.
Àn
 ==
	`UI¡
(0Ë|| in.aw.bôs.
size
 ==UI¡(
	`log2Ceû
(
bótByãs
)))

97 
ö
.
aw
.
ªady
 :
w_out
.ªady && in.
w
.
vÆid
 && in.w.
bôs
.
œ°


98 
ö
.
w
.
ªady
 :
w_out
.ªady && in.
aw
.
vÆid


99 
w_out
.
vÆid
 :
ö
.
aw
.vÆid && in.
w
.valid

100 
w_out
.
bôs
 :
edgeOut
.
	`Put
(
w_id
, 
w_addr
, 
w_size
, 
ö
.
w
.bôs.
d©a
, in.w.bôs.
°rb
).
_2


101 
ö
.
w
.
bôs
.
c‹ru±
.
f‹óch
 { 
w_out
.bôs.c‹ru± :
_
 }

103 
vÆ
 
w_£l
 = 
	`UI¡ToOH
(
ö
.
aw
.
bôs
.
id
, 
numIds
)

104 (
w_£l
.
toBoﬁs
 
zù
 
w_cou¡
Ë
f‹óch
 { (
s
, 
r
) =>

105 
	`whí
 (
ö
.
aw
.
	`fúe
(Ë&& 
s
Ë{ 
r
 :∏+ 
	`UI¡
(1) }

108 
	`TLArbôî
(
TLArbôî
.
roundRobö
)(
out
.
a
, (
	`UI¡
(0), 
r_out
), (
ö
.
aw
.
bôs
.
Àn
, 
w_out
))

110 
vÆ
 
ok_b
 = 
	`Wúe
(
ö
.
b
)

111 
vÆ
 
ok_r
 = 
	`Wúe
(
ö
.
r
)

113 
vÆ
 
d_ª•
 = 
	`Mux
(
out
.
d
.
bôs
.
díõd
 || out.d.bôs.
c‹ru±
, 
AXI4P¨amëîs
.
RESP_SLVERR
, AXI4P¨amëîs.
RESP_OKAY
)

114 
vÆ
 
d_hasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
bôs
)

115 
vÆ
 
d_œ°
 = 
edgeOut
.
	`œ°
(
out
.
d
)

117 
out
.
d
.
ªady
 :
	`Mux
(
d_hasD©a
, 
ok_r
.ªady, 
ok_b
.ready)

118 
ok_r
.
vÆid
 :
out
.
d
.vÆid && 
d_hasD©a


119 
ok_b
.
vÆid
 :
out
.
d
.vÆid && !
d_hasD©a


121 
ok_r
.
bôs
.
id
 :
out
.
d
.bôs.
sour˚
 >> 
addedBôs


122 
ok_r
.
bôs
.
d©a
 :
out
.
d
.bits.data

123 
ok_r
.
bôs
.
ª•
 :
d_ª•


124 
ok_r
.
bôs
.
œ°
 :
d_œ°


127 
ö
.
r
 <> 
Queue
.
	`úªvoˇbÀ
(
ok_r
, 1, 
Êow
=
åue
)

129 
ok_b
.
bôs
.
id
 :
out
.
d
.bôs.
sour˚
 >> 
addedBôs


130 
ok_b
.
bôs
.
ª•
 :
d_ª•


133 
vÆ
 
q_b
 = 
Queue
.
	`úªvoˇbÀ
(
ok_b
, 1, 
Êow
=
åue
)

137 
vÆ
 
b_cou¡
 = 
	`RegInô
(
Vec
.
	`fûl
(
numIds
Ë{ 
	`UI¡
(0, 
width
 = 
txnCou¡Bôs
) })

138 
vÆ
 
b_Ælow
 = 
	`b_cou¡
(
ö
.
b
.
bôs
.
id
Ë=/
	`w_cou¡
(in.b.bits.id)

139 
vÆ
 
b_£l
 = 
	`UI¡ToOH
(
ö
.
b
.
bôs
.
id
, 
numIds
)

141 (
b_£l
.
toBoﬁs
 
zù
 
b_cou¡
Ë
f‹óch
 { (
s
, 
r
) =>

142 
	`whí
 (
ö
.
b
.
	`fúe
(Ë&& 
s
Ë{ 
r
 :∏+ 
	`UI¡
(1) }

145 
ö
.
b
.
bôs
 :
q_b
.bits

146 
ö
.
b
.
vÆid
 :
q_b
.vÆid && 
b_Ælow


147 
q_b
.
ªady
 :
ö
.
b
.ªady && 
b_Ælow


150 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

151 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

152 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

155 
	}
}

157 ˛as†
	cAXI4BundÀREº‹
(
∑øms
: 
AXI4BundÀP¨amëîs
Ë
exãnds
 
	$AXI4BundÀBa£
(
∑øms
)

159 
vÆ
 
id
 = 
	$UI¡
(
width
 = 
∑øms
.
idBôs
)

160 
vÆ
 
œ°
 = 
	`Boﬁ
()

163 
obje˘
 
AXI4ToTL


165 
def
 
	`≠∂y
(
wc‹ru±
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
) =

167 
vÆ
 
axi42é
 = 
	`LazyModuÀ
(
√w
 
	`AXI4ToTL
(
wc‹ru±
))

168 
axi42é
.
node


170 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/UserYanker.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
UI¡ToOH1


10 
˛ass
 
	$AXI4U£rY™kî
(
ˇpMaxFlight
: 
O±i⁄
[
I¡
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


12 
vÆ
 
node
 = 
	`AXI4Ad≠ãrNode
(

13 
ma°îFn
 = { 
mp
 => mp.
	`c›y
(

14 
u£rBôs
 = 0,

15 
ma°îs
 = 
mp
.ma°îs.
m≠
 { 
m
 => m.
	`c›y
(

16 
maxFlight
 = (
m
.maxFlight, 
ˇpMaxFlight
Ë
m©ch
 {

17 (
	`Some
(
x
), Some(
y
)Ë=> Some(x 
mö
 y)

18 (
	`Some
(
x
), 
N⁄e
) => Some(x)

19 (
N⁄e
, 
	`Some
(
y
)) => Some(y)

20 (
N⁄e
, None) => None })})},

21 
¶aveFn
 = { 
•
 => sp })

23 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

24 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

25 
vÆ
 
bôs
 = 
edgeIn
.
bundÀ
.
u£rBôs


26 
vÆ
 
√ed_by∑ss
 = 
edgeOut
.
¶ave
.
möL©ícy
 < 1

27 
	`ªquúe
 (
bôs
 > 0)

29 
edgeOut
.
ma°î
.
ma°îs
.
f‹óch
 { 
m
 =>

30 
	`ªquúe
 (
m
.
maxFlight
.
isDeföed
, "UserYankerÇeedsá flight cap onÉach ID")

33 
def
 
	`queue
(
id
: 
I¡
) = {

34 
vÆ
 
dïth
 = 
edgeOut
.
ma°î
.
ma°îs
.
	`föd
(
_
.
id
.
	`c⁄èös
(id)).
	`Ê©M≠
(_.
maxFlight
).
	`gëOrEl£
(0)

35 i‡(
dïth
 == 0) {

36 
	`Wúe
(
√w
 
	`QueueIO
(
	`UI¡
(
width
 = 
bôs
), 1))

38 
	`ModuÀ
(
√w
 
	`Queue
(
	`UI¡
(
width
 = 
bôs
), 
dïth
, 
Êow
=
√ed_by∑ss
)).
io


42 
vÆ
 
rqueues
 = 
Seq
.
	`èbuœã
(
edgeIn
.
ma°î
.
ídId
Ë{ 
i
 => 
	`queue
(i) }

43 
vÆ
 
wqueues
 = 
Seq
.
	`èbuœã
(
edgeIn
.
ma°î
.
ídId
Ë{ 
i
 => 
	`queue
(i) }

45 
vÆ
 
¨id
 = 
ö
.
¨
.
bôs
.
id


46 
vÆ
 
¨_ªady
 = 
	`Vec
(
rqueues
.
	`m≠
(
_
.
íq
.
ªady
))(
¨id
)

47 
ö
 .
¨
.
ªady
 :
out
.¨.ªady && 
¨_ªady


48 
out
.
¨
.
vÆid
 :
ö
 .¨.vÆid && 
¨_ªady


49 
out
.
¨
.
bôs
 :
ö
 .ar.bits

51 
vÆ
 
rid
 = 
out
.
r
.
bôs
.
id


52 
vÆ
 
r_vÆid
 = 
	`Vec
(
rqueues
.
	`m≠
(
_
.
deq
.
vÆid
))(
rid
)

53 
vÆ
 
r_bôs
 = 
	`Vec
(
rqueues
.
	`m≠
(
_
.
deq
.
bôs
))(
rid
)

54 
	`as£π
 (!
out
.
r
.
vÆid
 || 
r_vÆid
)

55 
ö
.
r
 <> 
out
.r

56 
ö
.
r
.
bôs
.
u£r
.
gë
 :
r_bôs


58 
vÆ
 
¨£l
 = 
	`UI¡ToOH
(
¨id
, 
edgeIn
.
ma°î
.
ídId
).
toBoﬁs


59 
vÆ
 
r£l
 = 
	`UI¡ToOH
(
rid
, 
edgeIn
.
ma°î
.
ídId
).
toBoﬁs


60 (
rqueues
 
	`zù
 (
¨£l
 
zù
 
r£l
)Ë
f‹óch
 { (
q
, (
¨
, 
r
)) =>

61 
q
.
deq
.
ªady
 :
out
.
r
 .
vÆid
 && 
ö
 .∏.ªady &&Ñ && out.r.
bôs
.
œ°


62 
q
.
íq
.
vÆid
 :
ö
 .
¨
.vÆid && 
out
.¨.
ªady
 &&ár

63 
q
.
íq
.
bôs
 :
ö
.
¨
.bôs.
u£r
.
gë


66 
vÆ
 
awid
 = 
ö
.
aw
.
bôs
.
id


67 
vÆ
 
aw_ªady
 = 
	`Vec
(
wqueues
.
	`m≠
(
_
.
íq
.
ªady
))(
awid
)

68 
ö
 .
aw
.
ªady
 :
out
.aw.ªady && 
aw_ªady


69 
out
.
aw
.
vÆid
 :
ö
 .aw.vÆid && 
aw_ªady


70 
out
.
aw
.
bôs
 :
ö
 .aw.bits

72 
vÆ
 
bid
 = 
out
.
b
.
bôs
.
id


73 
vÆ
 
b_vÆid
 = 
	`Vec
(
wqueues
.
	`m≠
(
_
.
deq
.
vÆid
))(
bid
)

74 
vÆ
 
b_bôs
 = 
	`Vec
(
wqueues
.
	`m≠
(
_
.
deq
.
bôs
))(
bid
)

75 
	`as£π
 (!
out
.
b
.
vÆid
 || 
b_vÆid
)

76 
ö
.
b
 <> 
out
.b

77 
ö
.
b
.
bôs
.
u£r
.
gë
 :
b_bôs


79 
vÆ
 
aw£l
 = 
	`UI¡ToOH
(
awid
, 
edgeIn
.
ma°î
.
ídId
).
toBoﬁs


80 
vÆ
 
b£l
 = 
	`UI¡ToOH
(
bid
, 
edgeIn
.
ma°î
.
ídId
).
toBoﬁs


81 (
wqueues
 
	`zù
 (
aw£l
 
zù
 
b£l
)Ë
f‹óch
 { (
q
, (
aw
, 
b
)) =>

82 
q
.
deq
.
ªady
 :
out
.
b
 .
vÆid
 && 
ö
 .b .ready && b

83 
q
.
íq
.
vÆid
 :
ö
 .
aw
.vÆid && 
out
.aw.
ªady
 &&áw

84 
q
.
íq
.
bôs
 :
ö
.
aw
.bôs.
u£r
.
gë


87 
out
.
w
 <> 
ö
.w

90 
	}
}

92 
obje˘
 
AXI4U£rY™kî


94 
def
 
≠∂y
(
ˇpMaxFlight
: 
O±i⁄
[
I¡
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
): 
AXI4Node
 =

96 
vÆ
 
axi4y™k
 = 
LazyModuÀ
(
√w
 
AXI4U£rY™kî
(
ˇpMaxFlight
))

97 
axi4y™k
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Xbar.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
axi4


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
IºevoˇbÀIO


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


12 
˛ass
 
	$AXI4Xb¨
(

13 
¨bôøti⁄Pﬁicy
: 
TLArbôî
.
Pﬁicy
 = TLArbôî.
roundRobö
,

14 
maxFlightPîId
: 
I¡
 = 7,

15 
awQueueDïth
: 
I¡
 = 2)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


17 
	`ªquúe
 (
maxFlightPîId
 >= 1)

18 
	`ªquúe
 (
awQueueDïth
 >= 1)

20 
vÆ
 
node
 = 
	`AXI4NexusNode
(

21 
ma°îFn
 = { 
£q
 =>

22 
	`£q
(0).
	`c›y
(

23 
u£rBôs
 = 
£q
.
	`m≠
(
_
.u£rBôs).
max
,

24 
ma°îs
 = (
AXI4Xb¨
.
	`m≠I≈utIds
(
£q
Ë
zù
 seqË
Ê©M≠
 { (
ønge
, 
p‹t
) =>

25 
p‹t
.
ma°îs
 
m≠
 { 
ma°î
 => ma°î.
	`c›y
(
id
 = ma°î.id.
	`shi·
(
ønge
.
°¨t
)) }

29 
¶aveFn
 = { 
£q
 =>

30 
	`£q
(0).
	`c›y
(

31 
möL©ícy
 = 
£q
.
	`m≠
(
_
.möL©ícy).
mö
,

32 
wc‹ru±
 = 
£q
.
	`exi°s
(
_
.wcorrupt),

33 
¶aves
 = 
£q
.
Ê©M≠
 { 
p‹t
 =>

34 
	`ªquúe
 (
p‹t
.
bótByãs
 =
	`£q
(0).beatBytes,

35 
s
"Xbar data widths don't match: ${port.slaves.map(_.name)} has ${port.beatBytes}B vs ${seq(0).slaves.map(_.name)} has ${seq(0).beatBytes}B")

36 
p‹t
.
¶aves


41 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

42 
	`vÆ
 (
io_ö
, 
edgesIn
Ë
node
.
ö
.
unzù


43 
	`vÆ
 (
io_out
, 
edgesOut
Ë
node
.
out
.
unzù


46 
vÆ
 
öputIdR™ges
 = 
AXI4Xb¨
.
	`m≠I≈utIds
(
edgesIn
.
	`m≠
(
_
.
ma°î
))

49 
vÆ
 
p‹t_addrs
 = 
edgesOut
.
	`m≠
(
_
.
¶ave
.
¶aves
.m≠(_.
addªss
).
Ê©ãn
)

50 
vÆ
 
routögMask
 = 
	`AddªssDecodî
(
p‹t_addrs
)

51 
vÆ
 
rouã_addrs
 = 
p‹t_addrs
.
	`m≠
(
£q
 => 
AddªssSë
.
	`unify
(£q.m≠(
_
.
	`widí
(~
routögMask
)).
di°ö˘
))

52 
vÆ
 
ouçutP‹ts
 = 
rouã_addrs
.
	`m≠
(
£q
 => (
addr
: 
UI¡
Ë=> seq.m≠(
_
.
	`c⁄èös
◊ddr)).
	`ªdu˚
(_ || _))

55 
vÆ
 
awIn
 = 
Seq
.
	`fûl
(
io_ö
 .
size
Ë{ 
	`ModuÀ
(
√w
 
	`Queue
(
	`UI¡
(
width
 = 
io_out
.size), 
awQueueDïth
, 
Êow
 = 
åue
)) }

56 
vÆ
 
awOut
 = 
Seq
.
	`fûl
(
io_out
.
size
Ë{ 
	`ModuÀ
(
√w
 
	`Queue
(
	`UI¡
(
width
 = 
io_ö
 .size), 
awQueueDïth
, 
Êow
 = 
åue
)) }

58 
vÆ
 
ªque°ARIO
 = 
io_ö
.
m≠
 { 
i
 => 
	`Vec
(
ouçutP‹ts
.m≠ { 
o
 => 
	`o
(i.
¨
.
bôs
.
addr
) }) }

59 
vÆ
 
ªque°AWIO
 = 
io_ö
.
m≠
 { 
i
 => 
	`Vec
(
ouçutP‹ts
.m≠ { 
o
 => 
	`o
(i.
aw
.
bôs
.
addr
) }) }

60 
vÆ
 
ªque°ROI
 = 
io_out
.
m≠
 { 
o
 => 
öputIdR™ges
.m≠ { 
i
 => i.
	`c⁄èös
(o.
r
.
bôs
.
id
) } }

61 
vÆ
 
ªque°BOI
 = 
io_out
.
m≠
 { 
o
 => 
öputIdR™ges
.m≠ { 
i
 => i.
	`c⁄èös
(o.
b
.
bôs
.
id
) } }

64 
i
 <- 0 
u¡û
 
io_ö
.
size
Ë{ 
	`awIn
(i).
io
.
íq
.
bôs
 :
	`ªque°AWIO
(i).
asUI¡
 }

65 
vÆ
 
ªque°WIO
 = 
awIn
.
m≠
 { 
q
 => i‡(
io_out
.
size
 > 1Ëq.
io
.
deq
.
bôs
.
toBoﬁs
 
	`Seq
(
	`Boﬁ
(
åue
)) }

68 
vÆ
 
wide_bundÀ
 = 
AXI4BundÀP¨amëîs
.(
io_ö
.
	`m≠
(
_
.
∑øms
Ë++ 
io_out
.map(_.params))

71 
vÆ
 
ö
 = 
	`Wúe
(
	`Vec
(
io_ö
.
size
, 
	`AXI4BundÀ
(
wide_bundÀ
)))

72 
i
 <- 0 
u¡û
 
ö
.
size
) {

73 
	`ö
(
i
Ë<> 
	`io_ö
(i)

76 
def
 
	`åim
(
id
: 
UI¡
, 
size
: 
I¡
Ëi‡(sizê<1Ë
	`UI¡
(0Ë
	`id
(
	`log2Ceû
(size)-1, 0)

78 
vÆ
 
r
 = 
	`öputIdR™ges
(
i
)

79 
	`ö
(
i
).
aw
.
bôs
.
id
 :
	`io_ö
(i).aw.bôs.id | 
	`UI¡
(
r
.
°¨t
)

80 
	`ö
(
i
).
¨
.
bôs
.
id
 :
	`io_ö
(i).¨.bôs.id | 
	`UI¡
(
r
.
°¨t
)

81 
	`io_ö
(
i
).
r
.
bôs
.
id
 :
	`åim
(
	`ö
(i).r.bôs.id,Ñ.
size
)

82 
	`io_ö
(
i
).
b
.
bôs
.
id
 :
	`åim
(
	`ö
(i).b.bôs.id, 
r
.
size
)

84 i‡(
io_out
.
size
 > 1) {

86 
vÆ
 
ídId
 = 
	`edgesIn
(
i
).
ma°î
.endId

87 
vÆ
 
¨FIFOM≠
 = 
	`Wúe
(
öô
 = 
Vec
.
	`fûl
(
ídId
Ë{ 
	`Boﬁ
(
åue
) })

88 
vÆ
 
awFIFOM≠
 = 
	`Wúe
(
öô
 = 
Vec
.
	`fûl
(
ídId
Ë{ 
	`Boﬁ
(
åue
) })

89 
vÆ
 
¨Sñ
 = 
	`UI¡ToOH
(
	`io_ö
(
i
).
¨
.
bôs
.
id
, 
ídId
)

90 
vÆ
 
awSñ
 = 
	`UI¡ToOH
(
	`io_ö
(
i
).
aw
.
bôs
.
id
, 
ídId
)

91 
vÆ
 
rSñ
 = 
	`UI¡ToOH
(
	`io_ö
(
i
).
r
 .
bôs
.
id
, 
ídId
)

92 
vÆ
 
bSñ
 = 
	`UI¡ToOH
(
	`io_ö
(
i
).
b
 .
bôs
.
id
, 
ídId
)

93 
vÆ
 
¨Tag
 = 
	`OHToUI¡
(
	`ªque°ARIO
(
i
).
asUI¡
, 
io_out
.
size
)

94 
vÆ
 
awTag
 = 
	`OHToUI¡
(
	`ªque°AWIO
(
i
).
asUI¡
, 
io_out
.
size
)

96 
ma°î
 <- 
	`edgesIn
(
i
).ma°î.
ma°îs
) {

97 
def
 
	`idTøckî
(
p‹t
: 
UI¡
, 
ªq_fúe
: 
Boﬁ
, 
ª•_fúe
: Bool) = {

98 i‡(
ma°î
.
maxFlight
 =
	`Some
(0)) {

99 
	`Boﬁ
(
åue
)

101 
vÆ
 
ÀgÆFlight
 = 
ma°î
.
maxFlight
.
	`gëOrEl£
(
maxFlightPîId
+1)

102 
vÆ
 
Êight
 = 
ÀgÆFlight
 
mö
 
maxFlightPîId


103 
vÆ
 
ˇnOvîÊow
 = 
ÀgÆFlight
 > 
Êight


104 
vÆ
 
cou¡
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
	`log2Ceû
(
Êight
+1)))

105 
vÆ
 
œ°
 = 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Ceû
(
io_out
.
size
)))

106 
cou¡
 :cou¡ + 
ªq_fúe
.
asUI¡
 - 
ª•_fúe
.asUInt

107 
	`as£π
 (!
ª•_fúe
 || 
cou¡
 =/
	`UI¡
(0))

108 
	`as£π
 (!
ªq_fúe
 || 
cou¡
 =/
	`UI¡
(
Êight
))

109 
	`whí
 (
ªq_fúe
Ë{ 
œ°
 :
p‹t
 }

111 
vÆ
 
p‹tM©ch
 = i‡(
Êight
 =1Ë{ 
	`Boﬁ
(
åue
Ë} { 
œ°
 ==
p‹t
 }

112 (
cou¡
 ==
	`UI¡
(0Ë|| 
p‹tM©ch
Ë&& (
	`Boﬁ
(!
ˇnOvîÊow
Ë|| cou¡ =/UI¡(
Êight
))

116 
id
 <- 
ma°î
.id.
°¨t
 
u¡û
 ma°î.id.
íd
) {

117 
	`¨FIFOM≠
(
id
Ë:
	`idTøckî
(

118 
¨Tag
,

119 
	`¨Sñ
(
id
Ë&& 
	`io_ö
(
i
).
¨
.
	`fúe
(),

120 
	`rSñ
(
id
Ë&& 
	`io_ö
(
i
).
r
.
	`fúe
(Ë&& io_ö(i).r.
bôs
.
œ°
)

121 
	`awFIFOM≠
(
id
Ë:
	`idTøckî
(

122 
awTag
,

123 
	`awSñ
(
id
Ë&& 
	`io_ö
(
i
).
aw
.
	`fúe
(),

124 
	`bSñ
(
id
Ë&& 
	`io_ö
(
i
).
b
.
	`fúe
())

128 
vÆ
 
ÆlowAR
 = 
	`¨FIFOM≠
(
	`io_ö
(
i
).
¨
.
bôs
.
id
)

129 
	`ö
(
i
).
¨
.
vÆid
 :
	`io_ö
(i).¨.vÆid && 
ÆlowAR


130 
	`io_ö
(
i
).
¨
.
ªady
 :
	`ö
(i).¨.ªady && 
ÆlowAR


136 
vÆ
 
ÆlowAW
 = 
	`awFIFOM≠
(
	`io_ö
(
i
).
aw
.
bôs
.
id
)

137 
vÆ
 
œtched
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

138 
	`ö
(
i
).
aw
.
vÆid
 :
	`io_ö
(i).aw.vÆid && (
œtched
 || 
	`awIn
(i).
io
.
íq
.
ªady
Ë&& 
ÆlowAW


139 
	`io_ö
(
i
).
aw
.
ªady
 :
	`ö
(i).aw.ªady && (
œtched
 || 
	`awIn
(i).
io
.
íq
.ªadyË&& 
ÆlowAW


140 
	`awIn
(
i
).
io
.
íq
.
vÆid
 :
	`io_ö
(i).
aw
.vÆid && !
œtched


141 
	`whí
 (
	`awIn
(
i
).
io
.
íq
.
	`fúe
()Ë{ 
œtched
 :
	`Boﬁ
(
åue
) }

142 
	`whí
 (
	`ö
(
i
).
aw
.
	`fúe
()Ë{ 
œtched
 :
	`Boﬁ
(
Ál£
) }

145 
	`ö
(
i
).
w
.
vÆid
 :
	`io_ö
(i).w.vÆid && 
	`awIn
(i).
io
.
deq
.valid

146 
	`io_ö
(
i
).
w
.
ªady
 :
	`ö
(i).w.ªady && 
	`awIn
(i).
io
.
deq
.
vÆid


147 
	`awIn
(
i
).
io
.
deq
.
ªady
 :
	`io_ö
(i).
w
.
vÆid
 && io_ö(i).w.
bôs
.
œ°
 && 
	`ö
(i).w.ready

152 
vÆ
 
out
 = 
	`Wúe
(
	`Vec
(
io_out
.
size
, 
	`AXI4BundÀ
(
wide_bundÀ
)))

153 
i
 <- 0 
u¡û
 
out
.
size
) {

154 
	`io_out
(
i
Ë<> 
	`out
(i)

156 i‡(
io_ö
.
size
 > 1) {

158 
vÆ
 
œtched
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

159 
	`io_out
(
i
).
aw
.
vÆid
 :
	`out
(i).aw.vÆid && (
œtched
 || 
	`awOut
(i).
io
.
íq
.
ªady
)

160 
	`out
(
i
).
aw
.
ªady
 :
	`io_out
(i).aw.ªady && (
œtched
 || 
	`awOut
(i).
io
.
íq
.ready)

161 
	`awOut
(
i
).
io
.
íq
.
vÆid
 :
	`out
(i).
aw
.vÆid && !
œtched


162 
	`whí
 (
	`awOut
(
i
).
io
.
íq
.
	`fúe
()Ë{ 
œtched
 :
	`Boﬁ
(
åue
) }

163 
	`whí
 (
	`out
(
i
).
aw
.
	`fúe
()Ë{ 
œtched
 :
	`Boﬁ
(
Ál£
) }

166 
	`io_out
(
i
).
w
.
vÆid
 :
	`out
(i).w.vÆid && 
	`awOut
(i).
io
.
deq
.valid

167 
	`out
(
i
).
w
.
ªady
 :
	`io_out
(i).w.ªady && 
	`awOut
(i).
io
.
deq
.
vÆid


168 
	`awOut
(
i
).
io
.
deq
.
ªady
 :
	`out
(i).
w
.
vÆid
 && out(i).w.
bôs
.
œ°
 && 
	`io_out
(i).w.ready

173 
def
 
å™•o£
[
T
](
x
: 
Seq
[Seq[T]]ËSeq.
	`èbuœã
(
	`x
(0).
size
Ë{ 
i
 => Seq.èbuœã(x.sizeË{ 
j
 => x(j)(i) } }

174 
vÆ
 
p‹tsAROI
 = 
	`å™•o£
((
ö
 
zù
 
ªque°ARIO
Ë
m≠
 { (
i
, 
r
Ë=> 
AXI4Xb¨
.
	`Ánout
(i.
¨
,Ñ) })

175 
vÆ
 
p‹tsAWOI
 = 
	`å™•o£
((
ö
 
zù
 
ªque°AWIO
Ë
m≠
 { (
i
, 
r
Ë=> 
AXI4Xb¨
.
	`Ánout
(i.
aw
,Ñ) })

176 
vÆ
 
p‹tsWOI
 = 
	`å™•o£
((
ö
 
zù
 
ªque°WIO
Ë
m≠
 { (
i
, 
r
Ë=> 
AXI4Xb¨
.
	`Ánout
(i.
w
,Ñ) })

177 
vÆ
 
p‹tsRIO
 = 
	`å™•o£
((
out
 
zù
 
ªque°ROI
Ë
m≠
 { (
o
, 
r
Ë=> 
AXI4Xb¨
.
	`Ánout
(o.r,Ñ) })

178 
vÆ
 
p‹tsBIO
 = 
	`å™•o£
((
out
 
zù
 
ªque°BOI
Ë
m≠
 { (
o
, 
r
Ë=> 
AXI4Xb¨
.
	`Ánout
(o.
b
,Ñ) })

181 
o
 <- 0 
u¡û
 
out
.
size
) {

182 
	`awOut
(
o
).
io
.
íq
.
bôs
 :=

183 
AXI4Arbôî
.
	`ªtu∫Wö√r
(
¨bôøti⁄Pﬁicy
)(
	`out
(
o
).
aw
, 
	`p‹tsAWOI
(o):
_
*).
asUI¡


184 
	`AXI4Arbôî
(
¨bôøti⁄Pﬁicy
)(
	`out
(
o
).
¨
, 
	`p‹tsAROI
(o):
_
*)

186 
	`out
(
o
).
w
.
vÆid
 :
	`Mux1H
(
	`awOut
(o).
io
.
deq
.
bôs
, 
	`p‹tsWOI
(o).
	`m≠
(
_
.valid))

187 
	`out
(
o
).
w
.
bôs
 :
	`Mux1H
(
	`awOut
(o).
io
.
deq
.bôs, 
	`p‹tsWOI
(o).
	`m≠
(
_
.bits))

188 
	`p‹tsWOI
(
o
).
zùWôhIndex
.
m≠
 { (
p
, 
i
) =>

189 i‡(
ö
.
size
 > 1) {

190 
p
.
ªady
 :
	`out
(
o
).
w
.ªady && 
	`awOut
(o).
io
.
deq
.
	`bôs
(
i
)

192 
p
.
ªady
 :
	`out
(
o
).
w
.ready

197 
i
 <- 0 
u¡û
 
ö
.
size
) {

198 
	`AXI4Arbôî
(
¨bôøti⁄Pﬁicy
)(
	`ö
(
i
).
r
, 
	`p‹tsRIO
(i):
_
*)

199 
	`AXI4Arbôî
(
¨bôøti⁄Pﬁicy
)(
	`ö
(
i
).
b
, 
	`p‹tsBIO
(i):
_
*)

202 
	}
}

204 
obje˘
 
AXI4Xb¨


206 
def
 
≠∂y
(

207 
¨bôøti⁄Pﬁicy
: 
TLArbôî
.
Pﬁicy
 = TLArbôî.
roundRobö
,

208 
maxFlightPîId
: 
I¡
 = 7,

209 
awQueueDïth
: 
I¡
 = 2)(
im∂icô
 
p
: 
P¨amëîs
) =

211 
vÆ
 
axi4xb¨
 = 
LazyModuÀ
(
√w
 
AXI4Xb¨
(
¨bôøti⁄Pﬁicy
, 
maxFlightPîId
, 
awQueueDïth
))

212 
	gaxi4xb¨
.
	gnode


215 
def
 
m≠I≈utIds
(
p‹ts
: 
Seq
[
AXI4Ma°îP‹tP¨amëîs
]Ë
TLXb¨
.
assignR™ges
’‹ts.
m≠
(
_
.
ídId
))

218 
def
 
Ánout
[
T
 <: 
AXI4BundÀBa£
](
öput
: 
IºevoˇbÀIO
[T], 
	g£À˘
: 
Seq
[
Boﬁ
]) = {

219 
vÆ
 
fûãªd
 = 
Wúe
(
Vec
(
£À˘
.
size
, 
öput
))

220 
	gi
 <- 0 
u¡û
 
	g£À˘
.
	gsize
) {

221 
fûãªd
(
i
).
	gbôs
 :
öput
.
bôs


222 
fûãªd
(
i
).
vÆid
 :
öput
.vÆid && 
£À˘
(i)

224 
öput
.
ªady
 :
Mux1H
(
£À˘
, 
fûãªd
.
m≠
(
_
.ready))

225 
	gfûãªd


229 
obje˘
 
	gAXI4Arbôî


231 
def
 
	g≠∂y
[
T
 <: 
D©a
](
pﬁicy
: 
TLArbôî
.
Pﬁicy
)(
sök
: 
IºevoˇbÀIO
[T], 
	gsour˚s
: IrrevocableIO[T]*) {

232 i‡(
sour˚s
.
isEm±y
) {

233 
sök
.
vÆid
 :
Boﬁ
(
Ál£
)

235 
ªtu∫Wö√r
(
pﬁicy
)(
sök
, 
	gsour˚s
:
_
*)

238 
def
 
ªtu∫Wö√r
[
T
 <: 
D©a
](
pﬁicy
: 
TLArbôî
.
Pﬁicy
)(
sök
: 
IºevoˇbÀIO
[T], 
	gsour˚s
: IrrevocableIO[T]*) = {

239 
ªquúe
 (!
sour˚s
.
isEm±y
)

242 
vÆ
 
idÀ
 = 
RegInô
(
Boﬁ
(
åue
))

245 
vÆ
 
vÆids
 = 
sour˚s
.
m≠
(
_
.
vÆid
)

246 
vÆ
 
™yVÆid
 = 
vÆids
.
ªdu˚
(
_
 || _)

248 
vÆ
 
ªadys
 = 
Vec
(
pﬁicy
(
vÆids
.
size
, 
C©
(vÆids.
ªvî£
), 
idÀ
).
toBoﬁs
)

250 
vÆ
 
	gwö√r
 = 
Vec
((
ªadys
 
zù
 
vÆids
Ë
m≠
 { (
r
,
v
) =>Ñ&&v })

253 
ªquúe
 (
ªadys
.
size
 =
vÆids
.size)

255 
vÆ
 
¥efixOR
 = 
wö√r
.
sˇnLe·
(
Boﬁ
(
Ál£
))(
_
||_).
öô


256 
as£π
((
¥efixOR
 
zù
 
wö√r
Ë
m≠
 { (
p
,
w
Ë=> !∞|| !w } 
ªdu˚
 {
_
 && _})

258 
as£π
 (!
™yVÆid
 || 
wö√r
.
ªdu˚
(
_
||_))

261 
vÆ
 
	g°©e
 = 
RegInô
(
Vec
.
fûl
(
sour˚s
.
size
)(
Boﬁ
(
Ál£
)))

262 
vÆ
 
muxSèã
 = 
Mux
(
idÀ
, 
wö√r
, 
°©e
)

263 
	g°©e
 :
muxSèã


266 
whí
 (
™yVÆid
Ë{ 
idÀ
 :
Boﬁ
(
Ál£
) }

267 
whí
 (
sök
.
fúe
()Ë{ 
idÀ
 :
Boﬁ
(
åue
) }

269 i‡(
sour˚s
.
size
 > 1) {

270 
vÆ
 
Ælowed
 = 
Mux
(
idÀ
, 
ªadys
, 
°©e
)

271 (
sour˚s
 
zù
 
	gÆlowed
Ë
	gf‹óch
 { (
	gs
, 
	gr
) =>

272 
s
.
ªady
 :
sök
.ªady && 
r


275 
sour˚s
(0).
ªady
 :
sök
.ready

278 
sök
.
vÆid
 :
Mux
(
idÀ
, 
™yVÆid
, 
Mux1H
(
°©e
, 
vÆids
))

279 
	gsök
.
	gbôs
 :
Mux1H
(
muxSèã
, 
sour˚s
.
m≠
(
_
.
bôs
))

280 
	gmuxSèã


284 
˛ass
 
	$AXI4Xb¨FuzzTe°
(
«me
: 
Såög
, 
txns
: 
I¡
, 
nMa°îs
: I¡, 
nSœves
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


286 
vÆ
 
xb¨
 = 
	`AXI4Xb¨
()

287 
vÆ
 
¶aveSize
 = 0x1000

288 
vÆ
 
ma°îB™dSize
 = 
¶aveSize
 >> 
	`log2Ceû
(
nMa°îs
)

289 
def
 
	`fûãr
(
i
: 
I¡
Ë
TLFûãr
.
	`mSñe˘I¡î£˘
(
	`AddªssSë
(ò* 
ma°îB™dSize
, ~
	`BigI¡
(
¶aveSize
 - masterBandSize)))

291 
vÆ
 
¶aves
 = 
Seq
.
	`èbuœã
(
nSœves
Ë{ 
i
 => 
	`LazyModuÀ
(
√w
 
	`AXI4RAM
(
	`AddªssSë
(
¶aveSize
 * i, slaveSize-1))) }

292 
¶aves
.
f‹óch
 { 
s
 => (s.
node


293 :
	`AXI4Føgmíãr
()

294 :
	`AXI4Buf„r
(
Buf„rP¨ams
.
Êow
)

295 :
	`AXI4Buf„r
(
Buf„rP¨ams
.
Êow
)

296 :
	`AXI4Dñayî
(0.25)

297 :
xb¨
) }

299 
vÆ
 
ma°îs
 = 
Seq
.
	`fûl
(
nMa°îs
Ë{ 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
, 4, 
nOrdîed
 = 
	`Some
(1))) }

300 
ma°îs
.
zùWôhIndex
.
f‹óch
 { (
m
, 
i
Ë=> (
xb¨


301 :
	`AXI4Dñayî
(0.25)

302 :
	`AXI4Deöãæóvî
(4096)

303 :
	`TLToAXI4
()

304 :
	`TLFûãr
(
	`fûãr
(
i
))

305 :
	`TLRAMModñ
(
s
"${name} Master $i")

306 :
m
.
node
) }

308 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

309 
io
.
föished
 :
ma°îs
.
	`m≠
(
_
.
moduÀ
.io.föished).
	`ªdu˚
(_ || _)

311 
	}
}

313 
˛ass
 
	$AXI4Xb¨Te°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

314 
vÆ
 
dut21
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AXI4Xb¨FuzzTe°
("Xb¨ DUT21", 
txns
, 2, 1)).
moduÀ
)

315 
vÆ
 
dut12
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AXI4Xb¨FuzzTe°
("Xb¨ DUT12", 
txns
, 1, 2)).
moduÀ
)

316 
vÆ
 
dut22
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`AXI4Xb¨FuzzTe°
("Xb¨ DUT22", 
txns
, 2, 2)).
moduÀ
)

317 
io
.
föished
 :
	`Seq
(
dut21
, 
dut12
, 
dut22
).
	`m≠
(
_
.io.föished).
	`ªdu˚
(_ || _)

318 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/package.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
amba


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
∑ckage
 
obje˘
 
	gaxi4


10 
ty≥
 
	gAXI4Node
 = 
Sim∂eNodeH™dÀ
[
AXI4Ma°îP‹tP¨amëîs
, 
AXI4SœveP‹tP¨amëîs
, 
AXI4EdgeP¨amëîs
, 
AXI4BundÀ
]

11 
ty≥
 
	gAXI4Outw¨dNode
 = 
Outw¨dNodeH™dÀ
[
AXI4Ma°îP‹tP¨amëîs
, 
AXI4SœveP‹tP¨amëîs
, 
AXI4EdgeP¨amëîs
, 
AXI4BundÀ
]

12 
ty≥
 
	gAXI4Inw¨dNode
 = 
Inw¨dNodeH™dÀ
[
AXI4Ma°îP‹tP¨amëîs
, 
AXI4SœveP‹tP¨amëîs
, 
AXI4EdgeP¨amëîs
, 
AXI4BundÀ
]

14 
im∂icô
 cœs†
	cAXI4ClockDomaöCrossög
(
vÆ
 
x
: 
HasClockDomaöCrossög
Ë
exãnds
 
AnyVÆ
 {

15 
def
 
	`¸ossIn
 (
n
: 
AXI4Inw¨dNode
Ë(
im∂icô
 
vÆName
: 
VÆName
Ë
	`AXI4Inw¨dCrossögHñ≥r
(vÆName.
«me
, 
x
,Ç)

16 
def
 
	`¸ossOut
(
n
: 
AXI4Outw¨dNode
)(
im∂icô
 
vÆName
: 
VÆName
Ë
	`AXI4Outw¨dCrossögHñ≥r
(vÆName.
«me
, 
x
,Ç)

17 
def
 
	`¸oss
(
n
: 
AXI4Inw¨dNode
Ë(
im∂icô
 
vÆName
: 
VÆName
Ë
	`¸ossIn
(n)

18 
def
 
	`¸oss
(
n
: 
AXI4Outw¨dNode
)(
im∂icô
 
vÆName
: 
VÆName
Ë
	`¸ossOut
(n)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/config/Config.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
c⁄fig


5 
ab°ø˘
 
˛ass
 
	gFõld
[
T
] 
	$¥iv©e
 (
vÆ
 : 
O±i⁄
[
T
])

7 
def
 
	`this
(Ëthis(
N⁄e
)

8 
def
 
	`this
(: 
T
Ëthis(
	`Some
())

9 
	}
}

11 
ab°ø˘
 cœs†
	cVõw
 {

12 
föÆ
 
def
 
≠∂y
[
T
](
≤ame
: 
Fõld
[T]): T = 
	$≠∂y
(
≤ame
, 
this
)

13 
föÆ
 
def
 
≠∂y
[
T
](
≤ame
: 
Fõld
[T], 
sôe
: 
Võw
): T = {

14 
vÆ
 
out
 = 
	`föd
(
≤ame
, 
sôe
)

15 
	`ªquúe
 (
out
.
isDeföed
, 
s
"Key ${pname} isÇot defined in Parameters")

16 
out
.
gë


19 
föÆ
 
def
 
li·
[
T
](
≤ame
: 
Fõld
[T]): 
O±i⁄
[T] = 
	$li·
(
≤ame
, 
this
)

20 
föÆ
 
def
 
li·
[
T
](
≤ame
: 
Fõld
[T], 
sôe
: 
Võw
): 
O±i⁄
[T] = 
	`föd
’«me, sôe).
	$m≠
(
_
.
asIn°™˚Of
[
T
])

22 
¥Ÿe˘ed
[
c⁄fig
] 
def
 
föd
[
T
](
≤ame
: 
Fõld
[T], 
sôe
: 
Võw
): 
O±i⁄
[T]

23 
	}
}

25 
ab°ø˘
 cœs†
	cP¨amëîs
 
exãnds
 
Võw
 {

26 
föÆ
 
def
 ++ (
x
: 
P¨amëîs
): Parameters =

27 
√w
 
	$ChaöP¨amëîs
(
this
, 
x
)

29 
föÆ
 
def
 
	`Æãr
(
f
: (
Võw
, Võw, VõwË=> 
P¨tülFun˘i⁄
[
Any
,Any]): 
P¨amëîs
 =

30 
	`P¨amëîs
(
f
Ë++ 
this


32 
föÆ
 
def
 
	$ÆãrP¨tül
(
f
: 
P¨tülFun˘i⁄
[
Any
,Any]): 
P¨amëîs
 =

33 
	`P¨amëîs
((
_
,_,_Ë=> 
f
Ë++ 
this


35 
föÆ
 
def
 
	$ÆãrM≠
(
m
: 
M≠
[
Any
,Any]): 
P¨amëîs
 =

36 
√w
 
	`M≠P¨amëîs
(
m
Ë++ 
this


38 
¥Ÿe˘ed
[
c⁄fig
] 
def
 
chaö
[
T
](
sôe
: 
Võw
, 
èû
: Võw, 
≤ame
: 
Fõld
[T]): 
O±i⁄
[T]

39 
¥Ÿe˘ed
[
c⁄fig
] 
def
 
föd
[
T
](
≤ame
: 
Fõld
[T], 
sôe
: 
Võw
Ë
	`chaö
(sôe, 
√w
 
TîmöÆVõw
,Öname)

42 
obje˘
 
P¨amëîs
 {

43 
def
 
em±y
: 
P¨amëîs
 = 
√w
 
Em±yP¨amëîs


44 
def
 
	`≠∂y
(
f
: (
Võw
, Võw, VõwË=> 
P¨tülFun˘i⁄
[
Any
,Any]): 
P¨amëîs
 = 
√w
 
	`P¨tülP¨amëîs
(f)

45 
	}
}

47 ˛as†
	cC⁄fig
(
p
: 
P¨amëîs
Ë
exãnds
 Parameters {

48 
def
 
	`this
(
f
: (
Võw
, Võw, VõwË=> 
P¨tülFun˘i⁄
[
Any
,Any]Ëthis(
	$P¨amëîs
(
f
))

50 
¥Ÿe˘ed
[
c⁄fig
] 
def
 
chaö
[
T
](
sôe
: 
Võw
, 
èû
: Võw, 
≤ame
: 
Fõld
[T]Ë
p
.
	$chaö
(
sôe
, 
èû
, 
≤ame
)

51 
ovîride
 
def
 
toSåög
 = 
this
.
gëCœss
.
gëSim∂eName


52 
def
 
toIn°™˚
 = 
this


57 
¥iv©e
 cœs†
	cTîmöÆVõw
 
exãnds
 
Võw
 {

58 
def
 
föd
[
T
](
≤ame
: 
Fõld
[T], 
sôe
: 
Võw
): 
O±i⁄
[T] =Öname.

61 
¥iv©e
 
˛ass
 
	$ChaöVõw
(
hód
: 
P¨amëîs
, 
èû
: 
Võw
Ë
exãnds
 View {

62 
def
 
föd
[
T
](
≤ame
: 
Fõld
[T], 
sôe
: 
Võw
Ë
hód
.
	`chaö
(sôe, 
èû
,Öname)

63 
	}
}

65 
¥iv©e
 
˛ass
 
	$ChaöP¨amëîs
(
x
: 
P¨amëîs
, 
y
: P¨amëîsË
exãnds
 Parameters {

66 
def
 
chaö
[
T
](
sôe
: 
Võw
, 
èû
: Võw, 
≤ame
: 
Fõld
[T]Ë
x
.
	`chaö
(sôe, 
√w
 
	`ChaöVõw
(
y
,Åail),Öname)

67 
	}
}

69 
¥iv©e
 cœs†
	cEm±yP¨amëîs
 
exãnds
 
	mP¨amëîs
 {

70 
def
 
	mchaö
[
T
](
	msôe
: 
Võw
, 
	mèû
: Võw, 
	m≤ame
: 
Fõld
[T]Ë
èû
.
föd
(
≤ame
, 
sôe
)

73 
¥iv©e
 
˛ass
 
P¨tülP¨amëîs
(
f
: (
Võw
, Võw, VõwË=> 
P¨tülFun˘i⁄
[
Any
,Any]Ë
exãnds
 
	gP¨amëîs
 {

74 
	g¥Ÿe˘ed
[
c⁄fig
] 
def
 
	gchaö
[
T
](
	gsôe
: 
Võw
, 
	gèû
: Võw, 
	g≤ame
: 
Fõld
[T]) = {

75 
vÆ
 
g
 = 
f
(
sôe
, 
this
, 
èû
)

76 i‡(
	gg
.
isDeföedAt
(
≤ame
)Ë
Some
(
g
.
≠∂y
’«me).
asIn°™˚Of
[
T
]Ë
	gèû
.
föd
’«me, 
sôe
)

80 
¥iv©e
 
˛ass
 
	$M≠P¨amëîs
(
m≠
: 
M≠
[
Any
, Any]Ë
exãnds
 
P¨amëîs
 {

81 
¥Ÿe˘ed
[
c⁄fig
] 
def
 
chaö
[
T
](
sôe
: 
Võw
, 
èû
: Võw, 
≤ame
: 
Fõld
[T]) = {

82 
vÆ
 
g
 = 
m≠
.
	`gë
(
≤ame
)

83 i‡(
g
.
isDeföed
Ë
	`Some
(g.
gë
.
asIn°™˚Of
[
T
]Ë
èû
.
	`föd
(
≤ame
, 
sôe
)

85 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Custom.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gc‹e
.{
	gI≈ut
, 
	gOuçut
}

7 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.{
	gLazyModuÀ
, 
	gLazyModuÀImp
, 
	gNexusNode
, 
	gRídîedEdge
,

9 
	gSim∂eNodeImp
, 
	gSökNode
, 
	gSour˚Node
, 
	gVÆName
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


12 
˛ass
 
	$DebugCu°omP¨ams
(

13 
addrs
: 
Li°
[
I¡
],

14 
width
: 
I¡


16 
	`ªquúe
 (
width
 % 8 =0, 
s
"Currently only support custom debug widths whicháre multiples of 8,Çot ${width}")

17 
	}
}

19 ˛as†
	cDebugCu°omNuŒ
()

21 ˛as†
	cDebugCu°omBundÀ
(
vÆ
 
p
: 
DebugCu°omP¨ams
Ë
exãnds
 
BundÀ
 {

22 
vÆ
 
addr
 = 
	`I≈ut
(
	`UI¡
(
	`log2Up
(
p
.
addrs
.
	$fﬁdLe·
(0){
_
 
max
 _}).
W
))

23 
vÆ
 
d©a
 = 
	`Ouçut
(
	$UI¡
(
p
.
width
.
W
))

24 
vÆ
 
ªady
 = 
	`Ouçut
(
	$Boﬁ
())

25 
vÆ
 
vÆid
 = 
	`I≈ut
(
	`Boﬁ
())

26 
	}
}

28 
˛ass
 
DebugCu°omImp
 
exãnds
 
Sim∂eNodeImp
[
DebugCu°omP¨ams
, 
DebugCu°omNuŒ
, DebugCu°omP¨ams, 
DebugCu°omBundÀ
] {

30 
def
 
edge
(
pd
: 
DebugCu°omP¨ams
, 
pu
: 
DebugCu°omNuŒ
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
) =Öd

31 
def
 
bundÀ
(
e
: 
DebugCu°omP¨ams
Ë
√w
 
DebugCu°omBundÀ
(e)

32 
def
 
ªndî
(
e
: 
DebugCu°omP¨ams
Ë
RídîedEdge
(
cﬁour
 = "#20B2AA" )

37 
˛ass
 
	$DebugCu°omSök
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$SökNode
(
√w
 
DebugCu°omImp
)(
pi
 = 
	`Seq
(
	$DebugCu°omNuŒ
()))

40 
˛ass
 
	$DebugCu°omSour˚
(
¢o›abÀ
: 
DebugCu°omP¨ams
)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$Sour˚Node
(
√w
 
DebugCu°omImp
)(
	$Seq
(
¢o›abÀ
))

43 
˛ass
 
	`DebugCu°omNexusNode
(

44 
sour˚Fn
: 
Seq
[
DebugCu°omP¨ams
] => DebugCustomParams,

45 
sökFn
 : 
Seq
[
DebugCu°omNuŒ
] => DebugCustomNull,

46 
öputRequúesOuçut
: 
Boﬁón
 = 
åue
,

47 
ouçutRequúesI≈ut
: 
Boﬁón
 = 
åue


48 )–
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$NexusNode
(
√w
 
DebugCu°omImp
Ë(
sour˚Fn
, 
sökFn
, 
öputRequúesOuçut
, 
ouçutRequúesI≈ut
)

50 
˛ass
 
	$DebugCu°omXb¨
(

51 
öputRequúesOuçut
: 
Boﬁón
 = 
åue
,

52 
ouçutRequúesI≈ut
: 
Boﬁón
 = 
åue


53 )(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

54 
vÆ
 
node
 = 
	`DebugCu°omNexusNode
(

55 
sour˚Fn
 = { 
£q
 =>

56 i‡(
£q
.
size
 == 0) {

57 
	`DebugCu°omP¨ams
(
Nû
, 0)

59 
vÆ
 
Æl_addrs
 = 
£q
.
m≠
{
_
.
addrs
}.
Ê©ãn


60 
	`ªquúe
(
Æl_addrs
.
size
 =Æl_addrs.
di°ö˘
.size, "Different Custom sources can't useÅhe sameáddresses.")

61 
vÆ
 
max_width
 = 
£q
.
	`fﬁdLe·
(0){(
ªsu…
, 
cuºít
Ë=>Ñesu… 
max
 cuºít.
width
}

62 
	`DebugCu°omP¨ams
(
Æl_addrs
.
toLi°
, 
max_width
)

65 
sökFn
 = { 
£q
 => 
√w
 
	`DebugCu°omNuŒ
()},

66 
öputRequúesOuçut
,

67 
ouçutRequúesI≈ut


70 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

72 
	`ªquúe
(
node
.
out
.
size
 == 1, "Must haveÉxactly one sinkÇode,Çot ${node.out.size}")

74 
	`vÆ
 (
sök
, 
sökP¨am
Ë
node
.
out
.
hód


75 
	`vÆ
 (
sour˚s
, 
sour˚P¨ams
Ë
node
.
ö
.
unzù


76 
vÆ
 
decoded
 = 
sour˚P¨ams
.
m≠
 { 
x
 => x.
addrs
.
	`fﬁdLe·
(
Ál£
.
B
Ë{ (
ªsu…
, 
cuºít
Ë=>Ñesu… || cuºít.
U
 ==
sök
.
addr
}}

77 
sour˚s
.
zùWôhIndex
.
f‹óch
 { (
sour˚
, 
i
) =>

78 
sour˚
.
addr
 :
sök
.addr

80 
sour˚
.
vÆid
 :
sök
.vÆid & 
	`decoded
(
i
)

83 
sök
.
ªady
 :(
decoded
 
zù
 
sour˚s
).
	`fﬁdLe·
(
Ál£
.
B
){(
ªsu…
, (
d
, 
i
)) =>Ñesult || (d & i.ready)}

84 
sök
.
d©a
 :(
decoded
 
zù
 
sour˚s
).
	`fﬁdLe·
(0.U){ (
ªsu…
, (
d
, 
i
)Ë=>Ñesu… | 
	`Mux
(i.
ªady
, i.data, 0.U)}

87 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DMI.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


15 
obje˘
 
	gDMIC⁄°s
{

17 
def
 
	gdmiD©aSize
 = 32

19 
def
 
dmiOpSize
 = 2

20 
def
 
dmi_OP_NONE
 = "b00".
U


21 
def
 
dmi_OP_READ
 = "b01".
U


22 
def
 
dmi_OP_WRITE
 = "b10".
U


24 
def
 
dmiRe•Size
 = 2

25 
def
 
dmi_RESP_SUCCESS
 = "b00".
U


26 
def
 
dmi_RESP_FAILURE
 = "b01".
U


27 
def
 
dmi_RESP_HW_FAILURE
 = "b10".
U


30 
def
 
dmi_RESP_RESERVED
 = "b11".
U


40 ˛as†
	cDMIReq
(
addrBôs
 : 
I¡
Ë
exãnds
 
BundÀ
 {

41 
vÆ
 
addr
 = 
	$UI¡
(
addrBôs
.
W
)

42 
vÆ
 
d©a
 = 
	$UI¡
(
DMIC⁄°s
.
dmiD©aSize
.
W
)

43 
vÆ
 
›
 = 
	$UI¡
(
DMIC⁄°s
.
dmiOpSize
.
W
)

45 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`DMIReq
(
addrBôs
).
asIn°™˚Of
[
this
.
ty≥
]

50 ˛as†
	cDMIRe•
–Ë
exãnds
 
BundÀ
 {

51 
vÆ
 
d©a
 = 
	$UI¡
(
DMIC⁄°s
.
dmiD©aSize
.
W
)

52 
vÆ
 
ª•
 = 
	`UI¡
(
DMIC⁄°s
.
dmiRe•Size
.
W
)

60 ˛as†
	cDMIIO
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
) {

61 
vÆ
 
ªq
 = 
√w
 
	`Decou∂edIO
“ew 
	`DMIReq
(
	`p
(
DebugModuÀP¨ams
).
nDMIAddrSize
))

62 
vÆ
 
ª•
 = 
√w
 
	`Decou∂edIO
“ew 
DMIRe•
).
	`Êù
()

70 ˛as†
	cClockedDMIIO
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
){

71 
vÆ
 
dmi
 = 
√w
 
	$DMIIO
()(
p
)

72 
vÆ
 
dmiClock
 = 
	$Clock
(
OUTPUT
)

73 
vÆ
 
dmiRe£t
 = 
	`Boﬁ
(
OUTPUT
)

80 ˛as†
	cDMIToTL
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

82 
vÆ
 
node
 = 
	`TLClõ¡Node
(
	`Seq
(
	`TLClõ¡P‹tP¨amëîs
(Seq(
	`TLClõ¡P¨amëîs
("debug")))))

84 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

85 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

86 
vÆ
 
dmi
 = 
√w
 
	`DMIIO
()(
p
).
	`Êù
()

89 
	`vÆ
 (
é
, 
edge
Ë
node
.
	`out
(0)

91 
vÆ
 
§c
 = 
	`Wúe
(
öô
 = 0.U)

92 
vÆ
 
addr
 = 
	`Wúe
(
öô
 = (
io
.
dmi
.
ªq
.
bôs
.addr << 2))

93 
vÆ
 
size
 = (
	`log2Ceû
(
DMIC⁄°s
.
dmiD©aSize
 / 8)).
U


95 
	`vÆ
 (
_
, 
gbôs
Ë
edge
.
	`Gë
(
§c
, 
addr
, 
size
)

96 
	`vÆ
 (
_
, 
pfbôs
Ë
edge
.
	`Put
(
§c
, 
addr
, 
size
, 
io
.
dmi
.
ªq
.
bôs
.
d©a
)

104 
	`vÆ
 (
_
, 
nbôs
Ë
edge
.
	`Put
(
§c
, 
toAddªss
 = (
DMI_RegAddrs
.
DMI_DMCONTROL
 << 2).
U
, 
size
, 
d©a
=0.U, 
mask
 = 0.U)

106 
	`whí
 (
io
.
dmi
.
ªq
.
bôs
.
›
 ==
DMIC⁄°s
.
dmi_OP_WRITE
Ë{ 
é
.
a
.bô†:
pfbôs


107 }.
	`ñ£whí
 (
io
.
dmi
.
ªq
.
bôs
.
›
 ==
DMIC⁄°s
.
dmi_OP_READ
Ë{ 
é
.
a
.bô†:
gbôs


108 }.
Ÿhîwi£
 { 
é
.
a
.
bôs
 :
nbôs


111 
é
.
a
.
vÆid
 :
io
.
dmi
.
ªq
.valid

112 
io
.
dmi
.
ªq
.
ªady
 :
é
.
a
.ready

114 
io
.
dmi
.
ª•
.
vÆid
 :
é
.
d
.valid

115 
é
.
d
.
ªady
 :
io
.
dmi
.
ª•
.ready

116 
io
.
dmi
.
ª•
.
bôs
.ª• :
	`Mux
(
é
.
d
.bôs.
c‹ru±
 ||Ål.d.bôs.
díõd
, 
DMIC⁄°s
.
dmi_RESP_FAILURE
, DMIC⁄°s.
dmi_RESP_SUCCESS
)

117 
io
.
dmi
.
ª•
.
bôs
.
d©a
 :
é
.
d
.bits.data

120 
é
.
b
.
ªady
 :
Ál£
.
B


121 
é
.
c
.
vÆid
 :
Ál£
.
B


122 
é
.
e
.
vÆid
 :
Ál£
.
B


125 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Debug.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
In°ru˘i⁄s


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.
	gsy°embußc˚ss
.
_


16 
obje˘
 
	gDsbBusC⁄°s
 {

17 
def
 
	gsbAddrWidth
 = 12

18 
def
 
sbIdWidth
 = 10

22 
obje˘
 
	gDsbRegAddrs
{

25 
def
 
	gHALTED
 = 0x100

26 
def
 
GOING
 = 0x104

27 
def
 
RESUMING
 = 0x108

28 
def
 
EXCEPTION
 = 0x10C

30 
def
 
WHERETO
 = 0x300

36 
def
 
DATA
 = 0x380

41 
def
 
PROGBUF
(
cfg
:
DebugModuÀP¨ams
) = {

42 
vÆ
 
tmp
 = 
DATA
 - (
cfg
.
nProgømBuf„rW‹ds
 * 4)

43 i‡(
cfg
.
hasIm∂icôEbªak
Ë(
tmp
 - 4) tmp

46 
def
 
IMPEBREAK
(
cfg
: 
DebugModuÀP¨ams
Ë{ 
DATA
 - 4 }

50 
def
 
ABSTRACT
(
cfg
:
DebugModuÀP¨ams
Ë
PROGBUF
(cfg) - 8

52 
def
 
FLAGS
 = 0x400

53 
def
 
ROMBASE
 = 0x800

61 
obje˘
 
DebugModuÀAc˚ssTy≥
 
exãnds
 
sˇœ
.
Enumî©i⁄
 {

62 
ty≥
 
DebugModuÀAc˚ssTy≥
 = 
VÆue


63 
vÆ
 
Ac˚ss8Bô
, 
	gAc˚ss16Bô
, 
	gAc˚ss32Bô
, 
	gAc˚ss64Bô
, 
	gAc˚ss128Bô
 = 
VÆue


65 
imp‹t
 
	gDebugModuÀAc˚ssTy≥
.
_


67 
obje˘
 
DebugAb°ø˘Comm™dEº‹
 
exãnds
 
	gsˇœ
.
	gEnumî©i⁄
 {

68 
ty≥
 
	gDebugAb°ø˘Comm™dEº‹
 = 
VÆue


69 
vÆ
 
Suc˚ss
, 
	gEºBusy
, 
	gEºNŸSuµ‹ãd
, 
	gEºEx˚±i⁄
, 
	gEºHÆtResume
 = 
VÆue


71 
imp‹t
 
	gDebugAb°ø˘Comm™dEº‹
.
_


73 
obje˘
 
DebugAb°ø˘Comm™dTy≥
 
exãnds
 
	gsˇœ
.
	gEnumî©i⁄
 {

74 
ty≥
 
	gDebugAb°ø˘Comm™dTy≥
 = 
VÆue


75 
vÆ
 
Ac˚ssRegi°î
, 
	gQuickAc˚ss
 = 
VÆue


77 
imp‹t
 
	gDebugAb°ø˘Comm™dTy≥
.
	g_


96 
˛ass
 
	$DebugModuÀP¨ams
 (

97 
nDMIAddrSize
 : 
I¡
 = 7,

98 
nProgømBuf„rW‹ds
: 
I¡
 = 16,

99 
nAb°ø˘D©aW‹ds
 : 
I¡
 = 4,

100 
nS¸©ch
 : 
I¡
 = 1,

101 
hasBusMa°î
 : 
Boﬁón
 = 
Ál£
,

102 
maxSuµ‹ãdSBAc˚ss
 : 
I¡
 = 32,

103 
suµ‹tQuickAc˚ss
 : 
Boﬁón
 = 
Ál£
,

104 
suµ‹tH¨tAºay
 : 
Boﬁón
 = 
Ál£
,

105 
hasIm∂icôEbªak
 : 
Boﬁón
 = 
Ál£


108 
	`ªquúe
 ((
nDMIAddrSize
 >7Ë&& (nDMIAddrSizê<32), 
s
"Legal DMIAddrSize is 7-32,Çot ${nDMIAddrSize}")

110 
	`ªquúe
 ((
nAb°ø˘D©aW‹ds
 > 0Ë&& (nAb°ø˘D©aW‹d†<16), 
s
"LegalÇAbstractDataWords is 0-16,Çot ${nAbstractDataWords}")

111 
	`ªquúe
 ((
nProgømBuf„rW‹ds
 >0Ë&& (nProgømBuf„rW‹d†<16), 
s
"LegalÇProgramBufferWords is 0-16,Çot ${nProgramBufferWords}")

113 i‡(
suµ‹tQuickAc˚ss
) {

117 
	}
}

119 
obje˘
 
	gDeÁu…DebugModuÀP¨ams
 {

121 
def
 
≠∂y
(
xÀn
:
I¡
 ): 
DebugModuÀP¨ams
 = {

122 
√w
 
DebugModuÀP¨ams
().
c›y
(

123 
nAb°ø˘D©aW‹ds
 = (i‡(
xÀn
 == 32) 1 if (xlen == 64) 2 4),

124 
maxSuµ‹ãdSBAc˚ss
 = 
xÀn


130 
obje˘
 
DebugModuÀP¨ams
 
exãnds
 
	gFõld
[DebugModuleParams]

137 
˛ass
 
DebugModuÀH¨tSñFuncs
 (

138 
h¨tIdToH¨tSñ
 : (
UI¡
Ë=> UI¡ = (
x
:UInt) => x,

139 
h¨tSñToH¨tId
 : (
UI¡
Ë=> UI¡ = (
x
:UInt) => x

142 
obje˘
 
DebugModuÀH¨tSñKey
 
exãnds
 
Fõld
(
	$DebugModuÀH¨tSñFuncs
())

152 ˛as†
	cDebugI¡î«lBundÀ
 ()(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
) {

153 
vÆ
 
ªsumîeq
 = 
	$Boﬁ
()

154 
vÆ
 
h¨t£l
 = 
	$UI¡
(10.
W
)

155 
vÆ
 
ackhavîe£t
 = 
	`Boﬁ
()

161 ˛as†
	cDebugCålBundÀ
 (
nComp⁄íts
: 
I¡
)(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
) {

162 
vÆ
 
debugU«vaû
 = 
	`Vec
(
nComp⁄íts
, 
	`Boﬁ
()).
asI≈ut


163 
vÆ
 
ndª£t
 = 
	$Boﬁ
(
OUTPUT
)

164 
vÆ
 
dma˘ive
 = 
	`Boﬁ
(
OUTPUT
)

197 
obje˘
 
WNŸifyWúe
 {

198 
def
 
	`≠∂y
(
n
: 
I¡
, 
vÆue
: 
UI¡
, 
£t
: 
Boﬁ
, 
«me
: 
Såög
, 
desc
: SåögË: 
RegFõld
 = {

199 
	`RegFõld
(
n
, 
	`UI¡
(0), 
	`RegWrôeFn
((
vÆid
, 
d©a
) => {

200 
£t
 :
vÆid


201 
vÆue
 :
d©a


202 
	`Boﬁ
(
åue
)

203 }), 
	`Some
(
	`RegFõldDesc
(
«me
 =Çame, 
desc
 = desc,

204 
ac˚ss
 = 
RegFõldAc˚ssTy≥
.
W
)))

206 
	}
}

209 
obje˘
 
	gRWNŸify
 {

210 
def
 
≠∂y
 (
n
: 
I¡
, 
rVÆ
: 
UI¡
, 
wVÆ
: UI¡, 
rNŸify
: 
Boﬁ
, 
wNŸify
: Boﬁ, 
desc
: 
O±i⁄
[
RegFõldDesc
] = 
N⁄e
): 
RegFõld
 = {

211 
RegFõld
(
n
,

212 
RegRódFn
 ((
ªady
Ë=> {
rNŸify
 :ªady ; (
Boﬁ
(
åue
), 
rVÆ
)}),

213 
RegWrôeFn
((
vÆid
, 
d©a
) => {

214 
wNŸify
 :
vÆid


215 
whí
 (
vÆid
Ë{
wVÆ
 :
d©a
}

216 
Boﬁ
(
åue
)

218 ), 
desc
)

222 ˛as†
	cTLDebugModuÀOuãr
(
devi˚
: 
Devi˚
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

225 
imp‹t
 
DMI_RegAddrs
.
_


227 
vÆ
 
öäode
 = 
	`I¡NexusNode
(

228 
sour˚Fn
 = { 
_
 => 
	`I¡Sour˚P‹tP¨amëîs
(
	`Seq
(
	`I¡Sour˚P¨amëîs
(1, Seq(
	`Resour˚
(
devi˚
, "int"))))) },

229 
sökFn
 = { 
_
 => 
	`I¡SökP‹tP¨amëîs
(
	`Seq
(
	`I¡SökP¨amëîs
())Ë
	}
},

230 
	gouçutRequúesI≈ut
 = 
Ál£
)

232 
vÆ
 
dmiNode
 = 
TLRegi°îNode
 (

233 
addªss
 = 
AddªssSë
.
mißlig√d
(
DMI_DMCONTROL
 << 2, 4),

234 
devi˚
 = device,

235 
bótByãs
 = 4,

236 
execuèbÀ
 = 
Ál£


239 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

240 
	`ªquúe
 (
öäode
.
edges
.
ö
.
size
 == 0, "Debug Module doesÇotáccept interrupts")

242 
vÆ
 
nComp⁄íts
 = 
öäode
.
out
.
size


244 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

245 
vÆ
 
˘æ
 = (
√w
 
	`DebugCålBundÀ
(
nComp⁄íts
))

246 
vÆ
 
ö√rCål
 = 
√w
 
	`Decou∂edIO
“ew 
	`DebugI¡î«lBundÀ
())

254 
vÆ
 
DMCONTROLRe£t
 = 
	`Wúe
(
öô
 = (
√w
 
	`DMCONTROLFõlds
().
	`‰omBôs
(0.U)))

255 
vÆ
 
DMCONTROLNxt
 = 
	`Wúe
(
öô
 = 
√w
 
	`DMCONTROLFõlds
().
	`‰omBôs
(0.U))

257 
vÆ
 
DMCONTROLReg
 = 
	`Wúe
(
öô
 = 
√w
 
	`DMCONTROLFõlds
().
	`‰omBôs
(
	`AsyncRe£tReg
(
upd©eD©a
 = 
DMCONTROLNxt
.
asUI¡
,

258 
ª£tD©a
 = 
	`BigI¡
(0),

259 
íabÀ
 = 
åue
.
B
,

260 
«me
 = "DMCONTROL"

263 
vÆ
 
DMCONTROLRdD©a
 = 
	`Wúe
(
öô
 = 
DMCONTROLReg
)

265 
vÆ
 
DMCONTROLWrD©aVÆ
 = 
	`Wúe
(
öô
 = 0.U(32.
W
))

266 
vÆ
 
DMCONTROLWrD©a
 = (
√w
 
	`DMCONTROLFõlds
()).
	`‰omBôs
(
DMCONTROLWrD©aVÆ
)

267 
vÆ
 
DMCONTROLWrEn
 = 
	`Wúe
(
öô
 = 
Ál£
.
B
)

268 
vÆ
 
DMCONTROLRdEn
 = 
	`Wúe
(
öô
 = 
Ál£
.
B
)

270 
vÆ
 
dma˘ive
 = 
DMCONTROLReg
.dmactive

272 
DMCONTROLNxt
 :
DMCONTROLReg


273 
	`whí
 (~
dma˘ive
) {

274 
DMCONTROLNxt
 :
DMCONTROLRe£t


275 } .
Ÿhîwi£
 {

276 
	`whí
 (
DMCONTROLWrEn
) {

277 
DMCONTROLNxt
.
ndmª£t
 :
DMCONTROLWrD©a
.ndmreset

278 
DMCONTROLNxt
.
h¨t£Œo
 :
DMCONTROLWrD©a
.hartsello

279 
DMCONTROLNxt
.
hÆåeq
 :
DMCONTROLWrD©a
.haltreq

280 
DMCONTROLNxt
.
ªsumîeq
 :
DMCONTROLWrD©a
.resumereq

281 
DMCONTROLNxt
.
ackhavîe£t
 :
DMCONTROLWrD©a
.ackhavereset

286 
	`whí
 (
DMCONTROLWrEn
) {

287 
DMCONTROLNxt
.
dma˘ive
 :
DMCONTROLWrD©a
.dmactive

291 
dmiNode
.
	`ªgm≠
(

292 0 -> 
	`Seq
(
	`RWNŸify
(32, 
DMCONTROLRdD©a
.
	`asUI¡
(),

293 
DMCONTROLWrD©aVÆ
, 
DMCONTROLRdEn
, 
DMCONTROLWrEn
, 
	`Some
(
	`RegFõldDesc
("dmi_dmc⁄åﬁ", "", 
ª£t
=Some(0)))))

300 
vÆ
 
debugI¡Nxt
 = 
	`Wúe
(
öô
 = 
Vec
.
	`fûl
(
nComp⁄íts
){
Ál£
.
B
})

301 
vÆ
 
debugI¡Regs
 = 
	`Wúe
(
öô
 = 
	`Vec
(
	`AsyncRe£tReg
(
upd©eD©a
 = 
debugI¡Nxt
.
asUI¡
,

302 
ª£tD©a
 = 0,

303 
íabÀ
 = 
åue
.
B
,

304 
«me
 = "debugI¡îru±s").
toBoﬁs
))

306 
debugI¡Nxt
 :
debugI¡Regs


308 
	`vÆ
 (
öäode_out
, 
_
Ë
öäode
.
out
.
unzù


309 
comp⁄ít
 <- 0 
u¡û
 
nComp⁄íts
) {

310 
	`öäode_out
(
comp⁄ít
)(0Ë:
	`debugI¡Regs
(component)

321 
comp⁄ít
 <- 0 
u¡û
 
nComp⁄íts
) {

322 
	`whí
 (~
dma˘ive
) {

323 
	`debugI¡Nxt
(
comp⁄ít
Ë:
Ál£
.
B


324 }. 
Ÿhîwi£
 {

325 
	`whí
 (
DMCONTROLWrEn
 && 
DMCONTROLWrD©a
.
h¨t£Œo
 ==
comp⁄ít
.
U
) {

326 
	`debugI¡Nxt
(
comp⁄ít
Ë:
DMCONTROLWrD©a
.
hÆåeq


331 
io
.
ö√rCål
.
vÆid
 :
DMCONTROLWrEn


332 
io
.
ö√rCål
.
bôs
.
h¨t£l
 :
DMCONTROLWrD©a
.
h¨t£Œo


333 
io
.
ö√rCål
.
bôs
.
ªsumîeq
 :
DMCONTROLWrD©a
.resumereq

334 
io
.
ö√rCål
.
bôs
.
ackhavîe£t
 :
DMCONTROLWrD©a
.ackhavereset

336 
io
.
˘æ
.
ndª£t
 :
DMCONTROLReg
.
ndmª£t


337 
io
.
˘æ
.
dma˘ive
 :
DMCONTROLReg
.dmactive

339 
	}
}

342 ˛as†
	cTLDebugModuÀOuãrAsync
(
devi˚
: 
Devi˚
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

344 
vÆ
 
dmi2é
 = 
	`LazyModuÀ
(
√w
 
	$DMIToTL
())

345 
vÆ
 
dmiXb¨
 = 
	`LazyModuÀ
 (
√w
 
	$TLXb¨
())

347 
vÆ
 
dmOuãr
 = 
	`LazyModuÀ
–
√w
 
	$TLDebugModuÀOuãr
(
devi˚
))

348 
vÆ
 
öäode
 = 
	$I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
 = 
åue
Ë:*
dmOuãr
.
öäode


350 
vÆ
 
dmiI¬îNode
 = 
	$TLAsyncCrossögSour˚
(Ë:
dmiXb¨
.
node


352 
dmiXb¨
.
node
 :
dmi2é
.node

353 
dmOuãr
.
dmiNode
 :
dmiXb¨
.
node


355 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

357 
vÆ
 
nComp⁄íts
 = 
dmOuãr
.
öäode
.
edges
.
out
.
size


359 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

360 
vÆ
 
dmi
 = 
√w
 
	`DMIIO
()(
p
).
	`Êù
()

361 
vÆ
 
˘æ
 = 
√w
 
	`DebugCålBundÀ
(
nComp⁄íts
)

362 
vÆ
 
ö√rCål
 = 
√w
 
	`AsyncBundÀ
“ew 
	`DebugI¡î«lBundÀ
(), 
AsyncQueueP¨ams
.
	`sögÀt⁄
())

365 
dmi2é
.
moduÀ
.
io
.
dmi
 <> io.dmi

367 
io
.
˘æ
 <> 
dmOuãr
.
moduÀ
.io.ctrl

368 
io
.
ö√rCål
 :
	`ToAsyncBundÀ
(
dmOuãr
.
moduÀ
.io.ö√rCål, 
AsyncQueueP¨ams
.
	`sögÀt⁄
())

371 
	}
}

373 
˛ass
 
TLDebugModuÀI¬î
(
devi˚
: 
Devi˚
, 
gëNComp⁄íts
: (Ë=> 
I¡
, 
bótByãs
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


376 
vÆ
 
cfg
 = 
p
(
DebugModuÀP¨ams
)

377 
vÆ
 
h¨tSñFuncs
 = 
p
(
DebugModuÀH¨tSñKey
)

379 
vÆ
 
dmiNode
 = 
TLRegi°îNode
(

380 
addªss
 = 
AddªssSë
.
mißlig√d
(0, 
DMI_RegAddrs
.
DMI_DMCONTROL
 << 2) ++

381 
AddªssSë
.
mißlig√d
((
DMI_RegAddrs
.
DMI_DMCONTROL
 + 1) << 2, (0x200 - ((DMI_RegAddrs.DMI_DMCONTROL + 1) << 2))),

382 
devi˚
 = device,

383 
bótByãs
 = 4,

384 
execuèbÀ
 = 
Ál£


387 
vÆ
 
éNode
 = 
TLRegi°îNode
(

388 
addªss
=
Seq
(
AddªssSë
(0, 0xFFF)),

389 
devi˚
=device,

390 
bótByãs
=beatBytes,

391 
execuèbÀ
=
åue


394 
vÆ
 
sb2éO±
 = 
cfg
.
hasBusMa°î
.
›ti⁄
(
LazyModuÀ
(
√w
 
SBToTL
()))

399 
vÆ
 
cu°omNode
 = 
√w
 
DebugCu°omSök
()

401 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
LazyModuÀImp
(
this
){

402 
vÆ
 
nComp⁄íts
 = 
gëNComp⁄íts
()

403 
A¬Ÿ©ed
.
∑øms
(
this
, 
cfg
)

405 
vÆ
 
	gio
 = 
IO
(
√w
 
BundÀ
 {

406 
vÆ
 
dma˘ive
 = 
Boﬁ
(
INPUT
)

407 
vÆ
 
ö√rCål
 = (
√w
 
Decou∂edIO
“ew 
DebugI¡î«lBundÀ
())).
Êù


408 
vÆ
 
debugU«vaû
 = 
Vec
(
nComp⁄íts
, 
Boﬁ
()).
asI≈ut


416 
imp‹t
 
	gDMI_RegAddrs
.
_


417 
imp‹t
 
	gDsbRegAddrs
.
_


418 
imp‹t
 
	gDsbBusC⁄°s
.
_


419 
imp‹t
 
	gDMIC⁄°s
.
_


425 
ªquúe
 (
cfg
.
suµ‹tQuickAc˚ss
 =
Ál£
, "No Quick Access support yet")

426 
ªquúe
 (
cfg
.
suµ‹tH¨tAºay
 =
Ál£
, "No Hart Array support yet")

432 
vÆ
 
	ghÆãdBôRegs
 = 
RegInô
(
Vec
.
fûl
(
nComp⁄íts
){
Ál£
.
B
})

433 
vÆ
 
ªsumeReqRegs
 = 
RegInô
(
Vec
.
fûl
(
nComp⁄íts
){
Ál£
.
B
})

434 
vÆ
 
haveRe£tBôRegs
 = 
RegInô
(
Vec
.
fûl
(
nComp⁄íts
){
åue
.
B
})

438 
vÆ
 
h¨tHÆãdWrEn
 = 
Wúe
(
Boﬁ
())

439 
vÆ
 
h¨tHÆãdId
 = 
Wúe
(
UI¡
(
sbIdWidth
.
W
))

440 
vÆ
 
h¨tGoögWrEn
 = 
Wúe
(
Boﬁ
())

441 
vÆ
 
h¨tGoögId
 = 
Wúe
(
UI¡
(
sbIdWidth
.
W
))

442 
vÆ
 
h¨tResumögWrEn
 = 
Wúe
(
Boﬁ
())

443 
vÆ
 
h¨tResumögId
 = 
Wúe
(
UI¡
(
sbIdWidth
.
W
))

444 
vÆ
 
h¨tEx˚±i⁄WrEn
 = 
Wúe
(
Boﬁ
())

445 
vÆ
 
h¨tEx˚±i⁄Id
 = 
Wúe
(
UI¡
(
sbIdWidth
.
W
))

447 
vÆ
 
dmiProgømBuf„rRdEn
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nProgømBuf„rW‹ds
 * 4){
Ál£
.
B
})

448 
vÆ
 
dmiProgømBuf„rAc˚ssLegÆ
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

449 
vÆ
 
dmiProgømBuf„rWrEnMaybe
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nProgømBuf„rW‹ds
 * 4){
Ál£
.
B
})

451 
vÆ
 
dmiAb°ø˘D©aRdEn
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nAb°ø˘D©aW‹ds
 * 4){
Ál£
.
B
})

452 
vÆ
 
dmiAb°ø˘D©aAc˚ssLegÆ
 = 
Wúe
 (
öô
 = 
Ál£
.
B
)

453 
vÆ
 
dmiAb°ø˘D©aWrEnMaybe
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nAb°ø˘D©aW‹ds
 * 4){
Ál£
.
B
})

459 
vÆ
 
£À˘edH¨tReg
 = 
RegInô
(0.U(10.
W
))

461 
whí
 (
io
.
ö√rCål
.
fúe
()){

462 
£À˘edH¨tReg
 :
io
.
ö√rCål
.
bôs
.
h¨t£l


465 
io
.
ö√rCål
.
ªady
 :
åue
.
B


473 
vÆ
 
DMSTATUSRdD©a
 = 
Wúe
(
öô
 = (
√w
 
DMSTATUSFõlds
()).
‰omBôs
(0.U))

474 
DMSTATUSRdD©a
.
authítiˇãd
 :
åue
.
B


475 
DMSTATUSRdD©a
.
vîsi⁄
 := 2.U

477 
whí
 (
£À˘edH¨tReg
 >
nComp⁄íts
.
U
) {

478 
DMSTATUSRdD©a
.
Æ ⁄exi°ít
 :
åue
.
B


479 
DMSTATUSRdD©a
.
™yn⁄exi°ít
 :
åue
.
B


480 }.
ñ£whí
 (
io
.
debugU«vaû
(
£À˘edH¨tReg
)) {

481 
DMSTATUSRdD©a
.
Ælu«vaû
 :
åue
.
B


482 
DMSTATUSRdD©a
.
™yu«vaû
 :
åue
.
B


483 }.
ñ£whí
 (
hÆãdBôRegs
(
£À˘edH¨tReg
)) {

484 
DMSTATUSRdD©a
.
ÆlhÆãd
 :
åue
.
B


485 
DMSTATUSRdD©a
.
™yhÆãd
 :
åue
.
B


486 }.
Ÿhîwi£
 {

487 
DMSTATUSRdD©a
.
ÆÃu¬ög
 :
åue
.
B


488 
DMSTATUSRdD©a
.
™yru¬ög
 :
åue
.
B


490 
DMSTATUSRdD©a
.
Ælhavîe£t
 :
haveRe£tBôRegs
(
£À˘edH¨tReg
)

491 
DMSTATUSRdD©a
.
™yhavîe£t
 :
haveRe£tBôRegs
(
£À˘edH¨tReg
)

493 
vÆ
 
ªsumîeq
 = 
io
.
ö√rCål
.
fúe
(Ë&& io.ö√rCål.
bôs
.resumereq

495 
whí
 (
io
.
ö√rCål
.
fúe
()){

496 
whí
 (
io
.
ö√rCål
.
bôs
.
ackhavîe£t
) {

497 
haveRe£tBôRegs
(
io
.
ö√rCål
.
bôs
.
h¨t£l
Ë:
Ál£
.
B


501 
DMSTATUSRdD©a
.
ÆÃesumóck
 :~
ªsumeReqRegs
(
£À˘edH¨tReg
Ë&& ~
ªsumîeq


502 
DMSTATUSRdD©a
.
™yªsumóck
 :~
ªsumeReqRegs
(
£À˘edH¨tReg
Ë&& ~
ªsumîeq


505 
DMSTATUSRdD©a
.
devåìvÆid
 :
Ál£
.
B


507 
DMSTATUSRdD©a
.
im≥bªak
 :(
cfg
.
hasIm∂icôEbªak
).
B


511 
vÆ
 
HARTINFORdD©a
 = 
Wúe
 (
öô
 = (
√w
 
HARTINFOFõlds
()).
‰omBôs
(0.U))

512 
HARTINFORdD©a
.
d©Øc˚ss
 :
åue
.
B


513 
HARTINFORdD©a
.
d©asize
 :
cfg
.
nAb°ø˘D©aW‹ds
.
U


514 
HARTINFORdD©a
.
d©Øddr
 :
DsbRegAddrs
.
DATA
.
U


515 
HARTINFORdD©a
.
ns¸©ch
 :
cfg
.
nS¸©ch
.
U


518 
vÆ
 
numHÆãdSètus
 = ((
nComp⁄íts
 - 1) / 32) + 1

519 
vÆ
 
hÆãdSètus
 = 
Wúe
(
Vec
(
numHÆãdSètus
, 
Bôs
(
width
 = 32)))

521 
ii
 <- 0 
u¡û
 
numHÆãdSètus
) {

522 
hÆãdSètus
(
ii
Ë:
C©
(
hÆãdBôRegs
.
¶i˚
(iò* 32, (iò+ 1Ë* 32).
ªvî£
)

525 
vÆ
 
	ghÆãdSumm¨y
 = 
C©
(
hÆãdSètus
.
m≠
(
_
.
‹R
).
ªvî£
)

526 
vÆ
 
HALTSUM1RdD©a
 = (
√w
 
HALTSUM1Fõlds
()).
‰omBôs
(
hÆãdSumm¨y
)

528 
vÆ
 
£À˘edHÆãdSètus
 = 
Mux
((
£À˘edH¨tReg
 >> 5Ë> 
numHÆãdSètus
.
U
, 0.U, 
hÆãdSètus
(selectedHartReg >> 5))

529 
vÆ
 
	gHALTSUM0RdD©a
 = (
√w
 
HALTSUM0Fõlds
()).
‰omBôs
(
£À˘edHÆãdSètus
)

535 
vÆ
 
ABSTRACTCSRe£t
 = 
Wúe
(
öô
 = (
√w
 
ABSTRACTCSFõlds
()).
‰omBôs
(0.U))

536 
ABSTRACTCSRe£t
.
d©acou¡
 :
cfg
.
nAb°ø˘D©aW‹ds
.
U


537 
ABSTRACTCSRe£t
.
¥ogbufsize
 :
cfg
.
nProgømBuf„rW‹ds
.
U


539 
vÆ
 
ABSTRACTCSReg
 = 
Reg
(
√w
 
ABSTRACTCSFõlds
())

540 
vÆ
 
ABSTRACTCSWrD©aVÆ
 = 
Wúe
(
öô
 = 0.U(32.
W
))

541 
vÆ
 
ABSTRACTCSWrD©a
 = (
√w
 
ABSTRACTCSFõlds
()).
‰omBôs
(
ABSTRACTCSWrD©aVÆ
)

542 
vÆ
 
ABSTRACTCSRdD©a
 = 
Wúe
(
öô
 = 
ABSTRACTCSReg
)

544 
vÆ
 
ABSTRACTCSRdEn
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

545 
vÆ
 
ABSTRACTCSWrEnMaybe
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

547 
vÆ
 
ABSTRACTCSWrEnLegÆ
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

548 
vÆ
 
ABSTRACTCSWrEn
 = 
ABSTRACTCSWrEnMaybe
 && 
ABSTRACTCSWrEnLegÆ


550 
vÆ
 
îr‹Busy
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

551 
vÆ
 
îr‹Ex˚±i⁄
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

552 
vÆ
 
îr‹Unsuµ‹ãd
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

553 
vÆ
 
îr‹HÆtResume
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

555 
whí
(~
io
.
dma˘ive
){

556 
ABSTRACTCSReg
 :
ABSTRACTCSRe£t


557 }.
Ÿhîwi£
 {

558 
whí
 (
îr‹Busy
){

559 
ABSTRACTCSReg
.
cmdîr
 :
DebugAb°ø˘Comm™dEº‹
.
EºBusy
.
id
.
U


560 }.
ñ£whí
 (
îr‹Ex˚±i⁄
) {

561 
ABSTRACTCSReg
.
cmdîr
 :
DebugAb°ø˘Comm™dEº‹
.
EºEx˚±i⁄
.
id
.
U


562 }.
ñ£whí
 (
îr‹Unsuµ‹ãd
) {

563 
ABSTRACTCSReg
.
cmdîr
 :
DebugAb°ø˘Comm™dEº‹
.
EºNŸSuµ‹ãd
.
id
.
U


564 }.
ñ£whí
 (
îr‹HÆtResume
) {

565 
ABSTRACTCSReg
.
cmdîr
 :
DebugAb°ø˘Comm™dEº‹
.
EºHÆtResume
.
id
.
U


566 }.
Ÿhîwi£
 {

567 
whí
 (
ABSTRACTCSWrEn
){

568 
ABSTRACTCSReg
.
cmdîr
 :ABSTRACTCSReg.cmdî∏& ~(
ABSTRACTCSWrD©a
.cmderr);

574 
vÆ
 
	gab°ø˘Comm™dBusy
 = 
Wúe
(
öô
 = 
åue
.
B
)

575 
ABSTRACTCSRdD©a
.
busy
 :
ab°ø˘Comm™dBusy


579 
vÆ
 
ABSTRACTAUTORe£t
 = 
Wúe
(
öô
 = (
√w
 
ABSTRACTAUTOFõlds
()).
‰omBôs
(0.U))

580 
vÆ
 
ABSTRACTAUTOReg
 = 
Reg
(
√w
 
ABSTRACTAUTOFõlds
())

581 
vÆ
 
ABSTRACTAUTOWrD©aVÆ
 = 
Wúe
(
öô
 = 0.U(32.
W
))

582 
vÆ
 
ABSTRACTAUTOWrD©a
 = (
√w
 
ABSTRACTAUTOFõlds
()).
‰omBôs
(
ABSTRACTAUTOWrD©aVÆ
)

583 
vÆ
 
ABSTRACTAUTORdD©a
 = 
Wúe
(
öô
 = 
ABSTRACTAUTOReg
)

585 
vÆ
 
ABSTRACTAUTORdEn
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

586 
vÆ
 
ABSTRACTAUTOWrEnMaybe
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

588 
vÆ
 
ABSTRACTAUTOWrEnLegÆ
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

589 
vÆ
 
ABSTRACTAUTOWrEn
 = 
ABSTRACTAUTOWrEnMaybe
 && 
ABSTRACTAUTOWrEnLegÆ


591 
whí
 (~
io
.
dma˘ive
) {

592 
ABSTRACTAUTOReg
 :
ABSTRACTAUTORe£t


593 }.
ñ£whí
 (
ABSTRACTAUTOWrEn
) {

594 
ABSTRACTAUTOReg
.
aut€xe˝rogbuf
 :
ABSTRACTAUTOWrD©a
.aut€xe˝rogbu‡& ( (1 << 
cfg
.
nProgømBuf„rW‹ds
Ë- 1).
U


595 
ABSTRACTAUTOReg
.
aut€xecd©a
 :
ABSTRACTAUTOWrD©a
.aut€xecd©®& ( (1 << 
cfg
.
nAb°ø˘D©aW‹ds
Ë- 1).
U


598 
vÆ
 
dmiAb°ø˘D©aAc˚ssVec
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nAb°ø˘D©aW‹ds
 * 4){
Ál£
.
B
})

599 
dmiAb°ø˘D©aAc˚ssVec
 :(
dmiAb°ø˘D©aWrEnMaybe
 
zù
 
dmiAb°ø˘D©aRdEn
).
m≠
{ (
r
,
w
) =>Ñ | w}

601 
vÆ
 
	gdmiProgømBuf„rAc˚ssVec
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nProgømBuf„rW‹ds
 * 4){
Ál£
.
B
})

602 
dmiProgømBuf„rAc˚ssVec
 :(
dmiProgømBuf„rWrEnMaybe
 
zù
 
dmiProgømBuf„rRdEn
).
m≠
{ (
r
,
w
) =>Ñ | w}

604 
vÆ
 
	gdmiAb°ø˘D©aAc˚ss
 = 
dmiAb°ø˘D©aAc˚ssVec
.
ªdu˚
(
_
 || _ )

605 
vÆ
 
dmiProgømBuf„rAc˚ss
 = 
dmiProgømBuf„rAc˚ssVec
.
ªdu˚
(
_
 || _)

608 
vÆ
 
aut€xecD©a
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nAb°ø˘D©aW‹ds
){
Ál£
.
B
})

609 
vÆ
 
aut€xecProg
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
cfg
.
nProgømBuf„rW‹ds
){
Ál£
.
B
})

610 (
aut€xecD©a
 
zù
 
ABSTRACTAUTOReg
.
aut€xecd©a
.
toBoﬁs
).
zùWôhIndex
.
f‹óch
 {(
t
, 
i
Ë=>Å.
_1
 :
dmiAb°ø˘D©aAc˚ssVec
(ò* 4Ë&&Å.
_2
 }

611 (
aut€xecProg
 
zù
 
ABSTRACTAUTOReg
.
aut€xe˝rogbuf
.
toBoﬁs
).
zùWôhIndex
.
f‹óch
 {(
t
, 
	gi
Ë=>Å.
_1
 :
dmiProgømBuf„rAc˚ssVec
(
i
 * 4Ë&&Å.
_2
}

613 
vÆ
 
aut€xec
 = 
aut€xecD©a
.
ªdu˚
(
_
 || _Ë|| 
aut€xecProg
.reduce(_ || _)

617 
vÆ
 
COMMANDRe£t
 = 
Wúe
(
öô
 = (
√w
 
COMMANDFõlds
()).
‰omBôs
(0.U))

618 
vÆ
 
COMMANDReg
 = 
Reg
(
√w
 
COMMANDFõlds
())

620 
vÆ
 
COMMANDWrD©aVÆ
 = 
Wúe
(
öô
 = 0.U(32.
W
))

621 
vÆ
 
COMMANDWrD©a
 = 
Wúe
(
öô
 = (
√w
 
COMMANDFõlds
()).
‰omBôs
(
COMMANDWrD©aVÆ
))

622 
vÆ
 
COMMANDWrEnMaybe
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

623 
vÆ
 
COMMANDWrEnLegÆ
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

624 
vÆ
 
COMMANDRdEn
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

626 
vÆ
 
COMMANDWrEn
 = 
COMMANDWrEnMaybe
 && 
COMMANDWrEnLegÆ


627 
vÆ
 
COMMANDRdD©a
 = 
COMMANDReg


629 
whí
 (~
io
.
dma˘ive
) {

630 
COMMANDReg
 :
COMMANDRe£t


631 }.
Ÿhîwi£
 {

632 
whí
 (
COMMANDWrEn
) {

633 
COMMANDReg
 :
COMMANDWrD©a


641 
vÆ
 
ab°ø˘D©aMem
 = 
Reg
(
Vec
(
cfg
.
nAb°ø˘D©aW‹ds
*4, 
UI¡
(8.
W
)))

642 
vÆ
 
	gab°ø˘D©aNxt
 = 
Wúe
(
öô
 = 
ab°ø˘D©aMem
)

645 
vÆ
 
¥ogømBuf„rMem
 = 
Reg
(
Vec
(
cfg
.
nProgømBuf„rW‹ds
*4, 
UI¡
(8.
W
)))

646 
vÆ
 
	g¥ogømBuf„rNxt
 = 
Wúe
(
öô
 = 
¥ogømBuf„rMem
)

653 
comp⁄ít
 <- 0 
u¡û
 
nComp⁄íts
) {

654 
whí
 (~
io
.
dma˘ive
) {

655 
hÆãdBôRegs
(
comp⁄ít
Ë:
Ál£
.
B


656 
ªsumeReqRegs
(
comp⁄ít
Ë:
Ál£
.
B


657 }.
Ÿhîwi£
 {

659 
whí
 (
h¨tHÆãdWrEn
) {

660 
whí
 (
h¨tSñFuncs
.
h¨tIdToH¨tSñ
(
h¨tHÆãdId
Ë==
comp⁄ít
.
U
) {

661 
hÆãdBôRegs
(
comp⁄ít
Ë:
åue
.
B


663 }.
ñ£whí
 (
h¨tResumögWrEn
) {

664 
whí
 (
h¨tSñFuncs
.
h¨tIdToH¨tSñ
(
h¨tResumögId
Ë==
comp⁄ít
.
U
) {

665 
hÆãdBôRegs
(
comp⁄ít
Ë:
Ál£
.
B


673 
whí
 (
h¨tResumögWrEn
) {

674 
whí
 (
h¨tSñFuncs
.
h¨tIdToH¨tSñ
(
h¨tResumögId
Ë==
comp⁄ít
.
U
) {

675 
ªsumeReqRegs
(
comp⁄ít
Ë:
Ál£
.
B


678 
whí
(
ªsumîeq
) {

679 
ªsumeReqRegs
(
io
.
ö√rCål
.
bôs
.
h¨t£l
Ë:
åue
.
B


684 
vÆ
 (
sbcsFõlds
, 
sbAddrFõlds
, 
sbD©aFõlds
):

685 (
Seq
[
RegFõld
], 
	gSeq
[Seq[RegFõld]], Seq[Seq[RegFõld]]Ë
sb2éO±
.
m≠
{ 
sb2é
 =>

686 
Sy°emBusAc˚ssModuÀ
(
sb2é
,
io
.
dma˘ive
)(
	gp
)

687 }.
gëOrEl£
((
Seq
.
em±y
[
RegFõld
], Seq.
fûl
[Seq[RegField]](4)(Seq.empty[RegField]), Seq.fill[Seq[RegField]](4)(Seq.empty[RegField])))

692 
	gdmiNode
.
ªgm≠
(

693 (
DMI_DMSTATUS
 << 2Ë-> 
Seq
(
RegFõld
.
r
(32, 
DMSTATUSRdD©a
.
asUI¡
(), 
RegFõldDesc
("dmi_dmstatus", ""))),

695 (
DMI_HARTINFO
 << 2Ë-> 
Seq
(
RegFõld
.
r
(32, 
HARTINFORdD©a
.
asUI¡
(), 
RegFõldDesc
("dmi_hartinfo", "" ))),

696 (
DMI_HALTSUM0
 << 2Ë-> 
Seq
(
RegFõld
.
r
(32, 
HALTSUM0RdD©a
.
asUI¡
(), 
RegFõldDesc
("dmi_haltsum0", ""))),

697 (
DMI_HALTSUM1
 << 2Ë-> 
Seq
(
RegFõld
.
r
(32, 
HALTSUM1RdD©a
.
asUI¡
(), 
RegFõldDesc
("dmi_haltsum1", ""))),

698 (
DMI_ABSTRACTCS
 << 2Ë-> 
Seq
(
RWNŸify
(32, 
ABSTRACTCSRdD©a
.
asUI¡
(), 
ABSTRACTCSWrD©aVÆ
, 
ABSTRACTCSRdEn
, 
ABSTRACTCSWrEnMaybe
,

699 
Some
(
RegFõldDesc
("dmi_abstractcs", "" )))),

700 (
DMI_ABSTRACTAUTO
<< 2Ë-> 
Seq
(
RWNŸify
(32, 
ABSTRACTAUTORdD©a
.
asUI¡
(), 
ABSTRACTAUTOWrD©aVÆ
, 
ABSTRACTAUTORdEn
, 
ABSTRACTAUTOWrEnMaybe
,

701 
Some
(
RegFõldDesc
("dmi_ab°ø˘auto", "", 
ª£t
=Some(0))))),

702 (
DMI_COMMAND
 << 2Ë-> 
Seq
(
RWNŸify
(32, 
COMMANDRdD©a
.
asUI¡
(), 
COMMANDWrD©aVÆ
, 
COMMANDRdEn
, 
COMMANDWrEnMaybe
,

703 
Some
(
RegFõldDesc
("dmi_comm™d", "", 
ª£t
=Some(0))))),

704 (
DMI_DATA0
 << 2Ë-> 
RegFõldGroup
("dmi_d©a", 
N⁄e
, 
ab°ø˘D©aMem
.
zùWôhIndex
.
m≠
{(
x
, 
i
Ë=> 
RWNŸify
(8, x, 
ab°ø˘D©aNxt
(i),

705 
dmiAb°ø˘D©aRdEn
(
i
),

706 
dmiAb°ø˘D©aWrEnMaybe
(
i
),

707 
Some
(
RegFõldDesc
(
s
"dmi_d©a_$i", "", 
ª£t
 = Some(0))))}),

708 (
DMI_PROGBUF0
 << 2Ë-> 
RegFõldGroup
("dmi_¥ogbuf", 
N⁄e
, 
¥ogømBuf„rMem
.
zùWôhIndex
.
m≠
{(
x
, 
i
Ë=> 
RWNŸify
(8, x, 
¥ogømBuf„rNxt
(i),

709 
dmiProgømBuf„rRdEn
(
i
),

710 
dmiProgømBuf„rWrEnMaybe
(
i
),

711 
Some
(
RegFõldDesc
(
s
"dmi_¥ogbuf_$i", "", 
ª£t
 = Some(0))))}),

712 (
DMI_SBCS
 << 2Ë-> 
sbcsFõlds
,

713 (
DMI_SBDATA0
 << 2Ë-> 
sbD©aFõlds
(0),

714 (
DMI_SBDATA1
 << 2Ë-> 
sbD©aFõlds
(1),

715 (
DMI_SBDATA2
 << 2Ë-> 
sbD©aFõlds
(2),

716 (
DMI_SBDATA3
 << 2Ë-> 
sbD©aFõlds
(3),

717 (
DMI_SBADDRESS0
 << 2Ë-> 
sbAddrFõlds
(0),

718 (
DMI_SBADDRESS1
 << 2Ë-> 
sbAddrFõlds
(1),

719 (
DMI_SBADDRESS2
 << 2Ë-> 
sbAddrFõlds
(2),

720 (
DMI_SBADDRESS3
 << 2Ë-> 
sbAddrFõlds
(3)

724 
	gab°ø˘D©aMem
.
	gzùWôhIndex
.
	gf‹óch
 { (
	gx
, 
	gi
) =>

725 
whí
 (
dmiAb°ø˘D©aWrEnMaybe
(
i
Ë&& 
dmiAb°ø˘D©aAc˚ssLegÆ
) {

726 
x
 :
ab°ø˘D©aNxt
(
i
)

730 
vÆ
 (
cu°oms
, 
cu°omP¨ams
Ë
cu°omNode
.
ö
.
unzù


731 
vÆ
 
√edCu°om
 = (
cu°oms
.
size
 > 0Ë&& (
cu°omP¨ams
.
hód
.
addrs
.size > 0)

732 i‡(
√edCu°om
) {

733 
vÆ
 (
cu°om
, 
cu°omP
Ë
cu°omNode
.
ö
.
hód


734 
ªquúe
(
cu°omP
.
width
 % 8 =0, 
s
"Debug Custom width must be divisible by 8,Çot ${customP.width}")

735 
vÆ
 
	gcu°om_d©a
 = 
cu°om
.
d©a
.
toBoﬁs


736 
vÆ
 
cu°om_byãs
 = 
Seq
.
èbuœã
(
cu°omP
.
width
/8){
i
 => 
cu°om_d©a
.
¶i˚
(i*8, (i+1)*8).
	gasUI¡
}

737 
whí
 (
cu°om
.
ªady
 && cu°om.
vÆid
) {

738 (
ab°ø˘D©aMem
 
zù
 
	gcu°om_byãs
).
	gzùWôhIndex
.
	gf‹óch
 {((
	ga
, 
	gb
), 
	gi
) =>

739 
a
 :
b


744 
¥ogømBuf„rMem
.
zùWôhIndex
.
f‹óch
 { (
x
, 
	gi
) =>

745 
whí
 (
dmiProgømBuf„rWrEnMaybe
(
i
Ë&& 
dmiProgømBuf„rAc˚ssLegÆ
) {

746 
x
 :
¥ogømBuf„rNxt
(
i
)

754 
vÆ
 
goReg
 = 
Reg
(
Boﬁ
())

755 
vÆ
 
goAb°ø˘
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

756 
vÆ
 
goCu°om
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

757 
vÆ
 
jÆAb°ø˘
 = 
Wúe
(
öô
 = (
√w
 
Gíî©edUJ
()).
‰omBôs
(
In°ru˘i⁄s
.
JAL
.
vÆue
.
U
))

758 
jÆAb°ø˘
.
£tImm
(
ABSTRACT
(
cfg
Ë- 
WHERETO
)

760 
whí
 (~
io
.
dma˘ive
){

761 
goReg
 :
Ál£
.
B


762 }.
Ÿhîwi£
 {

763 
whí
 (
goAb°ø˘
) {

764 
goReg
 :
åue
.
B


765 }.
ñ£whí
 (
h¨tGoögWrEn
){

766 
as£π
(
h¨tGoögId
 === 0.U, "Unexpected 'GOING' hart.")

767 
	ggoReg
 :
Ál£
.
B


771 ˛as†
	cÊagBundÀ
 
exãnds
 
BundÀ
 {

772 
vÆ
 
ª£rved
 = 
UI¡
(6.
W
)

773 
vÆ
 
ªsume
 = 
Boﬁ
()

774 
vÆ
 
go
 = 
Boﬁ
()

777 
vÆ
 
Êags
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(1024){
√w
 
ÊagBundÀ
().
‰omBôs
(0.U)})

778 
as£π
 ((
h¨tSñFuncs
.
h¨tSñToH¨tId
(
£À˘edH¨tReg
) < 1024.U),

780 
Êags
(
h¨tSñFuncs
.
h¨tSñToH¨tId
(
£À˘edH¨tReg
)).
	ggo
 :
goReg


781 
comp⁄ít
 <- 0 
u¡û
 
nComp⁄íts
) {

782 
vÆ
 
comp⁄ítSñ
 = 
Wúe
(
öô
 = 
comp⁄ít
.
U
)

783 
Êags
(
h¨tSñFuncs
.
h¨tSñToH¨tId
(
comp⁄ítSñ
)).
ªsume
 :
ªsumeReqRegs
(
comp⁄ít
)

790 
vÆ
 
ac˚ssRegi°îComm™dWr
 = 
Wúe
(
öô
 = (
√w
 
ACCESS_REGISTERFõlds
()).
‰omBôs
(
COMMANDWrD©a
.
asUI¡
()))

791 
vÆ
 
ac˚ssRegi°îComm™dReg
 = 
Wúe
(
öô
 = (
√w
 
ACCESS_REGISTERFõlds
()).
‰omBôs
(
COMMANDReg
.
asUI¡
()))

795 ˛as†
	cGíî©edI
 
exãnds
 
BundÀ
 {

796 
vÆ
 
imm
 = 
UI¡
(12.
W
)

797 
vÆ
 
rs1
 = 
UI¡
(5.
W
)

798 
vÆ
 
fun˘3
 = 
UI¡
(3.
W
)

799 
vÆ
 
rd
 = 
UI¡
(5.
W
)

800 
vÆ
 
›code
 = 
UI¡
(7.
W
)

803 ˛as†
	cGíî©edS
 
exãnds
 
BundÀ
 {

804 
vÆ
 
immhi
 = 
UI¡
(7.
W
)

805 
vÆ
 
rs2
 = 
UI¡
(5.
W
)

806 
vÆ
 
rs1
 = 
UI¡
(5.
W
)

807 
vÆ
 
fun˘3
 = 
UI¡
(3.
W
)

808 
vÆ
 
immlo
 = 
UI¡
(5.
W
)

809 
vÆ
 
›code
 = 
UI¡
(7.
W
)

812 ˛as†
	cGíî©edUJ
 
exãnds
 
BundÀ
 {

813 
vÆ
 
imm3
 = 
UI¡
(1.
W
)

814 
vÆ
 
imm0
 = 
UI¡
(10.
W
)

815 
vÆ
 
imm1
 = 
UI¡
(1.
W
)

816 
vÆ
 
imm2
 = 
UI¡
(8.
W
)

817 
vÆ
 
rd
 = 
UI¡
(5.
W
)

818 
vÆ
 
›code
 = 
UI¡
(7.
W
)

820 
def
 
£tImm
(
imm
: 
I¡
Ë: 
Unô
 = {

823 
ªquúe
(
imm
 % 2 == 0, "Immediate must beÉven for UJÉncoding.")

824 
vÆ
 
	gimmWúe
 = 
Wúe
(
öô
 = 
imm
.
S
(21.
W
))

825 
vÆ
 
immBôs
 = 
Wúe
(
öô
 = 
Vec
(
immWúe
.
toBoﬁs
))

827 
imm0
 :
immBôs
.
¶i˚
(1, 1 + 10).
asUI¡
()

828 
	gimm1
 :
immBôs
.
¶i˚
(11, 11 + 11).
asUI¡
()

829 
	gimm2
 :
immBôs
.
¶i˚
(12, 12 + 8).
asUI¡
()

830 
	gimm3
 :
immBôs
.
¶i˚
(20, 20 + 1).
asUI¡
()

834 
vÆ
 
	gab°ø˘Gíî©edMem
 = 
Reg
(
Vec
(2, (
UI¡
(32.
W
))))

835 
vÆ
 
	gab°ø˘Gíî©edI
 = 
Wúe
(
√w
 
Gíî©edI
())

836 
vÆ
 
ab°ø˘Gíî©edS
 = 
Wúe
(
√w
 
Gíî©edS
())

837 
vÆ
 
n›
 = 
Wúe
(
√w
 
Gíî©edI
())

839 
ab°ø˘Gíî©edI
.
›code
 :((
√w
 
Gíî©edI
()).
‰omBôs
(
In°ru˘i⁄s
.
LW
.
vÆue
.
U
)).opcode

840 
ab°ø˘Gíî©edI
.
rd
 :(
ac˚ssRegi°îComm™dReg
.
ªgno
 & 0x1F.U)

841 
ab°ø˘Gíî©edI
.
fun˘3
 :
ac˚ssRegi°îComm™dReg
.
size


842 
ab°ø˘Gíî©edI
.
rs1
 := 0.U

843 
ab°ø˘Gíî©edI
.
imm
 :
DATA
.
U


845 
ab°ø˘Gíî©edS
.
›code
 :((
√w
 
Gíî©edS
()).
‰omBôs
(
In°ru˘i⁄s
.
SW
.
vÆue
.
U
)).opcode

846 
ab°ø˘Gíî©edS
.
immlo
 :(
DATA
 & 0x1F).
U


847 
ab°ø˘Gíî©edS
.
fun˘3
 :
ac˚ssRegi°îComm™dReg
.
size


848 
ab°ø˘Gíî©edS
.
rs1
 := 0.U

849 
ab°ø˘Gíî©edS
.
rs2
 :(
ac˚ssRegi°îComm™dReg
.
ªgno
 & 0x1F.U)

850 
ab°ø˘Gíî©edS
.
immhi
 :(
DATA
 >> 5).
U


852 
n›
 :((
√w
 
Gíî©edI
()).
‰omBôs
(
In°ru˘i⁄s
.
ADDI
.
vÆue
.
U
))

853 
n›
.
rd
 := 0.U

854 
n›
.
rs1
 := 0.U

855 
n›
.
imm
 := 0.U

857 
whí
 (
goAb°ø˘
) {

858 
ab°ø˘Gíî©edMem
(0Ë:
Mux
(
ac˚ssRegi°îComm™dReg
.
å™s„r
,

859 
Mux
(
ac˚ssRegi°îComm™dReg
.
wrôe
,

861 
ab°ø˘Gíî©edI
.
asUI¡
(),

863 
ab°ø˘Gíî©edS
.
asUI¡
()),

864 
n›
.
asUI¡
()

866 
ab°ø˘Gíî©edMem
(1Ë:
Mux
(
ac˚ssRegi°îComm™dReg
.
po°exec
,

867 
n›
.
asUI¡
(),

868 
In°ru˘i⁄s
.
EBREAK
.
vÆue
.
U
)

874 i‡(
	g√edCu°om
) {

875 
vÆ
 (
cu°om
, 
cu°omP
Ë
cu°omNode
.
ö
.
hód


876 
cu°om
.
addr
 :
ac˚ssRegi°îComm™dReg
.
ªgno


877 
cu°om
.
vÆid
 :
goCu°om


883 
éNode
.
ªgm≠
(

885 
HALTED
 -> 
Seq
(
WNŸifyWúe
(
sbIdWidth
, 
h¨tHÆãdId
, 
h¨tHÆãdWrEn
,

887 
GOING
 -> 
Seq
(
WNŸifyWúe
(
sbIdWidth
, 
h¨tGoögId
, 
h¨tGoögWrEn
,

889 
RESUMING
 -> 
Seq
(
WNŸifyWúe
(
sbIdWidth
, 
h¨tResumögId
, 
h¨tResumögWrEn
,

891 
EXCEPTION
 -> 
Seq
(
WNŸifyWúe
(
sbIdWidth
, 
h¨tEx˚±i⁄Id
, 
h¨tEx˚±i⁄WrEn
,

893 
DATA
 -> 
RegFõldGroup
("debug_d©a", 
Some
("Data usedÅo communicate with Debug Module"),

894 
ab°ø˘D©aMem
.
zùWôhIndex
.
m≠
 {(
x
, 
i
Ë=> 
RegFõld
(8, x, 
RegFõldDesc
(
s
"debug_data_$i", ""))}),

895 
PROGBUF
(
cfg
)-> 
RegFõldGroup
("debug_¥ogbuf", 
Some
("Program buffer usedÅo communicate with Debug Module"),

896 
¥ogømBuf„rMem
.
zùWôhIndex
.
m≠
 {(
x
, 
i
Ë=> 
RegFõld
(8, x, 
RegFõldDesc
(
s
"debug_progbuf_$i", ""))}),

899 
IMPEBREAK
(
cfg
)-> {i‡(cfg.
hasIm∂icôEbªak
Ë
Seq
(
RegFõld
.
r
(32, 
In°ru˘i⁄s
.
EBREAK
.
vÆue
.
U
,

900 
RegFõldDesc
("debug_im≥bªak", "Debug Im∂icô EBREAK", 
ª£t
=
Some
(
In°ru˘i⁄s
.
EBREAK
.
vÆue
)))Ë
Nû
},

901 
WHERETO
 -> 
Seq
(
RegFõld
.
r
(32, 
jÆAb°ø˘
.
asUI¡
, 
RegFõldDesc
("debug_whîëo", "In°ru˘i⁄ fûÀd i¿by Debug ModuÀÅÿc⁄åﬁ h¨àö Debug Mode", vﬁ©ûê
åue
))),

902 
ABSTRACT
(
cfg
Ë-> 
RegFõldGroup
("debug_ab°ø˘", 
Some
("Instructions generated by Debug Module"),

903 
ab°ø˘Gíî©edMem
.
zùWôhIndex
.
m≠
{ (
x
,
i
Ë=> 
RegFõld
.
r
(32, x, 
RegFõldDesc
(
s
"debug_ab°ø˘_$i", "", vﬁ©ûe=
åue
))}),

904 
FLAGS
 -> 
RegFõldGroup
("debug_Êags", 
Some
("MemoryÑegion usedÅo control hart going/resuming in Debug Mode"),

905 
Êags
.
zùWôhIndex
.
m≠
{(
x
, 
i
Ë=> 
RegFõld
.
r
(8, x.
asUI¡
(), 
RegFõldDesc
(
s
"debug_Êags_$i", "", vﬁ©ûe=
åue
))}),

906 
ROMBASE
 -> 
RegFõldGroup
("debug_rom", 
Some
("Debug ROM"),

907 
DebugRomC⁄ã¡s
().
zùWôhIndex
.
m≠
{(
x
, 
i
Ë=> 
RegFõld
.
r
(8, (x & 0xFF).
U
(8.
W
), 
RegFõldDesc
(
s
"debug_rom_$i", "", 
ª£t
=
Some
(x)))})

911 
whí
 (~
io
.
dma˘ive
){

912 
	gab°ø˘D©aMem
.
	gf‹óch
 {
	gx
 => 
x
 := 0.U}

913 
¥ogømBuf„rMem
.
f‹óch
 {
x
 => x := 0.U}

920 
obje˘
 
CålSèã
 
exãnds
 
sˇœ
.
Enumî©i⁄
 {

921 
ty≥
 
CålSèã
 = 
VÆue


922 
vÆ
 
Waôög
, 
	gCheckGíî©e
, 
	gExec
, 
	gCu°om
 = 
VÆue


924 
def
 
≠∂y
–
t
 : 
VÆue
Ë: 
UI¡
 = {

925 
t
.
id
.
U
(
log2Up
(
vÆues
.
size
).
W
)

928 
imp‹t
 
CålSèã
.
_


931 
vÆ
 
˘æSèãReg
 = 
Reg
(
CålSèã
(
Waôög
))

933 
vÆ
 
h¨tHÆãd
 = 
hÆãdBôRegs
(
£À˘edH¨tReg
)

934 
vÆ
 
˘æSèãNxt
 = 
Wúe
(
öô
 = 
˘æSèãReg
)

939 
ab°ø˘Comm™dBusy
 :(
˘æSèãReg
 =/
CålSèã
(
Waôög
))

941 
ABSTRACTCSWrEnLegÆ
 :(
˘æSèãReg
 ==
CålSèã
(
Waôög
))

942 
COMMANDWrEnLegÆ
 :(
˘æSèãReg
 ==
CålSèã
(
Waôög
))

943 
ABSTRACTAUTOWrEnLegÆ
 :(
˘æSèãReg
 ==
CålSèã
(
Waôög
))

944 
dmiAb°ø˘D©aAc˚ssLegÆ
 :(
˘æSèãReg
 ==
CålSèã
(
Waôög
))

945 
dmiProgømBuf„rAc˚ssLegÆ
 :(
˘æSèãReg
 ==
CålSèã
(
Waôög
))

947 
îr‹Busy
 :(
ABSTRACTCSWrEnMaybe
 && ~
ABSTRACTCSWrEnLegÆ
) ||

948 (
ABSTRACTAUTOWrEnMaybe
 && ~
ABSTRACTAUTOWrEnLegÆ
) ||

949 (
COMMANDWrEnMaybe
 && ~
COMMANDWrEnLegÆ
) ||

950 (
dmiAb°ø˘D©aAc˚ss
 && ~
dmiAb°ø˘D©aAc˚ssLegÆ
) ||

951 (
dmiProgømBuf„rAc˚ss
 && ~
dmiProgømBuf„rAc˚ssLegÆ
)

954 
vÆ
 
comm™dWrIsAc˚ssRegi°î
 = (
COMMANDWrD©a
.
cmdty≥
 ==
DebugAb°ø˘Comm™dTy≥
.
Ac˚ssRegi°î
.
id
.
U
)

955 
vÆ
 
comm™dRegIsAc˚ssRegi°î
 = (
COMMANDReg
.
cmdty≥
 ==
DebugAb°ø˘Comm™dTy≥
.
Ac˚ssRegi°î
.
id
.
U
)

957 
vÆ
 
comm™dWrIsUnsuµ‹ãd
 = 
COMMANDWrEn
 && !
comm™dWrIsAc˚ssRegi°î
;

959 
vÆ
 
	gcomm™dRegIsUnsuµ‹ãd
 = 
Wúe
(
öô
 = 
åue
.
B
)

960 
vÆ
 
comm™dRegBadHÆtResume
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

963 
vÆ
 
ac˚ssRegIsGPR
 = (
ac˚ssRegi°îComm™dReg
.
ªgno
 >= 0x1000.U &&áccessRegisterCommandReg.regno <= 0x101F.U)

964 
vÆ
 
ac˚ssRegIsCu°om
 = i‡(
√edCu°om
) {

965 
vÆ
 (
cu°om
, 
cu°omP
Ë
cu°omNode
.
ö
.
hód


966 
cu°omP
.
addrs
.
fﬁdLe·
(
Ál£
.
B
){

967 (
ªsu…
, 
cuºít
Ë=>Ñesu… || (cuºít.
U
 ==
ac˚ssRegi°îComm™dReg
.
ªgno
)}

968 } 
	gÁl£
.
B


970 
whí
 (
comm™dRegIsAc˚ssRegi°î
) {

971 
whí
 (
ac˚ssRegIsCu°om
 && 
ac˚ssRegi°îComm™dReg
.
å™s„r
 &&ác˚ssRegi°îComm™dReg.
wrôe
 ==
Ál£
.
B
) {

972 
comm™dRegIsUnsuµ‹ãd
 :
Ál£
.
B


973 }.
ñ£whí
 (!
ac˚ssRegi°îComm™dReg
.
å™s„r
 || 
ac˚ssRegIsGPR
) {

974 
comm™dRegIsUnsuµ‹ãd
 :
Ál£
.
B


975 
comm™dRegBadHÆtResume
 :~
h¨tHÆãd


979 
vÆ
 
wrAc˚ssRegi°îComm™d
 = 
COMMANDWrEn
 && 
comm™dWrIsAc˚ssRegi°î
 && (
ABSTRACTCSReg
.
cmdîr
 === 0.U)

980 
vÆ
 
ªgAc˚ssRegi°îComm™d
 = 
aut€xec
 && 
comm™dRegIsAc˚ssRegi°î
 && (
ABSTRACTCSReg
.
cmdîr
 === 0.U)

986 
whí
 (
˘æSèãReg
 ==
CålSèã
(
Waôög
)){

987 
whí
 (
wrAc˚ssRegi°îComm™d
 || 
ªgAc˚ssRegi°îComm™d
) {

988 
˘æSèãNxt
 :
CålSèã
(
CheckGíî©e
)

989 }.
ñ£whí
 (
comm™dWrIsUnsuµ‹ãd
) {

990 
îr‹Unsuµ‹ãd
 :
åue
.
B


991 }.
ñ£whí
 (
aut€xec
 && 
comm™dRegIsUnsuµ‹ãd
) {

992 
îr‹Unsuµ‹ãd
 :
åue
.
B


994 }.
ñ£whí
 (
˘æSèãReg
 ==
CålSèã
(
CheckGíî©e
)){

1001 
whí
 (
comm™dRegIsUnsuµ‹ãd
) {

1002 
îr‹Unsuµ‹ãd
 :
åue
.
B


1003 
˘æSèãNxt
 :
CålSèã
(
Waôög
)

1004 }.
ñ£whí
 (
comm™dRegBadHÆtResume
){

1005 
îr‹HÆtResume
 :
åue
.
B


1006 
˘æSèãNxt
 :
CålSèã
(
Waôög
)

1007 }.
Ÿhîwi£
 {

1008 
whí
(
ac˚ssRegIsCu°om
) {

1009 
˘æSèãNxt
 :
CålSèã
(
Cu°om
)

1010 }.
Ÿhîwi£
 {

1011 
˘æSèãNxt
 :
CålSèã
(
Exec
)

1012 
goAb°ø˘
 :
åue
.
B


1015 }.
ñ£whí
 (
˘æSèãReg
 ==
CålSèã
(
Exec
)) {

1020 
whí
(
goReg
 ==
Ál£
.
B
 && 
h¨tHÆãdWrEn
 && (
h¨tSñFuncs
.
h¨tIdToH¨tSñ
(
h¨tHÆãdId
Ë==
£À˘edH¨tReg
)){

1021 
˘æSèãNxt
 :
CålSèã
(
Waôög
)

1023 
whí
(
h¨tEx˚±i⁄WrEn
) {

1024 
as£π
(
h¨tEx˚±i⁄Id
 === 0.U, "Unexpected 'EXCEPTION' hart")

1025 
	g˘æSèãNxt
 :
CålSèã
(
Waôög
)

1026 
îr‹Ex˚±i⁄
 :
åue
.
B


1028 }.
ñ£whí
 (
˘æSèãReg
 ==
CålSèã
(
Cu°om
)) {

1029 
as£π
(
√edCu°om
.
B
, "ShouldÇot be in custom state unless weÇeed it.")

1030 
goCu°om
 :
åue
.
B


1031 
vÆ
 (
cu°om
, 
cu°omP
Ë
cu°omNode
.
ö
.
hód


1032 
whí
 (
cu°om
.
ªady
 && cu°om.
vÆid
) {

1033 
˘æSèãNxt
 :
CålSèã
(
Waôög
)

1037 
whí
 (~
io
.
dma˘ive
) {

1038 
˘æSèãReg
 :
CålSèã
(
Waôög
)

1039 }.
Ÿhîwi£
 {

1040 
˘æSèãReg
 :
˘æSèãNxt


1042 
as£π
 ((!
h¨tEx˚±i⁄WrEn
 || 
˘æSèãReg
 ==
CålSèã
(
Exec
)),

1051 
˛ass
 
TLDebugModuÀI¬îAsync
(
devi˚
: 
Devi˚
, 
gëNComp⁄íts
: (Ë=> 
I¡
, 
bótByãs
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
{

1053 
vÆ
 
dmI¬î
 = 
LazyModuÀ
(
√w
 
TLDebugModuÀI¬î
(
devi˚
, 
gëNComp⁄íts
, 
bótByãs
))

1054 
vÆ
 
	gdmiXög
 = 
LazyModuÀ
(
√w
 
TLAsyncCrossögSök
(
AsyncQueueP¨ams
.
sögÀt⁄
()))

1055 
vÆ
 
dmiNode
 = 
dmiXög
.
node


1056 
vÆ
 
éNode
 = 
dmI¬î
.tlNode

1058 
dmI¬î
.
dmiNode
 :
dmiXög
.
node


1060 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

1062 
vÆ
 
io
 = 
IO
(
√w
 
BundÀ
 {

1064 
vÆ
 
dma˘ive
 = 
Boﬁ
(
INPUT
)

1065 
vÆ
 
ö√rCål
 = 
√w
 
AsyncBundÀ
“ew 
DebugI¡î«lBundÀ
(), 
AsyncQueueP¨ams
.
sögÀt⁄
()).
Êù


1067 
vÆ
 
debugU«vaû
 = 
Vec
(
gëNComp⁄íts
(), 
Boﬁ
()).
asI≈ut


1068 
vÆ
 
psd
 = 
√w
 
PSDTe°Mode
().
asI≈ut


1071 
	gdmI¬î
.
	gmoduÀ
.
	gio
.
	gö√rCål
 :
FromAsyncBundÀ
(
io
.
ö√rCål
)

1072 
dmI¬î
.
moduÀ
.
io
.
dma˘ive
 :~
Re£tC©chAndSync
(
˛ock
, ~io.dma˘ive, "dma˘iveSync", io.
psd
)

1073 
	gdmI¬î
.
	gmoduÀ
.
	gio
.
	gdebugU«vaû
 :
io
.
debugU«vaû


1082 ˛as†
	cTLDebugModuÀ
(
bótByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

1084 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("debug-c⁄åﬁÀr", 
	`Seq
("sifive,debug-013","riscv,debug-013")){

1085 
ovîride
 
vÆ
 
ÆwaysExãnded
 = 
åue


1088 
vÆ
 
dmOuãr
 = 
	`LazyModuÀ
(
√w
 
	$TLDebugModuÀOuãrAsync
(
devi˚
)(
p
))

1089 
vÆ
 
dmI¬î
 = 
	`LazyModuÀ
(
√w
 
	`TLDebugModuÀI¬îAsync
(
devi˚
, (Ë=> {
dmOuãr
.dmOuãr.
öäode
.
edges
.
out
.
size
}, bótByãs)’))

1091 
vÆ
 
	gnode
 = 
dmI¬î
.
éNode


1092 
vÆ
 
öäode
 = 
dmOuãr
.intnode

1094 
dmI¬î
.
dmiNode
 :
dmOuãr
.
dmiI¬îNode


1096 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

1097 
vÆ
 
nComp⁄íts
 = 
dmOuãr
.dmOuãr.
öäode
.
edges
.
out
.
size


1099 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

1100 
vÆ
 
˘æ
 = 
√w
 
	`DebugCålBundÀ
(
nComp⁄íts
)

1101 
vÆ
 
dmi
 = 
√w
 
	`ClockedDMIIO
().
Êù


1102 
vÆ
 
psd
 = 
√w
 
	`PSDTe°Mode
().
asI≈ut


1105 
dmOuãr
.
moduÀ
.
io
.
dmi
 <> io.dmi.dmi

1106 
dmOuãr
.
moduÀ
.
ª£t
 :
io
.
dmi
.
dmiRe£t


1107 
dmOuãr
.
moduÀ
.
˛ock
 :
io
.
dmi
.
dmiClock


1109 
dmI¬î
.
moduÀ
.
io
.
ö√rCål
 :
dmOuãr
.module.io.innerCtrl

1110 
dmI¬î
.
moduÀ
.
io
.
dma˘ive
 :
dmOuãr
.moduÀ.io.
˘æ
.dmactive

1111 
dmI¬î
.
moduÀ
.
io
.
debugU«vaû
 :io.
˘æ
.debugUnavail

1113 
dmI¬î
.
moduÀ
.
io
.
psd
 <> io.psd

1115 
io
.
˘æ
 <> 
dmOuãr
.
moduÀ
.io.ctrl

1117 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugRomContents.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


5 
obje˘
 
	gDebugRomC⁄ã¡s
 {

7 
def
 
≠∂y
(Ë: 
Aºay
[
Byã
] = { Array (

15 ).
m≠
(
_
.
toByã
) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugTransport.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gjèg
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


12 
˛ass
 
	$JègDTMC⁄fig
 (

13 
idcodeVîsi⁄
 : 
I¡
,

14 
idcodeP¨tNum
 : 
I¡
,

15 
idcodeM™ufId
 : 
I¡
,

21 
debugIdÀCy˛es
 : 
I¡
)

23 
obje˘
 
JègDTMKey
 
exãnds
 
Fõld
[
JègDTMC⁄fig
](
√w
 
	$JègDTMKeyDeÁu…
())

25 
˛ass
 
JègDTMKeyDeÁu…
 
exãnds
 
	$JègDTMC⁄fig
(

26 
idcodeVîsi⁄
 = 0,

27 
idcodeP¨tNum
 = 0,

28 
idcodeM™ufId
 = 0,

29 
debugIdÀCy˛es
 = 5)

31 
obje˘
 
dtmJTAGAddrs
 {

32 
def
 
IDCODE
 = 0x1

33 
def
 
DTM_INFO
 = 0x10

34 
def
 
DMI_ACCESS
 = 0x11

35 
	}
}

37 ˛as†
	cDMIAc˚ssUpd©e
(
addrBôs
: 
I¡
Ë
exãnds
 
BundÀ
 {

38 
vÆ
 
addr
 = 
	$UI¡
(
width
 = 
addrBôs
)

39 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
DMIC⁄°s
.
dmiD©aSize
)

40 
vÆ
 
›
 = 
	$UI¡
(
width
 = 
DMIC⁄°s
.
dmiOpSize
)

42 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`DMIAc˚ssUpd©e
(
addrBôs
).
asIn°™˚Of
[
this
.
ty≥
]

45 ˛as†
	cDMIAc˚ssC≠tuª
(
addrBôs
: 
I¡
Ë
exãnds
 
BundÀ
 {

46 
vÆ
 
addr
 = 
	$UI¡
(
width
 = 
addrBôs
)

47 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
DMIC⁄°s
.
dmiD©aSize
)

48 
vÆ
 
ª•
 = 
	$UI¡
(
width
 = 
DMIC⁄°s
.
dmiRe•Size
)

50 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`DMIAc˚ssC≠tuª
(
addrBôs
).
asIn°™˚Of
[
this
.
ty≥
]

54 ˛as†
	cDTMInfo
 
exãnds
 
BundÀ
 {

55 
vÆ
 
ª£rved1
 = 
	$UI¡
(15.
W
)

56 
vÆ
 
dmúe£t
 = 
	$Boﬁ
()

57 
vÆ
 
ª£rved0
 = 
	$UI¡
(1.
W
)

58 
vÆ
 
dmiIdÀCy˛es
 = 
	$UI¡
(3.
W
)

59 
vÆ
 
dmiSètus
 = 
	$UI¡
(2.
W
)

60 
vÆ
 
debugAddrBôs
 = 
	$UI¡
(6.
W
)

61 
vÆ
 
debugVîsi⁄
 = 
	`UI¡
(4.
W
)

65 ˛as†
	cSy°emJTAGIO
 
exãnds
 
BundÀ
 {

66 
vÆ
 
jèg
 = 
√w
 
	`JTAGIO
(
hasTRSTn
 = 
Ál£
).
Êù


67 
vÆ
 
ª£t
 = 
	$Boﬁ
(
INPUT
)

68 
vÆ
 
m‰_id
 = 
	`UI¡
(
INPUT
, 11)

71 
˛ass
 
	$DebugTøn•‹tModuÀJTAG
(
debugAddrBôs
: 
I¡
, 
c
: 
JègDTMC⁄fig
)

72 (
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

74 
vÆ
 
io
 = 
√w
 
BundÀ
 {

75 
vÆ
 
dmi
 = 
√w
 
	`DMIIO
()(
p
)

76 
vÆ
 
jèg
 = 
	`Flù≥d
(
√w
 
	`JTAGIO
(
hasTRSTn
 = 
Ál£
))

77 
vÆ
 
jèg_ª£t
 = 
	`Boﬁ
(
INPUT
)

78 
vÆ
 
jèg_m‰_id
 = 
	`UI¡
(
INPUT
, 11)

79 
vÆ
 
fsmRe£t
 = 
	`Boﬁ
(
OUTPUT
)

85 
vÆ
 
dtmInfo
 = 
	`Wúe
(
√w
 
DTMInfo
)

87 
vÆ
 
busyReg
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

88 
vÆ
 
°ickyBusyReg
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

89 
vÆ
 
°ickyN⁄zîoRe•Reg
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

91 
vÆ
 
skùOpReg
 = 
	`Reg
(
öô
 = 
	`Boﬁ
(
Ál£
))

92 
vÆ
 
downgødeOpReg
 = 
	`Reg
(
öô
 = 
	`Boﬁ
(
Ál£
))

94 
vÆ
 
busy
 = 
	`Wúe
(
	`Boﬁ
())

95 
vÆ
 
n⁄zîoRe•
 = 
	`Wúe
(
	`Boﬁ
())

97 
vÆ
 
busyRe•
 = 
	`Wúe
(
√w
 
	`DMIAc˚ssC≠tuª
(
debugAddrBôs
))

98 
vÆ
 
n⁄busyRe•
 = 
	`Wúe
(
√w
 
	`DMIAc˚ssC≠tuª
(
debugAddrBôs
))

99 
vÆ
 
dmiRe•
 = 
	`Wúe
(
√w
 
	`DMIAc˚ssC≠tuª
(
debugAddrBôs
))

100 
vÆ
 
n›Re•
 = 
	`Wúe
(
√w
 
	`DMIAc˚ssC≠tuª
(
debugAddrBôs
))

103 
vÆ
 
dmiReqReg
 = 
	`Reg
(
√w
 
	`DMIReq
(
debugAddrBôs
))

104 
vÆ
 
dmiReqVÆidReg
 = 
	`Reg
(
öô
 = 
	`Boﬁ
(
Ál£
));

106 
vÆ
 
dmiSètus
 = 
	`Wúe
(
	`UI¡
(
width
 = 2))

111 
dmiSètus
 :
	`C©
(
°ickyN⁄zîoRe•Reg
, stickyN⁄zîoRe•Reg | 
°ickyBusyReg
)

113 
dtmInfo
.
debugVîsi⁄
 := 1.U

114 
dtmInfo
.
debugAddrBôs
 :
	`UI¡
(debugAddrBits)

115 
dtmInfo
.
dmiSètus
 := dmiStatus

116 
dtmInfo
.
dmiIdÀCy˛es
 :
	`UI¡
(
c
.
debugIdÀCy˛es
)

117 
dtmInfo
.
ª£rved0
 := 0.U

118 
dtmInfo
.
dmúe£t
 :
Ál£
.
B


119 
dtmInfo
.
ª£rved1
 := 0.U

121 
vÆ
 
dtmInfoChaö
 = 
	`ModuÀ
 (
	`C≠tuªUpd©eChaö
(
gí
 = 
√w
 
	`DTMInfo
()))

122 
dtmInfoChaö
.
io
.
ˇ±uª
.
bôs
 :
dtmInfo


127 
vÆ
 
dmiAc˚ssChaö
 = 
	`ModuÀ
(
	`C≠tuªUpd©eChaö
(
gíC≠tuª
 = 
√w
 
	`DMIAc˚ssC≠tuª
(
debugAddrBôs
),

128 
gíUpd©e
 = 
√w
 
	`DMIAc˚ssUpd©e
(
debugAddrBôs
)))

136 
	`whí
 (
io
.
dmi
.
ªq
.
vÆid
) {

137 
busyReg
 :
	`Boﬁ
(
åue
)

139 
	`whí
 (
io
.
dmi
.
ª•
.
	`fúe
()) {

140 
busyReg
 :
	`Boﬁ
(
Ál£
)

148 
busy
 :(
busyReg
 & !
io
.
dmi
.
ª•
.
vÆid
Ë| 
°ickyBusyReg
;

153 
	`whí
 (
dmiAc˚ssChaö
.
io
.
upd©e
.
vÆid
) {

154 
skùOpReg
 :
	`Boﬁ
(
Ál£
)

155 
downgødeOpReg
 :
	`Boﬁ
(
Ál£
)

157 
	`whí
 (
dmiAc˚ssChaö
.
io
.
ˇ±uª
.capture) {

158 
skùOpReg
 :
busy


159 
downgødeOpReg
 :(!
busy
 & 
n⁄zîoRe•
)

160 
°ickyBusyReg
 :
busy


161 
°ickyN⁄zîoRe•Reg
 :
n⁄zîoRe•


163 
	`whí
 (
dtmInfoChaö
.
io
.
upd©e
.
vÆid
) {

164 
	`whí
 (
dtmInfoChaö
.
io
.
upd©e
.
bôs
.
dmúe£t
) {

165 
°ickyN⁄zîoRe•Reg
 :
	`Boﬁ
(
Ál£
)

166 
°ickyBusyReg
 :
	`Boﬁ
(
Ál£
)

176 
n⁄zîoRe•
 :
°ickyN⁄zîoRe•Reg
 | (
io
.
dmi
.
ª•
.
vÆid
 & (io.dmi.ª•.
bôs
.ª• =/
	`UI¡
(0)))

177 
	`as£π
(!
n⁄zîoRe•
, "There isÇoÑeasonÅo getáÇon zeroÑesponse inÅhe current system.");

178 
	`as£π
(!
°ickyN⁄zîoRe•Reg
, "There isÇoÑeasonÅo haveá stickyÇon zeroÑesponse inÅhe current system.");

180 
busyRe•
.
addr
 :
	`UI¡
(0)

181 
busyRe•
.
ª•
 :
	`Fûl
(
DMIC⁄°s
.
dmiRe•Size
, 1.U)

182 
busyRe•
.
d©a
 :
	`UI¡
(0)

184 
dmiRe•
.
addr
 :
dmiReqReg
.addr

185 
dmiRe•
.
ª•
 :
io
.
dmi
.ª•.
bôs
.resp

186 
dmiRe•
.
d©a
 :
io
.
dmi
.
ª•
.
bôs
.data

188 
n›Re•
.
addr
 :
	`UI¡
(0)

189 
n›Re•
.
ª•
 :
	`UI¡
(0)

190 
n›Re•
.
d©a
 :
	`UI¡
(0)

195 
dmiAc˚ssChaö
.
io
.
ˇ±uª
.
bôs
 :
	`Mux
(
busy
, 
busyRe•
, Mux(io.
dmi
.
ª•
.
vÆid
, 
dmiRe•
, 
n›Re•
))

196 
	`whí
 (
dmiAc˚ssChaö
.
io
.
upd©e
.
vÆid
) {

197 
skùOpReg
 :
	`Boﬁ
(
Ál£
)

198 
downgødeOpReg
 :
	`Boﬁ
(
Ál£
)

200 
	`whí
 (
dmiAc˚ssChaö
.
io
.
ˇ±uª
.capture) {

201 
skùOpReg
 :
busy


202 
downgødeOpReg
 :(!
busy
 & 
n⁄zîoRe•
)

203 
°ickyBusyReg
 :
busy


204 
°ickyN⁄zîoRe•Reg
 :
n⁄zîoRe•


210 
vÆ
 
dmiReqVÆidCheck
 = 
	`Wúe
(
öô
 = 
	`Boﬁ
(
Ál£
))

211 
	`as£π
(!(
dmiReqVÆidCheck
 && 
io
.
dmi
.
ªq
.
	`fúe
()), "Conflicting updates for dmiReqValidReg, shouldÇot happen.");

213 
	`whí
 (
dmiAc˚ssChaö
.
io
.
upd©e
.
vÆid
) {

214 
	`whí
 (
skùOpReg
) {

216 }.
	`ñ£whí
 (
downgødeOpReg
 || (
dmiAc˚ssChaö
.
io
.
upd©e
.
bôs
.
›
 ==
DMIC⁄°s
.
dmi_OP_NONE
)) {

218 
dmiReqReg
.
addr
 :
	`UI¡
(0)

219 
dmiReqReg
.
d©a
 :
	`UI¡
(0)

220 
dmiReqReg
.
›
 :
	`UI¡
(0)

221 }.
Ÿhîwi£
 {

222 
dmiReqReg
 :
dmiAc˚ssChaö
.
io
.
upd©e
.
bôs


223 
dmiReqVÆidReg
 :
	`Boﬁ
(
åue
)

224 
dmiReqVÆidCheck
 :
	`Boﬁ
(
åue
)

228 
	`whí
 (
io
.
dmi
.
ªq
.
	`fúe
()) {

229 
dmiReqVÆidReg
 :
	`Boﬁ
(
Ál£
)

232 
io
.
dmi
.
ª•
.
ªady
 :
	`Mux
(

233 
dmiReqReg
.
›
 ==
DMIC⁄°s
.
dmi_OP_WRITE
,

235 
io
.
dmi
.
ª•
.
vÆid
,

237 
dmiAc˚ssChaö
.
io
.
ˇ±uª
.capture)

240 
	`covî
(
dmiReqReg
.
›
 ==
DMIC⁄°s
.
dmi_OP_WRITE
 & 
dmiAc˚ssChaö
.
io
.
ˇ±uª
.ˇ±uª & 
busy
, "NotÉnough Idleáfter DMI Write");

242 
	`covî
(
dmiReqReg
.
›
 ==
DMIC⁄°s
.
dmi_OP_WRITE
 & 
dmiAc˚ssChaö
.
io
.
ˇ±uª
.ˇ±uª & !
busy
, "Enough Idleáfter DMI Write");

245 
	`covî
(
dmiReqReg
.
›
 ==
DMIC⁄°s
.
dmi_OP_READ
 & 
dmiAc˚ssChaö
.
io
.
ˇ±uª
.ˇ±uª & 
busy
, "NotÉnough Idleáfter DMI Read");

247 
	`covî
(
dmiReqReg
.
›
 ==
DMIC⁄°s
.
dmi_OP_READ
 & 
dmiAc˚ssChaö
.
io
.
ˇ±uª
.ˇ±uª & !
busy
, "Enough Idleáfter DMI Read");

249 
io
.
dmi
.
ªq
.
vÆid
 :
dmiReqVÆidReg


252 
io
.
dmi
.
ªq
.
bôs
 :
dmiReqReg


256 
vÆ
 
idcode
 = 
	`Wúe
(
öô
 = 
√w
 
	`JTAGIdcodeBundÀ
().
	`‰omBôs
(0.U))

257 
idcode
.
Æways1
 := 1.U

258 
idcode
.
vîsi⁄
 :
c
.
idcodeVîsi⁄
.
U


259 
idcode
.
∑πNumbî
 :
c
.
idcodeP¨tNum
.
U


260 
idcode
.
m‰Id
 :
io
.
jèg_m‰_id


262 
vÆ
 
èpIO
 = 
	`JègT≠Gíî©‹
(
úLígth
 = 5,

263 
ö°ru˘i⁄s
 = 
	`M≠
(

264 
dtmJTAGAddrs
.
DMI_ACCESS
 -> 
dmiAc˚ssChaö
,

265 
dtmJTAGAddrs
.
DTM_INFO
 -> 
dtmInfoChaö
),

266 
icode
 = 
	`Some
(
dtmJTAGAddrs
.
IDCODE
)

269 
èpIO
.
idcode
.
gë
 := idcode

270 
èpIO
.
jèg
 <> 
io
.jtag

272 
èpIO
.
c⁄åﬁ
.
jèg_ª£t
 :
io
.jtag_reset

278 
io
.
fsmRe£t
 :
èpIO
.
ouçut
.
ª£t


280 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Periphery.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gc‹e
.{
	gI¡P¨am
, 
	gI≈ut
, 
	gOuçut
}

7 
imp‹t
 
	gchi£l3
.
	gutû
.
HasBœckBoxResour˚


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gjèg
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


17 
obje˘
 
In˛udeJègDTM
 
exãnds
 
	gFõld
[
Boﬁón
](
	gÁl£
)

21 ˛as†
	cDebugIO
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
Ë
wôh
 
C™HavePSDTe°ModeIO
 {

22 
vÆ
 
˛ockeddmi
 = (!
	`p
(
In˛udeJègDTM
)).
	`›ti⁄
(
√w
 
	`ClockedDMIIO
().
Êù
)

23 
vÆ
 
sy°emjèg
 = (
	`p
(
In˛udeJègDTM
)).
	$›ti⁄
(
√w
 
Sy°emJTAGIO
)

24 
vÆ
 
ndª£t
 = 
	$Boﬁ
(
OUTPUT
)

25 
vÆ
 
dma˘ive
 = 
	`Boﬁ
(
OUTPUT
)

31 
åaô
 
HasPîùhîyDebug
 { 
this
: 
Ba£Subsy°em
 =>

32 
vÆ
 
debug
 = 
	`LazyModuÀ
(
√w
 
	`TLDebugModuÀ
(
sbus
.
c⁄åﬁ_bus
.
bótByãs
))

33 
sbus
.
c⁄åﬁ_bus
.
	`toV¨übÀWidthSœve
(
	`Some
("debug")){ 
debug
.
node
 }

34 
vÆ
 
debugCu°omXb¨
 = 
	`LazyModuÀ
–
√w
 
	`DebugCu°omXb¨
(
ouçutRequúesI≈ut
 = 
Ál£
))

35 
debug
.
dmI¬î
.dmI¬î.
cu°omNode
 :
debugCu°omXb¨
.
node


37 
debug
.
dmI¬î
.dmI¬î.
sb2éO±
.
f‹óch
 { 
sb2é
 =>

38 
fbus
.
	`‰omP‹t
(
	`Some
("debug_sb")){ 
FlùRídîög
 { 
im∂icô
 
p
 => 
	`TLWidthWidgë
(1Ë:
sb2é
.
node
 } }

40 
	}
}

42 
åaô
 
HasPîùhîyDebugModuÀImp
 
exãnds
 
LazyModuÀImp
 {

43 
vÆ
 
ouãr
: 
HasPîùhîyDebug


45 
vÆ
 
debug
 = 
IO
(
√w
 
DebugIO
)

47 
debug
.
˛ockeddmi
.
f‹óch
 { 
dbg
 => 
ouãr
.debug.
moduÀ
.
io
.
dmi
 <> dbg }

49 
vÆ
 
dtm
 = 
debug
.
sy°emjèg
.
m≠
 { 
sj
 =>

51 
vÆ
 
dtm
 = 
ModuÀ
(
√w
 
DebugTøn•‹tModuÀJTAG
(
p
(
DebugModuÀP¨ams
).
nDMIAddrSize
,Ö(
JègDTMKey
)))

52 
	gdtm
.
	gio
.
	gjèg
 <> 
	gsj
.
jèg


54 
	gdtm
.
	g˛ock
 :
sj
.
jèg
.
TCK


55 
dtm
.
io
.
jèg_ª£t
 :
sj
.
ª£t


56 
dtm
.
io
.
jèg_m‰_id
 :
sj
.
m‰_id


57 
dtm
.
ª£t
 :dtm.
io
.
fsmRe£t


59 
ouãr
.
debug
.
moduÀ
.
io
.
dmi
.dmò<> 
dtm
.io.dmi

60 
ouãr
.
debug
.
moduÀ
.
io
.
dmi
.
dmiClock
 :
sj
.
jèg
.
TCK


62 
vÆ
 
psd
 = 
debug
.psd.
gëOrEl£
(
Wúe
(
√w
 
PSDTe°Mode
).
‰omBôs
(0.U))

63 
ouãr
.
debug
.
moduÀ
.
io
.
psd
 <>Ösd

64 
ouãr
.
debug
.
moduÀ
.
io
.
dmi
.
dmiRe£t
 :
Re£tC©chAndSync
(
sj
.
jèg
.
TCK
, sj.
ª£t
, "dmiRe£tC©ch", 
psd
)

65 
	gdtm


68 
	gdebug
.
	gndª£t
 :
ouãr
.
debug
.
moduÀ
.
io
.
˘æ
.
ndª£t


69 
debug
.
dma˘ive
 :
ouãr
.debug.
moduÀ
.
io
.
˘æ
.dmactive

72 
ouãr
.
debug
.
moduÀ
.
io
.
˘æ
.
debugU«vaû
.
f‹óch
 { 
_
 :
Boﬁ
(
Ál£
) }

75 ˛as†
	cSimDTM
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
BœckBox
 
wôh
 
HasBœckBoxResour˚
 {

76 
vÆ
 
io
 = 
√w
 
BundÀ
 {

77 
vÆ
 
˛k
 = 
	`Clock
(
INPUT
)

78 
vÆ
 
ª£t
 = 
	`Boﬁ
(
INPUT
)

79 
vÆ
 
debug
 = 
√w
 
DMIIO


80 
vÆ
 
exô
 = 
	`UI¡
(
OUTPUT
, 32)

83 
def
 
	`c⁄√˘
(
tb˛k
: 
Clock
, 
tbª£t
: 
Boﬁ
, 
dutio
: 
ClockedDMIIO
, 
tbsuc˚ss
: Bool) = {

84 
io
.
˛k
 :
tb˛k


85 
io
.
ª£t
 :
tbª£t


86 
dutio
.
dmi
 <> 
io
.
debug


87 
dutio
.
dmiClock
 :
tb˛k


88 
dutio
.
dmiRe£t
 :
tbª£t


90 
tbsuc˚ss
 :
io
.
exô
 ==
	`UI¡
(1)

91 
	`whí
 (
io
.
exô
 >
	`UI¡
(2)) {

92 
	`¥ötf
("*** FAILED *** (exô codê%d)\n", 
io
.
exô
 >> 
	`UI¡
(1))

93 
	`°›
(1)

95 
	}
}

97 
£tResour˚
("/vsrc/SimDTM.v")

98 
£tResour˚
("/csrc/SimDTM.cc")

101 
˛ass
 
	$SimJTAG
(
tickDñay
: 
I¡
 = 50Ë
exãnds
 
	`BœckBox
(
	`M≠
("TICK_DELAY" -> 
	$I¡P¨am
(
tickDñay
)))

102 
wôh
 
HasBœckBoxResour˚
 {

103 
vÆ
 
io
 = 
√w
 
BundÀ
 {

104 
vÆ
 
˛ock
 = 
	`Clock
(
INPUT
)

105 
vÆ
 
ª£t
 = 
	`Boﬁ
(
INPUT
)

106 
vÆ
 
jèg
 = 
√w
 
	`JTAGIO
(
hasTRSTn
 = 
åue
)

107 
vÆ
 
íabÀ
 = 
	`Boﬁ
(
INPUT
)

108 
vÆ
 
öô_d⁄e
 = 
	`Boﬁ
(
INPUT
)

109 
vÆ
 
exô
 = 
	`UI¡
(
OUTPUT
, 32)

112 
def
 
	`c⁄√˘
(
dutio
: 
JTAGIO
, 
tb˛ock
: 
Clock
, 
tbª£t
: 
Boﬁ
, 
öô_d⁄e
: Boﬁ, 
tbsuc˚ss
: Bool) = {

113 
dutio
 <> 
io
.
jèg


115 
io
.
˛ock
 :
tb˛ock


116 
io
.
ª£t
 :
tbª£t


118 
io
.
íabÀ
 :
	`PlusArg
("jtag_rbb_enable", 0, "Enable SimJTAG for JTAG Connections. Simulation willÖause until connection is made.")

119 
io
.
öô_d⁄e
 := init_done

123 
tbsuc˚ss
 :
io
.
exô
 ==
	`UI¡
(1)

124 
	`whí
 (
io
.
exô
 >
	`UI¡
(2)) {

125 
	`¥ötf
("*** FAILED *** (exô codê%d)\n", 
io
.
exô
 >> 
	`UI¡
(1))

126 
	`°›
(1)

130 
	`£tResour˚
("/vsrc/SimJTAG.v")

131 
	`£tResour˚
("/csrc/SimJTAG.cc")

132 
	`£tResour˚
("/csrc/remote_bitbang.h")

133 
	`£tResour˚
("/csrc/remote_bitbang.cc")

134 
	}
}

136 
obje˘
 
	gDebug
 {

137 
def
 
c⁄√˘Debug
(

138 
debug
: 
DebugIO
,

139 
c
: 
Clock
,

140 
r
: 
Boﬁ
,

141 
out
: 
Boﬁ
,

142 
tckHÆfPîiod
: 
I¡
 = 2,

143 
cmdDñay
: 
I¡
 = 2,

144 
psd
: 
PSDTe°Mode
 = 
√w
 PSDTe°Mode().
‰omBôs
(0.U))

145 (
im∂icô
 
p
: 
P¨amëîs
): 
Unô
 = {

146 
debug
.
˛ockeddmi
.
f‹óch
 { 
d
 =>

147 
vÆ
 
dtm
 = 
ModuÀ
(
√w
 
SimDTM
).
c⁄√˘
(
c
, 
r
, 
d
, 
out
)

149 
	gdebug
.
	gsy°emjèg
.
	gf‹óch
 { 
	gsj
 =>

150 
vÆ
 
jèg
 = 
ModuÀ
(
√w
 
SimJTAG
(
tickDñay
=3)).
c⁄√˘
(
sj
.jèg, 
c
, 
r
, ~r, 
out
)

151 
	gsj
.
	gª£t
 :
r


152 
sj
.
m‰_id
 :
p
(
JègDTMKey
).
idcodeM™ufId
.
U
(11.
W
)

154 
debug
.
psd
.
f‹óch
 { 
_
 <>Ösd }

157 
def
 
tõoffDebug
(
debug
: 
DebugIO
): 
Boﬁ
 = {

158 
debug
.
sy°emjèg
.
f‹óch
 { 
sj
 =>

159 
sj
.
jèg
.
TCK
 :
Boﬁ
(
åue
).
asClock


160 
sj
.
jèg
.
TMS
 :
Boﬁ
(
åue
)

161 
sj
.
jèg
.
TDI
 :
Boﬁ
(
åue
)

162 
sj
.
jèg
.
TRSTn
.
f‹óch
 { 
r
 =>Ñ :
Boﬁ
(
åue
) }

163 
sj
.
ª£t
 :
Boﬁ
(
åue
)

164 
sj
.
m‰_id
 := 0.U

167 
debug
.
˛ockeddmi
.
f‹óch
 { 
d
 =>

168 
d
.
dmi
.
ªq
.
vÆid
 :
Boﬁ
(
Ál£
)

169 
d
.
dmi
.
ª•
.
ªady
 :
Boﬁ
(
åue
)

170 
d
.
dmiClock
 :
Boﬁ
(
Ál£
).
asClock


171 
d
.
dmiRe£t
 :
Boﬁ
(
åue
)

173 
debug
.
psd
.
f‹óch
 { 
_
 <> 
√w
 
PSDTe°Mode
().
‰omBôs
(0.U)}

174 
debug
.
ndª£t


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/SBA.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.
sy°embußc˚ss


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.
_


14 
obje˘
 
Sy°emBusAc˚ssSèã
 
exãnds
 
	gsˇœ
.
	gEnumî©i⁄
 {

15 
ty≥
 
	gSy°emBusAc˚ssSèã
 = 
VÆue


16 
vÆ
 
IdÀ
, 
	gSBRódReque°
, 
	gSBWrôeReque°
, 
	gSBRódRe•⁄£
, 
	gSBWrôeRe•⁄£
 = 
VÆue


18 
imp‹t
 
	gSy°emBusAc˚ssSèã
.
_


20 
obje˘
 
SBEº‹Code
 
exãnds
 
	gsˇœ
.
	gEnumî©i⁄
 {

21 
ty≥
 
	gSBEº‹Code
 = 
VÆue


22 
vÆ
 
NoEº‹
 = 
VÆue
(0)

23 
vÆ
 
Timeout
 = 
VÆue
(1)

24 
vÆ
 
BadAddr
 = 
VÆue
(2)

25 
vÆ
 
AlgnEº‹
 = 
VÆue
(3)

26 
vÆ
 
BadAc˚ss
 = 
VÆue
(4)

27 
vÆ
 
OthîEº‹
 = 
VÆue
(7)

29 
imp‹t
 
	gSBEº‹Code
.
_


31 
obje˘
 
	gSy°emBusAc˚ssModuÀ


33 
def
 
≠∂y
(
sb2é
: 
SBToTL
, 
dma˘ive
: 
Boﬁ
)(
im∂icô
 
p
: 
P¨amëîs
):

34 (
Seq
[
RegFõld
], 
	gSeq
[Seq[RegField]], Seq[Seq[RegField]]) =

36 
imp‹t
 
SBEº‹Code
.
_


37 
imp‹t
 
DMI_RegAddrs
.
_


39 
vÆ
 
cfg
 = 
p
(
DebugModuÀP¨ams
)

41 
vÆ
 
™yAddªssWrEn
 = 
Wúe
(
öô
 = 
Ál£
.
B
).
sugge°Name
("anyAddressWrEn")

42 
vÆ
 
™yD©aRdEn
 = 
Wúe
(
öô
 = 
Ál£
.
B
).
sugge°Name
("anyDataRdEn")

43 
vÆ
 
™yD©aWrEn
 = 
Wúe
(
öô
 = 
Ál£
.
B
).
sugge°Name
("anyDataWrEn")

46 
vÆ
 
SBCSFõldsReg
 = 
Reg
(
√w
 
SBCSFõlds
()).
sugge°Name
("SBCSFieldsReg")

48 
vÆ
 
SBCSFõldsRegRe£t
 = 
Wúe
(
öô
 = (
√w
 
SBCSFõlds
()).
‰omBôs
(0.U))

49 
SBCSFõldsRegRe£t
.
sbvîsi⁄
 :1.U(1.
W
)

50 
SBCSFõldsRegRe£t
.
sbbusy
 :(
sb2é
.
moduÀ
.
io
.
sbSèãOut
 =/
Sy°emBusAc˚ssSèã
.
IdÀ
.
id
.
U
)

51 
SBCSFõldsRegRe£t
.
sbasize
 :
sb2é
.
moduÀ
.
edge
.
bundÀ
.
addªssBôs
.
U


52 
SBCSFõldsRegRe£t
.
sbac˚ss128
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 =128).
B


53 
SBCSFõldsRegRe£t
.
sbac˚ss64
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >64).
B


54 
SBCSFõldsRegRe£t
.
sbac˚ss32
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >32).
B


55 
SBCSFõldsRegRe£t
.
sbac˚ss16
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >16).
B


56 
SBCSFõldsRegRe£t
.
sbac˚ss8
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >8).
B


58 
vÆ
 
SBCSRdD©a
 = 
Wúe
(
öô
 = 
√w
 
SBCSFõlds
().
‰omBôs
(0.U)).
sugge°Name
("SBCSRdData")

60 
vÆ
 
SBCSWrD©aVÆ
 = 
Wúe
(
öô
 = 0.U(32.
W
))

61 
vÆ
 
SBCSWrD©a
 = 
Wúe
(
öô
 = 
√w
 
SBCSFõlds
().
‰omBôs
(
SBCSWrD©aVÆ
))

63 
vÆ
 
SBCSRdEn
, 
	gSBCSWrEn
 = 
Wúe
(
öô
 = 
Ál£
.
B
)

64 
SBCSWrEn
.
sugge°Name
("SBCSWrEn")

65 
SBCSRdEn
.
sugge°Name
("SBCSRdEn")

67 
vÆ
 
sbcsfõlds
 = 
Seq
(
RWNŸify
(32, 
SBCSRdD©a
.
asUI¡
(), 
SBCSWrD©aVÆ
, 
SBCSRdEn
, 
SBCSWrEn
,

68 
Some
(
RegFõldDesc
("dmi_sbcs", ""))))

73 
vÆ
 
	ghasSBAddr1
 = (
sb2é
.
moduÀ
.
edge
.
bundÀ
.
addªssBôs
 >= 33)

74 
vÆ
 
hasSBAddr2
 = (
sb2é
.
moduÀ
.
edge
.
bundÀ
.
addªssBôs
 >= 65)

75 
vÆ
 
hasSBAddr3
 = (
sb2é
.
moduÀ
.
edge
.
bundÀ
.
addªssBôs
 >= 97)

76 
vÆ
 
hasAddr
 = 
Seq
(
åue
, 
hasSBAddr1
, 
hasSBAddr2
, 
hasSBAddr3
)

78 
vÆ
 
	gSBADDRESSFõldsReg
 = 
Seq
.
fûl
(4)(
Reg
 (
UI¡
(32.
W
)))

79 
SBADDRESSFõldsReg
.
zùWôhIndex
.
f‹óch
 { (
a
,
i
Ë=>á.
sugge°Name
("SBADDRESS"+i+"FieldsReg")}

80 
vÆ
 
	gSBADDRESSWrD©a
 = 
Seq
.
fûl
(4)(
Wúe
(
UI¡
(32.
W
)))

81 
vÆ
 
SBADDRESSRdEn
 = 
Seq
.
fûl
(4)(
Wúe
(
Boﬁ
()))

82 
vÆ
 
SBADDRESSWrEn
 = 
Seq
.
fûl
(4)(
Wúe
(
Boﬁ
()))

84 
vÆ
 
autoIn¸emíãdAddr
 = 
Wúe
(
öô
 = 0.U(128.
W
))

85 
autoIn¸emíãdAddr
 :
C©
(
SBADDRESSFõldsReg
.
ªvî£
Ë+ (1.U << 
SBCSFõldsReg
.
sbac˚ss
)

86 
autoIn¸emíãdAddr
.
sugge°Name
("autoIncrementedAddr")

88 
vÆ
 
sbaddrfõlds
: 
Seq
[Seq[
RegFõld
]] = 
SBADDRESSFõldsReg
.
zùWôhIndex
.
m≠
 { (
a
,
i
) =>

89 if(
hasAddr
(
i
)) {

90 
whí
 (~
dma˘ive
) {

91 
a
 :0.U(32.
W
)

92 }.
Ÿhîwi£
 {

93 
a
 :
Mux
(
SBADDRESSWrEn
(
i
Ë&& !
SBCSRdD©a
.
sbîr‹
 && !
SBCSFõldsReg
.
sbbusy
, 
SBADDRESSWrD©a
(i),

94 
Mux
((
sb2é
.
moduÀ
.
io
.
rdD⁄e
 || sb2é.moduÀ.io.
wrD⁄e
Ë&& 
SBCSFõldsReg
.
sbautoö¸emít
, 
autoIn¸emíãdAddr
(32*
i
+31,32*i), 
a
))

97 
Seq
(
RWNŸify
(32, 
a
, 
SBADDRESSWrD©a
(
i
), 
SBADDRESSRdEn
(i), 
SBADDRESSWrEn
(i),

98 
Some
(
RegFõldDesc
("dmi_sbaddr"+
i
, "", 
ª£t
=Some(0)))))

100 
	gSeq
.
	gem±y
[
RegFõld
]

104 
	gsb2é
.
	gmoduÀ
.
	gio
.
	gaddrIn
 :
Mux
(
sb2é
.
moduÀ
.
io
.
rdEn
,
C©
(
SBADDRESSWrD©a
.
ªvî£
),C©(
SBADDRESSFõldsReg
.reverse))

105 
	g™yAddªssWrEn
 :
SBADDRESSWrEn
.
ªdu˚
(
_
 || _)

110 
vÆ
 
hasSBD©a1
 = (
cfg
.
maxSuµ‹ãdSBAc˚ss
 > 32)

111 
vÆ
 
hasSBD©a2And3
 = (
cfg
.
maxSuµ‹ãdSBAc˚ss
 == 128)

112 
vÆ
 
hasD©a
 = 
Seq
(
åue
, 
hasSBD©a1
, 
hasSBD©a2And3
, hasSBData2And3)

114 
vÆ
 
	gSBDATAFõldsReg
 = 
Seq
.
fûl
(4)(Seq.fûl(4)(
Reg
 (
UI¡
(8.
W
))))

115 
SBDATAFõldsReg
.
zùWôhIndex
.
f‹óch
 { (
d
,
i
Ë=> d.zùWôhIndex.f‹óch { (d,
j
Ë=> d.
sugge°Name
("SBDATA"+i+"BYTE"+j) }}

116 
vÆ
 
	gSBDATARdD©a
 = 
Seq
.
fûl
(4)(
Wúe
(
UI¡
(32.
W
)))

117 
SBDATARdD©a
.
zùWôhIndex
.
f‹óch
 { (
d
,
i
Ë=> d.
sugge°Name
("SBDATARdData"+i) }

118 
vÆ
 
	gSBDATAWrD©a
 = 
Seq
.
fûl
(4)(
Wúe
(
UI¡
(32.
W
)))

119 
SBDATAWrD©a
.
zùWôhIndex
.
f‹óch
 { (
d
,
i
Ë=> d.
sugge°Name
("SBDATAWrData"+i) }

120 
vÆ
 
	gSBDATARdEn
 = 
Seq
.
fûl
(4)(
Wúe
(
Boﬁ
()))

121 
vÆ
 
SBDATAWrEn
 = 
Seq
.
fûl
(4)(
Wúe
(
Boﬁ
()))

122 
SBDATAWrEn
.
zùWôhIndex
.
f‹óch
 { (
d
,
i
Ë=> d.
sugge°Name
("SBDATAWrEn"+i) }

124 
vÆ
 
	gsbd©afõlds
: 
Seq
[Seq[
RegFõld
]] = 
SBDATAFõldsReg
.
zùWôhIndex
.
m≠
 { (
d
,
i
) =>

125 if(
hasD©a
(
i
)) {

127 
j
 <- 0 
to
 3) {

128 
whí
 (~
dma˘ive
) {

129 
d
(
j
Ë:0.U(8.
W
)

130 }.
Ÿhîwi£
 {

131 
d
(
j
Ë:
Mux
(
SBDATAWrEn
(
i
Ë&& !
SBCSFõldsReg
.
sbbusy
 && !
SBCSRdD©a
.
sbîr‹
, 
SBDATAWrD©a
(i)(8*j+7,8*j),

132 
Mux
(
sb2é
.
moduÀ
.
io
.
rdLﬂd
(4*
i
+
j
), sb2é.moduÀ.io.
d©aOut
, 
d
(j)))

136 
SBDATARdD©a
(
i
Ë:
C©
(
d
.
ªvî£
)

138 
Seq
(
RWNŸify
(32, 
SBDATARdD©a
(
i
), 
SBDATAWrD©a
(i), 
SBDATARdEn
(i), 
SBDATAWrEn
(i),

139 
Some
(
RegFõldDesc
("dmi_sbd©a"+
i
, "", 
ª£t
=Some(0)))))

141 
	gSeq
.
	gem±y
[
RegFõld
]

145 
	gsb2é
.
	gmoduÀ
.
	gio
.
	gd©aIn
 :
Mux
(
sb2é
.
moduÀ
.
io
.
wrEn
,
C©
(
SBDATAWrD©a
.
ªvî£
),C©(
SBDATAFõldsReg
.
Ê©ãn
.reverse))

146 
	g™yD©aRdEn
 :
SBDATARdEn
.
ªdu˚
(
_
 || _)

147 
™yD©aWrEn
 :
SBDATAWrEn
.
ªdu˚
(
_
 || _)

149 
vÆ
 
åyWrEn
 = 
SBDATAWrEn
(0)

150 
vÆ
 
åyRdEn
 = (
SBADDRESSWrEn
(0Ë&& 
SBCSFõldsReg
.
sbªad⁄addr
Ë|| (
SBDATARdEn
(0Ë&& SBCSFõldsReg.
sbªad⁄d©a
)

152 
vÆ
 
sbAc˚ssEº‹
 = (
SBCSFõldsReg
.
sbac˚ss
 ==0.UË&& (SBCSFõldsReg.
sbac˚ss8
 =/= 1.U) ||

153 (
SBCSFõldsReg
.
sbac˚ss
 ==1.UË&& (SBCSFõldsReg.
sbac˚ss16
 =/= 1.U) ||

154 (
SBCSFõldsReg
.
sbac˚ss
 ==2.UË&& (SBCSFõldsReg.
sbac˚ss32
 =/= 1.U) ||

155 (
SBCSFõldsReg
.
sbac˚ss
 ==3.UË&& (SBCSFõldsReg.
sbac˚ss64
 =/= 1.U) ||

156 (
SBCSFõldsReg
.
sbac˚ss
 ==4.UË&& (SBCSFõldsReg.
sbac˚ss128
 =/= 1.U)

158 
vÆ
 
com∑ªAddr
 = 
Wúe
(
UI¡
(32.
W
))

159 
com∑ªAddr
 :
Mux
(
SBADDRESSWrEn
(0),
SBADDRESSWrD©a
(0),
SBADDRESSFõldsReg
(0))

161 
vÆ
 
	gsbAlignmítEº‹
 = (
SBCSFõldsReg
.
sbac˚ss
 ==1.UË&& (
com∑ªAddr
(0) =/= 0.U) ||

162 (
SBCSFõldsReg
.
sbac˚ss
 ==2.UË&& (
com∑ªAddr
(1,0) =/= 0.U) ||

163 (
SBCSFõldsReg
.
sbac˚ss
 ==3.UË&& (
com∑ªAddr
(2,0) =/= 0.U) ||

164 (
SBCSFõldsReg
.
sbac˚ss
 ==4.UË&& (
com∑ªAddr
(3,0) =/= 0.U)

166 
sbAc˚ssEº‹
.
sugge°Name
("sbAccessError")

167 
sbAlignmítEº‹
.
sugge°Name
("sbAlignmentError")

169 
sb2é
.
moduÀ
.
io
.
wrEn
 :
åyWrEn
 && !
SBCSFõldsReg
.
sbbusy
 && !
SBCSRdD©a
.
sbîr‹
 && !
sbAc˚ssEº‹
 && !
sbAlignmítEº‹


170 
sb2é
.
moduÀ
.
io
.
rdEn
 :
åyRdEn
 && !
SBCSFõldsReg
.
sbbusy
 && !
SBCSRdD©a
.
sbîr‹
 && !
sbAc˚ssEº‹
 && !
sbAlignmítEº‹


171 
sb2é
.
moduÀ
.
io
.
sizeIn
 :
SBCSFõldsReg
.
sbac˚ss


172 
sb2é
.
moduÀ
.
io
.
dma˘ive
 := dmactive

174 
vÆ
 
sbBusy
 = (
sb2é
.
moduÀ
.
io
.
sbSèãOut
 =/
Sy°emBusAc˚ssSèã
.
IdÀ
.
id
.
U
)

176 
whí
 (~
dma˘ive
) {

177 
SBCSFõldsReg
 :
SBCSFõldsRegRe£t


178 }.
Ÿhîwi£
 {

179 
SBCSFõldsReg
.
sbbusyîr‹
 :
Mux
(
SBCSWrEn
 && 
SBCSWrD©a
.sbbusyîr‹, 
Ál£
.
B
,

180 
Mux
(
™yAddªssWrEn
 && 
sbBusy
, 
åue
.
B
,

181 
Mux
((
™yD©aRdEn
 || 
™yD©aWrEn
Ë&& 
sbBusy
, 
åue
.
B
, 
SBCSFõldsReg
.
sbbusyîr‹
)))

182 
	gSBCSFõldsReg
.
	gsbªad⁄addr
 :
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sbªad⁄addr
 , 
SBCSFõldsReg
.sbreadonaddr)

183 
	gSBCSFõldsReg
.
	gsbautoö¸emít
 :
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sbautoö¸emít
, 
SBCSFõldsReg
.sbautoincrement)

184 
	gSBCSFõldsReg
.
	gsbªad⁄d©a
 :
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sbªad⁄d©a
 , 
SBCSFõldsReg
.sbreadondata)

185 
	gSBCSFõldsReg
.
	gsbac˚ss
 :
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sbac˚ss
, 
SBCSFõldsReg
.sbaccess)

186 
	gSBCSFõldsReg
.
	gsbvîsi⁄
 :1.U(1.
W
)

190 
vÆ
 
sbEº‹Reg
 = 
Reg
(
Vec
(4, 
UI¡
(1.
W
)))

191 
whí
(~
dma˘ive
) {

192 
	gi
 <- 0 
	gu¡û
 3)

193 
sbEº‹Reg
(
i
) := 0.U

194 }.
Ÿhîwi£
 {

195 
i
 <- 0 
u¡û
 3)

196 
sbEº‹Reg
(
i
Ë:
Mux
(
SBCSWrEn
 && 
SBCSWrD©a
.
sbîr‹
(iË==1.U, 
NoEº‹
.
id
.
U
(i),

197 
Mux
((
sb2é
.
moduÀ
.
io
.
wrEn
 && !sb2é.moduÀ.io.
wrLegÆ
Ë|| (sb2é.moduÀ.io.
rdEn
 && !sb2é.moduÀ.io.
rdLegÆ
), 
BadAddr
.
id
.
U
(
i
),

198 
Mux
((
åyWrEn
 || 
åyRdEn
Ë&& 
sbAlignmítEº‹
, 
AlgnEº‹
.
id
.
U
(
i
),

199 
Mux
((
åyWrEn
 || 
åyRdEn
Ë&& 
sbAc˚ssEº‹
, 
BadAc˚ss
.
id
.
U
(
i
),

200 
Mux
((
sb2é
.
moduÀ
.
io
.
rdD⁄e
 || sb2é.moduÀ.io.
wrD⁄e
Ë&& sb2é.moduÀ.io.
ª•Eº‹
, 
OthîEº‹
.
id
.
U
(
i
), 
sbEº‹Reg
(i))))))

203 
	gSBCSRdD©a
 :
SBCSFõldsReg


204 
SBCSRdD©a
.
sbasize
 :
sb2é
.
moduÀ
.
edge
.
bundÀ
.
addªssBôs
.
U


205 
SBCSRdD©a
.
sbac˚ss128
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 =128).
B


206 
SBCSRdD©a
.
sbac˚ss64
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >64).
B


207 
SBCSRdD©a
.
sbac˚ss32
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >32).
B


208 
SBCSRdD©a
.
sbac˚ss16
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >16).
B


209 
SBCSRdD©a
.
sbac˚ss8
 :(
cfg
.
maxSuµ‹ãdSBAc˚ss
 >8).
B


210 
SBCSRdD©a
.
sbbusy
 :
sbBusy


211 
SBCSRdD©a
.
sbîr‹
 :
sbEº‹Reg
.
asUI¡


213 
covî
(
SBCSFõldsReg
.
sbbusyîr‹
, "SBCS Cover", "sberror set")

214 
covî
(
SBCSFõldsReg
.
sbbusy
 === 3.U, "SBCS Cover", "sbbusyerrorálignmentÉrror")

216 
covî
((
sb2é
.
moduÀ
.
io
.
wrEn
 || sb2é.moduÀ.io.
rdEn
Ë&& 
SBCSFõldsReg
.
sbac˚ss
 ==0.U && !
sbAc˚ssEº‹
 && !
sbAlignmítEº‹
, "SBCS Cover", "8-bitáccess")

217 
covî
((
sb2é
.
moduÀ
.
io
.
wrEn
 || sb2é.moduÀ.io.
rdEn
Ë&& 
SBCSFõldsReg
.
sbac˚ss
 ==1.U && !
sbAc˚ssEº‹
 && !
sbAlignmítEº‹
, "SBCS Cover", "16-bitáccess")

218 
covî
((
sb2é
.
moduÀ
.
io
.
wrEn
 || sb2é.moduÀ.io.
rdEn
Ë&& 
SBCSFõldsReg
.
sbac˚ss
 ==2.U && !
sbAc˚ssEº‹
 && !
sbAlignmítEº‹
, "SBCS Cover", "32-bitáccess")

219 
covî
((
sb2é
.
moduÀ
.
io
.
wrEn
 || sb2é.moduÀ.io.
rdEn
Ë&& 
SBCSFõldsReg
.
sbac˚ss
 ==3.U && !
sbAc˚ssEº‹
 && !
sbAlignmítEº‹
, "SBCS Cover", "64-bitáccess")

220 
covî
((
sb2é
.
moduÀ
.
io
.
wrEn
 || sb2é.moduÀ.io.
rdEn
Ë&& 
SBCSFõldsReg
.
sbac˚ss
 ==4.U && !
sbAc˚ssEº‹
 && !
sbAlignmítEº‹
, "SBCS Cover", "128-bitáccess")

222 
covî
(
SBCSFõldsReg
.
sbautoö¸emít
 && SBCSFõldsReg.
sbbusy
, "SBCS Cover", "Access witháutoincrement set")

223 
covî
(!
SBCSFõldsReg
.
sbautoö¸emít
 && SBCSFõldsReg.
sbbusy
, "SBCS Cover", "Access withoutáutoincrement set")

225 (
	gsbcsfõlds
, 
	gsbaddrfõlds
, 
	gsbd©afõlds
)

229 ˛as†
	cSBToTL
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

231 
vÆ
 
cfg
 = 
	$p
(
DebugModuÀP¨ams
)

233 
vÆ
 
node
 = 
	`TLClõ¡Node
(
	`Seq
(
	`TLClõ¡P‹tP¨amëîs
(Seq(
	`TLClõ¡P¨amëîs
("debug")))))

235 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

236 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

237 
vÆ
 
rdEn
 = 
	`Boﬁ
(
INPUT
)

238 
vÆ
 
wrEn
 = 
	`Boﬁ
(
INPUT
)

239 
vÆ
 
addrIn
 = 
	`UI¡
(
INPUT
, 128)

240 
vÆ
 
d©aIn
 = 
	`UI¡
(
INPUT
, 128)

241 
vÆ
 
sizeIn
 = 
	`UI¡
(
INPUT
, 3)

242 
vÆ
 
dma˘ive
 = 
	`Boﬁ
(
INPUT
)

243 
vÆ
 
rdLegÆ
 = 
	`Boﬁ
(
OUTPUT
)

244 
vÆ
 
wrLegÆ
 = 
	`Boﬁ
(
OUTPUT
)

245 
vÆ
 
rdD⁄e
 = 
	`Boﬁ
(
OUTPUT
)

246 
vÆ
 
wrD⁄e
 = 
	`Boﬁ
(
OUTPUT
)

247 
vÆ
 
ª•Eº‹
 = 
	`Boﬁ
(
OUTPUT
)

248 
vÆ
 
d©aOut
 = 
	`UI¡
(
OUTPUT
, 8)

249 
vÆ
 
rdLﬂd
 = 
	`Vec
(
cfg
.
maxSuµ‹ãdSBAc˚ss
/8, 
	`Boﬁ
()).
asOuçut


250 
vÆ
 
sbSèãOut
 = 
	`UI¡
(
OUTPUT
, 
	`log2Ceû
(
Sy°emBusAc˚ssSèã
.
maxId
))

253 
imp‹t
 
Sy°emBusAc˚ssSèã
.
_


255 
	`vÆ
 (
é
, 
edge
Ë
node
.
	`out
(0)

257 
vÆ
 
sbSèã
 = 
	`Reg
(
öô
 = 0.U)

260 
vÆ
 
d
 = 
	`Queue
(
é
.d, 2)

261 
d
.
ªady
 :(
sbSèã
 ==
SBRódRe•⁄£
.
id
.
U
Ë|| (sbSèã ==
SBWrôeRe•⁄£
.id.U)

263 
vÆ
 
muxedD©a
 = 
	`Wúe
(
öô
 = 0.U(8.
W
))

264 
vÆ
 
ªque°VÆid
 = 
é
.
a
.
vÆid


265 
vÆ
 
ªque°Ródy
 = 
é
.
a
.
ªady


266 
vÆ
 
ª•⁄£VÆid
 = 
d
.
vÆid


267 
vÆ
 
ª•⁄£Ródy
 = 
d
.
ªady


269 
vÆ
 
cou¡î
 = 
	`Reg
(
öô
 = 0.U((
	`log2Ceû
(
cfg
.
maxSuµ‹ãdSBAc˚ss
/8)+1).
W
))

270 
vÆ
 
vecD©a
 = 
	`Wúe
(
	`Vec
(
cfg
.
maxSuµ‹ãdSBAc˚ss
/8, 
	`UI¡
(8.
W
)))

271 
vecD©a
 :
Vec
.
	`èbuœã
(16Ë{ 
i
 => 
io
.
	`d©aIn
(8*i+7,8*i) }

272 
muxedD©a
 :
	`vecD©a
(
cou¡î
)

274 
	`vÆ
 (
rdLegÆ
, 
gbôs
Ë
edge
.
	`Gë
(0.U, 
io
.
addrIn
, io.
sizeIn
)

275 
	`vÆ
 (
wrLegÆ
, 
pfbôs
Ë
edge
.
	`Put
(0.U, 
io
.
addrIn
, io.
sizeIn
, 
muxedD©a
)

277 
io
.
rdLegÆ
 :=ÑdLegal

278 
io
.
wrLegÆ
 := wrLegal

280 
io
.
sbSèãOut
 :
sbSèã


281 
	`whí
(
sbSèã
 ==
SBRódReque°
.
id
.
U
Ë{ 
é
.
a
.
bôs
 :
gbôs
 }

282 .
Ÿhîwi£
 { 
é
.
a
.
bôs
 :
pfbôs
 }

284 
vÆ
 
ª•Eº‹
 = 
d
.
bôs
.
díõd
 || d.bôs.
c‹ru±


285 
io
.
ª•Eº‹
 :=ÑespError

287 
vÆ
 
wrTxVÆid
 = 
sbSèã
 ==
SBWrôeReque°
.
id
.
U
 && 
ªque°VÆid
 && 
ªque°Ródy


288 
vÆ
 
rdTxVÆid
 = 
sbSèã
 ==
SBRódRe•⁄£
.
id
.
U
 && 
ª•⁄£VÆid
 && 
ª•⁄£Ródy


289 
vÆ
 
txLa°
 = 
cou¡î
 ==((1.U << 
io
.
sizeIn
) - 1.U)

290 
cou¡î
 :
	`Mux
((
wrTxVÆid
 || 
rdTxVÆid
Ë&& 
txLa°
, 0.U,

291 
	`Mux
((
wrTxVÆid
 || 
rdTxVÆid
Ë, 
cou¡î
+1.U, counter))

293 
i
 <- 0 
	`u¡û
 (
cfg
.
maxSuµ‹ãdSBAc˚ss
/8)) {

294 
io
.
	`rdLﬂd
(
i
Ë:
rdTxVÆid
 && (
cou¡î
 ==i.
U
)

298 
	`whí
(~
io
.
dma˘ive
){

299 
sbSèã
 :
IdÀ
.
id
.
U


300 }.
	`ñ£whí
 (
sbSèã
 ==
IdÀ
.
id
.
U
){

301 
sbSèã
 :
	`Mux
(
io
.
rdEn
 && 
rdLegÆ
, 
SBRódReque°
.
id
.
U
,

302 
	`Mux
(
io
.
wrEn
 && 
wrLegÆ
, 
SBWrôeReque°
.
id
.
U
, 
sbSèã
))

303 }.
	`ñ£whí
 (
sbSèã
 ==
SBRódReque°
.
id
.
U
){

304 
sbSèã
 :
	`Mux
(
ªque°VÆid
 && 
ªque°Ródy
, 
SBRódRe•⁄£
.
id
.
U
, sbState)

305 }.
	`ñ£whí
 (
sbSèã
 ==
SBWrôeReque°
.
id
.
U
){

306 
sbSèã
 :
	`Mux
(
wrTxVÆid
 && 
txLa°
, 
SBWrôeRe•⁄£
.
id
.
U
, sbState)

307 }.
	`ñ£whí
 (
sbSèã
 ==
SBRódRe•⁄£
.
id
.
U
){

308 
sbSèã
 :
	`Mux
(
rdTxVÆid
 && 
txLa°
, 
IdÀ
.
id
.
U
, sbState)

309 }.
	`ñ£whí
 (
sbSèã
 ==
SBWrôeRe•⁄£
.
id
.
U
){

310 
sbSèã
 :
	`Mux
(
ª•⁄£VÆid
 && 
ª•⁄£Ródy
, 
IdÀ
.
id
.
U
, sbState)

313 
io
.
rdD⁄e
 :
rdTxVÆid
 && 
txLa°


314 
io
.
wrD⁄e
 :(
sbSèã
 ==
SBWrôeRe•⁄£
.
id
.
U
Ë&& 
ª•⁄£VÆid
 && 
ª•⁄£Ródy


315 
io
.
d©aOut
 :
d
.
bôs
.
d©a


317 
é
.
a
.
vÆid
 :(
sbSèã
 ==
SBRódReque°
.
id
.
U
Ë|| (sbSèã ==
SBWrôeReque°
.id.U)

320 
é
.
b
.
ªady
 :
Ál£
.
B


321 
é
.
c
.
vÆid
 :
Ál£
.
B


322 
é
.
e
.
vÆid
 :
Ál£
.
B


324 
	`as£π
 (!
é
.
d
.
vÆid
 ||Ål.d.
ªady
, "Debug moduleÇotÑeadyÅoáccept TLÑesponse")

325 
	`as£π
 (
sbSèã
 ==
IdÀ
.
id
.
U
 ||

326 
sbSèã
 ==
SBRódReque°
.
id
.
U
 ||

327 
sbSèã
 ==
SBWrôeReque°
.
id
.
U
 ||

328 
sbSèã
 ==
SBRódRe•⁄£
.
id
.
U
 ||

329 
sbSèã
 ==
SBWrôeRe•⁄£
.
id
.
U
, "SBA state machine in undefined state")

331 
	`covî
 (
sbSèã
 ==
IdÀ
.
id
.
U
, "SBA State Cover", "SBA Access Idle")

332 
	`covî
 (
sbSèã
 ==
SBRódReque°
.
id
.
U
, "SBA State Cover", "SBA Access Read Req")

333 
	`covî
 (
sbSèã
 ==
SBWrôeReque°
.
id
.
U
, "SBA State Cover", "SBA Access Write Req")

334 
	`covî
 (
sbSèã
 ==
SBRódRe•⁄£
.
id
.
U
, "SBA State Cover", "SBA Access Read Resp")

335 
	`covî
 (
sbSèã
 ==
SBWrôeRe•⁄£
.
id
.
U
, "SBA State Cover", "SBA Access Write Resp")

337 
	`covî
 (
io
.
rdEn
 && !io.
rdLegÆ
, "SB Legality Cover", "SBA Rd Address Illegal")

338 
	`covî
 (
io
.
wrEn
 && !io.
wrLegÆ
, "SB Legality Cover", "SBA Wr Address Illegal")

341 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/abstract_commands.scala

1 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


3 
imp‹t
 
	gChi£l
.
_


8 
obje˘
 
	gAC_RegAddrs
 {

11 ˛as†
	cACCESS_REGISTERFõlds
 
exãnds
 
	mBundÀ
 {

15 
vÆ
 
	mcmdty≥
 = 
	$UI¡
(8.
W
)

17 
vÆ
 
ª£rved0
 = 
	$UI¡
(1.
W
)

32 
vÆ
 
size
 = 
	$UI¡
(3.
W
)

34 
vÆ
 
ª£rved1
 = 
	$UI¡
(1.
W
)

39 
vÆ
 
po°exec
 = 
	$Boﬁ
()

48 
vÆ
 
å™s„r
 = 
	$Boﬁ
()

57 
vÆ
 
wrôe
 = 
	$Boﬁ
()

64 
vÆ
 
ªgno
 = 
	`UI¡
(16.
W
)

68 ˛as†
	cQUICK_ACCESSFõlds
 
exãnds
 
BundÀ
 {

72 
vÆ
 
cmdty≥
 = 
	$UI¡
(8.
W
)

74 
vÆ
 
ª£rved0
 = 
	`UI¡
(24.
W
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/dm_registers.scala

1 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
debug


3 
imp‹t
 
	gChi£l
.
_


8 
obje˘
 
	gDMI_RegAddrs
 {

30 
def
 
	gDMI_DMSTATUS
 = 0x11

45 
def
 
DMI_DMCONTROL
 = 0x10

58 
def
 
DMI_HARTINFO
 = 0x12

63 
def
 
DMI_HAWINDOWSEL
 = 0x14

75 
def
 
DMI_HAWINDOW
 = 0x15

77 
def
 
DMI_ABSTRACTCS
 = 0x16

95 
def
 
DMI_COMMAND
 = 0x17

100 
def
 
DMI_ABSTRACTAUTO
 = 0x18

118 
def
 
DMI_DEVTREEADDR0
 = 0x19

120 
def
 
DMI_DEVTREEADDR1
 = 0x1a

122 
def
 
DMI_DEVTREEADDR2
 = 0x1b

124 
def
 
DMI_DEVTREEADDR3
 = 0x1c

130 
def
 
DMI_NEXTDM
 = 0x1d

148 
def
 
DMI_DATA0
 = 0x04

150 
def
 
DMI_DATA11
 = 0x0f

161 
def
 
DMI_PROGBUF0
 = 0x20

163 
def
 
DMI_PROGBUF15
 = 0x2f

172 
def
 
DMI_AUTHDATA
 = 0x30

181 
def
 
DMI_HALTSUM0
 = 0x40

195 
def
 
DMI_HALTSUM1
 = 0x13

209 
def
 
DMI_HALTSUM2
 = 0x34

221 
def
 
DMI_HALTSUM3
 = 0x35

228 
def
 
DMI_SBADDRESS3
 = 0x37

230 
def
 
DMI_SBCS
 = 0x38

246 
def
 
DMI_SBADDRESS0
 = 0x39

253 
def
 
DMI_SBADDRESS1
 = 0x3a

260 
def
 
DMI_SBADDRESS2
 = 0x3b

295 
def
 
DMI_SBDATA0
 = 0x3c

303 
def
 
DMI_SBDATA1
 = 0x3d

310 
def
 
DMI_SBDATA2
 = 0x3e

317 
def
 
DMI_SBDATA3
 = 0x3f

321 ˛as†
	cDMSTATUSFõlds
 
exãnds
 
	mBundÀ
 {

323 
vÆ
 
	mª£rved0
 = 
	$UI¡
(9.
W
)

332 
vÆ
 
im≥bªak
 = 
	$Boﬁ
()

334 
vÆ
 
ª£rved1
 = 
	$UI¡
(2.
W
)

338 
vÆ
 
Ælhavîe£t
 = 
	$Boﬁ
()

342 
vÆ
 
™yhavîe£t
 = 
	$Boﬁ
()

347 
vÆ
 
ÆÃesumóck
 = 
	$Boﬁ
()

352 
vÆ
 
™yªsumóck
 = 
	$Boﬁ
()

356 
vÆ
 
Æ ⁄exi°ít
 = 
	$Boﬁ
()

360 
vÆ
 
™yn⁄exi°ít
 = 
	$Boﬁ
()

364 
vÆ
 
Ælu«vaû
 = 
	$Boﬁ
()

368 
vÆ
 
™yu«vaû
 = 
	$Boﬁ
()

372 
vÆ
 
ÆÃu¬ög
 = 
	$Boﬁ
()

376 
vÆ
 
™yru¬ög
 = 
	$Boﬁ
()

380 
vÆ
 
ÆlhÆãd
 = 
	$Boﬁ
()

384 
vÆ
 
™yhÆãd
 = 
	$Boﬁ
()

390 
vÆ
 
authítiˇãd
 = 
	$Boﬁ
()

401 
vÆ
 
authbusy
 = 
	$Boﬁ
()

403 
vÆ
 
ª£rved2
 = 
	$UI¡
(1.
W
)

411 
vÆ
 
devåìvÆid
 = 
	$Boﬁ
()

424 
vÆ
 
vîsi⁄
 = 
	`UI¡
(4.
W
)

428 ˛as†
	cDMCONTROLFõlds
 
exãnds
 
BundÀ
 {

439 
vÆ
 
hÆåeq
 = 
	$Boﬁ
()

450 
vÆ
 
ªsumîeq
 = 
	$Boﬁ
()

462 
vÆ
 
h¨åe£t
 = 
	$Boﬁ
()

469 
vÆ
 
ackhavîe£t
 = 
	$Boﬁ
()

471 
vÆ
 
ª£rved0
 = 
	$UI¡
(1.
W
)

485 
vÆ
 
ha£l
 = 
	$Boﬁ
()

490 
vÆ
 
h¨t£Œo
 = 
	$UI¡
(10.
W
)

495 
vÆ
 
h¨t£lhi
 = 
	$UI¡
(10.
W
)

497 
vÆ
 
ª£rved1
 = 
	$UI¡
(4.
W
)

507 
vÆ
 
ndmª£t
 = 
	$Boﬁ
()

528 
vÆ
 
dma˘ive
 = 
	`Boﬁ
()

532 ˛as†
	cHARTINFOFõlds
 
exãnds
 
BundÀ
 {

534 
vÆ
 
ª£rved0
 = 
	$UI¡
(8.
W
)

541 
vÆ
 
ns¸©ch
 = 
	$UI¡
(4.
W
)

543 
vÆ
 
ª£rved1
 = 
	$UI¡
(3.
W
)

552 
vÆ
 
d©Øc˚ss
 = 
	$Boﬁ
()

563 
vÆ
 
d©asize
 = 
	$UI¡
(4.
W
)

571 
vÆ
 
d©Øddr
 = 
	`UI¡
(12.
W
)

575 ˛as†
	cHAWINDOWSELFõlds
 
exãnds
 
BundÀ
 {

577 
vÆ
 
ª£rved0
 = 
	$UI¡
(17.
W
)

583 
vÆ
 
hawödow£l
 = 
	`UI¡
(15.
W
)

587 ˛as†
	cHAWINDOWFõlds
 
exãnds
 
BundÀ
 {

589 
vÆ
 
maskd©a
 = 
	`UI¡
(32.
W
)

593 ˛as†
	cABSTRACTCSFõlds
 
exãnds
 
BundÀ
 {

595 
vÆ
 
ª£rved0
 = 
	$UI¡
(3.
W
)

599 
vÆ
 
¥ogbufsize
 = 
	$UI¡
(5.
W
)

601 
vÆ
 
ª£rved1
 = 
	$UI¡
(11.
W
)

608 
vÆ
 
busy
 = 
	$Boﬁ
()

610 
vÆ
 
ª£rved2
 = 
	$UI¡
(1.
W
)

633 
vÆ
 
cmdîr
 = 
	$UI¡
(3.
W
)

635 
vÆ
 
ª£rved3
 = 
	$UI¡
(4.
W
)

640 
vÆ
 
d©acou¡
 = 
	`UI¡
(4.
W
)

644 ˛as†
	cCOMMANDFõlds
 
exãnds
 
BundÀ
 {

649 
vÆ
 
cmdty≥
 = 
	$UI¡
(8.
W
)

654 
vÆ
 
c⁄åﬁ
 = 
	`UI¡
(24.
W
)

658 ˛as†
	cABSTRACTAUTOFõlds
 
exãnds
 
BundÀ
 {

663 
vÆ
 
aut€xe˝rogbuf
 = 
	$UI¡
(16.
W
)

665 
vÆ
 
ª£rved0
 = 
	$UI¡
(4.
W
)

670 
vÆ
 
aut€xecd©a
 = 
	`UI¡
(12.
W
)

674 ˛as†
	cDEVTREEADDR0Fõlds
 
exãnds
 
BundÀ
 {

676 
vÆ
 
addr
 = 
	`UI¡
(32.
W
)

680 ˛as†
	cNEXTDMFõlds
 
exãnds
 
BundÀ
 {

682 
vÆ
 
addr
 = 
	`UI¡
(32.
W
)

686 ˛as†
	cDATA0Fõlds
 
exãnds
 
BundÀ
 {

688 
vÆ
 
d©a
 = 
	`UI¡
(32.
W
)

692 ˛as†
	cPROGBUF0Fõlds
 
exãnds
 
BundÀ
 {

694 
vÆ
 
d©a
 = 
	`UI¡
(32.
W
)

698 ˛as†
	cAUTHDATAFõlds
 
exãnds
 
BundÀ
 {

700 
vÆ
 
d©a
 = 
	`UI¡
(32.
W
)

704 ˛as†
	cHALTSUM0Fõlds
 
exãnds
 
BundÀ
 {

706 
vÆ
 
hÆtsum0
 = 
	`UI¡
(32.
W
)

710 ˛as†
	cHALTSUM1Fõlds
 
exãnds
 
BundÀ
 {

712 
vÆ
 
hÆtsum1
 = 
	`UI¡
(32.
W
)

716 ˛as†
	cHALTSUM2Fõlds
 
exãnds
 
BundÀ
 {

718 
vÆ
 
hÆtsum2
 = 
	`UI¡
(32.
W
)

722 ˛as†
	cHALTSUM3Fõlds
 
exãnds
 
BundÀ
 {

724 
vÆ
 
hÆtsum3
 = 
	`UI¡
(32.
W
)

728 ˛as†
	cSBADDRESS3Fõlds
 
exãnds
 
BundÀ
 {

733 
vÆ
 
addªss
 = 
	`UI¡
(32.
W
)

737 ˛as†
	cSBCSFõlds
 
exãnds
 
BundÀ
 {

746 
vÆ
 
sbvîsi⁄
 = 
	$UI¡
(3.
W
)

748 
vÆ
 
ª£rved0
 = 
	$UI¡
(6.
W
)

758 
vÆ
 
sbbusyîr‹
 = 
	$Boﬁ
()

768 
vÆ
 
sbbusy
 = 
	$Boﬁ
()

773 
vÆ
 
sbªad⁄addr
 = 
	$Boﬁ
()

790 
vÆ
 
sbac˚ss
 = 
	$UI¡
(3.
W
)

795 
vÆ
 
sbautoö¸emít
 = 
	$Boﬁ
()

800 
vÆ
 
sbªad⁄d©a
 = 
	$Boﬁ
()

822 
vÆ
 
sbîr‹
 = 
	$UI¡
(3.
W
)

827 
vÆ
 
sbasize
 = 
	$UI¡
(7.
W
)

831 
vÆ
 
sbac˚ss128
 = 
	$Boﬁ
()

835 
vÆ
 
sbac˚ss64
 = 
	$Boﬁ
()

839 
vÆ
 
sbac˚ss32
 = 
	$Boﬁ
()

843 
vÆ
 
sbac˚ss16
 = 
	$Boﬁ
()

847 
vÆ
 
sbac˚ss8
 = 
	`Boﬁ
()

851 ˛as†
	cSBADDRESS0Fõlds
 
exãnds
 
BundÀ
 {

855 
vÆ
 
addªss
 = 
	`UI¡
(32.
W
)

859 ˛as†
	cSBADDRESS1Fõlds
 
exãnds
 
BundÀ
 {

864 
vÆ
 
addªss
 = 
	`UI¡
(32.
W
)

868 ˛as†
	cSBADDRESS2Fõlds
 
exãnds
 
BundÀ
 {

873 
vÆ
 
addªss
 = 
	`UI¡
(32.
W
)

877 ˛as†
	cSBDATA0Fõlds
 
exãnds
 
BundÀ
 {

881 
vÆ
 
d©a
 = 
	`UI¡
(32.
W
)

885 ˛as†
	cSBDATA1Fõlds
 
exãnds
 
BundÀ
 {

890 
vÆ
 
d©a
 = 
	`UI¡
(32.
W
)

894 ˛as†
	cSBDATA2Fõlds
 
exãnds
 
BundÀ
 {

899 
vÆ
 
d©a
 = 
	`UI¡
(32.
W
)

903 ˛as†
	cSBDATA3Fõlds
 
exãnds
 
BundÀ
 {

908 
vÆ
 
d©a
 = 
	`UI¡
(32.
W
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BootROM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.{
	gBa£Subsy°em
, 
	gHasRe£tVe˘‹Wúe
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
imp‹t
 
	gjava
.
	gnio
.{
	gByãBuf„r
, 
	gByãOrdî
}

13 
imp‹t
 
	gjava
.
	gnio
.
	gfûe
.{
	gFûes
, 
	gP©hs
}

16 
˛ass
 
	$BoŸROMP¨ams
(

17 
addªss
: 
BigI¡
 = 0x10000,

18 
size
: 
I¡
 = 0x10000,

19 
h™g
: 
BigI¡
 = 0x10040,

20 
c⁄ã¡FûeName
: 
Såög
)

21 
obje˘
 
BoŸROMP¨ams
 
exãnds
 
Fõld
[BootROMParams]

23 
˛ass
 
	`TLROM
(
vÆ
 
ba£
: 
BigI¡
, vÆ 
size
: 
I¡
, 
c⁄ã¡sDñayed
: => 
Seq
[
Byã
], 
execuèbÀ
: 
Boﬁón
 = 
åue
, 
bótByãs
: Int = 4,

24 
ªsour˚s
: 
Seq
[
Resour˚
] = 
√w
 
	`Sim∂eDevi˚
("rom", 
	`Seq
("sifive,rom0")).
	`ªg
("mem"))(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


26 
vÆ
 
node
 = 
	`TLM™agîNode
(
	`Seq
(
	`TLM™agîP‹tP¨amëîs
(

27 
	`Seq
(
	`TLM™agîP¨amëîs
(

28 
addªss
 = 
	`Li°
(
	`AddªssSë
(
ba£
, 
size
-1)),

29 
ªsour˚s
 =Ñesources,

30 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

31 
execuèbÀ
 =Éxecutable,

32 
suµ‹tsGë
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

33 
fifoId
 = 
	`Some
(0))),

34 
bótByãs
 = beatBytes)))

36 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

37 
vÆ
 
c⁄ã¡s
 = 
c⁄ã¡sDñayed


38 
vÆ
 
wøpSize
 = 1 << 
	`log2Ceû
(
c⁄ã¡s
.
size
)

39 
	`ªquúe
 (
wøpSize
 <
size
)

41 
	`vÆ
 (
ö
, 
edge
Ë
node
.
	`ö
(0)

43 
vÆ
 
w‹ds
 = (
c⁄ã¡s
 ++ 
Seq
.
	`fûl
(
wøpSize
-c⁄ã¡s.
size
)(0.
toByã
)).
	`grou≥d
(
bótByãs
).
toSeq


44 
vÆ
 
bigs
 = 
w‹ds
.
	`m≠
(
_
.
	`fﬁdRight
(
	`BigI¡
(0)){ (
x
,
y
Ë=> (x.
toI¡
 & 0xff) | y << 8})

45 
vÆ
 
rom
 = 
	`Vec
(
bigs
.
	`m≠
(
x
 => 
	`UI¡
(x, 
width
 = 8*
bótByãs
)))

47 
ö
.
d
.
vÆid
 :ö.
a
.valid

48 
ö
.
a
.
ªady
 :ö.
d
.ready

50 
vÆ
 
ödex
 = 
ö
.
a
.
bôs
.
	`addªss
(
	`log2Ceû
(
wøpSize
)-1,log2Ceû(
bótByãs
))

51 
vÆ
 
high
 = i‡(
wøpSize
 =
size
Ë
	`UI¡
(0Ë
ö
.
a
.
bôs
.
	`addªss
(
	`log2Ceû
(size)-1,Üog2Ceil(wrapSize))

52 
ö
.
d
.
bôs
 :
edge
.
	`Ac˚ssAck
(ö.
a
.bôs, 
	`Mux
(
high
.
‹R
, 
	`UI¡
(0), 
	`rom
(
ödex
)))

55 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

56 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

57 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

59 
	}
}

62 
åaô
 
HasPîùhîyBoŸROM
 { 
this
: 
Ba£Subsy°em
 =>

63 
vÆ
 
dtb
: 
DTB


64 
¥iv©e
 
vÆ
 
∑øms
 = 
p
(
BoŸROMP¨ams
)

65 
¥iv©e
 
œzy
 
vÆ
 
c⁄ã¡s
 = {

66 
vÆ
 
romd©a
 = 
Fûes
.
ªadAŒByãs
(
P©hs
.
gë
(
∑øms
.
c⁄ã¡FûeName
))

67 
vÆ
 
rom
 = 
ByãBuf„r
.
wøp
(
romd©a
)

68 
rom
.
¨øy
(Ë++ 
dtb
.
c⁄ã¡s


70 
def
 
ª£tVe˘‹
: 
BigI¡
 = 
∑øms
.
h™g


72 
vÆ
 
boŸrom
 = 
LazyModuÀ
(
√w
 
TLROM
(
∑øms
.
addªss
,Ö¨ams.
size
, 
c⁄ã¡s
, 
åue
, 
sbus
.
c⁄åﬁ_bus
.
bótByãs
))

74 
	gsbus
.
	gc⁄åﬁ_bus
.
toV¨übÀWidthSœve
(
Some
("boŸrom")){ 
	gboŸrom
.
	gnode
 }

78 
åaô
 
HasPîùhîyBoŸROMModuÀImp
 
exãnds
 
LazyModuÀImp


79 
wôh
 
	gHasRe£tVe˘‹Wúe
 {

80 
vÆ
 
	gouãr
: 
HasPîùhîyBoŸROM


81 
globÆ_ª£t_ve˘‹
 :
ouãr
.
ª£tVe˘‹
.
U


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBlocker.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


18 
˛ass
 
	$BasicBusBlockîP¨ams
(

19 
c⁄åﬁAddªss
: 
BigI¡
,

20 
c⁄åﬁBótByãs
: 
I¡
,

21 
devi˚BótByãs
: 
I¡
,

22 
dódlock
: 
Boﬁón
 = 
Ál£
)

24 
˛ass
 
	$BasicBusBlockî
(
∑øms
: 
BasicBusBlockîP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
)

25 
exãnds
 
	$TLBusBy∑ssBa£
(
∑øms
.
devi˚BótByãs
,Ö¨ams.
dódlock
)

27 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("basic-bus-blockî", 
	`Seq
("sifive,basic-bus-blocker0"))

29 
vÆ
 
c⁄åﬁNode
 = 
	`TLRegi°îNode
(

30 
addªss
 = 
	`Seq
(
	`AddªssSë
(
∑øms
.
c⁄åﬁAddªss
, 0xFFF)),

31 
devi˚
 = device,

32 
bótByãs
 = 
∑øms
.
c⁄åﬁBótByãs
)

34 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

35 
vÆ
 
Ælow
 = 
	`RegInô
(
åue
.
B
)

36 
vÆ
 
≥ndög
 = 
	`RegNext
(
b¨
.
moduÀ
.
io
.pending)

38 
c⁄åﬁNode
.
	`ªgm≠
(

39 0 -> 
	`Seq
(
	`RegFõld
 (32, 
Ælow
)),

40 4 -> 
	`Seq
(
RegFõld
.
	`r
(32, 
≥ndög
)))

42 
b¨
.
moduÀ
.
io
.
by∑ss
 :!
Ælow


44 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBypass.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
imp‹t
 
	gsˇœ
.
	gm©h
.
mö


12 
ab°ø˘
 
˛ass
 
	$TLBusBy∑ssBa£
(
bótByãs
: 
I¡
, 
dódlock
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
¥Ÿe˘ed
 
vÆ
 
nodeIn
 = 
	`TLIdítôyNode
()

15 
¥Ÿe˘ed
 
vÆ
 
nodeOut
 = 
	`TLIdítôyNode
()

16 
vÆ
 
node
 = 
	`NodeH™dÀ
(
nodeIn
, 
nodeOut
)

18 
¥Ÿe˘ed
 
vÆ
 
b¨
 = 
	`LazyModuÀ
(
√w
 
	`TLBusBy∑ssB¨
(
dFn
 = { 
mp
 =>

19 
mp
.
	`c›y
(
m™agîs
 = mp.m™agîs.
m≠
 { 
m
 =>

20 
m
.
	`c›y
(

21 
mayDíyPut
 = 
m
.mayDíyPuà|| !
dódlock
,

22 
mayDíyGë
 = 
m
.mayDíyGë || !
dódlock
)

25 
¥Ÿe˘ed
 
vÆ
 
evîythög
 = 
	`Seq
(
	`AddªssSë
(0, 
	`BigI¡
("ffffffffffffffffffffffffffffffff", 16)))

26 
¥Ÿe˘ed
 
vÆ
 
∑øms
 = 
	`DevNuŒP¨ams
(
evîythög
, 
maxAtomic
=16, 
maxTøns„r
=4096, 
ªgi⁄
=
Regi⁄Ty≥
.
TRACKED
)

27 
¥Ÿe˘ed
 
vÆ
 
îr‹
 = i‡(
dódlock
Ë
	`LazyModuÀ
(
√w
 
	`TLDódlock
(
∑øms
, 
bótByãs
))

28 
	`LazyModuÀ
(
√w
 
	`TLEº‹
(
∑øms
, 
bótByãs
))

31 
b¨
.
node
 :
nodeIn


32 
îr‹
.
node
 :
b¨
.node

33 
nodeOut
 :
b¨
.
node


34 
	}
}

36 ˛as†
	cTLBusBy∑ss
(
bótByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$TLBusBy∑ssBa£
(
bótByãs
)

38 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

39 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

40 
vÆ
 
by∑ss
 = 
	`Boﬁ
(
INPUT
)

42 
b¨
.
moduÀ
.
io
.
by∑ss
 := io.bypass

44 
	}
}

46 
˛ass
 
TLBy∑ssNode
(
dFn
: 
TLM™agîP‹tP¨amëîs
 => TLM™agîP‹tP¨amëîs)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
TLCu°omNode


48 
def
 
ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

49 
ªquúe
 (
iSèrs
 =0 && 
oSèrs
 == 0, "TLBypassÇode doesÇot support :=* or :*=")

50 
ªquúe
 (
iKnown
 == 1, "TLBypassÇodeÉxpectsÉxactly one input")

51 
ªquúe
 (
oKnown
 == 2, "TLBypassÇodeÉxpectsÉxactlyÅwo outputs")

54 
def
 
m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
TLClõ¡P‹tP¨amëîs
]): Seq[TLClientPortParameters] = {Ö ++Ö }

55 
def
 
m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
TLM™agîP‹tP¨amëîs
]): Seq[TLM™agîP‹tP¨amëîs] = { Seq(
dFn
’.
œ°
)) }

58 
˛ass
 
TLBusBy∑ssB¨
(
dFn
: 
TLM™agîP‹tP¨amëîs
 => TLM™agîP‹tP¨amëîs)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


60 
vÆ
 
node
 = 
√w
 
TLBy∑ssNode
(
dFn
)

62 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

63 
vÆ
 
io
 = 
IO
(
√w
 
BundÀ
 {

64 
vÆ
 
by∑ss
 = 
Boﬁ
(
INPUT
)

65 
vÆ
 
≥ndög
 = 
Boﬁ
(
OUTPUT
)

68 
vÆ
 (
ö
, 
edgeIn
Ë
node
.in(0)

69 
vÆ
 
Seq
((
out0
, 
edgeOut0
), (
out1
, 
edgeOut1
)Ë
node
.
out


71 
ªquúe
 (
edgeOut0
.
m™agî
.
bótByãs
 =
edgeOut1
.manager.beatBytes,

72 
s
"BusBypass slave device widths mismatch (${edgeOut0.manager.managers.map(_.name)} has ${edgeOut0.manager.beatBytes}B vs ${edgeOut1.manager.managers.map(_.name)} has ${edgeOut1.manager.beatBytes}B)")

75 
vÆ
 
	gby∑ss
 = 
RegInô
(
io
.
by∑ss
)

76 
vÆ
 (
Êight
, 
√xt_Êight
Ë
edgeIn
.
öFlight
(
ö
)

78 
io
.
≥ndög
 :(
Êight
 > 0.U)

79 
whí
 (
√xt_Êight
 ==
UI¡
(0)Ë{ 
by∑ss
 :
io
.bypass }

80 
vÆ
 
°Æl
 = (
by∑ss
 =/
io
.by∑ssË&& 
edgeIn
.
fú°
(
ö
.
a
)

82 
out0
.
a
.
vÆid
 :!
°Æl
 && 
ö
.a.vÆid && 
by∑ss


83 
out1
.
a
.
vÆid
 :!
°Æl
 && 
ö
.a.vÆid && !
by∑ss


84 
ö
.
a
.
ªady
 :!
°Æl
 && 
Mux
(
by∑ss
, 
out0
.a.ªady, 
out1
.a.ready)

85 
	gout0
.
	ga
.
	gbôs
 :
ö
.
a
.
bôs


86 
out1
.
a
.
bôs
 :
ö
.a.bits

88 
out0
.
d
.
ªady
 :
ö
.d.ªady && 
by∑ss


89 
out1
.
d
.
ªady
 :
ö
.d.ªady && !
by∑ss


90 
ö
.
d
.
vÆid
 :
Mux
(
by∑ss
, 
out0
.d.vÆid, 
out1
.d.valid)

91 
def
 
ˇ°
(
x
: 
TLBundÀD
Ë{ 
vÆ
 
out
 = 
Wúe
(
ö
.
d
.
bôs
); 
	gout
 <> 
	gx
; out }

92 
	gö
.
	gd
.
	gbôs
 :
Mux
(
by∑ss
, 
ˇ°
(
out0
.
d
.
bôs
), ca°(
out1
.d.bits))

94 i‡(
	gedgeIn
.
	gm™agî
.
	g™ySuµ‹tAcquúeB
 &&ÉdgeIn.
	g˛õ¡
.
	g™ySuµ‹tProbe
) {

95 
	gout0
.
	gb
.
	gªady
 :
ö
.
b
.
ªady
 && 
by∑ss


96 
out1
.
b
.
ªady
 :
ö
.b.ªady && !
by∑ss


97 
ö
.
b
.
vÆid
 :
Mux
(
by∑ss
, 
out0
.b.vÆid, 
out1
.b.valid)

98 
def
 
ˇ°
(
x
: 
TLBundÀB
Ë{ 
vÆ
 
out
 = 
Wúe
(
ö
.
b
.
bôs
); 
	gout
 <> 
	gx
; out }

99 
	gö
.
	gb
.
	gbôs
 :
Mux
(
by∑ss
, 
ˇ°
(
out0
.
b
.
bôs
), ca°(
out1
.b.bits))

101 
	gout0
.
	gc
.
	gvÆid
 :
ö
.
c
.
vÆid
 && 
by∑ss


102 
out1
.
c
.
vÆid
 :
ö
.c.vÆid && !
by∑ss


103 
ö
.
c
.
ªady
 :
Mux
(
by∑ss
, 
out0
.c.ªady, 
out1
.c.ready)

104 
	gout0
.
	gc
.
	gbôs
 :
ö
.
c
.
bôs


105 
out1
.
c
.
bôs
 :
ö
.c.bits

107 
out0
.
e
.
vÆid
 :
ö
.e.vÆid && 
by∑ss


108 
out1
.
e
.
vÆid
 :
ö
.e.vÆid && !
by∑ss


109 
ö
.
e
.
ªady
 :
Mux
(
by∑ss
, 
out0
.e.ªady, 
out1
.e.ready)

110 
	gout0
.
	ge
.
	gbôs
 :
ö
.
e
.
bôs


111 
out1
.
e
.
bôs
 :
ö
.e.bits

113 
ö
.
b
.
vÆid
 :
Boﬁ
(
Ál£
)

114 
ö
.
c
.
ªady
 :
Boﬁ
(
åue
)

115 
ö
.
e
.
ªady
 :
Boﬁ
(
åue
)

117 
out0
.
b
.
ªady
 :
Boﬁ
(
åue
)

118 
out0
.
c
.
vÆid
 :
Boﬁ
(
Ál£
)

119 
out0
.
e
.
vÆid
 :
Boﬁ
(
Ál£
)

121 
out1
.
b
.
ªady
 :
Boﬁ
(
åue
)

122 
out1
.
c
.
vÆid
 :
Boﬁ
(
Ál£
)

123 
out1
.
e
.
vÆid
 :
Boﬁ
(
Ál£
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/CLINT.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
Ba£Subsy°em


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


13 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

15 
obje˘
 
	gCLINTC⁄°s


17 
def
 
msùOff£t
(
h¨t
: 
I¡
Ëh¨à* 
msùByãs


18 
def
 
timecmpOff£t
(
h¨t
: 
I¡
Ë0x4000 + h¨à* 
timecmpByãs


19 
def
 
timeOff£t
 = 0xbff8

20 
def
 
msùByãs
 = 4

21 
def
 
timecmpByãs
 = 8

22 
def
 
size
 = 0x10000

23 
def
 
timeWidth
 = 64

24 
def
 
ùiWidth
 = 32

25 
def
 
öts
 = 2

28 
˛ass
 
	$CLINTP¨ams
(
ba£Addªss
: 
BigI¡
 = 0x02000000, 
ötSèges
: 
I¡
 = 0)

30 
def
 
addªss
 = 
	`AddªssSë
(
ba£Addªss
, 
CLINTC⁄°s
.
size
-1)

31 
	}
}

33 
obje˘
 
CLINTKey
 
exãnds
 
	gFõld
[
O±i⁄
[
CLINTP¨ams
]](
	gN⁄e
)

35 
˛ass
 
	$CLINT
(
∑øms
: 
CLINTP¨ams
, 
bótByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


37 
imp‹t
 
CLINTC⁄°s
.
_


40 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("˛öt", 
	`Seq
("riscv,clint0")) {

41 
ovîride
 
vÆ
 
ÆwaysExãnded
 = 
åue


44 
vÆ
 
node
 = 
	`TLRegi°îNode
(

45 
addªss
 = 
	`Seq
(
∑øms
.address),

46 
devi˚
 = device,

47 
bótByãs
 = beatBytes)

49 
vÆ
 
öäode
 = 
	`I¡NexusNode
(

50 
sour˚Fn
 = { 
_
 => 
	`I¡Sour˚P‹tP¨amëîs
(
	`Seq
(
	`I¡Sour˚P¨amëîs
(
öts
, Seq(
	`Resour˚
(
devi˚
, "int"))))) },

51 
sökFn
 = { 
_
 => 
	`I¡SökP‹tP¨amëîs
(
	`Seq
(
	`I¡SökP¨amëîs
())) },

52 
ouçutRequúesI≈ut
 = 
Ál£
)

54 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

55 
A¬Ÿ©ed
.
	`∑øms
(
this
, 
∑øms
)

56 
	`ªquúe
 (
öäode
.
edges
.
ö
.
size
 == 0, "CLINT onlyÖroduces interrupts; it doesÇotácceptÅhem")

58 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

59 
vÆ
 
πcTick
 = 
	`Boﬁ
(
INPUT
)

62 
vÆ
 
time
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
timeWidth
))

63 
	`whí
 (
io
.
πcTick
Ë{ 
time
 :timê+ 
	`UI¡
(1) }

65 
vÆ
 
nTûes
 = 
öäode
.
out
.
size


66 
vÆ
 
timecmp
 = 
Seq
.
	`fûl
(
nTûes
Ë{ 
	`Reg
(
	`UI¡
(
width
 = 
timeWidth
)) }

67 
vÆ
 
ùi
 = 
Seq
.
	`fûl
(
nTûes
Ë{ 
	`RegInô
(
	`UI¡
(0, 
width
 = 1)) }

69 
	`vÆ
 (
öäode_out
, 
_
Ë
öäode
.
out
.
unzù


70 
öäode_out
.
zùWôhIndex
.
f‹óch
 { (, 
i
) =>

71 (0Ë:
	`Shi·Regi°î
(
	`ùi
(
i
)(0), 
∑øms
.
ötSèges
)

72 (1Ë:
	`Shi·Regi°î
(
time
.
asUI¡
 >
	`timecmp
(
i
).asUI¡, 
∑øms
.
ötSèges
)

85 
node
.
	`ªgm≠
(

86 0 -> 
	`RegFõldGroup
 ("msù", 
	`Some
("MSIP Bôs"), 
ùi
.
zùWôhIndex
.
Ê©M≠
{ (
r
, 
i
) =>

87 
	`RegFõld
(1, 
r
, 
	`RegFõldDesc
(
s
"msù_$i", s"MSIP bô f‹ H¨à$i", 
ª£t
=
	`Some
(0))Ë:: RegFõld(
ùiWidth
 - 1Ë:: 
Nû
 }),

88 
	`timecmpOff£t
(0Ë-> 
timecmp
.
zùWôhIndex
.
Ê©M≠
{ (
t
, 
i
Ë=> 
	`RegFõldGroup
(
s
"mtimecmp_$i", 
	`Some
(s"MTIMECMP for hart $i"),

89 
RegFõld
.
	`byãs
(
t
, 
	`Some
(
	`RegFõldDesc
(
s
"mtimecmp_$i", "", 
ª£t
=
N⁄e
))))},

90 
timeOff£t
 -> 
	`RegFõldGroup
("mtime", 
	`Some
("Timer Register"),

91 
RegFõld
.
	`byãs
(
time
, 
	`Some
(
	`RegFõldDesc
("mtime", "", 
ª£t
=Some(0), vﬁ©ûe=
åue
))))

94 
	}
}

97 
åaô
 
	gC™HavePîùhîyCLINT
 { 
	gthis
: 
Ba£Subsy°em
 =>

98 
vÆ
 
˛ötO±
 = 
p
(
CLINTKey
).
m≠
 { 
∑øms
 =>

99 
vÆ
 
˛öt
 = 
LazyModuÀ
(
√w
 
CLINT
(
∑øms
, 
sbus
.
c⁄åﬁ_bus
.
bótByãs
))

100 
	gsbus
.
	gc⁄åﬁ_bus
.
toV¨übÀWidthSœve
(
Some
("˛öt")Ë{ 
	g˛öt
.
	gnode
 }

101 
	g˛öt


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Deadlock.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


13 
˛ass
 
	$TLDódlock
(
∑øms
: 
DevNuŒP¨ams
, 
bótByãs
: 
I¡
 = 4)(
im∂icô
 
p
: 
P¨amëîs
)

14 
exãnds
 
	`DevNuŒDevi˚
(
∑øms
, 
bótByãs
, 
√w
 
	`Sim∂eDevi˚
("dódlock-devi˚", 
	`Seq
("sifive,deadlock0")))

16 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

17 
	`vÆ
 (
ö
, 
_
Ë
node
.
	`ö
(0)

18 
ö
.
a
.
ªady
 :
	`Boﬁ
(
Ál£
)

19 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

20 
ö
.
c
.
ªady
 :
	`Boﬁ
(
Ál£
)

21 
ö
.
d
.
vÆid
 :
	`Boﬁ
(
Ál£
)

22 
ö
.
e
.
ªady
 :
	`Boﬁ
(
Ál£
)

24 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/DevNull.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
˛ass
 
	$DevNuŒP¨ams
(

10 
addªss
: 
Seq
[
AddªssSë
],

11 
maxAtomic
: 
I¡
,

12 
maxTøns„r
: 
I¡
,

13 
ªgi⁄
: 
Regi⁄Ty≥
.
T
 = Regi⁄Ty≥.
UNCACHEABLE
,

14 
execuèbÀ
: 
Boﬁón
 = 
åue
,

15 
mayDíyGë
: 
Boﬁón
 = 
åue
,

16 
mayDíyPut
: 
Boﬁón
 = 
åue
,

18 
	`ªquúe
 (1 <
maxAtomic
, 
s
"AtomicÅransfer size must be > 1 (was $maxAtomic)")

19 
	`ªquúe
 (
maxAtomic
 <
maxTøns„r
, 
s
"AtomicÅransfer size must be <= maxÅransfer (but $maxAtomic > $maxTransfer)")

20 
	`ªquúe
 (
maxTøns„r
 <4096, 
s
"MaxÅransfer size must be <= 4096 (was $maxTransfer)")

21 
def
 
acquúe
: 
Boﬁón
 = 
ªgi⁄
 =
Regi⁄Ty≥
.
TRACKED


22 
	}
}

28 
ab°ø˘
 
˛ass
 
	$DevNuŒDevi˚
(
∑øms
: 
DevNuŒP¨ams
, 
bótByãs
: 
I¡
, 
devi˚
: 
Sim∂eDevi˚
)

29 (
im∂icô
 
p
: 
P¨amëîs
)

30 
exãnds
 
LazyModuÀ
 
wôh
 
HasClockDomaöCrossög
 {

31 
vÆ
 
x„r
 = 
	`Tøns„rSizes
(1, 
∑øms
.
maxTøns„r
)

32 
vÆ
 
©om
 = 
	`Tøns„rSizes
(1, 
∑øms
.
maxAtomic
)

33 
vÆ
 
node
 = 
	`TLM™agîNode
(
	`Seq
(
	`TLM™agîP‹tP¨amëîs
(

34 
	`Seq
(
	`TLM™agîP¨amëîs
(

35 
addªss
 = 
∑øms
.address,

36 
ªsour˚s
 = 
devi˚
.
ªg
,

37 
ªgi⁄Ty≥
 = 
∑øms
.
ªgi⁄
,

38 
execuèbÀ
 = 
∑øms
.executable,

39 
suµ‹tsAcquúeT
 = i‡(
∑øms
.
acquúe
Ë
x„r
 
Tøns„rSizes
.
n⁄e
,

40 
suµ‹tsAcquúeB
 = i‡(
∑øms
.
acquúe
Ë
x„r
 
Tøns„rSizes
.
n⁄e
,

41 
suµ‹tsGë
 = 
x„r
,

42 
suµ‹tsPutP¨tül
 = 
x„r
,

43 
suµ‹tsPutFuŒ
 = 
x„r
,

44 
suµ‹tsArôhmëic
 = 
©om
,

45 
suµ‹tsLogiˇl
 = 
©om
,

46 
suµ‹tsHöt
 = 
x„r
,

47 
fifoId
 = 
	`Some
(0),

48 
mayDíyGë
 = 
∑øms
.mayDenyGet,

49 
mayDíyPut
 = 
∑øms
.mayDenyPut,

50 
ÆwaysGø¡sT
 = 
∑øms
.
acquúe
)),

51 
bótByãs
 = beatBytes,

52 
ídSökId
 = i‡(
∑øms
.
acquúe
) 1 0,

53 
möL©ícy
 = 1)))

54 
vÆ
 
é_xög
 = 
this
.
	`¸ossIn
(
node
)

55 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Error.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
imp‹t
 
	gsˇœ
.
	gm©h
.
mö


13 
˛ass
 
	$TLEº‹
(
∑øms
: 
DevNuŒP¨ams
, 
bótByãs
: 
I¡
 = 4)(
im∂icô
 
p
: 
P¨amëîs
)

14 
exãnds
 
	`DevNuŒDevi˚
(
∑øms
, 
bótByãs
, 
√w
 
	`Sim∂eDevi˚
("îr‹-devi˚", 
	`Seq
("sifive,error0")))

16 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

17 
imp‹t
 
TLMesßges
.
_


18 
imp‹t
 
TLPîmissi⁄s
.
_


20 
	`vÆ
 (
ö
, 
edge
Ë
node
.
	`ö
(0)

21 
vÆ
 
a
 = 
	`Queue
(
ö
.a, 1)

22 
vÆ
 
da
 = 
	`Wúe
(
ö
.
d
)

23 
vÆ
 
idÀ
 = 
	`RegInô
(
	`Boﬁ
(
åue
))

25 
vÆ
 
a_œ°
 = 
edge
.
	`œ°
(
a
)

26 
	`vÆ
 (
da_fú°
, 
da_œ°
, 
_
Ë
edge
.
	`fú°œ°
(
da
)

28 
	`as£π
 (
idÀ
 || 
da_fú°
)

29 
a
.
ªady
 :(
da
.ªady && 
da_œ°
 && 
idÀ
Ë|| !
a_œ°


30 
da
.
vÆid
 :
a
.vÆid && 
a_œ°
 && 
idÀ


32 
da
.
bôs
.
›code
 :
TLMesßges
.
	`adRe•⁄£
(
a
.bits.opcode)

33 
da
.
bôs
.
∑øm
 :
	`UI¡
(0)

34 
da
.
bôs
.
size
 :
a
.bits.size

35 
da
.
bôs
.
sour˚
 :
a
.bits.source

36 
da
.
bôs
.
sök
 :
	`UI¡
(0)

37 
da
.
bôs
.
díõd
 :
	`Boﬁ
(
åue
)

38 
da
.
bôs
.
d©a
 :
	`UI¡
(0)

39 
da
.
bôs
.
c‹ru±
 :
edge
.
	`hasD©a
(da.bits)

41 i‡(
∑øms
.
acquúe
) {

42 
vÆ
 
c
 = 
	`Queue
(
ö
.c, 1)

43 
vÆ
 
dc
 = 
	`Wúe
(
ö
.
d
)

45 
vÆ
 
c_œ°
 = 
edge
.
	`œ°
(
c
)

46 
vÆ
 
dc_œ°
 = 
edge
.
	`œ°
(
dc
)

49 
	`whí
 (
da
.
	`fúe
(Ë&& da.
bôs
.
›code
 ==
Gø¡
Ë{ 
idÀ
 :
	`Boﬁ
(
Ál£
) }

50 
	`whí
 (
ö
.
e
.
	`fúe
()Ë{ 
idÀ
 :
	`Boﬁ
(
åue
) }

52 
c
.
ªady
 :(
dc
.ªady && 
dc_œ°
Ë|| !
c_œ°


53 
dc
.
vÆid
 :
c
.vÆid && 
c_œ°


56 
dc
.
bôs
.
›code
 :
Rñó£Ack


57 
dc
.
bôs
.
∑øm
 :
	`Vec
(
toB
, 
toN
,ÅoN)(
c
.bits.param)

58 
dc
.
bôs
.
size
 :
c
.bits.size

59 
dc
.
bôs
.
sour˚
 :
c
.bits.source

60 
dc
.
bôs
.
sök
 :
	`UI¡
(0)

61 
dc
.
bôs
.
díõd
 :
	`Boﬁ
(
Ál£
)

62 
dc
.
bôs
.
d©a
 :
	`UI¡
(0)

63 
dc
.
bôs
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

66 
TLArbôî
.
	`lowe°
(
edge
, 
ö
.
d
, 
dc
, 
da
)

68 
ö
.
d
 <> 
da


72 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

75 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

77 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MaskROM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
Ba£Subsy°em


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
˛ass
 
	$MaskROMP¨ams
(
addªss
: 
BigI¡
, 
«me
: 
Såög
, 
dïth
: 
I¡
 = 2048, 
width
: Int = 32)

14 
obje˘
 
PîùhîyMaskROMKey
 
exãnds
 
Fõld
[
Seq
[
MaskROMP¨ams
]]

16 
åaô
 
HasPîùhîyMaskROMSœve
 { 
this
: 
Ba£Subsy°em
 =>

17 
vÆ
 
maskROMP¨ams
 = 
	`p
(
PîùhîyMaskROMKey
)

18 
vÆ
 
maskROMs
 = 
maskROMP¨ams
 
m≠
 { 
∑øms
 =>

19 
vÆ
 
maskROM
 = 
	`LazyModuÀ
(
√w
 
	`TLMaskROM
(
∑øms
))

20 
sbus
.
c⁄åﬁ_bus
.
	`toFixedWidthSögÀBótSœve
(
maskROM
.
bótByãs
, 
	`Some
("MaskROM")Ë{ maskROM.
node
 }

21 
maskROM


23 
	}
}

25 ˛as†
	cTLMaskROM
(
c
: 
MaskROMP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

26 
vÆ
 
bótByãs
 = 
c
.
width
/8

27 
vÆ
 
node
 = 
	`TLM™agîNode
(
	`Seq
(
	`TLM™agîP‹tP¨amëîs
(

28 
	`Seq
(
	`TLM™agîP¨amëîs
(

29 
addªss
 = 
AddªssSë
.
	`mißlig√d
(
c
.addªss, c.
dïth
*
bótByãs
),

30 
ªsour˚s
 = 
√w
 
	`Sim∂eDevi˚
("rom", 
	`Seq
("sifive,maskrom0")).
	`ªg
("mem"),

31 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

32 
execuèbÀ
 = 
åue
,

33 
suµ‹tsGë
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

34 
fifoId
 = 
	`Some
(0))),

35 
bótByãs
 = beatBytes)))

37 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

38 
	`vÆ
 (
ö
, 
edge
)
node
.
	`ö
(0)

40 
vÆ
 
rom
 = 
	`ROMGíî©‹
(
	`ROMC⁄fig
(
c
.
«me
, c.
dïth
, c.
width
))

41 
rom
.
io
.
˛ock
 := clock

42 
rom
.
io
.
addªss
 :
edge
.
	`addr_hi
(
ö
.
a
.
bôs
.addªs†- 
	`UI¡
(
c
.addªss))(
	`log2Ceû
(c.
dïth
)-1, 0)

43 
rom
.
io
.
€
 :
	`Boﬁ
(
åue
)

44 
rom
.
io
.
me
 :
ö
.
a
.
	`fúe
()

46 
vÆ
 
d_fuŒ
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

47 
vÆ
 
d_size
 = 
	`Reg
(
	`UI¡
())

48 
vÆ
 
d_sour˚
 = 
	`Reg
(
	`UI¡
())

49 
vÆ
 
d_d©a
 = 
rom
.
io
.
q
 
hﬁdU∆ess
 
	`RegNext
(
ö
.
a
.
	`fúe
())

52 
	`whí
 (
ö
.
d
.
	`fúe
()Ë{ 
d_fuŒ
 :
	`Boﬁ
(
Ál£
) }

53 
	`whí
 (
ö
.
a
.
	`fúe
()Ë{ 
d_fuŒ
 :
	`Boﬁ
(
åue
) }

54 
ö
.
d
.
vÆid
 :
d_fuŒ


55 
ö
.
a
.
ªady
 :ö.
d
.ªady || !
d_fuŒ


57 
	`whí
 (
ö
.
a
.
	`fúe
()) {

58 
d_size
 :
ö
.
a
.
bôs
.
size


59 
d_sour˚
 :
ö
.
a
.
bôs
.
sour˚


62 
ö
.
d
.
bôs
 :
edge
.
	`Ac˚ssAck
(
d_sour˚
, 
d_size
, 
d_d©a
)

65 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

66 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

67 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

69 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MasterMux.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
˛ass
 
Ma°îMuxNode
(
uFn
: 
Seq
[
TLClõ¡P‹tP¨amëîs
] => TLClõ¡P‹tP¨amëîs)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
TLCu°omNode


13 
def
 
ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

14 
ªquúe
 (
iSèrs
 =0 && 
oSèrs
 == 0, "MasterMuxÇode doesÇot support :=* or :*=")

15 
ªquúe
 (
iKnown
 == 2, "MasterMuxÇodeÉxpectsÉxactlyÅwo inputs")

16 
ªquúe
 (
oKnown
 == 1, "MasterMuxÇodeÉxpectsÉxactly one output")

19 
def
 
m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
TLClõ¡P‹tP¨amëîs
]): Seq[TLClõ¡P‹tP¨amëîs] = { Seq(
uFn
(p)) }

20 
def
 
m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
TLM™agîP‹tP¨amëîs
]): Seq[TLManagerPortParameters] = {Ö ++Ö }

23 
˛ass
 
MuãMa°î
(
«me
: 
Såög
 = "MuãMa°î", 
maxProbe
: 
I¡
 = 0)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


25 
vÆ
 
node
 = 
TLClõ¡Node
(
Seq
(
TLClõ¡P‹tP¨amëîs
(
˛õ¡s
 = Seq(
TLClõ¡P¨amëîs
(

26 
«me
 =Çame,

27 
suµ‹tsProbe
 = i‡(
maxProbe
 > 0Ë
Tøns„rSizes
(1, maxProbeËTøns„rSizes.
n⁄e
)))))

29 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

30 
vÆ
 
Seq
((
out
, 
edgeOut
)Ë
node
.out

31 
out
.
a
.
vÆid
 :
Boﬁ
(
Ál£
)

32 
out
.
b
.
ªady
 :out.
c
.ready

33 
out
.
c
.
vÆid
 :out.
b
.valid

34 
out
.
d
.
ªady
 :
Boﬁ
(
åue
)

35 
out
.
e
.
vÆid
 :
Boﬁ
(
Ál£
)

37 
out
.
c
.
bôs
 :
edgeOut
.
ProbeAck
(out.
b
.bôs, 
TLPîmissi⁄s
.
NtoN
)

41 
˛ass
 
Ma°îMux
(
uFn
: 
Seq
[
TLClõ¡P‹tP¨amëîs
] => TLClõ¡P‹tP¨amëîs)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


43 
vÆ
 
node
 = 
√w
 
Ma°îMuxNode
(
uFn
)

45 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

46 
vÆ
 
io
 = 
IO
(
√w
 
BundÀ
 {

47 
vÆ
 
by∑ss
 = 
Boﬁ
(
INPUT
)

48 
vÆ
 
≥ndög
 = 
Boﬁ
(
OUTPUT
)

51 
vÆ
 
Seq
((
ö0
, 
edgeIn0
), (
ö1
, 
edgeIn1
)Ë
node
.
ö


52 
vÆ
 
Seq
((
out
, 
edgeOut
)Ë
node
.out

55 
vÆ
 
by∑ss
 = 
RegInô
(
io
.bypass)

56 
vÆ
 (
Êight
, 
√xt_Êight
Ë
edgeOut
.
öFlight
(
out
)

58 
io
.
≥ndög
 :(
Êight
 > 0.U)

59 
whí
 (
√xt_Êight
 ==
UI¡
(0)Ë{ 
by∑ss
 :
io
.bypass }

60 
vÆ
 
°Æl
 = (
by∑ss
 =/
io
.by∑ssË&& 
edgeOut
.
fú°
(
out
.
a
)

62 
ö0
.
a
.
ªady
 :!
°Æl
 && 
out
.a.ªady && 
by∑ss


63 
ö1
.
a
.
ªady
 :!
°Æl
 && 
out
.a.ªady && !
by∑ss


64 
out
.
a
.
vÆid
 :!
°Æl
 && 
Mux
(
by∑ss
, 
ö0
.a.vÆid, 
ö1
.a.valid)

65 
def
 
ˇ°A
(
x
: 
TLBundÀA
Ë{ 
vÆ
 
ªt
 = 
Wúe
(
out
.
a
.
bôs
); 
	gªt
 <> 
	gx
;Ñet }

66 
	gout
.
	ga
.
	gbôs
 :
Mux
(
by∑ss
, 
ˇ°A
(
ö0
.
a
.
bôs
), ca°A(
ö1
.a.bits))

68 
	gout
.
	gd
.
	gªady
 :
Mux
(
by∑ss
, 
ö0
.
d
.
ªady
, 
ö1
.d.ready)

69 
	gö0
.
	gd
.
	gvÆid
 :
out
.
d
.
vÆid
 && 
by∑ss


70 
ö1
.
d
.
vÆid
 :
out
.d.vÆid && !
by∑ss


71 
ö0
.
d
.
bôs
 :
out
.d.bits

72 
ö1
.
d
.
bôs
 :
out
.d.bits

74 i‡(
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeOut.
˛õ¡
.
™ySuµ‹tProbe
) {

75 
out
.
b
.
ªady
 :
Mux
(
by∑ss
, 
ö0
.b.ªady, 
ö1
.b.ready)

76 
	gö0
.
	gb
.
	gvÆid
 :
out
.
b
.
vÆid
 && 
by∑ss


77 
ö1
.
b
.
vÆid
 :
out
.b.vÆid && !
by∑ss


78 
ö0
.
b
.
bôs
 :
out
.b.bits

79 
ö1
.
b
.
bôs
 :
out
.b.bits

81 
ö0
.
c
.
ªady
 :
out
.c.ªady && 
by∑ss


82 
ö1
.
c
.
ªady
 :
out
.c.ªady && !
by∑ss


83 
out
.
c
.
vÆid
 :
Mux
(
by∑ss
, 
ö0
.c.vÆid, 
ö1
.c.valid)

84 
def
 
ˇ°C
(
x
: 
TLBundÀC
Ë{ 
vÆ
 
ªt
 = 
Wúe
(
out
.
c
.
bôs
); 
	gªt
 <> 
	gx
;Ñet }

85 
	gout
.
	gc
.
	gbôs
 :
Mux
(
by∑ss
, 
ˇ°C
(
ö0
.
c
.
bôs
), ca°C(
ö1
.c.bits))

87 
	gö0
.
	ge
.
	gªady
 :
out
.
e
.
ªady
 && 
by∑ss


88 
ö1
.
e
.
ªady
 :
out
.e.ªady && !
by∑ss


89 
out
.
e
.
vÆid
 :
Mux
(
by∑ss
, 
ö0
.e.vÆid, 
ö1
.e.valid)

90 
def
 
ˇ°E
(
x
: 
TLBundÀE
Ë{ 
vÆ
 
ªt
 = 
Wúe
(
out
.
e
.
bôs
); 
	gªt
 <> 
	gx
;Ñet }

91 
	gout
.
	ge
.
	gbôs
 :
Mux
(
by∑ss
, 
ˇ°E
(
ö0
.
e
.
bôs
), ca°E(
ö1
.e.bits))

93 
	gö0
.
	gb
.
	gvÆid
 :
Boﬁ
(
Ál£
)

94 
ö0
.
c
.
ªady
 :
Boﬁ
(
åue
)

95 
ö0
.
e
.
ªady
 :
Boﬁ
(
åue
)

97 
ö1
.
b
.
vÆid
 :
Boﬁ
(
Ál£
)

98 
ö1
.
c
.
ªady
 :
Boﬁ
(
åue
)

99 
ö1
.
e
.
ªady
 :
Boﬁ
(
åue
)

101 
out
.
b
.
ªady
 :
Boﬁ
(
åue
)

102 
out
.
c
.
vÆid
 :
Boﬁ
(
Ál£
)

103 
out
.
e
.
vÆid
 :
Boﬁ
(
Ál£
)

109 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


111 ˛as†
	cTLMa°îMuxTe°î
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

112 
vÆ
 
fuzz1
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

113 
vÆ
 
fuzz2
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

114 
vÆ
 
modñ1
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("MasterMux1"))

115 
vÆ
 
modñ2
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("MasterMux2"))

116 
vÆ
 
mux
 = 
	`LazyModuÀ
(
√w
 
	$Ma°îMux
(
uFn
 = 
_
.
hód
))

117 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0, 0x3ff), 
bótByãs
 = 4))

118 
mux
.
node
 :
	`TLFûãr
(
TLFûãr
.
	`mSñe˘I¡î£˘
(
	`AddªssSë
–0, ~16))Ë:
modñ1
.nodê:
fuzz1
.node

119 
mux
.
node
 :
	`TLFûãr
(
TLFûãr
.
	`mSñe˘I¡î£˘
(
	`AddªssSë
(16, ~16))Ë:
modñ2
.nodê:
fuzz2
.node

120 
øm
.
node
 :
	$TLFøgmíãr
(4, 16Ë:
mux
.
node


123 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

124 
io
.
föished
 :
fuzz1
.
moduÀ
.io.föished && 
fuzz2
.module.io.finished

125 
mux
.
moduÀ
.
io
.
by∑ss
 :
	`LFSR64
(
	`Boﬁ
(
åue
))(0)

127 
	}
}

129 
˛ass
 
	$TLMa°îMuxTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

130 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLMa°îMuxTe°î
(
txns
)).
moduÀ
)

131 
io
 <> 
dut
.io

132 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/PhysicalFilter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
˛ass
 
	$Devi˚PMPP¨ams
(
addªssBôs
: 
I¡
, 
∑geBôs
: Int)

13 ˛as†
	cDevi˚PMP
(
∑øms
: 
Devi˚PMPP¨ams
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

15 
	`ªquúe
 (
∑øms
.
addªssBôs
 >Ö¨ams.
∑geBôs
)

17 
vÆ
 
l
 = 
	$UI¡
(
width
 = 1)

18 
vÆ
 
a
 = 
	$UI¡
(
width
 = 1)

19 
vÆ
 
r
 = 
	$UI¡
(
width
 = 1)

20 
vÆ
 
w
 = 
	$UI¡
(
width
 = 1)

22 
vÆ
 
addr_hi
 = 
	`UI¡
(
width
 = 
∑øms
.
addªssBôs
-∑øms.
∑geBôs
)

23 
def
 
addªss
 = 
	`C©
(
addr_hi
, 
	$UI¡
(0, 
width
=
∑øms
.
∑geBôs
))

24 
def
 
blockPri‹Addªss
 = 
	`l
(0Ë&& 
	$a
(0)

26 
def
 
	$fõlds
(
blockAddªss
: 
Boﬁ
): 
Seq
[
RegFõld
] = {

27 
def
 
	`fõld
(
bôs
: 
I¡
, 
ªg
: 
UI¡
, 
lock
: 
Boﬁ
 = 
	`l
(0)) =

28 
	`RegFõld
(
bôs
, 
	`RegRódFn
(
ªg
), 
	`RegWrôeFn
((
wí
, 
d©a
) => {

29 
	`whí
 (
wí
 && !
lock
Ë{ 
ªg
 :
d©a
 }

30 
	`Boﬁ
(
åue
)

32 
	`Seq
(

33 
	`RegFõld
(
∑øms
.
∑geBôs
-2),

34 
	`fõld
(
∑øms
.
addªssBôs
-∑øms.
∑geBôs
, 
addr_hi
, 
	`l
(0Ë|| 
blockAddªss
),

35 
	`RegFõld
(56 - (
∑øms
.
addªssBôs
-2)),

36 
	`fõld
(1, 
r
),

37 
	`fõld
(1, 
w
),

38 
	`RegFõld
(1),

39 
	`fõld
(1, 
a
),

40 
	`RegFõld
(3),

41 
	`fõld
(1, 
l
))

43 
	}
}

45 
˛ass
 
	$PMPInôülVÆue
(
addªss
: 
BigI¡
 = 0, 
l
: 
Boﬁón
 = 
Ál£
, 
a
: Boﬁó¿Ál£, 
r
: Boﬁó¿Ál£, 
w
: Boolean = false)

47 
obje˘
 
Devi˚PMP


49 
def
 
	`≠∂y
(
addªssBôs
: 
I¡
, 
∑geBôs
: I¡, 
öôül
: 
O±i⁄
[
PMPInôülVÆue
] = 
N⁄e
) = {

50 
vÆ
 
out
 = 
	`Wúe
(
√w
 
	`Devi˚PMP
(
	`Devi˚PMPP¨ams
(
addªssBôs
, 
∑geBôs
)))

52 
öôül
.
f‹óch
 { 
i
 =>

53 
	`ªquúe
 ((
i
.
addªss
 >> 
addªssBôs
) == 0)

54 
	`ªquúe
 ((
i
.
addªss
 >> 
∑geBôs
) <<ÖageBits == i.address)

55 
out
.
addr_hi
 :
	`UI¡
(
i
.
addªss
 >> 
∑geBôs
)

58 
def
 
	`gë
(
f
: 
PMPInôülVÆue
 => 
Boﬁón
Ë
öôül
.
	`m≠
(
x
 => 
	`Boﬁ
(
	`f
(x)).
asUI¡
).
	`gëOrEl£
(
	`UI¡
(0))

59 
out
.
l
 :
	`gë
(
_
.l)

60 
out
.
a
 :
	`gë
(
_
.a)

61 
out
.
r
 :
	`gë
(
_
.r)

62 
out
.
w
 :
	`gë
(
_
.w)

63 
out


65 
	}
}

74 
˛ass
 
PhysiˇlFûãrP¨ams
(

75 
c⁄åﬁAddªss
: 
BigI¡
,

76 
c⁄åﬁBótByãs
: 
I¡
,

77 
pmpRegi°îs
: 
Seq
[
PMPInôülVÆue
] = Seq.
	$fûl
(4Ë{ 
	`PMPInôülVÆue
(Ë
	}
} )

79 
vÆ
 
∑ge
 = 4096

80 
vÆ
 
∑geBôs
 = 
log2Ceû
(
∑ge
)

81 
vÆ
 
size
 = (((
pmpRegi°îs
.sizê* 8Ë+ 
∑ge
 - 1) /Öage) *Öage

83 
ªquúe
 (!
pmpRegi°îs
.
isEm±y
)

84 
ªquúe
 (
c⁄åﬁAddªss
 > 0)

85 
ªquúe
 (
c⁄åﬁAddªss
 % 
size
 == 0)

86 
ªquúe
 (
c⁄åﬁBótByãs
 > 0 && 
isPow2
(controlBeatBytes))

89 ˛as†
	cPhysiˇlFûãr
(
∑øms
: 
PhysiˇlFûãrP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


91 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(
m™agîFn
 = { 
mp
 => mp.
	`c›y
(

92 
m™agîs
 = 
mp
.m™agîs.
	`m≠
(
_
.
	`c›y
(
ÆwaysGø¡sT
 = 
Ál£
)),

93 
ídSökId
 = i‡(
mp
.endSinkId == 0) { 0 } { mp.endSinkId+1 },

94 
möL©ícy
 = 1 
mö
 
mp
.minLatency)})

96 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("physiˇl-fûãr", 
	`Seq
("sifive,physical-filter-v0"))

97 
vÆ
 
c⁄åﬁNode
 = 
	`TLRegi°îNode
(

98 
addªss
 = 
	`Seq
(
	`AddªssSë
(
∑øms
.
c⁄åﬁAddªss
,Ö¨ams.
size
-1)),

99 
devi˚
 = device,

100 
bótByãs
 = 
∑øms
.
c⁄åﬁBótByãs
)

102 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

104 
vÆ
 
addªssBôs
 = 
	`log2Ceû
(
node
.
edges
.
out
.
	`m≠
(
_
.
m™agî
.
maxAddªss
).
max
+1+1)

105 
vÆ
 
pmps
 = 
	`RegInô
(
	`Vec
(
∑øms
.
pmpRegi°îs
.
m≠
 { 
ivÆ
 => 
	`Devi˚PMP
(
addªssBôs
,Ö¨ams.
∑geBôs
, 
	`Some
(ival)) }))

106 
vÆ
 
blocks
 = 
pmps
.
èû
.
	`m≠
(
_
.
blockPri‹Addªss
Ë:+ 
	`Boﬁ
(
Ál£
)

107 
c⁄åﬁNode
.
	`ªgm≠
(0 -> (
pmps
 
zù
 
blocks
).
m≠
 { (
p
, 
b
Ë=>Ö.
	`fõlds
(bË}.
toLi°
.
Ê©ãn
)

109 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

110 
out
 <> 
ö


113 
vÆ
 
mySökId
 = 
	`UI¡
(
edgeOut
.
m™agî
.
ídSökId
)

114 
vÆ
 
a_fú°
 = 
edgeIn
.
	`fú°
(
ö
.
a
)

115 
	`vÆ
 (
d_fú°
, 
d_œ°
, 
_
Ë
edgeIn
.
	`fú°œ°
(
ö
.
d
)

118 
vÆ
 
√edW
 = 
ö
.
a
.
bôs
.
›code
 =/
TLMesßges
.
Gë
 &&

119 (
ö
.
a
.
bôs
.
›code
 =/
TLMesßges
.
AcquúeBlock
 ||

120 
ö
.
a
.
bôs
.
∑øm
 =/
TLPîmissi⁄s
.
NtoB
 ||

121 
	`Boﬁ
(!
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
))

122 
vÆ
 
√edR
 = 
ö
.
a
.
bôs
.
›code
 =/
TLMesßges
.
PutFuŒD©a
 &&

123 
ö
.
a
.
bôs
.
›code
 =/
TLMesßges
.
PutP¨tülD©a


124 
vÆ
 
…
 = 
	`Boﬁ
(
Ál£
Ë+: 
pmps
.
	`m≠
(
ö
.
a
.
bôs
.
addªss
 < 
_
.address)

125 
vÆ
 
£l
 = (
pmps
.
	`m≠
(
_
.
a
Ë
	`zù
 (
…
.
öô
 
zù
Üt.
èû
)Ë
m≠
 { ◊, (
l
, 
r
)Ë=> 
	`a
(0) && !l &&Ñ }

126 
vÆ
 
ok
 = 
pmps
.
	`m≠
(
p
 => (p.
	`r
(0Ë|| !
√edR
Ë&& (p.
	`w
(0Ë|| !
√edW
))

127 
vÆ
 
ÆlowFú°
 = 
	`Pri‹ôyMux
(
£l
 :+ 
	`Boﬁ
(
åue
), 
ok
 :+ Boﬁ(
Ál£
))

128 
vÆ
 
Ælow
 = 
ÆlowFú°
 
hﬁdU∆ess
 
a_fú°


131 
vÆ
 
d_øck
 = 
	`Boﬁ
(
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
Ë&& 
ö
.
d
.
bôs
.
›code
 ==
TLMesßges
.
Rñó£Ack


132 
vÆ
 
Êight
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
	`log2Ceû
(
edgeIn
.
˛õ¡
.
ídSour˚Id
+1+1)))

133 
vÆ
 
díyWaô
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

134 
Êight
 :Êighà+ (
a_fú°
 && 
ö
.
a
.
	`fúe
()Ë- (
d_œ°
 && !
d_øck
 && in.
d
.fire())

137 
vÆ
 
díy_ªady
 = !
díyWaô
 && 
Êight
 ==
	`UI¡
(0)

138 
ö
.
a
.
ªady
 :
	`Mux
(
Ælow
, 
out
.a.ªady, !
a_fú°
 || 
díy_ªady
)

139 
out
.
a
.
vÆid
 :
ö
.a.vÆid && 
Ælow


142 
vÆ
 
díyVÆid
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

143 
vÆ
 
díy
 = 
	`Reg
(
ö
.
d
.
bôs
)

144 
vÆ
 
d_›code
 = 
TLMesßges
.
	`adRe•⁄£
(
ö
.
a
.
bôs
.
›code
)

145 
vÆ
 
d_gø¡
 = 
	`Boﬁ
(
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
Ë&& 
díy
.
›code
 ==
TLMesßges
.
Gø¡


146 
	`whí
 (
ö
.
a
.
vÆid
 && !
Ælow
 && 
díy_ªady
 && 
a_fú°
) {

147 
díyVÆid
 :
	`Boﬁ
(
åue
)

148 
díyWaô
 :
	`Boﬁ
(
åue
)

149 
díy
.
›code
 :
d_›code


150 
díy
.
∑øm
 :
	`UI¡
(0)

151 
díy
.
size
 :
ö
.
a
.
bôs
.size

152 
díy
.
sour˚
 :
ö
.
a
.
bôs
.source

153 
díy
.
sök
 :
mySökId


154 
díy
.
díõd
 :
	`Boﬁ
(
åue
)

155 
díy
.
d©a
 :
	`UI¡
(0)

156 
díy
.
c‹ru±
 :
	`d_›code
(0)

158 
	`whí
 (
díyVÆid
 && 
ö
.
d
.
ªady
 && 
d_œ°
) {

159 
díyVÆid
 :
	`Boﬁ
(
Ál£
)

160 
	`whí
 (!
d_gø¡
) {

161 
díyWaô
 :
	`Boﬁ
(
Ál£
)

165 
vÆ
 
out_d
 = 
	`Wúe
(
ö
.
d
.
bôs
)

166 
out_d
 :
out
.
d
.
bôs


171 
ö
.
d
.
vÆid
 :
out
.d.vÆid || 
díyVÆid


172 
out
.
d
.
ªady
 :!
díyVÆid
 && 
ö
.d.ready

173 
ö
.
d
.
bôs
 :
	`Mux
(
díyVÆid
, 
díy
, 
out_d
)

176 i‡(
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
) {

177 
vÆ
 
wSour˚Vec
 = 
	`Reg
(
	`Vec
(
edgeIn
.
˛õ¡
.
ídSour˚Id
, 
	`Boﬁ
()))

178 
vÆ
 
aWOk
 = 
	`Pri‹ôyMux
(
£l
, 
pmps
.
	`m≠
(
_
.
	`w
(0)))

179 
vÆ
 
dWOk
 = 
	`wSour˚Vec
(
ö
.
d
.
bôs
.
sour˚
)

180 
vÆ
 
by∑ss
 = 
	`Boﬁ
(
edgeIn
.
m™agî
.
möL©ícy
 =0Ë&& 
ö
.
a
.
vÆid
 && in.a.
bôs
.
sour˚
 ==ö.
d
.bits.source

181 
vÆ
 
d_gø¡
 = 
ö
.
d
.
bôs
.
›code
 ==
TLMesßges
.
Gø¡
 || in.d.bôs.›codê==TLMesßges.
Gø¡D©a


182 
vÆ
 
dWHñd
 = 
	`Mux
(
by∑ss
, 
aWOk
, 
dWOk
Ë
hﬁdU∆ess
 
d_fú°


184 
	`whí
 (
d_gø¡
 && !
dWHñd
) {

185 
ö
.
d
.
bôs
.
∑øm
 :
TLPîmissi⁄s
.
toB


188 
	`whí
 (
ö
.
a
.
	`fúe
(Ë&& 
a_fú°
) {

189 
	`wSour˚Vec
(
ö
.
a
.
bôs
.
sour˚
Ë:
aWOk


192 
edgeIn
.
˛õ¡
.
unu£dSour˚s
.
f‹óch
 { 
id
 =>

193 
	`wSour˚Vec
(
id
Ë:
	`Boﬁ
(
åue
)

197 
vÆ
 
isMyId
 = 
mySökId
 ==
ö
.
e
.
bôs
.
sök


198 
out
.
e
.
vÆid
 :
ö
.e.vÆid && !
isMyId


199 
ö
.
e
.
ªady
 :
out
.e.ªady || 
isMyId


201 
	`whí
 (
ö
.
e
.
	`fúe
(Ë&& 
isMyId
) {

202 
díyWaô
 :
	`Boﬁ
(
Ál£
)

206 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Plic.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
Ba£Subsy°em


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


15 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


16 
imp‹t
 
	gsˇœ
.
	gm©h
.
mö


18 ˛as†
	cG©ewayPLICIO
 
exãnds
 
	mBundÀ
 {

19 
vÆ
 
	mvÆid
 = 
	$Boﬁ
(
OUTPUT
)

20 
vÆ
 
ªady
 = 
	$Boﬁ
(
INPUT
)

21 
vÆ
 
com∂ëe
 = 
	`Boﬁ
(
INPUT
)

24 ˛as†
	cLevñG©eway
 
exãnds
 
ModuÀ
 {

25 
vÆ
 
io
 = 
√w
 
BundÀ
 {

26 
vÆ
 
öãºu±
 = 
	`Boﬁ
(
INPUT
)

27 
vÆ
 
∂ic
 = 
√w
 
G©ewayPLICIO


30 
vÆ
 
öFlight
 = 
	`Reg
(
öô
=
	$Boﬁ
(
Ál£
))

31 
	$whí
 (
io
.
öãºu±
 && io.
∂ic
.
ªady
Ë{ 
öFlight
 :
åue
 
	}
}

32 
	$whí
 (
io
.
∂ic
.
com∂ëe
Ë{ 
öFlight
 :
Ál£
 
	}
}

33 
io
.
∂ic
.
vÆid
 :io.
öãºu±
 && !
öFlight


36 
obje˘
 
PLICC⁄°s


38 
def
 
maxDevi˚s
 = 1023

39 
def
 
maxH¨ts
 = 15872

40 
def
 
¥i‹ôyBa£
 = 0x0

41 
def
 
≥ndögBa£
 = 0x1000

42 
def
 
íabÀBa£
 = 0x2000

43 
def
 
h¨tBa£
 = 0x200000

45 
def
 
˛aimOff£t
 = 4

46 
def
 
¥i‹ôyByãs
 = 4

48 
def
 
íabÀOff£t
(
i
: 
I¡
Ëò* ((
maxDevi˚s
+7)/8)

49 
def
 
h¨tOff£t
(
i
: 
I¡
) = i * 0x1000

50 
def
 
íabÀBa£
(
i
: 
I¡
):I¡ = 
íabÀOff£t
(i) +ÉnableBase

51 
def
 
h¨tBa£
(
i
: 
I¡
):I¡ = 
h¨tOff£t
(i) + hartBase

53 
def
 
size
 = 
h¨tBa£
(
maxH¨ts
)

54 
ªquúe
(
h¨tBa£
 >
íabÀBa£
(
maxH¨ts
))

57 
˛ass
 
	$PLICP¨ams
(
ba£Addªss
: 
BigI¡
 = 0xC000000, 
maxPri‹ôõs
: 
I¡
 = 7, 
ötSèges
: Int = 0)

59 
	`ªquúe
 (
maxPri‹ôõs
 >= 0)

60 
def
 
addªss
 = 
	`AddªssSë
(
ba£Addªss
, 
PLICC⁄°s
.
size
-1)

61 
	}
}

63 
obje˘
 
PLICKey
 
exãnds
 
	gFõld
[
O±i⁄
[
PLICP¨ams
]](
	gN⁄e
)

66 
˛ass
 
	$TLPLIC
(
∑øms
: 
PLICP¨ams
, 
bótByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


69 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("öãºu±-c⁄åﬁÀr", 
	`Seq
("riscv,plic0")) {

70 
ovîride
 
vÆ
 
ÆwaysExãnded
 = 
åue


71 
ovîride
 
def
 
	`des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

72 
vÆ
 
	`Des¸ùti⁄
(
«me
, 
m≠pög
Ë
su≥r
.
	`des¸ibe
(
ªsour˚s
)

73 
vÆ
 
exåa
 = 
	`M≠
(

74 "öãºu±-c⁄åﬁÀr" -> 
Nû
,

75 "riscv,ndev" -> 
	`Seq
(
	`Resour˚I¡
(
nDevi˚s
)),

76 "riscv,max-¥i‹ôy" -> 
	`Seq
(
	`Resour˚I¡
(
nPri‹ôõs
)),

77 "#öãºu±-˚Œs" -> 
	`Seq
(
	`Resour˚I¡
(1)))

78 
	`Des¸ùti⁄
(
«me
, 
m≠pög
 ++ 
exåa
)

82 
vÆ
 
node
 = 
	`TLRegi°îNode
(

83 
addªss
 = 
	`Seq
(
∑øms
.address),

84 
devi˚
 = device,

85 
bótByãs
 = beatBytes,

86 
undefZîo
 = 
åue
,

87 
c⁄cuºícy
 = 1)

89 
vÆ
 
öäode
 = 
	`I¡NexusNode
(

90 
sour˚Fn
 = { 
_
 => 
	`I¡Sour˚P‹tP¨amëîs
(
	`Seq
(
	`I¡Sour˚P¨amëîs
(1, Seq(
	`Resour˚
(
devi˚
, "int"))))) },

91 
sökFn
 = { 
_
 => 
	`I¡SökP‹tP¨amëîs
(
	`Seq
(
	`I¡SökP¨amëîs
())) },

92 
ouçutRequúesI≈ut
 = 
Ál£
,

93 
öputRequúesOuçut
 = 
Ál£
)

96 
def
 
nDevi˚s
: 
I¡
 = 
öäode
.
edges
.
ö
.
	`m≠
(
_
.
sour˚
.
num
).
sum


97 
def
 
möPri‹ôõs
 = 
	`mö
(
∑øms
.
maxPri‹ôõs
, 
nDevi˚s
)

98 
def
 
nPri‹ôõs
 = (1 << 
	`log2Ceû
(
möPri‹ôõs
+1)) - 1

99 
def
 
nH¨ts
 = 
öäode
.
edges
.
out
.
	`m≠
(
_
.
sour˚
.
num
).
sum


102 
œzy
 
vÆ
 
sour˚s
 = 
öäode
.
edges
.
ö
.
	`m≠
(
_
.
sour˚
)

103 
œzy
 
vÆ
 
Ê©Sour˚s
 = (
sour˚s
 
zù
 sour˚s.
	`m≠
(
_
.
num
).
	`sˇnLe·
(0)(_+_).
öô
).
m≠
 {

104 (
s
, 
o
Ë=> s.
sour˚s
.
	`m≠
(
z
 => z.
	`c›y
(
ønge
 = z.ønge.
	`off£t
(o)))

105 }.
Ê©ãn


107 
Resour˚Bödög
 {

108 
Ê©Sour˚s
.
f‹óch
 { 
s
 => s.
ªsour˚s
.f‹óch { 
r
 =>

110 (
s
.
ønge
.
°¨t
 
u¡û
 s.ønge.
íd
).
f‹óch
 { 
i
 => 
r
.
	`böd
(
devi˚
, 
	`Resour˚I¡
(i+1)) }

114 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

115 
A¬Ÿ©ed
.
	`∑øms
(
this
, 
∑øms
)

117 
	`vÆ
 (
io_devi˚s
, 
edgesIn
Ë
öäode
.
ö
.
unzù


118 
	`vÆ
 (
io_h¨ts
, 
_
Ë
öäode
.
out
.
unzù


121 
vÆ
 
öãºu±s
 = 
öäode
.
ö
.
m≠
 { (
i
, 
e
Ë=> i.
	`èke
”.
sour˚
.
num
Ë}.
Ê©ãn


123 
vÆ
 
h¨ts
 = 
io_h¨ts
.
Ê©ãn


125 
	`¥öén
(
s
"Interrupt map (${nHarts} harts ${nDevices} interrupts):")

126 
Ê©Sour˚s
.
f‹óch
 { 
s
 =>

128 
	`¥öén
(
s
" [${s.range.start+1}, ${s.range.end}] => ${s.name}")

130 
	`¥öén
("")

132 
	`ªquúe
 (
nDevi˚s
 =
öãºu±s
.
size
, 
s
"Must be:ÇDevices=$nDevices == interrupts.size=${interrupts.size}")

133 
	`ªquúe
 (
nH¨ts
 =
h¨ts
.
size
, 
s
"Must be:ÇHarts=$nHarts == harts.size=${harts.size}")

135 
	`ªquúe
(
nDevi˚s
 <
PLICC⁄°s
.
maxDevi˚s
, 
s
"Must be:ÇDevices=$nDevices <= PLICConsts.maxDevices=${PLICConsts.maxDevices}")

136 
	`ªquúe
(
nH¨ts
 > 0 &&ÇH¨t†<
PLICC⁄°s
.
maxH¨ts
, 
s
"Must be:ÇHarts=$nHarts > 0 &&ÇHarts <= PLICConsts.maxHarts=${PLICConsts.maxHarts}")

139 
vÆ
 
g©eways
 = 
öãºu±s
.
m≠
 { 
i
 =>

140 
vÆ
 
g©eway
 = 
	`ModuÀ
(
√w
 
LevñG©eway
)

141 
g©eway
.
io
.
öãºu±
 :
i


142 
g©eway
.
io
.
∂ic


145 
vÆ
 
¥ioBôs
 = 
	`log2Ceû
(
nPri‹ôõs
+1)

146 
vÆ
 
¥i‹ôy
 =

147 i‡(
nPri‹ôõs
 > 0Ë
	`Reg
(
	`Vec
(
nDevi˚s
, 
	`UI¡
(
width
=
¥ioBôs
)))

148 
	`Wúe
(
öô
=
Vec
.
	`fûl
(
nDevi˚s
)(
	`UI¡
(1)))

149 
vÆ
 
thªshﬁd
 =

150 i‡(
nPri‹ôõs
 > 0Ë
	`Reg
(
	`Vec
(
nH¨ts
, 
	`UI¡
(
width
=
¥ioBôs
)))

151 
	`Wúe
(
öô
=
Vec
.
	`fûl
(
nH¨ts
)(
	`UI¡
(0)))

152 
vÆ
 
≥ndög
 = 
	`Reg
(
öô
=
Vec
.
	`fûl
(
nDevi˚s
){
	`Boﬁ
(
Ál£
)})

155 
vÆ
 
fú°E«bÀ
 = 
nDevi˚s
 
mö
 7

156 
vÆ
 
fuŒE«bÀs
 = (
nDevi˚s
 - 
fú°E«bÀ
) / 8

157 
vÆ
 
èûE«bÀ
 = 
nDevi˚s
 - 
fú°E«bÀ
 - 8*
fuŒE«bÀs


158 
def
 
íabÀRegs
 = (
	`Reg
(
	`UI¡
(
width
 = 
fú°E«bÀ
)) +:

159 
Seq
.
	`fûl
(
fuŒE«bÀs
Ë{ 
	`Reg
(
	`UI¡
(
width
 = 8)) }) ++

160 (i‡(
èûE«bÀ
 > 0Ë
	`Some
(
	`Reg
(
	`UI¡
(
width
 =ÅaûE«bÀ))Ë
N⁄e
)

161 
vÆ
 
íabÀs
 = 
Seq
.
	`fûl
(
nH¨ts
Ë{ 
íabÀRegs
 }

162 
vÆ
 
íabÀVec
 = 
	`Vec
(
íabÀs
.
	`m≠
(
x
 => 
	`C©
(x.
ªvî£
)))

163 
vÆ
 
íabÀVec0
 = 
	`Vec
(
íabÀVec
.
	`m≠
(
x
 => 
	`C©
(x, 
	`UI¡
(0, 
width
=1))))

165 
vÆ
 
maxDevs
 = 
	`Reg
(
	`Vec
(
nH¨ts
, 
	`UI¡
(
width
 = 
	`log2Ceû
(
nDevi˚s
+1))))

166 
vÆ
 
≥ndögUI¡
 = 
	`C©
(
≥ndög
.
ªvî£
)

167 
h¨t
 <- 0 
u¡û
 
nH¨ts
) {

168 
vÆ
 
Ánö
 = 
	`ModuÀ
(
√w
 
	`PLICF™In
(
nDevi˚s
, 
¥ioBôs
))

169 
Ánö
.
io
.
¥io
 :
¥i‹ôy


170 
Ánö
.
io
.
ù
 :
	`íabÀVec
(
h¨t
Ë& 
≥ndögUI¡


171 
	`maxDevs
(
h¨t
Ë:
Ánö
.
io
.
dev


172 
	`h¨ts
(
h¨t
Ë:
	`Shi·Regi°î
(
	`Reg
(
√xt
 = 
Ánö
.
io
.
max
Ë> 
	`thªshﬁd
(h¨t), 
∑øms
.
ötSèges
)

175 
def
 
	`¥i‹ôyRegDesc
(
i
: 
I¡
) =

176 
	`RegFõldDesc
(

177 
«me
 = 
s
"priority_$i",

178 
desc
 = 
s
"ActingÖriority of interrupt source $i",

179 
group
 = 
	`Some
("priority"),

180 
groupDesc
 = 
	`Some
("ActingÖriorities ofÉach interrupt source."),

181 
ª£t
 = i‡(
nPri‹ôõs
 > 0Ë
N⁄e
 
	`Some
(1))

183 
def
 
	`≥ndögRegDesc
(
i
: 
I¡
) =

184 
	`RegFõldDesc
(

185 
«me
 = 
s
"pending_$i",

186 
desc
 = 
s
"SetÅo 1 if interrupt source $i isÖending,Ñegardless of itsÉnable orÖriority setting.",

187 
group
 = 
	`Some
("pending"),

188 
groupDesc
 = 
	`Some
("Pending Bit Array. 1 Bit forÉach interrupt source."),

189 vﬁ©ûê
åue
)

191 
def
 
	`íabÀRegDesc
(
i
: 
I¡
, 
j
: I¡, 
wide
: Int) = {

192 
vÆ
 
low
 = i‡(
j
 == 0) 1 j*8

193 
vÆ
 
high
 = 
low
 + 
wide
 - 1

194 
	`RegFõldDesc
(

195 
«me
 = 
s
"enables_${j}",

196 
desc
 = 
s
"Targets ${low}-${high}. Set bitsÅo 1 if interrupt should beÉnabled.",

197 
group
 = 
	`Some
(
s
"enables_${i}"),

198 
groupDesc
 = 
	`Some
(
s
"Enable bits forÉach interrupt source forÅarget $i. 1 bit forÉach interrupt source."))

201 
def
 
	`¥i‹ôyRegFõld
(
x
: 
UI¡
, 
i
: 
I¡
) =

202 i‡(
nPri‹ôõs
 > 0) {

203 
	`RegFõld
(
¥ioBôs
, 
x
, 
	`¥i‹ôyRegDesc
(
i
))

205 
RegFõld
.
	`r
(
¥ioBôs
, 
x
, 
	`¥i‹ôyRegDesc
(
i
))

208 
vÆ
 
¥i‹ôyRegFõlds
 = 
¥i‹ôy
.
zùWôhIndex
.
m≠
 { (
p
, 
i
) =>

209 
PLICC⁄°s
.
¥i‹ôyBa£
+4*(
i
+1Ë-> 
	`Seq
(
	`¥i‹ôyRegFõld
(
p
, i+1)) }

210 
vÆ
 
≥ndögRegFõlds
 = 
	`Seq
(
PLICC⁄°s
.
≥ndögBa£
 ->

211 (
	`RegFõld
(1Ë+: 
≥ndög
.
zùWôhIndex
.
m≠
 { (
b
, 
i
Ë=> 
RegFõld
.
	`r
(1, b, 
	`≥ndögRegDesc
(i+1))}))

212 
vÆ
 
íabÀRegFõlds
 = 
íabÀs
.
zùWôhIndex
.
m≠
 { (
e
, 
i
) =>

213 
PLICC⁄°s
.
	`íabÀBa£
(
i
Ë-> (
	`RegFõld
(1Ë+: 
e
.
zùWôhIndex
.
m≠
 { (
x
, 
j
) =>

214 
	`RegFõld
(
x
.
gëWidth
, x, 
	`íabÀRegDesc
(
i
, 
j
, x.getWidth)) }) }

222 
vÆ
 
˛aimî
 = 
	`Wúe
(
	`Vec
(
nH¨ts
, 
	`Boﬁ
()))

223 
	`as£π
((
˛aimî
.
asUI¡
 & (˛aimî.asUI¡ - 
	`UI¡
(1))) === UInt(0))

224 
vÆ
 
˛aimög
 = 
Seq
.
	`èbuœã
(
nH¨ts
){
i
 => 
	`Mux
(
	`˛aimî
(i), 
	`maxDevs
(i), 
	`UI¡
(0))}.
	`ªdu˚Le·
(
_
|_)

225 
vÆ
 
˛aimedDevs
 = 
	`Vec
(
	`UI¡ToOH
(
˛aimög
, 
nDevi˚s
+1).
toBoﬁs
)

227 ((
≥ndög
 
zù
 
g©eways
Ëzù 
˛aimedDevs
.
èû
Ë
f‹óch
 { ((
p
, 
g
), 
c
) =>

228 
g
.
ªady
 :!
p


229 
	`whí
 (
c
 || 
g
.
vÆid
Ë{ 
p
 := !c }

239 
vÆ
 
com∂ëî
 = 
	`Wúe
(
	`Vec
(
nH¨ts
, 
	`Boﬁ
()))

240 
	`as£π
((
com∂ëî
.
asUI¡
 & (com∂ëî.asUI¡ - 
	`UI¡
(1))) === UInt(0))

241 
vÆ
 
com∂ëîDev
 = 
	`Wúe
(
	`UI¡
(
width
 = 
	`log2Up
(
nDevi˚s
 + 1)))

242 
vÆ
 
com∂ëedDevs
 = 
	`Mux
(
com∂ëî
.
	`ªdu˚
(
_
 || _), 
	`UI¡ToOH
(
com∂ëîDev
, 
nDevi˚s
+1), 
	`UI¡
(0))

243 (
g©eways
 
zù
 
com∂ëedDevs
.
toBoﬁs
.
èû
Ë
f‹óch
 { (
g
, 
c
) =>

244 
g
.
com∂ëe
 :
c


247 
def
 
	`thªshﬁdRegDesc
(
i
: 
I¡
) =

248 
	`RegFõldDesc
(

249 
«me
 = 
s
"threshold_$i",

250 
desc
 = 
s
"Interrupt & claimÅhreshold forÅarget $i. Maximum value is ${nPriorities}.",

251 
ª£t
 = i‡(
nPri‹ôõs
 > 0Ë
N⁄e
 
	`Some
(1))

253 
def
 
	`thªshﬁdRegFõld
(
x
: 
UI¡
, 
i
: 
I¡
) =

254 i‡(
nPri‹ôõs
 > 0) {

255 
	`RegFõld
(
¥ioBôs
, 
x
, 
	`thªshﬁdRegDesc
(
i
))

257 
RegFõld
.
	`r
(
¥ioBôs
, 
x
, 
	`thªshﬁdRegDesc
(
i
))

260 
vÆ
 
h¨tRegFõlds
 = 
Seq
.
	`èbuœã
(
nH¨ts
Ë{ 
i
 =>

261 
PLICC⁄°s
.
	`h¨tBa£
(
i
Ë-> 
	`Seq
(

262 
	`thªshﬁdRegFõld
(
	`thªshﬁd
(
i
), i),

263 
	`RegFõld
(32-
¥ioBôs
),

264 
	`RegFõld
(32,

265 
RegRódFn
 { 
vÆid
 =>

266 
	`˛aimî
(
i
Ë:
vÆid


267 (
	`Boﬁ
(
åue
), 
	`maxDevs
(
i
))

269 
RegWrôeFn
 { (
vÆid
, 
d©a
) =>

270 
	`as£π
(
com∂ëîDev
 ==
d©a
.
	`exåa˘
(
	`log2Ceû
(
nDevi˚s
+1)-1, 0),

272 
com∂ëîDev
 :
d©a
.
	`exåa˘
(
	`log2Ceû
(
nDevi˚s
+1)-1, 0)

273 
	`com∂ëî
(
i
Ë:
vÆid
 && 
	`íabÀVec0
(i)(
com∂ëîDev
)

274 
	`Boﬁ
(
åue
)

276 
	`Some
(
	`RegFõldDesc
(
s
"claim_complete_$i",

277 
s
"Claim/CompleteÑegister for Target $i. ReadingÅhisÑegisterÑeturnsÅhe claimed interruptÇumberánd makes itÇoÜongerÖending." +

278 
s
"WritingÅhe interruptÇumber back completesÅhe interrupt.",

279 
ª£t
 = 
N⁄e
,

280 
wrTy≥
 = 
	`Some
(
RegFõldWrTy≥
.
MODIFY
),

281 
rdA˘i⁄
 = 
	`Some
(
RegFõldRdA˘i⁄
.
MODIFY
),

282 vﬁ©ûê
åue
))

287 
node
.
	`ªgm≠
((
¥i‹ôyRegFõlds
 ++ 
≥ndögRegFõlds
 ++ 
íabÀRegFõlds
 ++ 
h¨tRegFõlds
):
_
*)

289 i‡(
nDevi˚s
 >= 2) {

290 
vÆ
 
˛aimed
 = 
	`˛aimî
(0Ë&& 
	`maxDevs
(0) > 0

291 
vÆ
 
com∂ëed
 = 
	`com∂ëî
(0)

292 
	`covî
(
˛aimed
 && 
	`RegE«bÀ
(˛aimed, 
Ál£
.
B
, cœimed || 
com∂ëed
), "TWO_CLAIMS", "two claims withÇo intervening complete")

293 
	`covî
(
com∂ëed
 && 
	`RegE«bÀ
(com∂ëed, 
Ál£
.
B
, 
˛aimed
 || completed), "TWO_COMPLETES", "two completes withÇo intervening claim")

295 
vÆ
 
ï
 = 
	`íabÀs
(0).
asUI¡
 & 
≥ndög
.asUInt

296 
vÆ
 
ï2
 = 
	`RegNext
(
ï
)

297 
vÆ
 
diff
 = 
ï
 & ~
ï2


298 
	`covî
((
diff
 & (diff - 1)) =/= 0, "TWO_INTS_PENDING", "twoÉnabled interrupts becameÖending on same cycle")

300 i‡(
nPri‹ôõs
 > 0)

301 
	`ccovî
(
	`maxDevs
(0Ë> (
	`UI¡
(1Ë<< 
	`¥i‹ôy
(0).
gëWidth
Ë&& maxDevs(0Ë<
	`C©
(UI¡(1), 
	`thªshﬁd
(0)),

305 
def
 
	`ccovî
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

306 
	`covî
(
c⁄d
, 
s
"PLIC_$œbñ", "I¡îru±s;;" + 
desc
)

308 
	}
}

310 
˛ass
 
	$PLICF™In
(
nDevi˚s
: 
I¡
, 
¥ioBôs
: I¡Ë
exãnds
 
ModuÀ
 {

311 
vÆ
 
io
 = 
√w
 
BundÀ
 {

312 
vÆ
 
¥io
 = 
	`Vec
(
nDevi˚s
, 
	`UI¡
(
width
 = 
¥ioBôs
)).
Êù


313 
vÆ
 
ù
 = 
	`UI¡
(
width
 = 
nDevi˚s
).
Êù


314 
vÆ
 
dev
 = 
	`UI¡
(
width
 = 
	`log2Ceû
(
nDevi˚s
+1))

315 
vÆ
 
max
 = 
	`UI¡
(
width
 = 
¥ioBôs
)

318 
def
 
	`födMax
(
x
: 
Seq
[
UI¡
]): (UInt, UInt) = {

319 i‡(
x
.
Àngth
 > 1) {

320 
vÆ
 
hÆf
 = 1 << (
	`log2Ceû
(
x
.
Àngth
) - 1)

321 
vÆ
 
À·
 = 
	`födMax
(
x
 
èke
 
hÆf
)

322 
vÆ
 
right
 = 
	`födMax
(
x
 
dr›
 
hÆf
)

323 
	`MuxT
(
À·
.
_1
 >
right
._1,Üe·, (right._1, 
	`UI¡
(
hÆf
Ë|Ñight.
_2
))

324 } (
x
.
hód
, 
	`UI¡
(0))

327 
vÆ
 
ef„˘ivePri‹ôy
 = (
	`UI¡
(1Ë<< 
¥ioBôs
Ë+: (
io
.
ù
.
toBoﬁs
 
zù
 io.
¥io
).
m≠
 { (
p
, 
x
Ë=> 
	`C©
(p, x) }

328 
	`vÆ
 (
maxPri
, 
maxDev
Ë
	`födMax
(
ef„˘ivePri‹ôy
)

329 
io
.
max
 :
maxPri


330 
io
.
dev
 :
maxDev


331 
	}
}

334 
åaô
 
C™HavePîùhîyPLIC
 { 
this
: 
Ba£Subsy°em
 =>

335 
vÆ
 
∂icO±
 = 
p
(
PLICKey
).
m≠
 { 
∑øms
 =>

336 
vÆ
 
∂ic
 = 
LazyModuÀ
(
√w
 
TLPLIC
(
∑øms
, 
sbus
.
c⁄åﬁ_bus
.
bótByãs
))

337 
	gsbus
.
	gc⁄åﬁ_bus
.
toV¨übÀWidthSœve
(
Some
("∂ic")Ë{ 
	g∂ic
.
	gnode
 }

338 
	g∂ic
.
	göäode
 :=* 
ibus
.
toPLIC


339 
∂ic


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/TestRAM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
˛ass
 
	$TLTe°RAM
(
addªss
: 
AddªssSë
, 
execuèbÀ
: 
Boﬁón
 = 
åue
, 
bótByãs
: 
I¡
 = 4, 
åackC‹ru±i⁄
: Boﬁó¿åue)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
devi˚
 = 
√w
 
Mem‹yDevi˚


16 
vÆ
 
node
 = 
	`TLM™agîNode
(
	`Seq
(
	`TLM™agîP‹tP¨amëîs
(

17 
	`Seq
(
	`TLM™agîP¨amëîs
(

18 
addªss
 = 
	`Li°
(address),

19 
ªsour˚s
 = 
devi˚
.
ªg
,

20 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

21 
execuèbÀ
 =Éxecutable,

22 
suµ‹tsGë
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

23 
suµ‹tsPutP¨tül
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

24 
suµ‹tsPutFuŒ
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

25 
fifoId
 = 
	`Some
(0))),

26 
bótByãs
 = beatBytes)))

29 
	`ªquúe
 ((
addªss
.
mask
 & (
bótByãs
-1)) == beatBytes-1)

31 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

32 
def
 
	`bigBôs
(
x
: 
BigI¡
, 
èû
: 
Li°
[
Boﬁón
] = Li°.
em±y
[Boolean]): List[Boolean] =

33 i‡(
x
 =0Ë
èû
.
ªvî£
 
	`bigBôs
(x >> 1, ((x & 1) == 1) ::Åail)

34 
vÆ
 
mask
 = 
	`bigBôs
(
addªss
.mask >> 
	`log2Ceû
(
bótByãs
))

36 
	`vÆ
 (
ö
, 
edge
Ë
node
.
	`ö
(0)

38 
vÆ
 
addrBôs
 = (
mask
 
zù
 
edge
.
	`addr_hi
(
ö
.
a
.
bôs
).
toBoﬁs
).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
)

39 
vÆ
 
memAddªss
 = 
	`C©
(
addrBôs
.
ªvî£
)

40 
vÆ
 
mem
 = 
	`Mem
(1 << 
addrBôs
.
size
, 
	`Vec
(
bótByãs
, 
	`Bôs
(
width
 = 8)))

41 
vÆ
 
bad
 = 
	`Mem
(1 << 
addrBôs
.
size
, 
	`Boﬁ
())

44 
ö
.
a
.
ªady
 :ö.
d
.ready

45 
ö
.
d
.
vÆid
 :ö.
a
.valid

47 
vÆ
 
hasD©a
 = 
edge
.
	`hasD©a
(
ö
.
a
.
bôs
)

48 
vÆ
 
wd©a
 = 
Vec
.
	`èbuœã
(
bótByãs
Ë{ 
i
 => 
ö
.
a
.
bôs
.
	`d©a
(8*(i+1)-1, 8*i) }

50 
ö
.
d
.
bôs
 :
edge
.
	`Ac˚ssAck
(ö.
a
.bits)

51 
ö
.
d
.
bôs
.
d©a
 :
	`C©
(
	`mem
(
memAddªss
).
ªvî£
)

52 
ö
.
d
.
bôs
.
c‹ru±
 :!
hasD©a
 && 
	`bad
(
memAddªss
Ë&& 
	`Boﬁ
(
åackC‹ru±i⁄
)

53 
ö
.
d
.
bôs
.
›code
 :
	`Mux
(
hasD©a
, 
TLMesßges
.
Ac˚ssAck
, TLMesßges.
Ac˚ssAckD©a
)

54 
	`whí
 (
ö
.
a
.
	`fúe
(Ë&& 
hasD©a
) {

55 
mem
.
	`wrôe
(
memAddªss
, 
wd©a
, 
ö
.
a
.
bôs
.
mask
.
toBoﬁs
)

56 
bad
.
	`wrôe
(
memAddªss
, 
ö
.
a
.
bôs
.
c‹ru±
)

60 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

61 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

62 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

64 
	}
}

67 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


69 
˛ass
 
	$TLRAMZîoDñay
(
ømBótByãs
: 
I¡
, 
txns
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

70 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

71 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("ZeroDelay"))

72 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLTe°RAM
(
	`AddªssSë
(0x0, 0x3ff), 
bótByãs
 = 
ømBótByãs
))

74 
øm
.
node
 :
	`TLDñayî
(0.25Ë:
modñ
.nodê:
fuzz
.node

76 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

77 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

79 
	}
}

81 
˛ass
 
	$TLRAMZîoDñayTe°
(
ømBótByãs
: 
I¡
, 
txns
: I¡ = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

82 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMZîoDñay
(
ømBótByãs
, 
txns
)).
moduÀ
)

83 
io
.
föished
 :
dut
.io.finished

84 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Zero.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
TLMesßges


13 
˛ass
 
	$TLZîo
(
addªss
: 
AddªssSë
, 
bótByãs
: 
I¡
 = 4)(
im∂icô
 
p
: 
P¨amëîs
)

14 
exãnds
 
	`DevNuŒDevi˚
(

15 
∑øms
 = 
	`DevNuŒP¨ams
(

16 
addªss
 = 
	`Li°
(address),

17 
maxAtomic
 = 
bótByãs
,

18 
maxTøns„r
 = 
bótByãs
,

19 
ªgi⁄
 = 
Regi⁄Ty≥
.
UNCACHED
,

20 
execuèbÀ
 = 
åue
,

21 
mayDíyGë
 = 
Ál£
,

22 
mayDíyPut
 = 
Ál£
),

23 
bótByãs
 = beatBytes,

24 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("rom", 
	`Seq
("ucbbar,cacheable-zero0"))) {

25 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

26 
	`vÆ
 (
ö
, 
edge
Ë
node
.
	`ö
(0)

28 
vÆ
 
a
 = 
	`Queue
(
ö
.a, 2)

30 
a
.
ªady
 :
ö
.
d
.ready

31 
ö
.
d
.
vÆid
 :
a
.valid

32 
ö
.
d
.
bôs
 :
edge
.
	`Ac˚ssAck
(
a
.bits)

33 
ö
.
d
.
bôs
.
›code
 :
TLMesßges
.
	`adRe•⁄£
(
edge
.
	`›code
(
a
.bits))

36 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

37 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

38 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

40 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressDecoder.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
log2Ceû


6 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmax
,
	gmö
}

8 
obje˘
 
	gAddªssDecodî


10 
ty≥
 
	gP‹t
 = 
Seq
[
AddªssSë
]

11 
ty≥
 
P‹ts
 = 
Seq
[
P‹t
]

12 
ty≥
 
P¨tôi⁄
 = 
P‹ts


13 
ty≥
 
P¨tôi⁄s
 = 
Seq
[
P¨tôi⁄
]

15 
vÆ
 
addªssOrdî
 = 
Ordîög
.
‹dîed
[
AddªssSë
]

16 
vÆ
 
p‹tOrdî
 = 
Ordîög
.
IãøbÀ
(
addªssOrdî
)

17 
vÆ
 
∑πôi⁄Ordî
 = 
Ordîög
.
IãøbÀ
(
p‹tOrdî
)

22 
def
 
≠∂y
(
p‹ts
: 
P‹ts
, 
givíBôs
: 
BigI¡
 = BigInt(0)): BigInt = {

23 
vÆ
 
n⁄Em±yP‹ts
 = 
p‹ts
.
fûãr
(
_
.
n⁄Em±y
)

24 i‡(
n⁄Em±yP‹ts
.
size
 <= 1) {

25 
givíBôs


28 
n⁄Em±yP‹ts
.
combö©i⁄s
(2).
f‹óch
 { 
Seq
(
x
, 
y
) =>

29 
x
.
f‹óch
 { 
a
 => 
y
.f‹óch { 
b
 =>

30 
ªquúe
 (!
a
.
ovîœps
(
b
), 
s
"Ports cannot overlap: $a $b")

34 
vÆ
 
	gmaxBôs
 = 
log2Ceû
(1 + 
n⁄Em±yP‹ts
.
m≠
(
_
.m≠(_.
ba£
).
max
).max)

35 
vÆ
 (
bôsToTry
, 
bôsToTake
Ë(0 
u¡û
 
maxBôs
).
m≠
(
BigI¡
(1Ë<< 
_
).
∑πôi⁄
(
b
 => (
givíBôs
 & b) == 0)

36 
vÆ
 
∑πôi⁄s
 = 
Seq
(
n⁄Em±yP‹ts
.
m≠
(
_
.
s‹ãd
).s‹ãd(
p‹tOrdî
))

37 
vÆ
 
givíP¨tôi⁄s
 = 
bôsToTake
.
fﬁdLe·
(
∑πôi⁄s
Ë{ (
p
, 
b
Ë=> 
∑πôi⁄P¨tôi⁄s
(p, b) }

38 
vÆ
 
	g£À˘ed
 = 
ªcur£
(
givíP¨tôi⁄s
, 
bôsToTry
.
ªvî£
.
toSeq
)

39 
vÆ
 
	gouçut
 = 
£À˘ed
.
ªdu˚Le·
(
_
 | _Ë| 
givíBôs


42 
vÆ
 
wideP‹ts
 = 
n⁄Em±yP‹ts
.
m≠
 { 
_
.m≠ { _.
widí
(~
ouçut
) } }

44 
wideP‹ts
.
combö©i⁄s
(2).
f‹óch
 { 
Seq
(
x
, 
y
) =>

45 
x
.
f‹óch
 { 
a
 => 
y
.f‹óch { 
b
 =>

46 
ªquúe
 (!
a
.
ovîœps
(
b
), 
s
"Ports cannot overlap: $a $b")

50 
	gouçut


55 
def
 
≠∂y
(
keys
: 
Seq
[
I¡
]): Int = {

56 
vÆ
 
p‹ts
 = 
keys
.
m≠
(
b
 => 
Seq
(
AddªssSë
(b, 0)))

57 
≠∂y
(
p‹ts
).
	gtoI¡


71 
def
 
bôSc‹e
(
∑πôi⁄s
: 
P¨tôi⁄s
): 
Seq
[
I¡
] = {

72 
vÆ
 
maxP‹tsPîP¨tôi⁄
 = 
∑πôi⁄s
.
m≠
(
_
.
size
).
max


73 
vÆ
 
maxSësPîP¨tôi⁄
 = 
∑πôi⁄s
.
m≠
(
_
.m≠(_.
size
).
sum
).
max


74 
vÆ
 
sumSqu¨eP‹tsPîP¨tôi⁄
 = 
∑πôi⁄s
.
m≠
(
p
 =>Ö.
size
 *Ö.size).
sum


75 
vÆ
 
sumSqu¨eSësPîP¨tôi⁄
 = 
∑πôi⁄s
.
m≠
(
_
.m≠(
p
 =>Ö.
size
 *Ö.size).
sum
).
max


76 
Seq
(
maxP‹tsPîP¨tôi⁄
, 
maxSësPîP¨tôi⁄
, 
sumSqu¨eP‹tsPîP¨tôi⁄
, 
sumSqu¨eSësPîP¨tôi⁄
)

79 
def
 
∑πôi⁄P‹t
(
p‹t
: 
P‹t
, 
bô
: 
BigI¡
): (P‹t, 
	gP‹t
) = {

80 
vÆ
 
addr_a
 = 
AddªssSë
(0, ~
bô
)

81 
vÆ
 
	gaddr_b
 = 
AddªssSë
(
bô
, ~bit)

83 
vÆ
 
	gsub£t_a
 = 
p‹t
.
fûãr
(
_
.
ovîœps
(
addr_a
))

84 
vÆ
 
sub£t_b
 = 
p‹t
.
fûãr
(
_
.
ovîœps
(
addr_b
))

85 (
sub£t_a
, 
	gsub£t_b
)

88 
def
 
∑πôi⁄P‹ts
(
p‹ts
: 
P‹ts
, 
bô
: 
BigI¡
): (P‹ts, 
	gP‹ts
) = {

89 
vÆ
 
∑πôi⁄ed_p‹ts
 = 
p‹ts
.
m≠
(
p
 => 
∑πôi⁄P‹t
’, 
bô
))

91 
vÆ
 
	gˇ£_a_p‹ts
 = 
∑πôi⁄ed_p‹ts
.
m≠
(
_
.
_1
).
fûãr
(!_.
isEm±y
).
s‹ãd
(
p‹tOrdî
)

92 
vÆ
 
ˇ£_b_p‹ts
 = 
∑πôi⁄ed_p‹ts
.
m≠
(
_
.
_2
).
fûãr
(!_.
isEm±y
).
s‹ãd
(
p‹tOrdî
)

93 (
ˇ£_a_p‹ts
, 
	gˇ£_b_p‹ts
)

96 
def
 
∑πôi⁄P¨tôi⁄s
(
∑πôi⁄s
: 
P¨tôi⁄s
, 
bô
: 
BigI¡
): Partitions = {

97 
vÆ
 
∑πôi⁄ed_∑πôi⁄s
 = 
∑πôi⁄s
.
m≠
(
p
 => 
∑πôi⁄P‹ts
’, 
bô
))

98 
vÆ
 
	gˇ£_a_∑πôi⁄s
 = 
∑πôi⁄ed_∑πôi⁄s
.
m≠
(
_
.
_1
).
fûãr
(!_.
isEm±y
)

99 
vÆ
 
ˇ£_b_∑πôi⁄s
 = 
∑πôi⁄ed_∑πôi⁄s
.
m≠
(
_
.
_2
).
fûãr
(!_.
isEm±y
)

100 
vÆ
 
√w_∑πôi⁄s
 = (
ˇ£_a_∑πôi⁄s
 ++ 
ˇ£_b_∑πôi⁄s
).
s‹ãd
(
∑πôi⁄Ordî
)

104 
vÆ
 
kìp
 = (
√w_∑πôi⁄s
.
öô
 
zù
Çew_∑πôi⁄s.
èû
Ë
fûãr
 { (
a
,
b
Ë=> 
∑πôi⁄Ordî
.
com∑ª
◊,bË!0 } 
	gm≠
 { 
	g_
.
	g_2
 }

105 
	g√w_∑πôi⁄s
.
	ghód
 +: 
kìp


109 
vÆ
 
debug
 = 
Ál£


110 
def
 
ªcur£
(
∑πôi⁄s
: 
P¨tôi⁄s
, 
bôs
: 
Seq
[
BigI¡
]): Seq[BigInt] = {

111 i‡(
∑πôi⁄s
.
m≠
(
_
.
size
 <1).
ªdu˚
(_ && _)Ë
Seq
() {

112 i‡(
debug
) {

113 
¥öén
("Partitioning:")

114 
∑πôi⁄s
.
f‹óch
 { 
∑πôi⁄
 =>

115 
¥öén
(" Partition:")

116 
∑πôi⁄
.
f‹óch
 { 
p‹t
 =>

117 
¥öt
(" ")

118 
p‹t
.
f‹óch
 { 
a
 => 
¥öt
(
s
" ${a}") }

119 
¥öén
("")

123 
vÆ
 
ˇndid©es
 = 
bôs
.
m≠
 { 
bô
 =>

124 
vÆ
 
ªsu…
 = 
∑πôi⁄P¨tôi⁄s
(
∑πôi⁄s
, 
bô
)

125 
vÆ
 
	gsc‹e
 = 
bôSc‹e
(
ªsu…
)

126 i‡(
debug
)

127 
¥öén
(" F‹ bô %x, %s".
f‹m©
(
bô
, 
sc‹e
.
toSåög
))

128 (
	gsc‹e
, 
	gbô
, 
	gªsu…
)

130 
vÆ
 (
be°Sc‹e
, 
be°Bô
, 
be°P¨tôi⁄s
Ë
ˇndid©es
.
mö
(
Ordîög
.
by
[(
Seq
[
I¡
], 
BigI¡
, 
P¨tôi⁄s
), 
IãøbÀ
[I¡]](
_
.
_1
.
toIãøbÀ
))

131 i‡(
	gdebug
Ë
¥öén
("=> Sñe˘ed bô 0x%x".
f‹m©
(
be°Bô
))

132 
	gbe°Bô
 +: 
ªcur£
(
be°P¨tôi⁄s
, 
bôs
.
fûãr
(
_
 !
be°Bô
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressRange.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
_


8 
˛ass
 
	$AddªssR™ge
(
ba£
: 
BigI¡
, 
size
: BigI¡Ë
exãnds
 
Ordîed
[
AddªssR™ge
]

10 
vÆ
 
íd
 = 
ba£
 + 
size


12 
	`ªquúe
 (
ba£
 >0, 
s
"AddressRange base must beÖositive, got: $base")

13 
	`ªquúe
 (
size
 > 0, 
s
"AddressRange size must be > 0, got: $size")

15 
def
 
	`com∑ª
(
x
: 
AddªssR™ge
) = {

16 
vÆ
 
¥im¨y
 = (
this
.
ba£
 - 
x
.ba£).
signum


17 
vÆ
 
£c⁄d¨y
 = (
x
.
size
 - 
this
.size).
signum


18 i‡(
¥im¨y
 !0Ë¥im¨y 
£c⁄d¨y


21 
def
 
	`c⁄èös
(
x
: 
AddªssR™ge
Ë
ba£
 <x.ba£ && x.
íd
 <=Énd

22 
def
 (
x
: 
AddªssR™ge
): 
O±i⁄
[AddressRange] = {

23 i‡(
ba£
 > 
x
.
íd
 || x.base >Énd) {

24 
N⁄e


26 
vÆ
 
oba£
 = i‡(
ba£
 < 
x
.base) base x.base

27 
vÆ
 
€nd
 = i‡(
íd
 > 
x
.end)Énd x.end

28 
	`Some
(
	`AddªssR™ge
(
oba£
, 
€nd
-obase))

32 
¥iv©e
 
def
 
	`hñ≥r
(
ba£
: 
BigI¡
, 
íd
: BigInt) =

33 i‡(
ba£
 < 
íd
Ë
	`Seq
(
	`AddªssR™ge
(ba£,Énd-ba£)Ë
Nû


34 
def
 
	`subåa˘
(
x
: 
AddªssR™ge
) =

35 
	`hñ≥r
(
ba£
, 
íd
 
mö
 
x
.ba£Ë++ hñ≥r(ba£ 
max
 x.end,Énd)

38 
ovîride
 
def
 
	`toSåög
(Ë"AddªssR™ge(0x%x, 0x%x)".
	`f‹m©
(
ba£
, 
size
)

41 
def
 
toUVM
: 
Såög
 = 
f
" set_addr_range(1, 32'h${base}%08x, 32'h${end}%08x);"

42 
def
 
toJSON
: 
Såög
 = 
s
"""{"
ba£
": ${ba£}, "
max
": ${end}}"""

43 
	}
}

45 
obje˘
 
AddªssR™ge


47 
def
 
‰omSës
(
£q
: 
Seq
[
AddªssSë
]): Seq[
AddªssR™ge
] = 
unify
(£q.
Ê©M≠
(
_
.
toR™ges
))

48 
def
 
unify
(
£q
: 
Seq
[
AddªssR™ge
]): Seq[AddressRange] = {

49 i‡(
£q
.
isEm±y
Ë 
Nû


50 
vÆ
 
ønges
 = 
£q
.
s‹ãd


51 
ønges
.
èû
.
fﬁdLe·
(
Seq
‘™ges.
hód
)Ë{ (hód ::Åaû, 
x
) =>

52 
hód
.(
x
Ë
m©ch
 {

53 
Some
(
z
Ë=> z :: 
èû


54 
N⁄e
 => 
x
 :: 
hód
 :: 
èû


56 }.
ªvî£


59 
def
 
subåa˘
(
‰om
: 
Seq
[
AddªssR™ge
], 
èke
: Seq[AddressRange]): Seq[AddressRange] =

60 
èke
.
fﬁdLe·
(
‰om
Ë{ (
À·
, 
r
Ë=>Üe·.
Ê©M≠
 { 
_
.
subåa˘
(r) } }

63 
˛ass
 
	$AddªssM≠E¡ry
(
ønge
: 
AddªssR™ge
, 
≥rmissi⁄s
: 
Resour˚Pîmissi⁄s
, 
«mes
: 
Seq
[
Såög
]) {

64 
vÆ
 
	`Resour˚Pîmissi⁄s
(
r
, 
w
, 
x
, 
c
, 
a
Ë
≥rmissi⁄s


66 
def
 
	`toSåög
(
aw
: 
I¡
Ë
s
"\t%${aw}x - %${aw}x %c%c%c%c%¯%s".
	`f‹m©
(

67 
ønge
.
ba£
,

68 
ønge
.
ba£
+ønge.
size
,

69 i‡(
a
) 'A' ' ',

70 i‡(
r
) 'R' ' ',

71 i‡(
w
) 'W' ' ',

72 i‡(
x
) 'X' ' ',

73 i‡(
c
) 'C' ' ',

74 
«mes
.
	`mkSåög
(", "))

76 
def
 
toJSON
 = 
s
"""{"
ba£
":[${ønge.ba£}],"
size
":[${range.size}],""" +

77 
s
""""
r
":[$r],"
w
":[$w],"
x
":[$x],"
c
":[$c],"
a
":[$a],""" +

78 
s
""""
«mes
":[${names.map('"'+_+'"').mkString(",")}]}"""

79 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/BundleBridge.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
IO


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gP¨amëîs
,
	gFõld
}

10 
˛ass
 
	gBundÀBridgeP¨ams
[
T
 <: 
D©a
](
gí
: () => T)

11 
˛ass
 
	$BundÀBridgeNuŒ
()

13 
˛ass
 
BundÀBridgeImp
[
T
 <: 
D©a
](Ë
exãnds
 
Sim∂eNodeImp
[
BundÀBridgeP¨ams
[T], 
BundÀBridgeNuŒ
, BundleBridgeParams[T], T]

15 
def
 
	`edge
(
pd
: 
BundÀBridgeP¨ams
[
T
], 
pu
: 
BundÀBridgeNuŒ
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
) =Öd

16 
def
 
	`bundÀ
(
e
: 
BundÀBridgeP¨ams
[
T
]Ëe.
	`gí
()

17 
def
 
	`ªndî
(
e
: 
BundÀBridgeP¨ams
[
T
]Ë
	`RídîedEdge
(
cﬁour
 = "#cccc00" )

18 
	}
}

20 
˛ass
 
BundÀBridgeSök
[
T
 <: 
D©a
]()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$SökNode
(
√w
 
BundÀBridgeImp
[
T
])(
	`Seq
(
	$BundÀBridgeNuŒ
()))

22 
def
 
bundÀ
: 
T
 = 
	`ö
(0).
_1


24 
def
 
	`makeIO
()(
im∂icô
 
vÆName
: 
VÆName
): 
T
 = {

25 
vÆ
 
io
 = 
	`IO
(
bundÀ
.
˛⁄eTy≥
)

26 
io
.
	`sugge°Name
(
vÆName
.
«me
)

27 
io
 <> 
bundÀ


28 
io


30 
	}
}

32 
˛ass
 
BundÀBridgeSour˚
[
T
 <: 
D©a
](
gí
: (Ë=> T)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$Sour˚Node
(
√w
 
BundÀBridgeImp
[
T
])(
	`Seq
(
	$BundÀBridgeP¨ams
(
gí
)))

34 
def
 
bundÀ
: 
T
 = 
	`out
(0).
_1


36 
def
 
	`makeIO
()(
im∂icô
 
vÆName
: 
VÆName
): 
T
 = {

37 
vÆ
 
io
 = 
	`IO
(
	`Flù≥d
(
bundÀ
.
˛⁄eTy≥
))

38 
io
.
	`sugge°Name
(
vÆName
.
«me
)

39 
bundÀ
 <> 
io


40 
io


43 
¥iv©e
 
v¨
 
d⁄eSök
 = 
Ál£


44 
def
 
	`makeSök
()(
im∂icô
 
p
: 
P¨amëîs
) = {

45 
	`ªquúe
 (!
d⁄eSök
, "Can only call makeSink() once")

46 
d⁄eSök
 = 
åue


47 
vÆ
 
sök
 = 
BundÀBridgeSök
[
T
]()

48 
sök
 :
this


49 
sök


51 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ClockDomain.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
åaô
 
HasClockDomaöCrossög
 
exãnds
 
	gLazySc›e
 { 
	gthis
: 
LazyModuÀ
 => }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Clone.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gshim
.
Cl⁄eModuÀ


8 
föÆ
 cœs†
	cCl⁄eLazyModuÀ
 
	$¥iv©e
 (
vÆ
 
ba£
: 
LazyModuÀ
)

12 
def
 
˛⁄e
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: D©a](
node
: 
NodeH™dÀ
[DI, UI, EI, BI, DO, UO, EO, BO])(
im∂icô
 
vÆName
: 
VÆName
) =

13 
√w
 
	$MixedTe°Node
(
node
, 
this
)

15 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
io
 = 
	`Cl⁄eModuÀ
(
ba£
.
moduÀ
)

18 
obje˘
 
Cl⁄eLazyModuÀ


20 
def
 
	`≠∂y
(
ba£
: 
LazyModuÀ
Ë
√w
 
	`Cl⁄eLazyModuÀ
(base)

21 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/CloneModule.scala

6 
∑ckage
 
	gchi£l3
.
shim


8 
imp‹t
 
	gChi£l
.
_


9 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.{
	gRawModuÀ
, 
	gMu…iIOModuÀ
, 
	gBa£ModuÀ
}

10 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
Buûdî


11 
imp‹t
 
	gchi£l3
.
	gc‹e
.
U£rModuÀ


12 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gfúπl
.{
	gComm™d
, 
	gDefIn°™˚
}

13 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gimmuèbÀ
.
Li°M≠


14 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
AºayBuf„r


16 
˛ass
 
Cl⁄eP‹ts
 
	g¥Ÿe˘ed
[
shim
](
	gñts
: 
D©a
*Ë
exãnds
 
Rec‹d


18 
vÆ
 
ñemíts
 = 
Li°M≠
(
ñts
.
m≠
(
d
 => d.
ö°™˚Name
 -> d.
chi£lCl⁄eTy≥
): 
_
*)

19 
def
 
≠∂y
(
fõld
: 
Såög
Ë
ñemíts
(field)

20 
ovîride
 
def
 
˛⁄eTy≥
 = (
√w
 
Cl⁄eP‹ts
(
ñts
: 
_
*)).
asIn°™˚Of
[
this
.
ty≥
]

23 ˛as†
	cCl⁄eModuÀ
 
	$¥iv©e
 (
modñ
: 
RawModuÀ
Ë
exãnds
 
BœckBox


25 
imp‹t
 
Cl⁄eModuÀ
.
_


26 
ovîride
 
def
 
desúedName
 = 
modñ
.
«me


27 
vÆ
 
io
 = 
	`IO
(
√w
 
	`Cl⁄eP‹ts
(
modñ
.
gëP‹ts
.
	$m≠
(
_
.
id
): _*))

30 
obje˘
 
Cl⁄eModuÀ


32 
def
 
	`≠∂y
(
modñ
: 
Ba£ModuÀ
): 
Cl⁄eP‹ts
 = {

34 
vÆ
 
mod
 = 
	`ModuÀ
(
√w
 
	`Cl⁄eModuÀ
(
modñ
.
asIn°™˚Of
[
RawModuÀ
]))

37 
vÆ
 
mëhod
 = 
˛assOf
[
U£rModuÀ
].
	`gëDe˛¨edMëhod
("_commands")

38 
mëhod
.
	`£tAc˚ssibÀ
(
åue
)

39 
vÆ
 
comm™ds
 = 
mëhod
.
	`övoke
(
Buûdî
.
f‹˚dU£rModuÀ
).
asIn°™˚Of
[
AºayBuf„r
[
Comm™d
]]

40 
vÆ
 
vi˘imIdx
 = 
comm™ds
.
œ°IndexWhîe
 {

41 
	`DefIn°™˚
(
_
, 
kûl
, _Ë=> 
mod
 
eq
 kill

42 
_
 => 
Ál£


44 
vÆ
 
vi˘im
 = 
	`comm™ds
(
vi˘imIdx
).
asIn°™˚Of
[
DefIn°™˚
]

45 
vÆ
 
°™dö
 = 
√w
 
	`DefIn°™˚
(
vi˘im
.
sour˚Info
, 
modñ
, vi˘im.
p‹ts
) {

46 
ovîride
 
def
 
«me
 = 
vi˘im
.name

48 
comm™ds
.
	`upd©e
(
vi˘imIdx
, 
°™dö
)

50 
modñ
 
m©ch
 {

51 
_
: 
Mu…iIOModuÀ
 =>

52 
mod
.
	`io
("˛ock"Ë:
ModuÀ
.
˛ock


53 
mod
.
	`io
("ª£t"Ë:
ModuÀ
.
ª£t


54 
_
: 
RawModuÀ
 =>

56 
mod
.
io


58 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/DeviceTree.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
Fõld


6 
imp‹t
 
	gsys
.
	g¥o˚ss
.
_


7 
imp‹t
 
	gjava
.
	gio
.{
	gByãAºayI≈utSåóm
, 
	gByãAºayOuçutSåóm
}

9 
obje˘
 
DTSModñ
 
exãnds
 
	gFõld
[
Såög
]

10 
obje˘
 
DTSCom∑t
 
exãnds
 
	gFõld
[
Seq
[
Såög
]]

11 
obje˘
 
DTSTimeba£
 
exãnds
 
	gFõld
[
BigI¡
](0)

13 
obje˘
 
	gDTS


15 
def
 
≠∂y
(
ªs
: 
Resour˚VÆue
): 
Såög
 = "/dts-v1/;\n\n" + 
hñ≥r
‘es, "", 
deÁu…Cñls
).
mkSåög
("")

17 
¥iv©e
 
vÆ
 
	gnodeSèπCh¨s
 = (('a' 
to
 'z'Ë++ ('A'Åÿ'Z')).
toSë


18 
¥iv©e
 
vÆ
 
nodeCh¨s
 = (('a' 
to
 'z'Ë++ ('A'Åÿ'Z'Ë++ ('0'Åÿ'9'Ë++ 
Seq
(',', '.', '_', '+', '-', '@')).
toSë


19 
def
 
ÀgÆNode
(
x
: 
Såög
): 
Boﬁón
 =

20 
x
 ="/" || (!x.
isEm±y
 && x.
size
 < 32 && 
nodeSèπCh¨s
.
c⁄èös
(x(0)Ë&& x.
f‹Æl
(
nodeCh¨s
.c⁄èös(
_
)))

23 
¥iv©e
 
vÆ
 
¥›Ch¨s
 = (('a' 
to
 'z'Ë++ ('A'Åÿ'Z'Ë++ ('0'Åÿ'9'Ë++ 
Seq
(',', '.', '_', '+', '?', '#', '-')).
toSë


24 
def
 
ÀgÆPr›îty
(
x
: 
Såög
): 
Boﬁón
 =

25 
x
 ="/" || (!x.
isEm±y
 && x.
size
 < 32 && x.
f‹Æl
(
¥›Ch¨s
.
c⁄èös
(
_
)))

28 
¥iv©e
 
vÆ
 
°rCh¨s
 = (('#' 
to
 '['Ë++ (']'Åÿ'~'Ë++ 
Seq
(' ', '!')).
toSë


29 
def
 
ÀgÆSåög
(
x
: 
Såög
): 
Boﬁón
 = x.
f‹Æl
(
°rCh¨s
.
c⁄èös
(
_
))

31 
¥iv©e
 
˛ass
 
Cñls
(

32 
∑ª¡Addªss
: 
I¡
,

33 
∑ª¡Size
: 
I¡
,

34 
£lfAddªss
: 
I¡
,

35 
£lfSize
: 
I¡
)

36 
¥iv©e
 
vÆ
 
deÁu…Cñls
 = 
Cñls
(2, 1, 2, 1)

38 
¥iv©e
 
def
 
fmtCñl
(
x
: 
BigI¡
, 
˚Œs
: 
I¡
): 
Seq
[
Såög
] = {

39 
vÆ
 
˚Œbôs
 = 32

40 
vÆ
 
mask
 = (
BigI¡
(1Ë<< 
˚Œbôs
) - 1

41 (0 
u¡û
 
˚Œs
).
ªvî£
 
m≠
 { 
i
 => "0x%x".
f‹m©
((
x
 >> (i*
˚Œbôs
)Ë& 
mask
) }

44 
¥iv©e
 
def
 
fmtAddªss
(
x
: 
Resour˚Addªss
, 
˚Œs
: 
Cñls
): 
Seq
[
Såög
] = {

45 
vÆ
 
ønges
 = 
AddªssR™ge
.
‰omSës
(
x
.
addªss
)

46 
ønges
.
Ê©M≠
 { 
AddªssR™ge
(
ba£
, 
size
) =>

47 
fmtCñl
(
ba£
, 
˚Œs
.
∑ª¡Addªss
Ë++ fmtCñl(
size
, cñls.
∑ª¡Size
)

51 
¥iv©e
 
def
 
fmtM≠pög
(
x
: 
Resour˚M≠pög
, 
˚Œs
: 
Cñls
): 
Seq
[
Såög
] = {

52 
vÆ
 
ønges
 = 
AddªssR™ge
.
‰omSës
(
x
.
addªss
)

53 
ønges
.
Ê©M≠
 { 
AddªssR™ge
(
ba£
, 
size
) =>

54 
fmtCñl
(
ba£
+
x
.
off£t
, 
˚Œs
.
£lfAddªss
Ë++ fmtCñl(ba£, cñls.
∑ª¡Addªss
Ë++ fmtCñl(
size
, cñls.
£lfSize
)

58 
¥iv©e
 
def
 
fmtSåög
(
x
: 
Resour˚Såög
): 
Seq
[
Såög
] = {

59 
ªquúe
 (
ÀgÆSåög
(
x
.
vÆue
), 
s
"The string '${x.value}' contains charsÖrobably unwise for use iná DTS string")

60 
Seq
("\"" + 
x
.
vÆue
 + "\"")

63 
¥iv©e
 
def
 
fmtM≠
(
x
: 
Resour˚M≠
, 
ödít
: 
Såög
, 
˚Œs
: 
Cñls
): 
Seq
[String] = {

64 
vÆ
 (
nodes
, 
¥›s
Ë
x
.
vÆue
.
∑πôi⁄
(
_
 
m©ch
 {

65 (
_
, 
Seq
(
Resour˚M≠
(_, _))Ë=> 
åue


66 
_
 => 
Ál£


69 
def
 
gëI¡
(
x
: 
Resour˚VÆue
Ëx 
m©ch
 {

70 
Resour˚I¡
(
vÆue
Ë=> 
Some
(vÆue.
toI¡
)

71 
_
 => 
N⁄e


73 
vÆ
 
£lfAddªss
 = 
x
.
vÆue
.
gëOrEl£
("#addªss-˚Œs", 
Nû
).
	ghódO±i⁄
.
Ê©M≠
(
gëI¡
)

74 
vÆ
 
	g£lfSize
 = 
x
.
vÆue
.
gëOrEl£
("#size-˚Œs", 
Nû
).
	ghódO±i⁄
.
Ê©M≠
(
gëI¡
)

76 
vÆ
 
	gmyCñls
 = 
Cñls
(

77 
∑ª¡Addªss
 = 
˚Œs
.
£lfAddªss
,

78 
∑ª¡Size
 = 
˚Œs
.
£lfSize
,

79 
£lfAddªss
 = sñfAddªss.
gëOrEl£
(
deÁu…Cñls
.selfAddress),

80 
£lfSize
 = sñfSizê.
gëOrEl£
(
deÁu…Cñls
.selfSize))

82 
¥›s
.
Ê©M≠
 { (
k
, 
£q
) =>

83 
ªquúe
 (
ÀgÆPr›îty
(
k
), 
s
"The string '${k}' isÇotáÜegal DTSÖropertyÇame")

84 
	g£q
.
hódO±i⁄
 
	gm©ch
 {

85 
	gN⁄e
 => 
Seq
(
ödít
, 
k
, ";\n")

86 
Some
(
Resour˚Såög
(
_
)) => {

87 
£q
.
f‹óch
 { 
r
 =>Ñ 
m©ch
 {

88 
Resour˚Såög
(
_
Ë=> 
Unô


89 
_
 => 
ªquúe
(
Ál£
, 
s
"TheÖroperty '${k}' has values of conflictingÅype: ${seq}")

91 
Seq
(
ödít
, 
k
, " = ", 
£q
.
Ê©M≠
(
z
 => 
hñ≥r
(z, "", 
myCñls
)).
mkSåög
(", "), ";\n")

93 
Some
(
Resour˚Alüs
(
_
)) => {

94 
£q
.
f‹óch
 { 
r
 =>Ñ 
m©ch
 {

95 
Resour˚Alüs
(
_
Ë=> 
Unô


96 
_
 => 
ªquúe
(
Ál£
, 
s
"TheÖroperty '${k}' has values of conflictingÅype: ${seq}")

98 
Seq
(
ödít
, 
k
, " = ", 
£q
.
Ê©M≠
(
z
 => 
hñ≥r
(z, "", 
myCñls
)).
mkSåög
(", "), ";\n")

100 
Some
(
_
) => {

101 
£q
.
f‹óch
 { 
r
 =>Ñ 
m©ch
 {

102 
Resour˚M≠
(
_
, _Ë=> 
ªquúe
(
Ál£
, 
s
"TheÖroperty '${k}' has values of conflictingÅype: ${seq}")

103 
Resour˚Såög
(
_
Ë=> 
ªquúe
(
Ál£
, 
s
"TheÖroperty '${k}' has values of conflictingÅype: ${seq}")

104 
Resour˚Alüs
(
_
Ë=> 
ªquúe
(
Ál£
, 
s
"TheÖroperty '${k}' has values of conflictingÅype: ${seq}")

105 
	g_
 => 
Unô


107 
Seq
(
ödít
, 
k
, " = <", 
£q
.
Ê©M≠
(
z
 => 
hñ≥r
(z, "", 
myCñls
)).
mkSåög
(" "), ">;\n")

110 }.
	gtoLi°
 ++

111 
	gnodes
.
	gÊ©M≠
 { (
	gk
, 
Seq
(
s
: 
Resour˚M≠
)) =>

112 
ªquúe
 (
ÀgÆNode
(
k
), 
s
"The string '${k}' isÇotáÜegal DTSÇodeÇame")

113 
Seq
(
ödít
Ë++ 
	gs
.
	gœbñs
.
m≠
(
_
 + ": ").
fûãr
(_ => !ödít.
isEm±y
) ++

114 
Seq
(
k
, " {\n"Ë++ 
hñ≥r
(
s
, 
ödít
 + "\t", 
myCñls
) ++ Seq(indent, "};\n")

118 
¥iv©e
 
def
 
hñ≥r
(
ªs
: 
Resour˚VÆue
, 
ödít
: 
Såög
, 
˚Œs
: 
Cñls
): 
Seq
[Såög] =Ñe†
m©ch
 {

119 
x
: 
Resour˚Addªss
 => 
fmtAddªss
(x, 
˚Œs
)

120 
	gx
: 
Resour˚M≠pög
 => 
fmtM≠pög
(
x
, 
˚Œs
)

121 
	gx
: 
Resour˚I¡
 => 
Seq
(
x
.
vÆue
.
toSåög
)

122 
x
: 
Resour˚Såög
 => 
fmtSåög
(x)

123 
x
: 
Resour˚Re„ªn˚
 => 
Seq
("&" + x.
vÆue
)

124 
x
: 
Resour˚Alüs
 => 
Seq
("&" + x.
vÆue
)

125 
x
: 
Resour˚M≠
 => 
fmtM≠
(x, 
ödít
, 
˚Œs
)

129 
˛ass
 
	$DTB
(
c⁄ã¡s
: 
Seq
[
Byã
])

130 
obje˘
 
DTB


132 
def
 
	`≠∂y
(
dts
: 
Såög
): 
DTB
 = {

133 
vÆ
 
ö°ªam
 = 
√w
 
	`ByãAºayI≈utSåóm
(
dts
.
	`gëByãs
("UTF-8"))

134 
vÆ
 
out°ªam
 = 
√w
 
ByãAºayOuçutSåóm


135 
vÆ
 
¥oc
 = "dt¯-O dtb" #< 
ö°ªam
 #> 
out°ªam


136 
	`ªquúe
 (
¥oc
.! == 0, "FailedÅoÑun dtc; is it in yourÖath?")

137 
ö°ªam
.
˛o£


138 
out°ªam
.
˛o£


139 
	`DTB
(
out°ªam
.
toByãAºay
)

141 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/FixedClockResource.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
˛ass
 
FixedClockResour˚
(
vÆ
 
«me
: 
Såög
, vÆ 
‰eqMHz
: 
DoubÀ
, vÆ 
¥efix
: String = "soc/")

7 
vÆ
 
devi˚
 = 
√w
 
Devi˚Snù≥t
 {

8 
def
 
des¸ibe
() =

9 
Des¸ùti⁄
(
¥efix
 + 
«me
, 
M≠
(

10 "#˛ock-˚Œs" -> 
Seq
(
Resour˚I¡
(0)),

11 "˛ock-‰equícy" -> 
Seq
(
Resour˚I¡
(
‰eqMHz
 * 1000000)),

12 "˛ock-ouçut-«mes" -> 
Seq
(
Resour˚Såög
(
«me
)),

13 "com∑tibÀ" -> 
Seq
(
Resour˚Såög
("fixed-clock"))))

16 
def
 
böd
(
dev
: 
Devi˚
) {

17 
Resour˚Bödög
 { 
Resour˚
(
dev
, "˛ocks").
böd
(
Resour˚Re„ªn˚
(
devi˚
.
œbñ
)) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/JSON.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gimmuèbÀ
.
S‹ãdM≠


7 
obje˘
 
	gJSON


9 
def
 
≠∂y
(
ªs
: 
Resour˚VÆue
): 
Såög
 = {

10 
vÆ
 
roŸ
 = 
ªs
 
m©ch
 {

11 
Resour˚M≠
(
vÆue
, 
_
Ë=> vÆue.
toLi°
 
m©ch
 {

12 
Seq
(("/", Seq(
subåì
))) => subtree

13 
_
 => 
ªs


15 
	g_
 => 
ªs


17 
hñ≥r
(
roŸ
)(
S‹ãdM≠
(
m≠
‘oŸ):
_
*)).
mkSåög


20 
¥iv©e
 
def
 
m≠
(
ªs
: 
Resour˚VÆue
, 
∑th
: 
Såög
 = ""): 
Seq
[(Såög, Såög)] =Ñe†
m©ch
 {

21 
Resour˚M≠
(
vÆue
, 
œbñs
) => {

22 
œbñs
.
m≠
(
_
 -> 
∑th
) ++

23 
vÆue
.
Ê©M≠
 { (
key
, 
£q
Ë=> seq.Ê©M≠(
m≠
(
_
, 
∑th
 + "/" + key)) }

25 
	g_
 => 
Nû


28 
¥iv©e
 
def
 
hñ≥r
(
ªs
: 
Resour˚VÆue
)(
im∂icô
 
∑th
: 
M≠
[
Såög
, Såög]): 
Seq
[Såög] =Ñe†
m©ch
 {

29 
Resour˚Addªss
(
addªss
, 
Resour˚Pîmissi⁄s
(
r
, 
w
, 
x
, 
c
, 
a
)) =>

30 
AddªssR™ge
.
‰omSës
(
addªss
).
m≠
 { AddªssR™ge(
ba£
, 
size
) =>

31 
s
"""{"
ba£
":${ba£},"
size
":${size},"
r
":${r},"
w
":${w},"
x
":${x},"
c
":${c},"
a
":${a}}"""}

32 
Resour˚M≠pög
(
addªss
, 
off£t
, 
Resour˚Pîmissi⁄s
(
r
, 
w
, 
x
, 
c
, 
a
)) =>

33 
AddªssR™ge
.
‰omSës
(
addªss
).
m≠
 { AddªssR™ge(
ba£
, 
size
) =>

34 
s
"""{"
ba£
":${ba£},"
size
":${size},"
off£t
":${off£t},"
r
":${r},"
w
":${w},"
x
":${x},"
c
":${c},"
a
":${a}}"""}

35 
Resour˚I¡
(
vÆue
Ë=> 
Seq
(vÆue.
toSåög
)

36 
Resour˚Såög
(
vÆue
Ë=> 
Seq
("\"" + value + "\"")

37 
Resour˚Re„ªn˚
(
vÆue
Ë=> 
Seq
("\"&" + 
∑th
(value) + "\"")

38 
Resour˚Alüs
(
vÆue
Ë=> 
Seq
("\"&" + 
∑th
(value) + "\"")

39 
Resour˚M≠
(
vÆue
, 
_
) => {

40 
Seq
(
vÆue
.
m≠
 {

41 (
key
, 
Seq
(
v
: 
Resour˚M≠
)Ë=> 
s
""""
$
{key}":${helper(v).mkString}"""

42 (
key
, 
£q
Ë=> 
s
""""
$
{key}":[${seq.flatMap(helper).mkString(",")}]"""

43 }.
mkSåög
("{", ",", "}"))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/LazyModule.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.{
	gBa£ModuÀ
, 
	gRawModuÀ
, 
	gMu…iIOModuÀ
, 
	gwôhClockAndRe£t
}

7 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.{
	gSour˚Info
, 
	gSour˚Löe
, 
	gU∆oˇèbÀSour˚Info
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gimmuèbÀ
.{
	gS‹ãdM≠
,
	gLi°M≠
}

10 
imp‹t
 
	gsˇœ
.
	gutû
.
	gm©chög
.
_


12 
ab°ø˘
 cœs†
	cLazyModuÀ
()(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
)

14 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
chûdªn
 = 
Li°
[
LazyModuÀ
]()

15 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
nodes
 = 
Li°
[
Ba£Node
]()

16 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
öfo
: 
Sour˚Info
 = 
U∆oˇèbÀSour˚Info


17 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
∑ª¡
 = 
LazyModuÀ
.
sc›e


20 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
öModuÀBody
 = 
Li°
[(Ë=> 
Unô
]()

22 
def
 
∑ª¡s
: 
Seq
[
LazyModuÀ
] = 
∑ª¡
 
m©ch
 {

23 
N⁄e
 => 
Nû


24 
	`Some
(
x
Ë=> x +: x.
∑ª¡s


27 
LazyModuÀ
.
sc›e
 = 
	$Some
(
this
)

28 
∑ª¡
.
	`f‹óch
(
p
 =>Ö.
chûdªn
 = 
this
 ::Ö.children)

31 
¥iv©e
 
v¨
 
sugge°edNameV¨
: 
O±i⁄
[
Såög
] = 
N⁄e


32 
def
 
	$sugge°Name
(
x
: 
Såög
): 
this
.
ty≥
 = 
	`sugge°Name
(
	$Some
(
x
))

33 
def
 
	$sugge°Name
(
x
: 
O±i⁄
[
Såög
]): 
this
.
ty≥
 = {

34 
x
.
f‹óch
 { 
n
 => 
sugge°edNameV¨
 = 
	`Some
(n) }

35 
this


36 
	}
}

38 
¥iv©e
 
def
 
	$födCœssName
(
c
: 
Cœss
[
_
]): 
Såög
 = {

39 
vÆ
 
n
 = 
c
.
gëName
.
	`•lô
('.').
œ°


40 i‡(
n
.
	`c⁄èös
('$')Ë
	`födCœssName
(
c
.
gëSu≥r˛ass
) n

41 
	}
}

43 
œzy
 
vÆ
 
˛assName
 = 
	$födCœssName
(
gëCœss
)

44 
œzy
 
vÆ
 
sugge°edName
 = 
sugge°edNameV¨
.
	$gëOrEl£
(
˛assName
)

45 
œzy
 
vÆ
 
desúedName
 = 
˛assName


47 
def
 
«me
 = 
sugge°edName


48 
def
 
löe
 = 
	$sour˚Löe
(
öfo
)

51 
œzy
 
vÆ
 
moduÀName
 = 
moduÀ
.
«me


52 
œzy
 
vÆ
 
∑thName
 = 
moduÀ
.pathName

53 
œzy
 
vÆ
 
ö°™˚Name
 = 
∑thName
.
	`•lô
('.').
œ°


55 
def
 
moduÀ
: 
LazyModuÀImpLike


57 
def
 
omôGøphML
: 
Boﬁón
 = !
nodes
.
	`exi°s
(!
_
.omôGøphMLË&& !
chûdªn
.exists(!_.omitGraphML)

58 
œzy
 
vÆ
 
gøphML
: 
Såög
 = 
∑ª¡
.
	`m≠
(
_
.gøphML).
gëOrEl£
 {

59 
vÆ
 
buf
 = 
√w
 
SåögBuûdî


60 
buf
 ++= "<?xml version=\"1.0\"Éncoding=\"UTF-8\"?>\n"

61 
buf
 ++= "<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:y=\"http://www.yworks.com/xml/graphml\">\n"

62 
buf
 ++= " <key for=\"node\" id=\"n\" yfiles.type=\"nodegraphics\"/>\n"

63 
buf
 ++= " <key for=\"edge\" id=\"e\" yfiles.type=\"edgegraphics\"/>\n"

64 
buf
 ++= " <key for=\"node\" id=\"d\"áttr.name=\"Description\"áttr.type=\"string\"/>\n"

65 
buf
 ++= " <graph id=\"G\"Édgedefault=\"directed\">\n"

66 
	`nodesGøphML
(
buf
, " ")

67 
	`edgesGøphML
(
buf
, " ")

68 
buf
 ++= " </graph>\n"

69 
buf
 ++= "</graphml>\n"

70 
buf
.
toSåög


71 
	}
}

73 
¥iv©e
 
vÆ
 
	gödex
 = { 
LazyModuÀ
.
ödex
 = LazyModuÀ.ödex + 1; 
	gLazyModuÀ
.index }

75 
¥iv©e
 
def
 
	$nodesGøphML
(
buf
: 
SåögBuûdî
, 
∑d
: 
Såög
) {

76 
buf
 ++
s
"""${pad}<node id=\"${index}\">\n"""

77 
buf
 ++
s
"""${pad} <data key=\"n\"><y:ShapeNode><y:NodeLabel modelName=\"sides\" modelPosition=\"w\"ÑotationAngle=\"270.0\">${instanceName}</y:NodeLabel></y:ShapeNode></data>\n"""

78 
buf
 ++
s
"""${pad} <data key=\"d\">${moduleName} (${pathName})</data>\n"""

79 
buf
 ++
s
"""${pad} <graph id=\"${index}::\"Édgedefault=\"directed\">\n"""

80 
nodes
.
	`fûãr
(!
_
.
omôGøphML
).
f‹óch
 { 
n
 =>

81 
buf
 ++
s
"""${pad} <node id=\"${index}::${n.index}\">\n"""

82 
buf
 ++
s
"""${∑d} <d©®key=\"e\"><y:Sh≠eNode><y:Sh≠êty≥="
EŒù£
"/></y:ShapeNode></data>\n"""

83 
buf
 ++
s
"""${pad} <data key=\"d\">${n.nodedebugstring}</data>\n"""

84 
buf
 ++
s
"""${pad} </node>\n"""

86 
chûdªn
.
	`fûãr
(!
_
.
omôGøphML
).
f‹óch
 { _.
	`nodesGøphML
(
buf
, 
∑d
 + " ") }

87 
buf
 ++
s
"""${pad} </graph>\n"""

88 
buf
 ++
s
"""${pad}</node>\n"""

89 
	}
}

90 
¥iv©e
 
def
 
	$edgesGøphML
(
buf
: 
SåögBuûdî
, 
∑d
: 
Såög
) {

91 
nodes
.
	`fûãr
(!
_
.
omôGøphML
Ë
f‹óch
 { 
n
 =>Ç.
ouçuts
.fûãr(!_.
_1
.omôGøphML).f‹óch { (
o
, 
edge
) =>

92 
vÆ
 
	`RídîedEdge
(
cﬁour
, 
œbñ
, 
Êù≥d
Ë
edge


93 
buf
 ++
∑d


94 
buf
 ++= "<edge"

95 i‡(
Êù≥d
) {

96 
buf
 ++
s
"""Åarget=\"${index}::${n.index}\""""

97 
buf
 ++
s
""" source=\"${o.lazyModule.index}::${o.index}\">"""

99 
buf
 ++
s
""" source=\"${index}::${n.index}\""""

100 
buf
 ++
s
"""Åarget=\"${o.lazyModule.index}::${o.index}\">"""

102 
buf
 ++
s
"""<data key=\"e\"><y:PolyLineEdge>"""

103 i‡(
Êù≥d
) {

104 
buf
 ++
s
"""<y:Arrows source=\"standard\"Åarget=\"none\"/>"""

106 
buf
 ++
s
"""<y:Arrows source=\"none\"Åarget=\"standard\"/>"""

108 
buf
 ++
s
"""<y:LineStyle color=\"${colour}\"Åype=\"line\" width=\"1.0\"/>"""

109 
buf
 ++
s
"""<y:EdgeLabel modelName=\"centered\"ÑotationAngle=\"270.0\">${label}</y:EdgeLabel>"""

110 
buf
 ++
s
"""</y:PolyLineEdge></data></edge>\n"""

112 
chûdªn
.
	`fûãr
(!
_
.
omôGøphML
).
f‹óch
 { 
c
 => c.
	`edgesGøphML
(
buf
, 
∑d
) }

113 
	}
}

115 
def
 
nodeIãøt‹
(
ôîfunc
: (
LazyModuÀ
Ë=> 
Unô
): Unit = {

116 
ôîfunc
(
this
)

117 
chûdªn
.
f‹óch
–
_
.
nodeIãøt‹
(
ôîfunc
) )

120 
def
 
gëChûdªn
 = 
chûdªn


123 
obje˘
 
LazyModuÀ


125 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
sc›e
: 
O±i⁄
[
LazyModuÀ
] = 
N⁄e


126 
¥iv©e
 
v¨
 
ödex
 = 0

128 
def
 
≠∂y
[
T
 <: 
LazyModuÀ
](
bc
: T)(
im∂icô
 
vÆName
: 
VÆName
, 
	gsour˚Info
: 
Sour˚Info
): T = {

132 
ªquúe
 (
sc›e
.
isDeföed
, 
s
"LazyModule()áppliedÅo ${bc.name}Åwice ${sourceLine(sourceInfo)}")

133 
ªquúe
 (
sc›e
.
gë
 
eq
 
bc
, 
s
"LazyModule()áppliedÅo ${bc.name} before ${scope.get.name} ${sourceLine(sourceInfo)}")

134 
sc›e
 = 
bc
.
∑ª¡


135 
bc
.
öfo
 = 
sour˚Info


136 i‡(!
bc
.
sugge°edNameV¨
.
isDeföed
Ëbc.
sugge°Name
(
vÆName
.
«me
)

137 
bc


141 
£Æed
 
åaô
 
LazyModuÀImpLike
 
exãnds
 
	gRawModuÀ


143 
vÆ
 
	gwøµî
: 
LazyModuÀ


144 
vÆ
áuto: 
AutoBundÀ


145 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
d™gÀs
: 
Seq
[
D™gÀ
]

148 
ªquúe
 (!
LazyModuÀ
.
sc›e
.
isDeföed
, 
s
"${wrapper.name}.module was constructed before LazyModule() wasÑun on ${LazyModule.scope.get.name}")

150 
ovîride
 
def
 
	gdesúedName
 = 
wøµî
.
desúedName


151 
sugge°Name
(
wøµî
.
sugge°edName
)

153 
im∂icô
 
vÆ
 
p
 = 
wøµî
.p

155 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
ö°™tüã
() = {

156 
vÆ
 
chûdD™gÀs
 = 
wøµî
.
chûdªn
.
ªvî£
.
Ê©M≠
 { 
c
 =>

157 
im∂icô
 
vÆ
 
sour˚Info
 = 
c
.
öfo


158 
vÆ
 
mod
 = 
ModuÀ
(
c
.
moduÀ
)

159 
mod
.
föishIn°™tüã
()

160 
mod
.
d™gÀs


162 
vÆ
 
	gnodeD™gÀs
 = 
wøµî
.
nodes
.
ªvî£
.
Ê©M≠
(
_
.
ö°™tüã
())

163 
vÆ
 
ÆlD™gÀs
 = 
nodeD™gÀs
 ++ 
chûdD™gÀs


164 
vÆ
 
∑úög
 = 
S‹ãdM≠
(
ÆlD™gÀs
.
groupBy
(
_
.
sour˚
).
toSeq
:_*)

165 
vÆ
 
d⁄e
 = 
Së
(Ë++ 
∑úög
.
vÆues
.
fûãr
(
_
.
size
 =2).
m≠
 { 
Seq
(
a
, 
b
) =>

166 
ªquúe
 (
a
.
Êù≥d
 !
b
.flipped)

167 i‡(
a
.
Êù≥d
Ë{á.
d©a
 <> 
b
.data } { b.data <>á.data }

168 
a
.
sour˚


170 
vÆ
 
	gf‹w¨d
 = 
ÆlD™gÀs
.
fûãr
(
d
 => !
d⁄e
(d.
sour˚
))

171 
vÆ
áutÿ
IO
(
√w
 
AutoBundÀ
(
f‹w¨d
.
m≠
 { 
d
 => (d.
«me
, d.
d©a
, d.
Êù≥d
Ë}:
_
*))

172 
vÆ
 
d™gÀs
 = (
f‹w¨d
 
zù
áuto.
ñemíts
Ë
m≠
 { (
d
, (
_
, 
io
)) =>

173 i‡(
d
.
Êù≥d
Ë{ d.
d©a
 <> 
io
 } { io <> d.data }

174 
d
.
c›y
(
d©a
 = 
io
, 
«me
 = 
wøµî
.
sugge°edName
 + "_" + d.name)

176 
	gwøµî
.
	göModuÀBody
.
	gªvî£
.
	gf‹óch
 { 
_
() }

177 ◊uto, 
	gd™gÀs
)

180 
	g¥Ÿe˘ed
[
dùlomacy
] 
def
 
föishIn°™tüã
() {

181 
	gwøµî
.
	gnodes
.
	gªvî£
.
	gf‹óch
 { 
	g_
.
föishIn°™tüã
() }

185 ˛as†
	cLazyModuÀImp
(
vÆ
 
wøµî
: 
LazyModuÀ
Ë
exãnds
 
Mu…iIOModuÀ
 
wôh
 
LazyModuÀImpLike
 {

186 
	`vÆ
 (auto, 
d™gÀs
Ë
	`ö°™tüã
()

189 ˛as†
	cLazyRawModuÀImp
(
vÆ
 
wøµî
: 
LazyModuÀ
Ë
exãnds
 
RawModuÀ
 
wôh
 
LazyModuÀImpLike
 {

193 
vÆ
 
chûdClock
 = 
	`Wúe
(
	$Clock
())

194 
vÆ
 
chûdRe£t
 = 
	`Wúe
(
	$Boﬁ
())

195 
chûdClock
 :
	`Boﬁ
(
Ál£
).
asClock


196 
chûdRe£t
 :
	$Boﬁ
(
åue
)

197 
	`vÆ
 (auto, 
d™gÀs
Ë
	$wôhClockAndRe£t
(
chûdClock
, 
chûdRe£t
) {

198 
	`ö°™tüã
()

200 
	}
}

202 ˛as†
	cSim∂eLazyModuÀ
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


204 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
)

207 
åaô
 
LazySc›e


209 
this
: 
LazyModuÀ
 =>

210 
ovîride
 
def
 
toSåög
: 
Såög
 = 
s
"LazyScopeÇamed $name"

211 
def
 
≠∂y
[
T
](
body
: => T) = {

212 
vÆ
 
ßved
 = 
LazyModuÀ
.
sc›e


213 
LazyModuÀ
.
sc›e
 = 
	`Some
(
this
)

214 
vÆ
 
out
 = 
body


215 
	`ªquúe
 (
LazyModuÀ
.
sc›e
.
isDeföed
, 
s
"LazyScope ${name}ÅriedÅoÉxit, but scope wasÉmpty!")

216 
	`ªquúe
 (
LazyModuÀ
.
sc›e
.
gë
 
eq
 
this
, 
s
"LazyScope ${name}Éxited before LazyModule ${LazyModule.scope.get.name} was closed")

217 
LazyModuÀ
.
sc›e
 = 
ßved


218 
out


220 
	}
}

222 
obje˘
 
	gLazySc›e


224 
def
 
	g≠∂y
[
T
](
	gbody
: => T)(
im∂icô
 
vÆName
: 
VÆName
, 
	gp
: 
P¨amëîs
): T = {

225 
vÆ
 
sc›e
 = 
LazyModuÀ
(
√w
 
Sim∂eLazyModuÀ
 
wôh
 
LazySc›e
)

226 
sc›e
 { 
body
 }

228 
def
 
≠∂y
[
T
](
«me
: 
Såög
)(
body
: => T)(
im∂icô
 
p
: 
P¨amëîs
): T = {

229 
≠∂y
(
body
)(
VÆName
(
«me
), 
p
)

233 
˛ass
 
	$HÆfEdge
(
£rül
: 
I¡
, 
ödex
: I¡Ë
exãnds
 
Ordîed
[
HÆfEdge
] {

234 
imp‹t
 
sˇœ
.
m©h
.
Ordîed
.
‹dîögToOrdîed


235 
def
 
	`com∑ª
(
th©
: 
HÆfEdge
ËHÆfEdge.
	`u«µly
(
this
Ë
com∑ª
 HalfEdge.unapply(that)

236 
	}
}

237 
˛ass
 
	$D™gÀ
(
sour˚
: 
HÆfEdge
, 
sök
: HÆfEdge, 
Êù≥d
: 
Boﬁón
, 
«me
: 
Såög
, 
d©a
: 
D©a
)

239 
föÆ
 
˛ass
 
	`AutoBundÀ
(
ñts
: (
Såög
, 
D©a
, 
Boﬁón
)*Ë
exãnds
 
Rec‹d
 {

241 
vÆ
 
ñemíts
 = 
	`Li°M≠
(Ë++ 
ñts
.
zùWôhIndex
.
	`m≠
(
makeEÀmíts
).
	`groupBy
(
_
.
_1
).
vÆues
.
Ê©M≠
 {

242 
	`Seq
((
key
, 
ñemít
, 
i
)) => Seq(i -> (key ->Élement))

243 
£q
 => seq.
zùWôhIndex
.
m≠
 { ((
key
, 
ñemít
, 
i
), 
j
) => i -> (key + "_" + j ->Élement) }

244 }.
toLi°
.
	`s‹tBy
(
_
.
_1
).
	`m≠
(_.
_2
)

245 
	`ªquúe
 (
ñemíts
.
size
 =
ñts
.size)

247 
¥iv©e
 
def
 
	`makeEÀmíts
(
tu∂e
: ((
Såög
, 
D©a
, 
Boﬁón
), 
I¡
)) = {

248 
	`vÆ
 ((
key
, 
d©a
, 
Êù
), 
i
Ë
tu∂e


250 
vÆ
 
ªgex
 = 
√w
 
	`Regex
("(_[0-9]+)*$")

251 
vÆ
 
ñemít
 = i‡(
Êù
Ë
d©a
.
˛⁄eTy≥
.flip data.cloneType

252 (
ªgex
.
	`ª∂a˚AŒIn
(
key
, ""), 
ñemít
, 
i
)

255 
ovîride
 
def
 
˛⁄eTy≥
 = (
√w
 
	`AutoBundÀ
(
ñts
:
_
*)).
asIn°™˚Of
[
this
.
ty≥
]

256 
	}
}

258 
åaô
 
ModuÀVÆue
[
T
]

260 
def
 
gëWøµedVÆue
: 
T


263 
obje˘
 
InModuÀBody


265 
def
 
≠∂y
[
T
](
body
: => T): 
ModuÀVÆue
[T] = {

266 
ªquúe
 (
LazyModuÀ
.
sc›e
.
isDeföed
, 
s
"InModuleBody invoked outsideá LazyModule")

267 
vÆ
 
sc›e
 = 
LazyModuÀ
.sc›e.
gë


268 
vÆ
 
out
 = 
√w
 
ModuÀVÆue
[
T
] {

269 
v¨
 
ªsu…
: 
O±i⁄
[
T
] = 
N⁄e


270 
def
 
execuã
(Ë{ 
ªsu…
 = 
Some
(
body
) }

271 
def
 
gëWøµedVÆue
 = {

272 
ªquúe
 (
ªsu…
.
isDeföed
, 
s
"InModuleBody contents wereÑequested before module wasÉvaluated!")

273 
ªsu…
.
gë


276 
	gsc›e
.
	göModuÀBody
 = (
out
.
execuã
 
_
Ë+: 
sc›e
.
öModuÀBody


277 
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Nodes.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gP¨amëîs
,
	gFõld
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
HëîogíeousBag


9 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
Li°Buf„r


10 
imp‹t
 
	gsˇœ
.
	gutû
.
	gm©chög
.
_


12 
obje˘
 
M⁄ô‹sE«bÀd
 
exãnds
 
	gFõld
[
Boﬁón
](
	gåue
)

13 
obje˘
 
RídîFlù≥d
 
exãnds
 
	gFõld
[
Boﬁón
](
	gÁl£
)

15 
˛ass
 
RídîedEdge
(

16 
cﬁour
: 
Såög
,

17 
œbñ
: 
Såög
 = "",

18 
Êù≥d
: 
Boﬁón
 = 
Ál£
)

24 
åaô
 
Inw¨dNodeImp
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
]

26 
def
 
edgeI
(
pd
: 
DI
, 
pu
: 
UI
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
): 
EI


27 
def
 
bundÀI
(
ei
: 
EI
): 
BI


30 
def
 
m⁄ô‹
(
bundÀ
: 
BI
, 
edge
: 
EI
) {}

31 
def
 
ªndî
(
e
: 
EI
): 
RídîedEdge


34 
def
 
mixI
(
pu
: 
UI
, 
node
: 
Inw¨dNode
[
DI
, UI, 
BI
]): UI =Öu

41 
åaô
 
Outw¨dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
 <: 
D©a
]

43 
def
 
edgeO
(
pd
: 
DO
, 
pu
: 
UO
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
): 
EO


44 
def
 
bundÀO
(
eo
: 
EO
): 
BO


47 
def
 
mixO
(
pd
: 
DO
, 
node
: 
Outw¨dNode
[DO, 
UO
, 
BO
]): DO =Öd

48 
def
 
gëI
(
pd
: 
DO
): 
O±i⁄
[
Ba£Node
] = 
N⁄e


51 
ab°ø˘
 
˛ass
 
NodeImp
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
]

52 
exãnds
 
Obje˘
 
wôh
 
Inw¨dNodeImp
[
D
, 
U
, 
EI
, 
B
] wôh 
	gOutw¨dNodeImp
[D, U, 
EO
, B]

55 
ab°ø˘
 
˛ass
 
	gSim∂eNodeImp
[
D
, 
U
, 
E
, 
B
 <: 
D©a
]

56 
exãnds
 
NodeImp
[
D
, 
U
, 
E
, E, 
B
]

58 
def
 
edge
(
pd
: 
D
, 
pu
: 
U
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
): 
E


59 
def
 
edgeO
(
pd
: 
D
, 
pu
: 
U
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
edge
(pd,Öu,Ö, sourceInfo)

60 
def
 
edgeI
(
pd
: 
D
, 
pu
: 
U
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
edge
(pd,Öu,Ö, sourceInfo)

61 
def
 
bundÀ
(
e
: 
E
): 
B


62 
def
 
bundÀO
(
e
: 
E
Ë
bundÀ
(e)

63 
def
 
bundÀI
(
e
: 
E
Ë
bundÀ
(e)

66 
ab°ø˘
 cœs†
	cBa£Node
(
im∂icô
 
vÆ
 
vÆName
: 
VÆName
)

68 
	`ªquúe
 (
LazyModuÀ
.
sc›e
.
isDeföed
, "You cannot createáÇode outsideá LazyModule!")

70 
vÆ
 
œzyModuÀ
 = 
LazyModuÀ
.
sc›e
.
gë


71 
vÆ
 
ödex
 = 
œzyModuÀ
.
nodes
.
size


72 
œzyModuÀ
.
nodes
 = 
this
 ::ÜazyModule.nodes

74 
vÆ
 
£rül
 = 
Ba£Node
.serial

75 
Ba£Node
.
£rül
 = BaseNode.serial + 1

76 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	$ö°™tüã
(): 
Seq
[
D™gÀ
]

77 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	$föishIn°™tüã
(): 
Unô


79 
def
 
«me
 = 
œzyModuÀ
.«mê+ "." + 
vÆName
.name

80 
def
 
omôGøphML
 = 
ouçuts
.
isEm±y
 && 
öputs
.isEmpty

81 
œzy
 
vÆ
 
nodedebug°rög
: 
Såög
 = ""

83 
def
 
∑ª¡s
: 
Seq
[
LazyModuÀ
] = 
œzyModuÀ
 +:ÜazyModule.parents

84 
def
 
des¸ùti⁄
: 
Såög
 = ""

85 
def
 
loˇti⁄
: 
Såög
 = 
s
"(A $des¸ùti⁄ÇodêwôhÖ¨íà${œzyModuÀ.«me}" + 
∑ª¡s
.
èû
.
hódO±i⁄
.
	`m≠
(" insidê" + 
_
.
«me
).
	`gëOrEl£
("") + ")"

87 
def
 
wúePªfix
 = {

88 
vÆ
 
ˇmñCa£
 = "([a-z])([A-Z])".
r


89 
vÆ
 
deˇmñ
 = 
ˇmñCa£
.
	`ª∂a˚AŒIn
(
vÆName
.
«me
, 
_
 
m©ch
 { 
	`ˇmñCa£
(
l
, 
h
) =>Ü + "_" + h })

90 
vÆ
 
åimNode
 = "_?node$".
r


91 
vÆ
 
«me
 = 
åimNode
.
	`ª∂a˚Fú°In
(
deˇmñ
.
toLowîCa£
, "")

92 i‡(
«me
.
isEm±y
) "" name + "_"

95 
def
 
öputs
: 
Seq
[(
Ba£Node
, 
RídîedEdge
)]

96 
def
 
ouçuts
: 
Seq
[(
Ba£Node
, 
RídîedEdge
)]

98 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
sökC¨d
: 
I¡


99 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
sour˚C¨d
: 
I¡


100 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
Êexes
: 
Seq
[
Ba£Node
]

101 
	}
}

103 
obje˘
 
Ba£Node


105 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
£rül
 = 0

108 
åaô
 
NoH™dÀ


109 
obje˘
 
NoH™dÀObje˘
 
exãnds
 
NoH™dÀ


111 
åaô
 
NodeH™dÀ
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data]

112 
exãnds
 
Inw¨dNodeH™dÀ
[
DI
, 
UI
, 
EI
, 
BI
] 
wôh
 
	gOutw¨dNodeH™dÀ
[
DO
, 
UO
, 
EO
, 
BO
]

115 
ovîride
 
	gdef
 :[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): NodeH™dÀ[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(
h
, 
BIND_ONCE
); NodeH™dÀ(h, 
this
) }

116 
ovîride
 
	gdef
 :*[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): NodeH™dÀ[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(
h
, 
BIND_STAR
); NodeH™dÀ(h, 
this
) }

117 
ovîride
 
	gdef
 :=* [
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): NodeH™dÀ[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(
h
, 
BIND_QUERY
); NodeH™dÀ(h, 
this
) }

118 
ovîride
 
	gdef
 :*=*[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): NodeH™dÀ[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(
h
, 
BIND_FLEX
); NodeH™dÀ(h, 
this
) }

120 
ovîride
 
	gdef
 :[
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): Outw¨dNodeH™dÀ[
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(h, 
BIND_ONCE
); 
	gthis
 }

121 
ovîride
 
	gdef
 :*[
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): Outw¨dNodeH™dÀ[
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(h, 
BIND_STAR
); 
	gthis
 }

122 
ovîride
 
	gdef
 :=* [
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): Outw¨dNodeH™dÀ[
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(h, 
BIND_QUERY
); 
	gthis
 }

123 
ovîride
 
	gdef
 :*=*[
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): Outw¨dNodeH™dÀ[
DO
, 
UO
, 
EO
, 
BO
] = { 
böd
(h, 
BIND_FLEX
); 
	gthis
 }

126 
obje˘
 
	gNodeH™dÀ


128 
def
 
	g≠∂y
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: D©a](
i
: 
Inw¨dNodeH™dÀ
[DI, UI, EI, BI], 
	go
: 
Outw¨dNodeH™dÀ
[DO, UO, EO, BO]Ë
√w
 
NodeH™dÀPaú
(i, 
o
)

131 
˛ass
 
	gNodeH™dÀPaú
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data]

132 (
öw¨dH™dÀ
: 
Inw¨dNodeH™dÀ
[
DI
, 
UI
, 
EI
, 
BI
], 
	goutw¨dH™dÀ
: 
Outw¨dNodeH™dÀ
[
DO
, 
UO
, 
EO
, 
BO
])

133 
exãnds
 
	gNodeH™dÀ
[
DI
, 
UI
, 
EI
, 
BI
, 
DO
, 
UO
, 
EO
, 
BO
]

135 
vÆ
 
	göw¨d
 = 
öw¨dH™dÀ
.
öw¨d


136 
vÆ
 
outw¨d
 = 
outw¨dH™dÀ
.outward

137 
def
 
ö√r
 = 
öw¨dH™dÀ
.inner

138 
def
 
ouãr
 = 
outw¨dH™dÀ
.outer

141 
åaô
 
	gInw¨dNodeH™dÀ
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
] 
exãnds
 
NoH™dÀ


143 
def
 
öw¨d
: 
Inw¨dNode
[
DI
, 
UI
, 
BI
]

144 
def
 
	gö√r
: 
Inw¨dNodeImp
[
DI
, 
UI
, 
EI
, 
BI
]

146 
¥Ÿe˘ed
 
def
 
	gböd
[
EY
](
	gh
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
], 
	gbödög
: 
NodeBödög
)(
im∂icô
 
p
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
Unô
 = 
öw¨d
.
böd
(
h
.
outw¨d
, 
bödög
)

149 
	gdef
 :[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
Inw¨dNodeH™dÀ
[DX, UX, EX, BX] = { 
böd
(
h
, 
BIND_ONCE
); h }

150 
	gdef
 :*[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
Inw¨dNodeH™dÀ
[DX, UX, EX, BX] = { 
böd
(
h
, 
BIND_STAR
); h }

151 
	gdef
 :=* [
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
Inw¨dNodeH™dÀ
[DX, UX, EX, BX] = { 
böd
(
h
, 
BIND_QUERY
); h }

152 
	gdef
 :*=*[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeH™dÀ
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
Inw¨dNodeH™dÀ
[DX, UX, EX, BX] = { 
böd
(
h
, 
BIND_FLEX
); h }

154 
	gdef
 :[
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
NoH™dÀ
 = { 
böd
(h, 
BIND_ONCE
); 
	gNoH™dÀObje˘
 }

155 
	gdef
 :*[
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
NoH™dÀ
 = { 
böd
(h, 
BIND_STAR
); 
	gNoH™dÀObje˘
 }

156 
	gdef
 :=* [
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
NoH™dÀ
 = { 
böd
(h, 
BIND_QUERY
); 
	gNoH™dÀObje˘
 }

157 
	gdef
 :*=*[
EY
](
h
: 
Outw¨dNodeH™dÀ
[
DI
, 
UI
, EY, 
BI
])(
im∂icô
 
	gp
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
NoH™dÀ
 = { 
böd
(h, 
BIND_FLEX
); 
	gNoH™dÀObje˘
 }

160 
£Æed
 
åaô
 
NodeBödög


161 
obje˘
 
BIND_ONCE
 
exãnds
 
NodeBödög


162 
obje˘
 
BIND_QUERY
 
exãnds
 
NodeBödög


163 
obje˘
 
BIND_STAR
 
exãnds
 
NodeBödög


164 
obje˘
 
BIND_FLEX
 
exãnds
 
NodeBödög


166 
åaô
 
	gInw¨dNode
[
DI
, 
UI
, 
BI
 <: 
D©a
] 
exãnds
 
Ba£Node


168 
¥iv©e
 
vÆ
 
accPI
 = 
Li°Buf„r
[(
I¡
, 
Outw¨dNode
[
DI
, 
UI
, 
BI
], 
	gNodeBödög
, 
	gP¨amëîs
, 
	gSour˚Info
)]()

169 
¥iv©e
 
v¨
 
	giRólized
 = 
Ál£


171 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
iPushed
 = 
accPI
.
size


172 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
iPush
(
ödex
: 
I¡
, 
node
: 
Outw¨dNode
[
DI
, 
UI
, 
BI
], 
bödög
: 
NodeBödög
)(
im∂icô
 
p
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
) {

173 
vÆ
 
öfo
 = 
sour˚Löe
(
sour˚Info
, "át ", "")

174 
ªquúe
 (!
iRólized
, 
s
"${«me}${œzyModuÀ.löe} wa†öc‹ª˘ly c⁄√˘edá†®söká·î it†.moduÀ wa†u£d" + 
öfo
)

175 
	gaccPI
 +((
ödex
, 
	gnode
, 
	gbödög
, 
	gp
, 
	gsour˚Info
))

178 
	g¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
	giBödögs
 = { 
iRólized
 = 
åue
; 
	gaccPI
.
ªsu…
() }

180 
	g¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
	giSèr
: 
I¡


181 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
iP‹tM≠pög
: 
Seq
[(
I¡
, Int)]

182 
	g¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
	gdiP¨ams
: 
Seq
[
DI
]

183 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
uiP¨ams
: 
Seq
[
UI
]

185 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
böd
(
h
: 
Outw¨dNode
[
DI
, 
UI
, 
BI
], 
bödög
: 
NodeBödög
)(
im∂icô
 
p
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
): 
Unô


188 
åaô
 
Outw¨dNodeH™dÀ
[
DO
, 
UO
, 
EO
, 
BO
 <: 
D©a
] 
exãnds
 
NoH™dÀ


190 
def
 
outw¨d
: 
Outw¨dNode
[
DO
, 
UO
, 
BO
]

191 
def
 
	gouãr
: 
Outw¨dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
]

194 
åaô
 
	gOutw¨dNode
[
DO
, 
UO
, 
BO
 <: 
D©a
] 
exãnds
 
Ba£Node


196 
¥iv©e
 
vÆ
 
accPO
 = 
Li°Buf„r
[(
I¡
, 
Inw¨dNode
 [
DO
, 
UO
, 
BO
], 
	gNodeBödög
, 
	gP¨amëîs
, 
	gSour˚Info
)]()

197 
¥iv©e
 
v¨
 
	goRólized
 = 
Ál£


199 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
oPushed
 = 
accPO
.
size


200 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
oPush
(
ödex
: 
I¡
, 
node
: 
Inw¨dNode
 [
DO
, 
UO
, 
BO
], 
bödög
: 
NodeBödög
)(
im∂icô
 
p
: 
P¨amëîs
, 
	gsour˚Info
: 
Sour˚Info
) {

201 
vÆ
 
öfo
 = 
sour˚Löe
(
sour˚Info
, "át ", "")

202 
ªquúe
 (!
oRólized
, 
s
"${«me}${œzyModuÀ.löe} wa†öc‹ª˘ly c⁄√˘edá†®sour˚á·î it†.moduÀ wa†u£d" + 
öfo
)

203 
	gaccPO
 +((
ödex
, 
	gnode
, 
	gbödög
, 
	gp
, 
	gsour˚Info
))

206 
	g¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
	goBödögs
 = { 
oRólized
 = 
åue
; 
	gaccPO
.
ªsu…
() }

208 
	g¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
	goSèr
: 
I¡


209 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
oP‹tM≠pög
: 
Seq
[(
I¡
, Int)]

210 
	g¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
	guoP¨ams
: 
Seq
[
UO
]

211 
¥Ÿe˘ed
[
dùlomacy
] 
vÆ
 
doP¨ams
: 
Seq
[
DO
]

214 
ab°ø˘
 
˛ass
 
	$Cy˛eEx˚±i⁄
(
köd
: 
Såög
, 
lo›
: 
Seq
[Såög]Ë
exãnds
 
	`Ex˚±i⁄
(
s
"Diplomatic ${kind} cycle detected involving ${loop}")

215 
˛ass
 
	$SèrCy˛eEx˚±i⁄
(
lo›
: 
Seq
[
Såög
] = 
Nû
Ë
exãnds
 
	`Cy˛eEx˚±i⁄
("star",Üoop)

216 
˛ass
 
	$Downw¨dCy˛eEx˚±i⁄
(
lo›
: 
Seq
[
Såög
] = 
Nû
Ë
exãnds
 
	`Cy˛eEx˚±i⁄
("downward",Üoop)

217 
˛ass
 
	$Upw¨dCy˛eEx˚±i⁄
(
lo›
: 
Seq
[
Såög
] = 
Nû
Ë
exãnds
 
	`Cy˛eEx˚±i⁄
("upward",Üoop)

219 
˛ass
 
Edges
[
EI
, 
EO
](
ö
: EI, 
out
: EO)

220 
£Æed
 
ab°ø˘
 
˛ass
 
MixedNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

221 
vÆ
 
ö√r
: 
Inw¨dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

222 
vÆ
 
ouãr
: 
Outw¨dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

223 
im∂icô
 
vÆName
: 
VÆName
)

224 
exãnds
 
Ba£Node
 
wôh
 
NodeH™dÀ
[
DI
, 
UI
, 
EI
, 
BI
, 
DO
, 
UO
, 
EO
, 
BO
] wôh 
Inw¨dNode
[DI, UI, BI] wôh 
Outw¨dNode
[DO, UO, BO]

226 
vÆ
 
öw¨d
 = 
this


227 
vÆ
 
outw¨d
 = 
this


229 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèr
: I¡, 
oSèr
: Int): (Int, Int)

230 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
DI
]): Seq[
DO
]

231 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
UO
]): Seq[
UI
]

233 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
sökC¨d
 = 
oBödögs
.
	`cou¡
(
_
.
_3
 =
BIND_QUERY
Ë+ 
iBödögs
.cou¡(_._3 =
BIND_STAR
)

234 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
sour˚C¨d
 = 
iBödögs
.
	`cou¡
(
_
.
_3
 =
BIND_QUERY
Ë+ 
oBödögs
.cou¡(_._3 =
BIND_STAR
)

235 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
Êexes
 = 
oBödögs
.
	`fûãr
(
_
.
_3
 =
BIND_FLEX
).
	`m≠
(_.
_2
) ++

236 
iBödögs
.
	`fûãr
(
_
.
_3
 =
BIND_FLEX
).
	`m≠
(_.
_2
)

237 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
ÊexOff£t
 = {

238 
def
 
	`DFS
(
v
: 
Ba£Node
, 
visôed
: 
M≠
[
I¡
, BaseNode]): Map[Int, BaseNode] = {

239 i‡(
visôed
.
	`c⁄èös
(
v
.
£rül
)) {

240 
visôed


242 
v
.
Êexes
.
	`fﬁdLe·
(
visôed
 + (v.
£rül
 -> v))((
sum
, 
n
Ë=> 
	`DFS
(n, sum))

245 
vÆ
 
ÊexSë
 = 
	`DFS
(
this
, 
	`M≠
()).
vÆues


246 
vÆ
 
ÆlSök
 = 
ÊexSë
.
	`m≠
(
_
.
sökC¨d
).
sum


247 
vÆ
 
ÆlSour˚
 = 
ÊexSë
.
	`m≠
(
_
.
sour˚C¨d
).
sum


248 
	`ªquúe
 (
ÊexSë
.
size
 =1 || 
ÆlSök
 =0 || 
ÆlSour˚
 == 0,

249 
s
"TheÇodes ${flexSet.map(_.name)} whicháre inter-connected by :*=* have ${allSink} :*= operatorsánd ${allSource} :=* operators connectedÅoÅhem, making it impossibleÅo determine cardinality inference direction.")

250 
ÆlSök
 - 
ÆlSour˚


253 
¥iv©e
 
v¨
 
°¨Cy˛eGu¨d
 = 
Ál£


254 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
	`vÆ
 (
oP‹tM≠pög
, 
iP‹tM≠pög
, 
oSèr
, 
iSèr
) = {

255 
åy
 {

256 i‡(
°¨Cy˛eGu¨d
Ë
throw
 
	`SèrCy˛eEx˚±i⁄
()

257 
°¨Cy˛eGu¨d
 = 
åue


258 
vÆ
 
oSèrs
 = 
oBödögs
.
cou¡
 { (
_
,_,
b
,_,_Ë=> b =
BIND_STAR
 || (b =
BIND_FLEX
 && 
ÊexOff£t
 < 0) }

259 
vÆ
 
iSèrs
 = 
iBödögs
.
cou¡
 { (
_
,_,
b
,_,_Ë=> b =
BIND_STAR
 || (b =
BIND_FLEX
 && 
ÊexOff£t
 >= 0) }

260 
vÆ
 
oKnown
 = 
oBödögs
.
m≠
 { (
_
, 
n
, 
b
, _, _Ë=> b 
m©ch
 {

261 
BIND_ONCE
 => 1

262 
BIND_FLEX
 => { i‡(
ÊexOff£t
 < 0Ë0 
n
.
iSèr
 }

263 
BIND_QUERY
 => 
n
.
iSèr


264 
BIND_STAR
 => 0 }}.
	`fﬁdLe·
(0)(
_
+_)

265 
vÆ
 
iKnown
 = 
iBödögs
.
m≠
 { (
_
, 
n
, 
b
, _, _Ë=> b 
m©ch
 {

266 
BIND_ONCE
 => 1

267 
BIND_FLEX
 => { i‡(
ÊexOff£t
 >0Ë0 
n
.
oSèr
 }

268 
BIND_QUERY
 => 
n
.
oSèr


269 
BIND_STAR
 => 0 }}.
	`fﬁdLe·
(0)(
_
+_)

270 
	`vÆ
 (
iSèr
, 
oSèr
Ë
	`ªsﬁveSèr
(
iKnown
, 
oKnown
, 
iSèrs
, 
oSèrs
)

271 
vÆ
 
oSum
 = 
oBödögs
.
m≠
 { (
_
, 
n
, 
b
, _, _Ë=> b 
m©ch
 {

272 
BIND_ONCE
 => 1

273 
BIND_FLEX
 => { i‡(
ÊexOff£t
 < 0Ë
oSèr
 
n
.
iSèr
 }

274 
BIND_QUERY
 => 
n
.
iSèr


275 
BIND_STAR
 => 
oSèr
 }}.
	`sˇnLe·
(0)(
_
+_)

276 
vÆ
 
iSum
 = 
iBödögs
.
m≠
 { (
_
, 
n
, 
b
, _, _Ë=> b 
m©ch
 {

277 
BIND_ONCE
 => 1

278 
BIND_FLEX
 => { i‡(
ÊexOff£t
 >0Ë
iSèr
 
n
.
oSèr
 }

279 
BIND_QUERY
 => 
n
.
oSèr


280 
BIND_STAR
 => 
iSèr
 }}.
	`sˇnLe·
(0)(
_
+_)

281 
vÆ
 
oTŸÆ
 = 
oSum
.
œ°O±i⁄
.
	`gëOrEl£
(0)

282 
vÆ
 
iTŸÆ
 = 
iSum
.
œ°O±i⁄
.
	`gëOrEl£
(0)

283 (
oSum
.
öô
 
zù
 oSum.
èû
, 
iSum
.öô zù iSum.èû, 
oSèr
, 
iSèr
)

284 } 
ˇtch
 {

285 
c
: 
SèrCy˛eEx˚±i⁄
 => 
throw
 c.
	`c›y
(
lo›
 = 
s
"${name}${lazyModule.line}" +: c.loop)

289 
œzy
 
vÆ
 
oP‹ts
 = 
oBödögs
.
Ê©M≠
 { (
i
, 
n
, 
_
, 
p
, 
s
) =>

290 
	`vÆ
 (
°¨t
, 
íd
Ë
n
.
	`iP‹tM≠pög
(
i
)

291 (
°¨t
 
u¡û
 
íd
Ë
m≠
 { 
j
 => (j, 
n
, 
p
, 
s
) }

293 
œzy
 
vÆ
 
iP‹ts
 = 
iBödögs
.
Ê©M≠
 { (
i
, 
n
, 
_
, 
p
, 
s
) =>

294 
	`vÆ
 (
°¨t
, 
íd
Ë
n
.
	`oP‹tM≠pög
(
i
)

295 (
°¨t
 
u¡û
 
íd
Ë
m≠
 { 
j
 => (j, 
n
, 
p
, 
s
) }

298 
¥iv©e
 
v¨
 
oP¨amsCy˛eGu¨d
 = 
Ál£


299 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
diP¨ams
: 
Seq
[
DI
] = 
iP‹ts
.
m≠
 { (
i
, 
n
, 
_
, _Ë=>Ç.
	`doP¨ams
(i) }

300 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
doP¨ams
: 
Seq
[
DO
] = {

301 
åy
 {

302 i‡(
oP¨amsCy˛eGu¨d
Ë
throw
 
	`Downw¨dCy˛eEx˚±i⁄
()

303 
oP¨amsCy˛eGu¨d
 = 
åue


304 
vÆ
 
o
 = 
	`m≠P¨amsD
(
oP‹ts
.
size
, 
diP¨ams
)

305 
	`ªquúe
 (
o
.
size
 =
oP‹ts
.size, 
s
"DiplomacyÉrror: $name $location has ${o.size} != ${oPorts.size} down/up outerÖarameters${lazyModule.line}")

306 
o
.
	`m≠
(
ouãr
.
	`mixO
(
_
, 
this
))

307 } 
ˇtch
 {

308 
c
: 
Downw¨dCy˛eEx˚±i⁄
 => 
throw
 c.
	`c›y
(
lo›
 = 
s
"${name}${lazyModule.line}" +: c.loop)

312 
¥iv©e
 
v¨
 
iP¨amsCy˛eGu¨d
 = 
Ál£


313 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
uoP¨ams
: 
Seq
[
UO
] = 
oP‹ts
.
m≠
 { (
o
, 
n
, 
_
, _Ë=>Ç.
	`uiP¨ams
(o) }

314 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
uiP¨ams
: 
Seq
[
UI
] = {

315 
åy
 {

316 i‡(
iP¨amsCy˛eGu¨d
Ë
throw
 
	`Upw¨dCy˛eEx˚±i⁄
()

317 
iP¨amsCy˛eGu¨d
 = 
åue


318 
vÆ
 
i
 = 
	`m≠P¨amsU
(
iP‹ts
.
size
, 
uoP¨ams
)

319 
	`ªquúe
 (
i
.
size
 =
iP‹ts
.size, 
s
"DiplomacyÉrror: $name $location has ${i.size} != ${iPorts.size} up/down innerÖarameters${lazyModule.line}")

320 
i
.
	`m≠
(
ö√r
.
	`mixI
(
_
, 
this
))

321 } 
ˇtch
 {

322 
c
: 
Upw¨dCy˛eEx˚±i⁄
 => 
throw
 c.
	`c›y
(
lo›
 = 
s
"${name}${lazyModule.line}" +: c.loop)

326 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
edgesOut
 = (
oP‹ts
 
zù
 
doP¨ams
).
m≠
 { ((
i
, 
n
, 
p
, 
s
), 
o
Ë=> 
ouãr
.
	`edgeO
(o,Ç.
	`uiP¨ams
(i),Ö, s) }

327 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
edgesIn
 = (
iP‹ts
 
zù
 
uiP¨ams
).
m≠
 { ((
o
, 
n
, 
p
, 
s
), 
i
Ë=> 
ö√r
.
	`edgeI
“.
	`doP¨ams
(o), i,Ö, s) }

330 
œzy
 
vÆ
 
edges
 = 
	`Edges
(
edgesIn
, 
edgesOut
)

332 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
bundÀOut
: 
Seq
[
BO
] = 
edgesOut
.
	`m≠
(
e
 => 
	`Wúe
(
ouãr
.
	`bundÀO
(e)))

333 
¥Ÿe˘ed
[
dùlomacy
] 
œzy
 
vÆ
 
bundÀIn
: 
Seq
[
BI
] = 
edgesIn
 .
	`m≠
(
e
 => 
	`Wúe
(
ö√r
.
	`bundÀI
(e)))

335 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
d™gÀsOut
: 
Seq
[
D™gÀ
] = 
oP‹ts
.
zùWôhIndex
.
m≠
 { ((
j
, 
n
, 
_
, _), 
i
) =>

336 
	`D™gÀ
(

337 
sour˚
 = 
	`HÆfEdge
(
£rül
, 
i
),

338 
sök
 = 
	`HÆfEdge
(
n
.
£rül
, 
j
),

339 
Êù≥d

Ál£
,

340 
«me
 = 
wúePªfix
 + "out",

341 
d©a
 = 
	`bundÀOut
(
i
))

343 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
d™gÀsIn
: 
Seq
[
D™gÀ
] = 
iP‹ts
.
zùWôhIndex
.
m≠
 { ((
j
, 
n
, 
_
, _), 
i
) =>

344 
	`D™gÀ
(

345 
sour˚
 = 
	`HÆfEdge
(
n
.
£rül
, 
j
),

346 
sök
 = 
	`HÆfEdge
(
£rül
, 
i
),

347 
Êù≥d

åue
,

348 
«me
 = 
wúePªfix
 + "in",

349 
d©a
 = 
	`bundÀIn
(
i
))

352 
¥iv©e
 
v¨
 
bundÀsSa„Now
 = 
Ál£


354 
def
 
out
: 
Seq
[(
BO
, 
EO
)] = {

355 
	`ªquúe
(
bundÀsSa„Now
, 
s
"${name}.out should only be called fromÅhe context of its module implementation")

356 
bundÀOut
 
zù
 
edgesOut


358 
def
 
ö
: 
Seq
[(
BI
, 
EI
)] = {

359 
	`ªquúe
(
bundÀsSa„Now
, 
s
"${name}.in should only be called fromÅhe context of its module implementation")

360 
bundÀIn
 
zù
 
edgesIn


364 
¥Ÿe˘ed
 
vÆ
 
idítôy
 = 
Ál£


365 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ö°™tüã
() = {

366 
bundÀsSa„Now
 = 
åue


367 i‡(!
idítôy
) {

368 (
iP‹ts
 
zù
 
ö
Ë
f‹óch
 {

369 ((
_
, _, 
p
, _), (
b
, 
e
)Ë=> i‡(
	`p
(
M⁄ô‹sE«bÀd
)Ë
ö√r
.
	`m⁄ô‹
(b,É)

371 
d™gÀsOut
 ++ 
d™gÀsIn


374 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`föishIn°™tüã
() = {

375 
bundÀsSa„Now
 = 
Ál£


379 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`böd
(
h
: 
Outw¨dNode
[
DI
, 
UI
, 
BI
], 
bödög
: 
NodeBödög
)(
im∂icô
 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
) {

380 
vÆ
 
x
 = 
this


381 
vÆ
 
y
 = 
h


382 
vÆ
 
öfo
 = 
	`sour˚Löe
(
sour˚Info
, "át ", "")

383 
vÆ
 
i
 = 
x
.
iPushed


384 
vÆ
 
o
 = 
y
.
oPushed


385 
y
.
	`oPush
(
i
, 
x
, 
bödög
 
m©ch
 {

386 
BIND_ONCE
 => BIND_ONCE

387 
BIND_FLEX
 => BIND_FLEX

388 
BIND_STAR
 => 
BIND_QUERY


389 
BIND_QUERY
 => 
BIND_STAR
 })

390 
x
.
	`iPush
(
o
, 
y
, 
bödög
)

394 
def
 
öputs
 = (
iP‹ts
 
zù
 
edgesIn
Ë
m≠
 { ((
_
, 
n
, 
p
, _), 
e
) =>

395 
vÆ
 
ª
 = 
ö√r
.
	`ªndî
(
e
)

396 (
n
, 
ª
.
	`c›y
(
Êù≥d
 =Ñe.Êù≥d !
	`p
(
RídîFlù≥d
)))

398 
def
 
ouçuts
 = 
oP‹ts
 
m≠
 { (
i
, 
n
, 
_
, _Ë=> (n,Ç.
	`öputs
(i).
_2
) }

399 
	}
}

401 
ab°ø˘
 
˛ass
 
	gMixedCu°omNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

402 
ö√r
: 
Inw¨dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

403 
	gouãr
: 
Outw¨dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

404 
im∂icô
 
	gvÆName
: 
VÆName
)

405 
exãnds
 
	$MixedNode
(
ö√r
, 
ouãr
)

407 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int)

408 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
DI
]): Seq[
DO
]

409 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
UO
]): Seq[
UI
]

410 
	}
}

412 
ab°ø˘
 
˛ass
 
Cu°omNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(

413 
im∂icô
 
	gvÆName
: 
VÆName
)

414 
exãnds
 
	$MixedCu°omNode
(
imp
, imp)

416 
˛ass
 
MixedAd≠ãrNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

417 
ö√r
: 
Inw¨dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

418 
ouãr
: 
Outw¨dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

419 
dFn
: 
DI
 => 
DO
,

420 
uFn
: 
UO
 => 
UI
)(

421 
im∂icô
 
vÆName
: 
VÆName
)

422 
exãnds
 
	$MixedNode
(
ö√r
, 
ouãr
)

424 
ovîride
 
def
 
des¸ùti⁄
 = "adapter"

425 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

426 
	`ªquúe
 (
oSèrs
 + 
iSèrs
 <1, 
s
"$name $locationáppearsÜeft ofá :*= $iStarsÅimesándÑight ofá :=* $oStarsÅimes;át most once isállowed${lazyModule.line}")

427 i‡(
oSèrs
 > 0) {

428 
	`ªquúe
 (
iKnown
 >
oKnown
, 
s
"$name $location has $oKnown outputsánd $iKnown inputs; cannotássign ${iKnown-oKnown}ÉdgesÅoÑesolve :=*${lazyModule.line}")

429 (0, 
iKnown
 - 
oKnown
)

430 } i‡(
iSèrs
 > 0) {

431 
	`ªquúe
 (
oKnown
 >
iKnown
, 
s
"$name $location has $oKnown outputsánd $iKnown inputs; cannotássign ${oKnown-iKnown}ÉdgesÅoÑesolve :*=${lazyModule.line}")

432 (
oKnown
 - 
iKnown
, 0)

434 
	`ªquúe
 (
oKnown
 =
iKnown
, 
s
"$name $location has $oKnown outputsánd $iKnown inputs;Åhese doÇot match")

438 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
DI
]): Seq[
DO
] = {

439 
	`ªquúe
(
n
 =
p
.
size
, 
s
"$name $location has ${p.size} inputsánd ${n} outputs;Åhey must match${lazyModule.line}")

440 
p
.
	`m≠
(
dFn
)

442 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
UO
]): Seq[
UI
] = {

443 
	`ªquúe
(
n
 =
p
.
size
, 
s
"$name $location has ${n} inputsánd ${p.size} outputs;Åhey must match${lazyModule.line}")

444 
p
.
	`m≠
(
uFn
)

446 
	}
}

448 
˛ass
 
	gAd≠ãrNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(

449 
	gdFn
: 
D
 => D,

450 
	guFn
: 
U
 => U)(

451 
im∂icô
 
vÆName
: 
VÆName
)

452 
exãnds
 
MixedAd≠ãrNode
[
D
, 
U
, 
EI
, 
B
, D, U, 
EO
, B](
	gimp
, imp)(
	gdFn
, 
	guFn
)

455 
˛ass
 
	gIdítôyNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])()(
im∂icô
 
	gvÆName
: 
VÆName
)

456 
exãnds
 
	$Ad≠ãrNode
(
imp
)({ 
s
 => s 
	}
}, { 
	gs
 => s })

458 
¥Ÿe˘ed
 
ovîride
 
vÆ
 
	gidítôy
 = 
åue


459 
ovîride
 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
ö°™tüã
() = {

460 
vÆ
 
d™gÀs
 = 
su≥r
.
ö°™tüã
()

461 (
out
 
zù
 
ö
Ë
m≠
 { ((
o
, 
_
), (
i
, _)) => o <> i }

462 
	gd™gÀs


466 
˛ass
 
	gMixedNexusNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

467 
ö√r
: 
Inw¨dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

468 
	gouãr
: 
Outw¨dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

469 
	gdFn
: 
Seq
[
DI
] => 
DO
,

470 
	guFn
: 
Seq
[
UO
] => 
UI
,

472 
	göputRequúesOuçut
: 
Boﬁón
 = 
åue
,

473 
	gouçutRequúesI≈ut
: 
Boﬁón
 = 
åue
)(

474 
im∂icô
 
vÆName
: 
VÆName
)

475 
exãnds
 
	$MixedNode
(
ö√r
, 
ouãr
)

477 
ovîride
 
def
 
des¸ùti⁄
 = "nexus"

478 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

480 
	`ªquúe
 (!
ouçutRequúesI≈ut
 || 
oKnown
 =0 || 
iSèrs
 + 
iKnown
 !0, 
s
"$name $location has $oKnownÑequired outputsándÇoÖossible inputs")

481 
	`ªquúe
 (!
öputRequúesOuçut
 || 
iKnown
 =0 || 
oSèrs
 + 
oKnown
 !0, 
s
"$name $location has $iKnownÑequired inputsándÇoÖossible outputs")

482 i‡(
iKnown
 =0 && 
oKnown
 == 0) (0, 0) (1, 1)

484 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
DI
]): Seq[
DO
] = { i‡“ > 0Ë{ 
vÆ
 
a
 = 
	`dFn
’); Seq.
	`fûl
“)◊Ë} 
Nû
 }

485 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
UO
]): Seq[
UI
] = { i‡“ > 0Ë{ 
vÆ
 
a
 = 
	`uFn
’); Seq.
	`fûl
“)◊Ë} 
Nû
 }

486 
	}
}

488 
˛ass
 
	gNexusNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(

489 
	gdFn
: 
Seq
[
D
] => D,

490 
	guFn
: 
Seq
[
U
] => U,

491 
	göputRequúesOuçut
: 
Boﬁón
 = 
åue
,

492 
	gouçutRequúesI≈ut
: 
Boﬁón
 = 
åue
)(

493 
im∂icô
 
vÆName
: 
VÆName
)

494 
exãnds
 
MixedNexusNode
[
D
, 
U
, 
EI
, 
B
, D, U, 
EO
, B](
	gimp
, imp)(
	gdFn
, 
	guFn
, 
	göputRequúesOuçut
, 
	gouçutRequúesI≈ut
)

497 
˛ass
 
	gSour˚Node
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(
	gpo
: 
Seq
[D])(
im∂icô
 
vÆName
: 
VÆName
)

498 
exãnds
 
	$MixedNode
(
imp
, imp)

500 
ovîride
 
def
 
des¸ùti⁄
 = "source"

501 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

502 
	`ªquúe
 (
oSèrs
 <1, 
s
"$name $locationáppearsÑight ofá :=* ${oStars}Åimes;át most once isállowed${lazyModule.line}")

503 
	`ªquúe
 (
iSèrs
 =0, 
s
"$name $location cannotáppearÜeft ofá :*=${lazyModule.line}")

504 
	`ªquúe
 (
iKnown
 =0, 
s
"$name $location cannotáppearÜeft ofá :=${lazyModule.line}")

505 
	`ªquúe
 (
po
.
size
 =
oKnown
 || 
oSèrs
 =1, 
s
"$name $location has only ${oKnown} outputs connected out of ${po.size}")

506 
	`ªquúe
 (
po
.
size
 >
oKnown
, 
s
"$name $location has ${oKnown} outputs out of ${po.size}; cannotássign ${po.size - oKnown}ÉdgesÅoÑesolve :=*${lazyModule.line}")

507 (0, 
po
.
size
 - 
oKnown
)

509 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
D
]): Seq[D] = 
po


510 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
U
]): Seq[U] = 
	`Seq
()

511 
	}
}

514 
˛ass
 
SökNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(
	gpi
: 
Seq
[U])(
im∂icô
 
vÆName
: 
VÆName
)

515 
exãnds
 
	$MixedNode
(
imp
, imp)

517 
ovîride
 
def
 
des¸ùti⁄
 = "sink"

518 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

519 
	`ªquúe
 (
iSèrs
 <1, 
s
"$name $locationáppearsÜeft ofá :*= ${iStars}Åimes;át most once isállowed${lazyModule.line}")

520 
	`ªquúe
 (
oSèrs
 =0, 
s
"$name $location cannotáppearÑight ofá :=*${lazyModule.line}")

521 
	`ªquúe
 (
oKnown
 =0, 
s
"$name $location cannotáppearÑight ofá :=${lazyModule.line}")

522 
	`ªquúe
 (
pi
.
size
 =
iKnown
 || 
iSèrs
 =1, 
s
"$name $location has only ${iKnown} inputs connected out of ${pi.size}")

523 
	`ªquúe
 (
pi
.
size
 >
iKnown
, 
s
"$name $location has ${iKnown} inputs out of ${pi.size}; cannotássign ${pi.size - iKnown}ÉdgesÅoÑesolve :*=${lazyModule.line}")

524 (
pi
.
size
 - 
iKnown
, 0)

526 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
D
]): Seq[D] = 
	`Seq
()

527 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
U
]): Seq[U] = 
pi


528 
	}
}

530 
˛ass
 
MixedTe°Node
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: D©a] 
¥Ÿe˘ed
[
dùlomacy
](

531 
node
: 
NodeH™dÀ
 [
DI
, 
UI
, 
EI
, 
BI
, 
DO
, 
UO
, 
EO
, 
BO
], 
	g˛⁄e
: 
Cl⁄eLazyModuÀ
)(

532 
im∂icô
 
vÆName
: 
VÆName
)

533 
exãnds
 
	$MixedNode
(
node
.
ö√r
,Çode.
ouãr
)

536 
def
 
iP¨ams
: 
Seq
[
DI
] = 
node
.
öw¨d
 .
diP¨ams


537 
def
 
oP¨ams
: 
Seq
[
UO
] = 
node
.
outw¨d
.
uoP¨ams


539 
ovîride
 
def
 
des¸ùti⁄
 = "test"

540 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

541 
	`ªquúe
 (
oSèrs
 <1, 
s
"$name $locationáppearsÑight ofá :=* $oStarsÅimes;át most once isállowed${lazyModule.line}")

542 
	`ªquúe
 (
iSèrs
 <1, 
s
"$name $locationáppearsÜeft ofá :*= $iStarsÅimes;át most once isállowed${lazyModule.line}")

543 
	`ªquúe
 (
node
.
öw¨d
 .
uiP¨ams
.
size
 =
iKnown
 || 
iSèrs
 =1, 
s
"$name $location has only $iKnown inputs connected out of ${node.inward.uiParams.size}")

544 
	`ªquúe
 (
node
.
outw¨d
.
doP¨ams
.
size
 =
oKnown
 || 
oSèrs
 =1, 
s
"$name $location has only $oKnown outputs connected out of ${node.outward.doParams.size}")

545 (
node
.
öw¨d
.
uiP¨ams
.
size
 - 
iKnown
,Çode.
outw¨d
.
doP¨ams
.sizê- 
oKnown
)

548 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
UO
]): Seq[
UI
] = 
node
.
öw¨d
 .
uiP¨ams


549 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
DI
]): Seq[
DO
] = 
node
.
outw¨d
.
doP¨ams


551 
ovîride
 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
	`ö°™tüã
() = {

552 
vÆ
 
d™gÀs
 = 
su≥r
.
	`ö°™tüã
()

553 
vÆ
 
‹ig_moduÀ
 = 
˛⁄e
.
ba£
.
moduÀ


554 
vÆ
 
˛⁄e_auto
 = 
˛⁄e
.
	`io
("auto").
asIn°™˚Of
[
AutoBundÀ
]

556 
d™gÀsOut
.
zùWôhIndex
.
f‹óch
 { (
d
, 
i
) =>

557 
vÆ
 
‹ig
 = 
‹ig_moduÀ
.
d™gÀs
.
	`föd
(
_
.
sour˚
 =
	`HÆfEdge
(
node
.
outw¨d
.
£rül
, 
i
))

558 
	`ªquúe
 (
‹ig
.
isDeföed
, 
s
"ClonedÇode ${node.outward.name} must be connectedÉxternally out ${orig_module.name}")

559 
vÆ
 
io_«me
 = 
‹ig_moduÀ
.auto.
ñemíts
.
	`föd
(
_
.
_2
 
eq
 
‹ig
.
gë
.
d©a
).gë.
_1


560 
d
.
d©a
 <> 
˛⁄e_auto
.
	`ñemíts
(
io_«me
)

562 
d™gÀsIn
.
zùWôhIndex
.
f‹óch
 { (
d
, 
i
) =>

563 
vÆ
 
‹ig
 = 
‹ig_moduÀ
.
d™gÀs
.
	`föd
(
_
.
sök
 =
	`HÆfEdge
(
node
.
öw¨d
.
£rül
, 
i
))

564 
	`ªquúe
 (
‹ig
.
isDeföed
, 
s
"ClonedÇode ${node.inward.name} must be connectedÉxternally in ${orig_module.name}")

565 
vÆ
 
io_«me
 = 
‹ig_moduÀ
.auto.
ñemíts
.
	`föd
(
_
.
_2
 
eq
 
‹ig
.
gë
.
d©a
).gë.
_1


566 
˛⁄e_auto
.
	`ñemíts
(
io_«me
Ë<> 
d
.
d©a


569 
d™gÀs


571 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Parameters.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gShi·Queue
, 
	gR©i⁄ÆDúe˘i⁄
, 
	gFa°ToSlow
, 
	gAsyncQueueP¨ams
}

9 
obje˘
 
	gRegi⁄Ty≥
 {

11 
vÆ
 
	gˇ£s
 = 
Seq
(
CACHED
, 
TRACKED
, 
UNCACHED
, 
UNCACHEABLE
, 
PUT_EFFECTS
, 
GET_EFFECTS
)

12 
£Æed
 
åaô
 
T
 
exãnds
 
	gOrdîed
[T] {

13 
def
 
com∑ª
(
th©
: 
T
): 
I¡
 = 
ˇ£s
.
ödexOf
—h©Ëcom∑ª ca£s.ödexOf(
this
)

16 
obje˘
 
CACHED
 
exãnds
 
T


17 
obje˘
 
TRACKED
 
exãnds
 
T


18 
obje˘
 
UNCACHED
 
exãnds
 
T


19 
obje˘
 
UNCACHEABLE
 
exãnds
 
T


20 
obje˘
 
PUT_EFFECTS
 
exãnds
 
T


21 
obje˘
 
GET_EFFECTS
 
exãnds
 
T


25 
˛ass
 
	$IdR™ge
(
°¨t
: 
I¡
, 
íd
: I¡Ë
exãnds
 
Ordîed
[
IdR™ge
]

27 
	`ªquúe
 (
°¨t
 >0, 
s
"Ids cannot beÇegative, but got: $start.")

28 
	`ªquúe
 (
°¨t
 <
íd
, "IdÑanges cannot beÇegative.")

30 
def
 
	`com∑ª
(
x
: 
IdR™ge
) = {

31 
vÆ
 
¥im¨y
 = (
this
.
°¨t
 - 
x
.°¨t).
signum


32 
vÆ
 
£c⁄d¨y
 = (
x
.
íd
 - 
this
.íd).
signum


33 i‡(
¥im¨y
 !0Ë¥im¨y 
£c⁄d¨y


36 
def
 
	`ovîœps
(
x
: 
IdR™ge
Ë
°¨t
 < x.
íd
 && x.start <Énd

37 
def
 
	`c⁄èös
(
x
: 
IdR™ge
Ë
°¨t
 <x.°¨à&& x.
íd
 <=Énd

39 
def
 
	`c⁄èös
(
x
: 
I¡
Ë
°¨t
 <x && x < 
íd


40 
def
 
	`c⁄èös
(
x
: 
UI¡
) =

41 i‡(
size
 == 0) {

42 
	`Boﬁ
(
Ál£
)

43 } i‡(
size
 == 1) {

44 
x
 ==
	`UI¡
(
°¨t
)

47 
vÆ
 
œrge°DñèBô
 = 
	`log2Flo‹
(
°¨t
 ^ (
íd
-1))

48 
vÆ
 
smÆÀ°Comm⁄Bô
 = 
œrge°DñèBô
 + 1

49 
vÆ
 
uncomm⁄Mask
 = (1 << 
smÆÀ°Comm⁄Bô
) - 1

50 
vÆ
 
uncomm⁄Bôs
 = (
x
 | 
	`UI¡
(0, 
width
=
smÆÀ°Comm⁄Bô
))(
œrge°DñèBô
, 0)

52 (
x
 >> 
smÆÀ°Comm⁄Bô
Ë==
	`UI¡
(
°¨t
 >> smallestCommonBit) &&

54 
	`UI¡
(
°¨t
 & 
uncomm⁄Mask
Ë<
uncomm⁄Bôs
 &&

55 
uncomm⁄Bôs
 <
	`UI¡
((
íd
-1Ë& 
uncomm⁄Mask
)

58 
def
 
	`shi·
(
x
: 
I¡
Ë
	`IdR™ge
(
°¨t
+x, 
íd
+x)

59 
def
 
size
 = 
íd
 - 
°¨t


60 
def
 
isEm±y
 = 
íd
 =
°¨t


62 
def
 
ønge
 = 
°¨t
 
u¡û
 
íd


63 
	}
}

65 
obje˘
 
	gIdR™ge


67 
def
 
ovîœps
(
s
: 
Seq
[
IdR™ge
]Ëi‡(s.
isEm±y
Ë
N⁄e
 {

68 
vÆ
 
ønges
 = 
s
.
s‹ãd


69 (
ønges
.
èû
 
zù
Ñ™ges.
öô
Ë
föd
 { (
a
, 
b
Ë=>á 
ovîœps
 b }

74 
˛ass
 
	$Tøns„rSizes
(
mö
: 
I¡
, 
max
: Int)

76 
def
 
	`this
(
x
: 
I¡
) =Åhis(x, x)

78 
	`ªquúe
 (
mö
 <
max
, 
s
"MinÅransfer $min > maxÅransfer $max")

79 
	`ªquúe
 (
mö
 >0 && 
max
 >0, 
s
"TransferSizes must beÖositive, got: ($min, $max)")

80 
	`ªquúe
 (
max
 =0 || 
	`isPow2
(max), 
s
"TransferSizes must beáÖower of 2, got: $max")

81 
	`ªquúe
 (
mö
 =0 || 
	`isPow2
(mö), 
s
"TransferSizes must beáÖower of 2, got: $min")

82 
	`ªquúe
 (
max
 =0 || 
mö
 !0, 
s
"TransferSize 0 is forbidden unless (0,0), got: ($min, $max)")

84 
def
 
n⁄e
 = 
mö
 == 0

85 
def
 
	`c⁄èös
(
x
: 
I¡
Ë
	`isPow2
(xË&& 
mö
 <x && x <
max


86 
def
 
	`c⁄èösLg
(
x
: 
I¡
Ë
	`c⁄èös
(1 << x)

87 
def
 
	`c⁄èösLg
(
x
: 
UI¡
) =

88 i‡(
n⁄e
Ë
	`Boﬁ
(
Ál£
)

89 i‡(
mö
 =
max
Ë{ 
	`UI¡
(
	`log2Ceû
(mö)Ë==
x
 }

90 { 
	`UI¡
(
	`log2Ceû
(
mö
)Ë<
x
 && x <UI¡÷og2Ceû(
max
)) }

92 
def
 
	`c⁄èös
(
x
: 
Tøns„rSizes
Ëx.
n⁄e
 || (
mö
 <x.mö && x.
max
 <= max)

94 
def
 
	`öãr£˘
(
x
: 
Tøns„rSizes
) =

95 i‡(
x
.
max
 < 
mö
 || max < x.möË
Tøns„rSizes
.
n⁄e


96 
	`Tøns„rSizes
(
sˇœ
.
m©h
.
	`max
(
mö
, 
x
.mö), sˇœ.m©h.
	`mö
(
max
, x.max))

98 
ovîride
 
def
 
	`toSåög
(Ë"Tøns„rSizes[%d, %d]".
	`f‹m©
(
mö
, 
max
)

100 
	}
}

102 
obje˘
 
	gTøns„rSizes
 {

103 
def
 
≠∂y
(
x
: 
I¡
Ë
√w
 
Tøns„rSizes
(x)

104 
vÆ
 
n⁄e
 = 
√w
 
Tøns„rSizes
(0)

106 
im∂icô
 
def
 
asBoﬁ
(
x
: 
Tøns„rSizes
Ë!x.
n⁄e


113 
˛ass
 
	$AddªssSë
(
ba£
: 
BigI¡
, 
mask
: BigI¡Ë
exãnds
 
Ordîed
[
AddªssSë
]

116 
	`ªquúe
 ((
ba£
 & 
mask
Ë=0, 
s
"Mis-aligned AddressSetsáre forbidden, got: ($base, $mask)")

117 
	`ªquúe
 (
ba£
 >0, 
s
"AddressSetÇegative base isámbiguous: $base")

120 
def
 
	`c⁄èös
(
x
: 
BigI¡
Ë((x ^ 
ba£
Ë& ~
mask
) == 0

121 
def
 
	`c⁄èös
(
x
: 
UI¡
Ë((x ^ 
	`UI¡
(
ba£
)).
	`zext
(Ë& 
	`SI¡
(~
mask
)) === SInt(0)

124 
def
 
	`ÀgÆize
(
x
: 
UI¡
): UI¡ = 
ba£
.
U
 | (
mask
.U & x)

127 
def
 
	`ovîœps
(
x
: 
AddªssSë
Ë(~(
mask
 | x.maskË& (
ba£
 ^ x.base)) == 0

129 
def
 
	`c⁄èös
(
x
: 
AddªssSë
Ë((x.
mask
 | (
ba£
 ^ x.base)) & ~mask) == 0

132 
def
 
Æignmít
 = ((
mask
 + 1) & ~mask)

134 
def
 
c⁄tiguous
 = 
Æignmít
 =
mask
+1

136 
def
 
föôe
 = 
mask
 >= 0

137 
def
 
max
 = { 
	`ªquúe
 (
föôe
, "Max c™nŸ bêˇlcuœãd o¿öföôêmask"); 
ba£
 | 
mask
 }

140 
def
 
	`widí
(
imask
: 
BigI¡
Ë
	`AddªssSë
(
ba£
 & ~imask, 
mask
 | imask)

143 
def
 
	`öãr£˘
(
x
: 
AddªssSë
): 
O±i⁄
[AddressSet] = {

144 i‡(!
	`ovîœps
(
x
)) {

145 
N⁄e


147 
vÆ
 
r_mask
 = 
mask
 & 
x
.mask

148 
vÆ
 
r_ba£
 = 
ba£
 | 
x
.base

149 
	`Some
(
	`AddªssSë
(
r_ba£
, 
r_mask
))

153 
def
 
	`subåa˘
(
x
: 
AddªssSë
): 
Seq
[AddressSet] = {

154 i‡(!
	`ovîœps
(
x
)) {

155 
	`Seq
(
this
)

157 
vÆ
 
√w_öÊex
 = ~
x
.
mask
 & mask

158 
vÆ
 
‰a˘uª
 = 
AddªssSë
.
	`íumî©eMask
(
√w_öÊex
).
	`Ê©M≠
(
m
 => 
	`öãr£˘
(
	`AddªssSë
(m, ~new_inflex)))

159 
‰a˘uª
.
	`fûãr
(!
_
.
	`ovîœps
(
x
))

164 
def
 
	`com∑ª
(
x
: 
AddªssSë
) = {

165 
vÆ
 
¥im¨y
 = (
this
.
ba£
 - 
x
.ba£).
signum


166 
vÆ
 
£c⁄d¨y
 = (
x
.
mask
 - 
this
.mask).
signum


167 i‡(
¥im¨y
 !0Ë¥im¨y 
£c⁄d¨y


171 
ovîride
 
def
 
	`toSåög
() = {

172 i‡(
mask
 >= 0) {

173 "AddªssSë(0x%x, 0x%x)".
	`f‹m©
(
ba£
, 
mask
)

175 "AddªssSë(0x%x, ~0x%x)".
	`f‹m©
(
ba£
, ~
mask
)

179 
def
 
toR™ges
 = {

180 
	`ªquúe
 (
föôe
, "Ranges cannot be calculated on infinite mask")

181 
vÆ
 
size
 = 
Æignmít


182 
vÆ
 
‰agmíts
 = 
mask
 & ~(
size
-1)

183 
vÆ
 
bôs
 = 
	`bôIndexes
(
‰agmíts
)

184 (
	`BigI¡
(0Ë
	`u¡û
 (BigI¡(1Ë<< 
bôs
.
size
)).
m≠
 { 
i
 =>

185 
vÆ
 
off
 = 
	`bôIndexes
(
i
).
	`fﬁdLe·
(
ba£
Ë{ (
a
, 
b
Ë=>á.
	`£tBô
(
	`bôs
(b)) }

186 
	`AddªssR™ge
(
off
, 
size
)

189 
	}
}

191 
obje˘
 
	gAddªssSë


193 
vÆ
 
	gevîythög
 = 
AddªssSë
(0, -1)

194 
def
 
mißlig√d
(
ba£
: 
BigI¡
, 
size
: BigI¡, 
èû
: 
Seq
[
AddªssSë
] = Seq()): Seq[AddressSet] = {

195 i‡(
size
 =0Ë
èû
.
ªvî£
 {

196 
vÆ
 
maxBa£Alignmít
 = 
ba£
 & (-base)

197 
vÆ
 
maxSizeAlignmít
 = 
BigI¡
(1Ë<< 
log2Flo‹
(
size
)

198 
vÆ
 
°ï
 =

199 i‡(
maxBa£Alignmít
 =0 || maxBa£Alignmíà> 
maxSizeAlignmít
)

200 
maxSizeAlignmít
 
maxBa£Alignmít


201 
mißlig√d
(
ba£
+
°ï
, 
size
-°ï, 
AddªssSë
(ba£, sãp-1Ë+: 
èû
)

205 
def
 
unify
(
£q
: 
Seq
[
AddªssSë
]): Seq[AddressSet] = {

206 
vÆ
 
n
 = 
£q
.
size


207 
vÆ
 
¨øy
 = 
Aºay
(
£q
:
_
*)

208 
v¨
 
fûãr
 = 
Aºay
.
fûl
(
n
Ë{ 
Ál£
 }

209 
i
 <- 0 
u¡û
 
n
-1Ë{ i‡(!
fûãr
(i)) {

210 
j
 <- 
i
+1 
u¡û
 
n
Ë{ i‡(!
fûãr
(j)) {

211 
vÆ
 
a
 = 
¨øy
(
i
)

212 
vÆ
 
b
 = 
¨øy
(
j
)

213 i‡(
a
.
mask
 =
b
.mask && 
isPow2
◊.
ba£
 ^ b.base)) {

214 
vÆ
 
c_ba£
 = 
a
.
ba£
 & ~◊.ba£ ^ 
b
.base)

215 
vÆ
 
c_mask
 = 
a
.
mask
 | (a.
ba£
 ^ 
b
.base)

216 
fûãr
.
upd©e
(
j
, 
åue
)

217 
	g¨øy
.
upd©e
(
i
, 
AddªssSë
(
c_ba£
, 
c_mask
))

221 
vÆ
 
	gout
 = (
¨øy
 
zù
 
fûãr
Ë
Ê©M≠
 { (
a
, 
f
Ë=> i‡(fË
N⁄e
 
Some
(a) }

222 i‡(
	gout
.
	gsize
 !
n
Ë
unify
(
out
Ëout.
toLi°


225 
def
 
íumî©eMask
(
mask
: 
BigI¡
): 
Seq
[BigInt] = {

226 
def
 
hñ≥r
(
id
: 
BigI¡
): 
Seq
[BigInt] =

227 i‡(
id
 =
mask
Ë
Seq
(idËid +: 
hñ≥r
(((~mask | id) + 1) & mask)

228 
hñ≥r
(0)

231 
def
 
íumî©eBôs
(
mask
: 
BigI¡
): 
Seq
[BigInt] = {

232 
def
 
hñ≥r
(
x
: 
BigI¡
): 
Seq
[BigInt] = {

233 i‡(
x
 == 0) {

234 
Nû


236 
vÆ
 
bô
 = 
x
 & (-x)

237 
bô
 +: 
hñ≥r
(
x
 & ~bit)

240 
hñ≥r
(
mask
)

244 
˛ass
 
	$Buf„rP¨ams
(
dïth
: 
I¡
, 
Êow
: 
Boﬁón
, 
pùe
: Boolean)

246 
	`ªquúe
 (
dïth
 >= 0, "Buffer depth must be >= 0")

247 
def
 
isDeföed
 = 
dïth
 > 0

248 
def
 
œãncy
 = i‡(
isDeföed
 && !
Êow
) 1 0

250 
def
 
≠∂y
[
T
 <: 
D©a
](
x
: 
Decou∂edIO
[T]) =

251 i‡(
isDeföed
Ë
	`Queue
(
x
, 
dïth
, 
Êow
=Êow, 
pùe
=pipe)

252 
x


254 
def
 
sq
[
T
 <: 
D©a
](
x
: 
Decou∂edIO
[T]) =

255 i‡(!
isDeföed
Ë
x
 {

256 
vÆ
 
sq
 = 
	`ModuÀ
(
√w
 
	`Shi·Queue
(
x
.
bôs
, 
dïth
, 
Êow
=Êow, 
pùe
=pipe))

257 
sq
.
io
.
íq
 <> 
x


258 
sq
.
io
.
deq


261 
ovîride
 
def
 
	`toSåög
(Ë"Buf„rP¨ams:%d%s%s".
	`f‹m©
(
dïth
, i‡(
Êow
Ë"F" "", i‡(
pùe
) "P" "")

263 
	}
}

265 
obje˘
 
	gBuf„rP¨ams


267 
im∂icô
 
def
 
≠∂y
(
dïth
: 
I¡
): 
Buf„rP¨ams
 = Buf„rP¨ams(dïth, 
Ál£
, false)

269 
vÆ
  = 
Buf„rP¨ams
(2)

270 
vÆ
 
n⁄e
 = 
Buf„rP¨ams
(0)

271 
vÆ
 
Êow
 = 
Buf„rP¨ams
(1, 
åue
, 
Ál£
)

272 
vÆ
 
	gpùe
 = 
Buf„rP¨ams
(1, 
Ál£
, 
åue
)

275 
˛ass
 
	$TriSèãVÆue
(
vÆue
: 
Boﬁón
, 
£t
: Boolean)

277 
def
 
	`upd©e
(
‹ig
: 
Boﬁón
Ëi‡(
£t
Ë
vÆue
 orig

278 
	}
}

280 
obje˘
 
TriSèãVÆue


282 
im∂icô
 
def
 
≠∂y
(
vÆue
: 
Boﬁón
): 
TriSèãVÆue
 = TriSèãVÆue(vÆue, 
åue
)

283 
def
 
	gun£t
 = 
TriSèãVÆue
(
Ál£
, false)

287 
£Æed
 
åaô
 
	gClockCrossögTy≥


289 
def
 
	gßmeClock
 = 
this
 
m©ch
 {

290 
_
: 
Synchr⁄ousCrossög
 => 
åue


291 
_
 => 
Ál£


295 
obje˘
 
NoCrossög


296 
˛ass
 
	$Synchr⁄ousCrossög
(
∑øms
: 
Buf„rP¨ams
 = Buf„rP¨ams.Ë
exãnds
 
ClockCrossögTy≥


297 
˛ass
 
	$R©i⁄ÆCrossög
(
dúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Fa°ToSlow
Ë
exãnds
 
ClockCrossögTy≥


298 
˛ass
 
	$Asynchr⁄ousCrossög
(
dïth
: 
I¡
 = 8, 
sour˚Sync
: I¡ = 3, 
sökSync
: I¡ = 3, 
ß„
: 
Boﬁón
 = 
åue
, 
«ºow
: Boﬁó¿
Ál£
Ë
exãnds
 
ClockCrossögTy≥


300 
def
 
asSökP¨ams
 = 
	`AsyncQueueP¨ams
(
dïth
, 
sökSync
, 
ß„
, 
«ºow
)

301 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Resources.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
log2Ceû


6 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gimmuèbÀ
.{
	gLi°M≠
,
	gS‹ãdM≠
}

7 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
HashM≠


9 
£Æed
 
åaô
 
Resour˚VÆue


18 
˛ass
 
	$Resour˚Pîmissi⁄s
(
r
: 
Boﬁón
, 
w
: Boﬁón, 
x
: Boﬁón, 
c
: Boﬁón, 
a
: Boolean)

24 
föÆ
 
˛ass
 
	$Resour˚Addªss
(
addªss
: 
Seq
[
AddªssSë
], 
≥rmissi⁄s
: 
Resour˚Pîmissi⁄s
Ë
exãnds
 
Resour˚VÆue


27 
def
 
	`this
(
x
: 
I¡
Ëthis(
	`Seq
(
	`AddªssSë
(x, 0)), 
	`Resour˚Pîmissi⁄s
(
Ál£
, false, false, false, false))

28 
	}
}

29 
obje˘
 
	gResour˚Addªss
 {

30 
def
 
≠∂y
(
x
: 
I¡
Ë
√w
 
Resour˚Addªss
(x)

38 
föÆ
 
˛ass
 
	$Resour˚M≠pög
(
addªss
: 
Seq
[
AddªssSë
], 
off£t
: 
BigI¡
, 
≥rmissi⁄s
: 
Resour˚Pîmissi⁄s
Ë
exãnds
 
Resour˚VÆue


39 
föÆ
 ˛as†
	cResour˚Såög
(
vÆue
: 
Såög
Ë
exãnds
 
Resour˚VÆue


40 
föÆ
 ˛as†
	cResour˚I¡
(
vÆue
: 
BigI¡
Ë
exãnds
 
Resour˚VÆue
 {

41 
def
 
	`this
(
x
: 
DoubÀ
Ëthis(
	`BigDecimÆ
(x).
	`£tSˇÀ
(0, 
BigDecimÆ
.
RoundögMode
.
HALF_UP
).
toBigI¡
)

43 
obje˘
 
Resour˚I¡
 {

44 
def
 
	`≠∂y
(
x
: 
DoubÀ
Ë
√w
 
	`Resour˚I¡
(x)

45 
	}
}

50 
föÆ
 
˛ass
 
	$Resour˚Re„ªn˚
(
vÆue
: 
Såög
Ë
exãnds
 
Resour˚VÆue


51 
föÆ
 
˛ass
 
	$Resour˚Alüs
(
vÆue
: 
Såög
Ë
exãnds
 
Resour˚VÆue


52 
föÆ
 
˛ass
 
	$Resour˚M≠
(
vÆue
: 
M≠
[
Såög
, 
Seq
[
Resour˚VÆue
]], 
œbñs
: Seq[Såög] = 
Nû
Ë
exãnds
 ResourceValue

55 
˛ass
 
	$Bödög
(
devi˚
: 
O±i⁄
[
Devi˚
], 
vÆue
: 
Resour˚VÆue
)

56 
˛ass
 
	$Resour˚Bödögs
(
m≠
: 
M≠
[
Såög
, 
Seq
[
Bödög
]] = M≠.
em±y
)

58 
def
 
	`≠∂y
(
key
: 
Såög
): 
Seq
[
Bödög
] = 
m≠
.
	`gëOrEl£
(key, 
Nû
)

59 
	}
}

65 
˛ass
 
	$Des¸ùti⁄
(
«me
: 
Såög
, 
m≠pög
: 
M≠
[Såög, 
Seq
[
Resour˚VÆue
]])

67 
ab°ø˘
 cœs†
	cDevi˚


69 
def
 
	$des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄


71 
def
 
∑ª¡
: 
O±i⁄
[
Devi˚
] = 
N⁄e


74 
vÆ
 
œbñ
 = "L" + 
Devi˚
.
ödex
.
toSåög


75 
Devi˚
.
ödex
 = Device.index + 1

78 
ab°ø˘
 cœs†
	cDevi˚Snù≥t
 
exãnds
 
Devi˚


80 
föÆ
 
def
 
	`des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
Ë
	$des¸ibe
()

81 
def
 
	$des¸ibe
(): 
Des¸ùti⁄


83 
Resour˚Bödög
 { 
	`Resour˚
(
this
, "exi°s").
	`böd
(
	`Resour˚Såög
("yes")) }

84 
	}
}

86 
obje˘
 
	gDevi˚


88 
¥iv©e
 
v¨
 
	gödex
: 
I¡
 = 0

89 
def
 
skùIndexes
(
x
: 
I¡
Ë{ 
ödex
 += x }

93 
åaô
 
Devi˚I¡îru±s


95 
this
: 
Devi˚
 =>

98 
vÆ
 
ÆwaysExãnded
 = 
Ál£


99 
def
 
des¸ibeI¡îru±s
(
ªsour˚s
: 
Resour˚Bödögs
): 
M≠
[
Såög
, 
Seq
[
Resour˚VÆue
]] = {

100 
vÆ
 
ªsour˚s
("int")

102 .
f‹óch
 { 
b
 => 
ªquúe
 (b.
devi˚
.
isDeföed
, "Device ${devname}Öroperty 'int' is missing user device") }

103 
vÆ
 
	g∑ª¡s
 = .
m≠
(
_
.
devi˚
.
gë
).
di°ö˘


104 
vÆ
 
sim∂e
 = 
∑ª¡s
.
size
 =1 && !
ÆwaysExãnded


106 
vÆ
 
∑ª¡
 =

107 i‡(!
sim∂e
Ë
N⁄e
 

108 
Some
("öãºu±-∑ª¡" -> 
Seq
(
Resour˚Re„ªn˚
(
∑ª¡s
.
hód
.
œbñ
)))

109 
vÆ
 
öãºu±s
 =

110 i‡(!
sim∂e
Ë
N⁄e
 

111 
Some
("öãºu±s" -> .
m≠
(
_
.
vÆue
))

113 
vÆ
 
öãºu±s_exãnded
 =

114 i‡(
sim∂e
 || 
∑ª¡s
.
isEm±y
Ë
N⁄e
 

115 
Some
("öãºu±s-exãnded" -> .
Ê©M≠
(
b
 => 
Seq
(
Resour˚Re„ªn˚
(b.
devi˚
.
gë
.
œbñ
), b.
vÆue
)))

117 
Li°M≠
(Ë++ 
	g∑ª¡
 ++ 
	göãºu±s
 ++ 
	göãºu±s_exãnded


120 
def
 
Seq
(
Resour˚
(
this
, "int"))

124 
åaô
 
	gDevi˚Clocks


126 
	gthis
: 
Devi˚
 =>

129 
vÆ
 
ªquúedClocks
 = 0 
to
 1

130 
def
 
des¸ibeClocks
(
ªsour˚s
: 
Resour˚Bödögs
): 
M≠
[
Såög
, 
Seq
[
Resour˚VÆue
]] = {

131 
vÆ
 
˛ocks
 = 
ªsour˚s
("˛ocks").
m≠
(
_
.
vÆue
)

132 
ªquúe
 (
ªquúedClocks
.
c⁄èös
(
˛ocks
.
size
))

133 i‡(!
˛ocks
.
isEm±y
Ë
M≠
("clocks" -> clocks) Map()

138 
åaô
 
	gDevi˚RegName


140 
	gthis
: 
Devi˚
 =>

141 
def
 
des¸ibeName
(
dev«me
: 
Såög
, 
ªsour˚s
: 
Resour˚Bödögs
): String = {

142 
vÆ
 
ªg
 = 
ªsour˚s
.
m≠
.
fûãrKeys
(
ªgFûãr
)

143 i‡(
ªg
.
isEm±y
) {

144 
dev«me


146 
vÆ
 (
«med
, 
bulk
Ë
ªg
.
∑πôi⁄
 { (
k
, 
v
Ë=> 
ªgName
(k).
isDeföed
 }

147 
vÆ
 
	gmaöªg
 = 
ªg
.
föd
(
x
 => 
ªgName
(x.
_1
Ë="c⁄åﬁ").
gëOrEl£
‘eg.
hód
).
_2


148 
ªquúe
 (!
maöªg
.
isEm±y
, 
s
"reg binding for $devname isÉmpty!")

149 
	gmaöªg
.
	ghód
.
vÆue
 
	gm©ch
 {

150 
	gx
: 
Resour˚Addªss
 => 
s
"${devname}@${x.address.head.base.toString(16)}"

151 
_
 => 
ªquúe
(
Ál£
, 
s
"Device hasÅhe wrongÅype of 'reg'Öroperty (${reg.head})"); ""

156 
def
 
ªg
(
«me
: 
Såög
): 
Seq
[
Resour˚
] = Seq(Resour˚(
this
, "reg/" +Çame))

157 
def
 
	gªg
: 
Seq
[
Resour˚
] = Seq(Resour˚(
this
, "reg"))

159 
def
 
ªgFûãr
(
«me
: 
Såög
): 
Boﬁón
 =Çamê="ªg" ||Çame.
èke
(4) == "reg/"

160 
def
 
ªgName
(
«me
: 
Såög
): 
O±i⁄
[String] = {

161 
vÆ
 
keys
 = 
«me
.
•lô
("/")

162 
ªquúe
 (
keys
.
size
 >1 && keys.sizê<2 && keys(0Ë="ªg", 
s
"InvalidÑegÇame '${name}'")

163 i‡(
	gkeys
.
	gsize
 =1Ë
N⁄e
 
Some
(
keys
(1))

171 
˛ass
 
	$Sim∂eDevi˚
(
dev«me
: 
Såög
, 
devcom∑t
: 
Seq
[Såög]Ë
exãnds
 
Devi˚


172 
wôh
 
Devi˚I¡îru±s


173 
wôh
 
Devi˚Clocks


174 
wôh
 
Devi˚RegName


176 
ovîride
 
def
 
∑ª¡
 = 
	`Some
(
Resour˚Anch‹s
.
soc
)

177 
def
 
	`des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

178 
vÆ
 
«me
 = 
	`des¸ibeName
(
dev«me
, 
ªsour˚s
)

179 
vÆ
 
	`des¸ibeI¡îru±s
(
ªsour˚s
)

180 
vÆ
 
˛ocks
 = 
	`des¸ibeClocks
(
ªsour˚s
)

182 
def
 
	`›tDef
(
x
: 
Såög
, 
£q
: 
Seq
[
Resour˚VÆue
]Ëi‡(£q.
isEm±y
Ë
N⁄e
 
	`Some
(x -> seq)

183 
vÆ
 
com∑t
 = 
	`›tDef
("com∑tibÀ", 
devcom∑t
.
	`m≠
(
	`Resour˚Såög
(
_
)))

185 
vÆ
 
ªg
 = 
ªsour˚s
.
m≠
.
	`fûãrKeys
(
ªgFûãr
)

186 
	`vÆ
 (
«med
, 
bulk
Ë
ªg
.
∑πôi⁄
 { (
k
, 
v
Ë=> 
	`ªgName
(k).
isDeföed
 }

188 
«med
.
f‹óch
 {

189 (
k
, 
	`Seq
(
	`Bödög
(
_
, 
vÆue
: 
Resour˚Addªss
))) =>

190 
vÆ
 
ønges
 = 
AddªssR™ge
.
	`‰omSës
(
vÆue
.
addªss
)

191 
	`ªquúe
 (
ønges
.
size
 =1, 
s
"DTS device $name has $k = $ranges, must beá singleÑange!")

192 (
k
, 
£q
) =>

193 
	`ªquúe
 (
Ál£
, 
s
"DTS device $name has $k = $seq, must beá single ResourceAddress!")

196 
vÆ
 
«mes
 = 
	`›tDef
("ªg-«mes", 
«med
.
	`m≠
(
x
 => 
	`Resour˚Såög
(
	`ªgName
(x.
_1
).
gë
)).
toLi°
)

197 
vÆ
 
ªgs
 = 
	`›tDef
("ªg", (
«med
 ++ 
bulk
).
	`Ê©M≠
(
_
.
_2
.
	`m≠
(_.
vÆue
)).
toLi°
)

199 
	`Des¸ùti⁄
(
«me
, 
	`Li°M≠
(Ë++ 
com∑t
 ++ ++ 
˛ocks
 ++ 
«mes
 ++ 
ªgs
)

201 
	}
}

208 
˛ass
 
	$Sim∂eBus
(
dev«me
: 
Såög
, 
devcom∑t
: 
Seq
[Såög], 
off£t
: 
BigI¡
 = 0Ë
exãnds
 
	`Sim∂eDevi˚
(dev«me, devcom∑à++ 
	`Seq
("simple-bus"))

210 
ovîride
 
def
 
	`des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

211 
vÆ
 
ønges
 = 
	`ªsour˚s
("ønges").
cﬁÀ˘
 {

212 
	`Bödög
(
_
, 
a
: 
Resour˚Addªss
Ë=> 
	`Resour˚M≠pög
◊.
addªss
, 
off£t
,á.
≥rmissi⁄s
)

214 
	`ªquúe
 (!
ønges
.
isEm±y
, 
s
"SimpleBus $devname must setÑanges")

216 
vÆ
 
m≠
 = 
AddªssR™ge
.
	`‰omSës
(
ønges
.
	`Ê©M≠
(
_
.
addªss
))

217 
vÆ
 
möBa£
 = 
m≠
.
	`m≠
(
_
.
ba£
).
mö


218 
vÆ
 
maxBa£
 = 
m≠
.
	`m≠
(
_
.
íd
).
max


219 
vÆ
 
maxSize
 = 
m≠
.
	`m≠
(
_
.
size
).
max


221 
def
 
	`ofI¡
(
x
: 
I¡
Ë
	`Seq
(
	`Resour˚I¡
(
	`BigI¡
(x)))

222 
vÆ
 
exåa
 = 
	`M≠
(

223 "#addªss-˚Œs" -> 
	`ofI¡
((
	`log2Ceû
(
maxBa£
) + 31) / 32),

224 "#size-˚Œs" -> 
	`ofI¡
((
	`log2Ceû
(
maxSize
) + 31) / 32),

225 "ønges" -> 
ønges
)

227 
vÆ
 
	`Des¸ùti⁄
(
_
, 
m≠pög
Ë
su≥r
.
	`des¸ibe
(
ªsour˚s
)

228 
	`Des¸ùti⁄
(
s
"${dev«me}@${möBa£.toSåög(16)}", 
m≠pög
 ++ 
exåa
)

231 
def
 
ønges
 = 
	`Seq
(
	`Resour˚
(
this
, "ranges"))

232 
	}
}

235 ˛as†
	cMem‹yDevi˚
 
exãnds
 
Devi˚
 
wôh
 
	mDevi˚RegName


237 
def
 
	$des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

238 
	`Des¸ùti⁄
(
	`des¸ibeName
("mem‹y", 
ªsour˚s
), 
	`Li°M≠
(

239 "ªg" -> 
ªsour˚s
.
m≠
.
	`fûãrKeys
(
ªgFûãr
).
	`Ê©M≠
(
_
.
_2
).
	`m≠
(_.
vÆue
).
toLi°
,

240 "devi˚_ty≥" -> 
	`Seq
(
	`Resour˚Såög
("memory"))))

242 
	}
}

244 
˛ass
 
	$Resour˚
(
ow√r
: 
Devi˚
, 
key
: 
Såög
)

246 
def
 
	`böd
(
u£r
: 
Devi˚
, 
vÆue
: 
Resour˚VÆue
) {

247 
vÆ
 
sc›e
 = 
BödögSc›e
.
a˘ive
.
gë


248 
sc›e
.
ªsour˚Bödögs
 = (
this
, 
	`Some
(
u£r
), 
vÆue
) +: scope.resourceBindings

250 
def
 
	`böd
(
vÆue
: 
Resour˚VÆue
) {

251 
vÆ
 
sc›e
 = 
BödögSc›e
.
a˘ive
.
gë


252 
sc›e
.
ªsour˚Bödögs
 = (
this
, 
N⁄e
, 
vÆue
) +: scope.resourceBindings

254 
	}
}

257 
åaô
 
BödögSc›e


259 
this
: 
LazyModuÀ
 =>

261 
¥iv©e
 
vÆ
 
∑ª¡Sc›e
 = 
BödögSc›e
.
föd
(
∑ª¡
)

262 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
ªsour˚BödögFns
: 
Seq
[(Ë=> 
Unô
] = 
Nû


263 
¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
ªsour˚Bödögs
: 
Seq
[(
Resour˚
, 
O±i⁄
[
Devi˚
], 
	gResour˚VÆue
)] = 
Nû


265 
¥iv©e
 
˛ass
 
Ex∑ndedVÆue
(
∑th
: 
Seq
[
Såög
], 
œbñs
: Seq[Såög], 
vÆue
: Seq[
Resour˚VÆue
])

266 
¥iv©e
 
œzy
 
vÆ
 
evÆ
: 
Unô
 = {

267 
ªquúe
 (!
LazyModuÀ
.
sc›e
.
isDeföed
, "MayÇotÉvaluate binding while still constructing LazyModules")

268 
∑ª¡Sc›e
.
f‹óch
 { 
_
.
evÆ
 }

269 
ªsour˚Bödögs
 = 
∑ª¡Sc›e
.
m≠
(
_
.ªsour˚Bödögs).
gëOrEl£
(
Nû
)

270 
BödögSc›e
.
a˘ive
 = 
Some
(
this
)

271 
ªsour˚BödögFns
.
ªvî£
.
f‹óch
 { 
_
() }

272 
BödögSc›e
.
a˘ive
 = 
N⁄e


273 
ªsour˚BödögFns
 = 
Nû


276 
¥iv©e
 
def
 
makeTªe
(
li°
: 
Seq
[
Ex∑ndedVÆue
]): Seq[
Resour˚VÆue
] = {

277 
vÆ
 (
vÆues_p
, 
keys_p
Ë
li°
.
∑πôi⁄
(
_
.
∑th
.
isEm±y
)

278 
vÆ
 
vÆues
 = 
vÆues_p
.
Ê©M≠
(
_
.
vÆue
)

279 
vÆ
 
œbñs
 = 
vÆues_p
.
Ê©M≠
(
_
.labels)

280 
vÆ
 
keys
 = 
keys_p
.
groupBy
(
_
.
∑th
.
hód
).
toLi°
.
m≠
 { (
key
, 
£q
) =>

281 (
key
 -> 
makeTªe
(
£q
.
m≠
 { 
x
 => x.
c›y
(
∑th
 = x.∑th.
èû
) }))

283 i‡(
	gœbñs
.
	gisEm±y
 && 
	gkeys
.isEm±yË
vÆues
 
Resour˚M≠
(
S‹ãdM≠
(
keys
:
_
*), 
œbñs
) +: values

286 
¥iv©e
 
def
 
ex∑nd
(
∑th
: 
Seq
[
Såög
], 
vÆues
: Seq[
Resour˚VÆue
]): Seq[
Ex∑ndedVÆue
] = {

287 
Ex∑ndedVÆue
(
∑th
, 
Nû
, Nil) +:

288 
vÆues
.
Ê©M≠
 {

289 
Resour˚M≠
(
m≠
, 
œbñs
) =>

290 
Ex∑ndedVÆue
(
∑th
, 
œbñs
, 
Nû
) +:

291 
m≠
.
toLi°
.
Ê©M≠
 { (
key
, 
	gvÆues
Ë=> 
ex∑nd
(
∑th
 :+ key, 
vÆues
) }

292 
	gz
 => 
Seq
(
Ex∑ndedVÆue
(
∑th
, 
Nû
, Seq(
z
)))

296 
¥iv©e
 
def
 
cﬁÀ˘
(
skùRoŸ
: 
I¡
, 
∑th
: 
Li°
[
Såög
], 
off£t
: 
BigI¡
, 
m≠
: 
Resour˚M≠
): Li°[(Såög, 
Resour˚Addªss
)] = {

298 
vÆ
 
«me
 = 
∑th
.
hódO±i⁄
.
gëOrEl£
("/")

299 
def
 
shi·
(
x
: 
Seq
[
AddªssSë
]Ëx.
m≠
(
a
 =>á.
c›y
(
ba£
 =á.ba£ + 
off£t
))

300 
vÆ
 
addªs£s
: 
Li°
[(
Såög
, 
Resour˚Addªss
)] = 
m≠
.
vÆue
.
toLi°
.
Ê©M≠
 { (
_
, 
£q
Ë=> seq.
cﬁÀ˘
 {

301 
y
: 
Resour˚Addªss
 => (
«me
 -> y.
c›y
(
addªss
 = 
shi·
(y.address)))

304 
vÆ
 
haveChûdAddªs£s
 = 
m≠
.
vÆue
.
vÆues
.
exi°s
(
_
.exists {

305 
x
: 
Resour˚M≠
 => x.
vÆue
.
c⁄èös
("reg") || x.value.contains("ranges")

306 
_
 => 
Ál£


308 
def
 
m≠Chûdªn
(
off£t
: 
BigI¡
Ë
m≠
.
vÆue
.
toLi°
.
Ê©M≠
 { (
key
, 
£q
Ë=> seq.
cﬁÀ˘
 {

309 
m≠
: 
Resour˚M≠
 => 
cﬁÀ˘
(
skùRoŸ
, 
key
 :: 
∑th
, 
off£t
, map)

310 }.
	gÊ©ãn
 }

312 
vÆ
 
	gchûdAddªs£s
 = 
m≠
.
vÆue
.
li·
("ønges"Ë
m©ch
 {

314 
N⁄e
 
∑th
.
size
 < 
skùRoŸ
 => 
m≠Chûdªn
(
off£t
)

316 
N⁄e
 => 
Nû


318 
Some
(
Nû
Ë=> 
m≠Chûdªn
(
off£t
)

320 
Some
(
£q
Ë!
haveChûdAddªs£s
 => seq.
cﬁÀ˘
 {

321 
Resour˚M≠pög
(
addr
, 
_
, 
≥rm
Ë=> (
«me
 -> 
Resour˚Addªss
(
shi·
(addr),Öerm))

324 
Some
(
Seq
(
Resour˚M≠pög
(
addr
, 
dñè
, 
≥rm
))Ë=> 
m≠Chûdªn
(
off£t
+delta)

326 
x
 => { 
ªquúe
(
Ál£
, 
s
"U√x≥˘ed vÆuêöÑ™ge†key: ${x}"); 
	gNû
 }

328 
	gaddªs£s
 ++ 
	gchûdAddªs£s


332 
def
 
	gbödögTªe
: 
Resour˚M≠
 = {

333 
evÆ


334 
vÆ
 
m≠
: 
M≠
[
Devi˚
, 
Resour˚Bödögs
] =

335 
ªsour˚Bödögs
.
ªvî£
.
groupBy
(
_
.
_1
.
ow√r
).
m≠VÆues
(
£q
 => 
Resour˚Bödögs
(

336 
£q
.
groupBy
(
_
.
_1
.
key
).
m≠VÆues
(_.
m≠
(
z
 => 
Bödög
(z.
_2
, z.
_3
)).
di°ö˘
)))

337 
vÆ
 
	gdescs
: 
HashM≠
[
Devi˚
, 
Des¸ùti⁄
] = HashM≠.
em±y


338 
def
 
gëDesc
(
dev
: 
Devi˚
): 
Des¸ùti⁄
 = {

339 i‡(
descs
.
c⁄èös
(
dev
)) {

340 
descs
(
dev
)

342 
vÆ
 
bödögs
 = 
m≠
.
li·
(
dev
).
gëOrEl£
(
Resour˚Bödögs
())

343 
vÆ
 
Des¸ùti⁄
(
«me
, 
m≠pög
Ë
dev
.
des¸ibe
(
bödögs
)

344 
vÆ
 
fuŒName
 = 
dev
.
∑ª¡
 
m©ch
 {

345 
N⁄e
 => 
«me


346 
Some
(
∑ª¡
Ë=> 
gëDesc
’¨ít).
«me
 + "/" +Çame

348 
vÆ
 
	gdesc
 = 
Des¸ùti⁄
(
fuŒName
, 
m≠pög
)

349 
	gdescs
 +((
dev
, 
	gdesc
))

350 
	gdesc


353 
	gm≠
.
	gkeys
.
f‹óch
(
gëDesc
)

354 
vÆ
 
	gåì
 = 
makeTªe
(
descs
.
toLi°
.
Ê©M≠
 { (
d
, 
Des¸ùti⁄
(
«me
, 
m≠pög
)) =>

355 
vÆ
 
tokís
 = 
«me
.
•lô
("/").
toLi°


356 
ex∑nd
(
tokís
, 
Seq
(
Resour˚M≠
(
m≠pög
, Seq(
d
.
œbñ
)))) })

357 
Resour˚M≠
(
S‹ãdM≠
("/" -> 
åì
))

361 
def
 
	gcﬁÀ˘Resour˚Addªs£s
 = 
cﬁÀ˘
(2, 
Nû
, 0, 
bödögTªe
)

364 
obje˘
 
	gBödögSc›e


366 
	g¥Ÿe˘ed
[
dùlomacy
] 
v¨
 
	ga˘ive
: 
O±i⁄
[
BödögSc›e
] = 
N⁄e


367 
¥Ÿe˘ed
[
dùlomacy
] 
def
 
föd
(
m
: 
O±i⁄
[
LazyModuÀ
] = LazyModuÀ.
sc›e
): O±i⁄[
BödögSc›e
] = m.
Ê©M≠
 {

368 
x
: 
BödögSc›e
 => 
föd
(x.
∑ª¡
).
‹El£
(
Some
(x))

369 
x
 => 
föd
(x.
∑ª¡
)

373 
obje˘
 
Resour˚Bödög


378 
def
 
≠∂y
(
block
: => 
Unô
) {

379 
vÆ
 
sc›e
 = 
BödögSc›e
.
föd
()

380 
ªquúe
 (
sc›e
.
isDeföed
, "ResourceBinding must be called from withiná BindingScope")

381 
	gsc›e
.
	ggë
.
	gªsour˚BödögFns
 = { (Ë=> 
block
 } +: 
sc›e
.
gë
.
ªsour˚BödögFns


385 
obje˘
 
Resour˚Anch‹s


387 
vÆ
 
roŸ
 = 
√w
 
Devi˚
 {

388 
def
 
des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

389 
vÆ
 
width
 = 
ªsour˚s
("width").
m≠
(
_
.
vÆue
)

390 
vÆ
 
modñ
 = 
ªsour˚s
("modñ").
m≠
(
_
.
vÆue
)

391 
vÆ
 
com∑t
 = 
ªsour˚s
("com∑t").
m≠
(
_
.
vÆue
)

392 
Des¸ùti⁄
("/", 
M≠
(

393 "#addªss-˚Œs" -> 
width
,

394 "#size-˚Œs" -> 
width
,

395 "modñ" -> 
modñ
,

396 "com∑tibÀ" -> 
com∑t
))

400 
vÆ
 
	gsoc
 = 
√w
 
Devi˚
 {

401 
def
 
des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

402 
vÆ
 
width
 = 
ªsour˚s
("width").
m≠
(
_
.
vÆue
)

403 
vÆ
 
com∑t
 = 
ªsour˚s
("com∑t").
m≠
(
_
.
vÆue
Ë:+ 
Resour˚Såög
("simple-bus")

404 
Des¸ùti⁄
("soc", 
M≠
(

405 "#addªss-˚Œs" -> 
width
,

406 "#size-˚Œs" -> 
width
,

407 "com∑tibÀ" -> 
com∑t
,

408 "ønges" -> 
Nû
))

412 
vÆ
 
	g˝us
 = 
√w
 
Devi˚
 {

413 
def
 
des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

414 
vÆ
 
width
 = 
ªsour˚s
("width").
m≠
(
_
.
vÆue
)

415 
Des¸ùti⁄
("˝us", 
M≠
(

416 "#addªss-˚Œs" -> 
width
,

417 "#size-˚Œs" -> 
Seq
(
Resour˚I¡
(0))))

421 
vÆ
 
	gÆü£s
 = 
√w
 
Devi˚
 {

422 
def
 
des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 =

423 
Des¸ùti⁄
("Æü£s", 
M≠
() ++

424 
ªsour˚s
("u¨t").
zùWôhIndex
.
m≠
 { (
Bödög
(
_
, 
vÆue
), 
i
) =>

425 (
s
"£rül${i}" -> 
Seq
(
vÆue
))})

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/SRAM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
Des¸ibedSRAM


9 
ab°ø˘
 
˛ass
 
	$Dùlom©icSRAM
(

10 
addªss
: 
AddªssSë
,

11 
bótByãs
: 
I¡
,

12 
devName
: 
O±i⁄
[
Såög
])(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
devi˚
 = 
devName


15 .
	`m≠
(
√w
 
	`Sim∂eDevi˚
(
_
, 
	`Seq
("sifive,sram0")))

16 .
	`gëOrEl£
(
√w
 
	`Mem‹yDevi˚
())

18 
vÆ
 
ªsour˚s
 = 
devi˚
.
	`ªg
("mem")

20 
def
 
	`bigBôs
(
x
: 
BigI¡
, 
èû
: 
Li°
[
Boﬁón
] = 
Nû
): List[Boolean] =

21 i‡(
x
 =0Ë
èû
.
ªvî£
 
	`bigBôs
(x >> 1, ((x & 1) == 1) ::Åail)

23 
def
 
mask
: 
Li°
[
Boﬁón
] = 
	`bigBôs
(
addªss
.mask >> 
	`log2Ceû
(
bótByãs
))

26 
def
 
	`makeSögÀP‹ãdByãWrôeSeqMem
(
size
: 
I¡
, 
œ√s
: I¡ = 
bótByãs
, 
bôs
: Int = 8) = {

28 
vÆ
 
mem
 = 
	`Des¸ibedSRAM
(

29 
«me
 = 
devName
.
	`gëOrEl£
("mem"),

30 
desc
 = 
devName
.
	`gëOrEl£
("mem"),

31 
size
 = size,

32 
d©a
 = 
	`Vec
(
œ√s
, 
	`UI¡
(
width
 = 
bôs
))

34 
devName
.
	`f‹óch
(
n
 => 
mem
.
	`sugge°Name
“.
	`•lô
("-").
œ°
))

35 
mem


37 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ValName.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
dùlomacy


5 
imp‹t
 
	gsˇœ
.
	gœnguage
.
	gex≥rimíèl
.
ma¸os


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gma¸os
.
VÆNameIm∂


8 ˛as†
	cVÆName
(
«me
: 
Såög
)

10 
obje˘
 
VÆName


12 
im∂icô
 
def
 
	$m©îülize
(
im∂icô
 
x
: 
VÆNameIm∂
): 
VÆName
 = 
	`VÆName
(x.
«me
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.{
	gSour˚Info
, 
	gSour˚Löe
, 
	gU∆oˇèbÀSour˚Info
}

6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	gsˇœ
.
	gœnguage
.
im∂icôC⁄vîsi⁄s


9 
∑ckage
 
obje˘
 
	gdùlomacy


11 
ty≥
 
	gSim∂eNodeH™dÀ
[
D
, 
U
, 
E
, 
B
 <: 
Chi£l
.
D©a
] = 
NodeH™dÀ
[D, U, E, B, D, U, E, B]

13 
def
 
sour˚Löe
(
sour˚Info
: 
Sour˚Info
, 
¥efix
: 
Såög
 = " (", 
suffix
: Såög = ")"Ësour˚Infÿ
m©ch
 {

14 
Sour˚Löe
(
fûíame
, 
löe
, 
cﬁ
Ë=> 
s
"$prefix$filename:$line:$col$suffix"

15 
_
 => ""

18 
def
 
bôIndexes
(
x
: 
BigI¡
, 
èû
: 
Seq
[
I¡
] = 
Nû
): Seq[Int] = {

19 
ªquúe
 (
x
 >= 0)

20 i‡(
x
 == 0) {

21 
èû
.
ªvî£


23 
vÆ
 
lowe°
 = 
x
.
lowe°SëBô


24 
bôIndexes
(
x
.
˛órBô
(
lowe°
),Üowe° +: 
èû
)

28 
im∂icô
 cœs†
	cBigI¡HexC⁄ãxt
(
vÆ
 
sc
: 
SåögC⁄ãxt
Ë
exãnds
 
AnyVÆ
 {

29 
def
 
	`x
(
¨gs
: 
Any
*): 
BigI¡
 = {

30 
vÆ
 
‹ig
 = 
sc
.
	`s
(
¨gs
: 
_
*)

31 
	`BigI¡
(
‹ig
.
	`ª∂a˚
("_", ""), 16)

33 
	}
}

35 
ty≥
 
	gPr›îtyO±i⁄
 = 
O±i⁄
[(
Såög
, 
Seq
[
Resour˚VÆue
])]

36 
ty≥
 
	gPr›îtyM≠
 = 
IãøbÀ
[(
Såög
, 
Seq
[
Resour˚VÆue
])]

38 
im∂icô
 cœs†
	cI¡ToPr›îty
(
x
: 
I¡
) {

39 
def
 
asPr›îty
: 
Seq
[
Resour˚VÆue
] = 
	`Seq
(
	`Resour˚I¡
(
	`BigI¡
(
x
)))

40 
	}
}

42 
im∂icô
 cœs†
	cBigI¡ToPr›îty
(
x
: 
BigI¡
) {

43 
def
 
asPr›îty
: 
Seq
[
Resour˚VÆue
] = 
	`Seq
(
	`Resour˚I¡
(
x
))

44 
	}
}

46 
im∂icô
 cœs†
	cSåögToPr›îty
(
x
: 
Såög
) {

47 
def
 
asPr›îty
: 
Seq
[
Resour˚VÆue
] = 
	`Seq
(
	`Resour˚Såög
(
x
))

48 
	}
}

50 
im∂icô
 cœs†
	cDevi˚ToPr›îty
(
x
: 
Devi˚
) {

51 
def
 
asPr›îty
: 
Seq
[
Resour˚VÆue
] = 
	`Seq
(
	`Resour˚Re„ªn˚
(
x
.
œbñ
))

52 
	}
}

54 
def
 
E«bÀM⁄ô‹s
[
T
](
body
: 
P¨amëîs
 => T)(
im∂icô
 
p
: P¨amëîsËbody’.
ÆãrP¨tül
 {

55 
M⁄ô‹sE«bÀd
 => 
åue


57 
def
 
DißbÀM⁄ô‹s
[
T
](
body
: 
P¨amëîs
 => T)(
im∂icô
 
p
: P¨amëîsËbody’.
ÆãrP¨tül
 {

58 
M⁄ô‹sE«bÀd
 => 
Ál£


60 
def
 
FlùRídîög
[
T
](
body
: 
P¨amëîs
 => T)(
im∂icô
 
p
: P¨amëîsËbody’.
ÆãrP¨tül
 {

61 
RídîFlù≥d
 => !
p
(RenderFlipped)

64 
im∂icô
 
def
 
moduÀVÆue
[
T
](
vÆue
: 
ModuÀVÆue
[T]): T = vÆue.
gëWøµedVÆue


66 
im∂icô
 
def
 
	$noCrossög
(
vÆue
: 
NoCrossög
.
ty≥
): 
ClockCrossögTy≥
 = 
	`Synchr⁄ousCrossög
(
Buf„rP¨ams
.
n⁄e
)

67 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Configs.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
C⁄fig


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.{
	gDCacheP¨ams
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.{
	gMaxH¨tIdBôs
, 
	gXLí
}

14 
˛ass
 
Tø˚GíC⁄fig
 
exãnds
 
C⁄fig
(
√w
 
WôhTø˚Gí
(
Li°
.
	$fûl
(2){ 
	`DCacheP¨ams
(
nSës
 = 16, 
nWays
 = 1Ë
	}
}Ë++ 
√w
 
Ba£Subsy°emC⁄fig
)

16 
˛ass
 
Tø˚GíBuf„æessC⁄fig
 
exãnds
 
C⁄fig
(
√w
 
WôhBuf„æessBrﬂdˇ°Hub
 ++Çew 
Tø˚GíC⁄fig
)

20 
˛ass
 
	$WôhTø˚Gí
(
∑øms
: 
Seq
[
DCacheP¨ams
], 
nReqs
: 
I¡
 = 8192Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

21 
GroundTe°TûesKey
 => 
∑øms
.
m≠
 { 
d˝
 => 
	`Tø˚GíP¨ams
(

22 
dˇche
 = 
	`Some
(
d˝
),

23 
w‹dBôs
 = 
	`sôe
(
XLí
),

24 
addrBôs
 = 32,

25 
addrBag
 = {

26 
vÆ
 
nSës
 = 2

27 
vÆ
 
nWays
 = 1

28 
vÆ
 
blockOff£t
 = 
	`sôe
(
Sy°emBusKey
).blockOffset

29 
vÆ
 
nBóts
 = 
	`sôe
(
Sy°emBusKey
).
blockBóts


30 
Li°
.
	`èbuœã
(4 * 
nWays
Ë{ 
i
 =>

31 
Seq
.
	`èbuœã
(
nBóts
Ë{ 
j
 => 
	`BigI¡
((j * 8Ë+ ((
i
 * 
nSës
Ë<< 
blockOff£t
)) }

32 }.
Ê©ãn


34 
maxReque°s
 = 
nReqs
,

35 
memSèπ
 = 
	`sôe
(
ExtMem
).
gë
.
ma°î
.
ba£
,

36 
numGís
 = 
∑øms
.
size
)

38 
MaxH¨tIdBôs
 => 
	`log2Up
(
∑øms
.
size
)

39 
	}
})

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/DummyPTW.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


6 
imp‹t
 
	gChi£l
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
C‹eModuÀ


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
P¨amëîizedBundÀ


13 ˛as†
	cDummyPTW
(
n
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
) {

14 
vÆ
 
io
 = 
√w
 
BundÀ
 {

15 
vÆ
 
ªque°‹s
 = 
	`Vec
(
n
, 
√w
 
TLBPTWIO
).
Êù


18 
vÆ
 
ªq_¨b
 = 
	`ModuÀ
(
√w
 
	`RRArbôî
(
	`VÆid
“ew 
PTWReq
), 
n
))

19 
ªq_¨b
.
io
.
ö
 <> io.
ªque°‹s
.
	$m≠
(
_
.
ªq
)

20 
ªq_¨b
.
io
.
out
.
ªady
 :
	$Boﬁ
(
åue
)

22 
def
 
	$v≤_to_µn
(
v≤
: 
UI¡
): UI¡ = 
	`v≤
(
µnBôs
 - 1, 0)

24 ˛as†
	cQueueCh™√l
 
exãnds
 
	$P¨amëîizedBundÀ
()(
p
) {

25 
vÆ
 
µn
 = 
	`UI¡
(
width
 = 
µnBôs
)

26 
vÆ
 
cho£n
 = 
	`UI¡
(
width
 = 
	`log2Up
(
n
))

27 
	}
}

29 
vÆ
 
	gs1_µn
 = 
	$v≤_to_µn
(
ªq_¨b
.
io
.
out
.
bôs
.bôs.
addr
)

30 
vÆ
 
s2_µn
 = 
	$RegE«bÀ
(
s1_µn
, 
ªq_¨b
.
io
.
out
.
vÆid
)

31 
vÆ
 
s2_cho£n
 = 
	$RegE«bÀ
(
ªq_¨b
.
io
.
cho£n
,Ñeq_¨b.io.
out
.
vÆid
)

32 
vÆ
 
s2_vÆid
 = 
	$Reg
(
√xt
 = 
ªq_¨b
.
io
.
out
.
vÆid
 &&Ñeq_¨b.io.out.
bôs
.valid)

34 
vÆ
 
s2_ª•
 = 
	`Wúe
(
öô
 = 0.U.a
	$sTy≥Of
(
√w
 
PTWRe•
))

35 
s2_ª•
.
±e
.
µn
 :
s2_µn


36 
s2_ª•
.
±e
.
ª£rved_f‹_so·w¨e
 :
	$UI¡
(0)

37 
s2_ª•
.
Àvñ
 :
	`UI¡
(
pgLevñs
-1)

38 
s2_ª•
.
±e
.
d
 :
	$Boﬁ
(
åue
)

39 
s2_ª•
.
±e
.
a
 :
	$Boﬁ
(
åue
)

40 
s2_ª•
.
±e
.
g
 :
	$Boﬁ
(
Ál£
)

41 
s2_ª•
.
±e
.
u
 :
	$Boﬁ
(
åue
)

42 
s2_ª•
.
±e
.
r
 :
	$Boﬁ
(
åue
)

43 
s2_ª•
.
±e
.
w
 :
	$Boﬁ
(
åue
)

44 
s2_ª•
.
±e
.
x
 :
	$Boﬁ
(
Ál£
)

45 
s2_ª•
.
±e
.
v
 :
	$Boﬁ
(
åue
)

47 
io
.
ªque°‹s
.
zùWôhIndex
.
f‹óch
 { (
ªque°‹
, 
i
) =>

48 
ªque°‹
.
ª•
.
vÆid
 :
s2_vÆid
 && 
s2_cho£n
 ==
	`UI¡
(
i
)

49 
ªque°‹
.
ª•
.
bôs
 :
s2_ª•


50 
ªque°‹
.
°©us
 :0.U.a
	`sTy≥Of
(requestor.status)

51 
ªque°‹
.
±br
.
mode
 :ªque°‹.±br.
	`pgLevñsToMode
(
pgLevñs
).
U


52 
ªque°‹
.
±br
.
asid
 :
	`UI¡
(0)

53 
ªque°‹
.
±br
.
µn
 :
	`UI¡
(0)

54 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Generator.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
Gíî©‹Aµ


7 
obje˘
 
Gíî©‹
 
exãnds
 
	gGíî©‹Aµ
 {

8 
vÆ
 
	gl⁄gName
 = 
«mes
.
t›ModuÀProje˘
 + "." +Çames.
c⁄figs


9 
gíî©eFúπl


10 
gíî©eA¬o


11 
gíî©eTe°SuôeMake‰ags


12 
gíî©eAπeÁ˘s


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/GroundTestSubsystem.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


14 
imp‹t
 
	gsˇœ
.
	gm©h
.
max


16 
obje˘
 
TûeId
 
exãnds
 
	gFõld
[
I¡
]

18 ˛as†
	cGroundTe°Subsy°em
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
Ba£Subsy°em


19 
wôh
 
C™HaveMa°îAXI4MemP‹t


20 
wôh
 
HasPîùhîyTe°RAMSœve
 {

21 
vÆ
 
tûeP¨ams
 = 
	$p
(
GroundTe°TûesKey
)

22 
vÆ
 
tûes
 = 
tûeP¨ams
.
zùWôhIndex
.
m≠
 { (
c
, 
i
Ë=> 
	`LazyModuÀ
(

23 
c
.
	`buûd
(
i
, 
p
.
ÆãrP¨tül
 {

24 
TûeKey
 => 
c


25 
Sh¨edMem‹yTLEdge
 => 
sbus
.
busVõw


29 
tûes
.
	`Ê©M≠
(
_
.
dˇcheO±
).
f‹óch
 { 
dc
 =>

30 
sbus
.
	`‰omTûe
(
N⁄e
, 
buf„r
 = 
Buf„rP¨ams
.){ 
dc
.
node
 }

31 
	}
}

34 
I¡SökNode
(
	$I¡SökP‹tSim∂e
()Ë:
ibus
.
toPLIC


36 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`GroundTe°Subsy°emModuÀImp
(
this
)

37 
	}
}

39 
˛ass
 
GroundTe°Subsy°emModuÀImp
[+
L
 <: 
GroundTe°Subsy°em
](
_ouãr
: LË
exãnds
 
	$Ba£Subsy°emModuÀImp
(
_ouãr
)

40 
wôh
 
C™HaveMa°îAXI4MemP‹tModuÀImp
 {

41 
vÆ
 
suc˚ss
 = 
	`IO
(
	`Boﬁ
(
OUTPUT
))

43 
ouãr
.
tûes
.
zùWôhIndex
.
m≠
 { (
t
, 
i
Ë=>Å.
moduÀ
.
c⁄°™ts
.
h¨tid
 :
	`UI¡
(i) }

45 
vÆ
 
°©us
 = 
	`DebugComböî
(
ouãr
.
tûes
.
	`m≠
(
_
.
moduÀ
.status))

46 
suc˚ss
 :
°©us
.
föished


47 
	}
}

50 
åaô
 
HasPîùhîyTe°RAMSœve
 { 
this
: 
Ba£Subsy°em
 =>

51 
vÆ
 
ã°øm
 = 
LazyModuÀ
(
√w
 
TLRAM
(
AddªssSë
(0x52000000, 0xfff), 
åue
,Årue, 
pbus
.
bótByãs
))

52 
	gpbus
.
toV¨übÀWidthSœve
(
Some
("Te°RAM")Ë{ 
	gã°øm
.
	gnode
 }

56 
åaô
 
	gHasPîùhîyTe°FuzzMa°î
 { 
	gthis
: 
Ba£Subsy°em
 =>

57 
vÆ
 
fuzzî
 = 
LazyModuÀ
(
√w
 
TLFuzzî
(5000))

58 
pbus
.
‰omOthîMa°î
(
Some
("Fuzzî")Ë{ 
fuzzî
.
node
 }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
∑ckage
 
obje˘
 
	ggroundã°
 {

6 
vÆ
 
	gã°RamAddr
 = 0x10000

7 
vÆ
 
timeoutCodeBôs
 = 4

8 
vÆ
 
îr‹CodeBôs
 = 4

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Status.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
VÆidMux


8 ˛as†
	cGroundTe°Sètus
 
exãnds
 
	mBundÀ
 {

9 
vÆ
 
	mföished
 = 
	$Boﬁ
(
OUTPUT
)

10 
vÆ
 
timeout
 = 
	`VÆid
(
	$UI¡
(
width
 = 4))

11 
vÆ
 
îr‹
 = 
	`VÆid
(
	`UI¡
(
width
 = 4))

14 
obje˘
 
DebugComböî
 {

15 
def
 
	`≠∂y
(
debugs
: 
Seq
[
GroundTe°Sètus
]): GroundTestStatus = {

16 
vÆ
 
out
 = 
	`Wúe
(
√w
 
GroundTe°Sètus
)

17 
out
.
föished
 :
debugs
.
	`m≠
(
_
.föished).
	`ªdu˚
(_ && _)

18 
out
.
timeout
 :
	`VÆidMux
(
debugs
.
	`m≠
(
_
.timeout))

19 
out
.
îr‹
 :
	`VÆidMux
(
debugs
.
	`m≠
(
_
.error))

20 
out


22 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TestHarness.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
LazyModuÀ


10 ˛as†
	cTe°H¨√ss
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

11 
vÆ
 
io
 = 
√w
 
BundÀ
 { vÆ 
suc˚ss
 = 
	`Boﬁ
(
OUTPUT
) }

12 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
GroundTe°Subsy°em
).
moduÀ
)

13 
io
.
suc˚ss
 :
dut
.success

14 
dut
.
	`c⁄√˘SimAXIMem
()

15 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Tile.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.{
	gDCache
, 
	gRockëC‹eP¨ams
}

12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


14 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
Li°Buf„r


16 
åaô
 
GroundTe°TûeP¨ams
 
exãnds
 
	gTûeP¨ams
 {

17 
vÆ
 
	gmemSèπ
: 
BigI¡


18 
vÆ
 
maxReque°s
: 
I¡


19 
vÆ
 
numGís
: 
I¡


21 
def
 
buûd
(
i
: 
I¡
, 
p
: 
P¨amëîs
): 
GroundTe°Tûe


23 
vÆ
 
iˇche
 = 
N⁄e


24 
vÆ
 
btb
 = 
N⁄e


25 
vÆ
 
rocc
 = 
Nû


26 
vÆ
 
c‹e
 = 
RockëC‹eP¨ams
(
nPMPs
 = 0)

27 
vÆ
 
ˇched
 = if(
dˇche
.
isDeföed
) 1 0

28 
vÆ
 
d©aS¸©ch∑dByãs
 = 0

31 
obje˘
 
GroundTe°TûesKey
 
exãnds
 
Fõld
[
Seq
[
GroundTe°TûeP¨ams
]]

33 
ab°ø˘
 
˛ass
 
	$GroundTe°Tûe
(
∑øms
: 
GroundTe°TûeP¨ams
)

34 (
im∂icô
 
p
: 
P¨amëîs
)

35 
exãnds
 
	`Ba£Tûe
(
∑øms
, 
¸ossög
 = 
	$Synchr⁄ousCrossög
())(
p
) {

36 
vÆ
 
ötInw¨dNode
: 
I¡Inw¨dNode
 = 
	`I¡IdítôyNode
()

37 
vÆ
 
ötOutw¨dNode
: 
I¡Outw¨dNode
 = 
	`I¡IdítôyNode
()

38 
vÆ
 
¶aveNode
: 
TLInw¨dNode
 = 
	`TLIdítôyNode
()

40 
vÆ
 
dˇcheO±
 = 
∑øms
.
dˇche
.
m≠
 { 
dc
 => 
	`LazyModuÀ
(
√w
 
	`DCache
(0)) }

42 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`GroundTe°TûeModuÀImp
(
this
)

43 
	}
}

45 ˛as†
	cGroundTe°TûeModuÀImp
(
ouãr
: 
GroundTe°Tûe
Ë
exãnds
 
	$Ba£TûeModuÀImp
(
ouãr
) {

46 
vÆ
 
°©us
 = 
	$IO
(
√w
 
GroundTe°Sètus
)

47 
vÆ
 
hÆt_™d_ˇtch_fúe
 = 
N⁄e


49 
ouãr
.
dˇcheO±
 
f‹óch
 { 
dˇche
 =>

50 
vÆ
 
±w
 = 
	`ModuÀ
(
√w
 
	`DummyPTW
(1))

51 
±w
.
io
.
ªque°‹s
.
hód
 <> 
dˇche
.
moduÀ
.io.ptw

53 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TraceGen.scala

20 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
groundã°


22 
imp‹t
 
	gChi£l
.
_


23 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

24 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


25 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


26 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


27 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


59 
˛ass
 
Tø˚GíP¨ams
(

60 
dˇche
: 
O±i⁄
[
DCacheP¨ams
] = 
Some
(DCacheParams()),

61 
w‹dBôs
: 
I¡
,

62 
addrBôs
: 
I¡
,

63 
addrBag
: 
Li°
[
BigI¡
],

64 
maxReque°s
: 
I¡
,

65 
memSèπ
: 
BigI¡
,

66 
numGís
: 
I¡
Ë
exãnds
 
GroundTe°TûeP¨ams
 {

67 
def
 
buûd
(
i
: 
I¡
, 
p
: 
P¨amëîs
): 
GroundTe°Tûe
 = 
√w
 
Tø˚GíTûe
(i, 
this
)(
	gp
)

68 
vÆ
 
	gh¨tId
 = 0

69 
vÆ
 
åa˚
 = 
Ál£


70 
vÆ
 
blockîCålAddr
 = 
N⁄e


71 
vÆ
 
«me
 = 
N⁄e


74 
åaô
 
	gHasTø˚GíP¨ams
 {

75 
im∂icô
 
vÆ
 
	gp
: 
P¨amëîs


76 
vÆ
 
∑øms
: 
Tø˚GíP¨ams


77 
vÆ
 
pAddrBôs
 = 
∑øms
.
addrBôs


78 
vÆ
 
numGís
 = 
∑øms
.numGens

79 
vÆ
 
numReqsPîGí
 = 
∑øms
.
maxReque°s


80 
vÆ
 
memSèπ
 = 
∑øms
.memStart

81 
vÆ
 
memRe•Timeout
 = 8192

82 
vÆ
 
numBôsInW‹d
 = 
∑øms
.
w‹dBôs


83 
vÆ
 
numByãsInW‹d
 = 
numBôsInW‹d
 / 8

84 
vÆ
 
numBôsInW‹dOff£t
 = 
log2Up
(
numByãsInW‹d
)

85 
vÆ
 
addªssBag
 = 
∑øms
.
addrBag


86 
vÆ
 
addªssBagLí
 = 
addªssBag
.
Àngth


87 
vÆ
 
logAddªssBagLí
 = 
log2Up
(
addªssBagLí
)

88 
vÆ
 
gíExåaAddrs
 = 
Ál£


89 
vÆ
 
logNumExåaAddrs
 = 1

90 
vÆ
 
numExåaAddrs
 = 1 << 
logNumExåaAddrs


91 
vÆ
 
maxTags
 = 8

93 
ªquúe
(
numByãsInW‹d
 * 8 =
numBôsInW‹d
)

94 
ªquúe
((1 << 
logAddªssBagLí
Ë=
addªssBagLí
)

143 ˛as†
	cTagM™
(
vÆ
 
logNumTags
 : 
I¡
Ë
exãnds
 
ModuÀ
 {

144 
vÆ
 
io
 = 
√w
 
BundÀ
 {

146 
vÆ
 
avaûabÀ
 = 
	`Boﬁ
(
OUTPUT
)

148 
vÆ
 
ègOut
 = 
	`UI¡
(
OUTPUT
, 
logNumTags
)

150 
vÆ
 
èke
 = 
	`Boﬁ
(
INPUT
)

152 
vÆ
 
put
 = 
	`Boﬁ
(
INPUT
)

154 
vÆ
 
ègIn
 = 
	`UI¡
(
INPUT
, 
logNumTags
)

158 
vÆ
 
numTags
 = 1 << 
logNumTags


161 
vÆ
 
öU£
 = 
Li°
.
	$fûl
(
numTags
)(
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
)))

164 
vÆ
 
öU£M≠
 = (0 
to
 
numTags
-1).
	`m≠
(
i
 => 
	`UI¡
(i)).
	$zù
(
öU£
)

167 
vÆ
 
√xtTag
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 
logNumTags
))

168 
io
.
ègOut
 :
√xtTag


171 
io
.
avaûabÀ
 :~
	`MuxLookup
(
√xtTag
, 
	`Boﬁ
(
åue
), 
öU£M≠
)

174 
	$whí
 (
io
.
èke
) {

175 (
i
, 
b
Ë<- 
öU£M≠
) {

176 
	`whí
 (
i
 ==
√xtTag
Ë{ 
b
 :
	`Boﬁ
(
åue
) }

178 
√xtTag
 :√xtTag + 
	`UI¡
(1)

179 
	}
}

182 
	$whí
 (
io
.
put
) {

183 (
i
, 
b
Ë<- 
öU£M≠
) {

184 
	`whí
 (
i
 ==
io
.
ègIn
Ë{ 
b
 :
	`Boﬁ
(
Ál£
) }

186 
	}
}

193 ˛as†
	cTø˚Gíî©‹
(
vÆ
 
∑øms
: 
Tø˚GíP¨ams
)(
im∂icô
 vÆ 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ


194 
wôh
 
HasTø˚GíP¨ams
 {

195 
vÆ
 
io
 = 
√w
 
BundÀ
 {

196 
vÆ
 
föished
 = 
	`Boﬁ
(
OUTPUT
)

197 
vÆ
 
timeout
 = 
	`Boﬁ
(
OUTPUT
)

198 
vÆ
 
mem
 = 
√w
 
HñœCacheIO


199 
vÆ
 
h¨tid
 = 
	`UI¡
(
INPUT
, 
	`log2Up
(
numGís
))

202 
vÆ
 
tŸÆNumAddrs
 = 
addªssBag
.
size
 + 
numExåaAddrs


203 
vÆ
 
öôCou¡
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
	$log2Up
(
tŸÆNumAddrs
)))

204 
vÆ
 
öôD⁄e
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

206 
vÆ
 
ªqTimî
 = 
	`ModuÀ
(
√w
 
	$Timî
(8192, 
maxTags
))

207 
ªqTimî
.
io
.
°¨t
.
vÆid
 :io.
mem
.
ªq
.
	$fúe
()

208 
ªqTimî
.
io
.
°¨t
.
bôs
 :io.
mem
.
ªq
.bôs.
èg


209 
ªqTimî
.
io
.
°›
.
vÆid
 :io.
mem
.
ª•
.valid

210 
ªqTimî
.
io
.
°›
.
bôs
 :io.
mem
.
ª•
.bôs.
èg


218 
vÆ
 
bagOfAddrs
 = 
addªssBag
.
	`m≠
(
x
 => 
	`UI¡
(
memSèπ
 + x, 
pAddrBôs
))

220 
vÆ
 
exåaAddrs
 = 
Seq
.
	$fûl
(
numExåaAddrs
) {

221 
	`UI¡
(
memSèπ
 + 
SìdedR™dom
.
‰omSìd
.
	`√xtI¡
(1 << 16Ë* 
numByãsInW‹d
, 
pAddrBôs
)

222 
	}
}

226 
vÆ
 
øndAddrBagIndex
 = 
	$LCG
(
logAddªssBagLí
)

230 
vÆ
 
addrBagIndi˚s
 = (0 
to
 
addªssBagLí
-1).

231 
	`m≠
(
i
 => 
	$UI¡
(
i
, 
logAddªssBagLí
))

233 
vÆ
 
øndAddrFromBag
 = 
	`MuxLookup
(
øndAddrBagIndex
, 
	`UI¡
(0),

234 
addrBagIndi˚s
.
	$zù
(
bagOfAddrs
))

238 
vÆ
 
exåaAddrIndi˚s
 = (0 
to
 
numExåaAddrs
-1)

239 .
	`m≠
(
i
 => 
	$UI¡
(
i
, 
logNumExåaAddrs
))

241 
vÆ
 
øndAddr
 =

242 i‡(! 
gíExåaAddrs
) {

243 
øndAddrFromBag


244 
	}
}

248 
vÆ
 
øndExåaAddrIndex
 = 
LCG
(
logNumExåaAddrs
)

251 
vÆ
 
øndAddrFromExåa
 = 
C©
(
UI¡
(0),

252 
MuxLookup
(
øndExåaAddrIndex
, 
UI¡
(0),

253 
exåaAddrIndi˚s
.
zù
(
exåaAddrs
)), 
UI¡
(0, 3))

255 
Fªquícy
(
Li°
(

256 (1, 
øndAddrFromBag
),

257 (1, 
øndAddrFromExåa
)))

260 
vÆ
 
	gÆlAddrs
 = 
exåaAddrs
 ++ 
bagOfAddrs


261 
vÆ
 
ÆlAddrIndi˚s
 = (0 
u¡û
 
tŸÆNumAddrs
)

262 .
m≠
(
i
 => 
UI¡
(i, 
	$log2Ceû
(
tŸÆNumAddrs
)))

263 
vÆ
 
öôAddr
 = 
	`MuxLookup
(
öôCou¡
, 
	`UI¡
(0),

264 
ÆlAddrIndi˚s
.
	$zù
(
ÆlAddrs
))

273 
	`vÆ
 (
›N›
 :: 
›Lﬂd
 :: 
›St‹e
 ::

274 
›Fí˚
 :: 
›LRSC
 :: 
›Sw≠
 ::

275 
›Dñay
 :: 
Nû
Ë
	`Enum
(
	`Bôs
(), 7)

280 
vÆ
 
øndOp
 = 
	`Fªquícy
(
	`Li°
(

281 (10, 
›Lﬂd
),

282 (10, 
›St‹e
),

283 (4, 
›Fí˚
),

284 (3, 
›LRSC
),

285 (3, 
›Sw≠
),

286 (2, 
›Dñay
)))

296 
vÆ
 
ègM™
 = 
	`ModuÀ
(
√w
 
	`TagM™
(
	$log2Ceû
(
maxTags
)))

299 
ègM™
.
io
.
èke
 :
	`Boﬁ
(
Ál£
);

300 
ègM™
.
io
.
put
 :
	`Boﬁ
(
Ál£
);

301 
ègM™
.
io
.
ègIn
 :
	`UI¡
(0);

309 
vÆ
 
cy˛eCou¡
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 32))

310 
cy˛eCou¡
 :cy˛eCou¡ + 
	`UI¡
(1);

319 
vÆ
 
dñayTimî
 = 
	`ModuÀ
(
√w
 
	$Dy«micTimî
(16))

322 
vÆ
 
øndDñayBa£
 = 
	$LCG16
()

325 
vÆ
 
øndDñay
 = 
	`Fªquícy
(
	`Li°
(

326 (14, 
	$UI¡
(0, 13Ë## 
	`øndDñayBa£
(2, 0)),

327 (2, 
	$UI¡
(0, 11Ë## 
	$øndDñayBa£
(5, 0))))

330 
dñayTimî
.
io
.
°¨t
 :
	$Boﬁ
(
Ál£
)

331 
dñayTimî
.
io
.
≥riod
 :
øndDñay


332 
dñayTimî
.
io
.
°›
 :
	$Boﬁ
(
Ál£
)

338 
vÆ
 
tid
 = 
io
.
h¨tid


341 
vÆ
 
ªqCou¡
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 32))

342 
vÆ
 
ª•Cou¡
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 32))

345 
vÆ
 
cuºítOp
 = 
	$Reg
(
öô
 = 
›N›
)

349 
vÆ
 
›InProgªss
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 2))

352 
vÆ
 
£ndFªshReq
 = 
	`Wúe
(
	$Boﬁ
())

353 
£ndFªshReq
 :
	$Boﬁ
(
Ál£
)

356 
vÆ
 
√xtD©a
 = 
	`Reg
(
öô
 = 
	`UI¡
(1, 
numBôsInW‹d
-
tid
.
gëWidth
))

359 
vÆ
 
ªqVÆid
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

360 
vÆ
 
ªqAddr
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 
numBôsInW‹d
))

361 
vÆ
 
ªqD©a
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 
numBôsInW‹d
))

362 
vÆ
 
ªqCmd
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 5))

363 
vÆ
 
ªqTag
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 7))

366 
vÆ
 
ˇnSídFªshReq
 = (!
ªqVÆid
 || 
io
.
mem
.
ªq
.
	`fúe
()) &&

367 
ègM™
.
io
.
avaûabÀ


370 
	`whí
 (
ªqCou¡
 < 
	$UI¡
(
numReqsPîGí
)) {

373 
	`whí
 (
cuºítOp
 ==
›N›
) {

375 
cuºítOp
 :
	`Mux
(
öôD⁄e
, 
øndOp
, 
›St‹e
)

379 
	`whí
 (
cuºítOp
 ==
›Fí˚
) {

380 
	`whí
 (
›InProgªss
 ==
	`UI¡
(0Ë&& !
ªqVÆid
) {

382 
	`¥ötf
("%d: fí˚-ªq @%d\n", 
tid
, 
cy˛eCou¡
)

384 
›InProgªss
 :
	`UI¡
(1)

387 .
	`ñ£whí
 (
ªqCou¡
 ==
ª•Cou¡
) {

389 
	`¥ötf
("%d: fí˚-ª• @%d\n", 
tid
, 
cy˛eCou¡
)

391 
cuºítOp
 :
øndOp


393 
›InProgªss
 :
	`UI¡
(0)

398 
	`whí
 (
cuºítOp
 ==
›Dñay
) {

399 
	`whí
 (
›InProgªss
 ==
	`UI¡
(0)) {

401 
dñayTimî
.
io
.
°¨t
 :
	`Boﬁ
(
åue
)

403 
›InProgªss
 :
	`UI¡
(1)

405 .
	`ñ£whí
 (
dñayTimî
.
io
.
timeout
) {

407 
cuºítOp
 :
øndOp


409 
›InProgªss
 :
	`UI¡
(0)

414 
	`whí
 (
cuºítOp
 ==
›Lﬂd
 ||

415 
cuºítOp
 ==
›St‹e
 ||

416 
cuºítOp
 ==
›Sw≠
) {

417 
	`whí
 (
ˇnSídFªshReq
) {

419 
ªqAddr
 :
	`Mux
(
öôD⁄e
, 
øndAddr
, 
öôAddr
)

421 
	`whí
 (
cuºítOp
 ==
›Lﬂd
) {

422 
ªqCmd
 :
M_XRD


423 } .
	`ñ£whí
 (
cuºítOp
 ==
›St‹e
) {

424 
ªqCmd
 :
M_XWR


425 } .
	`ñ£whí
 (
cuºítOp
 ==
›Sw≠
) {

426 
ªqCmd
 :
M_XA_SWAP


429 
£ndFªshReq
 :
	`Boﬁ
(
åue
)

431 
	`whí
 (!
öôD⁄e
 && 
öôCou¡
 =/
	`UI¡
(
tŸÆNumAddrs
 - 1)) {

432 
öôCou¡
 :öôCou¡ + 
	`UI¡
(1)

433 
cuºítOp
 :
›St‹e


434 } .
Ÿhîwi£
 {

435 
cuºítOp
 :
øndOp


436 
öôD⁄e
 :
	`Boﬁ
(
åue
)

443 
	`whí
 (
cuºítOp
 ==
›LRSC
) {

445 
	`whí
 (
›InProgªss
 ==
	`UI¡
(0)) {

446 
	`whí
 (
ˇnSídFªshReq
) {

448 
ªqAddr
 :
øndAddr


449 
ªqCmd
 :
M_XLR


451 
£ndFªshReq
 :
	`Boﬁ
(
åue
)

453 
›InProgªss
 :
	`UI¡
(1)

457 
	`whí
 (
›InProgªss
 ==
	`UI¡
(1)) {

459 
dñayTimî
.
io
.
°¨t
 :
	`Boﬁ
(
åue
)

461 
›InProgªss
 :
	`UI¡
(2)

464 
	`whí
 (
›InProgªss
 ==
	`UI¡
(2)) {

465 
	`whí
 (
dñayTimî
.
io
.
timeout
) {

467 
›InProgªss
 :
	`UI¡
(3)

471 
	`whí
 (
›InProgªss
 ==
	`UI¡
(3)) {

472 
	`whí
 (
ˇnSídFªshReq
) {

475 
ªqCmd
 :
M_XSC


477 
£ndFªshReq
 :
	`Boﬁ
(
åue
)

479 
›InProgªss
 :
	`UI¡
(0)

481 
cuºítOp
 :
øndOp


485 
	}
}

490 
	$whí
 (
£ndFªshReq
) {

492 
ªqTag
 :
ègM™
.
io
.
ègOut


493 
ègM™
.
io
.
èke
 :
	`Boﬁ
(
åue
)

495 
ªqD©a
 :
	`C©
(
√xtD©a
, 
tid
)

496 
√xtD©a
 :√xtD©®+ 
	`UI¡
(1)

498 
ªqVÆid
 :
	`Boﬁ
(
åue
)

500 
ªqCou¡
 :ªqCou¡ + 
	`UI¡
(1)

501 
	}
}

502 .
ñ£whí
 (
io
.
mem
.
ªq
.
	$fúe
()) {

504 
ªqVÆid
 :
	`Boﬁ
(
Ál£
)

505 
	}
}

508 
io
.
mem
.
ªq
.
vÆid
 :
ªqVÆid


509 
io
.
mem
.
ªq
.
bôs
.
addr
 :
ªqAddr


510 
io
.
mem
.
ªq
.
bôs
.
d©a
 :
ªqD©a


511 
io
.
mem
.
ªq
.
bôs
.
typ
 :
UI¡
(
	$log2Ceû
(
numByãsInW‹d
))

512 
io
.
mem
.
ªq
.
bôs
.
cmd
 :
ªqCmd


513 
io
.
mem
.
ªq
.
bôs
.
èg
 :
ªqTag


516 
	`whí
 (
io
.
mem
.
ªq
.
	$fúe
()) {

518 
vÆ
 
addr
 = 
io
.
mem
.
ªq
.
bôs
.addr

520 
	`¥ötf
("%d:", 
tid
)

522 
	`whí
 (
ªqCmd
 ==
M_XRD
) {

523 
	`¥ötf
("Üﬂd-ªq 0x%x", 
addr
)

525 
	`whí
 (
ªqCmd
 ==
M_XLR
) {

526 
	`¥ötf
("Üﬂd-ª£rve-ªq 0x%x", 
addr
)

528 
	`whí
 (
ªqCmd
 ==
M_XWR
) {

529 
	`¥ötf
(" st‹e-ªq %d 0x%x", 
ªqD©a
, 
addr
)

531 
	`whí
 (
ªqCmd
 ==
M_XSC
) {

532 
	`¥ötf
(" st‹e-c⁄d-ªq %d 0x%x", 
ªqD©a
, 
addr
)

534 
	`whí
 (
ªqCmd
 ==
M_XA_SWAP
) {

535 
	`¥ötf
(" sw≠-ªq %d 0x%x", 
ªqD©a
, 
addr
)

538 
	`¥ötf
(" #%d", 
ªqTag
)

540 
	`¥ötf
(" @%d\n", 
cy˛eCou¡
)

541 
	}
}

547 
	$whí
 (
io
.
mem
.
ª•
.
vÆid
) {

549 
ègM™
.
io
.
ègIn
 :io.
mem
.
ª•
.
bôs
.
èg


550 
ègM™
.
io
.
put
 :
	`Boﬁ
(
åue
)

552 
	`¥ötf
("%d:Ñe• %d #%d @%d\n", 
tid
,

553 
io
.
mem
.
ª•
.
bôs
.
d©a
, io.mem.ª•.bôs.
èg
, 
cy˛eCou¡
)

555 
ª•Cou¡
 :ª•Cou¡ + 
	`UI¡
(1)

556 
	}
}

561 
vÆ
 
d⁄e
 = 
ªqCou¡
 ==
UI¡
(
numReqsPîGí
) &&

562 
ª•Cou¡
 ==
	$UI¡
(
numReqsPîGí
)

564 
vÆ
 
d⁄ePul£
 = 
d⁄e
 && !
	`Reg
(
öô
 = 
	`Boﬁ
(
Ál£
), 
√xt
 = done)

567 
	$whí
 (
d⁄ePul£
) {

568 
	`¥ötf
(
s
"FINISHED ${numGens}\n")

569 
	}
}

571 
io
.
föished
 :
d⁄e


572 
io
.
timeout
 :
ªqTimî
.io.timeout.
vÆid


580 
˛ass
 
	$Tø˚GíTûe
(
vÆ
 
id
: 
I¡
, vÆ 
∑øms
: 
Tø˚GíP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$GroundTe°Tûe
(
∑øms
) {

581 
vÆ
 
ma°îNode
: 
TLOutw¨dNode
 = 
dˇcheO±
.
	`m≠
(
_
.
node
).
	`gëOrEl£
(
	`TLIdítôyNode
())

582 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`Tø˚GíTûeModuÀImp
(
this
)

583 
	}
}

585 ˛as†
	cTø˚GíTûeModuÀImp
(
ouãr
: 
Tø˚GíTûe
Ë
exãnds
 
	$GroundTe°TûeModuÀImp
(
ouãr
) {

587 
vÆ
 
åa˚gí
 = 
	`ModuÀ
(
√w
 
	$Tø˚Gíî©‹
(
ouãr
.
∑øms
))

588 
åa˚gí
.
io
.
h¨tid
 :
c⁄°™ts
.hartid

590 
ouãr
.
dˇcheO±
 
f‹óch
 { 
dˇche
 =>

591 
vÆ
 
dˇcheIF
 = 
	`ModuÀ
(
√w
 
	`Sim∂eHñœCacheIF
())

592 
dˇcheIF
.
io
.
ªque°‹
 <> 
åa˚gí
.io.
mem


593 
dˇche
.
moduÀ
.
io
.
˝u
 <> 
dˇcheIF
.io.
ˇche


596 
°©us
.
föished
 :
åa˚gí
.
io
.finished

597 
°©us
.
timeout
.
vÆid
 :
åa˚gí
.
io
.timeout

598 
°©us
.
timeout
.
bôs
 :
	$UI¡
(0)

599 
°©us
.
îr‹
.
vÆid
 :
	$Boﬁ
(
Ál£
)

601 
	`as£π
(!
åa˚gí
.
io
.
timeout
, 
s
"TraceGenÅile ${outer.id}:ÑequestÅimed out")

602 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Bundles.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 ˛as†
	cSyncI¡îru±s
(
∑øms
: 
I¡Edge
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

11 
vÆ
 
sync
 = 
	`Vec
(
∑øms
.
sour˚
.
num
, 
	`Boﬁ
())

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Crossing.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gSynchr⁄izîShi·Reg
, 
	gAsyncRe£tReg
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
	g_


10 @
dïªˇãd
("IntXing doesÇotÉnsure interrupt source is glitch free. Use IntSyncSourceánd IntSyncSink", "rocket-chip 1.2")

11 
˛ass
 
	$I¡Xög
(
sync
: 
I¡
 = 3)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


13 
vÆ
 
öäode
 = 
	`I¡Ad≠ãrNode
()

15 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

16 (
öäode
.
ö
 
zù
 i¡node.
out
Ë
f‹óch
 { ((ö, 
_
), (out, _)) =>

17 
out
 :
	`Synchr⁄izîShi·Reg
(
ö
, 
sync
)

20 
	}
}

22 
obje˘
 
	gI¡SyncCrossögSour˚


24 
def
 
≠∂y
(
ÆªadyRegi°îed
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
) =

26 
vÆ
 
ötsour˚
 = 
LazyModuÀ
(
√w
 
I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
))

27 
ötsour˚
.
node


32 
˛ass
 
	$I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


34 
vÆ
 
node
 = 
	`I¡SyncSour˚Node
(
ÆªadyRegi°îed
)

36 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

37 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

38 i‡(
ÆªadyRegi°îed
) {

39 
out
.
sync
 :
ö


41 
out
.
sync
 :
	`AsyncRe£tReg
(
	`C©
(
ö
.
ªvî£
)).
toBoﬁs


45 
	}
}

48 
˛ass
 
	$I¡SyncCrossögSök
(
sync
: 
I¡
 = 3)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


50 
vÆ
 
node
 = 
	`I¡SyncSökNode
(
sync
)

52 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

53 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

54 
out
 :
	`Synchr⁄izîShi·Reg
(
ö
.
sync
, sync)

57 
	}
}

59 
obje˘
 
	gI¡SyncCrossögSök


61 
def
 
≠∂y
(
sync
: 
I¡
 = 3)(
im∂icô
 
p
: 
P¨amëîs
) =

63 
vÆ
 
ötsök
 = 
LazyModuÀ
(
√w
 
I¡SyncCrossögSök
(
sync
))

64 
ötsök
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/CrossingHelper.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
˛ass
 
	$I¡Inw¨dCrossögHñ≥r
(
«me
: 
Såög
, 
sc›e
: 
LazySc›e
, 
node
: 
I¡Inw¨dNode
) {

9 
def
 
	`≠∂y
(
xög
: 
ClockCrossögTy≥
 = 
NoCrossög
, 
ÆªadyRegi°îed
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
): 
I¡Inw¨dNode
 = {

10 
xög
 
m©ch
 {

11 
x
: 
Asynchr⁄ousCrossög
 =>

12 
node
 :*=* 
sc›e
 { 
	`I¡SyncCrossögSök
(
x
.
sökSync
Ë:*=* 
	`I¡SyncNameNode
(
«me
Ë} :*=* I¡SyncNameNode“ameË:*=* 
	`I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
)

13 
	`R©i⁄ÆCrossög
(
_
) =>

14 
node
 :*=* 
sc›e
 { 
	`I¡SyncCrossögSök
(1Ë:*=* 
	`I¡SyncNameNode
(
«me
Ë} :*=* I¡SyncNameNode“ameË:*=* 
	`I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
)

15 
	`Synchr⁄ousCrossög
(
_
) =>

16 
node
 :*=* 
sc›e
 { 
	`I¡SyncCrossögSök
(0Ë:*=* 
	`I¡SyncNameNode
(
«me
Ë} :*=* I¡SyncNameNode“ameË:*=* 
	`I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
)

19 
	}
}

21 
˛ass
 
	$I¡Outw¨dCrossögHñ≥r
(
«me
: 
Såög
, 
sc›e
: 
LazySc›e
, 
node
: 
I¡Outw¨dNode
) {

22 
def
 
	`≠∂y
(
xög
: 
ClockCrossögTy≥
 = 
NoCrossög
, 
ÆªadyRegi°îed
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
): 
I¡Outw¨dNode
 = {

23 
xög
 
m©ch
 {

24 
x
: 
Asynchr⁄ousCrossög
 =>

25 
	`I¡SyncCrossögSök
(
x
.
sökSync
Ë:*=* 
	`I¡SyncNameNode
(
«me
Ë:*=* 
sc›e
 { I¡SyncNameNode“ameË:*=* 
	`I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
Ë} :*=* 
node


26 
	`R©i⁄ÆCrossög
(
_
) =>

27 
	`I¡SyncCrossögSök
(1Ë:*=* 
	`I¡SyncNameNode
(
«me
Ë:*=* 
sc›e
 { I¡SyncNameNode“ameË:*=* 
	`I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
Ë} :*=* 
node


28 
	`Synchr⁄ousCrossög
(
buf„r
) =>

29 
	`I¡SyncCrossögSök
(0Ë:*=* 
	`I¡SyncNameNode
(
«me
Ë:*=* 
sc›e
 { I¡SyncNameNode“ameË:*=* 
	`I¡SyncCrossögSour˚
(
ÆªadyRegi°îed
Ë} :*=* 
node


32 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Nodes.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
obje˘
 
I¡Imp
 
exãnds
 
	gSim∂eNodeImp
[
I¡Sour˚P‹tP¨amëîs
, 
I¡SökP‹tP¨amëîs
, 
I¡Edge
, 
Vec
[
Boﬁ
]]

12 
def
 
edge
(
pd
: 
I¡Sour˚P‹tP¨amëîs
, 
pu
: 
I¡SökP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
I¡Edge
(pd,Öu,Ö, sourceInfo)

13 
def
 
bundÀ
(
e
: 
I¡Edge
Ë
Vec
”.
sour˚
.
num
, 
Boﬁ
())

14 
def
 
ªndî
(
e
: 
I¡Edge
Ë
RídîedEdge
(
cﬁour
 = "#0000ff" , 
œbñ
 =É.
sour˚
.
sour˚s
.
m≠
(
_
.
ønge
.
size
).
sum
.
toSåög
, 
Êù≥d
 = 
åue
)

16 
ovîride
 
def
 
mixO
(
pd
: 
I¡Sour˚P‹tP¨amëîs
, 
node
: 
Outw¨dNode
[I¡Sour˚P‹tP¨amëîs, 
I¡SökP‹tP¨amëîs
, 
Vec
[
Boﬁ
]]): IntSourcePortParameters =

17 
pd
.
c›y
(
sour˚s
 =Öd.sour˚s.
m≠
 { 
s
 => s.c›y (
nodeP©h
 = 
node
 +: s.nodePath) })

18 
ovîride
 
def
 
mixI
(
pu
: 
I¡SökP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
I¡Sour˚P‹tP¨amëîs
, I¡SökP‹tP¨amëîs, 
Vec
[
Boﬁ
]]): IntSinkPortParameters =

19 
pu
.
c›y
(
söks
 =Öu.söks.
m≠
 { 
s
 => s.c›y (
nodeP©h
 = 
node
 +: s.nodePath) })

22 
˛ass
 
	$I¡Sour˚Node
(
p‹tP¨ams
: 
Seq
[
I¡Sour˚P‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$Sour˚Node
(
I¡Imp
)(
p‹tP¨ams
)

23 
˛ass
 
	$I¡SökNode
(
p‹tP¨ams
: 
Seq
[
I¡SökP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$SökNode
(
I¡Imp
)(
p‹tP¨ams
)

24 
˛ass
 
	`I¡Ad≠ãrNode
(

25 
sour˚Fn
: 
I¡Sour˚P‹tP¨amëîs
 => I¡Sour˚P‹tP¨amëî†{ 
s
 => s 
	}
},

26 
	gsökFn
: 
I¡SökP‹tP¨amëîs
 => I¡SökP‹tP¨amëî†{ 
s
 => s })(

27 
im∂icô
 
vÆName
: 
VÆName
)

28 
exãnds
 
	$Ad≠ãrNode
(
I¡Imp
)(
sour˚Fn
, 
sökFn
)

29 ˛as†
	cI¡IdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$IdítôyNode
(
I¡Imp
)()

31 
obje˘
 
I¡NameNode
 {

32 
def
 
	`≠∂y
(
«me
: 
VÆName
Ë
	$I¡IdítôyNode
()(
«me
)

33 
def
 
	$≠∂y
(
«me
: 
O±i⁄
[
Såög
]): 
I¡IdítôyNode
 = 
	`≠∂y
((
	`VÆName
“ame.
	`gëOrEl£
("with_no_name"))))

34 
def
 
	$≠∂y
(
«me
: 
Såög
): 
I¡IdítôyNode
 = 
	`≠∂y
(
	`Some
(name))

37 
˛ass
 
	`I¡NexusNode
(

38 
sour˚Fn
: 
Seq
[
I¡Sour˚P‹tP¨amëîs
] => IntSourcePortParameters,

39 
sökFn
: 
Seq
[
I¡SökP‹tP¨amëîs
] => IntSinkPortParameters,

40 
öputRequúesOuçut
: 
Boﬁón
 = 
åue
,

41 
ouçutRequúesI≈ut
: 
Boﬁón
 = 
åue
)(

42 
im∂icô
 
vÆName
: 
VÆName
)

43 
exãnds
 
	$NexusNode
(
I¡Imp
)(
sour˚Fn
, 
sökFn
, 
öputRequúesOuçut
, 
ouçutRequúesI≈ut
)

45 
obje˘
 
I¡SyncImp
 
exãnds
 
Sim∂eNodeImp
[
I¡Sour˚P‹tP¨amëîs
, 
I¡SökP‹tP¨amëîs
, 
I¡Edge
, 
SyncI¡îru±s
]

47 
def
 
	`edge
(
pd
: 
I¡Sour˚P‹tP¨amëîs
, 
pu
: 
I¡SökP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
	`I¡Edge
(pd,Öu,Ö, sourceInfo)

48 
def
 
	`bundÀ
(
e
: 
I¡Edge
Ë
√w
 
	`SyncI¡îru±s
(e)

49 
def
 
	`ªndî
(
e
: 
I¡Edge
Ë
	`RídîedEdge
(
cﬁour
 = "#ff00ff" , 
œbñ
 =É.
sour˚
.
sour˚s
.
	`m≠
(
_
.
ønge
.
size
).
sum
.
toSåög
, 
Êù≥d
 = 
åue
)

51 
ovîride
 
def
 
	`mixO
(
pd
: 
I¡Sour˚P‹tP¨amëîs
, 
node
: 
Outw¨dNode
[I¡Sour˚P‹tP¨amëîs, 
I¡SökP‹tP¨amëîs
, 
SyncI¡îru±s
]): IntSourcePortParameters =

52 
pd
.
	`c›y
(
sour˚s
 =Öd.sour˚s.
m≠
 { 
s
 => s.c›y (
nodeP©h
 = 
node
 +: s.nodePath) })

53 
ovîride
 
def
 
	`mixI
(
pu
: 
I¡SökP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
I¡Sour˚P‹tP¨amëîs
, I¡SökP‹tP¨amëîs, 
SyncI¡îru±s
]): IntSinkPortParameters =

54 
pu
.
	`c›y
(
söks
 =Öu.söks.
m≠
 { 
s
 => s.c›y (
nodeP©h
 = 
node
 +: s.nodePath) })

55 
	}
}

57 ˛as†
	cI¡SyncIdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$IdítôyNode
(
I¡SyncImp
)()

59 
obje˘
 
I¡SyncNameNode
 {

60 
def
 
	`≠∂y
(
«me
: 
VÆName
Ë
	$I¡SyncIdítôyNode
()(
«me
)

61 
def
 
	$≠∂y
(
«me
: 
O±i⁄
[
Såög
]): 
I¡SyncIdítôyNode
 = 
	`≠∂y
((
	`VÆName
“ame.
	`gëOrEl£
("with_no_name"))))

62 
def
 
	$≠∂y
(
«me
: 
Såög
): 
I¡SyncIdítôyNode
 = 
	`≠∂y
(
	`Some
(name))

65 
˛ass
 
	$I¡SyncSour˚Node
(
ÆªadyRegi°îed
: 
Boﬁón
)(
im∂icô
 
vÆName
: 
VÆName
)

66 
exãnds
 
	$MixedAd≠ãrNode
(
I¡Imp
, 
I¡SyncImp
)(

67 
dFn
 = { 
p
 =>Ö 
	}
},

68 
	guFn
 = { 
p
 =>Ö })

70 
ovîride
 
œzy
 
vÆ
 
	gnodedebug°rög
 = 
s
"alreadyRegistered:${alreadyRegistered}"

73 
˛ass
 
	$I¡SyncSökNode
(
sync
: 
I¡
)(
im∂icô
 
vÆName
: 
VÆName
)

74 
exãnds
 
	$MixedAd≠ãrNode
(
I¡SyncImp
, 
I¡Imp
)(

75 
dFn
 = { 
p
 =>Ö 
	}
},

76 
	guFn
 = { 
p
 =>Ö })

78 
ovîride
 
œzy
 
vÆ
 
	gnodedebug°rög
 = 
s
"sync:${sync}"

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/NullIntSource.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
˛ass
 
	$NuŒI¡Sour˚
(
num
: 
I¡
 = 1, 
p‹ts
: I¡ = 1, 
sour˚s
: I¡ = 1)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


12 
vÆ
 
öäode
 = 
	`I¡Sour˚Node
(
	`I¡Sour˚P‹tSim∂e
(
num
, 
p‹ts
, 
sour˚s
))

14 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

15 
öäode
.
out
.
f‹óch
 { (
o
, 
_
Ë=> o.f‹óch { _ :
Ál£
.
B
 } }

17 
	}
}

19 
obje˘
 
NuŒI¡Sour˚
 {

20 
def
 
≠∂y
(
num
: 
I¡
 = 1, 
p‹ts
: I¡ = 1, 
sour˚s
: I¡ = 1)(
im∂icô
 
p
: 
P¨amëîs
): 
I¡Node
 = {

21 
vÆ
 
nuŒ_öt_sour˚
 = 
LazyModuÀ
(
√w
 
NuŒI¡Sour˚
(
num
, 
p‹ts
, 
sour˚s
))

22 
	gnuŒ_öt_sour˚
.
	göäode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Parameters.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
˛ass
 
	$I¡R™ge
(
°¨t
: 
I¡
, 
íd
: Int)

13 
	`ªquúe
 (
°¨t
 >= 0)

14 
	`ªquúe
 (
°¨t
 <
íd
)

15 
def
 
size
 = 
íd
 - 
°¨t


16 
def
 
	`ovîœps
(
x
: 
I¡R™ge
Ë
°¨t
 < x.
íd
 && x.start <Énd

17 
def
 
	`off£t
(
x
: 
I¡
Ë
	`I¡R™ge
(x+
°¨t
, x+
íd
)

18 
	}
}

20 
obje˘
 
	gI¡R™ge


22 
im∂icô
 
def
 
≠∂y
(
íd
: 
I¡
): 
I¡R™ge
 =ápply(0,Énd)

25 
˛ass
 
I¡Sour˚P¨amëîs
(

26 
ønge
: 
I¡R™ge
,

27 
ªsour˚s
: 
Seq
[
Resour˚
] = Seq(),

28 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

30 
vÆ
 
«me
 = 
nodeP©h
.
œ°O±i⁄
.
	`m≠
(
_
.
œzyModuÀ
.«me).
	`gëOrEl£
("disconnected")

31 
	}
}

33 
˛ass
 
I¡SökP¨amëîs
(

34 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

36 
vÆ
 
«me
 = 
nodeP©h
.
œ°O±i⁄
.
	`m≠
(
_
.
œzyModuÀ
.«me).
	`gëOrEl£
("disconnected")

37 
	}
}

39 
˛ass
 
	$I¡Sour˚P‹tP¨amëîs
(
sour˚s
: 
Seq
[
I¡Sour˚P¨amëîs
])

41 
vÆ
 
num
 = 
sour˚s
.
	`m≠
(
_
.
ønge
.
size
).
sum


43 
sour˚s
.
	`m≠
(
_
.
ønge
).
	`combö©i⁄s
(2).
f‹óch
 { 
	`Seq
(
a
, 
b
Ë=> 
	`ªquúe
 (!a.
	`ovîœps
(b)) }

45 
	`ªquúe
 (
sour˚s
.
isEm±y
 || sour˚s.
	`m≠
(
_
.
ønge
.
íd
).
max
 =
num
)

46 
	}
}

47 
obje˘
 
	gI¡Sour˚P‹tSim∂e


49 
def
 
≠∂y
(
num
: 
I¡
 = 1, 
p‹ts
: I¡ = 1, 
sour˚s
: I¡ = 1, 
ªsour˚s
: 
Seq
[
Resour˚
] = 
Nû
) =

50 i‡(
num
 =0Ë
Nû
 

51 
Seq
.
fûl
(
p‹ts
)(
I¡Sour˚P‹tP¨amëîs
(Seq.fûl(
sour˚s
)(
I¡Sour˚P¨amëîs
(
ønge
 = 
I¡R™ge
(0, 
num
), 
ªsour˚s
 =Ñesources))))

54 
˛ass
 
	$I¡SökP‹tP¨amëîs
(
söks
: 
Seq
[
I¡SökP¨amëîs
])

55 
obje˘
 
I¡SökP‹tSim∂e


57 
def
 
	`≠∂y
(
p‹ts
: 
I¡
 = 1, 
söks
: Int = 1) =

58 
Seq
.
	`fûl
(
p‹ts
)(
	`I¡SökP‹tP¨amëîs
(Seq.fûl(
söks
)(
	`I¡SökP¨amëîs
())))

59 
	}
}

61 
˛ass
 
I¡Edge
(
sour˚
: 
I¡Sour˚P‹tP¨amëîs
, 
sök
: 
I¡SökP‹tP¨amëîs
, 
∑øms
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/RegisterRouter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


10 
åaô
 
	gHasI¡îru±Sour˚s
 { 
	gthis
: 
Regi°îRouãr
[
_
] =>

11 
def
 
nI¡îru±s
: 
I¡


12 
¥Ÿe˘ed
 
vÆ
 
öäode
 = 
I¡Sour˚Node
(
I¡Sour˚P‹tSim∂e
(
num
 = 
nI¡îru±s
, 
ªsour˚s
 = 
Seq
(
Resour˚
(
devi˚
, "int"))))

15 
vÆ
 
	götXög
: 
I¡Outw¨dCrossögHñ≥r
 = 
this
.
¸ossOut
(
öäode
)

18 
vÆ
 
öãºu±s
: 
ModuÀVÆue
[
Vec
[
Boﬁ
]] = 
InModuÀBody
 { i‡(
öäode
.
out
.
isEm±y
ËVec(0, Boﬁ()Ëöäode.out(0).
_1
 }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Xbar.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
öãºu±s


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 ˛as†
	cI¡Xb¨
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


11 
vÆ
 
öäode
 = 
	`I¡NexusNode
(

12 
sökFn
 = { 
_
 => 
	`I¡SökP‹tP¨amëîs
(
	`Seq
(
	`I¡SökP¨amëîs
())) },

13 
sour˚Fn
 = { 
£q
 =>

14 
	`I¡Sour˚P‹tP¨amëîs
((
£q
 
zù
 seq.
	`m≠
(
_
.
num
).
	`sˇnLe·
(0)(_+_).
öô
).
m≠
 {

15 (
s
, 
o
Ë=> s.
sour˚s
.
	`m≠
(
z
 => z.
	`c›y
(
ønge
 = z.ønge.
	`off£t
(o)))

16 }.
Ê©ãn
)

17 
	}
})

19 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

20 
vÆ
 
ˇt
 = 
öäode
.
ö
.
m≠
 { (
i
, 
e
Ë=> i.
	`èke
”.
sour˚
.
num
Ë}.
Ê©ãn


21 
öäode
.
out
.
f‹óch
 { (
o
, 
_
Ë=> o :
ˇt
 }

22 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
∑ckage
 
obje˘
 
	göãºu±s


10 
ty≥
 
	gI¡Inw¨dNode
 = 
Inw¨dNodeH™dÀ
[
I¡Sour˚P‹tP¨amëîs
, 
I¡SökP‹tP¨amëîs
, 
I¡Edge
, 
Vec
[
Boﬁ
]]

11 
ty≥
 
	gI¡Outw¨dNode
 = 
Outw¨dNodeH™dÀ
[
I¡Sour˚P‹tP¨amëîs
, 
I¡SökP‹tP¨amëîs
, 
I¡Edge
, 
Vec
[
Boﬁ
]]

12 
ty≥
 
	gI¡Node
 = 
Sim∂eNodeH™dÀ
[
I¡Sour˚P‹tP¨amëîs
, 
I¡SökP‹tP¨amëîs
, 
I¡Edge
, 
Vec
[
Boﬁ
]]

14 
im∂icô
 cœs†
	cI¡ClockDomaöCrossög
(
vÆ
 
x
: 
HasClockDomaöCrossög
Ë
exãnds
 
AnyVÆ
 {

15 
def
 
	`¸ossIn
 (
n
: 
I¡Inw¨dNode
Ë(
im∂icô
 
vÆName
: 
VÆName
Ë
	`I¡Inw¨dCrossögHñ≥r
(vÆName.
«me
, 
x
,Ç)

16 
def
 
	`¸ossOut
(
n
: 
I¡Outw¨dNode
)(
im∂icô
 
vÆName
: 
VÆName
Ë
	`I¡Outw¨dCrossögHñ≥r
(vÆName.
«me
, 
x
,Ç)

17 
def
 
	`¸oss
(
n
: 
I¡Inw¨dNode
Ë(
im∂icô
 
vÆName
: 
VÆName
Ë
	`¸ossIn
(n)

18 
def
 
	`¸oss
(
n
: 
I¡Outw¨dNode
)(
im∂icô
 
vÆName
: 
VÆName
Ë
	`¸ossOut
(n)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagShifter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
jèg


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gchi£l3
.
	gc‹e
.{
	gI≈ut
, 
	gOuçut
}

8 
imp‹t
 
	gchi£l3
.
	gc‹e
.
D©aMúr‹


9 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gfúπl
.
KnownWidth


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


17 ˛as†
	cShi·îIO
 
exãnds
 
	mBundÀ
 {

18 
vÆ
 
	mshi·
 = 
	$Boﬁ
()

19 
vÆ
 
d©a
 = 
	$Boﬁ
()

20 
vÆ
 
ˇ±uª
 = 
	$Boﬁ
()

21 
vÆ
 
upd©e
 = 
	$Boﬁ
()

25 
def
 
	$chaöC⁄åﬁFrom
(
ö
: 
Shi·îIO
) {

26 
shi·
 :
ö
.shift

27 
ˇ±uª
 :
ö
.capture

28 
upd©e
 :
ö
.update

30 
	}
}

32 
åaô
 
ChaöIO
 
exãnds
 
BundÀ
 {

33 
vÆ
 
chaöIn
 = 
I≈ut
(
√w
 
Shi·îIO
)

34 
vÆ
 
chaöOut
 = 
Ouçut
(
√w
 
Shi·îIO
)

37 
˛ass
 
C≠tuª
[+
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ
 {

38 
vÆ
 
bôs
 = 
I≈ut
(
gí
)

39 
vÆ
 
ˇ±uª
 = 
Ouçut
(
Boﬁ
())

40 
ovîride
 
def
 
˛⁄eTy≥
 = 
C≠tuª
(
gí
).
asIn°™˚Of
[
this
.
ty≥
]

43 
obje˘
 
C≠tuª
 {

44 
def
 
≠∂y
[
T
 <: 
D©a
](
gí
: T): 
C≠tuª
[T] = 
√w
 Capture(gen)

50 
åaô
 
Chaö
 
exãnds
 
ModuÀ
 {

51 
vÆ
 
io
: 
ChaöIO


58 ˛as†
	cJègBy∑ssChaö
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
Chaö
 {

59 
˛ass
 
ModIO
 
exãnds
 
ChaöIO


60 
vÆ
 
io
 = 
	$IO
(
√w
 
ModIO
)

61 
io
.
chaöOut
 
chaöC⁄åﬁFrom
 io.
chaöIn


63 
vÆ
 
ªg
 = 
	`Reg
(
	$Boﬁ
())

65 
io
.
chaöOut
.
d©a
 :
ªg


67 
	`covî
(
io
.
chaöIn
.
ˇ±uª
, "bypass_chain_capture", "JTAG; bypass_chain_capture; This Bypass Chain captured data")

69 
	$whí
 (
io
.
chaöIn
.
ˇ±uª
) {

70 
ªg
 :
Ál£
.
B


71 } .
	$ñ£whí
 (
io
.
chaöIn
.
shi·
) {

72 
ªg
 :
io
.
chaöIn
.
d©a


73 
	}
}

74 
as£π
(!(
io
.
chaöIn
.
ˇ±uª
 && io.chaöIn.
upd©e
)

75 && !(
io
.
chaöIn
.
ˇ±uª
 && io.chaöIn.
shi·
)

76 && !(
io
.
chaöIn
.
upd©e
 && io.chaöIn.
shi·
))

79 
obje˘
 
JègBy∑ssChaö
 {

80 
def
 
≠∂y
()(
im∂icô
 
p
: 
P¨amëîs
Ë
√w
 
JègBy∑ssChaö


91 
˛ass
 
C≠tuªChaö
[+
T
 <: 
D©a
](
gí
: T)(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
Chaö
 {

92 ˛as†
	cModIO
 
exãnds
 
ChaöIO
 {

93 
vÆ
 
ˇ±uª
 = 
C≠tuª
(
gí
)

95 
vÆ
 
io
 = 
	$IO
(
√w
 
ModIO
)

96 
io
.
chaöOut
 
chaöC⁄åﬁFrom
 io.
chaöIn


98 
vÆ
 
n
 = 
D©aMúr‹
.
	$widthOf
(
gí
Ë
m©ch
 {

99 
	`KnownWidth
(
x
) => x

100 
_
 => 
	`ªquúe
(
Ál£
, 
s
"can't generate chain for unknown width dataÅype $gen"); -1

101 
	}
}

103 
vÆ
 
	gªgs
 = (0 
u¡û
 
n
Ë
m≠
 (
x
 => 
Reg
(
	$Boﬁ
()))

105 
io
.
chaöOut
.
d©a
 :
	$ªgs
(0)

107 
	`covî
(
io
.
chaöIn
.
ˇ±uª
, "chain_capture", "JTAG; chain_capture; This Chain captured data")

109 
	$whí
 (
io
.
chaöIn
.
ˇ±uª
) {

110 (0 
u¡û
 
n
Ë
	`m≠
 (
x
 => 
	`ªgs
(xË:
io
.
ˇ±uª
.
bôs
.
	`asUI¡
()(x))

111 
io
.
ˇ±uª
.ˇ±uª :
åue
.
B


112 
	}
} .
	$ñ£whí
 (
io
.
chaöIn
.
shi·
) {

113 
	`ªgs
(
n
-1Ë:
io
.
chaöIn
.
d©a


114 (0 
u¡û
 
n
-1Ë
	`m≠
 (
x
 => 
	`ªgs
(x) :=Ñegs(x+1))

115 
io
.
ˇ±uª
.ˇ±uª :
Ál£
.
B


116 
	}
} .
Ÿhîwi£
 {

117 
io
.
ˇ±uª
.ˇ±uª :
Ál£
.
B


119 
as£π
(!(
io
.
chaöIn
.
ˇ±uª
 && io.chaöIn.
upd©e
)

120 && !(
io
.
chaöIn
.
ˇ±uª
 && io.chaöIn.
shi·
)

121 && !(
io
.
chaöIn
.
upd©e
 && io.chaöIn.
shi·
))

124 
obje˘
 
C≠tuªChaö
 {

125 
def
 
≠∂y
[
T
 <: 
D©a
](
gí
: T)(
im∂icô
 
p
: 
P¨amëîs
Ë
√w
 
C≠tuªChaö
(gen)

138 
˛ass
 
C≠tuªUpd©eChaö
[+
T
 <: 
D©a
, +
V
 <: D©a](
gíC≠tuª
: T, 
	ggíUpd©e
: V)(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
Chaö
 {

139 ˛as†
	cModIO
 
exãnds
 
ChaöIO
 {

140 
vÆ
 
ˇ±uª
 = 
C≠tuª
(
gíC≠tuª
)

141 
vÆ
 
upd©e
 = 
VÆid
(
gíUpd©e
)

143 
vÆ
 
io
 = 
	$IO
(
√w
 
ModIO
)

144 
io
.
chaöOut
 
chaöC⁄åﬁFrom
 io.
chaöIn


146 
vÆ
 
ˇ±uªWidth
 = 
D©aMúr‹
.
	$widthOf
(
gíC≠tuª
Ë
m©ch
 {

147 
	`KnownWidth
(
x
) => x

148 
_
 => 
	`ªquúe
(
Ál£
, 
s
"can't generate chain for unknown width dataÅype $genCapture"); -1

149 
	}
}

150 
vÆ
 
	gupd©eWidth
 = 
D©aMúr‹
.
	$widthOf
(
gíUpd©e
Ë
m©ch
 {

151 
	`KnownWidth
(
x
) => x

152 
_
 => 
	`ªquúe
(
Ál£
, 
s
"can't generate chain for unknown width dataÅype $genUpdate"); -1

153 
	}
}

154 
vÆ
 
	gn
 = 
m©h
.
	$max
(
ˇ±uªWidth
, 
upd©eWidth
)

156 
vÆ
 
ªgs
 = (0 
u¡û
 
n
Ë
	`m≠
 (
x
 => 
	`Reg
(
	$Boﬁ
()))

158 
io
.
chaöOut
.
d©a
 :
	$ªgs
(0)

160 
vÆ
 
upd©eBôs
 = 
	$C©
(
ªgs
.
ªvî£
)(
upd©eWidth
-1, 0)

161 
io
.
upd©e
.
bôs
 :
upd©eBôs
.
	$asTy≥Of
(
io
.
upd©e
.
bôs
)

163 
vÆ
 
ˇ±uªBôs
 = 
io
.
ˇ±uª
.
bôs
.
	$asUI¡
()

165 
	`covî
(
io
.
chaöIn
.
ˇ±uª
, "chain_capture", "JTAG;chain_capture; This Chain captured data")

166 
	`covî
(
io
.
chaöIn
.
ˇ±uª
, "chain_update", "JTAG;chain_update; This Chain updated data")

168 
	$whí
 (
io
.
chaöIn
.
ˇ±uª
) {

169 (0 
u¡û
 
m©h
.
	`mö
(
n
, 
ˇ±uªWidth
)Ë
	`m≠
 (
x
 => 
	`ªgs
(xË:
	`ˇ±uªBôs
(x))

170 (
ˇ±uªWidth
 
u¡û
 
n
Ë
	`m≠
 (
x
 => 
	`ªgs
(x) := 0.U)

171 
io
.
ˇ±uª
.ˇ±uª :
åue
.
B


172 
io
.
upd©e
.
vÆid
 :
Ál£
.
B


173 
	}
} .
	$ñ£whí
 (
io
.
chaöIn
.
upd©e
) {

174 
io
.
ˇ±uª
.ˇ±uª :
Ál£
.
B


175 
io
.
upd©e
.
vÆid
 :
åue
.
B


176 
	}
} .
	$ñ£whí
 (
io
.
chaöIn
.
shi·
) {

177 
	`ªgs
(
n
-1Ë:
io
.
chaöIn
.
d©a


178 (0 
u¡û
 
n
-1Ë
	`m≠
 (
x
 => 
	`ªgs
(x) :=Ñegs(x+1))

179 
io
.
ˇ±uª
.ˇ±uª :
Ál£
.
B


180 
io
.
upd©e
.
vÆid
 :
Ál£
.
B


181 
	}
} .
Ÿhîwi£
 {

182 
io
.
ˇ±uª
.ˇ±uª :
Ál£
.
B


183 
io
.
upd©e
.
vÆid
 :
Ál£
.
B


185 
as£π
(!(
io
.
chaöIn
.
ˇ±uª
 && io.chaöIn.
upd©e
)

186 && !(
io
.
chaöIn
.
ˇ±uª
 && io.chaöIn.
shi·
)

187 && !(
io
.
chaöIn
.
upd©e
 && io.chaöIn.
shi·
))

190 
obje˘
 
C≠tuªUpd©eChaö
 {

193 
def
 
≠∂y
[
T
 <: 
D©a
](
gí
: T)(
im∂icô
 
p
: 
P¨amëîs
Ë
√w
 
C≠tuªUpd©eChaö
(gen, gen)

194 
def
 
	g≠∂y
[
T
 <: 
D©a
, 
V
 <: D©a](
gíC≠tuª
: T, 
	ggíUpd©e
: V)(
im∂icô
 
p
: 
P¨amëîs
) =

195 
√w
 
C≠tuªUpd©eChaö
(
gíC≠tuª
, 
gíUpd©e
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagStateMachine.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
jèg


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.{
	gI≈ut
, 
	gOuçut
}

7 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
wôhRe£t


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gP¨amëîs
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gAsyncRe£tRegVec
}

11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


13 
obje˘
 
	gJègSèã
 {

14 
£Æed
 
ab°ø˘
 cœs†
	cSèã
(
vÆ
 
id
: 
I¡
) {

15 
def
 
U
: 
UI¡
 = 
id
.
	`U
(
Sèã
.
width
.
W
)

16 
	}
}

18 
obje˘
 
Sèã
 {

19 
imp‹t
 
sˇœ
.
œnguage
.
im∂icôC⁄vîsi⁄s


21 
im∂icô
 
def
 
toI¡
(
x
: 
Sèã
Ëx.
id


22 
im∂icô
 
def
 
toBigI¡
(
x
: 
Sèã
):
BigI¡
 = x.
id


25 
vÆ
 
Æl
: 
Së
[
Sèã
] = Set(

26 
Te°LogicRe£t
,

27 
RunTe°IdÀ
,

28 
Sñe˘DRSˇn
,

29 
C≠tuªDR
,

30 
Shi·DR
,

31 
Exô1DR
,

32 
Pau£DR
,

33 
Exô2DR
,

34 
Upd©eDR
,

35 
Sñe˘IRSˇn
,

36 
C≠tuªIR
,

37 
Shi·IR
,

38 
Exô1IR
,

39 
Pau£IR
,

40 
Exô2IR
,

41 
Upd©eIR


43 
vÆ
 
	gwidth
 = 
log2Ceû
(
Æl
.
size
)

44 
def
 
chi£lTy≥
(Ë
UI¡
(
width
.
W
)

48 
obje˘
 
Te°LogicRe£t
 
exãnds
 
	$Sèã
(15)

49 
obje˘
 
RunTe°IdÀ
 
exãnds
 
	$Sèã
(12)

50 
obje˘
 
Sñe˘DRSˇn
 
exãnds
 
	$Sèã
(7)

51 
obje˘
 
C≠tuªDR
 
exãnds
 
	$Sèã
(6)

52 
obje˘
 
Shi·DR
 
exãnds
 
	$Sèã
(2)

53 
obje˘
 
Exô1DR
 
exãnds
 
	$Sèã
(1)

54 
obje˘
 
Pau£DR
 
exãnds
 
	$Sèã
(3)

55 
obje˘
 
Exô2DR
 
exãnds
 
	$Sèã
(0)

56 
obje˘
 
Upd©eDR
 
exãnds
 
	$Sèã
(5)

57 
obje˘
 
Sñe˘IRSˇn
 
exãnds
 
	$Sèã
(4)

58 
obje˘
 
C≠tuªIR
 
exãnds
 
	$Sèã
(14)

59 
obje˘
 
Shi·IR
 
exãnds
 
	$Sèã
(10)

60 
obje˘
 
Exô1IR
 
exãnds
 
	$Sèã
(9)

61 
obje˘
 
Pau£IR
 
exãnds
 
	$Sèã
(11)

62 
obje˘
 
Exô2IR
 
exãnds
 
	$Sèã
(8)

63 
obje˘
 
Upd©eIR
 
exãnds
 
	`Sèã
(13)

64 
	}
}

74 ˛as†
	cJègSèãMachöe
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$ModuÀ
() {

75 ˛as†
	cSèãMachöeIO
 
exãnds
 
BundÀ
 {

76 
vÆ
 
tms
 = 
	`I≈ut
(
	`Boﬁ
())

77 
vÆ
 
cuºSèã
 = 
	`Ouçut
(
JègSèã
.
Sèã
.
chi£lTy≥
)

79 
vÆ
 
io
 = 
	$IO
(
√w
 
SèãMachöeIO
)

81 
vÆ
 
√xtSèã
 = 
	`Wúe
(
JègSèã
.
Sèã
.
	$chi£lTy≥
())

82 
vÆ
 
cuºSèãReg
 = 
	`ModuÀ
 (
√w
 
	`AsyncRe£tRegVec
(
w
 = 
JègSèã
.
Sèã
.
width
,

83 
öô
 = 
JègSèã
.
Sèã
.
	$toI¡
(
JègSèã
.
Te°LogicRe£t
)))

84 
cuºSèãReg
.
io
.
í
 :
åue
.
B


85 
cuºSèãReg
.
io
.
d
 :
√xtSèã


86 
vÆ
 
cuºSèã
 = 
cuºSèãReg
.
io
.
q


88 
cuºSèã
) {

89 
	`is
 (
JègSèã
.
Te°LogicRe£t
.
U
) {

90 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Te°LogicRe£t
.
U
, JègSèã.
RunTe°IdÀ
.U)

92 
	`is
 (
JègSèã
.
RunTe°IdÀ
.
U
) {

93 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Sñe˘DRSˇn
.
U
, JègSèã.
RunTe°IdÀ
.U)

95 
	`is
 (
JègSèã
.
Sñe˘DRSˇn
.
U
) {

96 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Sñe˘IRSˇn
.
U
, JègSèã.
C≠tuªDR
.U)

98 
	`is
 (
JègSèã
.
C≠tuªDR
.
U
) {

99 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Exô1DR
.
U
, JègSèã.
Shi·DR
.U)

101 
	`is
 (
JègSèã
.
Shi·DR
.
U
) {

102 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Exô1DR
.
U
, JègSèã.
Shi·DR
.U)

104 
	`is
 (
JègSèã
.
Exô1DR
.
U
) {

105 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Upd©eDR
.
U
, JègSèã.
Pau£DR
.U)

107 
	`is
 (
JègSèã
.
Pau£DR
.
U
) {

108 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Exô2DR
.
U
, JègSèã.
Pau£DR
.U)

110 
	`is
 (
JègSèã
.
Exô2DR
.
U
) {

111 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Upd©eDR
.
U
, JègSèã.
Shi·DR
.U)

113 
	`is
 (
JègSèã
.
Upd©eDR
.
U
) {

114 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Sñe˘DRSˇn
.
U
, JègSèã.
RunTe°IdÀ
.U)

116 
	`is
 (
JègSèã
.
Sñe˘IRSˇn
.
U
) {

117 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Te°LogicRe£t
.
U
, JègSèã.
C≠tuªIR
.U)

119 
	`is
 (
JègSèã
.
C≠tuªIR
.
U
) {

120 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Exô1IR
.
U
, JègSèã.
Shi·IR
.U)

122 
	`is
 (
JègSèã
.
Shi·IR
.
U
) {

123 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Exô1IR
.
U
, JègSèã.
Shi·IR
.U)

125 
	`is
 (
JègSèã
.
Exô1IR
.
U
) {

126 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Upd©eIR
.
U
, JègSèã.
Pau£IR
.U)

128 
	`is
 (
JègSèã
.
Pau£IR
.
U
) {

129 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Exô2IR
.
U
, JègSèã.
Pau£IR
.U)

131 
	`is
 (
JègSèã
.
Exô2IR
.
U
) {

132 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Upd©eIR
.
U
, JègSèã.
Shi·IR
.U)

134 
	`is
 (
JègSèã
.
Upd©eIR
.
U
) {

135 
√xtSèã
 :
	`Mux
(
io
.
tms
, 
JègSèã
.
Sñe˘DRSˇn
.
U
, JègSèã.
RunTe°IdÀ
.U)

137 
	}
}

139 
	gio
.
	gcuºSèã
 :
cuºSèã


142 
JègSèã
.
Sèã
.
Æl
.
f‹óch
 { 
s
 =>

143 
covî
 (
cuºSèã
 ==
s
.
U
 && 
io
.
tms
 ==
åue
.
B
, s"${s.toString}_tms_1", s"JTAG; ${s.toString} with TMS = 1; State Transition from ${s.toString} with TMS = 1")

144 
covî
 (
cuºSèã
 ==
s
.
U
 && 
io
.
tms
 ==
Ál£
.
B
, s"${s.toString}_tms_0", s"JTAG; ${s.toString} with TMS = 0; State Transition from ${s.toString} with TMS = 0")

145 
covî
 (
cuºSèã
 ==
s
.
U
 && 
ª£t
.
toBoﬁ
 ==
åue
.
B
, s"${s.toString}_reset", s"JTAG; ${s.toString} withÑeset; JTAG Resetásserted during ${s.toString}")

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagTap.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
jèg


5 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
S‹ãdM≠


9 
imp‹t
 
	gChi£l
.
_


10 
imp‹t
 
	gchi£l3
.
	gc‹e
.{
	gI≈ut
, 
	gOuçut
}

11 
imp‹t
 
	gchi£l3
.
	gutû
.
_


12 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
wôhRe£t


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


18 
˛ass
 
	$JTAGIO
(
hasTRSTn
: 
Boﬁón
 = 
Ál£
Ë
exãnds
 
BundÀ
 {

19 
vÆ
 
TRSTn
 = i‡(
hasTRSTn
Ë
	`Some
(
	`Ouçut
(
	`Boﬁ
())Ë
N⁄e


20 
vÆ
 
TCK
 = 
	`Ouçut
(
	`Clock
())

21 
vÆ
 
TMS
 = 
	`Ouçut
(
	`Boﬁ
())

22 
vÆ
 
TDI
 = 
	`Ouçut
(
	`Boﬁ
())

23 
vÆ
 
TDO
 = 
	`I≈ut
(
√w
 
	`Tri°©e
())

25 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`JTAGIO
(
hasTRSTn
).
asIn°™˚Of
[
this
.
ty≥
]

26 
	}
}

30 ˛as†
	cJègOuçut
(
úLígth
: 
I¡
Ë
exãnds
 
BundÀ
 {

31 
vÆ
 
°©e
 = 
	`Ouçut
(
JègSèã
.
Sèã
.
	$chi£lTy≥
())

32 
vÆ
 
ö°ru˘i⁄
 = 
	`Ouçut
(
	$UI¡
(
úLígth
.
W
))

33 
vÆ
 
ª£t
 = 
	`Ouçut
(
	$Boﬁ
())

35 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`JègOuçut
(
úLígth
).
asIn°™˚Of
[
this
.
ty≥
]

38 ˛as†
	cJègC⁄åﬁ
 
exãnds
 
BundÀ
 {

39 
vÆ
 
jèg_ª£t
 = 
	`I≈ut
(
	`Boﬁ
())

44 
˛ass
 
	$JègBlockIO
(
úLígth
: 
I¡
, 
hasIdcode
:
Boﬁón
 = 
åue
Ë
exãnds
 
BundÀ
 {

46 
vÆ
 
jèg
 = 
	`Flù≥d
(
√w
 
	`JTAGIO
())

47 
vÆ
 
c⁄åﬁ
 = 
√w
 
JègC⁄åﬁ


48 
vÆ
 
ouçut
 = 
√w
 
	`JègOuçut
(
úLígth
)

49 
vÆ
 
idcode
 = i‡(
hasIdcode
Ë
	`Some
(
	`I≈ut
(
√w
 
	`JTAGIdcodeBundÀ
())Ë
N⁄e


51 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`JègBlockIO
(
úLígth
, 
hasIdcode
).
asIn°™˚Of
[
this
.
ty≥
]

52 
	}
}

56 
˛ass
 
	$JègC⁄åﬁÀrIO
(
úLígth
: 
I¡
Ë
exãnds
 
	$JègBlockIO
(
úLígth
, 
Ál£
) {

57 
vÆ
 
d©aChaöOut
 = 
	`Ouçut
(
√w
 
Shi·îIO
)

58 
vÆ
 
d©aChaöIn
 = 
	`I≈ut
(
√w
 
Shi·îIO
)

60 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`JègC⁄åﬁÀrIO
(
úLígth
).
asIn°™˚Of
[
this
.
ty≥
]

61 
	}
}

69 
˛ass
 
	$JègT≠C⁄åﬁÀr
(
úLígth
: 
I¡
, 
öôülIn°ru˘i⁄
: 
BigI¡
)(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

70 
	`ªquúe
(
úLígth
 >= 2)

72 
vÆ
 
io
 = 
	`IO
(
√w
 
	`JègC⁄åﬁÀrIO
(
úLígth
))

74 
vÆ
 
tdo
 = 
	`Wúe
(
	`Boﬁ
())

75 
vÆ
 
tdo_driví
 = 
	`Wúe
(
	`Boﬁ
())

76 
io
.
jèg
.
TDO
.
d©a
 :
	`NegEdgeReg
(
˛ock
, 
tdo
, 
«me
 = 
	`Some
("tdoReg"))

77 
io
.
jèg
.
TDO
.
driví
 :
	`NegEdgeReg
(
˛ock
, 
tdo_driví
, 
«me
 = 
	`Some
("tdoeReg"))

83 
vÆ
 
cuºSèã
 = 
	`Wúe
(
JègSèã
.
Sèã
.
chi£lTy≥
)

88 
	`ªquúe
(!
io
.
jèg
.
TRSTn
.
isDeföed
, "TRSTn should beábsorbed into jtckPOReset outside of JtagTapController.")

89 
	`wôhRe£t
(
io
.
c⁄åﬁ
.
jèg_ª£t
) {

90 
vÆ
 
°©eMachöe
 = 
	`ModuÀ
(
√w
 
JègSèãMachöe
)

91 
°©eMachöe
.
	`sugge°Name
("stateMachine")

92 
°©eMachöe
.
io
.
tms
 :io.
jèg
.
TMS


93 
cuºSèã
 :
°©eMachöe
.
io
.currState

94 
io
.
ouçut
.
°©e
 :
°©eMachöe
.io.
cuºSèã


103 
vÆ
 
úChaö
 = 
	`ModuÀ
(
	`C≠tuªUpd©eChaö
(
	`UI¡
(
úLígth
.
W
)))

104 
úChaö
.
	`sugge°Name
("irChain")

105 
úChaö
.
io
.
chaöIn
.
shi·
 :
cuºSèã
 ==
JègSèã
.
Shi·IR
.
U


106 
úChaö
.
io
.
chaöIn
.
d©a
 :io.
jèg
.
TDI


107 
úChaö
.
io
.
chaöIn
.
ˇ±uª
 :
cuºSèã
 ==
JègSèã
.
C≠tuªIR
.
U


108 
úChaö
.
io
.
chaöIn
.
upd©e
 :
cuºSèã
 ==
JègSèã
.
Upd©eIR
.
U


109 
úChaö
.
io
.
ˇ±uª
.
bôs
 :"b01".
U


111 
vÆ
 
upd©eIn°ru˘i⁄
 = 
	`Wúe
(
	`Boﬁ
())

113 
vÆ
 
√xtA˘iveIn°ru˘i⁄
 = 
	`Wúe
(
	`UI¡
(
úLígth
.
W
))

114 
vÆ
 
a˘iveIn°ru˘i⁄
 = 
	`NegEdgeReg
(
˛ock
, 
√xtA˘iveIn°ru˘i⁄
, 
upd©eIn°ru˘i⁄
, 
«me
 = 
	`Some
("irReg"))

116 
	`whí
 (
ª£t
.
toBoﬁ
) {

117 
√xtA˘iveIn°ru˘i⁄
 :
öôülIn°ru˘i⁄
.
	`U
(
úLígth
.
W
)

118 
upd©eIn°ru˘i⁄
 :
åue
.
B


119 } .
	`ñ£whí
 (
cuºSèã
 ==
JègSèã
.
Upd©eIR
.
U
) {

120 
√xtA˘iveIn°ru˘i⁄
 :
úChaö
.
io
.
upd©e
.
bôs


121 
upd©eIn°ru˘i⁄
 :
åue
.
B


122 } .
Ÿhîwi£
 {

125 
upd©eIn°ru˘i⁄
 :
Ál£
.
B


127 
io
.
ouçut
.
ö°ru˘i⁄
 :
a˘iveIn°ru˘i⁄


129 
io
.
ouçut
.
ª£t
 :
cuºSèã
 ==
JègSèã
.
Te°LogicRe£t
.
U


134 
io
.
d©aChaöOut
.
shi·
 :
cuºSèã
 ==
JègSèã
.
Shi·DR
.
U


135 
io
.
d©aChaöOut
.
d©a
 :io.
jèg
.
TDI


136 
io
.
d©aChaöOut
.
ˇ±uª
 :
cuºSèã
 ==
JègSèã
.
C≠tuªDR
.
U


137 
io
.
d©aChaöOut
.
upd©e
 :
cuºSèã
 ==
JègSèã
.
Upd©eDR
.
U


142 
	`whí
 (
cuºSèã
 ==
JègSèã
.
Shi·DR
.
U
) {

143 
tdo
 :
io
.
d©aChaöIn
.
d©a


144 
tdo_driví
 :
åue
.
B


145 } .
	`ñ£whí
 (
cuºSèã
 ==
JègSèã
.
Shi·IR
.
U
) {

146 
tdo
 :
úChaö
.
io
.
chaöOut
.
d©a


147 
tdo_driví
 :
åue
.
B


148 } .
Ÿhîwi£
 {

151 
tdo_driví
 :
Ál£
.
B


153 
	}
}

155 
obje˘
 
JègT≠Gíî©‹
 {

180 
def
 
≠∂y
(
úLígth
: 
I¡
, 
ö°ru˘i⁄s
: 
M≠
[
BigI¡
, 
Chaö
], 
icode
: 
O±i⁄
[BigI¡] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
): 
JègBlockIO
 = {

182 
vÆ
 
öã∫ÆIo
 = 
Wúe
(
√w
 
JègBlockIO
(
úLígth
, 
icode
.
isDeföed
))

186 
vÆ
 
	gÆlIn°ru˘i⁄s
 = 
icode
 
m©ch
 {

187 (
Some
(
icode
)) => {

188 
ªquúe
(!(
ö°ru˘i⁄s
 
c⁄èös
 
icode
), "instructions mayÇot contain IDCODE")

189 
vÆ
 
idcodeChaö
 = 
ModuÀ
(
C≠tuªChaö
(
√w
 
JTAGIdcodeBundÀ
()))

190 
idcodeChaö
.
sugge°Name
("idcodeChain")

191 
vÆ
 
i
 = 
öã∫ÆIo
.
idcode
.
gë
.
asUI¡
()

192 
as£π
(
i
 % 2.U === 1.U, "LSB must be set in IDCODE, see 12.1.1d")

193 
as£π
(((
i
 >> 1Ë& ((1.U << 11Ë- 1.U)Ë=/
JègIdcode
.
dummyM‰Id
.
U
,

195 
	gidcodeChaö
.
	gio
.
	gˇ±uª
.
	gbôs
 :
öã∫ÆIo
.
idcode
.
gë


196 
ö°ru˘i⁄s
 + (
icode
 -> 
idcodeChaö
)

199 
N⁄e
 => 
ö°ru˘i⁄s


202 
vÆ
 
by∑ssIcode
 = (
BigI¡
(1Ë<< 
úLígth
) - 1

203 
vÆ
 
öôülIn°ru˘i⁄
 = 
icode
.
gëOrEl£
(
by∑ssIcode
)

205 
ªquúe
(!(
ÆlIn°ru˘i⁄s
 
c⁄èös
 
by∑ssIcode
), "instructions mayÇot contain BYPASS code")

207 
vÆ
 
	gc⁄åﬁÀrI¡î«l
 = 
ModuÀ
(
√w
 
JègT≠C⁄åﬁÀr
(
úLígth
, 
öôülIn°ru˘i⁄
))

209 
vÆ
 
	gunu£dChaöOut
 = 
Wúe
(
√w
 
Shi·îIO
)

210 
unu£dChaöOut
.
shi·
 :
Ál£
.
B


211 
unu£dChaöOut
.
d©a
 :
Ál£
.
B


212 
unu£dChaöOut
.
ˇ±uª
 :
Ál£
.
B


213 
unu£dChaöOut
.
upd©e
 :
Ál£
.
B


215 
vÆ
 
by∑ssChaö
 = 
ModuÀ
(
JègBy∑ssChaö
())

218 
by∑ssChaö
.
io
.
chaöIn
 :
c⁄åﬁÀrI¡î«l
.io.
d©aChaöOut


219 
ªquúe
(
ÆlIn°ru˘i⁄s
.
size
 > 0, "Seriously? JTAG TAP withÇo instructions?")

224 
vÆ
 
	gchaöToIcode
 = (
S‹ãdM≠
(
ÆlIn°ru˘i⁄s
.
toLi°
:
_
*).
groupBy
 { (
icode
, 
chaö
Ë=> chaö } 
	gm≠
 {

225 (
	gchaö
, 
	gicodeToChaö
Ë=> 
chaö
 -> 
icodeToChaö
.
keys


226 }).
	gtoLi°
.
s‹tBy
(
_
.
_2
.
hód
)

228 
vÆ
 
	gchaöToSñe˘
 = 
chaöToIcode
 
m≠
 {

229 (
chaö
, 
icodes
) => {

230 
assume
(
icodes
.
size
 > 0)

231 
vÆ
 
icodeSñe˘s
 = 
icodes
 
m≠
 { 
c⁄åﬁÀrI¡î«l
.
io
.
ouçut
.
ö°ru˘i⁄
 ==
_
.
asUI¡
(
úLígth
.
W
) }

232 
	gchaö
 -> 
	gicodeSñe˘s
.
ªdu˚Le·
(
_
||_)

236 
def
 
fﬁdOutSñe˘
(
ªs
: 
WhíC⁄ãxt
, 
x
: (
Chaö
, 
Boﬁ
)): WhenContext = {

237 
vÆ
 (
chaö
, 
£À˘
Ë
x


239 
ªs
.
ñ£whí
(
£À˘
) {

240 
c⁄åﬁÀrI¡î«l
.
io
.
d©aChaöIn
 :
chaö
.io.
chaöOut


244 
vÆ
 
em±yWhí
 = 
whí
 (
Ál£
.
B
) { }

245 
chaöToSñe˘
.
toSeq
.
fﬁdLe·
(
em±yWhí
)(
fﬁdOutSñe˘
).
Ÿhîwi£
 {

246 
c⁄åﬁÀrI¡î«l
.
io
.
d©aChaöIn
 :
by∑ssChaö
.io.
chaöOut


249 
def
 
m≠InSñe˘
(
x
: (
Chaö
, 
Boﬁ
)) {

250 
vÆ
 (
chaö
, 
£À˘
Ë
x


251 
whí
 (
£À˘
) {

252 
chaö
.
io
.
chaöIn
 :
c⁄åﬁÀrI¡î«l
.io.
d©aChaöOut


253 } .
Ÿhîwi£
 {

254 
chaö
.
io
.
chaöIn
 :
unu£dChaöOut


258 
chaöToSñe˘
.
m≠
(
m≠InSñe˘
)

260 
c⁄åﬁÀrI¡î«l
.
io
.
jèg
 <> 
öã∫ÆIo
.jtag

261 
öã∫ÆIo
.
c⁄åﬁ
 <> 
c⁄åﬁÀrI¡î«l
.
io
.control

262 
öã∫ÆIo
.
ouçut
 <> 
c⁄åﬁÀrI¡î«l
.
io
.output

264 
öã∫ÆIo


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagUtils.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
jèg


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gchi£l3
.
	gutû
.
_


9 ˛as†
	cJTAGIdcodeBundÀ
 
exãnds
 
	mBundÀ
 {

10 
vÆ
 
	mvîsi⁄
 = 
	$UI¡
(4.
W
)

11 
vÆ
 
∑πNumbî
 = 
	$UI¡
(16.
W
)

12 
vÆ
 
m‰Id
 = 
	$UI¡
(11.
W
)

13 
vÆ
 
Æways1
 = 
	`UI¡
(1.
W
)

16 
obje˘
 
JègIdcode
 {

19 
def
 
	`≠∂y
(
vîsi⁄
: 
I¡
, 
∑πNumbî
: I¡, 
m‰Id
: I¡): 
BigI¡
 = {

20 
	`ªquúe
(
vîsi⁄
 < (1 << 4), "version field must be 4 bitsát most")

21 
	`ªquúe
(
∑πNumbî
 < (1 << 16), "partÇumber must be 16 bitsát most")

22 
	`ªquúe
(
m‰Id
 < (1 << 11), "manufacturer identity must be 11 bitsát most")

23 
	`BigI¡
(
vîsi⁄
Ë<< 28 | BigI¡(
∑πNumbî
Ë<< 12 | BigI¡(
m‰Id
) << 1 | 1

29 
def
 
dummyM‰Id
: 
I¡
 = 0x7f

30 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/Utils.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
jèg


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gc‹e
.{
	gI≈ut
, 
	gOuçut
}

7 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
wôhClock


11 ˛as†
	cTri°©e
 
exãnds
 
	mBundÀ
 {

12 
vÆ
 
	md©a
 = 
	$Boﬁ
()

13 
vÆ
 
driví
 = 
	`Boﬁ
()

18 
obje˘
 
NegEdgeReg
 {

19 
def
 
≠∂y
[
T
 <: 
D©a
](
˛ock
: 
Clock
, 
√xt
: T, 
íabÀ
: 
Boﬁ
=
åue
.
B
, 
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): T = {

21 
	`wôhClock
((!
˛ock
.
asUI¡
).
asClock
) {

22 
vÆ
 
ªg
 = 
	`RegE«bÀ
(
√xt
 =Çext, 
íabÀ
 =Énable)

23 
«me
.
f‹óch
{
ªg
.
	`sugge°Name
(
_
)}

24 
ªg


27 
	}
}

32 
˛ass
 
	$ClockedCou¡î
(
cou¡s
: 
BigI¡
, 
öô
: 
O±i⁄
[BigI¡]Ë
exãnds
 
ModuÀ
 {

33 
	`ªquúe
(
cou¡s
 > 0, "really?")

35 
vÆ
 
width
 = 
	`log2Ceû
(
cou¡s
)

36 ˛as†
	cCou¡IO
 
exãnds
 
BundÀ
 {

37 
vÆ
 
cou¡
 = 
	`Ouçut
(
	`UI¡
(
width
.
W
))

38 
	}
}

39 
vÆ
 
	gio
 = 
	$IO
(
√w
 
Cou¡IO
)

41 
vÆ
 
cou¡
 = 
öô
 
m©ch
 {

42 
	`Some
(
öô
Ë=> 
	`RegInô
(öô.
	`U
(
width
.
W
))

43 
N⁄e
 => 
	`Reg
(
	`UI¡
(
width
.
W
))

44 
	}
}

46 
whí
 (
cou¡
 ==(
cou¡s
 - 1).
asUI¡
) {

47 
cou¡
 := 0.U

48 } .
Ÿhîwi£
 {

49 
cou¡
 := count + 1.U

51 
io
.
cou¡
 := count

56 
obje˘
 
ClockedCou¡î
 {

57 
def
 
≠∂y
 (
d©a
: 
Boﬁ
, 
cou¡s
: 
BigI¡
, 
öô
: BigI¡): 
UI¡
 = {

58 
wôhClock
(
d©a
.
asClock
) {

59 
vÆ
 
cou¡î
 = 
ModuÀ
(
√w
 
ClockedCou¡î
(
cou¡s
, 
Some
(
öô
)))

60 
	gcou¡î
.
	gio
.
	gcou¡


64 
def
 
≠∂y
 (
d©a
: 
Boﬁ
, 
cou¡s
: 
BigI¡
): 
UI¡
 = {

65 
wôhClock
(
d©a
.
asClock
) {

66 
vÆ
 
cou¡î
 = 
ModuÀ
(
√w
 
ClockedCou¡î
(
cou¡s
, 
N⁄e
))

67 
	gcou¡î
.
	gio
.
	gcou¡


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
imp‹t
 
	gsˇœ
.
	gœnguage
.
im∂icôC⁄vîsi⁄s


7 
∑ckage
 
obje˘
 
	gjèg
 {

14 
im∂icô
 
def
 
	gö°ru˘i⁄I¡KeyToBigI¡
[
V
 <: 
Chaö
](
x
: (
I¡
, 
	gV
)Ë(
BigI¡
(x.
_1
), 
	gx
.
	g_2
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/Annotation.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
ªgm≠≥r


5 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.{
	gChi£lA¬Ÿ©i⁄
, 
	gRawModuÀ
, 
	gRunFúπlTønsf‹m
}

6 
imp‹t
 
	gfúπl
.
	g™nŸ©i⁄s
.
_


7 
imp‹t
 
	gfúπl
.{
	gCúcuôF‹m
, 
	gCúcuôSèã
, 
	gLowF‹m
, 
	gTønsf‹m
}

9 
˛ass
 
RegFõldDescSî
(

10 
byãOff£t
: 
Såög
,

11 
bôOff£t
: 
I¡
,

12 
bôWidth
: 
I¡
,

13 
«me
: 
Såög
,

14 
ª£tVÆue
: 
BigI¡
,

15 
ac˚ssTy≥
: 
Såög
,

16 
wrTy≥
: 
Såög
,

17 
rdA˘i⁄
: 
Såög
,

18 
desc
: 
Såög
,

19 
group
: 
Såög
,

20 
groupDesc
: 
Såög
,

21 vﬁ©ûe: 
Boﬁón
 = 
Ál£
,

22 
hasRe£t
: 
Boﬁón
 = 
Ál£
,

23 
íumî©i⁄s
: 
M≠
[
BigI¡
, (
Såög
, Såög)] = 
	$M≠
()

26 
˛ass
 
	`Regi°îsSî
(

27 
di•œyName
: 
Såög
,

28 
devi˚Name
: 
Såög
,

29 
ba£Addªss
: 
BigI¡
,

30 
ªgFõlds
: 
Seq
[
RegFõldDescSî
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/DescribedReg.scala

2 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
ªgm≠≥r


4 
imp‹t
 
	gChi£l
.
_


5 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
_


6 
imp‹t
 
	gchi£l3
.{
	gI≈ut
, 
	gOuçut
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gAsyncRe£tRegVec
, 
	gSim∂eRegIO
}

9 
obje˘
 
	gDes¸ibedReg
 {

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
	gRegFõldAc˚ssTy≥
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
	gRegFõldWrTy≥
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
	gRegFõldRdA˘i⁄
.
_


14 
def
 
	g≠∂y
[
T
 <: 
D©a
](

15 
gí
: => 
T
,

16 
	g«me
: 
Såög
,

17 
	gdesc
: 
Såög
,

18 
	gª£t
: 
O±i⁄
[
T
],

19 
	gac˚ss
: 
RegFõldAc˚ssTy≥
 = 
RW
,

20 
	gwrTy≥
: 
O±i⁄
[
RegFõldWrTy≥
] = 
N⁄e
,

21 
	grdA˘i⁄
: 
O±i⁄
[
RegFõldRdA˘i⁄
] = 
N⁄e
,

22 vﬁ©ûe: 
Boﬁón
 = 
Ál£
,

23 
	gíumî©i⁄s
: 
M≠
[
BigI¡
, (
Såög
, Såög)] = M≠()): (
T
, 
	gRegFõldDesc
) = {

24 
vÆ
 
rdesc
 = 
RegFõldDesc
(
«me
, 
desc
, 
N⁄e
, None,

25 
ac˚ss
, 
wrTy≥
, 
rdA˘i⁄
, vﬁ©ûe, 
ª£t
.
m≠
{
_
.
lôVÆue
}, 
íumî©i⁄s
)

26 
vÆ
 
	gªg
 = 
ª£t
.
m≠
{
i
 => 
RegInô
(i)}.
gëOrEl£
(
Reg
(
gí
))

27 
	gªg
.
sugge°Name
(
«me
 + "_reg")

28 (
	gªg
, 
	grdesc
)

31 
def
 
async
(

32 
width
: 
I¡
,

33 
«me
: 
Såög
,

34 
desc
: 
Såög
,

35 
ª£t
: 
I¡
,

36 
ac˚ss
: 
RegFõldAc˚ssTy≥
 = 
RW
,

37 
wrTy≥
: 
O±i⁄
[
RegFõldWrTy≥
] = 
N⁄e
,

38 
rdA˘i⁄
: 
O±i⁄
[
RegFõldRdA˘i⁄
] = 
N⁄e
,

39 vﬁ©ûe: 
Boﬁón
 = 
Ál£
,

40 
íumî©i⁄s
: 
M≠
[
BigI¡
, (
Såög
, Såög)] = M≠()): (
Sim∂eRegIO
, 
	gRegFõldDesc
) = {

41 
vÆ
 
rdesc
 = 
RegFõldDesc
(
«me
, 
desc
, 
N⁄e
, None,

42 
ac˚ss
, 
wrTy≥
, 
rdA˘i⁄
, vﬁ©ûe, 
Some
(
ª£t
), 
íumî©i⁄s
)

43 
vÆ
 
	gªg
 = 
ModuÀ
(
√w
 
AsyncRe£tRegVec
(
w
 = 
width
, 
öô
 = 
ª£t
))

44 
ªg
.
sugge°Name
(
«me
 + "_reg")

45 (
ªg
.
io
, 
	grdesc
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegField.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
ªgm≠≥r


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.{
	gRódyVÆidIO
}

8 
imp‹t
 
	g‹g
.
	gjs⁄4s
.
	gJs⁄DSL
.
_


9 
imp‹t
 
	g‹g
.
	gjs⁄4s
.
	gJs⁄AST
.
JVÆue


10 
imp‹t
 
	g‹g
.
	gjs⁄4s
.
	gjacks⁄
.
	gJs⁄Mëhods
.{
	g¥ëty
, 
	gªndî
}

12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gSim∂eRegIO
}

19 
obje˘
 
RegFõldAc˚ssTy≥
 
exãnds
 
	gsˇœ
.
	gEnumî©i⁄
 {

20 
ty≥
 
	gRegFõldAc˚ssTy≥
 = 
VÆue


21 
vÆ
 
R
, 
	gW
, 
	gRW
 = 
VÆue


23 
imp‹t
 
	gRegFõldAc˚ssTy≥
.
_


25 
obje˘
 
RegFõldWrTy≥
 
exãnds
 
	gsˇœ
.
	gEnumî©i⁄
 {

26 
ty≥
 
	gRegFõldWrTy≥
 = 
VÆue


27 
vÆ
 
ONE_TO_CLEAR
, 
	gONE_TO_SET
, 
	gONE_TO_TOGGLE
, 
	gZERO_TO_CLEAR
,

28 
	gZERO_TO_SET
, 
	gZERO_TO_TOGGLE
, 
	gCLEAR
, 
	gSET
, 
	gMODIFY
 = 
VÆue


30 
imp‹t
 
	gRegFõldWrTy≥
.
_


32 
obje˘
 
RegFõldRdA˘i⁄
 
exãnds
 
	gsˇœ
.
	gEnumî©i⁄
 {

33 
ty≥
 
	gRegFõldRdA˘i⁄
 = 
VÆue


34 
vÆ
 
CLEAR
, 
	gSET
, 
	gMODIFY
 = 
VÆue


36 
imp‹t
 
	gRegFõldRdA˘i⁄
.
_


38 
˛ass
 
RegFõldDesc
 (

39 
«me
: 
Såög
,

40 
desc
: 
Såög
,

41 
group
: 
O±i⁄
[
Såög
] = 
N⁄e
,

42 
groupDesc
: 
O±i⁄
[
Såög
] = 
N⁄e
,

43 
ac˚ss
: 
RegFõldAc˚ssTy≥
 = RegFõldAc˚ssTy≥.
RW
,

44 
wrTy≥
: 
O±i⁄
[
RegFõldWrTy≥
] = 
N⁄e
,

45 
rdA˘i⁄
: 
O±i⁄
[
RegFõldRdA˘i⁄
] = 
N⁄e
,

46 vﬁ©ûe: 
Boﬁón
 = 
Ál£
,

48 
ª£t
: 
O±i⁄
[
BigI¡
] = 
N⁄e
,

49 
íumî©i⁄s
: 
M≠
[
BigI¡
, (
Såög
, Såög)] = 
	$M≠
()

52 
obje˘
 
RegFõldDesc
 {

53 
def
 
ª£rved
: 
RegFõldDesc
 = 
	`RegFõldDesc
("ª£rved", "", 
ac˚ss
=
RegFõldAc˚ssTy≥
.
R
, 
ª£t
=
	`Some
(0))

54 
	}
}

62 
obje˘
 
	gRegFõldGroup
 {

63 
def
 
≠∂y
 (
«me
: 
Såög
, 
desc
: 
O±i⁄
[Såög], 
ªgs
: 
Seq
[
RegFõld
], 
descFú°O∆y
: 
Boﬁón
 = 
åue
): Seq[RegField] = {

64 
ªgs
.
zùWôhIndex
.
m≠
 {(
r
, 
i
) =>

65 
vÆ
 
gDesc
 = i‡((
i
 > 0Ë& 
descFú°O∆y
Ë
N⁄e
 
desc


66 
r
.
desc
.
m≠
 { 
d
 =>

67 
r
.
c›y
(
desc
 = 
Some
(
d
.c›y(
group
 = Some(
«me
), 
groupDesc
 = 
gDesc
)) )

68 }.
gëOrEl£
(
r
)

73 
˛ass
 
RegRódFn
 
¥iv©e
(
combö©i⁄Æ
: 
Boﬁón
, 
‚
: (
Boﬁ
, BoﬁË=> (Boﬁ, Boﬁ, 
UI¡
))

74 
obje˘
 
	gRegRódFn


81 
im∂icô
 
def
 
≠∂y
(
x
: (
Boﬁ
, BoﬁË=> (Boﬁ, Boﬁ, 
UI¡
)) =

82 
√w
 
RegRódFn
(
Ál£
, 
x
)

83 
im∂icô
 
def
 
≠∂y
(
x
: 
Regi°îRódIO
[
UI¡
]): 
RegRódFn
 =

84 
RegRódFn
((
ivÆid
, 
‹ódy
) => {

85 
x
.
ªque°
.
vÆid
 :
ivÆid


86 
x
.
ª•⁄£
.
ªady
 :
‹ódy


87 (
x
.
ªque°
.
ªady
, x.
ª•⁄£
.
vÆid
, x.ª•⁄£.
bôs
)

92 
im∂icô
 
def
 
≠∂y
(
x
: 
Boﬁ
 => (Boﬁ, 
UI¡
)) =

93 
√w
 
RegRódFn
(
åue
, { (
_
, 
‹ódy
) =>

94 
vÆ
 (
ovÆid
, 
d©a
Ë
x
(
‹ódy
)

95 (
Boﬁ
(
åue
), 
ovÆid
, 
d©a
)

98 
im∂icô
 
def
 
≠∂y
(
x
: 
RódyVÆidIO
[
UI¡
]):
RegRódFn
 = RegRódFn(
ªady
 => { x.ªady :ªady; (x.
vÆid
, x.
bôs
) })

100 
im∂icô
 
def
 
≠∂y
(
x
: 
UI¡
):
RegRódFn
 = RegRódFn(
ªady
 => (
Boﬁ
(
åue
), x))

102 
im∂icô
 
def
 
≠∂y
(
x
: 
Unô
):
RegRódFn
 = RegRódFn(
UI¡
(0))

105 
˛ass
 
RegWrôeFn
 
¥iv©e
(
combö©i⁄Æ
: 
Boﬁón
, 
‚
: (
Boﬁ
, Boﬁ, 
UI¡
) => (Bool, Bool))

106 
obje˘
 
	gRegWrôeFn


113 
im∂icô
 
def
 
≠∂y
(
x
: (
Boﬁ
, Boﬁ, 
UI¡
) => (Bool, Bool)) =

114 
√w
 
RegWrôeFn
(
Ál£
, 
x
)

115 
im∂icô
 
def
 
≠∂y
(
x
: 
Regi°îWrôeIO
[
UI¡
]): 
RegWrôeFn
 =

116 
RegWrôeFn
((
ivÆid
, 
‹ódy
, 
d©a
) => {

117 
x
.
ªque°
.
vÆid
 :
ivÆid


118 
x
.
ªque°
.
bôs
 :
d©a


119 
x
.
ª•⁄£
.
ªady
 :
‹ódy


120 (
x
.
ªque°
.
ªady
, x.
ª•⁄£
.
vÆid
)

125 
im∂icô
 
def
 
≠∂y
(
x
: (
Boﬁ
, 
UI¡
) => Bool) =

127 
√w
 
RegWrôeFn
(
åue
, { (
_
, 
‹ódy
, 
d©a
) =>

128 (
Boﬁ
(
åue
), 
x
(
‹ódy
, 
d©a
))

132 
im∂icô
 
def
 
≠∂y
(
x
: 
Decou∂edIO
[
UI¡
]): 
RegWrôeFn
 = RegWrôeFn((
vÆid
, 
d©a
Ë=> { x.vÆid :vÆid; x.
bôs
 :d©a; x.
ªady
 })

134 
im∂icô
 
def
 
≠∂y
(
x
: 
UI¡
): 
RegWrôeFn
 = RegWrôeFn((
vÆid
, 
d©a
Ë=> { 
whí
 (vÆidË{ x :d©®}; 
Boﬁ
(
åue
) })

136 
im∂icô
 
def
 
≠∂y
(
x
: 
Unô
): 
RegWrôeFn
 = RegWrôeFn((
vÆid
, 
d©a
Ë=> { 
Boﬁ
(
åue
) })

139 
˛ass
 
	$RegFõld
(
width
: 
I¡
, 
ªad
: 
RegRódFn
, 
wrôe
: 
RegWrôeFn
, 
desc
: 
O±i⁄
[
RegFõldDesc
])

141 
	`ªquúe
 (
width
 >0, 
s
"RegField width must be >= 0,Çot $width")

143 
def
 
pùñöed
 = !
ªad
.
combö©i⁄Æ
 || !
wrôe
.combinational

145 
def
 
ªadO∆y
 = 
this
.
	`c›y
(
wrôe
 = (), 
desc
 =Åhis.desc.
	`m≠
(
_
.c›y(
ac˚ss
 = 
RegFõldAc˚ssTy≥
.
R
)))

147 
def
 
	`toJs⁄
(
byãOff£t
: 
I¡
, 
bôOff£t
: I¡): 
JVÆue
 = {

148 –("byãOff£t" -> 
s
"0x${byteOffset.toHexString}") ~

149 ("bôOff£t" -> 
bôOff£t
) ~

150 ("bôWidth" -> 
width
) ~

151 ("«me" -> 
desc
.
	`m≠
(
_
.
«me
)) ~

152 ("des¸ùti⁄" -> 
desc
.
m≠
{ 
d
=> i‡(d.des¯=""Ë
N⁄e
 
	`Some
(d.desc)}) ~

153 ("ª£tVÆue" -> 
desc
.
m≠
{
_
.
ª£t
}) ~

154 ("group" -> 
desc
.
m≠
{
_
.
group
}) ~

155 ("groupDesc" -> 
desc
.
m≠
{
_
.
groupDesc
}) ~

156 ("ac˚ssTy≥" -> 
desc
.
m≠
 {
d
 => d.
ac˚ss
.
toSåög
}) ~

157 ("wrôeTy≥" -> 
desc
.
m≠
 {
d
 => d.
wrTy≥
.
	`m≠
(
_
.
toSåög
)}) ~

158 ("ªadA˘i⁄" -> 
desc
.
m≠
 {
d
 => d.
rdA˘i⁄
.
	`m≠
(
_
.
toSåög
)}) ~

159 ("vﬁ©ûe" -> 
desc
.
m≠
 {
d
 => i‡(d.vﬁ©ûeË
	`Some
(
åue
Ë
N⁄e
}) ~

160 ("íumî©i⁄s" -> 
desc
.
m≠
 {
d
 =>

161 
	`O±i⁄
(
d
.
íumî©i⁄s
.
m≠
 { (
key
, (
«me
, 
edesc
)) =>

162 (("vÆue" -> 
key
Ë~ ("«me" -> 
«me
Ë~ ("des¸ùti⁄" -> 
edesc
))

163 }).
	`fûãr
(
_
.
n⁄Em±y
)}) )

165 
	}
}

167 
obje˘
 
	gRegFõld


170 
ty≥
 
	gM≠
 = (
I¡
, 
	gSeq
[
RegFõld
])

172 
def
 
≠∂y
(
n
: 
I¡
Ë: 
RegFõld
 =áµly“, (), (), 
Some
(
RegFõldDesc
.
ª£rved
))

174 
def
 
≠∂y
(
n
: 
I¡
, 
r
: 
RegRódFn
, 
w
: 
RegWrôeFn
Ë: 
RegFõld
 =áµly“,Ñ, w, 
N⁄e
)

175 
def
 
≠∂y
(
n
: 
I¡
, 
r
: 
RegRódFn
, 
w
: 
RegWrôeFn
, 
desc
: 
RegFõldDesc
Ë: 
RegFõld
 =áµly“,Ñ, w, 
Some
(desc))

176 
def
 
≠∂y
(
n
: 
I¡
, 
rw
: 
UI¡
Ë: 
RegFõld
 =áµly“,Ñw,Ñw, 
N⁄e
)

177 
def
 
≠∂y
(
n
: 
I¡
, 
rw
: 
UI¡
, 
desc
: 
RegFõldDesc
Ë: 
RegFõld
 =áµly“,Ñw,Ñw, 
Some
(desc))

178 
def
 
r
(
n
: 
I¡
,Ñ: 
RegRódFn
Ë: 
RegFõld
 = 
≠∂y
“,Ñ, (), 
N⁄e
)

179 
def
 
r
(
n
: 
I¡
,Ñ: 
RegRódFn
, 
desc
: 
RegFõldDesc
Ë: 
RegFõld
 = 
≠∂y
“,Ñ, (), 
Some
(desc.
c›y
(
ac˚ss
 = 
RegFõldAc˚ssTy≥
.
R
)))

180 
def
 
w
(
n
: 
I¡
, w: 
RegWrôeFn
Ë: 
RegFõld
 = 
≠∂y
“, (), w, 
N⁄e
)

181 
def
 
w
(
n
: 
I¡
, w: 
RegWrôeFn
, 
desc
: 
RegFõldDesc
Ë: 
RegFõld
 = 
≠∂y
“, (), w, 
Some
(desc.
c›y
(
ac˚ss
 = 
RegFõldAc˚ssTy≥
.
W
)))

186 
def
 
w1ToCÀ¨
(
n
: 
I¡
, 
ªg
: 
UI¡
, 
£t
: UI¡, 
desc
: 
O±i⁄
[
RegFõldDesc
] = 
N⁄e
): 
RegFõld
 =

187 
RegFõld
(
n
, 
ªg
, 
RegWrôeFn
((
vÆid
, 
d©a
Ë=> {Ñeg :~(~ªg | 
Mux
(vÆid, d©a, 
UI¡
(0))Ë| 
£t
; 
Boﬁ
(
åue
) }),

188 
desc
.
m≠
{
_
.
c›y
(
ac˚ss
 = 
RegFõldAc˚ssTy≥
.
RW
, 
wrTy≥
=
Some
(
RegFõldWrTy≥
.
ONE_TO_CLEAR
), vﬁ©ûê
åue
)})

192 
def
 
rwReg
(
n
: 
I¡
, 
bb
: 
Sim∂eRegIO
, 
desc
: 
O±i⁄
[
RegFõldDesc
] = 
N⁄e
Ë: 
RegFõld
 =

193 
RegFõld
(
n
, 
bb
.
q
, 
RegWrôeFn
((
vÆid
, 
d©a
) => {

194 
bb
.
í
 :
vÆid


195 
bb
.
d
 :
d©a


196 
Boﬁ
(
åue
)

197 }), 
desc
)

204 
def
 
byãs
(
ªg
: 
UI¡
, 
numByãs
: 
I¡
, 
desc
: 
O±i⁄
[
RegFõldDesc
]): 
Seq
[
RegFõld
] = {

205 
ªquúe
(
ªg
.
gëWidth
 * 8 >
numByãs
, "Can't breaká ${reg.getWidth}-bit-wideÑegister into only ${numBytes} bytes.")

206 
vÆ
 
	gnumFuŒByãs
 = 
ªg
.
gëWidth
/8

207 
vÆ
 
numP¨tülByãs
 = i‡((
ªg
.
gëWidth
 % 8) > 0) 1 0

208 
vÆ
 
numPadByãs
 = 
numByãs
 - 
numFuŒByãs
 - 
numP¨tülByãs


209 
vÆ
 
∑d
 = 
ªg
 | 
UI¡
(0, 
width
 = 8*
numByãs
)

210 
vÆ
 
ﬁdByãs
 = 
Vec
.
èbuœã
(
numByãs
Ë{ 
i
 => 
∑d
(8*(i+1)-1, 8*i) }

211 
vÆ
 
	g√wByãs
 = 
Wúe
(
öô
 = 
ﬁdByãs
)

212 
vÆ
 
vÆids
 = 
Wúe
(
öô
 = 
Vec
.
fûl
(
numByãs
Ë{ 
Boﬁ
(
Ál£
) })

213 
whí
 (
vÆids
.
ªdu˚
(
_
 || _)Ë{ 
ªg
 :
√wByãs
.
asUI¡
 }

215 
def
 
wrFn
(
i
: 
I¡
): 
RegWrôeFn
 = RegWrôeFn((
vÆid
, 
d©a
) => {

216 
vÆids
(
i
Ë:
vÆid


217 
whí
 (
vÆid
Ë{
√wByãs
(
i
Ë:
d©a
}

218 
Boﬁ
(
åue
)

221 
vÆ
 
fuŒByãs
 = 
Seq
.
èbuœã
(
numFuŒByãs
Ë{ 
i
 =>

222 
vÆ
 
√wDesc
 = 
desc
.
m≠
 {
d
 => d.
c›y
(
«me
 = d.«mê+ 
s
"_$i")}

223 
RegFõld
(8, 
ﬁdByãs
(
i
), 
wrFn
(i), 
√wDesc
)}

224 
vÆ
 
	g∑πülByãs
 = i‡(
numP¨tülByãs
 > 0) {

225 
vÆ
 
√wDesc
 = 
desc
.
m≠
 {
d
 => d.
c›y
(
«me
 = d.«mê+ 
s
"_$numFullBytes")}

226 
Seq
(
RegFõld
(
ªg
.
gëWidth
 % 8, 
ﬁdByãs
(
numFuŒByãs
), 
wrFn
“umFuŒByãs), 
√wDesc
),

227 
RegFõld
(8 - (
ªg
.
gëWidth
 % 8)))

228 } 
Nû


229 
vÆ
 
	g∑dByãs
 = 
Seq
.
fûl
(
numPadByãs
){
RegFõld
(8)}

230 
fuŒByãs
 ++ 
∑πülByãs
 ++ 
∑dByãs


233 
def
 
byãs
(
ªg
: 
UI¡
, 
desc
: 
O±i⁄
[
RegFõldDesc
]): 
Seq
[
RegFõld
] = {

234 
vÆ
 
width
 = 
ªg
.
gëWidth


235 
ªquúe
 (
width
 % 8 =0, 
s
"RegField.bytes must be called on byte-sizedÑeg,Çot ${width} bits")

236 
byãs
(
ªg
, 
width
/8, 
desc
)

239 
def
 
byãs
(
ªg
: 
UI¡
, 
numByãs
: 
I¡
): 
Seq
[
RegFõld
] = byãs‘eg,ÇumByãs, 
N⁄e
)

240 
def
 
byãs
(
ªg
: 
UI¡
): 
Seq
[
RegFõld
] = byãs‘eg, 
N⁄e
)

244 
åaô
 
	gHasRegM≠


246 
def
 
ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*): 
Unô


247 
vÆ
 
öãºu±s
: 
Vec
[
Boﬁ
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegMapper.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
ªgm≠≥r


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gGíîicP¨amëîizedBundÀ
, 
	gRedu˚Othîs
, 
	gMuxSeq
}

9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


10 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.{
	gSour˚Info
, 
	gSour˚Löe
}

14 
˛ass
 
	$RegM≠≥rP¨ams
(
ödexBôs
: 
I¡
, 
maskBôs
: I¡, 
exåaBôs
: Int)

16 ˛as†
	cRegM≠≥rI≈ut
(
∑øms
: 
RegM≠≥rP¨ams
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

18 
vÆ
 
ªad
 = 
	$Boﬁ
()

19 
vÆ
 
ödex
 = 
	$UI¡
(
width
 = 
∑øms
.
ödexBôs
)

20 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
maskBôs
*8)

21 
vÆ
 
mask
 = 
	$UI¡
(
width
 = 
∑øms
.
maskBôs
)

22 
vÆ
 
exåa
 = 
	`UI¡
(
width
 = 
∑øms
.
exåaBôs
)

25 ˛as†
	cRegM≠≥rOuçut
(
∑øms
: 
RegM≠≥rP¨ams
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

27 
vÆ
 
ªad
 = 
	$Boﬁ
()

28 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
maskBôs
*8)

29 
vÆ
 
exåa
 = 
	`UI¡
(
width
 = 
∑øms
.
exåaBôs
)

32 
obje˘
 
RegM≠≥r


35 
def
 
	`≠∂y
(
byãs
: 
I¡
, 
c⁄cuºícy
: I¡, 
undefZîo
: 
Boﬁón
, 
ö
: 
Decou∂edIO
[
RegM≠≥rI≈ut
], 
m≠pög
: 
RegFõld
.
M≠
*)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) = {

37 
vÆ
 
byãm≠
 = 
m≠pög
.
toLi°
.
m≠
 { (
off£t
, 
fõlds
Ë=> (off£t, fõlds.
	`fûãr
(
_
.
width
 != 0)) }

40 
byãm≠
.
f‹óch
 { 
byã
 => 
	`ªquúe
 (byã.
_1
 >= 0) }

43 
vÆ
 
bôm≠
 = 
byãm≠
.
m≠
 { (
byã
, 
fõlds
) =>

44 
vÆ
 
bôs
 = 
fõlds
.
	`sˇnLe·
(
byã
 * 8)(
_
 + _.
width
).
öô


45 
bôs
 
zù
 
fõlds


46 }.
Ê©ãn
.
	`s‹tBy
(
_
.
_1
)

49 (
bôm≠
.
öô
 
zù
 bôm≠.
èû
Ë
f‹óch
 { ((
lbô
, 
lfõld
), (
rbô
, 
rfõld
)) =>

50 
	`ªquúe
 (
lbô
 + 
lfõld
.
width
 <
rbô
, 
s
"Register map overlapsát bit ${rbit}.")

54 
vÆ
 
w‹dm≠
 = 
bôm≠
.
	`groupBy
(
_
.
_1
 / (8*
byãs
))

57 
vÆ
 
öP¨ams
 = 
ö
.
bôs
.
∑øms


58 
vÆ
 
öBôs
 = 
öP¨ams
.
ödexBôs


59 
	`as£π
 (
w‹dm≠
.
keySë
.
max
 < (1 << 
öBôs
), "Register map doesÇot fit in device")

61 
vÆ
 
out
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`RegM≠≥rOuçut
(
öP¨ams
)))

62 
vÆ
 
‰⁄t
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`RegM≠≥rI≈ut
(
öP¨ams
)))

63 
‰⁄t
.
bôs
 :
ö
.bits

66 
vÆ
 
pùñöed
 = 
w‹dm≠
.
vÆues
.
	`m≠
(
_
.m≠(_.
_2
.pùñöed)).
Ê©ãn
.
	`ªdu˚
(_ || _)

67 
vÆ
 
dïth
 = 
c⁄cuºícy


68 
	`ªquúe
 (
dïth
 >= 0)

69 
	`ªquúe
 (!
pùñöed
 || 
dïth
 > 0, "Register-based device withÑequest/response handshakingÇeeds concurrency > 0")

70 
vÆ
 
back
 = i‡(
dïth
 > 0Ë
	`Queue
(
‰⁄t
, depth) front

73 
def
 
	`toBôs
(
x
: 
I¡
, 
èû
: 
Li°
[
Boﬁón
] = Li°.
em±y
): List[Boolean] =

74 i‡(
x
 =0Ë
èû
.
ªvî£
 
	`toBôs
(x >> 1, ((x & 1) == 1) ::Åail)

75 
def
 
	`ofBôs
(
bôs
: 
Li°
[
Boﬁón
]Ëbôs.
	`fﬁdRight
(0){ (
x
,
y
) => (if (x) 1 0) | y << 1 }

78 
vÆ
 
mask
 = 
	`AddªssDecodî
(
w‹dm≠
.
keySë
.
toLi°
)

79 
vÆ
 
maskM©ch
 = ~
	`UI¡
(
mask
, 
width
 = 
öBôs
)

80 
vÆ
 
maskFûãr
 = 
	`toBôs
(
mask
)

81 
vÆ
 
maskBôs
 = 
maskFûãr
.
	`fûãr
(
x
 => x).
size


84 
vÆ
 
ªgSize
 = 1 << 
maskBôs


85 
def
 
	`ªgIndexI
(
x
: 
I¡
Ë
	`ofBôs
((
maskFûãr
 
zù
 
	`toBôs
(x)).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
))

86 
def
 
	`ªgIndexU
(
x
: 
UI¡
Ëi‡(
maskBôs
 =0Ë
	`UI¡
(0) 

87 
	`C©
((
maskFûãr
 
zù
 
x
.
toBoﬁs
).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
).
ªvî£
)

89 
vÆ
 
födex
 = 
‰⁄t
.
bôs
.
ödex
 & 
maskM©ch


90 
vÆ
 
bödex
 = 
back
 .
bôs
.
ödex
 & 
maskM©ch


93 
vÆ
 
iRightReg
 = 
Aºay
.
	`fûl
(
ªgSize
Ë{ 
	`Boﬁ
(
åue
) }

94 
vÆ
 
oRightReg
 = 
Aºay
.
	`fûl
(
ªgSize
Ë{ 
	`Boﬁ
(
åue
) }

97 
vÆ
 
Ê©
 = 
w‹dm≠
.
toLi°
.
m≠
 { (
w‹d
, 
fõlds
) =>

98 
vÆ
 
ödex
 = 
	`ªgIndexI
(
w‹d
)

99 i‡(
undefZîo
) {

100 
vÆ
 
uöt
 = 
	`UI¡
(
w‹d
 & ~
mask
, 
width
 = 
öBôs
)

101 
	`iRightReg
(
ödex
Ë
födex
 ==
uöt


102 
	`oRightReg
(
ödex
Ë
bödex
 ==
uöt


105 
fõlds
 
f‹óch
 { (
bô
, 
fõld
) =>

106 
vÆ
 
off
 = 
bô
 - 8*
byãs
*
w‹d


108 
	`ªquúe
 (
off
 + 
fõld
.
width
 <
byãs
 * 8, 
s
"Fieldát word ${word}*(${bytes}B) has bits [${off}, ${off+field.width}), whichÉxceeds wordÜimit.")

111 
fõlds
.
m≠
 { (
bô
, 
fõld
Ë=> (
ödex
, bô-8*
byãs
*
w‹d
, field) }

112 }.
Ê©ãn


115 
vÆ
 
rivÆid
 = 
	`Wúe
(
	`Vec
(
Ê©
.
size
, 
	`Boﬁ
()))

116 
vÆ
 
wivÆid
 = 
	`Wúe
(
	`Vec
(
Ê©
.
size
, 
	`Boﬁ
()))

117 
vÆ
 
r‹ódy
 = 
	`Wúe
(
	`Vec
(
Ê©
.
size
, 
	`Boﬁ
()))

118 
vÆ
 
w‹ódy
 = 
	`Wúe
(
	`Vec
(
Ê©
.
size
, 
	`Boﬁ
()))

121 
vÆ
 
rifúe
 = 
Aºay
.
	`fûl
(
ªgSize
Ë{ 
Nû
:
Li°
[(
Boﬁ
, Bool)] }

122 
vÆ
 
wifúe
 = 
Aºay
.
	`fûl
(
ªgSize
Ë{ 
Nû
:
Li°
[(
Boﬁ
, Bool)] }

123 
vÆ
 
rofúe
 = 
Aºay
.
	`fûl
(
ªgSize
Ë{ 
Nû
:
Li°
[(
Boﬁ
, Bool)] }

124 
vÆ
 
wofúe
 = 
Aºay
.
	`fûl
(
ªgSize
Ë{ 
Nû
:
Li°
[(
Boﬁ
, Bool)] }

127 
vÆ
 
d©aOut
 = 
Aºay
.
	`fûl
(
ªgSize
Ë{ 
	`UI¡
(0) }

130 
vÆ
 
‰⁄tMask
 = 
	`FûlI¡îÀaved
(8, 
‰⁄t
.
bôs
.
mask
)

131 
vÆ
 
backMask
 = 
	`FûlI¡îÀaved
(8, 
back
 .
bôs
.
mask
)

134 
i
 <- 0 
u¡û
 
Ê©
.
size
) {

135 
	`vÆ
 (
ªg
, 
low
, 
fõld
Ë
	`Ê©
(
i
)

136 
vÆ
 
high
 = 
low
 + 
fõld
.
width
 - 1

138 
	`ªquúe
 (
high
 < 8*
byãs
)

139 
vÆ
 
rimask
 = 
	`‰⁄tMask
(
high
, 
low
).
	`‹R
()

140 
vÆ
 
wimask
 = 
	`‰⁄tMask
(
high
, 
low
).
	`™dR
()

141 
vÆ
 
romask
 = 
	`backMask
(
high
, 
low
).
	`‹R
()

142 
vÆ
 
womask
 = 
	`backMask
(
high
, 
low
).
	`™dR
()

143 
vÆ
 
d©a
 = i‡(
fõld
.
wrôe
.
combö©i⁄Æ
Ë
back
.
bôs
.d©®
‰⁄t
.bits.data

144 
vÆ
 
f_rivÆid
 = 
	`rivÆid
(
i
Ë&& 
rimask


145 
vÆ
 
f_r‹ódy
 = 
	`r‹ódy
(
i
Ë&& 
romask


146 
vÆ
 
f_wivÆid
 = 
	`wivÆid
(
i
Ë&& 
wimask


147 
vÆ
 
f_w‹ódy
 = 
	`w‹ódy
(
i
Ë&& 
womask


148 
	`vÆ
 (
f_rúódy
, 
f_rovÆid
, 
f_d©a
Ë
fõld
.
ªad
.
	`‚
(
f_rivÆid
, 
f_r‹ódy
)

149 
	`vÆ
 (
f_wúódy
, 
f_wovÆid
Ë
fõld
.
wrôe
.
	`‚
(
f_wivÆid
, 
f_w‹ódy
, 
	`d©a
(
high
, 
low
))

152 
vÆ
 
‚ame
 = 
fõld
.
desc
.
m≠
{
_
.
«me
}.
	`gëOrEl£
("")

153 
vÆ
 
fdesc
 = 
fõld
.
desc
.
m≠
{
_
.des¯+ ":"}.
	`gëOrEl£
("")

155 
	`covî
(
f_rivÆid
 && 
f_rúódy
, 
‚ame
 + "_Reg_ªad_°¨t", 
fdesc
 + " RegField Read Request Initiate")

156 
	`covî
(
f_rovÆid
 && 
f_r‹ódy
, 
‚ame
 + "_Reg_ªad_out", 
fdesc
 + " RegField Read Request Complete")

157 
	`covî
(
f_wivÆid
 && 
f_wúódy
, 
‚ame
 + "_Reg_wrôe_°¨t", 
fdesc
 + " RegField Write Request Initiate")

158 
	`covî
(
f_wovÆid
 && 
f_w‹ódy
, 
‚ame
 + "_Reg_wrôe_out", 
fdesc
 + " RegField Write Request Complete")

160 
def
 
	`lôOR
(
x
: 
Boﬁ
, 
y
: BoﬁËi‡(x.
isLô
 && x.
lôVÆue
 =1Ë
	`Boﬁ
(
åue
) x || y

162 
	`rifúe
(
ªg
Ë(
	`rivÆid
(
i
), 
	`lôOR
(
f_rúódy
, !
rimask
)) +:Ñifire(reg)

163 
	`wifúe
(
ªg
Ë(
	`wivÆid
(
i
), 
	`lôOR
(
f_wúódy
, !
wimask
)) +: wifire(reg)

164 
	`rofúe
(
ªg
Ë(
	`r‹ódy
(
i
), 
	`lôOR
(
f_rovÆid
, !
romask
)) +:Ñofire(reg)

165 
	`wofúe
(
ªg
Ë(
	`w‹ódy
(
i
), 
	`lôOR
(
f_wovÆid
, !
womask
)) +: wofire(reg)

168 
vÆ
 
¥ïíd
 = i‡(
low
 =0Ë{ 
f_d©a
 } { 
	`C©
(f_d©a, 
	`d©aOut
(
ªg
Ë| 
	`UI¡
(0, 
width
=low)) }

169 
	`d©aOut
(
ªg
Ë(
¥ïíd
 | 
	`UI¡
(0, 
width
=
high
+1))(high, 0)

173 
vÆ
 
iödex
 = 
	`ªgIndexU
(
‰⁄t
.
bôs
.
ödex
)

174 
vÆ
 
oödex
 = 
	`ªgIndexU
(
back
 .
bôs
.
ödex
)

175 
vÆ
 
‰⁄tSñ
 = 
	`UI¡ToOH
(
iödex
).
toBoﬁs


176 
vÆ
 
backSñ
 = 
	`UI¡ToOH
(
oödex
).
toBoﬁs


179 
def
 
	`mux
(
ödex
: 
UI¡
, 
vÆid
: 
Boﬁ
, 
£À˘
: 
Seq
[Boﬁ], 
gu¨d
: Seq[Boﬁ], 
Êow
: Seq[Seq[(Bool, Bool)]]): Bool =

180 
	`MuxSeq
(
ödex
, 
	`Boﬁ
(
åue
), ((
£À˘
 
zù
 
gu¨d
Ëzù 
Êow
).
m≠
 { ((
s
, 
g
), 
f
) =>

181 
vÆ
 
out
 = 
	`Wúe
(
	`Boﬁ
())

182 
	`Redu˚Othîs
((
out
, 
vÆid
 && 
s
 && 
g
Ë+: 
f
)

183 
out
 || !
g


187 
vÆ
 
rifúeMux
 = 
	`mux
(
iödex
, 
ö
.
vÆid
 && 
‰⁄t
.
ªady
 && fr⁄t.
bôs
.
ªad
, 
‰⁄tSñ
, 
iRightReg
, 
rifúe
)

188 
vÆ
 
wifúeMux
 = 
	`mux
(
iödex
, 
ö
.
vÆid
 && 
‰⁄t
.
ªady
 && !‰⁄t.
bôs
.
ªad
, 
‰⁄tSñ
, 
iRightReg
, 
wifúe
)

189 
vÆ
 
rofúeMux
 = 
	`mux
(
oödex
, 
back
.
vÆid
 && 
out
.
ªady
 && back .
bôs
.
ªad
, 
backSñ
, 
oRightReg
, 
rofúe
)

190 
vÆ
 
wofúeMux
 = 
	`mux
(
oödex
, 
back
.
vÆid
 && 
out
.
ªady
 && !back .
bôs
.
ªad
, 
backSñ
, 
oRightReg
, 
wofúe
)

192 
vÆ
 
úódy
 = 
	`Mux
(
‰⁄t
.
bôs
.
ªad
, 
rifúeMux
, 
wifúeMux
)

193 
vÆ
 
‹ódy
 = 
	`Mux
(
back
 .
bôs
.
ªad
, 
rofúeMux
, 
wofúeMux
)

196 
ö
.
ªady
 :
‰⁄t
.ªady && 
úódy


197 
‰⁄t
.
vÆid
 :
ö
.vÆid && 
úódy


198 
back
.
ªady
 :
out
.ªady && 
‹ódy


199 
out
.
vÆid
 :
back
.vÆid && 
‹ódy


201 
out
.
bôs
.
ªad
 :
back
.bits.read

202 
out
.
bôs
.
d©a
 :
	`Mux
(
	`MuxSeq
(
oödex
, 
	`Boﬁ
(
åue
), 
oRightReg
),

203 
	`MuxSeq
(
oödex
, 
	`UI¡
(0), 
d©aOut
),

204 
	`UI¡
(0))

205 
out
.
bôs
.
exåa
 :
back
.bits.extra

207 
out


209 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterCrossing.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
ªgm≠≥r


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.{
	gIºevoˇbÀ
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gAsyncQueue
,
	gAsyncQueueP¨ams
,
	gAsyncRe£tRegVec
}

11 ˛as†
	cBusyRegi°îCrossög
 
exãnds
 
	mModuÀ
 {

12 
vÆ
 
	mio
 = 
√w
 
BundÀ
 {

13 
vÆ
 
by∑ss
 = 
Boﬁ
(
INPUT
)

14 
vÆ
 
ma°î_ªque°_vÆid
 = 
Boﬁ
(
INPUT
)

15 
vÆ
 
ma°î_ªque°_ªady
 = 
Boﬁ
(
OUTPUT
)

16 
vÆ
 
ma°î_ª•⁄£_vÆid
 = 
Boﬁ
(
OUTPUT
)

17 
vÆ
 
ma°î_ª•⁄£_ªady
 = 
Boﬁ
(
INPUT
)

18 
vÆ
 
¸ossög_ªque°_vÆid
 = 
Boﬁ
(
OUTPUT
)

19 
vÆ
 
¸ossög_ªque°_ªady
 = 
Boﬁ
(
INPUT
)

23 
vÆ
 
	gbusy
 = 
RegInô
(
	$Boﬁ
(
Ál£
))

24 
vÆ
 
by∑ss
 = 
	`Reg
(
	$Boﬁ
())

26 
	`whí
 (
io
.
¸ossög_ªque°_ªady
 || 
	$Mux
(
busy
, 
by∑ss
, 
io
.bypass)) {

27 
busy
 :
	`Mux
(busy, !
io
.
ma°î_ª•⁄£_ªady
, io.
ma°î_ªque°_vÆid
)

28 
	}
}

30 
	$whí
 (
io
.
ma°î_ªque°_vÆid
 && io.
ma°î_ªque°_ªady
) {

31 
by∑ss
 :
io
.bypass

32 
	}
}

34 
io
.
¸ossög_ªque°_vÆid
 :io.
ma°î_ªque°_vÆid
 && !io.
by∑ss
 && !
busy


35 
io
.
ma°î_ªque°_ªady
 :(io.
by∑ss
 || io.
¸ossög_ªque°_ªady
Ë&& !
busy


36 
io
.
ma°î_ª•⁄£_vÆid
 :(
by∑ss
 || io.
¸ossög_ªque°_ªady
Ë&& 
busy


39 ˛as†
	cRegi°îCrossögAs£πi⁄
 
exãnds
 
ModuÀ
 {

40 
vÆ
 
io
 = 
√w
 
BundÀ
 {

41 
vÆ
 
ma°î_by∑ss
 = 
Boﬁ
(
INPUT
)

42 
vÆ
 
¶ave_ª£t
 = 
Boﬁ
(
INPUT
)

45 
vÆ
 
up
 = 
RegInô
(
	$Boﬁ
(
Ál£
))

46 
up
 :!
io
.
¶ave_ª£t


48 
	`as£π
 (
io
.
ma°î_by∑ss
 || !
up
 || !io.
¶ave_ª£t
)

49 
	}
}

52 
˛ass
 
Regi°îWrôeIO
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ
 {

53 
vÆ
 
ªque°
 = 
Decou∂ed
(
gí
).
Êù


54 
vÆ
 
ª•⁄£
 = 
IºevoˇbÀ
(
Boﬁ
())

56 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
Regi°îWrôeIO
(
gí
).
asIn°™˚Of
[
this
.
ty≥
]

79 
˛ass
 
Regi°îWrôeCrossögIO
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ
 {

81 
vÆ
 
ma°î_˛ock
 = 
Clock
(
INPUT
)

82 
vÆ
 
ma°î_ª£t
 = 
Boﬁ
(
INPUT
)

83 
vÆ
 
ma°î_p‹t
 = 
√w
 
Regi°îWrôeIO
(
gí
)

85 
vÆ
 
ma°î_by∑ss
 = 
Boﬁ
(
INPUT
)

87 
vÆ
 
¶ave_˛ock
 = 
Clock
(
INPUT
)

88 
vÆ
 
¶ave_ª£t
 = 
Boﬁ
(
INPUT
)

89 
vÆ
 
¶ave_ªgi°î
 = 
gí
.
asOuçut


90 
vÆ
 
¶ave_vÆid
 = 
Boﬁ
(
OUTPUT
)

93 
˛ass
 
Regi°îWrôeCrossög
[
T
 <: 
D©a
](
gí
: T, 
	gsync
: 
I¡
 = 3Ë
exãnds
 
ModuÀ
 {

94 
vÆ
 
io
 = 
√w
 
Regi°îWrôeCrossögIO
(
gí
)

96 
vÆ
 
c⁄åﬁ
 = 
ModuÀ
(
√w
 
BusyRegi°îCrossög
)

97 
vÆ
 
¸ossög
 = 
ModuÀ
(
√w
 
AsyncQueue
(
gí
, 
AsyncQueueP¨ams
.
sögÀt⁄
(
sync
)))

99 
	gc⁄åﬁ
.
	g˛ock
 :
io
.
ma°î_˛ock


100 
c⁄åﬁ
.
ª£t
 :
io
.
ma°î_ª£t


101 
¸ossög
.
io
.
íq_˛ock
 :io.
ma°î_˛ock


102 
¸ossög
.
io
.
íq_ª£t
 :io.
ma°î_ª£t


103 
¸ossög
.
io
.
deq_˛ock
 :io.
¶ave_˛ock


104 
¸ossög
.
io
.
deq_ª£t
 :io.
¶ave_ª£t


106 
c⁄åﬁ
.
io
.
by∑ss
 :io.
ma°î_by∑ss


107 
c⁄åﬁ
.
io
.
ma°î_ªque°_vÆid
 :io.
ma°î_p‹t
.
ªque°
.
vÆid


108 
c⁄åﬁ
.
io
.
ma°î_ª•⁄£_ªady
 :io.
ma°î_p‹t
.
ª•⁄£
.
ªady


109 
io
.
ma°î_p‹t
.
ªque°
.
ªady
 :
c⁄åﬁ
.io.
ma°î_ªque°_ªady


110 
io
.
ma°î_p‹t
.
ª•⁄£
.
vÆid
 :
c⁄åﬁ
.io.
ma°î_ª•⁄£_vÆid


112 
c⁄åﬁ
.
io
.
¸ossög_ªque°_ªady
 :
¸ossög
.io.
íq
.
ªady


113 
¸ossög
.
io
.
íq
.
vÆid
 :
c⁄åﬁ
.io.
¸ossög_ªque°_vÆid


114 
¸ossög
.
io
.
íq
.
bôs
 :io.
ma°î_p‹t
.
ªque°
.bits

116 
¸ossög
.
io
.
deq
.
ªady
 :
Boﬁ
(
åue
)

117 
io
.
¶ave_vÆid
 :
¸ossög
.io.
deq
.
vÆid


118 
io
.
¶ave_ªgi°î
 :
¸ossög
.io.
deq
.
bôs


120 
vÆ
 
as£πi⁄
 = 
ModuÀ
(
√w
 
Regi°îCrossögAs£πi⁄
)

121 
as£πi⁄
.
˛ock
 :
io
.
ma°î_˛ock


122 
as£πi⁄
.
ª£t
 :
io
.
ma°î_ª£t


123 
as£πi⁄
.
io
.
ma°î_by∑ss
 := io.master_bypass

124 
as£πi⁄
.
io
.
¶ave_ª£t
 := io.slave_reset

128 
˛ass
 
Regi°îRódIO
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ
 {

129 
vÆ
 
ªque°
 = 
Decou∂ed
(
Boﬁ
()).
Êù


130 
vÆ
 
ª•⁄£
 = 
IºevoˇbÀ
(
gí
)

132 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
Regi°îRódIO
(
gí
).
asIn°™˚Of
[
this
.
ty≥
]

135 
˛ass
 
Regi°îRódCrossögIO
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ
 {

137 
vÆ
 
ma°î_˛ock
 = 
Clock
(
INPUT
)

138 
vÆ
 
ma°î_ª£t
 = 
Boﬁ
(
INPUT
)

139 
vÆ
 
ma°î_p‹t
 = 
√w
 
Regi°îRódIO
(
gí
)

141 
vÆ
 
ma°î_by∑ss
 = 
Boﬁ
(
INPUT
)

143 
vÆ
 
¶ave_˛ock
 = 
Clock
(
INPUT
)

144 
vÆ
 
¶ave_ª£t
 = 
Boﬁ
(
INPUT
)

145 
vÆ
 
¶ave_ªgi°î
 = 
gí
.
asI≈ut


148 
˛ass
 
Regi°îRódCrossög
[
T
 <: 
D©a
](
gí
: T, 
	gsync
: 
I¡
 = 3Ë
exãnds
 
ModuÀ
 {

149 
vÆ
 
io
 = 
√w
 
Regi°îRódCrossögIO
(
gí
)

151 
vÆ
 
c⁄åﬁ
 = 
ModuÀ
(
√w
 
BusyRegi°îCrossög
)

152 
vÆ
 
¸ossög
 = 
ModuÀ
(
√w
 
AsyncQueue
(
gí
, 
AsyncQueueP¨ams
.
sögÀt⁄
(
sync
)))

154 
	gc⁄åﬁ
.
	g˛ock
 :
io
.
ma°î_˛ock


155 
c⁄åﬁ
.
ª£t
 :
io
.
ma°î_ª£t


156 
¸ossög
.
io
.
deq_˛ock
 :io.
ma°î_˛ock


157 
¸ossög
.
io
.
deq_ª£t
 :io.
ma°î_ª£t


158 
¸ossög
.
io
.
íq_˛ock
 :io.
¶ave_˛ock


159 
¸ossög
.
io
.
íq_ª£t
 :io.
¶ave_ª£t


161 
c⁄åﬁ
.
io
.
by∑ss
 :io.
ma°î_by∑ss


162 
c⁄åﬁ
.
io
.
ma°î_ªque°_vÆid
 :io.
ma°î_p‹t
.
ªque°
.
vÆid


163 
c⁄åﬁ
.
io
.
ma°î_ª•⁄£_ªady
 :io.
ma°î_p‹t
.
ª•⁄£
.
ªady


164 
io
.
ma°î_p‹t
.
ªque°
.
ªady
 :
c⁄åﬁ
.io.
ma°î_ªque°_ªady


165 
io
.
ma°î_p‹t
.
ª•⁄£
.
vÆid
 :
c⁄åﬁ
.io.
ma°î_ª•⁄£_vÆid


167 
c⁄åﬁ
.
io
.
¸ossög_ªque°_ªady
 :
¸ossög
.io.
deq
.
vÆid


168 
¸ossög
.
io
.
deq
.
ªady
 :
c⁄åﬁ
.io.
¸ossög_ªque°_vÆid


169 
io
.
ma°î_p‹t
.
ª•⁄£
.
bôs
 :
¸ossög
.io.
deq
.bits

171 
¸ossög
.
io
.
íq
.
vÆid
 :
Boﬁ
(
åue
)

172 
¸ossög
.
io
.
íq
.
bôs
 :io.
¶ave_ªgi°î


174 
vÆ
 
as£πi⁄
 = 
ModuÀ
(
√w
 
Regi°îCrossögAs£πi⁄
)

175 
as£πi⁄
.
˛ock
 :
io
.
ma°î_˛ock


176 
as£πi⁄
.
ª£t
 :
io
.
ma°î_ª£t


177 
as£πi⁄
.
io
.
ma°î_by∑ss
 := io.master_bypass

178 
as£πi⁄
.
io
.
¶ave_ª£t
 := io.slave_reset

190 
obje˘
 
AsyncRWSœveRegFõld
 {

192 
def
 
≠∂y
(

193 
ma°î_˛ock
: 
Clock
,

194 
ma°î_ª£t
: 
Boﬁ
,

195 
¶ave_˛ock
: 
Clock
,

196 
¶ave_ª£t
: 
Boﬁ
,

197 
width
: 
I¡
,

198 
öô
: 
I¡
,

199 
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
,

200 
ma°î_by∑ss
: 
Boﬁ
 = Boﬁ(
åue
),

201 
desc
: 
O±i⁄
[
RegFõldDesc
] = 
N⁄e


202 ): (
UI¡
, 
	gRegFõld
) = {

204 
vÆ
 
async_¶ave_ªg
 = 
ModuÀ
(
√w
 
AsyncRe£tRegVec
(
width
, 
öô
))

205 
	g«me
.
f‹óch
(
async_¶ave_ªg
.
sugge°Name
(
_
))

206 
	gasync_¶ave_ªg
.
	gª£t
 :
¶ave_ª£t


207 
async_¶ave_ªg
.
˛ock
 :
¶ave_˛ock


209 
vÆ
 
wr_¸ossög
 = 
ModuÀ
 (
√w
 
Regi°îWrôeCrossög
(
UI¡
(
width
 = width)))

210 
«me
.
f‹óch
(
n
 => 
wr_¸ossög
.
sugge°Name
(
s
"${n}_wcrossing"))

212 
wr_¸ossög
.
io
.
ma°î_˛ock
 := master_clock

213 
wr_¸ossög
.
io
.
ma°î_ª£t
 := master_reset

214 
wr_¸ossög
.
io
.
ma°î_by∑ss
 := master_bypass

215 
wr_¸ossög
.
io
.
¶ave_˛ock
 := slave_clock

216 
wr_¸ossög
.
io
.
¶ave_ª£t
 := slave_reset

218 
async_¶ave_ªg
.
io
.
í
 :
wr_¸ossög
.io.
¶ave_vÆid


219 
async_¶ave_ªg
.
io
.
d
 :
wr_¸ossög
.io.
¶ave_ªgi°î


221 
vÆ
 
rd_¸ossög
 = 
ModuÀ
 (
√w
 
Regi°îRódCrossög
(
UI¡
(
width
 = width )))

222 
«me
.
f‹óch
(
n
 => 
rd_¸ossög
.
sugge°Name
(
s
"${n}_rcrossing"))

224 
rd_¸ossög
.
io
.
ma°î_˛ock
 := master_clock

225 
rd_¸ossög
.
io
.
ma°î_ª£t
 := master_reset

226 
rd_¸ossög
.
io
.
ma°î_by∑ss
 := master_bypass

227 
rd_¸ossög
.
io
.
¶ave_˛ock
 := slave_clock

228 
rd_¸ossög
.
io
.
¶ave_ª£t
 := slave_reset

230 
rd_¸ossög
.
io
.
¶ave_ªgi°î
 :
async_¶ave_ªg
.io.
q


232 (
async_¶ave_ªg
.
io
.
q
, 
RegFõld
(
width
, 
rd_¸ossög
.io.
ma°î_p‹t
, 
wr_¸ossög
.io.ma°î_p‹t, 
desc
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterRouter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
ªgm≠≥r


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


11 
˛ass
 
	$Regi°îRouãrP¨ams
(

12 
«me
: 
Såög
,

13 
com∑t
: 
Seq
[
Såög
],

14 
ba£
: 
BigI¡
,

15 
size
: 
BigI¡
 = 4096,

16 
c⁄cuºícy
: 
I¡
 = 0,

17 
bótByãs
: 
I¡
 = 4,

18 
undefZîo
: 
Boﬁón
 = 
åue
,

19 
execuèbÀ
: 
Boﬁón
 = 
Ál£
)

21 
ab°ø˘
 
˛ass
 
Regi°îRouãr
[
T
 <: 
D©a
](
devP¨ams
: 
Regi°îRouãrP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
)

22 
exãnds
 
LazyModuÀ


23 
wôh
 
HasClockDomaöCrossög
 {

25 
	`ªquúe
 (
	`isPow2
(
devP¨ams
.
size
))

26 
vÆ
 
addªss
 = 
	`Seq
(
	`AddªssSë
(
devP¨ams
.
ba£
, devP¨ams.
size
-1))

27 
vÆ
 
c⁄cuºícy
 = 
devP¨ams
.concurrency

28 
vÆ
 
bótByãs
 = 
devP¨ams
.beatBytes

29 
vÆ
 
undefZîo
 = 
devP¨ams
.undefZero

30 
vÆ
 
execuèbÀ
 = 
devP¨ams
.executable

31 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
(
devP¨ams
.
«me
, devP¨ams.
com∑t
) {

32 
ovîride
 
def
 
	`des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

33 
vÆ
 
	`Des¸ùti⁄
(
«me
, 
m≠pög
Ë
su≥r
.
	`des¸ibe
(
ªsour˚s
)

34 
	`Des¸ùti⁄
(
«me
, 
m≠pög
 ++ 
	`exåaResour˚s
(
ªsour˚s
))

38 
def
 
	`exåaResour˚s
(
ªsour˚s
: 
Resour˚Bödögs
Ë
M≠
[
Såög
, 
Seq
[
Resour˚VÆue
]]()

40 
¥Ÿe˘ed
 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*): 
Unô


41 
	}
}

43 
ab°ø˘
 
˛ass
 
IORegi°îRouãr
[
T
 <: 
D©a
](
devP¨ams
: 
Regi°îRouãrP¨ams
, 
	gp‹tBundÀ
: => T)(
im∂icô
 
p
: 
P¨amëîs
)

44 
exãnds
 
	$Regi°îRouãr
(
devP¨ams
) {

45 
vÆ
 
ioNode
 = 
	`BundÀBridgeSour˚
((Ë=> 
p‹tBundÀ
.
˛⁄eTy≥
)

46 
vÆ
 
p‹t
 = 
InModuÀBody
 { 
ioNode
.
bundÀ
 }

47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ALU.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
C‹eModuÀ


10 
obje˘
 
	gALU


12 
vÆ
 
	gSZ_ALU_FN
 = 4

13 
def
 
FN_X
 = 
BôP©
("b????")

14 
def
 
FN_ADD
 = 
UI¡
(0)

15 
def
 
FN_SL
 = 
UI¡
(1)

16 
def
 
FN_SEQ
 = 
UI¡
(2)

17 
def
 
FN_SNE
 = 
UI¡
(3)

18 
def
 
FN_XOR
 = 
UI¡
(4)

19 
def
 
FN_SR
 = 
UI¡
(5)

20 
def
 
FN_OR
 = 
UI¡
(6)

21 
def
 
FN_AND
 = 
UI¡
(7)

22 
def
 
FN_SUB
 = 
UI¡
(10)

23 
def
 
FN_SRA
 = 
UI¡
(11)

24 
def
 
FN_SLT
 = 
UI¡
(12)

25 
def
 
FN_SGE
 = 
UI¡
(13)

26 
def
 
FN_SLTU
 = 
UI¡
(14)

27 
def
 
FN_SGEU
 = 
UI¡
(15)

29 
def
 
FN_DIV
 = 
FN_XOR


30 
def
 
FN_DIVU
 = 
FN_SR


31 
def
 
FN_REM
 = 
FN_OR


32 
def
 
FN_REMU
 = 
FN_AND


34 
def
 
FN_MUL
 = 
FN_ADD


35 
def
 
FN_MULH
 = 
FN_SL


36 
def
 
FN_MULHSU
 = 
FN_SEQ


37 
def
 
FN_MULHU
 = 
FN_SNE


39 
def
 
isMulFN
(
‚
: 
UI¡
, 
cmp
: UInt) = fn(1,0) === cmp(1,0)

40 
def
 
isSub
(
cmd
: 
UI¡
) = cmd(3)

41 
def
 
isCmp
(
cmd
: 
UI¡
Ëcmd >
FN_SLT


42 
def
 
cmpUnsig√d
(
cmd
: 
UI¡
) = cmd(1)

43 
def
 
cmpInvîãd
(
cmd
: 
UI¡
) = cmd(0)

44 
def
 
cmpEq
(
cmd
: 
UI¡
) = !cmd(3)

47 
imp‹t
 
ALU
.
_


48 
imp‹t
 
In°ru˘i⁄s
.
_


50 ˛as†
	cALU
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
) {

51 
vÆ
 
io
 = 
√w
 
BundÀ
 {

52 
vÆ
 
dw
 = 
	`Bôs
(
INPUT
, 
SZ_DW
)

53 
vÆ
 
‚
 = 
	`Bôs
(
INPUT
, 
SZ_ALU_FN
)

54 
vÆ
 
ö2
 = 
	`UI¡
(
INPUT
, 
xLí
)

55 
vÆ
 
ö1
 = 
	`UI¡
(
INPUT
, 
xLí
)

56 
vÆ
 
out
 = 
	`UI¡
(
OUTPUT
, 
xLí
)

57 
vÆ
 
addî_out
 = 
	`UI¡
(
OUTPUT
, 
xLí
)

58 
vÆ
 
cmp_out
 = 
	`Boﬁ
(
OUTPUT
)

62 
vÆ
 
ö2_öv
 = 
	`Mux
(
	`isSub
(
io
.
‚
), ~io.
ö2
, io.in2)

63 
vÆ
 
ö1_x‹_ö2
 = 
io
.
ö1
 ^ 
ö2_öv


64 
io
.
addî_out
 :io.
ö1
 + 
ö2_öv
 + 
	$isSub
(
io
.
‚
)

67 
vÆ
 
¶t
 =

68 
	`Mux
(
io
.
	`ö1
(
xLí
-1Ë==io.
	`ö2
(xLí-1), io.
	`addî_out
(xLen-1),

69 
	`Mux
(
	`cmpUnsig√d
(
io
.
‚
), io.
	`ö2
(
xLí
-1), io.
	`ö1
(xLen-1)))

70 
io
.
cmp_out
 :
	`cmpInvîãd
(io.
‚
Ë^ 
	`Mux
(
	`cmpEq
(io.‚), 
ö1_x‹_ö2
 ==
	`UI¡
(0), 
¶t
)

73 
	`vÆ
 (
shamt
, 
shö_r
) =

74 i‡(
xLí
 =32Ë(
io
.
	`ö2
(4,0), io.
ö1
)

76 
	`ªquúe
(
xLí
 == 64)

77 
vÆ
 
shö_hi_32
 = 
	`Fûl
(32, 
	`isSub
(
io
.
‚
Ë&& io.
	`ö1
(31))

78 
vÆ
 
shö_hi
 = 
	`Mux
(
io
.
dw
 ==
DW_64
, io.
	`ö1
(63,32), 
shö_hi_32
)

79 
vÆ
 
shamt
 = 
	`C©
(
io
.
	`ö2
(5Ë& (io.
dw
 ==
DW_64
), io.in2(4,0))

80 (
shamt
, 
	`C©
(
shö_hi
, 
io
.
	`ö1
(31,0)))

81 
	}
}

82 
vÆ
 
	gshö
 = 
Mux
(
io
.
‚
 ==
FN_SR
 || io.‚ ==
FN_SRA
, 
shö_r
, 
	$Revî£
(
shö_r
))

83 
vÆ
 
shout_r
 = (
	`C©
(
	`isSub
(
io
.
‚
Ë& 
	`shö
(
xLí
-1), 
shö
).
asSI¡
 >> 
shamt
)(xLen-1,0)

84 
vÆ
 
shout_l
 = 
	$Revî£
(
shout_r
)

85 
vÆ
 
shout
 = 
	`Mux
(
io
.
‚
 ==
FN_SR
 || io.‚ ==
FN_SRA
, 
shout_r
, 
	`UI¡
(0)) |

86 
	`Mux
(
io
.
‚
 ==
FN_SL
, 
shout_l
, 
	$UI¡
(0))

89 
vÆ
 
logic
 = 
	`Mux
(
io
.
‚
 ==
FN_XOR
 || io.‚ ==
FN_OR
, 
ö1_x‹_ö2
, 
	`UI¡
(0)) |

90 
	`Mux
(
io
.
‚
 ==
FN_OR
 || io.‚ ==
FN_AND
, io.
ö1
 & io.
ö2
, 
	$UI¡
(0))

91 
vÆ
 
shi·_logic
 = (
	`isCmp
(
io
.
‚
Ë&& 
¶t
Ë| 
logic
 | 
shout


92 
vÆ
 
out
 = 
	`Mux
(
io
.
‚
 ==
FN_ADD
 || io.‚ ==
FN_SUB
, io.
addî_out
, 
shi·_logic
)

94 
io
.
out
 := out

95 i‡(
xLí
 > 32) {

96 
	`ªquúe
(
xLí
 == 64)

97 
	`whí
 (
io
.
dw
 ==
DW_32
Ë{ io.
out
 :
	`C©
(
	`Fûl
(32, 
	`out
(31)), out(31,0)) }

98 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/AMOALU.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
˛ass
 
	$St‹eGí
(
typ
: 
UI¡
, 
addr
: UI¡, 
d©
: UI¡, 
maxSize
: 
I¡
) {

10 
vÆ
 
size
 = 
	`typ
(
	`log2Up
÷og2Up(
maxSize
)+1)-1,0)

11 
def
 
mißlig√d
 =

12 (
addr
 & ((
	`UI¡
(1Ë<< 
size
Ë- UI¡(1))(
	`log2Up
(
maxSize
)-1,0)).
‹R


14 
def
 
mask
 = {

15 
v¨
 
ªs
 = 
	`UI¡
(1)

16 
i
 <- 0 
u¡û
 
	`log2Up
(
maxSize
)) {

17 
vÆ
 
uµî
 = 
	`Mux
(
	`addr
(
i
), 
ªs
, 
	`UI¡
(0)Ë| Mux(
size
 >UI¡(i+1), UI¡((
	`BigI¡
(1) << (1 << i))-1), UInt(0))

18 
vÆ
 
lowî
 = 
	`Mux
(
	`addr
(
i
), 
	`UI¡
(0), 
ªs
)

19 
ªs
 = 
	`C©
(
uµî
, 
lowî
)

21 
ªs


24 
¥Ÿe˘ed
 
def
 
	`gíD©a
(
i
: 
I¡
): 
UI¡
 =

25 i‡(
i
 >
	`log2Up
(
maxSize
)Ë
d©


26 
	`Mux
(
size
 ==
	`UI¡
(
i
), 
	`Fûl
(1 << (
	`log2Up
(
maxSize
)-i), 
	`d©
((8 << i)-1,0)), 
	`gíD©a
(i+1))

28 
def
 
d©a
 = 
	`gíD©a
(0)

29 
def
 
w‹dD©a
 = 
	`gíD©a
(2)

30 
	}
}

32 
˛ass
 
	$LﬂdGí
(
typ
: 
UI¡
, sig√d: 
Boﬁ
, 
addr
: UI¡, 
d©
: UI¡, 
zîo
: Boﬁ, 
maxSize
: 
I¡
) {

33 
¥iv©e
 
vÆ
 
size
 = 
√w
 
	`St‹eGí
(
typ
, 
addr
, 
d©
, 
maxSize
).size

35 
¥iv©e
 
def
 
	`gíD©a
(
logMöSize
: 
I¡
): 
UI¡
 = {

36 
v¨
 
ªs
 = 
d©


37 
i
 <- 
	`log2Up
(
maxSize
)-1 
to
 
logMöSize
 
by
 -1) {

38 
vÆ
 
pos
 = 8 << 
i


39 
vÆ
 
shi·ed
 = 
	`Mux
(
	`addr
(
i
), 
	`ªs
(2*
pos
-1,pos),Ñes(pos-1,0))

40 
vÆ
 
doZîo
 = 
	`Boﬁ
(
i
 =0Ë&& 
zîo


41 
vÆ
 
zî€d
 = 
	`Mux
(
doZîo
, 
	`UI¡
(0), 
shi·ed
)

42 
ªs
 = 
	`C©
(
	`Mux
(
size
 ==
	`UI¡
(
i
Ë|| 
doZîo
, 
	`Fûl
(8*
maxSize
-
pos
, sig√d && 
	`zî€d
’os-1)), 
	`ªs
(8*maxSize-1,pos)), 
zî€d
)

44 
ªs


47 
def
 
w‹dD©a
 = 
	`gíD©a
(2)

48 
def
 
d©a
 = 
	`gíD©a
(0)

49 
	}
}

51 ˛as†
	cAMOALU
(
›î™dBôs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

52 
vÆ
 
möXLí
 = 32

53 
vÆ
 
widths
 = (0 
to
 
	`log2Ceû
(
›î™dBôs
 / 
möXLí
)).
	`m≠
(möXLí << 
_
)

55 
vÆ
 
io
 = 
√w
 
BundÀ
 {

56 
vÆ
 
mask
 = 
	`UI¡
(
INPUT
, 
›î™dBôs
/8)

57 
vÆ
 
cmd
 = 
	`Bôs
(
INPUT
, 
M_SZ
)

58 
vÆ
 
lhs
 = 
	`Bôs
(
INPUT
, 
›î™dBôs
)

59 
vÆ
 
rhs
 = 
	`Bôs
(
INPUT
, 
›î™dBôs
)

60 
vÆ
 
out
 = 
	`Bôs
(
OUTPUT
, 
›î™dBôs
)

61 
vÆ
 
out_unmasked
 = 
	`Bôs
(
OUTPUT
, 
›î™dBôs
)

64 
vÆ
 
max
 = 
io
.
cmd
 ==
M_XA_MAX
 || io.cmd ==
M_XA_MAXU


65 
vÆ
 
mö
 = 
io
.
cmd
 ==
M_XA_MIN
 || io.cmd ==
M_XA_MINU


66 
vÆ
 
add
 = 
io
.
cmd
 ==
M_XA_ADD


67 
vÆ
 
logic_™d
 = 
io
.
cmd
 ==
M_XA_OR
 || io.cmd ==
M_XA_AND


68 
vÆ
 
logic_x‹
 = 
io
.
cmd
 ==
M_XA_XOR
 || io.cmd ==
M_XA_OR


70 
vÆ
 
addî_out
 = {

72 
vÆ
 
mask
 = ~(
	`UI¡
(0, 
›î™dBôs
Ë+: 
widths
.
öô
.
	`m≠
(
w
 => !
io
.
	`mask
(w/8-1Ë<< (w-1))).
	`ªdu˚
(
_
|_)

73 (
io
.
lhs
 & 
mask
Ë+ (io.
rhs
 & mask)

74 
	}
}

76 
vÆ
 
Àss
 = {

78 
def
 
isLessUnsig√d
(
x
: 
UI¡
, 
y
: UI¡, 
n
: 
I¡
): 
Boﬁ
 = {

79 i‡(
n
 =
möXLí
Ë
x
“-1, 0Ë< 
y
(n-1, 0)

80 
x
(
n
-1,Ç/2Ë< 
y
“-1,Ç/2Ë|| x“-1,Ç/2Ë==y“-1,Ç/2Ë&& 
isLessUnsig√d
(x, y,Ç/2)

83 
def
 
isLess
(
x
: 
UI¡
, 
y
: UI¡, 
n
: 
I¡
): 
Boﬁ
 = {

84 
vÆ
 signed = {

85 
vÆ
 
mask
 = 
M_XA_MIN
 ^ 
M_XA_MINU


86 (
io
.
cmd
 & 
mask
Ë==(
M_XA_MIN
 & mask)

88 
Mux
(
x
(
n
-1Ë==
y
“-1), 
isLessUnsig√d
(x, y,Ç), Mux(signed, x(n-1), y(n-1)))

91 
Pri‹ôyMux
(
widths
.
ªvî£
.
m≠
(
w
 => (
io
.
mask
(w/8/2), 
isLess
(io.
lhs
, io.
rhs
, w))))

94 
vÆ
 
	gmömax
 = 
Mux
(Mux(
Àss
, 
mö
, 
max
), 
io
.
lhs
, io.
rhs
)

95 
vÆ
 
	glogic
 =

96 
Mux
(
logic_™d
, 
io
.
lhs
 & io.
rhs
, 0.U) |

97 
Mux
(
logic_x‹
, 
io
.
lhs
 ^ io.
rhs
, 0.U)

98 
vÆ
 
	gout
 =

99 
Mux
(
add
, 
addî_out
,

100 
Mux
(
logic_™d
 || 
logic_x‹
, 
logic
,

101 
mömax
))

103 
vÆ
 
	gwmask
 = 
	$FûlI¡îÀaved
(8, 
io
.
mask
)

104 
io
.
out
 :
wmask
 & ouà| ~wmask & io.
lhs


105 
io
.
out_unmasked
 :
out


106 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BTB.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
In°™˚Id


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
CacheBlockByãs


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
HasC‹eP¨amëîs


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


14 
˛ass
 
	$BHTP¨ams
(

15 
nE¡rõs
: 
I¡
 = 512,

16 
cou¡îLígth
: 
I¡
 = 1,

17 
hi°‹yLígth
: 
I¡
 = 8,

18 
hi°‹yBôs
: 
I¡
 = 3)

20 
˛ass
 
	`BTBP¨ams
(

21 
nE¡rõs
: 
I¡
 = 28,

22 
nM©chBôs
: 
I¡
 = 14,

23 
nPages
: 
I¡
 = 6,

24 
nRAS
: 
I¡
 = 6,

25 
bhtP¨ams
: 
O±i⁄
[
BHTP¨ams
] = 
	`Some
(
	`BHTP¨ams
()),

26 
upd©esOutOfOrdî
: 
Boﬁón
 = 
Ál£
)

28 
åaô
 
HasBtbP¨amëîs
 
exãnds
 
HasC‹eP¨amëîs
 { 
this
: 
In°™˚Id
 =>

29 
vÆ
 
btbP¨ams
 = 
tûeP¨ams
.
btb
.
	`gëOrEl£
(
	`BTBP¨ams
(
nE¡rõs
 = 0))

30 
vÆ
 
m©chBôs
 = 
btbP¨ams
.
nM©chBôs
 
max
 
	`log2Ceû
(
	`p
(
CacheBlockByãs
Ë* 
tûeP¨ams
.
iˇche
.
gë
.
nSës
)

31 
vÆ
 
íåõs
 = 
btbP¨ams
.
nE¡rõs


32 
vÆ
 
upd©esOutOfOrdî
 = 
btbP¨ams
.updatesOutOfOrder

33 
vÆ
 
nPages
 = (
btbP¨ams
.nPages + 1) / 2 * 2

34 
	}
}

36 
ab°ø˘
 cœs†
	cBtbModuÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 
wôh
 
HasBtbP¨amëîs
 {

37 
A¬Ÿ©ed
.
	`∑øms
(
this
, 
btbP¨ams
)

40 
ab°ø˘
 cœs†
	cBtbBundÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
BundÀ
 
wôh
 
HasBtbP¨amëîs


42 ˛as†
	cRAS
(
ƒas
: 
I¡
) {

43 
def
 
	$push
(
addr
: 
UI¡
): 
Unô
 = {

44 
	`whí
 (
cou¡
 < 
ƒas
) { count := count + 1 }

45 
vÆ
 
√xtPos
 = 
	`Mux
(
	`Boﬁ
(
	`isPow2
(
ƒas
)Ë|| 
pos
 <Çøs-1,Öos+1, 
	`UI¡
(0))

46 
	`°ack
(
√xtPos
Ë:
addr


47 
pos
 :
√xtPos


49 
def
 
≥ek
: 
UI¡
 = 
	$°ack
(
pos
)

50 
def
 
	$p›
(): 
Unô
 = 
	`whí
 (!
isEm±y
) {

51 
cou¡
 := count - 1

52 
pos
 :
	`Mux
(
	`Boﬁ
(
	`isPow2
(
ƒas
)Ë||Öo†> 0,Öos-1, 
	`UI¡
(nras-1))

53 
	}
}

54 
def
 
	$˛ór
(): 
Unô
 = 
cou¡
 :
	$UI¡
(0)

55 
def
 
isEm±y
: 
Boﬁ
 = 
cou¡
 ==
	$UI¡
(0)

57 
¥iv©e
 
vÆ
 
cou¡
 = 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Up
(
ƒas
+1)))

58 
¥iv©e
 
vÆ
 
pos
 = 
	`Reg
(
	`UI¡
(
width
 = 
	$log2Up
(
ƒas
)))

59 
¥iv©e
 
vÆ
 
°ack
 = 
	`Reg
(
	`Vec
(
ƒas
, 
	`UI¡
()))

60 
	}
}

62 ˛as†
	cBHTRe•
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$BtbBundÀ
()(
p
) {

63 
vÆ
 
hi°‹y
 = 
	`UI¡
(
width
 = 
btbP¨ams
.
bhtP¨ams
.
	`m≠
(
_
.
hi°‹yLígth
).
	$gëOrEl£
(1))

64 
vÆ
 
vÆue
 = 
	`UI¡
(
width
 = 
btbP¨ams
.
bhtP¨ams
.
	`m≠
(
_
.
cou¡îLígth
).
	$gëOrEl£
(1))

65 
def
 
èkí
 = 
	$vÆue
(0)

66 
def
 
°r⁄gly_èkí
 = 
vÆue
 === 1

78 ˛as†
	cBHT
(
∑øms
: 
BHTP¨ams
)(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
HasC‹eP¨amëîs
 {

79 
def
 
	`ödex
(
addr
: 
UI¡
, 
hi°‹y
: UInt) = {

80 
def
 
	`hashHi°‹y
(
hi°
: 
UI¡
Ëi‡(
∑øms
.
hi°‹yLígth
 =∑øms.
hi°‹yBôs
) hist {

81 
vÆ
 
k
 = 
m©h
.
	`sqπ
(3)/2

82 
vÆ
 
i
 = 
	`BigDecimÆ
(
k
 * 
m©h
.
	`pow
(2, 
∑øms
.
hi°‹yLígth
)).
toBigI¡


83 (
i
.
U
 * 
hi°
)(
∑øms
.
hi°‹yLígth
-1,Ö¨ams.hi°‹yLígth-∑øms.
hi°‹yBôs
)

85 
def
 
	`hashAddr
(
addr
: 
UI¡
) = {

86 
vÆ
 
hi
 = 
addr
 >> 
	`log2Ceû
(
„tchByãs
)

87 
	`hi
(
	`log2Ceû
(
∑øms
.
nE¡rõs
)-1, 0Ë^ (
hi
 >>Üog2Ceil(params.nEntries))(1, 0)

89 
	`hashAddr
(
addr
Ë^ (
	`hashHi°‹y
(
hi°‹y
Ë<< (
	`log2Up
(
∑øms
.
nE¡rõs
Ë-Ö¨ams.
hi°‹yBôs
))

91 
def
 
	$gë
(
addr
: 
UI¡
): 
BHTRe•
 = {

92 
vÆ
 
ªs
 = 
	`Wúe
(
√w
 
BHTRe•
)

93 
ªs
.
vÆue
 :
	`èbÀ
(
	`ödex
(
addr
, 
hi°‹y
))

94 
ªs
.
hi°‹y
 := history

95 
ªs


96 
	}
}

97 
def
 
	$upd©eTabÀ
(
addr
: 
UI¡
, 
d
: 
BHTRe•
, 
èkí
: 
Boﬁ
): 
Unô
 = {

98 
	`èbÀ
(
	`ödex
(
addr
, 
d
.
hi°‹y
)Ë:(
∑øms
.
cou¡îLígth
 
m©ch
 {

99 1 => 
èkí


100 2 => 
	`C©
(
èkí
 ^ 
d
.
	`vÆue
(0), d.
vÆue
 === 1 || d.value(1) &&Åaken)

102 
	}
}

103 
def
 
	$ª£tHi°‹y
(
d
: 
BHTRe•
): 
Unô
 = {

104 
hi°‹y
 :
d
.history

105 
	}
}

106 
def
 
	$upd©eHi°‹y
(
addr
: 
UI¡
, 
d
: 
BHTRe•
, 
èkí
: 
Boﬁ
): 
Unô
 = {

107 
hi°‹y
 :
	`C©
(
èkí
, 
d
.history >> 1)

108 
	}
}

109 
def
 
	$adv™˚Hi°‹y
(
èkí
: 
Boﬁ
): 
Unô
 = {

110 
hi°‹y
 :
	`C©
(
èkí
, history >> 1)

111 
	}
}

113 
¥iv©e
 
vÆ
 
	gèbÀ
 = 
Mem
(
∑øms
.
nE¡rõs
, 
	$UI¡
(
width
 = 
∑øms
.
cou¡îLígth
))

114 
vÆ
 
hi°‹y
 = 
	`Reg
(
	`UI¡
(
width
 = 
∑øms
.
hi°‹yLígth
))

115 
	}
}

117 
obje˘
 
	gCFITy≥
 {

118 
def
 
	gSZ
 = 2

119 
def
 
≠∂y
(Ë
UI¡
(
width
 = 
SZ
)

120 
def
 
bønch
 = 0.U

121 
def
 
jump
 = 1.U

122 
def
 
ˇŒ
 = 2.U

123 
def
 
ªt
 = 3.U

129 ˛as†
	cBTBUpd©e
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$BtbBundÀ
()(
p
) {

130 
vÆ
 
¥edi˘i⁄
 = 
√w
 
BTBRe•


131 
vÆ
 
pc
 = 
	$UI¡
(
width
 = 
vaddrBôs
)

132 
vÆ
 
èrgë
 = 
	$UI¡
(
width
 = 
vaddrBôs
)

133 
vÆ
 
èkí
 = 
	$Boﬁ
()

134 
vÆ
 
isVÆid
 = 
	$Boﬁ
()

135 
vÆ
 
br_pc
 = 
	$UI¡
(
width
 = 
vaddrBôs
)

136 
vÆ
 
cfiTy≥
 = 
	`CFITy≥
()

141 ˛as†
	cBHTUpd©e
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$BtbBundÀ
()(
p
) {

142 
vÆ
 
¥edi˘i⁄
 = 
√w
 
BHTRe•


143 
vÆ
 
pc
 = 
	$UI¡
(
width
 = 
vaddrBôs
)

144 
vÆ
 
bønch
 = 
	$Boﬁ
()

145 
vÆ
 
èkí
 = 
	$Boﬁ
()

146 
vÆ
 
mi•ªdi˘
 = 
	`Boﬁ
()

149 ˛as†
	cRASUpd©e
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$BtbBundÀ
()(
p
) {

150 
vÆ
 
cfiTy≥
 = 
	$CFITy≥
()

151 
vÆ
 
ªtu∫Addr
 = 
	`UI¡
(
width
 = 
vaddrBôs
)

158 ˛as†
	cBTBRe•
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$BtbBundÀ
()(
p
) {

159 
vÆ
 
cfiTy≥
 = 
	$CFITy≥
()

160 
vÆ
 
èkí
 = 
	$Boﬁ
()

161 
vÆ
 
mask
 = 
	$Bôs
(
width
 = 
„tchWidth
)

162 
vÆ
 
bridx
 = 
	`Bôs
(
width
 = 
	$log2Up
(
„tchWidth
))

163 
vÆ
 
èrgë
 = 
	$UI¡
(
width
 = 
vaddrBôs
)

164 
vÆ
 
íåy
 = 
	`UI¡
(
width
 = 
	`log2Up
(
íåõs
 + 1))

165 
vÆ
 
bht
 = 
√w
 
BHTRe•


168 ˛as†
	cBTBReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$BtbBundÀ
()(
p
) {

169 
vÆ
 
addr
 = 
	`UI¡
(
width
 = 
vaddrBôs
)

176 ˛as†
	cBTB
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
BtbModuÀ
 {

177 
vÆ
 
io
 = 
√w
 
BundÀ
 {

178 
vÆ
 
ªq
 = 
	`VÆid
(
√w
 
BTBReq
).
Êù


179 
vÆ
 
ª•
 = 
	`VÆid
(
√w
 
BTBRe•
)

180 
vÆ
 
btb_upd©e
 = 
	`VÆid
(
√w
 
BTBUpd©e
).
Êù


181 
vÆ
 
bht_upd©e
 = 
	`VÆid
(
√w
 
BHTUpd©e
).
Êù


182 
vÆ
 
bht_adv™˚
 = 
	`VÆid
(
√w
 
BTBRe•
).
Êù


183 
vÆ
 
øs_upd©e
 = 
	`VÆid
(
√w
 
RASUpd©e
).
Êù


184 
vÆ
 
øs_hód
 = 
	`VÆid
(
	`UI¡
(
width
 = 
vaddrBôs
))

185 
vÆ
 
Êush
 = 
	`Boﬁ
().
asI≈ut


188 
vÆ
 
idxs
 = 
	`Reg
(
	`Vec
(
íåõs
, 
	`UI¡
(
width
=
m©chBôs
 - 
	$log2Up
(
c‹eIn°Byãs
))))

189 
vÆ
 
idxPages
 = 
	`Reg
(
	`Vec
(
íåõs
, 
	`UI¡
(
width
=
	$log2Up
(
nPages
))))

190 
vÆ
 
tgts
 = 
	`Reg
(
	`Vec
(
íåõs
, 
	`UI¡
(
width
=
m©chBôs
 - 
	$log2Up
(
c‹eIn°Byãs
))))

191 
vÆ
 
tgtPages
 = 
	`Reg
(
	`Vec
(
íåõs
, 
	`UI¡
(
width
=
	$log2Up
(
nPages
))))

192 
vÆ
 
∑ges
 = 
	`Reg
(
	`Vec
(
nPages
, 
	`UI¡
(
width
=
vaddrBôs
 - 
m©chBôs
)))

193 
vÆ
 
∑geVÆid
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 
nPages
))

195 
vÆ
 
isVÆid
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 
íåõs
))

196 
vÆ
 
cfiTy≥
 = 
	`Reg
(
	`Vec
(
íåõs
, 
	$CFITy≥
()))

197 
vÆ
 
brIdx
 = 
	`Reg
(
	`Vec
(
íåõs
, 
	`UI¡
(
width
=
	$log2Up
(
„tchWidth
))))

199 
¥iv©e
 
def
 
	`∑ge
(
addr
: 
UI¡
Ëadd∏>> 
m©chBôs


200 
¥iv©e
 
def
 
	`∑geM©ch
(
addr
: 
UI¡
) = {

201 
vÆ
 
p
 = 
	`∑ge
(
addr
)

202 
∑geVÆid
 & 
∑ges
.
	`m≠
(
_
 ==
p
).
asUI¡


203 
	}
}

204 
¥iv©e
 
def
 
idxM©ch
(
addr
: 
UI¡
) = {

205 
vÆ
 
idx
 = 
addr
(
m©chBôs
-1, 
log2Up
(
c‹eIn°Byãs
))

206 
	gidxs
.
m≠
(
_
 ==
idx
).
asUI¡
 & 
isVÆid


209 
vÆ
 
	gr_btb_upd©e
 = 
	$Pùe
(
io
.
btb_upd©e
)

210 
vÆ
 
upd©e_èrgë
 = 
io
.
ªq
.
bôs
.
addr


212 
vÆ
 
∑geHô
 = 
	$∑geM©ch
(
io
.
ªq
.
bôs
.
addr
)

213 
vÆ
 
idxHô
 = 
	$idxM©ch
(
io
.
ªq
.
bôs
.
addr
)

215 
vÆ
 
upd©ePageHô
 = 
	$∑geM©ch
(
r_btb_upd©e
.
bôs
.
pc
)

216 
	`vÆ
 (
upd©eHô
, 
upd©eHôAddr
) =

217 i‡(
upd©esOutOfOrdî
) {

218 
vÆ
 
upd©eHôs
 = (
∑geHô
 << 1)(
	`Mux1H
(
	`idxM©ch
(
r_btb_upd©e
.
bôs
.
pc
), 
idxPages
))

219 (
upd©eHôs
.
‹R
, 
	`OHToUI¡
(updateHits))

220 
	}
} (
	gr_btb_upd©e
.
	gbôs
.
	g¥edi˘i⁄
.
	gíåy
 < 
	gíåõs
,Ñ_btb_update.bits.prediction.entry)

222 
vÆ
 
	gu£Upd©ePageHô
 = 
upd©ePageHô
.
‹R


223 
vÆ
 
u£PageHô
 = 
∑geHô
.
‹R


224 
vÆ
 
doIdxPageRïl
 = !
u£Upd©ePageHô


225 
vÆ
 
√xtPageRïl
 = 
Reg
(
UI¡
(
width
 = 
	$log2Ceû
(
nPages
)))

226 
vÆ
 
idxPageRïl
 = 
	`C©
(
	`∑geHô
(
nPages
-2,0),ÖageHô“Pages-1)Ë| 
	`Mux
(
u£PageHô
, 
	`UI¡
(0), 
	$UI¡ToOH
(
√xtPageRïl
))

227 
vÆ
 
idxPageUpd©eOH
 = 
	$Mux
(
u£Upd©ePageHô
, 
upd©ePageHô
, 
idxPageRïl
)

228 
vÆ
 
idxPageUpd©e
 = 
	$OHToUI¡
(
idxPageUpd©eOH
)

229 
vÆ
 
idxPageRïlEn
 = 
	`Mux
(
doIdxPageRïl
, 
idxPageRïl
, 
	$UI¡
(0))

231 
vÆ
 
ßmePage
 = 
	`∑ge
(
r_btb_upd©e
.
bôs
.
pc
Ë==
	$∑ge
(
upd©e_èrgë
)

232 
vÆ
 
doTgtPageRïl
 = !
ßmePage
 && !
u£PageHô


233 
vÆ
 
tgtPageRïl
 = 
	`Mux
(
ßmePage
, 
idxPageUpd©eOH
, 
	`C©
(
	`idxPageUpd©eOH
(
nPages
-2,0), idxPageUpdateOH(nPages-1)))

234 
vÆ
 
tgtPageUpd©e
 = 
	`OHToUI¡
(
∑geHô
 | 
	`Mux
(
u£PageHô
, 
	`UI¡
(0), 
tgtPageRïl
))

235 
vÆ
 
tgtPageRïlEn
 = 
	`Mux
(
doTgtPageRïl
, 
tgtPageRïl
, 
	$UI¡
(0))

237 
	`whí
 (
r_btb_upd©e
.
vÆid
 && (
doIdxPageRïl
 || 
doTgtPageRïl
)) {

238 
vÆ
 
bŸh
 = 
doIdxPageRïl
 && 
doTgtPageRïl


239 
vÆ
 
√xt
 = 
√xtPageRïl
 + 
Mux
[
UI¡
](
bŸh
, 2, 1)

240 
√xtPageRïl
 :
	`Mux
(
√xt
 >
nPages
, 
	`√xt
(0),Çext)

241 
	}
}

243 
vÆ
 
	gª∂
 = 
√w
 
	$P£udoLRU
(
íåõs
)

244 
vÆ
 
waddr
 = 
	$Mux
(
upd©eHô
, 
upd©eHôAddr
, 
ª∂
.
ª∂a˚
)

245 
vÆ
 
r_ª•
 = 
	$Pùe
(
io
.
ª•
)

246 
	`whí
 (
r_ª•
.
vÆid
 &&Ñ_ª•.
bôs
.
èkí
 || 
r_btb_upd©e
.valid) {

247 
ª∂
.
	`ac˚ss
(
	`Mux
(
r_btb_upd©e
.
vÆid
, 
waddr
, 
r_ª•
.
bôs
.
íåy
))

248 
	}
}

250 
	$whí
 (
r_btb_upd©e
.
vÆid
) {

251 
vÆ
 
mask
 = 
	`UI¡ToOH
(
waddr
)

252 
	`idxs
(
waddr
Ë:
r_btb_upd©e
.
bôs
.
	`pc
(
m©chBôs
-1, 
	`log2Up
(
c‹eIn°Byãs
))

253 
	`tgts
(
waddr
Ë:
	`upd©e_èrgë
(
m©chBôs
-1, 
	`log2Up
(
c‹eIn°Byãs
))

254 
	`idxPages
(
waddr
Ë:
idxPageUpd©e
 +& 1

255 
	`tgtPages
(
waddr
Ë:
tgtPageUpd©e


256 
	`cfiTy≥
(
waddr
Ë:
r_btb_upd©e
.
bôs
.
cfiTy≥


257 
isVÆid
 :
	`Mux
(
r_btb_upd©e
.
bôs
.isVÆid, isVÆid | 
mask
, isValid & ~mask)

258 i‡(
„tchWidth
 > 1)

259 
	`brIdx
(
waddr
Ë:
r_btb_upd©e
.
bôs
.
br_pc
 >> 
	`log2Up
(
c‹eIn°Byãs
)

261 
	`ªquúe
(
nPages
 % 2 == 0)

262 
vÆ
 
idxWrôesEví
 = !
	`idxPageUpd©e
(0)

264 
def
 
	`wrôeB™k
(
i
: 
I¡
, 
mod
: I¡, 
í
: 
UI¡
, 
d©a
: UInt) =

265 
i
 <- i 
u¡û
 
nPages
 
by
 
mod
)

266 
	`whí
 (
	`í
(
i
)Ë{ 
	`∑ges
(iË:
d©a
 }

268 
	`wrôeB™k
(0, 2, 
	`Mux
(
idxWrôesEví
, 
idxPageRïlEn
, 
tgtPageRïlEn
),

269 
	`Mux
(
idxWrôesEví
, 
	`∑ge
(
r_btb_upd©e
.
bôs
.
pc
),Öage(
upd©e_èrgë
)))

270 
	`wrôeB™k
(1, 2, 
	`Mux
(
idxWrôesEví
, 
tgtPageRïlEn
, 
idxPageRïlEn
),

271 
	`Mux
(
idxWrôesEví
, 
	`∑ge
(
upd©e_èrgë
),Öage(
r_btb_upd©e
.
bôs
.
pc
)))

272 
∑geVÆid
 :∑geVÆid | 
tgtPageRïlEn
 | 
idxPageRïlEn


273 
	}
}

275 
io
.
ª•
.
vÆid
 :(
∑geHô
 << 1)(
	$Mux1H
(
idxHô
, 
idxPages
))

276 
io
.
ª•
.
bôs
.
èkí
 :
åue


277 
io
.
ª•
.
bôs
.
èrgë
 :
	`C©
(
	`∑ges
(
	`Mux1H
(
idxHô
, 
tgtPages
)), Mux1H(idxHô, 
tgts
Ë<< 
	$log2Up
(
c‹eIn°Byãs
))

278 
io
.
ª•
.
bôs
.
íåy
 :
	$OHToUI¡
(
idxHô
)

279 
io
.
ª•
.
bôs
.
bridx
 :(i‡(
„tchWidth
 > 1Ë
	$Mux1H
(
idxHô
, 
brIdx
Ë
	$UI¡
(0))

280 
io
.
ª•
.
bôs
.
mask
 :
	`C©
((
	`UI¡
(1Ë<< ~
	`Mux
(io.ª•.bôs.
èkí
, ~io.ª•.bôs.
bridx
, UI¡(0)))-1, 
	$UI¡
(1))

281 
io
.
ª•
.
bôs
.
cfiTy≥
 :
	$Mux1H
(
idxHô
, 
cfiTy≥
)

284 
	`whí
 (
	$P›Cou¡AtLó°
(
idxHô
, 2)) {

285 
isVÆid
 :isVÆid & ~
idxHô


286 
	}
}

287 
	$whí
 (
io
.
Êush
) {

288 
isVÆid
 := 0

289 
	}
}

291 i‡(
btbP¨ams
.
bhtP¨ams
.
n⁄Em±y
) {

292 
vÆ
 
bht
 = 
√w
 
BHT
(
A¬Ÿ©ed
.
∑øms
(
this
, 
btbP¨ams
.
bhtP¨ams
.
gë
))

293 
vÆ
 
	gisBønch
 = (
idxHô
 & 
cfiTy≥
.
m≠
(
_
 ==
CFITy≥
.
bønch
).
asUI¡
).
‹R


294 
vÆ
 
ªs
 = 
bht
.
gë
(
io
.
ªq
.
bôs
.
addr
)

295 
whí
 (
io
.
bht_adv™˚
.
vÆid
) {

296 
bht
.
adv™˚Hi°‹y
(
io
.
bht_adv™˚
.
bôs
.bht.
èkí
)

298 
whí
 (
io
.
bht_upd©e
.
vÆid
) {

299 
whí
 (
io
.
bht_upd©e
.
bôs
.
bønch
) {

300 
bht
.
upd©eTabÀ
(
io
.
bht_upd©e
.
bôs
.
pc
, io.bht_upd©e.bôs.
¥edi˘i⁄
, io.bht_upd©e.bôs.
èkí
)

301 
whí
 (
io
.
bht_upd©e
.
bôs
.
mi•ªdi˘
) {

302 
bht
.
upd©eHi°‹y
(
io
.
bht_upd©e
.
bôs
.
pc
, io.bht_upd©e.bôs.
¥edi˘i⁄
, io.bht_upd©e.bôs.
èkí
)

304 }.
ñ£whí
 (
io
.
bht_upd©e
.
bôs
.
mi•ªdi˘
) {

305 
bht
.
ª£tHi°‹y
(
io
.
bht_upd©e
.
bôs
.
¥edi˘i⁄
)

308 
whí
 (!
ªs
.
èkí
 && 
isBønch
Ë{ 
io
.
ª•
.
bôs
.èkí :
Ál£
 }

309 
io
.
ª•
.
bôs
.
bht
 :
ªs


312 i‡(
btbP¨ams
.
nRAS
 > 0) {

313 
vÆ
 
øs
 = 
√w
 
RAS
(
btbP¨ams
.
nRAS
)

314 
vÆ
 
doPìk
 = (
idxHô
 & 
cfiTy≥
.
m≠
(
_
 ==
CFITy≥
.
ªt
).
asUI¡
).
‹R


315 
io
.
øs_hód
.
vÆid
 :!
øs
.
isEm±y


316 
io
.
øs_hód
.
bôs
 :
øs
.
≥ek


317 
whí
 (!
øs
.
isEm±y
 && 
doPìk
) {

318 
io
.
ª•
.
bôs
.
èrgë
 :
øs
.
≥ek


320 
whí
 (
io
.
øs_upd©e
.
vÆid
) {

321 
whí
 (
io
.
øs_upd©e
.
bôs
.
cfiTy≥
 ==
CFITy≥
.
ˇŒ
) {

322 
øs
.
push
(
io
.
øs_upd©e
.
bôs
.
ªtu∫Addr
)

323 }.
ñ£whí
 (
io
.
øs_upd©e
.
bôs
.
cfiTy≥
 ==
CFITy≥
.
ªt
) {

324 
øs
.
p›
()

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Breakpoint.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.{
	gC‹eModuÀ
, 
	gC‹eBundÀ
}

9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 ˛as†
	cBPC⁄åﬁ
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

12 
vÆ
 
ây≥
 = 
	$UI¡
(
width
 = 4)

13 
vÆ
 
dmode
 = 
	$Boﬁ
()

14 
vÆ
 
maskmax
 = 
	$UI¡
(
width
 = 6)

15 
vÆ
 
ª£rved
 = 
	`UI¡
(
width
 = 
xLí
-24)

16 
vÆ
 
a˘i⁄
 = 
	$Boﬁ
()

17 
vÆ
 
chaö
 = 
	$Boﬁ
()

18 
vÆ
 
zîo
 = 
	$UI¡
(
width
 = 2)

19 
vÆ
 
tm©ch
 = 
	$UI¡
(
width
 = 2)

20 
vÆ
 
m
 = 
	$Boﬁ
()

21 
vÆ
 
h
 = 
	$Boﬁ
()

22 
vÆ
 
s
 = 
	$Boﬁ
()

23 
vÆ
 
u
 = 
	$Boﬁ
()

24 
vÆ
 
x
 = 
	$Boﬁ
()

25 
vÆ
 
w
 = 
	$Boﬁ
()

26 
vÆ
 
r
 = 
	$Boﬁ
()

28 
def
 
tTy≥
 = 2

29 
def
 
maskMax
 = 4

30 
def
 
	`íabÀd
(
m°©us
: 
MSètus
Ë!m°©us.
debug
 && 
	$C©
(
m
, 
h
, 
s
, 
u
)(
m°©us
.
¥v
)

33 ˛as†
	cBP
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

34 
vÆ
 
c⁄åﬁ
 = 
√w
 
BPC⁄åﬁ


35 
vÆ
 
addªss
 = 
	$UI¡
(
width
 = 
vaddrBôs
)

37 
def
 
	`mask
(
dummy
: 
I¡
 = 0) =

38 (0 
u¡û
 
c⁄åﬁ
.
maskMax
-1).
	`sˇnLe·
(c⁄åﬁ.
	$tm©ch
(0))((
m
, 
i
Ë=> m && 
	`addªss
(i)).
asUI¡


40 
def
 
	`pow2AddªssM©ch
(
x
: 
UI¡
) =

41 (~
x
 | 
	`mask
()Ë==(~
addªss
 | 
	$mask
())

43 
def
 
	`øngeAddªssM©ch
(
x
: 
UI¡
) =

44 (
x
 >
addªss
Ë^ 
c⁄åﬁ
.
	$tm©ch
(0)

46 
def
 
	`addªssM©ch
(
x
: 
UI¡
) =

47 
	`Mux
(
c⁄åﬁ
.
	`tm©ch
(1), 
	`øngeAddªssM©ch
(
x
), 
	`pow2AddªssM©ch
(x))

50 ˛as†
	cBªakpoötUnô
(
n
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
) {

51 
vÆ
 
io
 = 
√w
 
BundÀ
 {

52 
vÆ
 
°©us
 = 
√w
 
	`MSètus
().
asI≈ut


53 
vÆ
 
bp
 = 
	`Vec
(
n
, 
√w
 
BP
).
asI≈ut


54 
vÆ
 
pc
 = 
	`UI¡
(
INPUT
, 
vaddrBôs
)

55 
vÆ
 
ó
 = 
	`UI¡
(
INPUT
, 
vaddrBôs
)

56 
vÆ
 
x˝t_if
 = 
	`Boﬁ
(
OUTPUT
)

57 
vÆ
 
x˝t_ld
 = 
	`Boﬁ
(
OUTPUT
)

58 
vÆ
 
x˝t_°
 = 
	`Boﬁ
(
OUTPUT
)

59 
vÆ
 
debug_if
 = 
	`Boﬁ
(
OUTPUT
)

60 
vÆ
 
debug_ld
 = 
	`Boﬁ
(
OUTPUT
)

61 
vÆ
 
debug_°
 = 
	`Boﬁ
(
OUTPUT
)

64 
io
.
x˝t_if
 :
Ál£


65 
io
.
x˝t_ld
 :
Ál£


66 
io
.
x˝t_°
 :
Ál£


67 
io
.
debug_if
 :
Ál£


68 
io
.
debug_ld
 :
Ál£


69 
io
.
debug_°
 :
Ál£


71 
io
.
bp
.
	`fﬁdLe·
((
	`Boﬁ
(
åue
), Boﬁ—rue), 
	$Boﬁ
(
åue
))Ë{ ((
ri
, 
wi
, 
xi
), 
bp
) =>

72 
vÆ
 
í
 = 
bp
.
c⁄åﬁ
.
	`íabÀd
(
io
.
°©us
)

73 
vÆ
 
r
 = 
í
 && 
ri
 && 
bp
.
c⁄åﬁ
.∏&& bp.
	`addªssM©ch
(
io
.
ó
)

74 
vÆ
 
w
 = 
í
 && 
wi
 && 
bp
.
c⁄åﬁ
.w && bp.
	`addªssM©ch
(
io
.
ó
)

75 
vÆ
 
x
 = 
í
 && 
xi
 && 
bp
.
c⁄åﬁ
.x && bp.
	`addªssM©ch
(
io
.
pc
)

76 
vÆ
 
íd
 = !
bp
.
c⁄åﬁ
.
chaö


78 
	`whí
 (
íd
 && 
r
Ë{ 
io
.
x˝t_ld
 :!
bp
.
c⁄åﬁ
.
a˘i⁄
; io.
debug_ld
 := bp.control.action }

79 
	`whí
 (
íd
 && 
w
Ë{ 
io
.
x˝t_°
 :!
bp
.
c⁄åﬁ
.
a˘i⁄
; io.
debug_°
 := bp.control.action }

80 
	`whí
 (
íd
 && 
x
Ë{ 
io
.
x˝t_if
 :!
bp
.
c⁄åﬁ
.
a˘i⁄
; io.
debug_if
 := bp.control.action }

82 (
íd
 || 
r
,Énd || 
w
,Énd || 
x
)

83 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BusErrorUnit.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


7 
imp‹t
 
	gchi£l3
.
	gutû
.
VÆid


8 
imp‹t
 
	gchi£l3
.
	gc‹e
.
D⁄tC¨e


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


15 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


16 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


18 
åaô
 
BusEº‹s
 
exãnds
 
	gBundÀ
 {

19 
def
 
	gtoEº‹Li°
: 
Li°
[
O±i⁄
[(
VÆid
[
UI¡
], 
	gSåög
, String)]]

22 ˛as†
	cL1BusEº‹s
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
Ë
wôh
 
BusEº‹s
 {

23 
vÆ
 
iˇche
 = 
√w
 
ICacheEº‹s


24 
vÆ
 
dˇche
 = 
√w
 
DCacheEº‹s


26 
def
 
toEº‹Li°
 = 
	`Li°
(
N⁄e
, None,

27 
iˇche
.
c‹ª˘abÀ
.
	`m≠
((
_
, "I_CORRECTABLE", "Instruction cache or ITIM correctable ECCÉrror ")),

28 
iˇche
.
unc‹ª˘abÀ
.
	`m≠
((
_
, "I_UNCORRECTABLE", "ITIM uncorrectable ECCÉrror")),

29 
N⁄e
,

30 
	`Some
((
dˇche
.
bus
, "DBUS", "Load or store TileLink busÉrror")),

31 
dˇche
.
c‹ª˘abÀ
.
	`m≠
((
_
, "D_CORRECTABLE", "Data cache correctable ECCÉrror")),

32 
dˇche
.
unc‹ª˘abÀ
.
	`m≠
((
_
, "D_UNCORRECTABLE", "Data cache uncorrectable ECCÉrror")))

35 
˛ass
 
	$BusEº‹UnôP¨ams
(
addr
: 
BigI¡
, 
size
: 
I¡
 = 4096)

37 
˛ass
 
BusEº‹Unô
[
T
 <: 
BusEº‹s
](
t
: => T, 
∑øms
: 
BusEº‹UnôP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

38 
vÆ
 
ªgWidth
 = 64

39 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("bus-îr‹-unô", 
	`Seq
("sifive,buserror0"))

40 
vÆ
 
ötNode
 = 
	`I¡Sour˚Node
(
	`I¡Sour˚P‹tSim∂e
(
ªsour˚s
 = 
devi˚
.))

41 
vÆ
 
node
 = 
	`TLRegi°îNode
(

42 
addªss
 = 
	`Seq
(
	`AddªssSë
(
∑øms
.
addr
,Ö¨ams.
size
-1)),

43 
devi˚
 = device,

44 
bótByãs
 = 
	`p
(
XLí
)/8)

46 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

47 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

48 
vÆ
 
îr‹s
 = 
t
.
Êù


49 
vÆ
 
öãºu±
 = 
	`Boﬁ
().
asOuçut


52 
vÆ
 
sour˚s_™d_desc
 = 
io
.
îr‹s
.
toEº‹Li°


53 
vÆ
 
sour˚s
 = 
sour˚s_™d_desc
.
	`m≠
(
_
.m≠(_.
_1
))

54 
vÆ
 
sour˚s_íums
 = 
sour˚s_™d_desc
.
zùWôhIndex
.
Ê©M≠
{(
s
, 
i
Ë=> s.
m≠
 {
e
 => (
	`BigI¡
(iË-> (e.
_2
,É.
_3
))}}

56 
vÆ
 
ˇu£Width
 = 
	`log2Ceû
(
sour˚s
.
	`œ°IndexWhîe
(
_
.
n⁄Em±y
) + 1)

57 
	`vÆ
 (
ˇu£
, 
ˇu£_desc
Ë
	`Des¸ibedReg
(
	`UI¡
(
ˇu£Width
.
W
),

58 "ˇu£", "Cau£ o‡îr‹Évít", 
ª£t
=
	`Some
(0.U(
ˇu£Width
.
W
)), vﬁ©ûe=
åue
, 
íumî©i⁄s
=
sour˚s_íums
.
toM≠
)

60 
	`vÆ
 (
vÆue
, 
vÆue_desc
Ë
	`Des¸ibedReg
(
	`UI¡
(
width
 = 
sour˚s
.
Ê©ãn
.
	`m≠
(
_
.
bôs
.
gëWidth
).
max
),

61 "vÆue", "Physiˇ»addªs†o‡îr‹Évít", 
ª£t
=
N⁄e
, vﬁ©ûe=
åue
)

62 
	`ªquúe
(
vÆue
.
gëWidth
 <
ªgWidth
)

64 
vÆ
 
íabÀ
 = 
	`Reg
(
öô
 = 
	`Vec
(
sour˚s
.
	`m≠
(
_
.
n⁄Em±y
.
B
)))

65 
vÆ
 
íabÀ_desc
 = 
sour˚s
.
zùWôhIndex
.
m≠
 { (
s
, 
i
) =>

66 i‡(
s
.
n⁄Em±y
Ë
	`RegFõldDesc
(s"íabÀ_$i", "", 
ª£t
=
	`Some
(1))

67 
RegFõldDesc
.
ª£rved


70 
vÆ
 
globÆ_öãºu±
 = 
	`Reg
(
öô
 = 
Vec
.
	`fûl
(
sour˚s
.
size
)(
Ál£
.
B
))

71 
vÆ
 
globÆ_öãºu±_desc
 = 
sour˚s
.
zùWôhIndex
.
m≠
 { (
s
, 
i
) =>

72 i‡(
s
.
n⁄Em±y
Ë
	`RegFõldDesc
(s"∂ic_öãºu±_$i", "", 
ª£t
=
	`Some
(0))

73 
RegFõldDesc
.
ª£rved


76 
vÆ
 
ac¸ued
 = 
	`Reg
(
öô
 = 
Vec
.
	`fûl
(
sour˚s
.
size
)(
Ál£
.
B
))

77 
vÆ
 
ac¸ued_desc
 = 
sour˚s
.
zùWôhIndex
.
m≠
 { (
s
, 
i
) =>

78 i‡(
s
.
n⁄Em±y
Ë
	`RegFõldDesc
(s"ac¸ued_$i", "", 
ª£t
=
	`Some
(0), vﬁ©ûê
åue
)

79 
RegFõldDesc
.
ª£rved


82 
vÆ
 
loˇl_öãºu±
 = 
	`Reg
(
öô
 = 
Vec
.
	`fûl
(
sour˚s
.
size
)(
Ál£
.
B
))

83 
vÆ
 
loˇl_öãºu±_desc
 = 
sour˚s
.
zùWôhIndex
.
m≠
 { (
s
, 
i
) =>

84 i‡(
s
.
n⁄Em±y
Ë
	`RegFõldDesc
(s"loˇl_öãºu±_$i", "", 
ª£t
=
	`Some
(0))

85 
RegFõldDesc
.
ª£rved


88 
vÆ
 
ˇu£_wí
 = 
	`Wúe
(
öô
 = 
Ál£
.
B
)

89 
vÆ
 
√w_ˇu£
 = 
	`Wúe
(
	`UI¡
(
ˇu£Width
.
W
), 
D⁄tC¨e
)

90 
vÆ
 
√w_vÆue
 = 
	`Wúe
(
	`UI¡
(
vÆue
.
gëWidth
.
W
), 
D⁄tC¨e
)

91 (((
s
, 
í
), 
acc
), 
i
Ë<- (
sour˚s
 
zù
 
íabÀ
 zù 
ac¸ued
).
zùWôhIndex
; s.
n⁄Em±y
) {

92 
	`whí
 (
s
.
gë
.
vÆid
) {

93 
acc
 :
åue


94 
	`whí
 (
í
) {

95 
ˇu£_wí
 :
åue


96 
√w_ˇu£
 :
i


97 
√w_vÆue
 :
s
.
gë
.
bôs


99 
	`covî
(
í
, 
s
"BusErrorCause_$i", s"Core;;BusErrorCause $i covered")

103 
	`whí
 (
ˇu£
 ==0 && 
ˇu£_wí
) {

104 
ˇu£
 :
	`O±imiz©i⁄B¨rõr
(
√w_ˇu£
)

105 
vÆue
 :
	`O±imiz©i⁄B¨rõr
(
√w_vÆue
)

108 
	`vÆ
 (
öt_out
, 
_
Ë
ötNode
.
	`out
(0)

109 
io
.
öãºu±
 :(
ac¸ued
.
asUI¡
 & 
loˇl_öãºu±
.asUI¡).
‹R


110 
	`öt_out
(0Ë:(
ac¸ued
.
asUI¡
 & 
globÆ_öãºu±
.asUI¡).
‹R


112 
def
 
	`ªg
(
r
: 
UI¡
, 
gn
: 
Såög
, 
d
: 
RegFõldDesc
Ë
	`RegFõldGroup
(gn, 
N⁄e
, 
RegFõld
.
	`byãs
‘, (r.
gëWidth
 + 7)/8, 
	`Some
(d)))

113 
def
 
	`ªg
(
v
: 
Vec
[
Boﬁ
], 
gn
: 
Såög
, 
gd
: Såög, 
d
: 
Seq
[
RegFõldDesc
]) =

114 
	`RegFõldGroup
(
gn
, 
	`Some
(
gd
), (
v
 
zù
 
d
).
m≠
 {(
r
, 
rd
Ë=> 
	`RegFõld
(1,Ñ,Ñd)})

115 
def
 
	`numbîRegs
(
x
: 
Seq
[Seq[
RegFõld
]]Ëx.
zùWôhIndex
.
m≠
 {(
f
, 
i
Ë=> (ò* 
ªgWidth
 / 8) -> f }

117 
node
.
	`ªgm≠
(
	`numbîRegs
(
	`Seq
(

118 
	`ªg
(
ˇu£
, "ˇu£", 
ˇu£_desc
),

119 
	`ªg
(
vÆue
, "vÆue", 
vÆue_desc
),

120 
	`ªg
(
íabÀ
, "íabÀ", "EvíàíabÀ mask", 
íabÀ_desc
),

121 
	`ªg
(
globÆ_öãºu±
, "∂ic_öãºu±", "Pœtf‹m-Àvñ i¡îru±É«bÀ mask", 
globÆ_öãºu±_desc
),

122 
	`ªg
(
ac¸ued
, "ac¸ued", "Ac¸uedÉvíàmask" ,
ac¸ued_desc
),

123 
	`ªg
(
loˇl_öãºu±
, "loˇl_öãºu±", "H¨t-loˇ»öãºu±-íabÀ mask", 
loˇl_öãºu±_desc
))):
_
*)

126 (
s
, 
i
Ë<- 
sour˚s
.
zùWôhIndex
; s.
isEm±y
) {

127 
	`íabÀ
(
i
Ë:
Ál£


128 
	`globÆ_öãºu±
(
i
Ë:
Ál£


129 
	`ac¸ued
(
i
Ë:
Ál£


130 
	`loˇl_öãºu±
(
i
Ë:
Ál£


133 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/CSR.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


13 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
LökedHashM≠


14 
imp‹t
 
	gIn°ru˘i⁄s
.
_


16 ˛as†
	cMSètus
 
exãnds
 
	mBundÀ
 {

18 
vÆ
 
	mdebug
 = 
	$Boﬁ
()

19 
vÆ
 
iß
 = 
	$UI¡
(
width
 = 32)

21 
vÆ
 
d¥v
 = 
	$UI¡
(
width
 = 
PRV
.
SZ
)

22 
vÆ
 
¥v
 = 
	$UI¡
(
width
 = 
PRV
.
SZ
)

23 
vÆ
 
sd
 = 
	$Boﬁ
()

24 
vÆ
 
zîo2
 = 
	$UI¡
(
width
 = 27)

25 
vÆ
 
sxl
 = 
	$UI¡
(
width
 = 2)

26 
vÆ
 
uxl
 = 
	$UI¡
(
width
 = 2)

27 
vÆ
 
sd_rv32
 = 
	$Boﬁ
()

28 
vÆ
 
zîo1
 = 
	$UI¡
(
width
 = 8)

29 
vÆ
 
t§
 = 
	$Boﬁ
()

30 
vÆ
 
tw
 = 
	$Boﬁ
()

31 
vÆ
 
tvm
 = 
	$Boﬁ
()

32 
vÆ
 
mxr
 = 
	$Boﬁ
()

33 
vÆ
 
sum
 = 
	$Boﬁ
()

34 
vÆ
 
m¥v
 = 
	$Boﬁ
()

35 
vÆ
 
xs
 = 
	$UI¡
(
width
 = 2)

36 
vÆ
 
fs
 = 
	$UI¡
(
width
 = 2)

37 
vÆ
 
mµ
 = 
	$UI¡
(
width
 = 2)

38 
vÆ
 
hµ
 = 
	$UI¡
(
width
 = 2)

39 
vÆ
 
•p
 = 
	$UI¡
(
width
 = 1)

40 
vÆ
 
mpõ
 = 
	$Boﬁ
()

41 
vÆ
 
hpõ
 = 
	$Boﬁ
()

42 
vÆ
 
•õ
 = 
	$Boﬁ
()

43 
vÆ
 
upõ
 = 
	$Boﬁ
()

44 
vÆ
 
mõ
 = 
	$Boﬁ
()

45 
vÆ
 
hõ
 = 
	$Boﬁ
()

46 
vÆ
 
sõ
 = 
	$Boﬁ
()

47 
vÆ
 
uõ
 = 
	`Boﬁ
()

50 ˛as†
	cDCSR
 
exãnds
 
BundÀ
 {

51 
vÆ
 
xdebugvî
 = 
	$UI¡
(
width
 = 2)

52 
vÆ
 
zîo4
 = 
	$UI¡
(
width
=2)

53 
vÆ
 
zîo3
 = 
	$UI¡
(
width
 = 12)

54 
vÆ
 
ebªakm
 = 
	$Boﬁ
()

55 
vÆ
 
ebªakh
 = 
	$Boﬁ
()

56 
vÆ
 
ebªaks
 = 
	$Boﬁ
()

57 
vÆ
 
ebªaku
 = 
	$Boﬁ
()

58 
vÆ
 
zîo2
 = 
	$Boﬁ
()

59 
vÆ
 
°›cy˛e
 = 
	$Boﬁ
()

60 
vÆ
 
°›time
 = 
	$Boﬁ
()

61 
vÆ
 
ˇu£
 = 
	$UI¡
(
width
 = 3)

62 
vÆ
 
zîo1
 = 
	$UI¡
(
width
=3)

63 
vÆ
 
°ï
 = 
	$Boﬁ
()

64 
vÆ
 
¥v
 = 
	`UI¡
(
width
 = 
PRV
.
SZ
)

67 ˛as†
	cMIP
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
)

68 
wôh
 
HasC‹eP¨amëîs
 {

69 
vÆ
 
lù
 = 
	`Vec
(
c‹eP¨ams
.
nLoˇlI¡îru±s
, 
	$Boﬁ
())

70 
vÆ
 
zîo2
 = 
	$Boﬁ
()

71 
vÆ
 
debug
 = 
	$Boﬁ
()

72 
vÆ
 
zîo1
 = 
	$Boﬁ
()

73 
vÆ
 
rocc
 = 
	$Boﬁ
()

74 
vÆ
 
meù
 = 
	$Boﬁ
()

75 
vÆ
 
heù
 = 
	$Boﬁ
()

76 
vÆ
 
£ù
 = 
	$Boﬁ
()

77 
vÆ
 
ueù
 = 
	$Boﬁ
()

78 
vÆ
 
mtù
 = 
	$Boﬁ
()

79 
vÆ
 
htù
 = 
	$Boﬁ
()

80 
vÆ
 
°ù
 = 
	$Boﬁ
()

81 
vÆ
 
utù
 = 
	$Boﬁ
()

82 
vÆ
 
msù
 = 
	$Boﬁ
()

83 
vÆ
 
hsù
 = 
	$Boﬁ
()

84 
vÆ
 
ssù
 = 
	$Boﬁ
()

85 
vÆ
 
usù
 = 
	`Boﬁ
()

88 ˛as†
	cPTBR
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

89 
def
 
	`pgLevñsToMode
(
i
: 
I¡
Ë(
xLí
, iË
m©ch
 {

91 (64, 
x
) x >= 3 && x <= 6 => x + 5

93 
	`vÆ
 (
modeBôs
, 
maxASIdBôs
Ë
xLí
 
m©ch
 {

96 
	}
}

97 
ªquúe
(
modeBôs
 + 
maxASIdBôs
 + 
maxPAddrBôs
 - 
pgIdxBôs
 =
xLí
)

99 
vÆ
 
mode
 = 
	$UI¡
(
width
 = 
modeBôs
)

100 
vÆ
 
asid
 = 
	$UI¡
(
width
 = 
maxASIdBôs
)

101 
vÆ
 
µn
 = 
	`UI¡
(
width
 = 
maxPAddrBôs
 - 
pgIdxBôs
)

102 
	}
}

104 
obje˘
 
	gPRV


106 
vÆ
 
	gSZ
 = 2

107 
vÆ
 
U
 = 0

108 
vÆ
 
S
 = 1

109 
vÆ
 
H
 = 2

110 
vÆ
 
M
 = 3

113 
obje˘
 
	gCSR


116 
vÆ
 
	gSZ
 = 3

117 
def
 
X
 = 
BôP©
.
d⁄tC¨e
(
SZ
)

118 
def
 
N
 = 
UI¡
(0,
SZ
)

119 
def
 
	gR
 = 
UI¡
(2,
SZ
)

120 
def
 
	gI
 = 
UI¡
(4,
SZ
)

121 
def
 
	gW
 = 
UI¡
(5,
SZ
)

122 
def
 
	gS
 = 
UI¡
(6,
SZ
)

123 
def
 
	gC
 = 
UI¡
(7,
SZ
)

126 
def
 
maskCmd
(
vÆid
: 
Boﬁ
, 
cmd
: 
UI¡
): UInt = {

128 
cmd
 & ~
Mux
(
vÆid
, 0.U, 
CSR
.
I
)

131 
vÆ
 
ADDRSZ
 = 12

132 
def
 
busEº‹I¡Cau£
 = 128

133 
def
 
debugI¡Cau£
 = 14

134 
def
 
debugTriggîCau£
 = {

135 
vÆ
 
ªs
 = 
debugI¡Cau£


136 
ªquúe
(!(
Cau£s
.
Æl
 
c⁄èös
 
ªs
))

137 
ªs


140 
vÆ
 
	gfú°Cå
 = 
CSRs
.
cy˛e


141 
vÆ
 
fú°CåH
 = 
CSRs
.
cy˛eh


142 
vÆ
 
fú°HPC
 = 
CSRs
.
hpmcou¡î3


143 
vÆ
 
fú°HPCH
 = 
CSRs
.
hpmcou¡î3h


144 
vÆ
 
fú°HPE
 = 
CSRs
.
mhpmevít3


145 
vÆ
 
fú°MHPC
 = 
CSRs
.
mhpmcou¡î3


146 
vÆ
 
fú°MHPCH
 = 
CSRs
.
mhpmcou¡î3h


147 
vÆ
 
fú°HPM
 = 3

148 
vÆ
 
nCå
 = 32

149 
vÆ
 
nHPM
 = 
nCå
 - 
fú°HPM


150 
vÆ
 
hpmWidth
 = 40

152 
vÆ
 
maxPMPs
 = 16

155 ˛as†
	cPîfCou¡îIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
C‹eBundÀ


156 
wôh
 
HasC‹eP¨amëîs
 {

157 
vÆ
 
evítSñ
 = 
	$UI¡
(
OUTPUT
, 
xLí
)

158 
vÆ
 
öc
 = 
	`UI¡
(
INPUT
, 
	`log2Ceû
(1+
ªtúeWidth
))

161 ˛as†
	cTø˚dIn°ru˘i⁄
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
C‹eBundÀ
 {

162 
vÆ
 
vÆid
 = 
	$Boﬁ
()

163 
vÆ
 
üddr
 = 
	$UI¡
(
width
 = 
c‹eMaxAddrBôs
)

164 
vÆ
 
ö¢
 = 
	$UI¡
(
width
 = 
iLí
)

165 
vÆ
 
¥iv
 = 
	$UI¡
(
width
 = 3)

166 
vÆ
 
ex˚±i⁄
 = 
	$Boﬁ
()

167 
vÆ
 
öãºu±
 = 
	$Boﬁ
()

168 
vÆ
 
ˇu£
 = 
	`UI¡
(
width
 = 
	`log2Ceû
(1 + 
CSR
.
busEº‹I¡Cau£
))

169 
vÆ
 
tvÆ
 = 
	`UI¡
(
width
 = 
c‹eMaxAddrBôs
 
max
 
iLí
)

172 ˛as†
	cCSRDecodeIO
 
exãnds
 
BundÀ
 {

173 
vÆ
 
c§
 = 
	$UI¡
(
INPUT
, 
CSR
.
ADDRSZ
)

174 
vÆ
 
Â_ûÀgÆ
 = 
	$Boﬁ
(
OUTPUT
)

175 
vÆ
 
Â_c§
 = 
	$Boﬁ
(
OUTPUT
)

176 
vÆ
 
rocc_ûÀgÆ
 = 
	$Boﬁ
(
OUTPUT
)

177 
vÆ
 
ªad_ûÀgÆ
 = 
	$Boﬁ
(
OUTPUT
)

178 
vÆ
 
wrôe_ûÀgÆ
 = 
	$Boﬁ
(
OUTPUT
)

179 
vÆ
 
wrôe_Êush
 = 
	$Boﬁ
(
OUTPUT
)

180 
vÆ
 
sy°em_ûÀgÆ
 = 
	`Boﬁ
(
OUTPUT
)

189 ˛as†
	cPCodeCSR
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

190 
	`ªquúe
(
∑ddrBôs
 > 12)

191 
vÆ
 
ba£
 = 
	`UI¡
(
width
 = 
∑ddrBôs
 - 12)

192 
vÆ
 
mask
 = 
	$UI¡
(
width
 = 10)

193 
vÆ
 
vÆid
 = 
	`Boﬁ
()

197 ˛as†
	cPCodeUpd©e
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
C‹eBundÀ


198 
wôh
 
HasC‹eP¨amëîs
 {

199 
vÆ
 
id
 = 
	`UI¡
(
OUTPUT
, 
	$log2Ceû
(
numPCodeR™ges
))

200 
vÆ
 
vÆue
 = 
√w
 
	`PCodeCSR
().
asOuçut


203 ˛as†
	cCSRFûeIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
C‹eBundÀ


204 
wôh
 
HasC‹eP¨amëîs
 {

205 
vÆ
 
ung©ed_˛ock
 = 
	`Clock
().
asI≈ut


206 
vÆ
 
öãºu±s
 = 
√w
 
	`C‹eI¡îru±s
().
asI≈ut


207 
vÆ
 
h¨tid
 = 
	$UI¡
(
INPUT
, 
h¨tIdLí
)

208 
vÆ
 
rw
 = 
√w
 
BundÀ
 {

209 
vÆ
 
addr
 = 
	`UI¡
(
INPUT
, 
CSR
.
ADDRSZ
)

210 
vÆ
 
cmd
 = 
	`Bôs
(
INPUT
, 
CSR
.
SZ
)

211 
vÆ
 
rd©a
 = 
	`Bôs
(
OUTPUT
, 
xLí
)

212 
vÆ
 
wd©a
 = 
	`Bôs
(
INPUT
, 
xLí
)

217 
vÆ
 
pcode_ªq
 = 
	$VÆid
(
√w
 
PCodeUpd©e
)

218 
vÆ
 
pcode_ª•
 = 
	`VÆid
(
√w
 
PCodeUpd©e
).
Êù


221 
vÆ
 
decode
 = 
	$Vec
(
decodeWidth
, 
√w
 
CSRDecodeIO
)

223 
vÆ
 
c§_°Æl
 = 
	$Boﬁ
(
OUTPUT
)

224 
vÆ
 
îë
 = 
	$Boﬁ
(
OUTPUT
)

225 
vÆ
 
sögÀSãp
 = 
	$Boﬁ
(
OUTPUT
)

227 
vÆ
 
°©us
 = 
√w
 
	`MSètus
().
asOuçut


228 
vÆ
 
±br
 = 
√w
 
	`PTBR
().
asOuçut


229 
vÆ
 
evec
 = 
	$UI¡
(
OUTPUT
, 
vaddrBôsExãnded
)

230 
vÆ
 
ex˚±i⁄
 = 
	$Boﬁ
(
INPUT
)

231 
vÆ
 
ªtúe
 = 
	`UI¡
(
INPUT
, 
	`log2Up
(1+
ªtúeWidth
))

232 
vÆ
 
ˇu£
 = 
	$UI¡
(
INPUT
, 
xLí
)

233 
vÆ
 
pc
 = 
	$UI¡
(
INPUT
, 
vaddrBôsExãnded
)

234 
vÆ
 
tvÆ
 = 
	$UI¡
(
INPUT
, 
vaddrBôsExãnded
)

235 
vÆ
 
time
 = 
	$UI¡
(
OUTPUT
, 
xLí
)

236 
vÆ
 
fc§_rm
 = 
	$Bôs
(
OUTPUT
, 
FPC⁄°™ts
.
RM_SZ
)

237 
vÆ
 
fc§_Êags
 = 
	`VÆid
(
	`Bôs
(
width
 = 
FPC⁄°™ts
.
FLAGS_SZ
)).
Êù


238 
vÆ
 
£t_fs_dúty
 = 
c‹eP¨ams
.
haveFSDúty
.
	`›ti⁄
(
	$Boﬁ
(
INPUT
))

239 
vÆ
 
rocc_öãºu±
 = 
	$Boﬁ
(
INPUT
)

240 
vÆ
 
öãºu±
 = 
	$Boﬁ
(
OUTPUT
)

241 
vÆ
 
öãºu±_ˇu£
 = 
	$UI¡
(
OUTPUT
, 
xLí
)

242 
vÆ
 
bp
 = 
	`Vec
(
nBªakpoöts
, 
√w
 
BP
).
asOuçut


243 
vÆ
 
pmp
 = 
	`Vec
(
nPMPs
, 
√w
 
PMP
).
asOuçut


244 
vÆ
 
cou¡îs
 = 
	$Vec
(
nPîfCou¡îs
, 
√w
 
PîfCou¡îIO
)

245 
vÆ
 
c§w_cou¡î
 = 
	$UI¡
(
OUTPUT
, 
CSR
.
nCå
)

246 
vÆ
 
ö°
 = 
	`Vec
(
ªtúeWidth
, 
	`UI¡
(
width
 = 
iLí
)).
asI≈ut


247 
vÆ
 
åa˚
 = 
	`Vec
(
ªtúeWidth
, 
√w
 
Tø˚dIn°ru˘i⁄
).
asOuçut


248 
	}
}

250 
˛ass
 
CSRFûe
(

251 
≥rfEvítSës
: 
EvítSës
 = 
√w
 EvítSës(
Seq
()),

252 
cu°omCSRs
: 
Seq
[
Cu°omCSR
] = 
Nû
)(
im∂icô
 
p
: 
P¨amëîs
)

253 
exãnds
 
	$C‹eModuÀ
()(
p
)

254 
wôh
 
HasC‹eP¨amëîs
 {

255 
vÆ
 
io
 = 
√w
 
CSRFûeIO
 {

256 
vÆ
 
cu°omCSRs
 = 
	`Vec
(
CSRFûe
.
this
.cu°omCSRs.
size
, 
√w
 
Cu°omCSRIO
).
asOuçut


259 
vÆ
 
ª£t_m°©us
 = 
	`Wúe
(
öô
=
√w
 
	`MSètus
().
	`‰omBôs
(0))

260 
ª£t_m°©us
.
mµ
 :
PRV
.
M


261 
ª£t_m°©us
.
¥v
 :
PRV
.
M


262 
vÆ
 
ªg_m°©us
 = 
	`Reg
(
öô
=
ª£t_m°©us
)

264 
vÆ
 
√w_¥v
 = 
	`Wúe
(
öô
 = 
ªg_m°©us
.
¥v
)

265 
ªg_m°©us
.
¥v
 :
	`ÀgÆizePrivûege
(
√w_¥v
)

267 
vÆ
 
ª£t_dc§
 = 
	`Wúe
(
öô
=
√w
 
	`DCSR
().
	`‰omBôs
(0))

268 
ª£t_dc§
.
xdebugvî
 := 1

269 
ª£t_dc§
.
¥v
 :
PRV
.
M


270 
vÆ
 
ªg_dc§
 = 
	`Reg
(
öô
=
ª£t_dc§
)

272 
	`vÆ
 (
suµ‹ãd_öãºu±s
, 
dñegabÀ_öãºu±s
) = {

273 
vÆ
 
sup
 = 
	`Wúe
(
√w
 
MIP
)

274 
sup
.
usù
 :
Ál£


275 
sup
.
ssù
 :
	`Boﬁ
(
usögVM
)

276 
sup
.
hsù
 :
Ál£


277 
sup
.
msù
 :
åue


278 
sup
.
utù
 :
Ál£


279 
sup
.
°ù
 :
	`Boﬁ
(
usögVM
)

280 
sup
.
htù
 :
Ál£


281 
sup
.
mtù
 :
åue


282 
sup
.
ueù
 :
Ál£


283 
sup
.
£ù
 :
	`Boﬁ
(
usögVM
)

284 
sup
.
heù
 :
Ál£


285 
sup
.
meù
 :
åue


286 
sup
.
rocc
 :
usögRoCC


287 
sup
.
zîo1
 :
Ál£


288 
sup
.
debug
 :
Ál£


289 
sup
.
zîo2
 :
Ál£


290 
sup
.
lù
 
f‹óch
 { 
_
 :
åue
 }

291 
vÆ
 
suµ‹ãd_high_öãºu±s
 = i‡(
io
.
öãºu±s
.
bu£º‹
.
n⁄Em±y
Ë
	`UI¡
(
	`BigI¡
(1Ë<< 
CSR
.
busEº‹I¡Cau£
) 0.U

293 
vÆ
 
dñ
 = 
	`Wúe
(
öô
=
sup
)

294 
dñ
.
msù
 :
Ál£


295 
dñ
.
mtù
 :
Ál£


296 
dñ
.
meù
 :
Ál£


298 (
sup
.
asUI¡
 | 
suµ‹ãd_high_öãºu±s
, 
dñ
.asUInt)

300 
vÆ
 
dñegabÀ_ex˚±i⁄s
 = 
	`UI¡
(
	`Seq
(

301 
Cau£s
.
mißlig√d_„tch
,

302 
Cau£s
.
„tch_∑ge_Áu…
,

303 
Cau£s
.
bªakpoöt
,

304 
Cau£s
.
lﬂd_∑ge_Áu…
,

305 
Cau£s
.
°‹e_∑ge_Áu…
,

309 
Cau£s
.
u£r_eˇŒ
).
	`m≠
(1 << 
_
).
sum
)

311 
vÆ
 
ªg_debug
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

312 
vÆ
 
ªg_dpc
 = 
	`Reg
(
	`UI¡
(
width
 = 
vaddrBôsExãnded
))

313 
vÆ
 
ªg_ds¸©ch
 = 
	`Reg
(
	`UI¡
(
width
 = 
xLí
))

314 
vÆ
 
ªg_sögÀSãµed
 = 
	`Reg
(
	`Boﬁ
())

316 
vÆ
 
ªg_t£À˘
 = 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Up
(
nBªakpoöts
)))

317 
vÆ
 
ªg_bp
 = 
	`Reg
(
	`Vec
(1 << 
	`log2Up
(
nBªakpoöts
), 
√w
 
BP
))

318 
vÆ
 
ªg_pmp
 = 
	`Reg
(
	`Vec
(
nPMPs
, 
√w
 
PMPReg
))

320 
vÆ
 
ªg_mõ
 = 
	`Reg
(
	`UI¡
(
width
 = 
xLí
))

321 
vÆ
 
ªg_midñeg
 = 
	`Reg
(
	`UI¡
(
width
 = 
xLí
))

322 
vÆ
 
ªg_medñeg
 = 
	`Reg
(
	`UI¡
(
width
 = 
xLí
))

323 
vÆ
 
ªg_mù
 = 
	`Reg
(
√w
 
MIP
)

324 
vÆ
 
ªg_mïc
 = 
	`Reg
(
	`UI¡
(
width
 = 
vaddrBôsExãnded
))

325 
vÆ
 
ªg_mˇu£
 = 
	`Reg
(
	`Bôs
(
width
 = 
xLí
))

326 
vÆ
 
ªg_mbadaddr
 = 
	`Reg
(
	`UI¡
(
width
 = 
vaddrBôsExãnded
))

327 
vÆ
 
ªg_ms¸©ch
 = 
	`Reg
(
	`Bôs
(
width
 = 
xLí
))

328 
vÆ
 
mtvecWidth
 = 
∑ddrBôs
 
mö
 
xLí


329 
vÆ
 
ªg_mtvec
 = 
mtvecInô
 
m©ch
 {

330 
	`Some
(
addr
Ë=> 
	`Reg
(
öô
=
	`UI¡
◊ddr, 
mtvecWidth
))

331 
N⁄e
 => 
	`Reg
(
	`UI¡
(
width
 = 
mtvecWidth
))

333 
vÆ
 
ªg_mcou¡îí
 = 
	`Reg
(
	`UI¡
(
width
 = 32))

334 
vÆ
 
ªg_scou¡îí
 = 
	`Reg
(
	`UI¡
(
width
 = 32))

335 
vÆ
 
dñegabÀ_cou¡îs
 = (
	`BigI¡
(1Ë<< (
nPîfCou¡îs
 + 
CSR
.
fú°HPM
)) - 1

337 
vÆ
 
ªg_£pc
 = 
	`Reg
(
	`UI¡
(
width
 = 
vaddrBôsExãnded
))

338 
vÆ
 
ªg_sˇu£
 = 
	`Reg
(
	`Bôs
(
width
 = 
xLí
))

339 
vÆ
 
ªg_sbadaddr
 = 
	`Reg
(
	`UI¡
(
width
 = 
vaddrBôsExãnded
))

340 
vÆ
 
ªg_ss¸©ch
 = 
	`Reg
(
	`Bôs
(
width
 = 
xLí
))

341 
vÆ
 
ªg_°vec
 = 
	`Reg
(
	`UI¡
(
width
 = 
vaddrBôs
))

342 
vÆ
 
ªg_•tbr
 = 
	`Reg
(
√w
 
PTBR
)

343 
vÆ
 
ªg_wfi
 = 
	`wôhClock
(
io
.
ung©ed_˛ock
Ë{ 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
)) }

345 
vÆ
 
ªg_fÊags
 = 
	`Reg
(
	`UI¡
(
width
 = 5))

346 
vÆ
 
ªg_‰m
 = 
	`Reg
(
	`UI¡
(
width
 = 3))

348 
vÆ
 
ªg_ö°ªt
 = 
	`WideCou¡î
(64, 
io
.
ªtúe
)

349 
vÆ
 
ªg_cy˛e
 = i‡(
íabÀCommôLog
Ë
ªg_ö°ªt
 
	`wôhClock
(
io
.
ung©ed_˛ock
Ë{ 
	`WideCou¡î
(64, !
ªg_wfi
) }

350 
vÆ
 
ªg_hpmevít
 = 
io
.
cou¡îs
.
	`m≠
(
c
 => 
	`Reg
(
öô
 = 
	`UI¡
(0, 
xLí
)))

351 (
io
.
cou¡îs
 
zù
 
ªg_hpmevít
Ë
f‹óch
 { (
c
, 
e
Ë=> c.
evítSñ
 :=É }

352 
vÆ
 
ªg_hpmcou¡î
 = 
io
.
cou¡îs
.
	`m≠
(
c
 => 
	`WideCou¡î
(
CSR
.
hpmWidth
, c.
öc
, 
ª£t
 = 
Ál£
))

354 
vÆ
 
mù
 = 
	`Wúe
(
öô
=
ªg_mù
)

355 
mù
.
lù
 :(
io
.
öãºu±s
.lù: 
Seq
[
Boﬁ
])

356 
mù
.
mtù
 :
io
.
öãºu±s
.mtip

357 
mù
.
msù
 :
io
.
öãºu±s
.msip

358 
mù
.
meù
 :
io
.
öãºu±s
.meip

360 
io
.
öãºu±s
.
£ù
.
f‹óch
 { 
mù
.£ù :
ªg_mù
.£ù || 
	`RegNext
(
_
) }

361 
mù
.
rocc
 :
io
.
rocc_öãºu±


362 
vÆ
 
ªad_mù
 = 
mù
.
asUI¡
 & 
suµ‹ãd_öãºu±s


363 
vÆ
 
high_öãºu±s
 = 
io
.
öãºu±s
.
bu£º‹
.
	`m≠
(
_
 << 
CSR
.
busEº‹I¡Cau£
).
	`gëOrEl£
(0.U)

365 
vÆ
 
≥ndög_öãºu±s
 = 
high_öãºu±s
 | (
ªad_mù
 & 
ªg_mõ
)

366 
vÆ
 
d_öãºu±s
 = 
io
.
öãºu±s
.
debug
 << 
CSR
.
debugI¡Cau£


367 
vÆ
 
m_öãºu±s
 = 
	`Mux
(
ªg_m°©us
.
¥v
 <
PRV
.
S
 ||Ñeg_m°©us.
mõ
, ~(~
≥ndög_öãºu±s
 | 
ªg_midñeg
), 
	`UI¡
(0))

368 
vÆ
 
s_öãºu±s
 = 
	`Mux
(
ªg_m°©us
.
¥v
 < 
PRV
.
S
 || (ªg_m°©us.¥v ==PRV.S &&Ñeg_m°©us.
sõ
), 
≥ndög_öãºu±s
 & 
ªg_midñeg
, 
	`UI¡
(0))

369 
	`vÆ
 (
™yI¡îru±
, 
whichI¡îru±
Ë
	`choo£I¡îru±
(
	`Seq
(
s_öãºu±s
, 
m_öãºu±s
, 
d_öãºu±s
))

370 
vÆ
 
öãºu±MSB
 = 
	`BigI¡
(1Ë<< (
xLí
-1)

371 
vÆ
 
öãºu±Cau£
 = 
	`UI¡
(
öãºu±MSB
Ë+ 
whichI¡îru±


372 
io
.
öãºu±
 :(
™yI¡îru±
 && !io.
sögÀSãp
 || 
ªg_sögÀSãµed
Ë&& !
ªg_debug


373 
io
.
öãºu±_ˇu£
 :
öãºu±Cau£


374 
io
.
bp
 :
ªg_bp
 
èke
 
nBªakpoöts


375 
io
.
pmp
 :
ªg_pmp
.
	`m≠
(
	`PMP
(
_
))

377 
vÆ
 
ißMaskSåög
 =

378 (i‡(
usögMulDiv
) "M" "") +

379 (i‡(
usögAtomics
) "A" "") +

380 (i‡(
fLí
 >= 32) "F" "") +

381 (i‡(
fLí
 >= 64) "D" "") +

382 (i‡(
usögCom¥es£d
) "C" "") +

383 (i‡(
usögRoCC
) "X" "")

384 
vÆ
 
ißSåög
 = "I" + 
ißMaskSåög
 +

385 (i‡(
usögVM
) "S" "") +

386 (i‡(
usögU£r
) "U" "")

387 
vÆ
 
ißMax
 = (
	`BigI¡
(
	`log2Ceû
(
xLí
Ë- 4Ë<< (xLí-2)Ë| 
	`ißSåögToMask
(
ißSåög
)

388 
vÆ
 
ªg_miß
 = 
	`Reg
(
öô
=
	`UI¡
(
ißMax
))

389 
vÆ
 
ªad_m°©us
 = 
io
.
°©us
.
	`asUI¡
()(
xLí
-1,0)

391 
vÆ
 
ªad_m≠pög
 = 
LökedHashM≠
[
I¡
,
Bôs
](

392 
CSRs
.
t£À˘
 -> 
ªg_t£À˘
,

393 
CSRs
.
td©a1
 -> 
	`ªg_bp
(
ªg_t£À˘
).
c⁄åﬁ
.
asUI¡
,

394 
CSRs
.
td©a2
 -> 
	`ªg_bp
(
ªg_t£À˘
).
addªss
.
	`£xtTo
(
xLí
),

395 
CSRs
.
miß
 -> 
ªg_miß
,

396 
CSRs
.
m°©us
 -> 
ªad_m°©us
,

397 
CSRs
.
mtvec
 -> 
ªg_mtvec
,

398 
CSRs
.
mù
 -> 
ªad_mù
,

399 
CSRs
.
mõ
 -> 
ªg_mõ
,

400 
CSRs
.
ms¸©ch
 -> 
ªg_ms¸©ch
,

401 
CSRs
.
mïc
 -> 
	`ªadEPC
(
ªg_mïc
).
	`£xtTo
(
xLí
),

402 
CSRs
.
mbadaddr
 -> 
ªg_mbadaddr
.
	`£xtTo
(
xLí
),

403 
CSRs
.
mˇu£
 -> 
ªg_mˇu£
,

404 
CSRs
.
mh¨tid
 -> 
io
.
h¨tid
)

406 
vÆ
 
debug_c§s
 = 
LökedHashM≠
[
I¡
,
Bôs
](

407 
CSRs
.
dc§
 -> 
ªg_dc§
.
asUI¡
,

408 
CSRs
.
dpc
 -> 
	`ªadEPC
(
ªg_dpc
).
	`£xtTo
(
xLí
),

409 
CSRs
.
ds¸©ch
 -> 
ªg_ds¸©ch
.
asUI¡
)

411 
vÆ
 
Â_c§s
 = 
LökedHashM≠
[
I¡
,
Bôs
](

412 
CSRs
.
fÊags
 -> 
ªg_fÊags
,

413 
CSRs
.
‰m
 -> 
ªg_‰m
,

414 
CSRs
.
fc§
 -> 
	`C©
(
ªg_‰m
, 
ªg_fÊags
))

416 i‡(
usögDebug
)

417 
ªad_m≠pög
 ++
debug_c§s


419 i‡(
usögFPU
)

420 
ªad_m≠pög
 ++
Â_c§s


422 i‡(
c‹eP¨ams
.
haveBasicCou¡îs
) {

423 
ªad_m≠pög
 +
CSRs
.
mcy˛e
 -> 
ªg_cy˛e


424 
ªad_m≠pög
 +
CSRs
.
mö°ªt
 -> 
ªg_ö°ªt


426 ((
e
, 
c
), 
i
Ë<- (
ªg_hpmevít
.
	`∑dTo
(
CSR
.
nHPM
, 
	`UI¡
(0))

427 
zù
 
ªg_hpmcou¡î
.
	`m≠
(
x
 => x: 
UI¡
).
	`∑dTo
(
CSR
.
nHPM
, 
	`UI¡
(0))Ë
zùWôhIndex
) {

428 
ªad_m≠pög
 +(
i
 + 
CSR
.
fú°HPE
Ë-> 
e


429 
ªad_m≠pög
 +(
i
 + 
CSR
.
fú°MHPC
Ë-> 
c


430 i‡(
usögU£r
Ë
ªad_m≠pög
 +(
i
 + 
CSR
.
fú°HPC
Ë-> 
c


431 i‡(
xLí
 == 32) {

432 
ªad_m≠pög
 +(
i
 + 
CSR
.
fú°MHPCH
Ë-> 
c


433 i‡(
usögU£r
Ë
ªad_m≠pög
 +(
i
 + 
CSR
.
fú°HPCH
Ë-> 
c


437 i‡(
usögU£r
) {

438 
ªad_m≠pög
 +
CSRs
.
mcou¡îí
 -> 
ªg_mcou¡îí


439 
ªad_m≠pög
 +
CSRs
.
cy˛e
 -> 
ªg_cy˛e


440 
ªad_m≠pög
 +
CSRs
.
ö°ªt
 -> 
ªg_ö°ªt


443 i‡(
xLí
 == 32) {

444 
ªad_m≠pög
 +
CSRs
.
mcy˛eh
 -> (
ªg_cy˛e
 >> 32)

445 
ªad_m≠pög
 +
CSRs
.
mö°ªth
 -> (
ªg_ö°ªt
 >> 32)

446 i‡(
usögU£r
) {

447 
ªad_m≠pög
 +
CSRs
.
cy˛eh
 -> (
ªg_cy˛e
 >> 32)

448 
ªad_m≠pög
 +
CSRs
.
ö°ªth
 -> (
ªg_ö°ªt
 >> 32)

462 
vÆ
 
pcode_ªgs
 = 
	`Reg
(
öô
=
Vec
.
	`fûl
(
numPCodeR™ges
){
√w
 
	`PCodeCSR
().
	`‰omBôs
(0)})

463 
def
 
pcode_c§s
 = 
	`Seq
(

464 
CSRs
.
•codî™ge0


465 ,
CSRs
.
•codî™ge1


466 ,
CSRs
.
•codî™ge2


467 ,
CSRs
.
•codî™ge3


470 
vÆ
 
pcode_upd©e
 = 
	`Reg
(
	`VÆid
(
√w
 
PCodeUpd©e
))

471 
vÆ
 
pcode_upd©e_ª•
 = 
	`Wúe
(
	`VÆid
(
√w
 
PCodeUpd©e
))

473 
	`¥öén
(
s
"hasPrivCodeLock: ${hasPrivCodeLock}")

474 i‡(
hasPrivCodeLock
) {

476 
	`ªquúe
(
numPCodeR™ges
 <4 &&ÇumPCodeR™ge†<
pcode_c§s
.
Àngth
)

478 
pcode_upd©e_ª•
 :
io
.
pcode_ª•


479 
io
.
pcode_ªq
 :
pcode_upd©e


481 
	`whí
(
pcode_upd©e_ª•
.
vÆid
) {

482 
	`pcode_ªgs
(
pcode_upd©e_ª•
.
bôs
.
id
Ë:pcode_upd©e_ª•.bôs.
vÆue


486 
c§_id
 <- 
pcode_c§s
) {

487 
ªad_m≠pög
 +
c§_id
 -> (

489 
vÆ
 
r
 = 
	`pcode_ªgs
(
c§_id
 & 3)

490 
	`C©
(
r
.
ba£
,Ñ.
mask
,Ñ.
vÆid
,Ñ.
locked
)

501 i‡(
usögVM
) {

502 
vÆ
 
ªad_sõ
 = 
ªg_mõ
 & 
ªg_midñeg


503 
vÆ
 
ªad_sù
 = 
ªad_mù
 & 
ªg_midñeg


504 
vÆ
 
ªad_s°©us
 = 
	`Wúe
(
öô
 = 0.U.a
	`sTy≥Of
(
√w
 
MSètus
))

505 
ªad_s°©us
.
sd
 :
io
.
°©us
.sd

506 
ªad_s°©us
.
uxl
 :
io
.
°©us
.uxl

507 
ªad_s°©us
.
sd_rv32
 :
io
.
°©us
.sd_rv32

508 
ªad_s°©us
.
mxr
 :
io
.
°©us
.mxr

509 
ªad_s°©us
.
sum
 :
io
.
°©us
.sum

510 
ªad_s°©us
.
xs
 :
io
.
°©us
.xs

511 
ªad_s°©us
.
fs
 :
io
.
°©us
.fs

512 
ªad_s°©us
.
•p
 :
io
.
°©us
.spp

513 
ªad_s°©us
.
•õ
 :
io
.
°©us
.spie

514 
ªad_s°©us
.
sõ
 :
io
.
°©us
.sie

516 
ªad_m≠pög
 +
CSRs
.
s°©us
 -> (
ªad_s°©us
.
	`asUI¡
())(
xLí
-1,0)

517 
ªad_m≠pög
 +
CSRs
.
sù
 -> 
ªad_sù
.
asUI¡


518 
ªad_m≠pög
 +
CSRs
.
sõ
 -> 
ªad_sõ
.
asUI¡


519 
ªad_m≠pög
 +
CSRs
.
ss¸©ch
 -> 
ªg_ss¸©ch


520 
ªad_m≠pög
 +
CSRs
.
sˇu£
 -> 
ªg_sˇu£


521 
ªad_m≠pög
 +
CSRs
.
sbadaddr
 -> 
ªg_sbadaddr
.
	`£xtTo
(
xLí
)

522 
ªad_m≠pög
 +
CSRs
.
•tbr
 -> 
ªg_•tbr
.
asUI¡


523 
ªad_m≠pög
 +
CSRs
.
£pc
 -> 
	`ªadEPC
(
ªg_£pc
).
	`£xtTo
(
xLí
)

524 
ªad_m≠pög
 +
CSRs
.
°vec
 -> 
ªg_°vec
.
	`£xtTo
(
xLí
)

525 
ªad_m≠pög
 +
CSRs
.
scou¡îí
 -> 
ªg_scou¡îí


526 
ªad_m≠pög
 +
CSRs
.
midñeg
 -> 
ªg_midñeg


527 
ªad_m≠pög
 +
CSRs
.
medñeg
 -> 
ªg_medñeg


530 
vÆ
 
pmpCfgPîCSR
 = 
xLí
 / 
√w
 
	`PMPC⁄fig
().
gëWidth


531 
def
 
	`pmpCfgIndex
(
i
: 
I¡
Ë(
xLí
 / 32Ë* (ò/ 
pmpCfgPîCSR
)

532 i‡(
ªg_pmp
.
n⁄Em±y
) {

533 
	`ªquúe
(
ªg_pmp
.
size
 <
CSR
.
maxPMPs
)

534 
vÆ
 
ªad_pmp
 = 
ªg_pmp
.
	`∑dTo
(
CSR
.
maxPMPs
, 0.U.a
	`sTy≥Of
(
√w
 
PMP
))

535 
i
 <- 0 
u¡û
 
ªad_pmp
.
size
 
by
 
pmpCfgPîCSR
)

536 
ªad_m≠pög
 +(
CSRs
.
pmpcfg0
 + 
	`pmpCfgIndex
(
i
)Ë-> 
ªad_pmp
.
	`m≠
(
_
.
cfg
).
	`¶i˚
(i, i + 
pmpCfgPîCSR
).
asUI¡


537 (
pmp
, 
i
Ë<- 
ªad_pmp
 
zùWôhIndex
)

538 
ªad_m≠pög
 +(
CSRs
.
pm∑ddr0
 + 
i
Ë-> 
pmp
.
ªadAddr


542 
vÆ
 
ªg_cu°om
 = 
cu°omCSRs
.
m≠
 { 
c§
 =>

543 
	`ªquúe
(
c§
.
mask
 >0 && c§.mask.
bôLígth
 <
xLí
)

544 
	`ªquúe
(!
ªad_m≠pög
.
	`c⁄èös
(
c§
.
id
))

545 
vÆ
 
ªg
 = 
c§
.
öô
.
	`m≠
(öô => 
	`RegInô
(öô.
	`U
(
xLí
.
W
))).
	`gëOrEl£
(
	`Reg
(
	`UI¡
(xLen.W)))

546 
ªad_m≠pög
 +
c§
.
id
 -> 
ªg


547 
ªg


551 
	`Seq
(
CSRs
.
mimpid
, CSRs.
m¨chid
, CSRs.
mvíd‹id
).
	`f‹óch
(
id
 => 
ªad_m≠pög
.
	`gëOrEl£Upd©e
(id, 0.U))

553 
vÆ
 
decoded_addr
 = 
ªad_m≠pög
 
m≠
 { (
k
, 
v
Ë=> k -> (
io
.
rw
.
addr
 === k) }

554 
vÆ
 
wd©a
 = 
	`ªadModifyWrôeCSR
(
io
.
rw
.
cmd
, io.rw.
rd©a
, io.rw.wdata)

556 
vÆ
 
sy°em_ö¢
 = 
io
.
rw
.
cmd
 ==
CSR
.
I


557 
vÆ
 
decode_èbÀ
 = 
	`Seq
(

558 
SCALL
-> 
	`Li°
(
Y
,
N
,N,N,N),

559 
SBREAK
-> 
	`Li°
(
N
,
Y
,N,N,N),

560 
MRET
-> 
	`Li°
(
N
,N,
Y
,N,N),

561 
WFI
-> 
	`Li°
(
N
,N,N,
Y
,N)Ë++ (i‡(
usögDebug
Ë
	`Seq
(

562 
DRET
-> 
	`Li°
(
N
,N,
Y
,N,N)Ë
	`Seq
()Ë++ (i‡(
usögVM
) Seq(

563 
SRET
-> 
	`Li°
(
N
,N,
Y
,N,N),

564 
SFENCE_VMA
->
	`Li°
(
N
,N,N,N,
Y
)Ë
	`Seq
())

565 
vÆ
 
ö¢_ˇŒ
::
ö¢_bªak
::
ö¢_ªt
::
ö¢_wfi
::
ö¢_s„n˚
::
Nû
 = 
	`DecodeLogic
(
io
.
rw
.
addr
 << 20, 
	`decode_èbÀ
(0).
_2
.
	`m≠
(
x
=>
X
), 
decode_èbÀ
).m≠(
sy°em_ö¢
 && 
_
.
toBoﬁ
)

567 
io_dec
 <- 
io
.
decode
) {

568 
vÆ
 
is_ˇŒ
::
is_bªak
::
is_ªt
::
is_wfi
::
is_s„n˚
::
Nû
 = 
	`DecodeLogic
(
io_dec
.
c§
 << 20, 
	`decode_èbÀ
(0).
_2
.
	`m≠
(
x
=>
X
), 
decode_èbÀ
).m≠(
_
.
toBoﬁ
)

569 
def
 
	`decodeAny
(
m
: 
LökedHashM≠
[
I¡
,
Bôs
]): 
Boﬁ
 = m.
m≠
 { (
k
: I¡, 
_
: BôsË=> 
io_dec
.
c§
 ==k }.
	`ªdu˚
(_||_)

570 
vÆ
 
Ælow_wfi
 = 
	`Boﬁ
(!
usögVM
Ë|| 
ªg_m°©us
.
¥v
 > 
PRV
.
S
 || !ªg_m°©us.
tw


571 
vÆ
 
Ælow_s„n˚_vma
 = 
	`Boﬁ
(!
usögVM
Ë|| 
ªg_m°©us
.
¥v
 > 
PRV
.
S
 || !ªg_m°©us.
tvm


572 
vÆ
 
Ælow_§ë
 = 
	`Boﬁ
(!
usögVM
Ë|| 
ªg_m°©us
.
¥v
 > 
PRV
.
S
 || !ªg_m°©us.
t§


573 
vÆ
 
cou¡î_addr
 = 
io_dec
.
	`c§
(
	`log2Ceû
(
ªg_mcou¡îí
.
gëWidth
)-1, 0)

574 
vÆ
 
Ælow_cou¡î
 = (
ªg_m°©us
.
¥v
 > 
PRV
.
S
 || 
	`ªg_mcou¡îí
(
cou¡î_addr
)) &&

575 (!
usögVM
 || 
ªg_m°©us
.
¥v
 >
PRV
.
S
 || 
	`ªg_scou¡îí
(
cou¡î_addr
))

576 
io_dec
.
Â_ûÀgÆ
 :
io
.
°©us
.
fs
 ==0 || !
	`ªg_miß
('f'-'a')

577 
io_dec
.
Â_c§
 :
	`Boﬁ
(
usögFPU
Ë&& 
	`DecodeLogic
(io_dec.
c§
, 
Â_c§s
.
keys
.
toLi°
.
	`m≠
(
_
.
U
), (
ªad_m≠pög
 -- fp_csrs.keys.toList).keys.toList.map(_.U))

578 
io_dec
.
rocc_ûÀgÆ
 :
io
.
°©us
.
xs
 ==0 || !
	`ªg_miß
('x'-'a')

579 
io_dec
.
ªad_ûÀgÆ
 :
ªg_m°©us
.
¥v
 < io_dec.
	`c§
(9,8) ||

580 !
	`decodeAny
(
ªad_m≠pög
) ||

581 
io_dec
.
c§
 ==
CSRs
.
•tbr
 && !
Ælow_s„n˚_vma
 ||

582 (
io_dec
.
c§
.
	`öR™ge
(
CSR
.
fú°Cå
, CSR.fú°Cå + CSR.
nCå
Ë|| io_dec.c§.öR™ge(CSR.
fú°CåH
, CSR.fú°CåH + CSR.nCå)Ë&& !
Ælow_cou¡î
 ||

583 
	`Boﬁ
(
usögDebug
Ë&& 
	`decodeAny
(
debug_c§s
Ë&& !
ªg_debug
 ||

584 
io_dec
.
Â_c§
 && io_dec.
Â_ûÀgÆ


585 
io_dec
.
wrôe_ûÀgÆ
 :io_dec.
	`c§
(11,10).
™dR


586 
io_dec
.
wrôe_Êush
 :!(io_dec.
c§
 >
CSRs
.
ms¸©ch
 && io_dec.c§ <CSRs.
mbadaddr
 || io_dec.c§ >CSRs.
ss¸©ch
 && io_dec.c§ <CSRs.
sbadaddr
)

587 
io_dec
.
sy°em_ûÀgÆ
 :
ªg_m°©us
.
¥v
 < io_dec.
	`c§
(9,8) ||

588 
is_wfi
 && !
Ælow_wfi
 ||

589 
is_ªt
 && !
Ælow_§ë
 ||

590 
is_s„n˚
 && !
Ælow_s„n˚_vma


593 
vÆ
 
ˇu£
 =

594 
	`Mux
(
ö¢_ˇŒ
, 
ªg_m°©us
.
¥v
 + 
Cau£s
.
u£r_eˇŒ
,

595 
Mux
[
UI¡
](
ö¢_bªak
, 
Cau£s
.
bªakpoöt
, 
io
.
ˇu£
))

596 
vÆ
 
ˇu£_lsbs
 = 
	`ˇu£
(
io
.
åa˚
.
hód
.
ˇu£
.
gëWidth
-1, 0)

597 
vÆ
 
ˇu£IsDebugI¡
 = 
	`ˇu£
(
xLí
-1Ë&& 
ˇu£_lsbs
 ==
CSR
.
debugI¡Cau£


598 
vÆ
 
ˇu£IsDebugTriggî
 = !
	`ˇu£
(
xLí
-1Ë&& 
ˇu£_lsbs
 ==
CSR
.
debugTriggîCau£


599 
vÆ
 
ˇu£IsDebugBªak
 = !
	`ˇu£
(
xLí
-1Ë&& 
ö¢_bªak
 && 
	`C©
(
ªg_dc§
.
ebªakm
,Ñeg_dc§.
ebªakh
,Ñeg_dc§.
ebªaks
,Ñeg_dc§.
ebªaku
)(
ªg_m°©us
.
¥v
)

600 
vÆ
 
å≠ToDebug
 = 
	`Boﬁ
(
usögDebug
Ë&& (
ªg_sögÀSãµed
 || 
ˇu£IsDebugI¡
 || 
ˇu£IsDebugTriggî
 || 
ˇu£IsDebugBªak
 || 
ªg_debug
)

601 
vÆ
 
debugTVec
 = 
	`Mux
(
ªg_debug
, Mux(
ö¢_bªak
, 
	`UI¡
(0x800), UInt(0x808)), UInt(0x800))

602 
vÆ
 
dñeg©e
 = 
	`Boﬁ
(
usögVM
Ë&& 
ªg_m°©us
.
¥v
 <
PRV
.
S
 && 
	`Mux
(
	`ˇu£
(
xLí
-1), 
	`ªg_midñeg
(
ˇu£_lsbs
), 
	`ªg_medñeg
(cause_lsbs))

603 
vÆ
 
mtvecBa£Align
 = 2

604 
vÆ
 
mtvecI¡îru±Align
 = {

605 
	`ªquúe
(
ªg_mù
.
gëWidth
 <
xLí
)

606 
	`log2Ceû
(
xLí
)

608 
vÆ
 
nŸDebugTVec
 = {

609 
vÆ
 
ba£
 = 
	`Mux
(
dñeg©e
, 
ªg_°vec
.
	`£xtTo
(
vaddrBôsExãnded
), 
ªg_mtvec
)

610 
vÆ
 
öãºu±Off£t
 = 
	`ˇu£
(
mtvecI¡îru±Align
-1, 0Ë<< 
mtvecBa£Align


611 
vÆ
 
öãºu±Vec
 = 
	`C©
(
ba£
 >> (
mtvecI¡îru±Align
 + 
mtvecBa£Align
), 
öãºu±Off£t
)

612 
vÆ
 
doVe˘‹
 = 
	`ba£
(0Ë&& 
	`ˇu£
(
ˇu£
.
gëWidth
-1Ë&& (
ˇu£_lsbs
 >> 
mtvecI¡îru±Align
) === 0

613 
	`Mux
(
doVe˘‹
, 
öãºu±Vec
, 
ba£
)

615 
vÆ
 
tvec
 = 
	`Mux
(
å≠ToDebug
, 
debugTVec
, 
nŸDebugTVec
)

616 
io
.
evec
 :
tvec


617 
io
.
±br
 :
ªg_•tbr


618 
io
.
îë
 :
ö¢_ˇŒ
 || 
ö¢_bªak
 || 
ö¢_ªt


619 
io
.
sögÀSãp
 :
ªg_dc§
.
°ï
 && !
ªg_debug


620 
io
.
°©us
 :
ªg_m°©us


621 
io
.
°©us
.
sd
 :io.°©us.
fs
.
™dR
 || io.°©us.
xs
.andR

622 
io
.
°©us
.
debug
 :
ªg_debug


623 
io
.
°©us
.
iß
 :
ªg_miß


624 
io
.
°©us
.
uxl
 :(i‡(
usögU£r
Ë
	`log2Ceû
(
xLí
) - 4 0)

625 
io
.
°©us
.
sxl
 :(i‡(
usögVM
Ë
	`log2Ceû
(
xLí
) - 4 0)

626 
io
.
°©us
.
d¥v
 :
	`Reg
(
√xt
 = 
	`Mux
(
ªg_m°©us
.
m¥v
 && !
ªg_debug
,Ñeg_m°©us.
mµ
,Ñeg_m°©us.
¥v
))

627 i‡(
xLí
 == 32)

628 
io
.
°©us
.
sd_rv32
 :io.°©us.
sd


630 
vÆ
 
ex˚±i⁄
 = 
ö¢_ˇŒ
 || 
ö¢_bªak
 || 
io
.exception

631 
	`as£π
(
	`P›Cou¡
(
ö¢_ªt
 :: 
ö¢_ˇŒ
 :: 
ö¢_bªak
 :: 
io
.
ex˚±i⁄
 :: 
Nû
) <= 1, "these conditions must be mutuallyÉxclusive")

633 
	`whí
 (
ö¢_wfi
 && !
io
.
sögÀSãp
 && !
ªg_debug
Ë{ 
ªg_wfi
 :
åue
 }

634 
	`whí
 (
≥ndög_öãºu±s
.
‹R
 || 
io
.
öãºu±s
.
debug
 || 
ex˚±i⁄
Ë{ 
ªg_wfi
 :
Ál£
 }

636 
	`whí
 (
io
.
	`ªtúe
(0Ë|| 
ex˚±i⁄
Ë{ 
ªg_sögÀSãµed
 :
åue
 }

637 
	`whí
 (!
io
.
sögÀSãp
Ë{ 
ªg_sögÀSãµed
 :
Ál£
 }

638 
	`as£π
(!
io
.
sögÀSãp
 || io.
ªtúe
 <
	`UI¡
(1))

639 
	`as£π
(!
ªg_sögÀSãµed
 || 
io
.
ªtúe
 ==
	`UI¡
(0))

641 
vÆ
 
ïc
 = 
	`f‹mEPC
(
io
.
pc
)

642 
vÆ
 
noCau£
 :: 
mCau£
 :: 
hCau£
 :: 
sCau£
 :: 
uCau£
 :: 
Nû
 = 
	`Enum
(5)

643 
vÆ
 
xˇu£_de°
 = 
	`Wúe
(
öô
 = 
noCau£
)

645 
	`whí
 (
ex˚±i⁄
) {

646 
	`whí
 (
å≠ToDebug
) {

647 
	`whí
 (!
ªg_debug
) {

648 
ªg_debug
 :
åue


649 
ªg_dpc
 :
ïc


650 
ªg_dc§
.
ˇu£
 :
	`Mux
(
ªg_sögÀSãµed
, 4, Mux(
ˇu£IsDebugI¡
, 3, 
Mux
[
UI¡
](
ˇu£IsDebugTriggî
, 2, 1)))

651 
ªg_dc§
.
¥v
 :
	`åimPrivûege
(
ªg_m°©us
.prv)

652 
√w_¥v
 :
PRV
.
M


654 }.
	`ñ£whí
 (
dñeg©e
) {

655 
ªg_£pc
 :
ïc


656 
ªg_sˇu£
 :
ˇu£


657 
xˇu£_de°
 :
sCau£


658 
ªg_sbadaddr
 :
io
.
tvÆ


659 
ªg_m°©us
.
•õ
 :ªg_m°©us.
sõ


660 
ªg_m°©us
.
•p
 :ªg_m°©us.
¥v


661 
ªg_m°©us
.
sõ
 :
Ál£


662 
√w_¥v
 :
PRV
.
S


663 }.
Ÿhîwi£
 {

664 
ªg_mïc
 :
ïc


665 
ªg_mˇu£
 :
ˇu£


666 
xˇu£_de°
 :
mCau£


667 
ªg_mbadaddr
 :
io
.
tvÆ


668 
ªg_m°©us
.
mpõ
 :ªg_m°©us.
mõ


669 
ªg_m°©us
.
mµ
 :
	`åimPrivûege
‘eg_m°©us.
¥v
)

670 
ªg_m°©us
.
mõ
 :
Ál£


671 
√w_¥v
 :
PRV
.
M


675 
i
 <- 0 
u¡û
 
suµ‹ãd_öãºu±s
.
gëWidth
) {

676 
vÆ
 
í
 = 
ex˚±i⁄
 && (
suµ‹ãd_öãºu±s
 & (
	`BigI¡
(1Ë<< 
i
).
U
Ë=/0 && 
ˇu£
 ==(BigI¡(1Ë<< (
xLí
 - 1)).U + i

677 
vÆ
 
dñegabÀ
 = (
dñegabÀ_öãºu±s
 & (
	`BigI¡
(1Ë<< 
i
).
U
) =/= 0

678 
	`covî
(
í
, 
s
"INTERRUPT_M_$i")

679 
	`covî
(
í
 && 
dñegabÀ
 && 
dñeg©e
, 
s
"INTERRUPT_S_$i")

681 
i
 <- 0 
u¡û
 
xLí
) {

682 
vÆ
 
suµ‹ãd_ex˚±i⁄s
 = 0x87e |

683 (i‡(
usögCom¥es£d
 && !
c‹eP¨ams
.
mißWrôabÀ
) 0 1) |

684 (i‡(
usögU£r
) 0x100 0) |

685 (i‡(
usögVM
) 0xb200 0)

686 i‡(((
suµ‹ãd_ex˚±i⁄s
 >> 
i
) & 1) != 0) {

687 
vÆ
 
í
 = 
ex˚±i⁄
 && 
ˇu£
 ==
i


688 
	`covî
(
í
, 
s
"EXCEPTION_M_$i")

689 
	`covî
(
í
 && 
dñeg©e
, 
s
"EXCEPTION_S_$i")

693 
	`whí
 (
ö¢_ªt
) {

694 
	`whí
 (
	`Boﬁ
(
usögVM
Ë&& !
io
.
rw
.
	`addr
(9)) {

695 
ªg_m°©us
.
sõ
 :ªg_m°©us.
•õ


696 
ªg_m°©us
.
•õ
 :
åue


697 
ªg_m°©us
.
•p
 :
PRV
.
U


698 
√w_¥v
 :
ªg_m°©us
.
•p


699 
io
.
evec
 :
	`ªadEPC
(
ªg_£pc
)

700 }.
	`ñ£whí
 (
	`Boﬁ
(
usögDebug
Ë&& 
io
.
rw
.
	`addr
(10)) {

701 
√w_¥v
 :
ªg_dc§
.
¥v


702 
ªg_debug
 :
Ál£


703 
io
.
evec
 :
	`ªadEPC
(
ªg_dpc
)

704 }.
Ÿhîwi£
 {

705 
ªg_m°©us
.
mõ
 :ªg_m°©us.
mpõ


706 
ªg_m°©us
.
mpõ
 :
åue


707 
ªg_m°©us
.
mµ
 :
	`ÀgÆizePrivûege
(
PRV
.
U
)

708 
√w_¥v
 :
ªg_m°©us
.
mµ


709 
io
.
evec
 :
	`ªadEPC
(
ªg_mïc
)

713 
io
.
time
 :
ªg_cy˛e


714 
io
.
c§_°Æl
 :
ªg_wfi


716 (
io
, 
ªg
Ë<- io.
cu°omCSRs
 
zù
 
ªg_cu°om
) {

717 
io
.
wí
 :
Ál£


718 
io
.
wd©a
 := wdata

719 
io
.
vÆue
 :
ªg


722 
io
.
rw
.
rd©a
 :
	`Mux1H
((
k
, 
v
Ë<- 
ªad_m≠pög
Ë
yõld
 
	`decoded_addr
(k) -> v)

725 
ªad_m≠pög
.
	`f‹óch
–{(
k
, 
v
) => {

726 
	`covî
(
io
.
rw
.
cmd
.
	`isO√Of
(
CSR
.
W
, CSR.
S
, CSR.
C
, CSR.
R
Ë&& io.rw.
addr
===
k
, "CSR_ac˚ss_"+k.
toSåög
, "Cover Accessing Core CSR field")

729 
vÆ
 
£t_fs_dúty
 = 
	`Wúe
(
öô
 = 
io
.£t_fs_dúty.
	`gëOrEl£
(
Ál£
.
B
))

730 i‡(
c‹eP¨ams
.
haveFSDúty
) {

731 
	`whí
 (
£t_fs_dúty
) {

732 
	`as£π
(
ªg_m°©us
.
fs
 > 0)

733 
ªg_m°©us
.
fs
 := 3

737 
io
.
fc§_rm
 :
ªg_‰m


738 
	`whí
 (
io
.
fc§_Êags
.
vÆid
) {

739 
ªg_fÊags
 :ªg_fÊag†| 
io
.
fc§_Êags
.
bôs


740 
£t_fs_dúty
 :
åue


743 
vÆ
 
c§_wí
 = 
io
.
rw
.
cmd
.
	`isO√Of
(
CSR
.
S
, CSR.
C
, CSR.
W
)

744 
io
.
c§w_cou¡î
 :
	`Mux
(
c‹eP¨ams
.
haveBasicCou¡îs
 && 
c§_wí
 && (io.
rw
.
addr
.
	`öR™ge
(
CSRs
.
mcy˛e
, CSRs.mcy˛ê+ 
CSR
.
nCå
Ë|| io.rw.addr.öR™ge(CSRs.
mcy˛eh
, CSRs.mcy˛eh + CSR.nCå)), 
	`UI¡ToOH
(io.rw.
	`addr
(
	`log2Ceû
(CSR.nCå+
nPîfCou¡îs
)-1, 0)), 0.U)

746 if(
hasPrivCodeLock
) {

747 
pcode_upd©e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

756 
	`whí
 (
c§_wí
) {

757 if(
hasPrivCodeLock
) {

758 
pcode_c§
 <- 
pcode_c§s
) {

760 
	`whí
 (
	`decoded_addr
(
pcode_c§
)) {

761 
vÆ
 
id
 = 
pcode_c§
 & 
	`UI¡
(3, 
width
=2)

762 
vÆ
 
lock
 = 
	`pcode_ªgs
(
id
).
locked


764 
	`whí
(
lock
 ==
	`UI¡
(0)) {

765 
pcode_upd©e
.
vÆid
 :
	`Boﬁ
(
åue
)

766 
pcode_upd©e
.
bôs
.
id
 := id

767 
pcode_upd©e
.
bôs
.
vÆue
.
ba£
 :
	`wd©a
(
∑ddrBôs
-1, 12)

768 
pcode_upd©e
.
bôs
.
vÆue
.
mask
 :
	`wd©a
(11,2)

769 
pcode_upd©e
.
bôs
.
vÆue
.
vÆid
 :
	`wd©a
(1)

770 
pcode_upd©e
.
bôs
.
vÆue
.
locked
 :
	`wd©a
(0)

774 
	`pcode_ªgs
(
id
).
locked
 :
	`wd©a
(0)

779 
	`whí
 (
	`decoded_addr
(
CSRs
.
m°©us
)) {

780 
vÆ
 
√w_m°©us
 = 
√w
 
	`MSètus
().
	`‰omBôs
(
wd©a
)

781 
ªg_m°©us
.
mõ
 :
√w_m°©us
.mie

782 
ªg_m°©us
.
mpõ
 :
√w_m°©us
.mpie

784 i‡(
usögU£r
) {

785 
ªg_m°©us
.
m¥v
 :
√w_m°©us
.mprv

786 
ªg_m°©us
.
mµ
 :
	`ÀgÆizePrivûege
(
√w_m°©us
.mpp)

787 i‡(
usögVM
) {

788 
ªg_m°©us
.
mxr
 :
√w_m°©us
.mxr

789 
ªg_m°©us
.
sum
 :
√w_m°©us
.sum

790 
ªg_m°©us
.
•p
 :
√w_m°©us
.spp

791 
ªg_m°©us
.
•õ
 :
√w_m°©us
.spie

792 
ªg_m°©us
.
sõ
 :
√w_m°©us
.sie

793 
ªg_m°©us
.
tw
 :
√w_m°©us
.tw

794 
ªg_m°©us
.
tvm
 :
√w_m°©us
.tvm

795 
ªg_m°©us
.
t§
 :
√w_m°©us
.tsr

799 i‡(
usögVM
 || 
usögFPU
Ë
ªg_m°©us
.
fs
 :
	`f‹mFS
(
√w_m°©us
.fs)

800 i‡(
usögRoCC
Ë
ªg_m°©us
.
xs
 :
	`Fûl
(2, 
√w_m°©us
.xs.
‹R
)

802 
	`whí
 (
	`decoded_addr
(
CSRs
.
miß
)) {

803 
vÆ
 
mask
 = 
	`UI¡
(
	`ißSåögToMask
(
ißMaskSåög
), 
xLí
)

804 
vÆ
 
f
 = 
	`wd©a
('f' - 'a')

806 
	`whí
 (!
usögCom¥es£d
 || !
io
.
	`pc
(1Ë|| 
	`wd©a
('c' - 'a')) {

807 i‡(
c‹eP¨ams
.
mißWrôabÀ
)

808 
ªg_miß
 :~(~
wd©a
 | (!
f
 << ('d' - 'a'))Ë& 
mask
 |Ñeg_misa & ~mask

811 
	`whí
 (
	`decoded_addr
(
CSRs
.
mù
)) {

816 
vÆ
 
√w_mù
 = 
	`ªadModifyWrôeCSR
(
io
.
rw
.
cmd
, 
ªg_mù
.
asUI¡
, io.rw.
wd©a
).
	`asTy≥Of
(
√w
 
MIP
)

817 i‡(
usögVM
) {

818 
ªg_mù
.
ssù
 :
√w_mù
.ssip

819 
ªg_mù
.
°ù
 :
√w_mù
.stip

820 
ªg_mù
.
£ù
 :
√w_mù
.seip

823 
	`whí
 (
	`decoded_addr
(
CSRs
.
mõ
)Ë{ 
ªg_mõ
 :
wd©a
 & 
suµ‹ãd_öãºu±s
 }

824 
	`whí
 (
	`decoded_addr
(
CSRs
.
mïc
)Ë{ 
ªg_mïc
 :
	`f‹mEPC
(
wd©a
) }

825 
	`whí
 (
	`decoded_addr
(
CSRs
.
ms¸©ch
)Ë{ 
ªg_ms¸©ch
 :
wd©a
 }

826 i‡(
mtvecWrôabÀ
)

827 
	`whí
 (
	`decoded_addr
(
CSRs
.
mtvec
)Ë{ 
ªg_mtvec
 :~(~
wd©a
 | 2.U | 
	`Mux
(
	`wd©a
(0), 
	`UI¡
(((
	`BigI¡
(1Ë<< 
mtvecI¡îru±Align
Ë- 1Ë<< 
mtvecBa£Align
), 0.U)) }

828 
	`whí
 (
	`decoded_addr
(
CSRs
.
mˇu£
)Ë{ 
ªg_mˇu£
 :
wd©a
 & 
	`UI¡
((
	`BigI¡
(1Ë<< (
xLí
-1)Ë+ (BigI¡(1Ë<< 
whichI¡îru±
.
gëWidth
) - 1) }

829 
	`whí
 (
	`decoded_addr
(
CSRs
.
mbadaddr
)Ë{ 
ªg_mbadaddr
 :
	`wd©a
(
vaddrBôsExãnded
-1,0) }

831 ((
e
, 
c
), 
i
Ë<- (
ªg_hpmevít
 
zù
 
ªg_hpmcou¡î
Ë
zùWôhIndex
) {

832 
	`wrôeCou¡î
(
i
 + 
CSR
.
fú°MHPC
, 
c
, 
wd©a
)

833 
	`whí
 (
	`decoded_addr
(
i
 + 
CSR
.
fú°HPE
)Ë{ 
e
 :
≥rfEvítSës
.
	`maskEvítSñe˘‹
(
wd©a
) }

835 i‡(
c‹eP¨ams
.
haveBasicCou¡îs
) {

836 
	`wrôeCou¡î
(
CSRs
.
mcy˛e
, 
ªg_cy˛e
, 
wd©a
)

837 
	`wrôeCou¡î
(
CSRs
.
mö°ªt
, 
ªg_ö°ªt
, 
wd©a
)

840 i‡(
usögFPU
) {

841 
	`whí
 (
	`decoded_addr
(
CSRs
.
fÊags
)Ë{ 
£t_fs_dúty
 :
åue
; 
ªg_fÊags
 :
wd©a
 }

842 
	`whí
 (
	`decoded_addr
(
CSRs
.
‰m
)Ë{ 
£t_fs_dúty
 :
åue
; 
ªg_‰m
 :
wd©a
 }

843 
	`whí
 (
	`decoded_addr
(
CSRs
.
fc§
)Ë{ 
£t_fs_dúty
 :
åue
; 
ªg_fÊags
 :
wd©a
; 
ªg_‰m
 :wd©®>>Ñeg_fÊags.
gëWidth
 }

845 i‡(
usögDebug
) {

846 
	`whí
 (
	`decoded_addr
(
CSRs
.
dc§
)) {

847 
vÆ
 
√w_dc§
 = 
√w
 
	`DCSR
().
	`‰omBôs
(
wd©a
)

848 
ªg_dc§
.
°ï
 :
√w_dc§
.step

849 
ªg_dc§
.
ebªakm
 :
√w_dc§
.ebreakm

850 i‡(
usögVM
Ë
ªg_dc§
.
ebªaks
 :
√w_dc§
.ebreaks

851 i‡(
usögU£r
Ë
ªg_dc§
.
ebªaku
 :
√w_dc§
.ebreaku

852 i‡(
usögU£r
Ë
ªg_dc§
.
¥v
 :
	`ÀgÆizePrivûege
(
√w_dc§
.prv)

854 
	`whí
 (
	`decoded_addr
(
CSRs
.
dpc
)Ë{ 
ªg_dpc
 :
	`f‹mEPC
(
wd©a
) }

855 
	`whí
 (
	`decoded_addr
(
CSRs
.
ds¸©ch
)Ë{ 
ªg_ds¸©ch
 :
wd©a
 }

857 i‡(
usögVM
) {

858 
	`whí
 (
	`decoded_addr
(
CSRs
.
s°©us
)) {

859 
vÆ
 
√w_s°©us
 = 
√w
 
	`MSètus
().
	`‰omBôs
(
wd©a
)

860 
ªg_m°©us
.
sõ
 :
√w_s°©us
.sie

861 
ªg_m°©us
.
•õ
 :
√w_s°©us
.spie

862 
ªg_m°©us
.
•p
 :
√w_s°©us
.spp

863 
ªg_m°©us
.
mxr
 :
√w_s°©us
.mxr

864 
ªg_m°©us
.
sum
 :
√w_s°©us
.sum

865 
ªg_m°©us
.
fs
 :
	`f‹mFS
(
√w_s°©us
.fs)

866 i‡(
usögRoCC
Ë
ªg_m°©us
.
xs
 :
	`Fûl
(2, 
√w_s°©us
.xs.
‹R
)

868 
	`whí
 (
	`decoded_addr
(
CSRs
.
sù
)) {

869 
vÆ
 
√w_sù
 = 
√w
 
	`MIP
().
	`‰omBôs
((
ªad_mù
 & ~
ªg_midñeg
Ë| (
wd©a
 &Ñeg_mideleg))

870 
ªg_mù
.
ssù
 :
√w_sù
.ssip

872 
	`whí
 (
	`decoded_addr
(
CSRs
.
•tbr
)) {

873 
vÆ
 
√w_•tbr
 = 
√w
 
	`PTBR
().
	`‰omBôs
(
wd©a
)

874 
vÆ
 
vÆid_mode
 = 
√w_•tbr
.
	`pgLevñsToMode
(
pgLevñs
)

875 
	`whí
 (
√w_•tbr
.
mode
 ==0Ë{ 
ªg_•tbr
.mode := 0 }

876 
	`whí
 (
√w_•tbr
.
mode
 ==
vÆid_mode
Ë{ 
ªg_•tbr
.mode := valid_mode }

877 
	`whí
 (
√w_•tbr
.
mode
 ==0 ||Çew_•tbr.modê==
vÆid_mode
) {

878 
ªg_•tbr
.
µn
 :
√w_•tbr
.
	`µn
(
µnBôs
-1,0)

879 i‡(
asIdBôs
 > 0Ë
ªg_•tbr
.
asid
 :
√w_•tbr
.
	`asid
(asIdBits-1,0)

882 
	`whí
 (
	`decoded_addr
(
CSRs
.
sõ
)Ë{ 
ªg_mõ
 :‘eg_mõ & ~
ªg_midñeg
Ë| (
wd©a
 &Ñeg_mideleg) }

883 
	`whí
 (
	`decoded_addr
(
CSRs
.
ss¸©ch
)Ë{ 
ªg_ss¸©ch
 :
wd©a
 }

884 
	`whí
 (
	`decoded_addr
(
CSRs
.
£pc
)Ë{ 
ªg_£pc
 :
	`f‹mEPC
(
wd©a
) }

885 
	`whí
 (
	`decoded_addr
(
CSRs
.
°vec
)Ë{ 
ªg_°vec
 :~(~
wd©a
 | 2.U | 
	`Mux
(
	`wd©a
(0), 
	`UI¡
(((
	`BigI¡
(1Ë<< 
mtvecI¡îru±Align
Ë- 1Ë<< 
mtvecBa£Align
), 0.U)) }

886 
	`whí
 (
	`decoded_addr
(
CSRs
.
sˇu£
)Ë{ 
ªg_sˇu£
 :
wd©a
 & 
	`UI¡
((
	`BigI¡
(1Ë<< (
xLí
-1)) + 31) }

887 
	`whí
 (
	`decoded_addr
(
CSRs
.
sbadaddr
)Ë{ 
ªg_sbadaddr
 :
	`wd©a
(
vaddrBôsExãnded
-1,0) }

888 
	`whí
 (
	`decoded_addr
(
CSRs
.
midñeg
)Ë{ 
ªg_midñeg
 :
wd©a
 & 
dñegabÀ_öãºu±s
 }

889 
	`whí
 (
	`decoded_addr
(
CSRs
.
medñeg
)Ë{ 
ªg_medñeg
 :
wd©a
 & 
dñegabÀ_ex˚±i⁄s
 }

890 
	`whí
 (
	`decoded_addr
(
CSRs
.
scou¡îí
)Ë{ 
ªg_scou¡îí
 :
wd©a
 & 
	`UI¡
(
dñegabÀ_cou¡îs
) }

892 i‡(
usögU£r
) {

893 
	`whí
 (
	`decoded_addr
(
CSRs
.
mcou¡îí
)Ë{ 
ªg_mcou¡îí
 :
wd©a
 & 
	`UI¡
(
dñegabÀ_cou¡îs
) }

895 i‡(
nBªakpoöts
 > 0) {

896 
	`whí
 (
	`decoded_addr
(
CSRs
.
t£À˘
)Ë{ 
ªg_t£À˘
 :
wd©a
 }

898 
vÆ
 
bp
 = 
	`ªg_bp
(
ªg_t£À˘
)

899 
	`whí
 (!
bp
.
c⁄åﬁ
.
dmode
 || 
ªg_debug
) {

900 
	`whí
 (
	`decoded_addr
(
CSRs
.
td©a1
)) {

901 
vÆ
 
√wBPC
 = 
√w
 
	`BPC⁄åﬁ
().
	`‰omBôs
(
wd©a
)

902 
vÆ
 
dMode
 = 
√wBPC
.
dmode
 && 
ªg_debug


903 
bp
.
c⁄åﬁ
 :
√wBPC


904 
bp
.
c⁄åﬁ
.
dmode
 :
dMode


905 
bp
.
c⁄åﬁ
.
a˘i⁄
 :
dMode
 && 
√wBPC
.action

907 
	`whí
 (
	`decoded_addr
(
CSRs
.
td©a2
)Ë{ 
bp
.
addªss
 :
wd©a
 }

910 i‡(
ªg_pmp
.
n⁄Em±y
Ë((
pmp
, 
√xt
), 
i
Ë<- (ªg_pm∞
	`zù
 (ªg_pmp.
èû
 :+Ñeg_pmp.
œ°
)Ë
zùWôhIndex
) {

911 
	`ªquúe
(
xLí
 % 
pmp
.
cfg
.
gëWidth
 == 0)

912 
	`whí
 (
	`decoded_addr
(
CSRs
.
pmpcfg0
 + 
	`pmpCfgIndex
(
i
)Ë&& !
pmp
.
cfgLocked
) {

913 
vÆ
 
√wCfg
 = 
√w
 
	`PMPC⁄fig
().
	`‰omBôs
(
wd©a
 >> ((
i
 * 
pmp
.
cfg
.
gëWidth
Ë% 
xLí
))

914 
pmp
.
cfg
 :
√wCfg


916 i‡(
pmpGønuœrôy
.
log2
 > 
PMP
.
lgAlign
)

917 
pmp
.
cfg
.
a
 :
	`C©
(
√wCfg
.
	`a
(1),ÇewCfg.a.
‹R
)

919 
	`whí
 (
	`decoded_addr
(
CSRs
.
pm∑ddr0
 + 
i
Ë&& !
pmp
.
	`addrLocked
(
√xt
)) {

920 
pmp
.
addr
 :
wd©a


923 (
io
, 
c§
, 
ªg
Ë<- (io.
cu°omCSRs
, cu°omCSRs, 
ªg_cu°om
).
zù≥d
) {

924 
vÆ
 
mask
 = 
c§
.mask.
	`U
(
xLí
.
W
)

925 
	`whí
 (
	`decoded_addr
(
c§
.
id
)) {

926 
ªg
 :(
wd©a
 & 
mask
) | (reg & ~mask)

927 
io
.
wí
 :
åue


932 i‡(!
usögVM
) {

933 
ªg_midñeg
 := 0

934 
ªg_medñeg
 := 0

935 
ªg_scou¡îí
 := 0

938 i‡(!
usögU£r
) {

939 
ªg_mcou¡îí
 := 0

942 
ªg_•tbr
.
asid
 := 0

943 i‡(
nBªakpoöts
 <1Ë
ªg_t£À˘
 := 0

944 i‡(
nBªakpoöts
 >= 1)

945 
	`ªg_bp
(
nBªakpoöts
-1).
c⁄åﬁ
.
chaö
 :
Ál£


946 
bpc
 <- 
ªg_bp
 
m≠
 {
_
.
c⁄åﬁ
}) {

947 
bpc
.
ây≥
 :bpc.
tTy≥


948 
bpc
.
maskmax
 :bpc.
maskMax


949 
bpc
.
ª£rved
 := 0

950 
bpc
.
zîo
 := 0

951 
bpc
.
h
 :
Ál£


952 i‡(!
usögVM
Ë
bpc
.
s
 :
Ál£


953 i‡(!
usögU£r
Ë
bpc
.
u
 :
Ál£


954 i‡(!
usögVM
 && !
usögU£r
Ë
bpc
.
m
 :
åue


955 
	`whí
 (
ª£t
) {

956 
bpc
.
a˘i⁄
 :
Ál£


957 
bpc
.
dmode
 :
Ál£


958 
bpc
.
r
 :
Ál£


959 
bpc
.
w
 :
Ál£


960 
bpc
.
x
 :
Ál£


963 
bp
 <- 
ªg_bp
 
dr›
 
nBªakpoöts
)

964 
bp
 :
√w
 
	`BP
().
	`‰omBôs
(0)

965 
pmp
 <- 
ªg_pmp
) {

966 
pmp
.
cfg
.
ªs
 := 0

967 
	`whí
 (
ª£t
) {

968 
pmp
.
cfg
.
a
 := 0

969 
pmp
.
cfg
.
l
 := 0

973 ((
t
, 
ö¢
), 
i
Ë<- (
io
.
åa˚
 
zù
 io.
ö°
).
zùWôhIndex
) {

974 
t
.
ex˚±i⁄
 :
io
.
ªtúe
 >
i
 &&Éxception

975 
t
.
vÆid
 :
io
.
ªtúe
 > 
i
 ||Å.
ex˚±i⁄


976 
t
.
ö¢
 := insn

977 
t
.
üddr
 :
io
.
pc


978 
t
.
¥iv
 :
	`C©
(
ªg_debug
, 
ªg_m°©us
.
¥v
)

979 
t
.
ˇu£
 := cause

980 
t
.
öãºu±
 :
	`ˇu£
(
xLí
-1)

981 
t
.
tvÆ
 :
io
.tval

984 
def
 
	`choo£I¡îru±
(
masksIn
: 
Seq
[
UI¡
]): (
Boﬁ
, UInt) = {

985 
vÆ
 
n⁄°™d¨d
 = 
suµ‹ãd_öãºu±s
.
gëWidth
-1 
to
 12 
by
 -1

987 
vÆ
 
°™d¨d
 = 
	`Seq
(11, 3, 7, 9, 1, 5, 8, 0, 4)

988 
vÆ
 
¥i‹ôy
 = 
n⁄°™d¨d
 ++ 
°™d¨d


989 
vÆ
 
masks
 = 
masksIn
.
ªvî£


990 
vÆ
 
™y
 = 
masks
.
	`Ê©M≠
(
m
 => 
¥i‹ôy
.
	`fûãr
(
_
 < m.
gëWidth
).
	`m≠
(
i
 => 
	`m
(i))).
	`ªdu˚
(_||_)

991 
vÆ
 
which
 = 
	`Pri‹ôyMux
(
masks
.
	`Ê©M≠
(
m
 => 
¥i‹ôy
.
	`fûãr
(
_
 < m.
gëWidth
).
	`m≠
(
i
 => (
	`m
(i), i.
U
))))

992 (
™y
, 
which
)

995 
def
 
	`ªadModifyWrôeCSR
(
cmd
: 
UI¡
, 
rd©a
: UI¡, 
wd©a
: UInt) = {

996 (
	`Mux
(
	`cmd
(1), 
rd©a
, 
	`UI¡
(0)Ë| 
wd©a
Ë& ~Mux(cmd(1,0).
™dR
, wdata, UInt(0))

999 
def
 
	`ÀgÆizePrivûege
(
¥iv
: 
UI¡
): UInt =

1000 i‡(
usögVM
Ë
	`Mux
(
¥iv
 ==
PRV
.
H
, PRV.
U
,Öriv)

1001 i‡(
usögU£r
Ë
	`Fûl
(2, 
	`¥iv
(0))

1002 
PRV
.
M


1004 
def
 
	`åimPrivûege
(
¥iv
: 
UI¡
): UInt =

1005 i‡(
usögVM
Ë
¥iv


1006 
	`ÀgÆizePrivûege
(
¥iv
)

1008 
def
 
	`wrôeCou¡î
(
lo
: 
I¡
, 
˘r
: 
WideCou¡î
, 
wd©a
: 
UI¡
) = {

1009 i‡(
xLí
 == 32) {

1010 
vÆ
 
hi
 = 
lo
 + 
CSRs
.
mcy˛eh
 - CSRs.
mcy˛e


1011 
	`whí
 (
	`decoded_addr
(
lo
)Ë{ 
˘r
 :
	`C©
(
	`˘r
(˘r.
gëWidth
-1, 32), 
wd©a
) }

1012 
	`whí
 (
	`decoded_addr
(
hi
)Ë{ 
˘r
 :
	`C©
(
	`wd©a
(˘r.
gëWidth
-33, 0), 
	`˘r
(31, 0)) }

1014 
	`whí
 (
	`decoded_addr
(
lo
)Ë{ 
˘r
 :
	`wd©a
(˘r.
gëWidth
-1, 0) }

1017 
def
 
	`f‹mEPC
(
x
: 
UI¡
Ë~(~x | (i‡(
usögCom¥es£d
) 1.U 3.U))

1018 
def
 
	`ªadEPC
(
x
: 
UI¡
Ë~(~x | 
	`Mux
(
	`ªg_miß
('c' - 'a'), 1.U, 3.U))

1019 
def
 
	`ißSåögToMask
(
s
: 
Såög
Ës.
	`m≠
(
x
 => 1 << (x - 'A')).
	`fﬁdLe·
(0)(
_
|_)

1020 
def
 
	`f‹mFS
(
fs
: 
UI¡
Ëi‡(
c‹eP¨ams
.
haveFSDúty
Ëf†
	`Fûl
(2, fs.
‹R
)

1021 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Consts.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
c⁄°™ts


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


7 
imp‹t
 
	gsˇœ
.
	gm©h
.
_


9 
åaô
 
	gSˇœrOpC⁄°™ts
 {

10 
vÆ
 
	gMT_SZ
 = 3

11 
def
 
MT_X
 = 
BôP©
("b???")

12 
def
 
MT_B
 = 
UI¡
("b000")

13 
def
 
MT_H
 = 
UI¡
("b001")

14 
def
 
MT_W
 = 
UI¡
("b010")

15 
def
 
MT_D
 = 
UI¡
("b011")

16 
def
 
MT_BU
 = 
UI¡
("b100")

17 
def
 
MT_HU
 = 
UI¡
("b101")

18 
def
 
MT_WU
 = 
UI¡
("b110")

19 
def
 
mtSize
(
mt
: 
UI¡
Ëmt(
MT_SZ
-2, 0)

20 
def
 
mtSig√d
(
mt
: 
UI¡
Ë!mt(
MT_SZ
-1)

22 
vÆ
 
SZ_BR
 = 3

23 
def
 
BR_X
 = 
BôP©
("b???")

24 
def
 
BR_EQ
 = 
UI¡
(0, 3)

25 
def
 
	gBR_NE
 = 
UI¡
(1, 3)

26 
def
 
	gBR_J
 = 
UI¡
(2, 3)

27 
def
 
	gBR_N
 = 
UI¡
(3, 3)

28 
def
 
	gBR_LT
 = 
UI¡
(4, 3)

29 
def
 
	gBR_GE
 = 
UI¡
(5, 3)

30 
def
 
	gBR_LTU
 = 
UI¡
(6, 3)

31 
def
 
	gBR_GEU
 = 
UI¡
(7, 3)

33 
def
 
	gA1_X
 = 
BôP©
("b??")

34 
def
 
A1_ZERO
 = 
UI¡
(0, 2)

35 
def
 
	gA1_RS1
 = 
UI¡
(1, 2)

36 
def
 
	gA1_PC
 = 
UI¡
(2, 2)

38 
def
 
	gIMM_X
 = 
BôP©
("b???")

39 
def
 
IMM_S
 = 
UI¡
(0, 3)

40 
def
 
	gIMM_SB
 = 
UI¡
(1, 3)

41 
def
 
	gIMM_U
 = 
UI¡
(2, 3)

42 
def
 
	gIMM_UJ
 = 
UI¡
(3, 3)

43 
def
 
	gIMM_I
 = 
UI¡
(4, 3)

44 
def
 
	gIMM_Z
 = 
UI¡
(5, 3)

46 
def
 
	gA2_X
 = 
BôP©
("b??")

47 
def
 
A2_ZERO
 = 
UI¡
(0, 2)

48 
def
 
	gA2_SIZE
 = 
UI¡
(1, 2)

49 
def
 
	gA2_RS2
 = 
UI¡
(2, 2)

50 
def
 
	gA2_IMM
 = 
UI¡
(3, 2)

52 
def
 
	gX
 = 
BôP©
("b?")

53 
def
 
N
 = 
BôP©
("b0")

54 
def
 
Y
 = 
BôP©
("b1")

56 
vÆ
 
SZ_DW
 = 1

57 
def
 
DW_X
 = 
X


58 
def
 
DW_32
 = 
Boﬁ
(
Ál£
)

59 
def
 
DW_64
 = 
Boﬁ
(
åue
)

60 
def
 
DW_XPR
 = 
DW_64


63 
åaô
 
	gMem‹yOpC⁄°™ts
 {

64 
vÆ
 
	gNUM_XA_OPS
 = 9

65 
vÆ
 
M_SZ
 = 5

66 
def
 
M_X
 = 
BôP©
("b?????");

67 
def
 
	gM_XRD
 = 
UI¡
("b00000");

68 
def
 
	gM_XWR
 = 
UI¡
("b00001");

69 
def
 
	gM_PFR
 = 
UI¡
("b00010");

70 
def
 
	gM_PFW
 = 
UI¡
("b00011");

71 
def
 
	gM_XA_SWAP
 = 
UI¡
("b00100");

72 
def
 
	gM_FLUSH_ALL
 = 
UI¡
("b00101")

73 
def
 
M_XLR
 = 
UI¡
("b00110");

74 
def
 
	gM_XSC
 = 
UI¡
("b00111");

75 
def
 
	gM_XA_ADD
 = 
UI¡
("b01000");

76 
def
 
	gM_XA_XOR
 = 
UI¡
("b01001");

77 
def
 
	gM_XA_OR
 = 
UI¡
("b01010");

78 
def
 
	gM_XA_AND
 = 
UI¡
("b01011");

79 
def
 
	gM_XA_MIN
 = 
UI¡
("b01100");

80 
def
 
	gM_XA_MAX
 = 
UI¡
("b01101");

81 
def
 
	gM_XA_MINU
 = 
UI¡
("b01110");

82 
def
 
	gM_XA_MAXU
 = 
UI¡
("b01111");

83 
def
 
	gM_FLUSH
 = 
UI¡
("b10000")

84 
def
 
M_PWR
 = 
UI¡
("b10001")

85 
def
 
M_PRODUCE
 = 
UI¡
("b10010")

86 
def
 
M_CLEAN
 = 
UI¡
("b10011")

87 
def
 
M_SFENCE
 = 
UI¡
("b10100")

89 
def
 
isAMOLogiˇl
(
cmd
: 
UI¡
Ëcmd.
isO√Of
(
M_XA_SWAP
, 
M_XA_XOR
, 
M_XA_OR
, 
M_XA_AND
)

90 
def
 
isAMOArôhmëic
(
cmd
: 
UI¡
Ëcmd.
isO√Of
(
M_XA_ADD
, 
M_XA_MIN
, 
M_XA_MAX
, 
M_XA_MINU
, 
M_XA_MAXU
)

91 
def
 
isAMO
(
cmd
: 
UI¡
Ë
isAMOLogiˇl
(cmdË|| 
isAMOArôhmëic
(cmd)

92 
def
 
isPª„tch
(
cmd
: 
UI¡
Ëcmd ==
M_PFR
 || cmd ==
M_PFW


93 
def
 
isRód
(
cmd
: 
UI¡
Ëcmd ==
M_XRD
 || cmd ==
M_XLR
 || cmd ==
M_XSC
 || 
isAMO
(cmd)

94 
def
 
isWrôe
(
cmd
: 
UI¡
Ëcmd ==
M_XWR
 || cmd ==
M_PWR
 || cmd ==
M_XSC
 || 
isAMO
(cmd)

95 
def
 
isWrôeI¡ít
(
cmd
: 
UI¡
Ë
isWrôe
(cmdË|| cmd ==
M_PFW
 || cmd ==
M_XLR


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/DCache.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.{
	gAddªssSë
, 
	gRegi⁄Ty≥
}

9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
LookupByH¨tId


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


13 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


14 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
_


15 
imp‹t
 
	gTLMesßges
.
_


17 ˛as†
	cDCacheEº‹s
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheBundÀ
()(
p
)

18 
wôh
 
C™HaveEº‹s
 {

19 
vÆ
 
c‹ª˘abÀ
 = (
ˇcheP¨ams
.
ègCode
.
ˇnC‹ª˘
 || cacheP¨ams.
d©aCode
.ˇnC‹ª˘).
	`›ti⁄
(
	`VÆid
(
	$UI¡
(
width
 = 
∑ddrBôs
)))

20 
vÆ
 
unc‹ª˘abÀ
 = (
ˇcheP¨ams
.
ègCode
.
ˇnDëe˘
 || cacheP¨ams.
d©aCode
.ˇnDëe˘).
	`›ti⁄
(
	`VÆid
(
	$UI¡
(
width
 = 
∑ddrBôs
)))

21 
vÆ
 
bus
 = 
	`VÆid
(
	`UI¡
(
width
 = 
∑ddrBôs
))

24 ˛as†
	cDCacheD©aReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheBundÀ
()(
p
) {

25 
vÆ
 
addr
 = 
	$Bôs
(
width
 = 
u¡agBôs
)

26 
vÆ
 
wrôe
 = 
	$Boﬁ
()

27 
vÆ
 
wd©a
 = 
	`UI¡
(
width
 = 
ícBôs
 * 
rowByãs
 / 
eccByãs
)

28 
vÆ
 
pois⁄
 = 
	$Boﬁ
()

29 
vÆ
 
w‹dMask
 = 
	`UI¡
(
width
 = 
rowByãs
 / 
w‹dByãs
)

30 
vÆ
 
eccMask
 = 
	`UI¡
(
width
 = 
w‹dByãs
 / 
eccByãs
)

31 
vÆ
 
way_í
 = 
	`Bôs
(
width
 = 
nWays
)

34 ˛as†
	cDCacheD©aAºay
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

35 
vÆ
 
io
 = 
√w
 
BundÀ
 {

36 
vÆ
 
ªq
 = 
	`VÆid
(
√w
 
DCacheD©aReq
).
Êù


37 
vÆ
 
ª•
 = 
	`Vec
(
nWays
, 
	`UI¡
(
width
 = 
ªq
.
bôs
.
wd©a
.
gëWidth
)).
asOuçut


40 
	`ªquúe
(
rowByãs
 % 
w‹dByãs
 == 0)

41 
vÆ
 
eccMask
 = i‡(
eccBôs
 =
w‹dBôs
Ë
	$Seq
(
åue
.
B
Ë
io
.
ªq
.
bôs
.
eccMask
.
toBoﬁs


42 
vÆ
 
wMask
 = i‡(
nWays
 =1Ë
eccMask
 (0 
u¡û
ÇWays).
	`Ê©M≠
(
i
 =>ÉccMask.
	`m≠
(
_
 && 
io
.
ªq
.
bôs
.
	$way_í
(
i
)))

43 
vÆ
 
wW‹ds
 = 
io
.
ªq
.
bôs
.
wd©a
.
	`grou≥d
(
ícBôs
 * (
w‹dBôs
 / 
eccBôs
))

44 
vÆ
 
addr
 = 
io
.
ªq
.
bôs
.add∏>> 
rowOffBôs


45 
vÆ
 
d©a_¨øys
 = 
Seq
.
	`èbuœã
(
rowByãs
 / 
w‹dByãs
) {

46 
i
 =>

47 
	`Des¸ibedSRAM
(

48 
«me
 = 
s
"data_arrays_${i}",

49 
desc
 = "DCache Data Array",

50 
size
 = 
nSës
 * 
ˇcheBlockByãs
 / 
rowByãs
,

51 
d©a
 = 
	`Vec
(
nWays
 * (
w‹dBôs
 / 
eccBôs
), 
	`UI¡
(
width
 = 
ícBôs
))

53 
	}
}

55 
vÆ
 
	grd©a
 = (
¨øy
, 
	gi
Ë<- 
d©a_¨øys
 
	gzùWôhIndex
Ë
	gyõld
 {

56 
vÆ
 
	gvÆid
 = 
io
.
ªq
.
vÆid
 && (
Boﬁ
(
d©a_¨øys
.
size
 =1Ë|| io.ªq.
bôs
.
w‹dMask
(
i
))

57 
whí
 (
vÆid
 && 
io
.
ªq
.
bôs
.
wrôe
) {

58 
vÆ
 
wD©a
 = 
wW‹ds
(
i
).
grou≥d
(
ícBôs
)

59 
¨øy
.
wrôe
(
addr
, 
Vec
((0 
u¡û
 
nWays
).
Ê©M≠
(
i
 => 
wD©a
)), 
wMask
)

61 
vÆ
 
	gd©a
 = 
¨øy
.
ªad
(
addr
, 
vÆid
 && !
io
.
ªq
.
bôs
.
wrôe
)

62 
	gd©a
.
grou≥d
(
w‹dBôs
 / 
eccBôs
).
m≠
(
_
.
asUI¡
).
	gtoSeq


64 (
	gio
.
ª•
 
zù
 
	grd©a
.
	gå™•o£
).
	gf‹óch
 { (
	gª•
, 
	gd©a
Ë=>Ñe• :
d©a
.
asUI¡
 }

67 ˛as†
	cDCacheMëad©aReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheBundÀ
()(
p
) {

68 
vÆ
 
wrôe
 = 
	$Boﬁ
()

69 
vÆ
 
addr
 = 
	$UI¡
(
width
 = 
vaddrBôsExãnded
)

70 
vÆ
 
idx
 = 
	$UI¡
(
width
 = 
idxBôs
)

71 
vÆ
 
way_í
 = 
	$UI¡
(
width
 = 
nWays
)

72 
vÆ
 
d©a
 = 
	`UI¡
(
width
 = 
ˇcheP¨ams
.
ègCode
.
	`width
(
√w
 
	`L1Mëad©a
().
gëWidth
))

75 
˛ass
 
	`DCache
(
h¨tid
: 
I¡
, 
vÆ
 
s¸©ch
: (Ë=> 
O±i⁄
[
AddªssSë
] = (Ë=> 
N⁄e
, vÆ 
buf„rUnˇchedReque°s
: O±i⁄[I¡] = N⁄e)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$HñœCache
(
h¨tid
)(
p
) {

76 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`DCacheModuÀ
(
this
)

77 
	}
}

79 @
chi£lName


80 ˛as†
	cDCacheModuÀ
(
ouãr
: 
DCache
Ë
exãnds
 
	$HñœCacheModuÀ
(
ouãr
) {

81 
vÆ
 
tECC
 = 
ˇcheP¨ams
.
ègCode


82 
vÆ
 
dECC
 = 
ˇcheP¨ams
.
d©aCode


83 
	`ªquúe
(
	`isPow2
(
eccByãs
Ë&&ÉccByã†<
w‹dByãs
)

84 
	`ªquúe
(
eccByãs
 =1 || !
dECC
.
isIn°™˚Of
[
IdítôyCode
])

85 
vÆ
 
usögRMW
 = 
eccByãs
 > 1 || 
usögAtomicsInCache


86 
vÆ
 
mmioOff£t
 = 
ouãr
.
fú°MMIO


88 
vÆ
 
˛ock_í_ªg
 = 
	`Reg
(
	$Boﬁ
())

89 
io
.
˝u
.
˛ock_íabÀd
 :
˛ock_í_ªg


91 
vÆ
 
g©ed_˛ock
 =

92 i‡(!
ˇcheP¨ams
.
˛ockG©e
Ë
˛ock


93 
	`ClockG©e
(
˛ock
, 
˛ock_í_ªg
, "dcache_clock_gate")

94 
	$wôhClock
 (
g©ed_˛ock
) {

97 
vÆ
 
ª∂a˚r
 = 
ˇcheP¨ams
.
ª∂a˚mít


98 
vÆ
 
mëaArb
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
DCacheMëad©aReq
, 8))

100 
vÆ
 
èg_¨øy
 = 
	`Des¸ibedSRAM
(

101 
«me
 = "tag_array",

102 
desc
 = "DCache Tag Array",

103 
size
 = 
nSës
,

104 
d©a
 = 
	`Vec
(
nWays
, 
mëaArb
.
io
.
out
.
bôs
.data)

108 
vÆ
 
d©a
 = 
	`ModuÀ
(
√w
 
DCacheD©aAºay
)

109 
vÆ
 
d©aArb
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
DCacheD©aReq
, 4))

110 
d©aArb
.
io
.
ö
.
èû
.
	`f‹óch
(
_
.
bôs
.
wd©a
 :d©aArb.io.ö.
hód
.bits.wdata)

111 
d©a
.
io
.
ªq
 <> 
d©aArb
.io.
out


112 
d©a
.
io
.
ªq
.
bôs
.
wd©a
 :
	`ícodeD©a
(
d©aArb
.io.
out
.bôs.
	`wd©a
(
rowBôs
-1, 0), d©aArb.io.out.bôs.
pois⁄
)

113 
d©aArb
.
io
.
out
.
ªady
 :
åue


114 
mëaArb
.
io
.
out
.
ªady
 :
˛ock_í_ªg


116 
vÆ
 
é_out_a
 = 
	`Wúe
(
é_out
.
a
)

117 
é_out
.
a
 <> 
ouãr
.
buf„rUnˇchedReque°s


118 .
	`m≠
(
_
 
mö
 
maxUnˇchedInFlight
-1)

119 .
	`m≠
(
	`Queue
(
é_out_a
, 
_
, 
Êow
 = 
åue
))

120 .
	`gëOrEl£
(
é_out_a
)

122 
	`vÆ
 (
é_out_c
, 
ªÀa£_queue_em±y
) =

123 i‡(
ˇcheP¨ams
.
acquúeBef‹eRñó£
) {

124 
vÆ
 
q
 = 
	`ModuÀ
(
√w
 
	`Queue
(
é_out
.
c
.
bôs
.
˛⁄eTy≥
, 
ˇcheD©aBóts
, 
Êow
 = 
åue
))

125 
é_out
.
c
 <> 
q
.
io
.
deq


126 (
q
.
io
.
íq
, q.io.
cou¡
 === 0)

128 (
é_out
.
c
, 
åue
.
B
)

131 
vÆ
 
s1_vÆid
 = 
	`Reg
(
√xt
=
io
.
˝u
.
ªq
.
	`fúe
(), 
öô
=
	`Boﬁ
(
Ál£
))

132 
vÆ
 
s1_¥obe
 = 
	`Reg
(
√xt
=
é_out
.
b
.
	`fúe
(), 
öô
=
	`Boﬁ
(
Ál£
))

133 
vÆ
 
¥obe_bôs
 = 
	`RegE«bÀ
(
é_out
.
b
.
bôs
,Ål_out.b.
	`fúe
())

134 
vÆ
 
s1_«ck
 = 
	`Wúe
(
öô
=
	`Boﬁ
(
Ál£
))

135 
vÆ
 
s1_vÆid_masked
 = 
s1_vÆid
 && !
io
.
˝u
.
s1_kûl


136 
vÆ
 
s1_vÆid_nŸ_«cked
 = 
s1_vÆid
 && !
s1_«ck


137 
vÆ
 
s1_ªq
 = 
	`Reg
(
io
.
˝u
.
ªq
.
bôs
)

138 
vÆ
 
s0_˛k_í
 = 
mëaArb
.
io
.
out
.
vÆid
 && !mëaArb.io.out.
bôs
.
wrôe


139 
	`whí
 (
s0_˛k_í
) {

140 
s1_ªq
 :
io
.
˝u
.
ªq
.
bôs


141 
s1_ªq
.
addr
 :
	`C©
(
mëaArb
.
io
.
out
.
bôs
.add∏>> 
blockOffBôs
, io.
˝u
.
ªq
.bôs.
	`addr
(blockOffBits-1,0))

142 
	`whí
 (!
mëaArb
.
io
.
	`ö
(7).
ªady
Ë{ 
s1_ªq
.
phys
 :
åue
 }

144 
vÆ
 
s1_ªad
 = 
	`isRód
(
s1_ªq
.
cmd
)

145 
vÆ
 
s1_wrôe
 = 
	`isWrôe
(
s1_ªq
.
cmd
)

146 
vÆ
 
s1_ªadwrôe
 = 
s1_ªad
 || 
s1_wrôe


147 
vÆ
 
s1_s„n˚
 = 
s1_ªq
.
cmd
 ==
M_SFENCE


148 
vÆ
 
s1_Êush_vÆid
 = 
	`Reg
(
	`Boﬁ
())

149 
vÆ
 
s1_waw_haz¨d
 = 
	`Wúe
(
	`Boﬁ
())

151 
vÆ
 
s_ªady
 :: 
s_vﬁu¡¨y_wrôeback
 :: 
s_¥obe_ªp_dúty
 :: 
s_¥obe_ªp_˛ón
 :: 
s_¥obe_ªåy
 :: 
s_¥obe_ªp_miss
 :: 
s_vﬁu¡¨y_wrôe_mëa
 :: 
s_¥obe_wrôe_mëa
 :: 
Nû
 = 
	`Enum
(
	`UI¡
(), 8)

152 
vÆ
 
ˇched_gø¡_waô
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

153 
vÆ
 
ªÀa£_ack_waô
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

154 
vÆ
 
ˇn_acquúe_bef‹e_ªÀa£
 = !
ªÀa£_ack_waô
 && 
ªÀa£_queue_em±y


155 
vÆ
 
ªÀa£_°©e
 = 
	`Reg
(
öô
=
s_ªady
)

156 
vÆ
 
™y_p°‹e_vÆid
 = 
	`Wúe
(
	`Boﬁ
())

157 
vÆ
 
öWrôeback
 = 
ªÀa£_°©e
.
	`isO√Of
(
s_vﬁu¡¨y_wrôeback
, 
s_¥obe_ªp_dúty
)

158 
vÆ
 
ªÀa£Way
 = 
	`Wúe
(
	`UI¡
())

159 
io
.
˝u
.
ªq
.
ªady
 :(
ªÀa£_°©e
 ==
s_ªady
Ë&& !
ˇched_gø¡_waô
 && !
s1_«ck


162 
vÆ
 
unˇchedInFlight
 = 
	`RegInô
(
Vec
.
	`fûl
(
maxUnˇchedInFlight
)(
Ál£
.
B
))

163 
vÆ
 
unˇchedReqs
 = 
	`Reg
(
	`Vec
(
maxUnˇchedInFlight
, 
√w
 
HñœCacheReq
))

166 
vÆ
 
s0_ªad
 = 
	`isRód
(
io
.
˝u
.
ªq
.
bôs
.
cmd
)

167 
d©aArb
.
io
.
	`ö
(3).
vÆid
 :io.
˝u
.
ªq
.vÆid && 
	`likñyNìdsRód
(io.˝u.ªq.
bôs
)

168 
d©aArb
.
io
.
	`ö
(3).
bôs
 := dataArb.io.in(1).bits

169 
d©aArb
.
io
.
	`ö
(3).
bôs
.
wrôe
 :
Ál£


170 
d©aArb
.
io
.
	`ö
(3).
bôs
.
addr
 :io.
˝u
.
ªq
.bits.addr

171 
d©aArb
.
io
.
	`ö
(3).
bôs
.
w‹dMask
 :
	`UI¡ToOH
(io.
˝u
.
ªq
.bôs.
addr
.
	`exåa˘
(
rowOffBôs
-1,
off£ésb
))

172 
d©aArb
.
io
.
	`ö
(3).
bôs
.
way_í
 :~
	`UI¡
(0, 
nWays
)

173 
	`whí
 (!
d©aArb
.
io
.
	`ö
(3).
ªady
 && 
s0_ªad
Ë{ io.
˝u
.
ªq
.ªady :
Ál£
 }

174 
vÆ
 
s1_did_ªad
 = 
	`RegE«bÀ
(
d©aArb
.
io
.
	`ö
(3).
ªady
 && (io.
˝u
.
ªq
.
vÆid
 && 
	`√edsRód
(io.˝u.ªq.
bôs
)), 
s0_˛k_í
)

175 
mëaArb
.
io
.
	`ö
(7).
vÆid
 :io.
˝u
.
ªq
.valid

176 
mëaArb
.
io
.
	`ö
(7).
bôs
.
wrôe
 :
Ál£


177 
mëaArb
.
io
.
	`ö
(7).
bôs
.
idx
 :io.
˝u
.
ªq
.bôs.
	`addr
(
idxMSB
, 
idxLSB
)

178 
mëaArb
.
io
.
	`ö
(7).
bôs
.
addr
 :io.
˝u
.
ªq
.bits.addr

179 
mëaArb
.
io
.
	`ö
(7).
bôs
.
way_í
 := metaArb.io.in(4).bits.way_en

180 
mëaArb
.
io
.
	`ö
(7).
bôs
.
d©a
 := metaArb.io.in(4).bits.data

181 
	`whí
 (!
mëaArb
.
io
.
	`ö
(7).
ªady
Ë{ io.
˝u
.
ªq
.ªady :
Ál£
 }

184 
vÆ
 
éb
 = 
	`ModuÀ
(
√w
 
	`TLB
(
Ál£
, 
	`log2Ceû
(
c‹eD©aByãs
), 
	`TLBC⁄fig
(
nTLBE¡rõs
)))

185 
io
.
±w
 <> 
éb
.io.ptw

186 
éb
.
io
.
kûl
 :io.
˝u
.
s2_kûl


187 
éb
.
io
.
ªq
.
vÆid
 :
s1_vÆid
 && !io.
˝u
.
s1_kûl
 && 
s1_ªadwrôe


188 
éb
.
io
.
ªq
.
bôs
.
∑s°hrough
 :
s1_ªq
.
phys


189 
éb
.
io
.
ªq
.
bôs
.
vaddr
 :
s1_ªq
.
addr


190 
éb
.
io
.
ªq
.
bôs
.
size
 :
s1_ªq
.
typ


191 
éb
.
io
.
ªq
.
bôs
.
cmd
 :
s1_ªq
.cmd

192 
	`whí
 (!
éb
.
io
.
ªq
.
ªady
 && !éb.io.
±w
.
ª•
.
vÆid
 && !io.
˝u
.ªq.
bôs
.
phys
Ë{ io.˝u.ªq.ªady :
Ál£
 }

193 
	`whí
 (
s1_vÆid
 && 
s1_ªadwrôe
 && 
éb
.
io
.
ª•
.
miss
Ë{ 
s1_«ck
 :
åue
 }

195 
éb
.
io
.
s„n˚
.
vÆid
 :
s1_vÆid
 && !io.
˝u
.
s1_kûl
 && 
s1_s„n˚


196 
éb
.
io
.
s„n˚
.
bôs
.
rs1
 :
s1_ªq
.
	`typ
(0)

197 
éb
.
io
.
s„n˚
.
bôs
.
rs2
 :
s1_ªq
.
	`typ
(1)

198 
éb
.
io
.
s„n˚
.
bôs
.
asid
 :io.
˝u
.
s1_d©a
.
d©a


199 
éb
.
io
.
s„n˚
.
bôs
.
addr
 :
s1_ªq
.addr

201 
vÆ
 
s1_∑ddr
 = 
éb
.
io
.
ª•
.
∑ddr


202 
vÆ
 
s1_vi˘im_way
 = 
	`Wúe
(
öô
 = 
ª∂a˚r
.
way
)

203 
	`vÆ
 (
s1_hô_way
, 
s1_hô_°©e
, 
s1_mëa
, 
s1_vi˘im_mëa
) =

204 i‡(
usögD©aS¸©ch∑d
) {

205 
vÆ
 
ba£Addr
 = 
	`p
(
LookupByH¨tId
)(
_
.
dˇche
.
	`Ê©M≠
(_.
s¸©ch
.
	`m≠
(_.
U
)), 
io
.
h¨tid
)

206 
vÆ
 
öS¸©ch∑d
 = 
s1_∑ddr
 >
ba£Addr
 && s1_∑dd∏< ba£Add∏+ 
nSës
 * 
ˇcheBlockByãs


207 
vÆ
 
hôSèã
 = 
	`Mux
(
öS¸©ch∑d
, 
Clõ¡Mëad©a
.
maximum
, Clõ¡Mëad©a.
⁄Re£t
)

208 
vÆ
 
dummyMëa
 = 
	`L1Mëad©a
(
	`UI¡
(0), 
Clõ¡Mëad©a
.
⁄Re£t
)

209 (
öS¸©ch∑d
, 
hôSèã
, 
	`Seq
(
tECC
.
	`ícode
(
dummyMëa
.
asUI¡
)), dummyMeta)

211 
vÆ
 
mëaReq
 = 
mëaArb
.
io
.
out


212 
vÆ
 
mëaIdx
 = 
mëaReq
.
bôs
.
idx


213 
	`whí
 (
mëaReq
.
vÆid
 && mëaReq.
bôs
.
wrôe
) {

214 
vÆ
 
wmask
 = i‡(
nWays
 =1Ë
	`Seq
(
åue
.
B
Ë
mëaReq
.
bôs
.
way_í
.
toBoﬁs


215 
èg_¨øy
.
	`wrôe
(
mëaIdx
, 
Vec
.
	`fûl
(
nWays
)(
mëaReq
.
bôs
.
d©a
), 
wmask
)

217 
vÆ
 
s1_mëa
 = 
èg_¨øy
.
	`ªad
(
mëaIdx
, 
mëaReq
.
vÆid
 && !mëaReq.
bôs
.
wrôe
)

218 
vÆ
 
s1_mëa_unc‹ª˘ed
 = 
s1_mëa
.
	`m≠
(
tECC
.
	`decode
(
_
).
unc‹ª˘ed
.
	`asTy≥Of
(
√w
 
L1Mëad©a
))

219 
vÆ
 
s1_èg
 = 
s1_∑ddr
 >> 
ègLSB


220 
vÆ
 
s1_mëa_hô_way
 = 
s1_mëa_unc‹ª˘ed
.
	`m≠
(
r
 =>Ñ.
coh
.
	`isVÆid
(Ë&&Ñ.
èg
 ==
s1_èg
).
asUI¡


221 
vÆ
 
s1_mëa_hô_°©e
 = 
Clõ¡Mëad©a
.
⁄Re£t
.
	`‰omBôs
(

222 
s1_mëa_unc‹ª˘ed
.
	`m≠
(
r
 => 
	`Mux
‘.
èg
 ==
s1_èg
 && !
s1_Êush_vÆid
,Ñ.
coh
.
asUI¡
, 
	`UI¡
(0)))

223 .
	`ªdu˚
 (
_
|_))

224 (
s1_mëa_hô_way
, 
s1_mëa_hô_°©e
, 
s1_mëa
, 
	`s1_mëa_unc‹ª˘ed
(
s1_vi˘im_way
))

226 
vÆ
 
s1_d©a_way
 = 
	`Wúe
(
öô
 = i‡(
nWays
 =1Ë1.U 
	`Mux
(
öWrôeback
, 
ªÀa£Way
, 
s1_hô_way
))

227 
vÆ
 
s1_Æl_d©a_ways
 = 
	`Vec
(
d©a
.
io
.
ª•
 :+ 
	`dummyEncodeD©a
(
é_out
.
d
.
bôs
.data))

228 
vÆ
 
s1_mask
 = 
	`Mux
(
s1_ªq
.
cmd
 ==
M_PWR
, 
io
.
˝u
.
s1_d©a
.
mask
, 
√w
 
	`St‹eGí
(s1_ªq.
typ
, s1_ªq.
addr
, 
	`UI¡
(0), 
w‹dByãs
).mask)

230 
vÆ
 
s2_vÆid_¥e_x˝t
 = 
	`Reg
(
√xt
=
s1_vÆid_masked
 && !
s1_s„n˚
, 
öô
=
	`Boﬁ
(
Ál£
))

231 
vÆ
 
s2_vÆid
 = 
s2_vÆid_¥e_x˝t
 && !
io
.
˝u
.
s2_x˝t
.
asUI¡
.
‹R


232 
vÆ
 
s2_¥obe
 = 
	`Reg
(
√xt
=
s1_¥obe
, 
öô
=
	`Boﬁ
(
Ál£
))

233 
vÆ
 
ªÀa£InFlight
 = 
s1_¥obe
 || 
s2_¥obe
 || 
ªÀa£_°©e
 =/
s_ªady


234 
vÆ
 
s2_vÆid_masked
 = 
s2_vÆid
 && 
	`Reg
(
√xt
 = !
s1_«ck
)

235 
vÆ
 
s2_vÆid_nŸ_kûÀd
 = 
s2_vÆid_masked
 && !
io
.
˝u
.
s2_kûl


236 
vÆ
 
s2_ªq
 = 
	`Reg
(
io
.
˝u
.
ªq
.
bôs
)

237 
vÆ
 
s2_unˇched
 = 
	`Reg
(
	`Boﬁ
())

238 
vÆ
 
s2_unˇched_ª•_addr
 = 
	`Reg
(
	`UI¡
())

239 
	`whí
 (
s1_vÆid_nŸ_«cked
 || 
s1_Êush_vÆid
) {

240 
s2_ªq
 :
s1_ªq


241 
s2_ªq
.
addr
 :
s1_∑ddr


242 
s2_unˇched
 :!
éb
.
io
.
ª•
.
ˇchóbÀ


244 
vÆ
 
s2_vaddr
 = 
	`C©
(
	`RegE«bÀ
(
s1_ªq
.
addr
, 
s1_vÆid_nŸ_«cked
 || 
s1_Êush_vÆid
Ë>> 
pgIdxBôs
, 
s2_ªq
.
	`addr
(pgIdxBits-1, 0))

245 
vÆ
 
s2_ªad
 = 
	`isRód
(
s2_ªq
.
cmd
)

246 
vÆ
 
s2_wrôe
 = 
	`isWrôe
(
s2_ªq
.
cmd
)

247 
vÆ
 
s2_ªadwrôe
 = 
s2_ªad
 || 
s2_wrôe


248 
vÆ
 
s2_Êush_vÆid_¥e_èg_ecc
 = 
	`RegNext
(
s1_Êush_vÆid
)

249 
vÆ
 
s1_mëa_decoded
 = 
s1_mëa
.
	`m≠
(
tECC
.
	`decode
(
_
))

250 
vÆ
 
s1_mëa_˛k_í
 = 
s1_vÆid_nŸ_«cked
 || 
s1_Êush_vÆid
 || 
s1_¥obe


251 
vÆ
 
s2_mëa_c‹ª˘abÀ_îr‹s
 = 
s1_mëa_decoded
.
	`m≠
(
m
 => 
	`RegE«bÀ
(m.
c‹ª˘abÀ
, 
s1_mëa_˛k_í
)).
asUI¡


252 
vÆ
 
s2_mëa_unc‹ª˘abÀ_îr‹s
 = 
s1_mëa_decoded
.
	`m≠
(
m
 => 
	`RegE«bÀ
(m.
unc‹ª˘abÀ
, 
s1_mëa_˛k_í
)).
asUI¡


253 
vÆ
 
s2_mëa_îr‹_unc‹ª˘abÀ
 = 
s2_mëa_unc‹ª˘abÀ_îr‹s
.
‹R


254 
vÆ
 
s2_mëa_c‹ª˘ed
 = 
s1_mëa_decoded
.
	`m≠
(
m
 => 
	`RegE«bÀ
(m.
c‹ª˘ed
, 
s1_mëa_˛k_í
).
	`asTy≥Of
(
√w
 
L1Mëad©a
))

255 
vÆ
 
s2_mëa_îr‹
 = (
s2_mëa_unc‹ª˘abÀ_îr‹s
 | 
s2_mëa_c‹ª˘abÀ_îr‹s
).
‹R


256 
vÆ
 
s2_Êush_vÆid
 = 
s2_Êush_vÆid_¥e_èg_ecc
 && !
s2_mëa_îr‹


257 
vÆ
 
s2_d©a
 = {

258 
vÆ
 
í
 = 
s1_vÆid
 || 
öWrôeback


259 i‡(
ˇcheP¨ams
.
pùñöeWayMux
) {

260 
vÆ
 
s2_d©a_way
 = 
	`RegE«bÀ
(
s1_d©a_way
, 
í
)

261 
vÆ
 
s2_Æl_d©a_ways
 = (0 
u¡û
 
nWays
).
	`m≠
(
i
 => 
	`RegE«bÀ
(
	`s1_Æl_d©a_ways
(i), 
í
))

262 
	`Mux1H
(
s2_d©a_way
, 
s2_Æl_d©a_ways
)

264 
	`RegE«bÀ
(
	`Mux1H
(
s1_d©a_way
, 
s1_Æl_d©a_ways
), 
í
 || 
é_out
.
d
.
	`fúe
())

267 
vÆ
 
s2_¥obe_way
 = 
	`RegE«bÀ
(
s1_hô_way
, 
s1_¥obe
)

268 
vÆ
 
s2_¥obe_°©e
 = 
	`RegE«bÀ
(
s1_hô_°©e
, 
s1_¥obe
)

269 
vÆ
 
s2_hô_way
 = 
	`RegE«bÀ
(
s1_hô_way
, 
s1_vÆid_nŸ_«cked
)

270 
vÆ
 
s2_hô_°©e
 = 
	`RegE«bÀ
(
s1_hô_°©e
, 
s1_vÆid_nŸ_«cked
 || 
s1_Êush_vÆid
)

271 
vÆ
 
s2_waw_haz¨d
 = 
	`RegE«bÀ
(
s1_waw_haz¨d
, 
s1_vÆid_nŸ_«cked
)

272 
vÆ
 
s2_°‹e_mîge
 = 
	`Wúe
(
	`Boﬁ
())

273 
vÆ
 
s2_hô_vÆid
 = 
s2_hô_°©e
.
	`isVÆid
()

274 
	`vÆ
 (
s2_hô
, 
s2_grow_∑øm
, 
s2_√w_hô_°©e
Ë
s2_hô_°©e
.
	`⁄Ac˚ss
(
s2_ªq
.
cmd
)

275 
vÆ
 
s2_d©a_decoded
 = 
	`decodeD©a
(
s2_d©a
)

276 
vÆ
 
s2_w‹d_idx
 = 
s2_ªq
.
addr
.
	`exåa˘
(
	`log2Up
(
rowBôs
/8)-1,Üog2Up(
w‹dByãs
))

277 
vÆ
 
s2_did_ªad
 = 
	`RegE«bÀ
(
s1_did_ªad
, 
s1_vÆid_nŸ_«cked
)

278 
vÆ
 
s2_d©a_îr‹
 = 
s2_did_ªad
 && (
s2_d©a_decoded
.
	`m≠
(
_
.
îr‹
).
	`grou≥d
(
w‹dBôs
/
eccBôs
).m≠(_.
	`ªdu˚
(_||_)).
toSeq
)(
s2_w‹d_idx
)

279 
vÆ
 
s2_d©a_îr‹_unc‹ª˘abÀ
 = (
s2_d©a_decoded
.
	`m≠
(
_
.
unc‹ª˘abÀ
).
	`grou≥d
(
w‹dBôs
/
eccBôs
).m≠(_.
	`ªdu˚
(_||_)).
toSeq
)(
s2_w‹d_idx
)

280 
vÆ
 
s2_d©a_c‹ª˘ed
 = (
s2_d©a_decoded
.
	`m≠
(
_
.
c‹ª˘ed
): 
Seq
[
UI¡
]).
asUI¡


281 
vÆ
 
s2_d©a_unc‹ª˘ed
 = (
s2_d©a_decoded
.
	`m≠
(
_
.
unc‹ª˘ed
): 
Seq
[
UI¡
]).
asUI¡


282 
vÆ
 
s2_vÆid_hô_¥e_d©a_ecc
 = 
s2_vÆid_masked
 && 
s2_ªadwrôe
 && !
s2_mëa_îr‹
 && 
s2_hô


283 
vÆ
 
s2_vÆid_d©a_îr‹
 = 
s2_vÆid_hô_¥e_d©a_ecc
 && 
s2_d©a_îr‹
 && 
ˇn_acquúe_bef‹e_ªÀa£


284 
vÆ
 
s2_vÆid_hô
 = 
s2_vÆid_hô_¥e_d©a_ecc
 && !
s2_d©a_îr‹
 && (!
s2_waw_haz¨d
 || 
s2_°‹e_mîge
)

285 
vÆ
 
s2_vÆid_miss
 = 
s2_vÆid_masked
 && 
s2_ªadwrôe
 && !
s2_mëa_îr‹
 && !
s2_hô
 && 
ˇn_acquúe_bef‹e_ªÀa£


286 
vÆ
 
s2_vÆid_ˇched_miss
 = 
s2_vÆid_miss
 && !
s2_unˇched
 && !
unˇchedInFlight
.
asUI¡
.
‹R


287 
	`d⁄tTouch
(
s2_vÆid_ˇched_miss
)

288 
vÆ
 
s2_w™t_vi˘imize
 = 
	`Boﬁ
(!
usögD©aS¸©ch∑d
Ë&& (
s2_vÆid_ˇched_miss
 || 
s2_vÆid_d©a_îr‹
 || 
s2_Êush_vÆid
)

289 
vÆ
 
s2_ˇ¬Ÿ_vi˘imize
 = !
s2_Êush_vÆid
 && 
io
.
˝u
.
s2_kûl


290 
vÆ
 
s2_vi˘imize
 = 
s2_w™t_vi˘imize
 && !
s2_ˇ¬Ÿ_vi˘imize


291 
vÆ
 
s2_vÆid_unˇched_≥ndög
 = 
s2_vÆid_miss
 && 
s2_unˇched
 && !
unˇchedInFlight
.
asUI¡
.
™dR


292 
vÆ
 
s2_vi˘im_way
 = 
	`Mux
(
s2_hô_vÆid
, 
s2_hô_way
, 
	`UI¡ToOH
(
	`RegE«bÀ
(
s1_vi˘im_way
, 
s1_vÆid_nŸ_«cked
 || 
s1_Êush_vÆid
)))

293 
vÆ
 
s2_vi˘im_èg
 = 
	`Mux
(
s2_vÆid_d©a_îr‹
, 
s2_ªq
.
	`addr
(
∑ddrBôs
-1, 
ègLSB
), 
	`RegE«bÀ
(
s1_vi˘im_mëa
.
èg
, 
s1_vÆid_nŸ_«cked
 || 
s1_Êush_vÆid
))

294 
vÆ
 
s2_vi˘im_°©e
 = 
	`Mux
(
s2_hô_vÆid
, 
s2_hô_°©e
, 
	`RegE«bÀ
(
s1_vi˘im_mëa
.
coh
, 
s1_vÆid_nŸ_«cked
 || 
s1_Êush_vÆid
))

296 
	`vÆ
 (
s2_¥b_ack_d©a
, 
s2_ªp‹t_∑øm
, 
¥obeNewCoh
)
s2_¥obe_°©e
.
	`⁄Probe
(
¥obe_bôs
.
∑øm
)

297 
	`vÆ
 (
s2_vi˘im_dúty
, 
s2_shrök_∑øm
, 
vﬁu¡¨yNewCoh
Ë
s2_vi˘im_°©e
.
	`⁄CacheC⁄åﬁ
(
M_FLUSH
)

298 
	`d⁄tTouch
(
s2_vi˘im_dúty
)

299 
vÆ
 
s2_upd©e_mëa
 = 
s2_hô_°©e
 =/
s2_√w_hô_°©e


300 
io
.
˝u
.
s2_«ck
 :
s2_vÆid
 && !
s2_vÆid_hô
 && !(
s2_vÆid_unˇched_≥ndög
 && 
é_out_a
.
ªady
)

301 
	`whí
 (
io
.
˝u
.
s2_«ck
 || (
s2_vÆid_hô
 && 
s2_upd©e_mëa
)Ë{ 
s1_«ck
 :
åue
 }

304 
vÆ
 
s2_fú°_mëa_c‹ª˘ed
 = 
	`Pri‹ôyMux
(
s2_mëa_c‹ª˘abÀ_îr‹s
, 
s2_mëa_c‹ª˘ed
)

305 
mëaArb
.
io
.
	`ö
(1).
vÆid
 :
s2_mëa_îr‹
 && (
s2_vÆid_masked
 || 
s2_Êush_vÆid_¥e_èg_ecc
 || 
s2_¥obe
)

306 
mëaArb
.
io
.
	`ö
(1).
bôs
.
wrôe
 :
åue


307 
mëaArb
.
io
.
	`ö
(1).
bôs
.
way_í
 :
s2_mëa_unc‹ª˘abÀ_îr‹s
 | 
	`Mux
(
s2_mëa_îr‹_unc‹ª˘abÀ
, 0.U, 
	`Pri‹ôyEncodîOH
(
s2_mëa_c‹ª˘abÀ_îr‹s
))

308 
mëaArb
.
io
.
	`ö
(1).
bôs
.
idx
 :
	`Mux
(
s2_¥obe
, 
	`¥obeIdx
(
¥obe_bôs
), 
	`s2_vaddr
(
idxMSB
, 
idxLSB
))

309 
mëaArb
.
io
.
	`ö
(1).
bôs
.
addr
 :
	`C©
(io.
˝u
.
ªq
.bôs.add∏>> 
u¡agBôs
, mëaArb.io.ö(1).bôs.
idx
 << 
blockOffBôs
)

310 
mëaArb
.
io
.
	`ö
(1).
bôs
.
d©a
 :
tECC
.
ícode
 {

311 
vÆ
 
√w_mëa
 = 
	`Wúe
(
öô
 = 
s2_fú°_mëa_c‹ª˘ed
)

312 
	`whí
 (
s2_mëa_îr‹_unc‹ª˘abÀ
Ë{ 
√w_mëa
.
coh
 :
Clõ¡Mëad©a
.
⁄Re£t
 }

313 
√w_mëa
.
asUI¡


317 
mëaArb
.
io
.
	`ö
(2).
vÆid
 :(
s2_vÆid_hô
 && 
s2_upd©e_mëa
Ë|| (
s2_w™t_vi˘imize
 && !
s2_vi˘im_dúty
)

318 
mëaArb
.
io
.
	`ö
(2).
bôs
.
wrôe
 :!
s2_ˇ¬Ÿ_vi˘imize


319 
mëaArb
.
io
.
	`ö
(2).
bôs
.
way_í
 :
s2_vi˘im_way


320 
mëaArb
.
io
.
	`ö
(2).
bôs
.
idx
 :
	`s2_vaddr
(
idxMSB
, 
idxLSB
)

321 
mëaArb
.
io
.
	`ö
(2).
bôs
.
addr
 :
	`C©
(io.
˝u
.
ªq
.bôs.add∏>> 
u¡agBôs
, 
	`s2_vaddr
(
idxMSB
, 0))

322 
mëaArb
.
io
.
	`ö
(2).
bôs
.
d©a
 :
tECC
.
	`ícode
(
	`L1Mëad©a
(
s2_ªq
.
addr
 >> 
ègLSB
, 
	`Mux
(
s2_vÆid_hô
, 
s2_√w_hô_°©e
, 
Clõ¡Mëad©a
.
⁄Re£t
)).
asUI¡
)

325 
vÆ
 
s2_Ã
 = 
	`Boﬁ
(
usögAtomics
 && !
usögD©aS¸©ch∑d
Ë&& 
s2_ªq
.
cmd
 ==
M_XLR


326 
vÆ
 
s2_sc
 = 
	`Boﬁ
(
usögAtomics
 && !
usögD©aS¸©ch∑d
Ë&& 
s2_ªq
.
cmd
 ==
M_XSC


327 
vÆ
 
ÃscCou¡
 = 
	`Reg
(
öô
=
	`UI¡
(0))

328 
vÆ
 
ÃscVÆid
 = 
ÃscCou¡
 > 
ÃscBackoff


329 
vÆ
 
ÃscBackögOff
 = 
ÃscCou¡
 > 0 && !
ÃscVÆid


330 
vÆ
 
ÃscAddr
 = 
	`Reg
(
	`UI¡
())

331 
vÆ
 
ÃscAddrM©ch
 = 
ÃscAddr
 ==(
s2_ªq
.
addr
 >> 
blockOffBôs
)

332 
vÆ
 
s2_sc_Áû
 = 
s2_sc
 && !(
ÃscVÆid
 && 
ÃscAddrM©ch
)

333 
	`whí
 ((
s2_vÆid_hô
 && 
s2_Ã
 && !
ˇched_gø¡_waô
 || 
s2_vÆid_ˇched_miss
Ë&& !
io
.
˝u
.
s2_kûl
) {

334 
ÃscCou¡
 :
	`Mux
(
s2_hô
, 
ÃscCy˛es
 - 1, 0.U)

335 
ÃscAddr
 :
s2_ªq
.
addr
 >> 
blockOffBôs


337 
	`whí
 (
ÃscCou¡
 > 0) {ÜrscCount :=ÜrscCount - 1 }

338 
	`whí
 (
s2_vÆid_nŸ_kûÀd
 && 
ÃscVÆid
Ë{ 
ÃscCou¡
 :
ÃscBackoff
 }

339 
	`whí
 (
s1_¥obe
Ë{ 
ÃscCou¡
 := 0 }

342 
vÆ
 
s2_c‹ª˘
 = 
s2_d©a_îr‹
 && !
™y_p°‹e_vÆid
 && !
	`RegNext
◊ny_p°‹e_vÆidË&& 
	`Boﬁ
(
usögD©aS¸©ch∑d
)

344 
vÆ
 
s2_vÆid_c‹ª˘
 = 
s2_vÆid_hô_¥e_d©a_ecc
 && 
s2_c‹ª˘
 && !
io
.
˝u
.
s2_kûl


345 
def
 
s2_°‹e_vÆid_¥e_kûl
 = 
s2_vÆid_hô
 && 
s2_wrôe
 && !
s2_sc_Áû


346 
def
 
s2_°‹e_vÆid
 = 
s2_°‹e_vÆid_¥e_kûl
 && !
io
.
˝u
.
s2_kûl


347 
vÆ
 
p°‹e1_cmd
 = 
	`RegE«bÀ
(
s1_ªq
.
cmd
, 
s1_vÆid_nŸ_«cked
 && 
s1_wrôe
)

348 
vÆ
 
p°‹e1_addr
 = 
	`RegE«bÀ
(
s1_ªq
.
addr
, 
s1_vÆid_nŸ_«cked
 && 
s1_wrôe
)

349 
vÆ
 
p°‹e1_d©a
 = 
	`RegE«bÀ
(
io
.
˝u
.
s1_d©a
.
d©a
, 
s1_vÆid_nŸ_«cked
 && 
s1_wrôe
)

350 
vÆ
 
p°‹e1_way
 = 
	`RegE«bÀ
(
s1_hô_way
, 
s1_vÆid_nŸ_«cked
 && 
s1_wrôe
)

351 
vÆ
 
p°‹e1_mask
 = 
	`RegE«bÀ
(
s1_mask
, 
s1_vÆid_nŸ_«cked
 && 
s1_wrôe
)

352 
vÆ
 
p°‹e1_°‹egí_d©a
 = 
	`Wúe
(
öô
 = 
p°‹e1_d©a
)

353 
vÆ
 
p°‹e1_rmw
 = 
	`Boﬁ
(
usögRMW
Ë&& 
	`RegE«bÀ
(
	`√edsRód
(
s1_ªq
), 
s1_vÆid_nŸ_«cked
 && 
s1_wrôe
)

354 
vÆ
 
p°‹e1_mîge_likñy
 = 
s2_vÆid
 && 
s2_wrôe
 && 
s2_°‹e_mîge


355 
vÆ
 
p°‹e1_mîge
 = 
s2_°‹e_vÆid
 && 
s2_°‹e_mîge


356 
vÆ
 
p°‹e2_vÆid
 = 
	`Reg
(
	`Boﬁ
())

357 
vÆ
 
p°‹e_døö_›p‹tuni°ic
 = !(
io
.
˝u
.
ªq
.
vÆid
 && 
	`likñyNìdsRód
(io.˝u.ªq.
bôs
))

358 
vÆ
 
p°‹e_døö_⁄_miss
 = 
ªÀa£InFlight


359 
vÆ
 
p°‹e1_hñd
 = 
	`Reg
(
	`Boﬁ
())

360 
vÆ
 
p°‹e1_vÆid_likñy
 = 
s2_vÆid
 && 
s2_wrôe
 || 
p°‹e1_hñd


361 
vÆ
 
p°‹e1_vÆid_¥e_kûl
 = 
s2_°‹e_vÆid_¥e_kûl
 || 
p°‹e1_hñd


362 
def
 
	`p°‹e1_vÆid_nŸ_rmw
(
s2_kûl
: 
Boﬁ
Ë
s2_vÆid_hô_¥e_d©a_ecc
 && (!
s2_waw_haz¨d
 || 
s2_°‹e_mîge
Ë&& 
s2_wrôe
 && !
s2_sc_Áû
 && !s2_kû»|| 
p°‹e1_hñd


363 
vÆ
 
p°‹e1_vÆid
 = 
s2_°‹e_vÆid
 || 
p°‹e1_hñd


364 
™y_p°‹e_vÆid
 :
p°‹e1_vÆid_¥e_kûl
 || 
p°‹e2_vÆid


365 
vÆ
 
p°‹e_døö_°ru˘uøl
 = 
p°‹e1_vÆid_likñy
 && 
p°‹e2_vÆid
 && ((
s1_vÆid
 && 
s1_wrôe
Ë|| 
p°‹e1_rmw
)

366 
	`as£π
(
p°‹e1_rmw
 || 
	`p°‹e1_vÆid_nŸ_rmw
(
io
.
˝u
.
s2_kûl
Ë==
p°‹e1_vÆid
)

367 
	`ccovî
(
p°‹e_døö_°ru˘uøl
, "STORE_STRUCTURAL_HAZARD", "D$Ñead-modify-write structural hazard")

368 
	`ccovî
(
p°‹e1_vÆid
 && 
p°‹e_døö_⁄_miss
, "STORE_DRAIN_ON_MISS", "D$ store buffer drain on miss")

369 
	`ccovî
(
s1_vÆid_nŸ_«cked
 && 
s1_waw_haz¨d
, "WAW_HAZARD", "D$ write-after-write hazard")

370 
def
 
	`should_p°‹e_døö
(
åuly
: 
Boﬁ
) = {

371 
vÆ
 
s2_kûl
 = 
åuly
 && 
io
.
˝u
.s2_kill

372 !
p°‹e1_mîge_likñy
 &&

373 (
	`Boﬁ
(
usögRMW
Ë&& 
p°‹e_døö_°ru˘uøl
 ||

374 (((
	`p°‹e1_vÆid_nŸ_rmw
(
s2_kûl
Ë&& !
p°‹e1_rmw
Ë|| 
p°‹e2_vÆid
Ë&& (
p°‹e_døö_›p‹tuni°ic
 || 
p°‹e_døö_⁄_miss
)))

376 
vÆ
 
p°‹e_døö
 = 
	`should_p°‹e_døö
(
åue
)

377 
p°‹e1_hñd
 :(
s2_°‹e_vÆid
 && !
s2_°‹e_mîge
 ||Ö°‹e1_hñdË&& 
p°‹e2_vÆid
 && !
p°‹e_døö


378 
vÆ
 
adv™˚_p°‹e1
 = (
p°‹e1_vÆid
 || 
s2_vÆid_c‹ª˘
Ë&& (
p°‹e2_vÆid
 ==
p°‹e_døö
)

379 
p°‹e2_vÆid
 :p°‹e2_vÆid && !
p°‹e_døö
 || 
adv™˚_p°‹e1


380 
vÆ
 
p°‹e2_addr
 = 
	`RegE«bÀ
(
	`Mux
(
s2_c‹ª˘
, 
s2_vaddr
, 
p°‹e1_addr
), 
adv™˚_p°‹e1
)

381 
vÆ
 
p°‹e2_way
 = 
	`RegE«bÀ
(
	`Mux
(
s2_c‹ª˘
, 
s2_hô_way
, 
p°‹e1_way
), 
adv™˚_p°‹e1
)

382 
vÆ
 
p°‹e2_°‹egí_d©a
 = {

383 
i
 <- 0 
u¡û
 
w‹dByãs
)

384 
yõld
 
	`RegE«bÀ
(
	`p°‹e1_°‹egí_d©a
(8*(
i
+1)-1, 8*i), 
adv™˚_p°‹e1
 || 
p°‹e1_mîge
 && 
	`p°‹e1_mask
(i))

385 }.
asUI¡


386 
vÆ
 
p°‹e2_°‹egí_mask
 = {

387 
vÆ
 
mask
 = 
	`Reg
(
	`UI¡
(
width
 = 
w‹dByãs
))

388 
	`whí
 (
adv™˚_p°‹e1
 || 
p°‹e1_mîge
) {

389 
vÆ
 
mîgedMask
 = 
p°‹e1_mask
 | 
	`Mux
(
p°‹e1_mîge
, 
mask
, 0.U)

390 
mask
 :~
	`Mux
(
s2_c‹ª˘
, 0.U, ~
mîgedMask
)

392 
mask


394 
s2_°‹e_mîge
 :(i‡(
eccByãs
 =1Ë
Ál£
.
B
 {

395 
	`ccovî
(
p°‹e1_mîge
, "STORE_MERGED", "D$ store merged")

398 
vÆ
 
w‹dM©ch
 = (
	`eccMask
(
p°‹e2_°‹egí_mask
Ë| ~eccMask(
p°‹e1_mask
)).
™dR


399 
vÆ
 
idxM©ch
 = 
	`s2_vaddr
(
u¡agBôs
-1, 
	`log2Ceû
(
w‹dByãs
)Ë==
	`p°‹e2_addr
(untagBits-1,Üog2Ceil(wordBytes))

400 
vÆ
 
ègM©ch
 = (
s2_hô_way
 & 
p°‹e2_way
).
‹R


401 
p°‹e2_vÆid
 && 
w‹dM©ch
 && 
idxM©ch
 && 
ègM©ch


403 
d©aArb
.
io
.
	`ö
(0).
vÆid
 :
	`should_p°‹e_døö
(
Ál£
)

404 
d©aArb
.
io
.
	`ö
(0).
bôs
.
wrôe
 :
p°‹e_døö


405 
d©aArb
.
io
.
	`ö
(0).
bôs
.
addr
 :
	`Mux
(
p°‹e2_vÆid
, 
p°‹e2_addr
, 
p°‹e1_addr
)

406 
d©aArb
.
io
.
	`ö
(0).
bôs
.
way_í
 :
	`Mux
(
p°‹e2_vÆid
, 
p°‹e2_way
, 
p°‹e1_way
)

407 
d©aArb
.
io
.
	`ö
(0).
bôs
.
wd©a
 :
	`Fûl
(
rowW‹ds
, 
	`Mux
(
p°‹e2_vÆid
, 
p°‹e2_°‹egí_d©a
, 
p°‹e1_d©a
))

408 
d©aArb
.
io
.
	`ö
(0).
bôs
.
pois⁄
 :
Ál£


409 
d©aArb
.
io
.
	`ö
(0).
bôs
.
w‹dMask
 :
	`UI¡ToOH
(
	`Mux
(
p°‹e2_vÆid
, 
p°‹e2_addr
, 
p°‹e1_addr
).
	`exåa˘
(
rowOffBôs
-1,
off£ésb
))

410 
d©aArb
.
io
.
	`ö
(0).
bôs
.
eccMask
 :
	`eccMask
(
	`Mux
(
p°‹e2_vÆid
, 
p°‹e2_°‹egí_mask
, 
p°‹e1_mask
))

413 
def
 
	`s1Dïíds
(
addr
: 
UI¡
, 
mask
: UInt) =

414 
	`addr
(
idxMSB
, 
w‹dOffBôs
Ë==
s1_ªq
.addr(idxMSB, wordOffBits) &&

415 
	`Mux
(
s1_wrôe
, (
	`eccByãMask
(
mask
Ë&ÉccByãMask(
s1_mask
)).
‹R
, (mask & s1_mask).orR)

416 
vÆ
 
s1_haz¨d
 =

417 (
p°‹e1_vÆid_¥e_kûl
 && 
	`s1Dïíds
(
p°‹e1_addr
, 
p°‹e1_mask
)) ||

418 (
p°‹e2_vÆid
 && 
	`s1Dïíds
(
p°‹e2_addr
, 
p°‹e2_°‹egí_mask
))

419 
vÆ
 
s1_øw_haz¨d
 = 
s1_ªad
 && 
s1_haz¨d


420 
s1_waw_haz¨d
 :(i‡(
eccByãs
 =1Ë
Ál£
.
B
 {

421 
	`ccovî
(
s1_vÆid_nŸ_«cked
 && 
s1_waw_haz¨d
, "WAW_HAZARD", "D$ write-after-write hazard")

422 
s1_wrôe
 && (
s1_haz¨d
 || 
	`√edsRód
(
s1_ªq
Ë&& !
s1_did_ªad
)

424 
	`whí
 (
s1_vÆid
 && 
s1_øw_haz¨d
Ë{ 
s1_«ck
 :
åue
 }

427 
io
.
˝u
.
s2_«ck_ˇu£_øw
 :
	`RegNext
(
s1_øw_haz¨d
)

430 
vÆ
 
a_sour˚
 = 
	`Pri‹ôyEncodî
(~
unˇchedInFlight
.
asUI¡
 << 
mmioOff£t
)

431 
vÆ
 
acquúe_addªss
 = (
s2_ªq
.
addr
 >> 
idxLSB
) << idxLSB

432 
vÆ
 
ac˚ss_addªss
 = 
s2_ªq
.
addr


433 
vÆ
 
a_size
 = 
	`mtSize
(
s2_ªq
.
typ
)

434 
vÆ
 
a_d©a
 = 
	`Fûl
(
bótW‹ds
, 
p°‹e1_d©a
)

435 
vÆ
 
gë
 = 
edge
.
	`Gë
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
).
_2


436 
vÆ
 
put
 = 
edge
.
	`Put
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
).
_2


437 
vÆ
 
©omics
 = i‡(
edge
.
m™agî
.
™ySuµ‹tLogiˇl
) {

438 
	`MuxLookup
(
s2_ªq
.
cmd
, 
	`Wúe
(
√w
 
	`TLBundÀA
(
edge
.
bundÀ
)), 
	`Aºay
(

439 
M_XA_SWAP
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
SWAP
).
_2
,

440 
M_XA_XOR
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
XOR
Ë.
_2
,

441 
M_XA_OR
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
OR
Ë.
_2
,

442 
M_XA_AND
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
AND
Ë.
_2
,

443 
M_XA_ADD
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
ADD
).
_2
,

444 
M_XA_MIN
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MIN
).
_2
,

445 
M_XA_MAX
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAX
).
_2
,

446 
M_XA_MINU
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MINU
).
_2
,

447 
M_XA_MAXU
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
ac˚ss_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAXU
).
_2
))

450 
	`as£π
 (!(
é_out_a
.
vÆid
 && 
s2_ªad
 && 
s2_wrôe
 && 
s2_unˇched
))

451 
	`Wúe
(
√w
 
	`TLBundÀA
(
edge
.
bundÀ
))

454 
é_out_a
.
vÆid
 :!
io
.
˝u
.
s2_kûl
 && ((
s2_vÆid_ˇched_miss
 && (
	`Boﬁ
(
ˇcheP¨ams
.
acquúeBef‹eRñó£
Ë|| !
s2_vi˘im_dúty
)Ë|| 
s2_vÆid_unˇched_≥ndög
)

455 
é_out_a
.
bôs
 :
	`Mux
(!
s2_unˇched
, 
	`acquúe
(
s2_vaddr
, 
s2_ªq
.
addr
, 
s2_grow_∑øm
), Mux(!
s2_wrôe
, 
gë
, Mux(!
s2_ªad
, 
put
, 
©omics
)))

458 
vÆ
 
a_£l
 = 
	`UI¡ToOH
(
a_sour˚
, 
maxUnˇchedInFlight
+
mmioOff£t
) >> mmioOffset

459 
	`whí
 (
é_out_a
.
	`fúe
()) {

460 
	`whí
 (
s2_unˇched
) {

461 (
a_£l
.
toBoﬁs
 
	`zù
 (
unˇchedInFlight
 
zù
 
unˇchedReqs
)Ë
f‹óch
 { (
s
, (
f
, 
r
)) =>

462 
	`whí
 (
s
) {

463 
f
 :
	`Boﬁ
(
åue
)

464 
r
 :
s2_ªq


467 }.
Ÿhîwi£
 {

468 
ˇched_gø¡_waô
 :
åue


473 
	`vÆ
 (
d_fú°
, 
d_œ°
, 
d_d⁄e
, 
d_addªss_öc
Ë
edge
.
	`addr_öc
(
é_out
.
d
)

474 
	`vÆ
 (
d_›c
, 
gø¡IsUnˇched
, 
gø¡IsUnˇchedD©a
) = {

475 
vÆ
 
unˇchedGø¡OpcodesS™sD©a
 = 
	`Seq
(
Ac˚ssAck
, 
HötAck
)

476 
vÆ
 
unˇchedGø¡OpcodesWôhD©a
 = 
	`Seq
(
Ac˚ssAckD©a
)

477 
vÆ
 
unˇchedGø¡Opcodes
 = 
unˇchedGø¡OpcodesWôhD©a
 ++ 
unˇchedGø¡OpcodesS™sD©a


478 
vÆ
 
whﬁe_›c
 = 
é_out
.
d
.
bôs
.
›code


479 i‡(
usögD©aS¸©ch∑d
) {

480 
	`as£π
(!
é_out
.
d
.
vÆid
 || 
whﬁe_›c
.
	`isO√Of
(
unˇchedGø¡Opcodes
))

482 
vÆ
 
›c
 = 
	`whﬁe_›c
(
unˇchedGø¡Opcodes
.
	`m≠
(
_
.
gëWidth
).
max
 - 1, 0)

483 
vÆ
 
d©a
 = 
	`DecodeLogic
(
›c
, 
unˇchedGø¡OpcodesWôhD©a
, 
unˇchedGø¡OpcodesS™sD©a
)

484 (
›c
, 
åue
.
B
, 
d©a
)

486 (
whﬁe_›c
, whﬁe_›c.
	`isO√Of
(
unˇchedGø¡Opcodes
), whﬁe_›c.isO√Of(
unˇchedGø¡OpcodesWôhD©a
))

489 
vÆ
 
gø¡IsCached
 = 
d_›c
.
	`isO√Of
(
Gø¡
, 
Gø¡D©a
)

490 
vÆ
 
gø¡IsVﬁu¡¨y
 = 
d_›c
 ==
Rñó£Ack


491 
vÆ
 
gø¡IsRefûl
 = 
d_›c
 ==
Gø¡D©a


492 
vÆ
 
gø¡InProgªss
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

493 
vÆ
 
blockProbeA·îGø¡Cou¡
 = 
	`Reg
(
öô
=
	`UI¡
(0))

494 
	`whí
 (
blockProbeA·îGø¡Cou¡
 > 0) { blockProbeAfterGrantCount := blockProbeAfterGrantCount - 1 }

495 
vÆ
 
ˇnAc˚±CachedGø¡
 = i‡(
ˇcheP¨ams
.
acquúeBef‹eRñó£
Ë!
ªÀa£_°©e
.
	`isO√Of
(
s_vﬁu¡¨y_wrôeback
, 
s_vﬁu¡¨y_wrôe_mëa
Ë
åue
.
B


496 
é_out
.
d
.
ªady
 :
	`Mux
(
gø¡IsCached
, (!
d_fú°
 ||Ål_out.
e
.ªadyË&& 
ˇnAc˚±CachedGø¡
, 
åue
.
B
)

497 
	`whí
 (
é_out
.
d
.
	`fúe
()) {

498 
	`whí
 (
gø¡IsCached
) {

499 
gø¡InProgªss
 :
åue


500 
	`as£π
(
ˇched_gø¡_waô
, "A GrantData was unexpected byÅhe dcache.")

501 
	`whí
(
d_œ°
) {

502 
ˇched_gø¡_waô
 :
Ál£


503 
gø¡InProgªss
 :
Ál£


504 
blockProbeA·îGø¡Cou¡
 :
blockProbeA·îGø¡Cy˛es
 - 1

505 
ª∂a˚r
.
miss


507 } .
	`ñ£whí
 (
gø¡IsUnˇched
) {

508 
vÆ
 
d_£l
 = 
	`UI¡ToOH
(
é_out
.
d
.
bôs
.
sour˚
, 
maxUnˇchedInFlight
+
mmioOff£t
) >> mmioOffset

509 
vÆ
 
ªq
 = 
	`Mux1H
(
d_£l
, 
unˇchedReqs
)

510 (
d_£l
.
toBoﬁs
 
zù
 
unˇchedInFlight
Ë
f‹óch
 { (
s
, 
f
) =>

511 
	`whí
 (
s
 && 
d_œ°
) {

512 
	`as£π
(
f
, "An AccessAck was unexpected byÅhe dcache.")

513 
f
 :
Ál£


516 
	`whí
 (
gø¡IsUnˇchedD©a
) {

517 i‡(!
ˇcheP¨ams
.
pùñöeWayMux
)

518 
s1_d©a_way
 :1.U << 
nWays


519 
s2_ªq
.
cmd
 :
M_XRD


520 
s2_ªq
.
typ
 :
ªq
.typ

521 
s2_ªq
.
èg
 :
ªq
.tag

522 
s2_ªq
.
addr
 := {

523 
	`ªquúe
(
rowOffBôs
 >
bótOffBôs
)

524 
vÆ
 
d⁄tC¨eBôs
 = 
s1_∑ddr
 >> 
rowOffBôs
 <<ÑowOffBits

525 
d⁄tC¨eBôs
 | 
ªq
.
	`addr
(
bótOffBôs
-1, 0)

527 
s2_unˇched_ª•_addr
 :
ªq
.
addr


529 } .
	`ñ£whí
 (
gø¡IsVﬁu¡¨y
) {

530 
	`as£π
(
ªÀa£_ack_waô
, "A ReleaseAck was unexpected byÅhe dcache.")

531 
ªÀa£_ack_waô
 :
Ál£


536 
é_out
.
e
.
vÆid
 :é_out.
d
.vÆid && 
d_fú°
 && 
gø¡IsCached
 && 
ˇnAc˚±CachedGø¡


537 
é_out
.
e
.
bôs
 :
edge
.
	`Gø¡Ack
—l_out.
d
.bits)

538 
	`as£π
(
é_out
.
e
.
	`fúe
(Ë==—l_out.
d
.fúe(Ë&& 
d_fú°
 && 
gø¡IsCached
))

543 
d©aArb
.
io
.
	`ö
(1).
vÆid
 :
é_out
.
d
.vÆid && 
gø¡IsRefûl
 && 
ˇnAc˚±CachedGø¡


544 
	`whí
 (
gø¡IsRefûl
 && !
d©aArb
.
io
.
	`ö
(1).
ªady
) {

545 
é_out
.
e
.
vÆid
 :
Ál£


546 
é_out
.
d
.
ªady
 :
Ál£


548 i‡(!
usögD©aS¸©ch∑d
) {

549 
d©aArb
.
io
.
	`ö
(1).
bôs
.
wrôe
 :
åue


550 
d©aArb
.
io
.
	`ö
(1).
bôs
.
addr
 :(
s2_vaddr
 >> 
idxLSB
Ë<< idxLSB | 
d_addªss_öc


551 
d©aArb
.
io
.
	`ö
(1).
bôs
.
way_í
 :
s2_vi˘im_way


552 
d©aArb
.
io
.
	`ö
(1).
bôs
.
wd©a
 :
é_out
.
d
.bôs.
d©a


553 
d©aArb
.
io
.
	`ö
(1).
bôs
.
pois⁄
 :
é_out
.
d
.bôs.
c‹ru±


554 
d©aArb
.
io
.
	`ö
(1).
bôs
.
w‹dMask
 :~
	`UI¡
(0, 
rowByãs
 / 
w‹dByãs
)

555 
d©aArb
.
io
.
	`ö
(1).
bôs
.
eccMask
 :~
	`UI¡
(0, 
w‹dByãs
 / 
eccByãs
)

557 
d©aArb
.
io
.
	`ö
(1).
bôs
 := dataArb.io.in(0).bits

564 
mëaArb
.
io
.
	`ö
(3).
vÆid
 :
gø¡IsCached
 && 
d_d⁄e
 && !
é_out
.
d
.
bôs
.
díõd


565 
mëaArb
.
io
.
	`ö
(3).
bôs
.
wrôe
 :
åue


566 
mëaArb
.
io
.
	`ö
(3).
bôs
.
way_í
 :
s2_vi˘im_way


567 
mëaArb
.
io
.
	`ö
(3).
bôs
.
idx
 :
	`s2_vaddr
(
idxMSB
, 
idxLSB
)

568 
mëaArb
.
io
.
	`ö
(3).
bôs
.
addr
 :
	`C©
(io.
˝u
.
ªq
.bôs.add∏>> 
u¡agBôs
, 
	`s2_vaddr
(
idxMSB
, 0))

569 
mëaArb
.
io
.
	`ö
(3).
bôs
.
d©a
 :
tECC
.
	`ícode
(
	`L1Mëad©a
(
s2_ªq
.
addr
 >> 
ègLSB
, 
s2_hô_°©e
.
	`⁄Gø¡
(s2_ªq.
cmd
, 
é_out
.
d
.bôs.
∑øm
)).
asUI¡
)

572 
vÆ
 
blockUnˇchedGø¡
 = 
	`Reg
(
	`Boﬁ
())

573 
blockUnˇchedGø¡
 :
d©aArb
.
io
.
out
.
vÆid


574 
	`whí
 (
gø¡IsUnˇchedD©a
 && (
blockUnˇchedGø¡
 || 
s1_vÆid
)) {

575 
é_out
.
d
.
ªady
 :
Ál£


577 
	`whí
 (
é_out
.
d
.
vÆid
) {

578 
io
.
˝u
.
ªq
.
ªady
 :
Ál£


579 
d©aArb
.
io
.
	`ö
(1).
vÆid
 :
åue


580 
d©aArb
.
io
.
	`ö
(1).
bôs
.
wrôe
 :
Ál£


581 
blockUnˇchedGø¡
 :!
d©aArb
.
io
.
	`ö
(1).
ªady


584 
	`ccovî
(
é_out
.
d
.
vÆid
 && !é_out.d.
ªady
, "BLOCK_D", "D$ D-channel blocked")

587 
vÆ
 
block_¥obe
 = 
ªÀa£InFlight
 || 
gø¡InProgªss
 || 
blockProbeA·îGø¡Cou¡
 > 0 || 
ÃscVÆid


588 
mëaArb
.
io
.
	`ö
(6).
vÆid
 :
é_out
.
b
.vÆid && (!
block_¥obe
 || 
ÃscBackögOff
)

589 
é_out
.
b
.
ªady
 :
mëaArb
.
io
.
	`ö
(6).ªady && !
block_¥obe
 && !
s1_vÆid
 && !
s2_vÆid


590 
mëaArb
.
io
.
	`ö
(6).
bôs
.
wrôe
 :
Ál£


591 
mëaArb
.
io
.
	`ö
(6).
bôs
.
idx
 :
	`¥obeIdx
(
é_out
.
b
.bits)

592 
mëaArb
.
io
.
	`ö
(6).
bôs
.
addr
 :
	`C©
(io.
˝u
.
ªq
.bôs.add∏>> 
∑ddrBôs
, 
é_out
.
b
.bôs.
addªss
)

593 
mëaArb
.
io
.
	`ö
(6).
bôs
.
way_í
 := metaArb.io.in(4).bits.way_en

594 
mëaArb
.
io
.
	`ö
(6).
bôs
.
d©a
 := metaArb.io.in(4).bits.data

597 
	`vÆ
 (
c_fú°
, 
c_œ°
, 
ªÀa£D⁄e
, 
c_cou¡
Ë
edge
.
	`cou¡
(
é_out_c
)

598 
vÆ
 
ªÀa£Reje˘ed
 = 
é_out_c
.
vÆid
 && !é_out_c.
ªady


599 
vÆ
 
s1_ªÀa£_d©a_vÆid
 = 
	`Reg
(
√xt
 = 
d©aArb
.
io
.
	`ö
(2).
	`fúe
())

600 
vÆ
 
s2_ªÀa£_d©a_vÆid
 = 
	`Reg
(
√xt
 = 
s1_ªÀa£_d©a_vÆid
 && !
ªÀa£Reje˘ed
)

601 
vÆ
 
ªÀa£D©aBót
 = 
	`C©
(
	`UI¡
(0), 
c_cou¡
Ë+ 
	`Mux
(
ªÀa£Reje˘ed
, UI¡(0), 
s1_ªÀa£_d©a_vÆid
 + C©(UI¡(0), 
s2_ªÀa£_d©a_vÆid
))

602 
vÆ
 
wrôeback_d©a_îr‹
 = 
s2_d©a_decoded
.
	`m≠
(
_
.
îr‹
).
	`ªdu˚
(_||_)

603 
vÆ
 
wrôeback_d©a_unc‹ª˘abÀ
 = 
s2_d©a_decoded
.
	`m≠
(
_
.
unc‹ª˘abÀ
).
	`ªdu˚
(_||_)

605 
vÆ
 
«ckRe•⁄£Mesßge
 = 
edge
.
	`ProbeAck
(
b
 = 
¥obe_bôs
, 
ªp‹tPîmissi⁄s
 = 
TLPîmissi⁄s
.
NtoN
)

606 
vÆ
 
˛ónRñó£Mesßge
 = 
edge
.
	`ProbeAck
(
b
 = 
¥obe_bôs
, 
ªp‹tPîmissi⁄s
 = 
s2_ªp‹t_∑øm
)

607 
vÆ
 
dútyRñó£Mesßge
 = 
edge
.
	`ProbeAck
(
b
 = 
¥obe_bôs
, 
ªp‹tPîmissi⁄s
 = 
s2_ªp‹t_∑øm
, 
d©a
 = 0.U)

609 
é_out_c
.
vÆid
 :
s2_ªÀa£_d©a_vÆid


610 
é_out_c
.
bôs
 :
«ckRe•⁄£Mesßge


611 
vÆ
 
√wCoh
 = 
	`Wúe
(
öô
 = 
¥obeNewCoh
)

612 
ªÀa£Way
 :
s2_¥obe_way


614 i‡(!
usögD©aS¸©ch∑d
) {

615 
	`whí
 (
s2_vi˘imize
 && 
s2_vi˘im_dúty
) {

616 
	`as£π
(!(
s2_vÆid
 && 
s2_hô_vÆid
 && !
s2_d©a_îr‹
))

617 
ªÀa£_°©e
 :
s_vﬁu¡¨y_wrôeback


618 
¥obe_bôs
 :
	`addªssToProbe
(
s2_vaddr
, 
	`C©
(
s2_vi˘im_èg
, 
s2_ªq
.
	`addr
(
ègLSB
-1, 
idxLSB
)) << idxLSB)

620 
	`whí
 (
s2_¥obe
) {

621 
vÆ
 
¥obeNack
 = 
	`Wúe
(
öô
 = 
åue
.
B
)

622 
	`whí
 (
s2_mëa_îr‹
) {

623 
ªÀa£_°©e
 :
s_¥obe_ªåy


624 }.
	`ñ£whí
 (
s2_¥b_ack_d©a
) {

625 
ªÀa£_°©e
 :
s_¥obe_ªp_dúty


626 }.
	`ñ£whí
 (
s2_¥obe_°©e
.
	`isVÆid
()) {

627 
é_out_c
.
vÆid
 :
åue


628 
é_out_c
.
bôs
 :
˛ónRñó£Mesßge


629 
ªÀa£_°©e
 :
	`Mux
(
ªÀa£D⁄e
, 
s_¥obe_wrôe_mëa
, 
s_¥obe_ªp_˛ón
)

630 }.
Ÿhîwi£
 {

631 
é_out_c
.
vÆid
 :
åue


632 
¥obeNack
 :!
ªÀa£D⁄e


633 
ªÀa£_°©e
 :
	`Mux
(
ªÀa£D⁄e
, 
s_ªady
, 
s_¥obe_ªp_miss
)

635 
	`whí
 (
¥obeNack
Ë{ 
s1_«ck
 :
åue
 }

637 
	`whí
 (
ªÀa£_°©e
 ==
s_¥obe_ªåy
) {

638 
mëaArb
.
io
.
	`ö
(6).
vÆid
 :
åue


639 
mëaArb
.
io
.
	`ö
(6).
bôs
.
idx
 :
	`¥obeIdx
(
¥obe_bôs
)

640 
mëaArb
.
io
.
	`ö
(6).
bôs
.
addr
 :
	`C©
(io.
˝u
.
ªq
.bôs.add∏>> 
∑ddrBôs
, 
¥obe_bôs
.
addªss
)

641 
	`whí
 (
mëaArb
.
io
.
	`ö
(6).
ªady
) {

642 
ªÀa£_°©e
 :
s_ªady


643 
s1_¥obe
 :
åue


646 
	`whí
 (
ªÀa£_°©e
 ==
s_¥obe_ªp_miss
) {

647 
é_out_c
.
vÆid
 :
åue


648 
	`whí
 (
ªÀa£D⁄e
Ë{ 
ªÀa£_°©e
 :
s_ªady
 }

650 
	`whí
 (
ªÀa£_°©e
 ==
s_¥obe_ªp_˛ón
) {

651 
é_out_c
.
vÆid
 :
åue


652 
é_out_c
.
bôs
 :
˛ónRñó£Mesßge


653 
	`whí
 (
ªÀa£D⁄e
Ë{ 
ªÀa£_°©e
 :
s_¥obe_wrôe_mëa
 }

655 
	`whí
 (
ªÀa£_°©e
 ==
s_¥obe_ªp_dúty
) {

656 
é_out_c
.
bôs
 :
dútyRñó£Mesßge


657 
	`whí
 (
ªÀa£D⁄e
Ë{ 
ªÀa£_°©e
 :
s_¥obe_wrôe_mëa
 }

659 
	`whí
 (
ªÀa£_°©e
.
	`isO√Of
(
s_vﬁu¡¨y_wrôeback
, 
s_vﬁu¡¨y_wrôe_mëa
)) {

660 
é_out_c
.
bôs
 :
edge
.
	`Rñó£
(
‰omSour˚
 = 0.U,

661 
toAddªss
 = 0.U,

662 
lgSize
 = 
lgCacheBlockByãs
,

663 
shrökPîmissi⁄s
 = 
s2_shrök_∑øm
,

664 
d©a
 = 0.U).
_2


665 
√wCoh
 :
vﬁu¡¨yNewCoh


666 
ªÀa£Way
 :
s2_vi˘im_way


667 
	`whí
 (
ªÀa£D⁄e
Ë{ 
ªÀa£_°©e
 :
s_vﬁu¡¨y_wrôe_mëa
 }

668 
	`whí
 (
é_out_c
.
	`fúe
(Ë&& 
c_fú°
Ë{ 
ªÀa£_ack_waô
 :
åue
 }

670 
é_out_c
.
bôs
.
sour˚
 :
¥obe_bôs
.source

671 
é_out_c
.
bôs
.
addªss
 :
¥obe_bôs
.address

672 
é_out_c
.
bôs
.
d©a
 :
s2_d©a_c‹ª˘ed


673 
é_out_c
.
bôs
.
c‹ru±
 :
öWrôeback
 && 
wrôeback_d©a_unc‹ª˘abÀ


676 
d©aArb
.
io
.
	`ö
(2).
vÆid
 :
öWrôeback
 && 
ªÀa£D©aBót
 < 
ªfûlCy˛es


677 
d©aArb
.
io
.
	`ö
(2).
bôs
 := dataArb.io.in(1).bits

678 
d©aArb
.
io
.
	`ö
(2).
bôs
.
wrôe
 :
Ál£


679 
d©aArb
.
io
.
	`ö
(2).
bôs
.
addr
 :(
	`¥obeIdx
(
¥obe_bôs
Ë<< 
blockOffBôs
Ë| (
	`ªÀa£D©aBót
(
	`log2Up
(
ªfûlCy˛es
)-1,0Ë<< 
rowOffBôs
)

680 
d©aArb
.
io
.
	`ö
(2).
bôs
.
w‹dMask
 :~
	`UI¡
(0, 
rowByãs
 / 
w‹dByãs
)

681 
d©aArb
.
io
.
	`ö
(2).
bôs
.
way_í
 :~
	`UI¡
(0, 
nWays
)

683 
mëaArb
.
io
.
	`ö
(4).
vÆid
 :
ªÀa£_°©e
.
	`isO√Of
(
s_vﬁu¡¨y_wrôe_mëa
, 
s_¥obe_wrôe_mëa
)

684 
mëaArb
.
io
.
	`ö
(4).
bôs
.
wrôe
 :
åue


685 
mëaArb
.
io
.
	`ö
(4).
bôs
.
way_í
 :
ªÀa£Way


686 
mëaArb
.
io
.
	`ö
(4).
bôs
.
idx
 :
	`¥obeIdx
(
¥obe_bôs
)

687 
mëaArb
.
io
.
	`ö
(4).
bôs
.
addr
 :
	`C©
(io.
˝u
.
ªq
.bôs.add∏>> 
u¡agBôs
, 
¥obe_bôs
.
	`addªss
(
idxMSB
, 0))

688 
mëaArb
.
io
.
	`ö
(4).
bôs
.
d©a
 :
tECC
.
	`ícode
(
	`L1Mëad©a
(
é_out_c
.bôs.
addªss
 >> 
ègLSB
, 
√wCoh
).
asUI¡
)

689 
	`whí
 (
mëaArb
.
io
.
	`ö
(4).
	`fúe
()Ë{ 
ªÀa£_°©e
 :
s_ªady
 }

692 
io
.
˝u
.
ª•
.
vÆid
 :
s2_vÆid_hô


693 
io
.
˝u
.
ª•
.
bôs
 <> 
s2_ªq


694 
io
.
˝u
.
ª•
.
bôs
.
has_d©a
 :
s2_ªad


695 
io
.
˝u
.
ª•
.
bôs
.
ª∂ay
 :
Ál£


699 
vÆ
 
s1_isSœveP‹tAc˚ss
 = 
usögD©aS¸©ch∑d
 && 
s1_ªq
.
phys


700 
vÆ
 
s2_isSœveP‹tAc˚ss
 = 
usögD©aS¸©ch∑d
 && 
s2_ªq
.
phys


701 
io
.
˝u
.
‹dîed
 :!(
s1_vÆid
 && !
s1_isSœveP‹tAc˚ss
 || 
s2_vÆid
 && !
s2_isSœveP‹tAc˚ss
 || 
ˇched_gø¡_waô
 || 
unˇchedInFlight
.
asUI¡
.
‹R
)

703 
vÆ
 
s1_x˝t_vÆid
 = 
éb
.
io
.
ªq
.
vÆid
 && !
s1_«ck


704 
vÆ
 
s1_x˝t
 = 
éb
.
io
.
ª•


705 
io
.
˝u
.
s2_x˝t
 :
	`Mux
(
	`RegNext
(
s1_x˝t_vÆid
), 
	`RegE«bÀ
(
s1_x˝t
, 
s1_vÆid_nŸ_«cked
), 0.U.a
	`sTy≥Of
(s1_xcpt))

707 i‡(
usögD©aS¸©ch∑d
) {

708 
	`ªquúe
(!
usögVM
)

709 
	`whí
 (
s2_isSœveP‹tAc˚ss
) {

710 
	`as£π
(!
s2_vÆid
 || 
s2_hô_vÆid
)

711 
io
.
˝u
.
s2_x˝t
 :0.U.a
	`sTy≥Of
(io.cpu.s2_xcpt)

713 
	`as£π
(!(
s2_vÆid_masked
 && 
s2_ªq
.
cmd
.
	`isO√Of
(
M_XLR
, 
M_XSC
)))

715 
	`ccovî
(
é_out
.
b
.
vÆid
 && !é_out.b.
ªady
, "BLOCK_B", "D$ B-channel blocked")

719 
io
.
˝u
.
ª∂ay_√xt
 :
é_out
.
d
.
	`fúe
(Ë&& 
gø¡IsUnˇchedD©a


720 
vÆ
 
doUnˇchedRe•
 = 
	`Reg
(
√xt
 = 
io
.
˝u
.
ª∂ay_√xt
)

721 
vÆ
 
s2_unˇched_d©a_bót
 = 
	`RegE«bÀ
(
é_out
.
d
.
bôs
.
d©a
, 
io
.
˝u
.
ª∂ay_√xt
)

722 
	`whí
 (
doUnˇchedRe•
) {

723 
	`as£π
(!
s2_vÆid_hô
)

724 
io
.
˝u
.
ª•
.
vÆid
 :
åue


725 
io
.
˝u
.
ª•
.
bôs
.
ª∂ay
 :
åue


726 
io
.
˝u
.
ª•
.
bôs
.
addr
 :
s2_unˇched_ª•_addr


730 
vÆ
 
s2_d©a_w‹d
 = ((0 
u¡û
 
rowBôs
 
by
 
w‹dBôs
).
	`m≠
(
i
 => 
	`s2_d©a_unc‹ª˘ed
(w‹dBôs+i-1,i)): 
Seq
[
UI¡
])(
s2_w‹d_idx
)

731 
vÆ
 
s2_d©a_w‹d_c‹ª˘ed
 = ((0 
u¡û
 
rowBôs
 
by
 
w‹dBôs
).
	`m≠
(
i
 => 
	`s2_d©a_c‹ª˘ed
(w‹dBôs+i-1,i)): 
Seq
[
UI¡
])(
s2_w‹d_idx
)

732 
vÆ
 
s2_unˇched_d©a_w‹d
 = ((0 
u¡û
 
ˇcheD©aBôs
 
by
 
w‹dBôs
).
	`m≠
(
i
 => 
	`s2_unˇched_d©a_bót
(w‹dBôs+i-1,i)): 
Seq
[
UI¡
])(
s2_w‹d_idx
)

733 
vÆ
 
s2_d©a_w‹d_possibly_unˇched
 = 
	`Mux
(
ˇcheP¨ams
.
pùñöeWayMux
 && 
doUnˇchedRe•
, 
s2_unˇched_d©a_w‹d
, 
s2_d©a_w‹d
)

734 
vÆ
 
lﬂdgí
 = 
√w
 
	`LﬂdGí
(
s2_ªq
.
typ
, 
	`mtSig√d
(s2_ªq.typ), s2_ªq.
addr
, 
s2_d©a_w‹d_possibly_unˇched
, 
s2_sc
, 
w‹dByãs
)

735 
io
.
˝u
.
ª•
.
bôs
.
d©a
 :
lﬂdgí
.d©®| 
s2_sc_Áû


736 
io
.
˝u
.
ª•
.
bôs
.
d©a_w‹d_by∑ss
 :
lﬂdgí
.
w‹dD©a


737 
io
.
˝u
.
ª•
.
bôs
.
d©a_øw
 :
s2_d©a_w‹d


738 
io
.
˝u
.
ª•
.
bôs
.
°‹e_d©a
 :
p°‹e1_d©a


741 i‡(
usögRMW
) {

743 
vÆ
 
amﬂlu
 = 
	`ModuÀ
(
√w
 
	`AMOALU
(
c‹eD©aBôs
))

744 
amﬂlu
.
io
.
mask
 :
p°‹e1_mask


745 
amﬂlu
.
io
.
cmd
 :(i‡(
usögAtomicsInCache
Ë
p°‹e1_cmd
 
M_XWR
)

746 
amﬂlu
.
io
.
lhs
 :
s2_d©a_w‹d


747 
amﬂlu
.
io
.
rhs
 :
p°‹e1_d©a


748 
p°‹e1_°‹egí_d©a
 :(i‡(!
usögD©aS¸©ch∑d
Ë
amﬂlu
.
io
.
out
 {

749 
vÆ
 
mask
 = 
	`FûlI¡îÀaved
(8, 
	`Mux
(
s2_c‹ª˘
, 0.U, 
p°‹e1_mask
))

750 
amﬂlu
.
io
.
out_unmasked
 & 
mask
 | 
s2_d©a_w‹d_c‹ª˘ed
 & ~mask

752 } i‡(!
usögAtomics
) {

753 
	`as£π
(!(
s1_vÆid_masked
 && 
s1_ªad
 && 
s1_wrôe
), "unsupported D$ operation")

757 
vÆ
 
ª£âög
 = 
	`RegInô
(
Ál£
.
B
)

758 i‡(!
usögD©aS¸©ch∑d
)

759 
	`whí
 (
	`RegNext
(
ª£t
)Ë{ 
ª£âög
 :
åue
 }

760 
vÆ
 
Êushed
 = 
	`Reg
(
öô
=
	`Boﬁ
(
åue
))

761 
vÆ
 
Êushög
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

762 
vÆ
 
ÊushCou¡î
 = 
	`Reg
(
öô
=
	`UI¡
(
nSës
 * (
nWays
-1), 
	`log2Ceû
(nSets *ÇWays)))

763 
vÆ
 
ÊushCou¡îNext
 = 
ÊushCou¡î
 +& 1

764 
vÆ
 
ÊushD⁄e
 = (
ÊushCou¡îNext
 >> 
	`log2Ceû
(
nSës
)Ë==
nWays


765 
vÆ
 
ÊushCou¡îWøp
 = 
	`ÊushCou¡îNext
(
	`log2Ceû
(
nSës
)-1, 0)

766 
	`whí
 (
s2_vÆid_masked
 && 
s2_ªq
.
cmd
 ==
M_FLUSH_ALL
) {

767 
io
.
˝u
.
s2_«ck
 :!
Êushed


768 
	`whí
 (!
Êushed
) {

769 
Êushög
 :!
io
.
˝u
.
s2_kûl
 && !
ªÀa£_ack_waô
 && !
unˇchedInFlight
.
asUI¡
.
‹R


772 
	`ccovî
(
s2_vÆid_masked
 && 
s2_ªq
.
cmd
 ==
M_FLUSH_ALL
 && 
s2_mëa_îr‹
, "TAG_ECC_ERROR_DURING_FENCE_I", "D$ ECCÉrror inÅagárray during cache flush")

773 
	`ccovî
(
s2_vÆid_masked
 && 
s2_ªq
.
cmd
 ==
M_FLUSH_ALL
 && 
s2_d©a_îr‹
, "DATA_ECC_ERROR_DURING_FENCE_I", "D$ ECCÉrror in dataárray during cache flush")

774 
s1_Êush_vÆid
 :
mëaArb
.
io
.
	`ö
(5).
	`fúe
(Ë&& !s1_Êush_vÆid && !
s2_Êush_vÆid_¥e_èg_ecc
 && 
ªÀa£_°©e
 ==
s_ªady
 && !
ªÀa£_ack_waô


775 
mëaArb
.
io
.
	`ö
(5).
vÆid
 :
Êushög


776 
mëaArb
.
io
.
	`ö
(5).
bôs
.
wrôe
 :
Ál£


777 
mëaArb
.
io
.
	`ö
(5).
bôs
.
idx
 :
	`ÊushCou¡î
(
idxBôs
-1, 0)

778 
mëaArb
.
io
.
	`ö
(5).
bôs
.
addr
 :
	`C©
(io.
˝u
.
ªq
.bôs.add∏>> 
u¡agBôs
, mëaArb.io.ö(5).bôs.
idx
 << 
blockOffBôs
)

779 
mëaArb
.
io
.
	`ö
(5).
bôs
.
way_í
 := metaArb.io.in(4).bits.way_en

780 
mëaArb
.
io
.
	`ö
(5).
bôs
.
d©a
 := metaArb.io.in(4).bits.data

783 
vÆ
 
suµ‹ts_Êush
 = !
edge
.
m™agî
.
m™agîs
.
	`f‹Æl
(
m
 => !m.
suµ‹tsAcquúeT
 || !m.
execuèbÀ
 || m.
ªgi⁄Ty≥
 >
Regi⁄Ty≥
.
TRACKED
 || m.ªgi⁄Ty≥ <Regi⁄Ty≥.
UNCACHEABLE
)

784 i‡(
suµ‹ts_Êush
) {

785 
	`whí
 (
é_out_a
.
	`fúe
(Ë&& !
s2_unˇched
Ë{ 
Êushed
 :
Ál£
 }

786 
	`whí
 (
Êushög
) {

787 
s1_vi˘im_way
 :
ÊushCou¡î
 >> 
	`log2Up
(
nSës
)

788 
	`whí
 (
s2_Êush_vÆid
) {

789 
ÊushCou¡î
 :
ÊushCou¡îNext


790 
	`whí
 (
ÊushD⁄e
) {

791 
Êushed
 :
åue


792 i‡(!
	`isPow2
(
nWays
)Ë
ÊushCou¡î
 :
ÊushCou¡îWøp


795 
	`whí
 (
Êushed
 && 
ªÀa£_°©e
 ==
s_ªady
 && !
ªÀa£_ack_waô
) {

796 
Êushög
 :
Ál£


800 
mëaArb
.
io
.
	`ö
(0).
vÆid
 :
ª£âög


801 
mëaArb
.
io
.
	`ö
(0).
bôs
 := metaArb.io.in(5).bits

802 
mëaArb
.
io
.
	`ö
(0).
bôs
.
wrôe
 :
åue


803 
mëaArb
.
io
.
	`ö
(0).
bôs
.
way_í
 :~
	`UI¡
(0, 
nWays
)

804 
mëaArb
.
io
.
	`ö
(0).
bôs
.
d©a
 :
tECC
.
	`ícode
(
	`L1Mëad©a
(
s2_ªq
.
addr
 >> 
ègLSB
, 
Clõ¡Mëad©a
.
⁄Re£t
).
asUI¡
)

805 
	`whí
 (
ª£âög
) {

806 
ÊushCou¡î
 :
ÊushCou¡îNext


807 
	`whí
 (
ÊushD⁄e
) {

808 
ª£âög
 :
Ál£


809 i‡(!
	`isPow2
(
nWays
)Ë
ÊushCou¡î
 :
ÊushCou¡îWøp


814 
˛ock_í_ªg
 :
io
.
±w
.
cu°omCSRs
.
dißbÀDCacheClockG©e
 ||

815 
io
.
˝u
.
kìp_˛ock_íabÀd
 ||

816 
mëaArb
.
io
.
out
.
vÆid
 ||

817 
s1_¥obe
 || 
s2_¥obe
 ||

818 
s1_vÆid
 || 
s2_vÆid_¥e_x˝t
 ||

819 
p°‹e1_hñd
 || 
p°‹e2_vÆid
 ||

820 
ªÀa£_°©e
 =/
s_ªady
 ||

821 
ªÀa£_ack_waô
 || !
ªÀa£_queue_em±y
 ||

822 !
éb
.
io
.
ªq
.
ªady
 ||

823 
ˇched_gø¡_waô
 || 
unˇchedInFlight
.
asUI¡
.
‹R
 ||

824 
ÃscCou¡
 > 0 || 
blockProbeA·îGø¡Cou¡
 > 0

827 
io
.
˝u
.
≥rf
.
acquúe
 :
edge
.
	`d⁄e
(
é_out_a
)

828 
io
.
˝u
.
≥rf
.
ªÀa£
 :
edge
.
	`d⁄e
(
é_out_c
)

829 
io
.
˝u
.
≥rf
.
gø¡
 :
d_d⁄e


830 
io
.
˝u
.
≥rf
.
ébMiss
 :io.
±w
.
ªq
.
	`fúe
()

831 
io
.
˝u
.
≥rf
.
blocked
 := {

833 
vÆ
 
cy˛es
 = 
ouãr
.
buf„rUnˇchedReque°s
.
	`m≠
(
n
 => i‡“ > 1Ë1 2).
	`gëOrEl£
(2)

834 
ˇched_gø¡_waô
 && 
d_addªss_öc
 < ((
ˇcheBlockByãs
 - 
cy˛es
 * 
bótByãs
Ë
max
 0)

838 
	`vÆ
 (
d©a_îr‹
, 
d©a_îr‹_unc‹ª˘abÀ
, 
d©a_îr‹_addr
) =

839 i‡(
usögD©aS¸©ch∑d
Ë(
s2_vÆid_d©a_îr‹
, 
s2_d©a_îr‹_unc‹ª˘abÀ
, 
s2_ªq
.
addr
) {

840 (
	`RegNext
(
é_out_c
.
	`fúe
(Ë&& 
öWrôeback
 && 
wrôeback_d©a_îr‹
),

841 
	`RegNext
(
wrôeback_d©a_unc‹ª˘abÀ
),

842 
¥obe_bôs
.
addªss
)

845 
vÆ
 
îr‹_addr
 =

846 
	`Mux
(
mëaArb
.
io
.
	`ö
(1).
vÆid
, 
	`C©
(
s2_fú°_mëa_c‹ª˘ed
.
èg
, mëaArb.io.ö(1).
bôs
.
	`addr
(
ègLSB
-1, 
idxLSB
)),

847 
d©a_îr‹_addr
 >> 
idxLSB
) << idxLSB

848 
io
.
îr‹s
.
unc‹ª˘abÀ
.
f‹óch
 { 
u
 =>

849 
u
.
vÆid
 :
mëaArb
.
io
.
	`ö
(1).vÆid && 
s2_mëa_îr‹_unc‹ª˘abÀ
 || 
d©a_îr‹
 && 
d©a_îr‹_unc‹ª˘abÀ


850 
u
.
bôs
 :
îr‹_addr


852 
io
.
îr‹s
.
c‹ª˘abÀ
.
f‹óch
 { 
c
 =>

853 
c
.
vÆid
 :
mëaArb
.
io
.
	`ö
(1).vÆid || 
d©a_îr‹


854 
c
.
bôs
 :
îr‹_addr


855 
io
.
îr‹s
.
unc‹ª˘abÀ
.
f‹óch
 { 
u
 => 
	`whí
 (u.
vÆid
Ë{ 
c
.vÆid :
Ál£
 } }

857 
io
.
îr‹s
.
bus
.
vÆid
 :
é_out
.
d
.
	`fúe
(Ë&& (é_out.d.
bôs
.
díõd
 ||Ål_out.d.bôs.
c‹ru±
)

858 
io
.
îr‹s
.
bus
.
bôs
 :
	`Mux
(
gø¡IsCached
, 
s2_ªq
.
addr
 >> 
idxLSB
 << idxLSB, 0.U)

860 
	`ccovîNŸS¸©ch∑d
(
io
.
îr‹s
.
bus
.
vÆid
 && 
gø¡IsCached
, "D_ERROR_CACHED", "D$ D-channelÉrror, cached")

861 
	`ccovî
(
io
.
îr‹s
.
bus
.
vÆid
 && !
gø¡IsCached
, "D_ERROR_UNCACHED", "D$ D-channelÉrror, uncached")

864 i‡(
usögD©aS¸©ch∑d
) {

865 
vÆ
 
d©a_îr‹_covî
 = 
	`Seq
(

866 
	`CovîBoﬁón
(!
d©a_îr‹
, 
	`Seq
("no_data_error")),

867 
	`CovîBoﬁón
(
d©a_îr‹
 && !
d©a_îr‹_unc‹ª˘abÀ
, 
	`Seq
("data_correctable_error")),

868 
	`CovîBoﬁón
(
d©a_îr‹
 && 
d©a_îr‹_unc‹ª˘abÀ
, 
	`Seq
("data_uncorrectable_error")))

869 
vÆ
 
ªque°_sour˚
 = 
	`Seq
(

870 
	`CovîBoﬁón
(
s2_isSœveP‹tAc˚ss
, 
	`Seq
("from_TL")),

871 
	`CovîBoﬁón
(!
s2_isSœveP‹tAc˚ss
, 
	`Seq
("from_CPU")))

873 
	`covî
(
√w
 
	`CrossPr›îty
(

874 
	`Seq
(
d©a_îr‹_covî
, 
ªque°_sour˚
),

875 
	`Seq
(),

879 
vÆ
 
d©a_îr‹_ty≥
 = 
	`Seq
(

880 
	`CovîBoﬁón
(!
s2_vÆid_d©a_îr‹
, 
	`Seq
("no_data_error")),

881 
	`CovîBoﬁón
(
s2_vÆid_d©a_îr‹
 && !
s2_d©a_îr‹_unc‹ª˘abÀ
, 
	`Seq
("data_correctable_error")),

882 
	`CovîBoﬁón
(
s2_vÆid_d©a_îr‹
 && 
s2_d©a_îr‹_unc‹ª˘abÀ
, 
	`Seq
("data_uncorrectable_error")))

883 
vÆ
 
d©a_îr‹_dúty
 = 
	`Seq
(

884 
	`CovîBoﬁón
(!
s2_vi˘im_dúty
, 
	`Seq
("data_clean")),

885 
	`CovîBoﬁón
(
s2_vi˘im_dúty
, 
	`Seq
("data_dirty")))

886 
vÆ
 
ªque°_sour˚
 = i‡(
suµ‹ts_Êush
) {

887 
	`Seq
(

888 
	`CovîBoﬁón
(!
Êushög
, 
	`Seq
("access")),

889 
	`CovîBoﬁón
(
Êushög
, 
	`Seq
("during_flush")))

891 
	`Seq
(
	`CovîBoﬁón
(
åue
.
B
, Seq("never_flush")))

893 
vÆ
 
èg_îr‹_covî
 = 
	`Seq
(

894 
	`CovîBoﬁón
–!
mëaArb
.
io
.
	`ö
(1).
vÆid
, 
	`Seq
("no_tag_error")),

895 
	`CovîBoﬁón
–
mëaArb
.
io
.
	`ö
(1).
vÆid
 && !
s2_mëa_îr‹_unc‹ª˘abÀ
, 
	`Seq
("tag_correctable_error")),

896 
	`CovîBoﬁón
–
mëaArb
.
io
.
	`ö
(1).
vÆid
 && 
s2_mëa_îr‹_unc‹ª˘abÀ
, 
	`Seq
("tag_uncorrectable_error")))

897 
	`covî
(
√w
 
	`CrossPr›îty
(

898 
	`Seq
(
d©a_îr‹_ty≥
, 
d©a_îr‹_dúty
, 
ªque°_sour˚
, 
èg_îr‹_covî
),

899 
	`Seq
(),

905 
def
 
	`ícodeD©a
(
x
: 
UI¡
, 
pois⁄
: 
Boﬁ
Ëx.
	`grou≥d
(
eccBôs
).
	`m≠
(
dECC
.
	`ícode
(
_
, i‡(dECC.
ˇnDëe˘
Ëpois⁄ 
Ál£
.
B
)).
asUI¡


906 
def
 
	`dummyEncodeD©a
(
x
: 
UI¡
Ëx.
	`grou≥d
(
eccBôs
).
	`m≠
(
dECC
.
	`swizzÀ
(
_
)).
asUI¡


907 
def
 
	`decodeD©a
(
x
: 
UI¡
Ëx.
	`grou≥d
(
dECC
.
	`width
(
eccBôs
)).
	`m≠
(dECC.
	$decode
(
_
))

908 
def
 
	`eccMask
(
byãMask
: 
UI¡
ËbyãMask.
	`grou≥d
(
eccByãs
).
	`m≠
(
_
.
‹R
).
asUI¡


909 
def
 
	`eccByãMask
(
byãMask
: 
UI¡
Ë
	`FûlI¡îÀaved
(
eccByãs
, 
	$eccMask
(
byãMask
))

911 
def
 
	`likñyNìdsRód
(
ªq
: 
HñœCacheReq
) = {

912 
vÆ
 
ªs
 = !
ªq
.
cmd
.
	`isO√Of
(
M_XWR
, 
M_PFW
Ë|| 
	`mtSize
‘eq.
typ
Ë< 
	`log2Ceû
(
eccByãs
)

913 
	`as£π
(!
	`√edsRód
(
ªq
Ë|| 
ªs
)

914 
ªs


915 
	}
}

916 
def
 
√edsRód
(
ªq
: 
HñœCacheReq
) =

917 
isRód
(
ªq
.
cmd
) ||

918 (
isWrôe
(
ªq
.
cmd
Ë&& (ªq.cmd ==
M_PWR
 || 
mtSize
‘eq.
typ
Ë< 
	$log2Ceû
(
eccByãs
)))

920 
def
 
	$ccovî
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

921 
	`covî
(
c⁄d
, 
s
"DCACHE_$œbñ", "Mem‹ySy°em;;" + 
desc
)

922 
def
 
	$ccovîNŸS¸©ch∑d
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

923 i‡(!
usögD©aS¸©ch∑d
Ë
	$ccovî
(
c⁄d
, 
œbñ
, 
desc
)

925 
	`ªquúe
(!
usögVM
 || 
ègLSB
 <
pgIdxBôs
)

926 
def
 
ègLSB
: 
I¡
 = 
u¡agBôs


927 
def
 
	$¥obeIdx
(
b
: 
TLBundÀB
): 
UI¡
 = b.
	$addªss
(
idxMSB
, 
idxLSB
)

928 
def
 
	$addªssToProbe
(
vaddr
: 
UI¡
, 
∑ddr
: UI¡): 
TLBundÀB
 = {

929 
vÆ
 
ªs
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
edge
.
bundÀ
))

930 
ªs
.
addªss
 :
∑ddr


931 
ªs
.
sour˚
 :
mmioOff£t
 - 1

932 
ªs


933 
	}
}

934 
def
 
	$acquúe
(
vaddr
: 
UI¡
, 
∑ddr
: UI¡, 
∑øm
: UI¡): 
TLBundÀA
 = {

935 i‡(!
edge
.
m™agî
.
™ySuµ‹tAcquúeT
Ë
	`Wúe
(
√w
 
	`TLBundÀA
”dge.
bundÀ
))

936 
edge
.
	`AcquúeBlock
(
	`UI¡
(0), 
∑ddr
 >> 
lgCacheBlockByãs
 <<ÜgCacheBlockByãs,ÜgCacheBlockByãs, 
∑øm
).
_2


937 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Decode.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.{
	gAºayBuf„r
, 
	gM≠
}

8 
obje˘
 
	gDecodeLogic


10 
def
 
ãrm
(
lô
: 
BôP©
) =

11 
√w
 
Tîm
(
lô
.
vÆue
, 
BigI¡
(2).
pow
÷ô.
gëWidth
)-÷ô.
mask
+1))

12 
def
 
logic
(
addr
: 
UI¡
, 
addrWidth
: 
I¡
, 
ˇche
: 
M≠
[
Tîm
,
Boﬁ
], 
ãrms
: 
Seq
[Term]) = {

13 
ãrms
.
m≠
 { 
t
 =>

14 
ˇche
.
gëOrEl£Upd©e
(
t
, (i‡—.
mask
 =0Ë
addr
 add∏& 
Bôs
(
BigI¡
(2).
pow
(
addrWidth
)-—.mask+1),áddrWidth)Ë==Bôs—.
vÆue
,áddrWidth))

15 }.
fﬁdLe·
(
Boﬁ
(
Ál£
))(
	g_
||_)

17 
def
 
≠∂y
(
addr
: 
UI¡
, : 
BôP©
, 
m≠pög
: 
IãøbÀ
[(BitPat, BitPat)]): UInt = {

18 
vÆ
 
ˇche
 = 
ˇches
.
gëOrEl£Upd©e
(
addr
, 
M≠
[
Tîm
,
Boﬁ
]())

19 
vÆ
 
	gdãrm
 = 
ãrm
()

20 
vÆ
 (
keys
, 
vÆues
Ë
m≠pög
.
unzù


21 
vÆ
 
addrWidth
 = 
keys
.
m≠
(
_
.
gëWidth
).
max


22 
vÆ
 
ãrms
 = 
keys
.
toLi°
.
m≠
(
k
 => 
ãrm
(k))

23 
vÆ
 
ãrmvÆues
 = 
ãrms
 
zù
 
vÆues
.
toLi°
.
m≠
(
ãrm
(
_
))

25 
t
 <- 
keys
.
zù
(
ãrms
).
èûs
; !
	gt
.
	gisEm±y
)

26 
	gu
 <- 
	gt
.
	gèû
)

27 
as£π
(!
t
.
hód
.
_2
.
öãr£˘s
(
u
._2), "DecodeLogic: keys " +Å.head + "ánd " + u + " overlap")

29 
C©
((0 
u¡û
 .
gëWidth
.
max
(
vÆues
.
m≠
(
_
.gëWidth).max)).m≠({ (
i
: 
I¡
) =>

30 
vÆ
 
möt
 = 
ãrmvÆues
.
fûãr
 { (
k
,
t
Ë=> (—.
mask
 >> 
i
Ë& 1Ë=0 && (—.
vÆue
 >> iË& 1Ë=1 }.
m≠
(
_
.
_1
)

31 
vÆ
 
maxt
 = 
ãrmvÆues
.
fûãr
 { (
k
,
t
Ë=> (—.
mask
 >> 
i
Ë& 1Ë=0 && (—.
vÆue
 >> iË& 1Ë=0 }.
m≠
(
_
.
_1
)

32 
vÆ
 
dc
 = 
ãrmvÆues
.
fûãr
 { (
k
,
t
Ë=> (—.
mask
 >> 
i
Ë& 1Ë=1 }.
m≠
(
_
.
_1
)

34 i‡(((
dãrm
.
mask
 >> 
i
) & 1) != 0) {

35 
logic
(
addr
, 
addrWidth
, 
ˇche
, 
Sim∂ifyDC
(
möt
, 
maxt
,áddrWidth))

37 
vÆ
 
defbô
 = (
dãrm
.
vÆue
.
toI¡
 >> 
i
) & 1

38 
vÆ
 
t
 = i‡(
defbô
 =0Ë
möt
 
maxt


39 
vÆ
 
bô
 = 
logic
(
addr
, 
addrWidth
, 
ˇche
, 
Sim∂ify
(
t
, 
dc
,áddrWidth))

40 i‡(
defbô
 =0Ë
bô
 ~bit

42 }).
ªvî£
)

44 
def
 
≠∂y
(
addr
: 
UI¡
, : 
Seq
[
BôP©
], 
m≠pögIn
: 
IãøbÀ
[(BitPat, Seq[BitPat])]): Seq[UInt] = {

45 
vÆ
 
m≠pög
 = 
AºayBuf„r
.
fûl
(.
size
)(AºayBuf„r[(
BôP©
, BitPat)]())

46 (
	gkey
, 
	gvÆues
Ë<- 
	gm≠pögIn
)

47 (
	gvÆue
, 
	gi
Ë<- 
vÆues
 
	gzùWôhIndex
)

48 
m≠pög
(
i
Ë+
key
 -> 
vÆue


49 (
thisDeÁu…
, 
	gthisM≠pög
Ë<-  
zù
 
	gm≠pög
)

50 
yõld
 
≠∂y
(
addr
, 
thisDeÁu…
, 
thisM≠pög
)

52 
def
 
≠∂y
(
addr
: 
UI¡
, : 
Seq
[
BôP©
], 
m≠pögIn
: 
Li°
[(UInt, Seq[BitPat])]): Seq[UInt] =

53 
≠∂y
(
addr
, , 
m≠pögIn
.
m≠
(
m
 => (
BôP©
(m.
_1
), m.
_2
)).
asIn°™˚Of
[
IãøbÀ
[(BôP©, 
Seq
[BitPat])]])

54 
def
 
≠∂y
(
addr
: 
UI¡
, 
åues
: 
IãøbÀ
[UI¡], 
Ál£s
: IãøbÀ[UI¡]): 
Boﬁ
 =

55 
≠∂y
(
addr
, 
BôP©
.
d⁄tC¨e
(1), 
åues
.
m≠
(BôP©(
_
Ë-> BôP©("b1")Ë++ 
Ál£s
.m≠(BôP©(_Ë-> BôP©("b0"))).
toBoﬁ


56 
¥iv©e
 
vÆ
 
	gˇches
 = 
M≠
[
UI¡
,M≠[
Tîm
,
Boﬁ
]]()

59 
˛ass
 
	$Tîm
(
vÆ
 
vÆue
: 
BigI¡
, vÆ 
mask
: BigInt = 0)

61 
v¨
 
¥ime
 = 
åue


63 
def
 
	`covîs
(
x
: 
Tîm
Ë((
vÆue
 ^ x.vÆueË&~ 
mask
 | x.mask &~ mask) == 0

64 
def
 
	`öãr£˘s
(
x
: 
Tîm
Ë((
vÆue
 ^ x.vÆueË&~ 
mask
 &~ x.mask) == 0

65 
ovîride
 
def
 
	`equÆs
(
th©
: 
Any
Ëth© 
m©ch
 {

66 
x
: 
Tîm
 => x.
vÆue
 =vÆuê&& x.
mask
 == mask

67 
_
 => 
Ál£


69 
ovîride
 
def
 
hashCode
 = 
vÆue
.
toI¡


70 
def
 < (
th©
: 
Tîm
Ë
vÆue
 <Åh©.vÆuê|| vÆuê=th©.vÆuê&& 
mask
 <Åhat.mask

71 
def
 
	`simû¨
(
x
: 
Tîm
) = {

72 
vÆ
 
diff
 = 
vÆue
 - 
x
.value

73 
mask
 =
x
.mask && 
vÆue
 > x.vÆuê&& (
diff
 & diff-1) == 0

75 
def
 
	`mîge
(
x
: 
Tîm
) = {

76 
¥ime
 = 
Ál£


77 
x
.
¥ime
 = 
Ál£


78 
vÆ
 
bô
 = 
vÆue
 - 
x
.value

79 
√w
 
	`Tîm
(
vÆue
 &~ 
bô
, 
mask
 | bit)

82 
ovîride
 
def
 
toSåög
 = 
vÆue
.
	`toSåög
(16Ë+ "-" + 
mask
.toSåög(16Ë+ (i‡(
¥ime
) "p" "")

83 
	}
}

85 
obje˘
 
	gSim∂ify


87 
def
 
gëPrimeIm∂iˇ¡s
(
im∂iˇ¡s
: 
Seq
[
Tîm
], 
bôs
: 
I¡
) = {

88 
v¨
 
¥ime
 = 
Li°
[
Tîm
]()

89 
im∂iˇ¡s
.
f‹óch
(
_
.
¥ime
 = 
åue
)

90 
vÆ
 
cﬁs
 = (0 
to
 
bôs
).
m≠
(
b
 => 
im∂iˇ¡s
.
fûãr
(b =
_
.
mask
.
bôCou¡
))

91 
vÆ
 
èbÀ
 = 
cﬁs
.
m≠
(
c
 => (0 
to
 
bôs
).m≠(
b
 => 
cﬁÀ˘i⁄
.
muèbÀ
.
Së
(c.
fûãr
(b =
_
.
vÆue
.
bôCou¡
):_*)))

92 
i
 <- 0 
to
 
bôs
) {

93 
j
 <- 0 
u¡û
 
bôs
-
i
)

94 
èbÀ
(
i
)(
j
).
f‹óch
(
a
 =>ÅabÀ(i+1)(jË++èbÀ(i)(j+1).
fûãr
(
_
.
simû¨
◊)).
m≠
(_.
mîge
(a)))

95 
r
 <- 
èbÀ
(
i
))

96 
p
 <- 
r
; 
	gp
.
	g¥ime
)

97 
	g¥ime
 = 
p
 :: 
¥ime


99 
¥ime
.
s‹tWôh
(
_
<_)

101 
def
 
gëEs£¡ülPrimeIm∂iˇ¡s
(
¥ime
: 
Seq
[
Tîm
], 
möãrms
: Seq[Tîm]): (Seq[Tîm],
	gSeq
[Term],Seq[Term]) = {

102 
vÆ
 
¥imeCovîs
 = 
¥ime
.
m≠
(
p
 => 
möãrms
.
fûãr
’ 
covîs
 
_
))

103 ((
icovî
, 
	gpi
), 
	gi
Ë<- (
¥imeCovîs
 
zù
 
	g¥ime
).
	gzùWôhIndex
) {

104 ((
	gjcovî
, 
	gpj
), 
	gj
Ë<- (
¥imeCovîs
 
zù
 
	g¥ime
).
	gzùWôhIndex
.
dr›
(
i
+1)) {

105 i‡(
	gicovî
.
	gsize
 > 
	gjcovî
.sizê&& jcovî.
f‹Æl
(
pi
 
covîs
 
_
))

106  
gëEs£¡ülPrimeIm∂iˇ¡s
(
¥ime
.
fûãr
(
_
 !
pj
), 
möãrms
)

110 
vÆ
 
	ges£¡üŒyCovîed
 = 
möãrms
.
fûãr
(
t
 => 
¥ime
.
cou¡
(
_
 
covîs
Å) == 1)

111 
vÆ
 
es£¡ül
 = 
¥ime
.
fûãr
(
p
 => 
es£¡üŒyCovîed
.
exi°s
’ 
covîs
 
_
))

112 
vÆ
 
n⁄es£¡ül
 = 
¥ime
.
fûãrNŸ
(
es£¡ül
 
c⁄èös
 
_
)

113 
vÆ
 
uncovîed
 = 
möãrms
.
fûãrNŸ
(
t
 => 
es£¡ül
.
exi°s
(
_
 
covîs
Å))

114 i‡(
es£¡ül
.
isEm±y
 || 
uncovîed
.isEmpty)

115 (
es£¡ül
, 
	gn⁄es£¡ül
, 
	guncovîed
)

117 
vÆ
 (
a
, 
b
, 
c
Ë
gëEs£¡ülPrimeIm∂iˇ¡s
(
n⁄es£¡ül
, 
uncovîed
)

118 (
	ges£¡ül
 ++ 
	ga
, 
	gb
, 
	gc
)

121 
def
 
gëCo°
(
covî
: 
Seq
[
Tîm
], 
bôs
: 
I¡
Ëcovî.
m≠
(bô†- 
_
.
mask
.
bôCou¡
).
sum


122 
def
 
chó≥r
(
a
: 
Li°
[
Tîm
], 
b
: Li°[Tîm], 
bôs
: 
I¡
) = {

123 
vÆ
 
ˇ
 = 
gëCo°
(
a
, 
bôs
)

124 
vÆ
 
	gcb
 = 
gëCo°
(
b
, 
bôs
)

125 
def
 
li°Less
(
a
: 
Li°
[
Tîm
], 
b
: Li°[Tîm]): 
Boﬁón
 = !b.
isEm±y
 && (a.isEm±y ||á.
hód
 < b.hód ||á.hód =b.hód &&Üi°Less◊.
èû
, b.tail))

126 
	gˇ
 < 
	gcb
 || c®=
cb
 && 
li°Less
(
a
.
s‹tWôh
(
_
<_), 
b
.sortWith(_<_))

128 
def
 
gëCovî
(
im∂iˇ¡s
: 
Seq
[
Tîm
], 
möãrms
: Seq[Tîm], 
bôs
: 
I¡
) = {

129 i‡(
möãrms
.
n⁄Em±y
) {

130 
vÆ
 
covî
 = 
möãrms
.
m≠
(
m
 => 
im∂iˇ¡s
.
fûãr
(
_
.
covîs
(m)))

131 
vÆ
 
Æl
 = 
covî
.
èû
.
fﬁdLe·
(covî.
hód
.
m≠
(
Së
(
_
)))((
c0
, 
	gc1
Ë=> c0.
Ê©M≠
(
a
 => 
c1
.map(a + _)))

132 
Æl
.
m≠
(
_
.
toLi°
).
ªdu˚Le·
((
a
, 
b
Ë=> i‡(
chó≥r
◊, b, 
bôs
))á b)

134 
	gSeq
[
Tîm
]()

136 
def
 
°rögify
(
s
: 
Seq
[
Tîm
], 
bôs
: 
I¡
Ës.
m≠
(
t
 => (0 
u¡û
 bôs).m≠(
i
 => i‡(—.
mask
 & (1 << i)Ë!0Ë"x" (—.
vÆue
 >> iË& 1).
toSåög
).
ªdu˚Le·
(
_
+_).
ªvî£
).reduceLeft(_+" + "+_)

138 
def
 
≠∂y
(
möãrms
: 
Seq
[
Tîm
], 
d⁄tˇªs
: Seq[Tîm], 
bôs
: 
I¡
) = {

139 
vÆ
 
¥ime
 = 
gëPrimeIm∂iˇ¡s
(
möãrms
 ++ 
d⁄tˇªs
, 
bôs
)

140 
	gmöãrms
.
f‹óch
(
t
 => 
as£π
(
¥ime
.
exi°s
(
_
.
covîs
(t))))

141 
vÆ
 (
ïrime
, 
¥ime2
, 
uncovîed
Ë
gëEs£¡ülPrimeIm∂iˇ¡s
(
¥ime
, 
möãrms
)

142 
vÆ
 
	gcovî
 = 
ïrime
 ++ 
gëCovî
(
¥ime2
, 
uncovîed
, 
bôs
)

143 
	gmöãrms
.
f‹óch
(
t
 => 
as£π
(
covî
.
exi°s
(
_
.
covîs
(t))))

144 
covî


148 
obje˘
 
	gSim∂ifyDC


150 
def
 
gëIm∂icôDC
(
maxãrms
: 
Seq
[
Tîm
], 
ãrm
: Tîm, 
bôs
: 
I¡
, 
above
: 
Boﬁón
): Term = {

151 
i
 <- 0 
u¡û
 
bôs
) {

152 
v¨
 
t
: 
Tîm
 = 
nuŒ


153 i‡(
above
 && ((
ãrm
.
vÆue
 |Åîm.
mask
Ë& (
BigI¡
(1Ë<< 
i
)) == 0)

154 
t
 = 
√w
 
Tîm
(
ãrm
.
vÆue
 | (
BigI¡
(1Ë<< 
i
),Åîm.
mask
)

155 i‡(!
	gabove
 && (
	gãrm
.
	gvÆue
 & (
BigI¡
(1Ë<< 
	gi
)) != 0)

156 
t
 = 
√w
 
Tîm
(
ãrm
.
vÆue
 & ~(
BigI¡
(1Ë<< 
i
),Åîm.
mask
)

157 i‡(
	gt
 !
nuŒ
 && !
maxãrms
.
exi°s
(
_
.
öãr£˘s
(
t
)))

158  
t


160 
	gnuŒ


162 
def
 
gëPrimeIm∂iˇ¡s
(
möãrms
: 
Seq
[
Tîm
], 
maxãrms
: Seq[Tîm], 
bôs
: 
I¡
) = {

163 
v¨
 
¥ime
 = 
Li°
[
Tîm
]()

164 
möãrms
.
f‹óch
(
_
.
¥ime
 = 
åue
)

165 
v¨
 
möt
 = 
möãrms
.
m≠
(
t
 => 
√w
 
Tîm
—.
vÆue
,Å.
mask
))

166 
vÆ
 
	gcﬁs
 = (0 
to
 
bôs
).
m≠
(
b
 => 
möt
.
fûãr
(b =
_
.
mask
.
bôCou¡
))

167 
vÆ
 
èbÀ
 = 
cﬁs
.
m≠
(
c
 => (0 
to
 
bôs
).m≠(
b
 => 
cﬁÀ˘i⁄
.
muèbÀ
.
Së
(c.
fûãr
(b =
_
.
vÆue
.
bôCou¡
):_*)))

169 
i
 <- 0 
to
 
bôs
) {

170 
j
 <- 0 
u¡û
 
bôs
-
i
) {

171 
èbÀ
(
i
)(
j
).
f‹óch
(
a
 =>ÅabÀ(i+1)(jË++èbÀ(i)(j+1).
fûãr
(
_
 
simû¨
á).
m≠
(_ 
mîge
á))

173 
j
 <- 0 
u¡û
 
bôs
-
i
) {

174 
a
 <- 
èbÀ
(
i
)(
j
).
fûãr
(
_
.
¥ime
)) {

175 
vÆ
 
dc
 = 
gëIm∂icôDC
(
maxãrms
, 
a
, 
bôs
, 
åue
)

176 i‡(
	gdc
 !
nuŒ
)

177 
èbÀ
(
i
+1)(
j
Ë+
dc
 
mîge
 
a


179 
	ga
 <- 
èbÀ
(
i
)(
	gj
+1).
fûãr
(
_
.
¥ime
)) {

180 
vÆ
 
	gdc
 = 
gëIm∂icôDC
(
maxãrms
, 
a
, 
bôs
, 
Ál£
)

181 i‡(
	gdc
 !
nuŒ
)

182 
èbÀ
(
i
+1)(
j
Ë+
a
 
mîge
 
dc


185 
	gr
 <- 
èbÀ
(
i
))

186 
	gp
 <- 
	gr
; p.
	g¥ime
)

187 
	g¥ime
 = 
p
 :: 
¥ime


189 
¥ime
.
s‹tWôh
(
_
<_)

192 
def
 
vîify
(
covî
: 
Seq
[
Tîm
], 
möãrms
: Seq[Tîm], 
maxãrms
: Seq[Term]) = {

193 
as£π
(
möãrms
.
f‹Æl
(
t
 => 
covî
.
exi°s
(
_
 
covîs
Å)))

194 
as£π
(
maxãrms
.
f‹Æl
(
t
 => !
covî
.
exi°s
(
_
 
öãr£˘s
Å)))

196 
def
 
≠∂y
(
möãrms
: 
Seq
[
Tîm
], 
maxãrms
: Seq[Tîm], 
bôs
: 
I¡
) = {

197 
vÆ
 
¥ime
 = 
gëPrimeIm∂iˇ¡s
(
möãrms
, 
maxãrms
, 
bôs
)

198 
vÆ
 (
ïrime
, 
¥ime2
, 
uncovîed
Ë
Sim∂ify
.
gëEs£¡ülPrimeIm∂iˇ¡s
(
¥ime
, 
möãrms
)

199 
vÆ
 
	gcovî
 = 
ïrime
 ++ 
Sim∂ify
.
gëCovî
(
¥ime2
, 
uncovîed
, 
bôs
)

200 
vîify
(
covî
, 
möãrms
, 
maxãrms
)

201 
	gcovî


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Events.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


10 
˛ass
 
EvítSë
(
g©e
: (
UI¡
, UI¡Ë=> 
Boﬁ
, 
evíts
: 
Seq
[(
Såög
, () => Bool)]) {

11 
def
 
size
 = 
evíts
.size

12 
def
 
hôs
 = 
evíts
.
m≠
(
_
.
_2
()).
asUI¡


13 
def
 
check
(
mask
: 
UI¡
Ë
g©e
(mask, 
hôs
)

14 
def
 
dump
() {

15 ((
	g«me
, 
	g_
), 
	gi
Ë<- 
	gevíts
.
	gzùWôhIndex
)

16 
whí
 (
check
(1.U << 
i
)Ë{ 
¥ötf
(
s
"Event $name\n") }

18 
def
 
	gwôhCovîs
 {

19 
	gevíts
.
	gzùWôhIndex
.
	gf‹óch
 {

20 ((
	g«me
, 
	g_
), 
	gi
Ë=> 
covî
(
check
(1.U << 
i
), 
«me
)

25 
˛ass
 
	$EvítSës
(
vÆ
 
evítSës
: 
Seq
[
EvítSë
]) {

26 
def
 
	`maskEvítSñe˘‹
(
evítSñ
: 
UI¡
): UInt = {

28 
vÆ
 
£tMask
 = (
	`BigI¡
(1Ë<< 
	`log2Ceû
(
evítSës
.
size
)) - 1

29 
vÆ
 
maskMask
 = ((
	`BigI¡
(1Ë<< 
evítSës
.
	`m≠
(
_
.
size
).
max
Ë- 1Ë<< 
evítSëIdBôs


30 
evítSñ
 & (
£tMask
 | 
maskMask
).
U


33 
¥iv©e
 
def
 
	`decode
(
cou¡î
: 
UI¡
): (UInt, UInt) = {

34 
	`ªquúe
(
evítSës
.
size
 <(1 << 
evítSëIdBôs
))

35 (
	`cou¡î
(
	`log2Ceû
(
evítSës
.
size
)-1, 0), 
cou¡î
 >> 
evítSëIdBôs
)

38 
def
 
	`evÆu©e
(
evítSñ
: 
UI¡
): 
Boﬁ
 = {

39 
	`vÆ
 (
£t
, 
mask
Ë
	`decode
(
evítSñ
)

40 
vÆ
 
£ts
 = 
evítSës
 
	`m≠
 (
_
 
check
 
mask
)

41 
	`£ts
(
£t
)

44 
def
 
	`covî
(Ë
evítSës
.
f‹óch
 { 
_
 
wôhCovîs
 }

46 
¥iv©e
 
def
 
evítSëIdBôs
 = 8

47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Frontend.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


15 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


16 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


18 ˛as†
	cFr⁄ãndReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

19 
vÆ
 
pc
 = 
	$UI¡
(
width
 = 
vaddrBôsExãnded
)

20 
vÆ
 
•ecuœtive
 = 
	`Boﬁ
()

23 ˛as†
	cFr⁄ãndEx˚±i⁄s
 
exãnds
 
BundÀ
 {

24 
vÆ
 
pf
 = 
√w
 
BundÀ
 {

25 
vÆ
 
ö°
 = 
	`Boﬁ
()

27 
vÆ
 
´
 = 
√w
 
BundÀ
 {

28 
vÆ
 
ö°
 = 
	`Boﬁ
()

29 
	}
}

32 ˛as†
	cFr⁄ãndRe•
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

33 
vÆ
 
btb
 = 
√w
 
BTBRe•


34 
vÆ
 
pc
 = 
	$UI¡
(
width
 = 
vaddrBôsExãnded
)

35 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
„tchWidth
 * 
c‹eIn°Bôs
)

36 
vÆ
 
mask
 = 
	$Bôs
(
width
 = 
„tchWidth
)

37 
vÆ
 
x˝t
 = 
√w
 
Fr⁄ãndEx˚±i⁄s


38 
vÆ
 
ª∂ay
 = 
	`Boﬁ
()

41 ˛as†
	cFr⁄ãndPîfEvíts
 
exãnds
 
BundÀ
 {

42 
vÆ
 
acquúe
 = 
	$Boﬁ
()

43 
vÆ
 
ébMiss
 = 
	`Boﬁ
()

46 ˛as†
	cFr⁄ãndIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

47 
vÆ
 
might_ªque°
 = 
	$Boﬁ
(
OUTPUT
)

48 
vÆ
 
ªq
 = 
	$VÆid
(
√w
 
Fr⁄ãndReq
)

49 
vÆ
 
s„n˚
 = 
	$VÆid
(
√w
 
SFí˚Req
)

50 
vÆ
 
ª•
 = 
	`Decou∂ed
(
√w
 
Fr⁄ãndRe•
).
Êù


51 
vÆ
 
btb_upd©e
 = 
	$VÆid
(
√w
 
BTBUpd©e
)

52 
vÆ
 
bht_upd©e
 = 
	$VÆid
(
√w
 
BHTUpd©e
)

53 
vÆ
 
øs_upd©e
 = 
	$VÆid
(
√w
 
RASUpd©e
)

54 
vÆ
 
Êush_iˇche
 = 
	$Boﬁ
(
OUTPUT
)

55 
vÆ
 
≈c
 = 
	$UI¡
(
INPUT
, 
width
 = 
vaddrBôsExãnded
)

56 
vÆ
 
≥rf
 = 
√w
 
	`Fr⁄ãndPîfEvíts
().
asI≈ut


59 
˛ass
 
	$Fr⁄ãnd
(
vÆ
 
iˇcheP¨ams
: 
ICacheP¨ams
, 
h¨tid
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

60 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`Fr⁄ãndModuÀ
(
this
)

61 
vÆ
 
iˇche
 = 
	`LazyModuÀ
(
√w
 
	`ICache
(
iˇcheP¨ams
, 
h¨tid
))

62 
vÆ
 
ma°îNode
 = 
iˇche
.masterNode

63 
vÆ
 
¶aveNode
 = 
iˇche
.slaveNode

64 
	}
}

66 
˛ass
 
	$Fr⁄ãndBundÀ
(
vÆ
 
ouãr
: 
Fr⁄ãnd
Ë
exãnds
 
	$C‹eBundÀ
()(
ouãr
.
p
)

67 
wôh
 
HasExã∫ÆlyDrivíTûeC⁄°™ts
 {

68 
vÆ
 
˝u
 = 
√w
 
	`Fr⁄ãndIO
().
Êù


69 
vÆ
 
±w
 = 
√w
 
	`TLBPTWIO
()

70 
vÆ
 
îr‹s
 = 
√w
 
ICacheEº‹s


71 
	}
}

73 @
chi£lName


74 ˛as†
	cFr⁄ãndModuÀ
(
ouãr
: 
Fr⁄ãnd
Ë
exãnds
 
	$LazyModuÀImp
(
ouãr
)

75 
wôh
 
HasRockëC‹eP¨amëîs


76 
wôh
 
HasL1ICacheP¨amëîs
 {

77 
vÆ
 
io
 = 
	`IO
(
√w
 
	$Fr⁄ãndBundÀ
(
ouãr
))

78 
im∂icô
 
vÆ
 
edge
 = 
ouãr
.
ma°îNode
.
edges
.
	$out
(0)

79 
vÆ
 
iˇche
 = 
ouãr
.iˇche.
moduÀ


80 
	$ªquúe
(
„tchWidth
*
c‹eIn°Byãs
 =
ouãr
.
iˇcheP¨ams
.
„tchByãs
)

82 
vÆ
 
fq
 = 
	`wôhRe£t
(
ª£t
 || 
io
.
˝u
.
ªq
.
vÆid
Ë{ 
	`ModuÀ
(
√w
 
	`Shi·Queue
“ew 
Fr⁄ãndRe•
, 5, 
Êow
 = 
åue
)) }

84 
vÆ
 
˛ock_í_ªg
 = 
	`Reg
(
	$Boﬁ
())

85 
vÆ
 
˛ock_í
 = 
˛ock_í_ªg
 || 
io
.
˝u
.
might_ªque°


86 
	`as£π
(!(
io
.
˝u
.
ªq
.
vÆid
 || io.˝u.
s„n˚
.vÆid || io.˝u.
Êush_iˇche
 || io.˝u.
bht_upd©e
.vÆid || io.˝u.
btb_upd©e
.vÆidË|| io.˝u.
might_ªque°
)

87 
vÆ
 
g©ed_˛ock
 =

88 i‡(!
rockëP¨ams
.
˛ockG©e
Ë
˛ock


89 
	`ClockG©e
(
˛ock
, 
˛ock_í
, "icache_clock_gate")

91 
iˇche
.
˛ock
 :
g©ed_˛ock


92 
iˇche
.
io
.
˛ock_íabÀd
 :
˛ock_í


93 
	$wôhClock
 (
g©ed_˛ock
) {

95 
vÆ
 
éb
 = 
	`ModuÀ
(
√w
 
	`TLB
(
åue
, 
	`log2Ceû
(
„tchByãs
), 
	`TLBC⁄fig
(
nTLBE¡rõs
)))

97 
vÆ
 
s0_vÆid
 = 
io
.
˝u
.
ªq
.
vÆid
 || !
fq
.io.
	`mask
(fq.io.
mask
.
gëWidth
-3)

98 
vÆ
 
s1_vÆid
 = 
	`RegNext
(
s0_vÆid
)

99 
vÆ
 
s1_pc
 = 
	`Reg
(
	`UI¡
(
width
=
vaddrBôsExãnded
))

100 
vÆ
 
s1_•ecuœtive
 = 
	`Reg
(
	`Boﬁ
())

101 
vÆ
 
s2_vÆid
 = 
	`RegInô
(
Ál£
.
B
)

102 
vÆ
 
s2_pc
 = 
	`RegInô
(
t
 = 
	`UI¡
(
width
 = 
vaddrBôsExãnded
), 
	`ÆignPC
(
io
.
ª£t_ve˘‹
))

103 
vÆ
 
s2_btb_ª•_vÆid
 = i‡(
usögBTB
Ë
	`Reg
(
	`Boﬁ
()Ë
Ál£
.
B


104 
vÆ
 
s2_btb_ª•_bôs
 = 
	`Reg
(
√w
 
BTBRe•
)

105 
vÆ
 
s2_btb_èkí
 = 
s2_btb_ª•_vÆid
 && 
s2_btb_ª•_bôs
.
èkí


106 
vÆ
 
s2_éb_ª•
 = 
	`Reg
(
éb
.
io
.
ª•
)

107 
vÆ
 
s2_x˝t
 = 
s2_éb_ª•
.
´
.
ö°
 || s2_éb_ª•.
pf
.inst

108 
vÆ
 
s2_•ecuœtive
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

109 
vÆ
 
s2_∑πül_ö¢_vÆid
 = 
	`RegInô
(
Ál£
.
B
)

110 
vÆ
 
s2_∑πül_ö¢
 = 
	`Reg
(
	`UI¡
(
width
 = 
c‹eIn°Bôs
))

111 
vÆ
 
wr⁄g_∑th
 = 
	`Reg
(
	`Boﬁ
())

113 
vÆ
 
s1_ba£_pc
 = ~(~
s1_pc
 | (
„tchByãs
 - 1))

114 
vÆ
 
¡pc
 = 
s1_ba£_pc
 + 
„tchByãs
.
U


115 
vÆ
 
¥edi˘ed_≈c
 = 
	`Wúe
(
öô
 = 
¡pc
)

116 
vÆ
 
¥edi˘ed_èkí
 = 
	`Wúe
(
öô
 = 
	`Boﬁ
(
Ál£
))

118 
vÆ
 
s2_ª∂ay
 = 
	`Wúe
(
	`Boﬁ
())

119 
s2_ª∂ay
 :(
s2_vÆid
 && !
fq
.
io
.
íq
.
	`fúe
()Ë|| 
	`RegNext
(s2_ª∂ay && !
s0_vÆid
, 
åue
.
B
)

120 
vÆ
 
≈c
 = 
	`Mux
(
s2_ª∂ay
, 
s2_pc
, 
¥edi˘ed_≈c
)

122 
s1_pc
 :
io
.
˝u
.
≈c


125 
vÆ
 
s0_•ecuœtive
 =

126 i‡(
usögCom¥es£d
Ë
s1_•ecuœtive
 || 
s2_vÆid
 && !
s2_•ecuœtive
 || 
¥edi˘ed_èkí


127 
	`Boﬁ
(
åue
)

128 
s1_•ecuœtive
 :
	`Mux
(
io
.
˝u
.
ªq
.
vÆid
, io.˝u.ªq.
bôs
.
•ecuœtive
, Mux(
s2_ª∂ay
, 
s2_•ecuœtive
, 
s0_•ecuœtive
))

130 
vÆ
 
s2_ªdúe˘
 = 
	`Wúe
(
öô
 = 
io
.
˝u
.
ªq
.
vÆid
)

131 
s2_vÆid
 :
Ál£


132 
	`whí
 (!
s2_ª∂ay
) {

133 
s2_vÆid
 :!
s2_ªdúe˘


134 
s2_pc
 :
s1_pc


135 
s2_•ecuœtive
 :
s1_•ecuœtive


136 
s2_éb_ª•
 :
éb
.
io
.
ª•


139 
io
.
±w
 <> 
éb
.io.ptw

140 
éb
.
io
.
ªq
.
vÆid
 :
s1_vÆid
 && !
s2_ª∂ay


141 
éb
.
io
.
ªq
.
bôs
.
vaddr
 :
s1_pc


142 
éb
.
io
.
ªq
.
bôs
.
∑s°hrough
 :
	`Boﬁ
(
Ál£
)

143 
éb
.
io
.
ªq
.
bôs
.
size
 :
	`log2Ceû
(
c‹eIn°Byãs
*
„tchWidth
)

144 
éb
.
io
.
s„n˚
 :io.
˝u
.sfence

145 
éb
.
io
.
kûl
 :!
s2_vÆid


147 
iˇche
.
io
.
h¨tid
 := io.hartid

148 
iˇche
.
io
.
ªq
.
vÆid
 :
s0_vÆid


149 
iˇche
.
io
.
ªq
.
bôs
.
addr
 :io.
˝u
.
≈c


150 
iˇche
.
io
.
övÆid©e
 :io.
˝u
.
Êush_iˇche


151 
iˇche
.
io
.
s1_∑ddr
 :
éb
.io.
ª•
.
∑ddr


152 
iˇche
.
io
.
s2_vaddr
 :
s2_pc


153 
iˇche
.
io
.
s1_kûl
 :
s2_ªdúe˘
 || 
éb
.io.
ª•
.
miss
 || 
s2_ª∂ay


154 
iˇche
.
io
.
s2_kûl
 :
s2_•ecuœtive
 && !
s2_éb_ª•
.
ˇchóbÀ
 || 
s2_x˝t


155 
iˇche
.
io
.
s2_¥e„tch
 :
s2_éb_ª•
.
¥e„tchabÀ


157 
fq
.
io
.
íq
.
vÆid
 :
	`RegNext
(
s1_vÆid
Ë&& 
s2_vÆid
 && (
iˇche
.io.
ª•
.vÆid || !
s2_éb_ª•
.
miss
 && iˇche.io.
s2_kûl
)

158 
fq
.
io
.
íq
.
bôs
.
pc
 :
s2_pc


159 
io
.
˝u
.
≈c
 :
	`ÆignPC
(
	`Mux
(io.˝u.
ªq
.
vÆid
, io.˝u.ªq.
bôs
.
pc
,Çpc))

161 
fq
.
io
.
íq
.
bôs
.
d©a
 :
iˇche
.io.
ª•
.bits.data

162 
fq
.
io
.
íq
.
bôs
.
mask
 :
	`UI¡
((1 << 
„tchWidth
)-1Ë<< 
s2_pc
.
	`exåa˘
(
	`log2Ceû
(„tchWidth)+log2Ceû(
c‹eIn°Byãs
)-1,Üog2Ceil(coreInstBytes))

163 
fq
.
io
.
íq
.
bôs
.
ª∂ay
 :
iˇche
.io.
ª•
.bôs.ª∂ay || iˇche.io.
s2_kûl
 && !iˇche.io.ª•.
vÆid
 && !
s2_x˝t


164 
fq
.
io
.
íq
.
bôs
.
btb
 :
s2_btb_ª•_bôs


165 
fq
.
io
.
íq
.
bôs
.
btb
.
èkí
 :
s2_btb_èkí


166 
fq
.
io
.
íq
.
bôs
.
x˝t
 :
s2_éb_ª•


167 
	`whí
 (
iˇche
.
io
.
ª•
.
vÆid
 && iˇche.io.ª•.
bôs
.
´
Ë{ 
fq
.io.
íq
.bôs.
x˝t
.´.
ö°
 :
åue
 }

169 i‡(
usögBTB
) {

170 
vÆ
 
btb
 = 
	`ModuÀ
(
√w
 
BTB
)

171 
btb
.
io
.
Êush
 :
Ál£


172 
btb
.
io
.
ªq
.
vÆid
 :
Ál£


173 
btb
.
io
.
ªq
.
bôs
.
addr
 :
s1_pc


174 
btb
.
io
.
btb_upd©e
 :io.
˝u
.btb_update

175 
btb
.
io
.
bht_upd©e
 :io.
˝u
.bht_update

176 
btb
.
io
.
øs_upd©e
.
vÆid
 :
Ál£


177 
btb
.
io
.
bht_adv™˚
.
vÆid
 :
Ál£


178 
	`whí
 (!
s2_ª∂ay
) {

179 
btb
.
io
.
ªq
.
vÆid
 :!
s2_ªdúe˘


180 
s2_btb_ª•_vÆid
 :
btb
.
io
.
ª•
.
vÆid


181 
s2_btb_ª•_bôs
 :
btb
.
io
.
ª•
.
bôs


183 
	`whí
 (
btb
.
io
.
ª•
.
vÆid
 && btb.io.ª•.
bôs
.
èkí
) {

184 
¥edi˘ed_≈c
 :
btb
.
io
.
ª•
.
bôs
.
èrgë
.
	`£xtTo
(
vaddrBôsExãnded
)

185 
¥edi˘ed_èkí
 :
	`Boﬁ
(
åue
)

188 
vÆ
 
f‹˚_èkí
 = 
io
.
±w
.
cu°omCSRs
.
bpmSètic


189 
	`whí
 (
io
.
±w
.
cu°omCSRs
.
ÊushBTB
Ë{ 
btb
.io.
Êush
 :
åue
 }

190 
	`whí
 (
f‹˚_èkí
Ë{ 
btb
.
io
.
bht_upd©e
.
vÆid
 :
Ál£
 }

192 
vÆ
 
s2_ba£_pc
 = ~(~
s2_pc
 | (
„tchByãs
-1))

193 
vÆ
 
èkí_idx
 = 
	`Wúe
(
	`UI¡
())

194 
vÆ
 
a·î_idx
 = 
	`Wúe
(
	`UI¡
())

195 
vÆ
 
u£RAS
 = 
	`Wúe
(
öô
=
Ál£
.
B
)

196 
vÆ
 
upd©eBTB
 = 
	`Wúe
(
öô
=
Ál£
.
B
)

198 
def
 
	`sˇnIn¢s
(
idx
: 
I¡
, 
¥evVÆid
: 
Boﬁ
, 
¥evBôs
: 
UI¡
, 
¥evTakí
: Bool): Bool = {

199 
def
 
	`ö¢IsRVC
(
bôs
: 
UI¡
Ë
	`bôs
(1,0) =/= 3

200 
vÆ
 
¥evRVI
 = 
¥evVÆid
 && !
	`ö¢IsRVC
(
¥evBôs
)

201 
vÆ
 
vÆid
 = 
fq
.
io
.
íq
.
bôs
.
	`mask
(
idx
Ë&& !
¥evRVI


202 
vÆ
 
bôs
 = 
fq
.
io
.
íq
.bôs.
	`d©a
(
c‹eIn°Bôs
*(
idx
+1)-1, coreInstBits*idx)

203 
vÆ
 
rvc
 = 
	`ö¢IsRVC
(
bôs
)

204 
vÆ
 
rviBôs
 = 
	`C©
(
bôs
, 
¥evBôs
)

205 
vÆ
 
rviBønch
 = 
	`rviBôs
(6,0Ë==
In°ru˘i⁄s
.
BEQ
.
vÆue
.
	`asUI¡
()(6,0)

206 
vÆ
 
rviJump
 = 
	`rviBôs
(6,0Ë==
In°ru˘i⁄s
.
JAL
.
vÆue
.
	`asUI¡
()(6,0)

207 
vÆ
 
rviJALR
 = 
	`rviBôs
(6,0Ë==
In°ru˘i⁄s
.
JALR
.
vÆue
.
	`asUI¡
()(6,0)

208 
vÆ
 
rviRëu∫
 = 
rviJALR
 && !
	`rviBôs
(7Ë&& 
	`BôP©
("b00?01") ===ÑviBits(19,15)

209 
vÆ
 
rviCÆl
 = (
rviJALR
 || 
rviJump
Ë&& 
	`rviBôs
(7)

210 
vÆ
 
rvcBønch
 = 
bôs
 ==
In°ru˘i⁄s
.
C_BEQZ
 || bô†==In°ru˘i⁄s.
C_BNEZ


211 
vÆ
 
rvcJAL
 = 
	`Boﬁ
(
xLí
 =32Ë&& 
bôs
 ==
In°ru˘i⁄s
.
C_JAL


212 
vÆ
 
rvcJump
 = 
bôs
 ==
In°ru˘i⁄s
.
C_J
 || 
rvcJAL


213 
vÆ
 
rvcImm
 = 
	`Mux
(
	`bôs
(14), 
√w
 
	`RVCDecodî
(
bôs
, 
xLí
).
bImm
.
asSI¡
,Çew RVCDecodî(bôs, xLí).
jImm
.asSInt)

214 
vÆ
 
rvcJR
 = 
bôs
 ==
In°ru˘i⁄s
.
C_MV
 && 
	`bôs
(6,2) === 0

215 
vÆ
 
rvcRëu∫
 = 
rvcJR
 && 
	`BôP©
("b00?01"Ë==
	`bôs
(11,7)

216 
vÆ
 
rvcJALR
 = 
bôs
 ==
In°ru˘i⁄s
.
C_ADD
 && 
	`bôs
(6,2) === 0

217 
vÆ
 
rvcCÆl
 = 
rvcJAL
 || 
rvcJALR


218 
vÆ
 
rviImm
 = 
	`Mux
(
	`rviBôs
(3), 
	`ImmGí
(
IMM_UJ
, 
rviBôs
), ImmGí(
IMM_SB
,ÑviBits))

219 
vÆ
 
¥edi˘_èkí
 = 
s2_btb_ª•_bôs
.
bht
.
èkí
 || 
f‹˚_èkí


220 
vÆ
 
èkí
 =

221 
¥evRVI
 && (
rviJump
 || 
rviJALR
 || 
rviBønch
 && 
¥edi˘_èkí
) ||

222 
vÆid
 && (
rvcJump
 || 
rvcJALR
 || 
rvcJR
 || 
rvcBønch
 && 
¥edi˘_èkí
)

223 
vÆ
 
¥edi˘Rëu∫
 = 
btb
.
io
.
øs_hód
.
vÆid
 && (
¥evRVI
 && 
rviRëu∫
 || vÆid && 
rvcRëu∫
)

224 
vÆ
 
¥edi˘Jump
 = 
¥evRVI
 && 
rviJump
 || 
vÆid
 && 
rvcJump


225 
vÆ
 
¥edi˘Bønch
 = 
¥edi˘_èkí
 && (
¥evRVI
 && 
rviBønch
 || 
vÆid
 && 
rvcBønch
)

227 
	`whí
 (
s2_vÆid
 && 
s2_btb_ª•_vÆid
 && 
s2_btb_ª•_bôs
.
bridx
 ==
idx
 && 
vÆid
 && !
rvc
) {

230 
btb
.
io
.
Êush
 :
åue


231 
fq
.
io
.
íq
.
bôs
.
ª∂ay
 :
åue


232 
wr⁄g_∑th
 :
åue


233 
	`ccovî
(
wr⁄g_∑th
, "BTB_NON_CFI_ON_WRONG_PATH", "BTBÖredictedáÇon-branch wasÅaken while onÅhe wrongÖath")

236 
	`whí
 (!
¥evTakí
) {

237 
èkí_idx
 :
idx


238 
a·î_idx
 :
idx
 + 1

239 
btb
.
io
.
øs_upd©e
.
vÆid
 :
fq
.io.
íq
.
	`fúe
(Ë&& !
wr⁄g_∑th
 && (
¥evRVI
 && (
rviCÆl
 || 
rviRëu∫
Ë|| vÆid && (
rvcCÆl
 || 
rvcRëu∫
))

240 
btb
.
io
.
øs_upd©e
.
bôs
.
cfiTy≥
 :
	`Mux
(Mux(
¥evRVI
, 
rviRëu∫
, 
rvcRëu∫
), 
CFITy≥
.
ªt
,

241 
	`Mux
(Mux(
¥evRVI
, 
rviCÆl
, 
rvcCÆl
), 
CFITy≥
.
ˇŒ
,

242 
	`Mux
(Mux(
¥evRVI
, 
rviBønch
, 
rvcBønch
Ë&& !
f‹˚_èkí
, 
CFITy≥
.
bønch
,

243 
CFITy≥
.
jump
)))

245 
	`whí
 (!
s2_btb_èkí
) {

246 
	`whí
 (
fq
.
io
.
íq
.
	`fúe
(Ë&& 
èkí
 && !
¥edi˘Bønch
 && !
¥edi˘Jump
 && !
¥edi˘Rëu∫
) {

247 
wr⁄g_∑th
 :
åue


249 
	`whí
 (
s2_vÆid
 && 
¥edi˘Rëu∫
) {

250 
u£RAS
 :
åue


252 
	`whí
 (
s2_vÆid
 && (
¥edi˘Bønch
 || 
¥edi˘Jump
)) {

253 
vÆ
 
pc
 = 
s2_ba£_pc
 | (
idx
*
c‹eIn°Byãs
)

254 
vÆ
 
≈c
 =

255 i‡(
idx
 =0Ë
pc
.
asSI¡
 + 
	`Mux
(
¥evRVI
, 
rviImm
 -& 2.
S
, 
rvcImm
)

256 
	`Mux
(
¥evRVI
, 
pc
 - 
c‹eIn°Byãs
,Öc).
asSI¡
 + Mux’ªvRVI, 
rviImm
, 
rvcImm
)

257 
¥edi˘ed_≈c
 :
≈c
.
asUI¡


260 
	`whí
 (
¥evRVI
 && 
rviBønch
 || 
vÆid
 && 
rvcBønch
) {

261 
btb
.
io
.
bht_adv™˚
.
vÆid
 :
fq
.io.
íq
.
	`fúe
(Ë&& !
wr⁄g_∑th


262 
btb
.
io
.
bht_adv™˚
.
bôs
 :
s2_btb_ª•_bôs


264 
	`whí
 (!
s2_btb_ª•_vÆid
 && (
¥edi˘Bønch
 && 
s2_btb_ª•_bôs
.
bht
.
°r⁄gly_èkí
 || 
¥edi˘Jump
 || 
¥edi˘Rëu∫
)) {

265 
upd©eBTB
 :
åue


269 i‡(
idx
 =
„tchWidth
-1) {

270 
	`whí
 (
fq
.
io
.
íq
.
	`fúe
()) {

271 
s2_∑πül_ö¢_vÆid
 :
Ál£


272 
	`whí
 (
vÆid
 && !
¥evTakí
 && !
rvc
) {

273 
s2_∑πül_ö¢_vÆid
 :
åue


274 
s2_∑πül_ö¢
 :
bôs
 | 0x3

277 
¥evTakí
 || 
èkí


279 
	`sˇnIn¢s
(
idx
 + 1, 
vÆid
, 
bôs
, 
¥evTakí
 || 
èkí
)

283 
	`whí
 (!
io
.
˝u
.
btb_upd©e
.
vÆid
) {

284 
vÆ
 
„tch_bubbÀ_likñy
 = !
fq
.
io
.
	`mask
(1)

285 
btb
.
io
.
btb_upd©e
.
vÆid
 :
fq
.io.
íq
.
	`fúe
(Ë&& !
wr⁄g_∑th
 && 
„tch_bubbÀ_likñy
 && 
upd©eBTB


286 
btb
.
io
.
btb_upd©e
.
bôs
.
¥edi˘i⁄
.
íåy
 :
	`UI¡
(
tûeP¨ams
.btb.
gë
.
nE¡rõs
)

287 
btb
.
io
.
btb_upd©e
.
bôs
.
isVÆid
 :
åue


288 
btb
.
io
.
btb_upd©e
.
bôs
.
cfiTy≥
 :btb.io.
øs_upd©e
.bits.cfiType

289 
btb
.
io
.
btb_upd©e
.
bôs
.
br_pc
 :
s2_ba£_pc
 | (
èkí_idx
 << 
	`log2Ceû
(
c‹eIn°Byãs
))

290 
btb
.
io
.
btb_upd©e
.
bôs
.
pc
 :
s2_ba£_pc


293 
btb
.
io
.
øs_upd©e
.
bôs
.
ªtu∫Addr
 :
s2_ba£_pc
 + (
a·î_idx
 << 
	`log2Ceû
(
c‹eIn°Byãs
))

295 
vÆ
 
èkí
 = 
	`sˇnIn¢s
(0, 
s2_∑πül_ö¢_vÆid
, 
s2_∑πül_ö¢
, 
Ál£
.
B
)

296 
	`whí
 (
u£RAS
) {

297 
¥edi˘ed_≈c
 :
btb
.
io
.
øs_hód
.
bôs


299 
	`whí
 (
fq
.
io
.
íq
.
	`fúe
(Ë&& (
s2_btb_èkí
 || 
èkí
)) {

300 
s2_∑πül_ö¢_vÆid
 :
Ál£


302 
	`whí
 (!
s2_btb_èkí
) {

303 
	`whí
 (
èkí
) {

304 
fq
.
io
.
íq
.
bôs
.
btb
.
bridx
 :
èkí_idx


305 
fq
.
io
.
íq
.
bôs
.
btb
.
èkí
 :
åue


306 
fq
.
io
.
íq
.
bôs
.
btb
.
íåy
 :
	`UI¡
(
tûeP¨ams
.btb.
gë
.
nE¡rõs
)

307 
	`whí
 (
fq
.
io
.
íq
.
	`fúe
()Ë{ 
s2_ªdúe˘
 :
åue
 }

311 
	`as£π
(!
s2_∑πül_ö¢_vÆid
 || 
fq
.
io
.
íq
.
bôs
.
	`mask
(0))

312 
	`whí
 (
s2_ªdúe˘
Ë{ 
s2_∑πül_ö¢_vÆid
 :
Ál£
 }

313 
	`whí
 (
io
.
˝u
.
ªq
.
vÆid
Ë{ 
wr⁄g_∑th
 :
Ál£
 }

316 
io
.
˝u
.
ª•
 <> 
fq
.io.
deq


319 
io
.
˝u
.
≥rf
 :
iˇche
.io.perf

320 
io
.
˝u
.
≥rf
.
ébMiss
 :io.
±w
.
ªq
.
	`fúe
()

321 
io
.
îr‹s
 :
iˇche
.io.errors

324 
˛ock_í_ªg
 :
io
.
˝u
.
might_ªque°
 ||

325 
iˇche
.
io
.
kìp_˛ock_íabÀd
 ||

326 
s1_vÆid
 || 
s2_vÆid
 ||

327 !
éb
.
io
.
ªq
.
ªady
 ||

328 !
fq
.
io
.
	`mask
(fq.io.
mask
.
gëWidth
-1)

329 
	}
}

331 
def
 
ÆignPC
(
pc
: 
UI¡
Ë~(~p¯| (
c‹eIn°Byãs
 - 1))

333 
def
 
	$ccovî
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

334 
	`covî
(
c⁄d
, 
s
"FRONTEND_$œbñ", "Rockë;;" + 
desc
)

335 
	}
}

338 
åaô
 
HasICacheFr⁄ãnd
 
exãnds
 
	gC™HavePTW
 { 
	gthis
: 
Ba£Tûe
 =>

339 
vÆ
 
moduÀ
: 
HasICacheFr⁄ãndModuÀ


340 
vÆ
 
‰⁄ãnd
 = 
LazyModuÀ
(
√w
 
Fr⁄ãnd
(
tûeP¨ams
.
iˇche
.
gë
, 
h¨tId
))

341 
	géMa°îXb¨
.
	gnode
 :
‰⁄ãnd
.
ma°îNode


342 
c⁄√˘TLSœve
(
‰⁄ãnd
.
¶aveNode
, 
tûeP¨ams
.
c‹e
.
„tchByãs
)

343 
	gnPTWP‹ts
 += 1

346 
åaô
 
HasICacheFr⁄ãndModuÀ
 
exãnds
 
	gC™HavePTWModuÀ
 {

347 
vÆ
 
	gouãr
: 
HasICacheFr⁄ãnd


348 
±wP‹ts
 +
ouãr
.
‰⁄ãnd
.
moduÀ
.
io
.
±w


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCache.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
d⁄tTouch


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gP¨amëîs
, 
	gFõld
}

9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


14 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
Li°Buf„r


16 
˛ass
 
	$DCacheP¨ams
(

17 
nSës
: 
I¡
 = 64,

18 
nWays
: 
I¡
 = 4,

19 
rowBôs
: 
I¡
 = 64,

20 
nTLBE¡rõs
: 
I¡
 = 32,

21 
ègECC
: 
O±i⁄
[
Såög
] = 
N⁄e
,

22 
d©aECC
: 
O±i⁄
[
Såög
] = 
N⁄e
,

23 
d©aECCByãs
: 
I¡
 = 1,

24 
nMSHRs
: 
I¡
 = 1,

25 
nSDQ
: 
I¡
 = 17,

26 
nRPQ
: 
I¡
 = 16,

27 
nMMIOs
: 
I¡
 = 1,

28 
blockByãs
: 
I¡
 = 64,

29 
acquúeBef‹eRñó£
: 
Boﬁón
 = 
Ál£
,

30 
pùñöeWayMux
: 
Boﬁón
 = 
Ál£
,

31 
˛ockG©e
: 
Boﬁón
 = 
Ál£
,

32 
s¸©ch
: 
O±i⁄
[
BigI¡
] = 
N⁄e
Ë
exãnds
 
L1CacheP¨ams
 {

34 
def
 
ègCode
: 
Code
 = Code.
	`‰omSåög
(
ègECC
)

35 
def
 
d©aCode
: 
Code
 = Code.
	`‰omSåög
(
d©aECC
)

37 
def
 
d©aS¸©ch∑dByãs
: 
I¡
 = 
s¸©ch
.
	`m≠
(
_
 => 
nSës
*
blockByãs
).
	`gëOrEl£
(0)

39 
def
 
ª∂a˚mít
 = 
√w
 
	`R™domRïœ˚mít
(
nWays
)

41 
	`ªquúe
((!
s¸©ch
.
isDeföed
 || 
nWays
 == 1),

43 
	`ªquúe
((!
s¸©ch
.
isDeföed
 || 
nMSHRs
 == 0),

45 
	`ªquúe
(
	`isPow2
(
nSës
), 
s
"nSets($nSets) must beÖow2")

46 
	}
}

48 
åaô
 
HasL1HñœCacheP¨amëîs
 
exãnds
 
HasL1CacheP¨amëîs
 
wôh
 
	gHasC‹eP¨amëîs
 {

49 
vÆ
 
	gˇcheP¨ams
 = 
tûeP¨ams
.
dˇche
.
gë


50 
vÆ
 
cfg
 = 
ˇcheP¨ams


52 
def
 
w‹dBôs
 = 
c‹eD©aBôs


53 
def
 
w‹dByãs
 = 
c‹eD©aByãs


54 
def
 
w‹dOffBôs
 = 
log2Up
(
w‹dByãs
)

55 
def
 
bótByãs
 = 
ˇcheBlockByãs
 / 
ˇcheD©aBóts


56 
def
 
bótW‹ds
 = 
bótByãs
 / 
w‹dByãs


57 
def
 
bótOffBôs
 = 
log2Up
(
bótByãs
)

58 
def
 
idxMSB
 = 
u¡agBôs
-1

59 
def
 
idxLSB
 = 
blockOffBôs


60 
def
 
off£tmsb
 = 
idxLSB
-1

61 
def
 
off£ésb
 = 
w‹dOffBôs


62 
def
 
rowW‹ds
 = 
rowBôs
/
w‹dBôs


63 
def
 
doN¨rowRód
 = 
c‹eD©aBôs
 * 
nWays
 % 
rowBôs
 == 0

64 
def
 
eccByãs
 = 
ˇcheP¨ams
.
d©aECCByãs


65 
vÆ
 
eccBôs
 = 
ˇcheP¨ams
.
d©aECCByãs
 * 8

66 
vÆ
 
ícBôs
 = 
ˇcheP¨ams
.
d©aCode
.
width
(
eccBôs
)

67 
vÆ
 
ícW‹dBôs
 = 
ícBôs
 * (
w‹dBôs
 / 
eccBôs
)

68 
def
 
ícD©aBôs
 = 
ˇcheP¨ams
.
d©aCode
.
width
(
c‹eD©aBôs
)

69 
def
 
ícRowBôs
 = 
ícD©aBôs
*
rowW‹ds


70 
def
 
ÃscCy˛es
 = 
c‹eP¨ams
.lrscCycles

71 
def
 
ÃscBackoff
 = 3

72 
def
 
blockProbeA·îGø¡Cy˛es
 = 8

73 
def
 
nIOMSHRs
 = 
ˇcheP¨ams
.
nMMIOs


74 
def
 
maxUnˇchedInFlight
 = 
ˇcheP¨ams
.
nMMIOs


75 
def
 
d©aS¸©ch∑dSize
 = 
ˇcheP¨ams
.
d©aS¸©ch∑dByãs


77 
ªquúe
(
rowBôs
 >
c‹eD©aBôs
, 
s
"rowBits($rowBits) < coreDataBits($coreDataBits)")

78 i‡(!
	gusögD©aS¸©ch∑d
)

79 
ªquúe
(
rowBôs
 =
ˇcheD©aBôs
, 
s
"rowBits($rowBits) != cacheDataBits($cacheDataBits)")

81 
ªquúe
(
xLí
 <
ˇcheD©aBôs
, 
s
"xLen($xLen) > cacheDataBits($cacheDataBits)")

84 
ab°ø˘
 cœs†
	cL1HñœCacheModuÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ


85 
wôh
 
HasL1HñœCacheP¨amëîs


87 
ab°ø˘
 cœs†
	cL1HñœCacheBundÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
)

88 
wôh
 
HasL1HñœCacheP¨amëîs


92 
åaô
 
HasC‹eMemOp
 
exãnds
 
HasC‹eP¨amëîs
 {

93 
vÆ
 
addr
 = 
	$UI¡
(
width
 = 
c‹eMaxAddrBôs
)

94 
vÆ
 
èg
 = 
	$Bôs
(
width
 = 
dˇcheReqTagBôs
)

95 
vÆ
 
cmd
 = 
	$Bôs
(
width
 = 
M_SZ
)

96 
vÆ
 
typ
 = 
	`Bôs
(
width
 = 
MT_SZ
)

99 
åaô
 
HasC‹eD©a
 
exãnds
 
HasC‹eP¨amëîs
 {

100 
vÆ
 
d©a
 = 
	`Bôs
(
width
 = 
c‹eD©aBôs
)

101 
	}
}

103 ˛as†
	cHñœCacheReqI¡î«l
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
Ë
wôh
 
HasC‹eMemOp
 {

104 
vÆ
 
phys
 = 
	`Boﬁ
()

107 ˛as†
	cHñœCacheReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$HñœCacheReqI¡î«l
()(
p
Ë
wôh
 
HasC‹eD©a


109 ˛as†
	cHñœCacheRe•
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
)

110 
wôh
 
HasC‹eMemOp


111 
wôh
 
HasC‹eD©a
 {

112 
vÆ
 
ª∂ay
 = 
	$Boﬁ
()

113 
vÆ
 
has_d©a
 = 
	$Boﬁ
()

114 
vÆ
 
d©a_w‹d_by∑ss
 = 
	$Bôs
(
width
 = 
c‹eD©aBôs
)

115 
vÆ
 
d©a_øw
 = 
	$Bôs
(
width
 = 
c‹eD©aBôs
)

116 
vÆ
 
°‹e_d©a
 = 
	`Bôs
(
width
 = 
c‹eD©aBôs
)

119 ˛as†
	cAlignmítEx˚±i⁄s
 
exãnds
 
BundÀ
 {

120 
vÆ
 
ld
 = 
	$Boﬁ
()

121 
vÆ
 
°
 = 
	`Boﬁ
()

124 ˛as†
	cHñœCacheEx˚±i⁄s
 
exãnds
 
BundÀ
 {

125 
vÆ
 
ma
 = 
√w
 
AlignmítEx˚±i⁄s


126 
vÆ
 
pf
 = 
√w
 
AlignmítEx˚±i⁄s


127 
vÆ
 
´
 = 
√w
 
AlignmítEx˚±i⁄s


130 ˛as†
	cHñœCacheWrôeD©a
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

131 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
c‹eD©aBôs
)

132 
vÆ
 
mask
 = 
	`UI¡
(
width
 = 
c‹eD©aByãs
)

135 ˛as†
	cHñœCachePîfEvíts
 
exãnds
 
BundÀ
 {

136 
vÆ
 
acquúe
 = 
	$Boﬁ
()

137 
vÆ
 
ªÀa£
 = 
	$Boﬁ
()

138 
vÆ
 
gø¡
 = 
	$Boﬁ
()

139 
vÆ
 
ébMiss
 = 
	$Boﬁ
()

140 
vÆ
 
blocked
 = 
	`Boﬁ
()

144 ˛as†
	cHñœCacheIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

145 
vÆ
 
ªq
 = 
	$Decou∂ed
(
√w
 
HñœCacheReq
)

146 
vÆ
 
s1_kûl
 = 
	$Boﬁ
(
OUTPUT
)

147 
vÆ
 
s1_d©a
 = 
√w
 
	`HñœCacheWrôeD©a
().
asOuçut


148 
vÆ
 
s2_«ck
 = 
	$Boﬁ
(
INPUT
)

149 
vÆ
 
s2_«ck_ˇu£_øw
 = 
	$Boﬁ
(
INPUT
)

150 
vÆ
 
s2_kûl
 = 
	$Boﬁ
(
OUTPUT
)

152 
vÆ
 
ª•
 = 
	`VÆid
(
√w
 
HñœCacheRe•
).
Êù


153 
vÆ
 
ª∂ay_√xt
 = 
	$Boﬁ
(
INPUT
)

154 
vÆ
 
s2_x˝t
 = (
√w
 
HñœCacheEx˚±i⁄s
).
asI≈ut


155 
vÆ
 
‹dîed
 = 
	$Boﬁ
(
INPUT
)

156 
vÆ
 
≥rf
 = 
√w
 
	`HñœCachePîfEvíts
().
asI≈ut


158 
vÆ
 
kìp_˛ock_íabÀd
 = 
	$Boﬁ
(
OUTPUT
)

159 
vÆ
 
˛ock_íabÀd
 = 
	`Boﬁ
(
INPUT
)

164 
ab°ø˘
 cœs†
	cHñœCache
(
h¨tid
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

165 
¥Ÿe˘ed
 
vÆ
 
cfg
 = 
	`p
(
TûeKey
).
dˇche
.
gë


167 
¥Ÿe˘ed
 
def
 
ˇcheClõ¡P¨amëîs
 = 
cfg
.
s¸©ch
.
	`m≠
(
x
 => 
	`Seq
()).
	`gëOrEl£
(Seq(
	`TLClõ¡P¨amëîs
(

168 
«me
 = 
s
"Core ${hartid} DCache",

169 
sour˚Id
 = 
	`IdR™ge
(0, 1 
max
 
cfg
.
nMSHRs
),

170 
suµ‹tsProbe
 = 
	$Tøns„rSizes
(
cfg
.
blockByãs
, cfg.blockBytes))))

172 
¥Ÿe˘ed
 
def
 
mmioClõ¡P¨amëîs
 = 
	`Seq
(
	`TLClõ¡P¨amëîs
(

173 
«me
 = 
s
"Core ${hartid} DCache MMIO",

174 
sour˚Id
 = 
	`IdR™ge
(
fú°MMIO
, fú°MMIO + 
cfg
.
nMMIOs
),

175 
ªque°Fifo
 = 
åue
))

177 
def
 
fú°MMIO
 = (
ˇcheClõ¡P¨amëîs
.
	$m≠
(
_
.
sour˚Id
.
íd
Ë:+ 0).
max


179 
vÆ
 
node
 = 
	`TLClõ¡Node
(
	`Seq
(
	`TLClõ¡P‹tP¨amëîs
(

180 
ˇcheClõ¡P¨amëîs
 ++ 
mmioClõ¡P¨amëîs
,

181 
möL©ícy
 = 1)))

183 
vÆ
 
moduÀ
: 
HñœCacheModuÀ


186 ˛as†
	cHñœCacheBundÀ
(
vÆ
 
ouãr
: 
HñœCache
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

187 
vÆ
 
h¨tid
 = 
	$UI¡
(
INPUT
, 
h¨tIdLí
)

188 
vÆ
 
˝u
 = (
√w
 
HñœCacheIO
).
Êù


189 
vÆ
 
±w
 = 
√w
 
	$TLBPTWIO
()

190 
vÆ
 
îr‹s
 = 
√w
 
DCacheEº‹s


193 ˛as†
	cHñœCacheModuÀ
(
ouãr
: 
HñœCache
Ë
exãnds
 
	$LazyModuÀImp
(
ouãr
)

194 
wôh
 
HasL1HñœCacheP¨amëîs
 {

195 
im∂icô
 
vÆ
 
edge
 = 
ouãr
.
node
.
edges
.
	$out
(0)

196 
	`vÆ
 (
é_out
, 
_
Ë
ouãr
.
node
.
	$out
(0)

197 
vÆ
 
io
 = 
	`IO
(
√w
 
	$HñœCacheBundÀ
(
ouãr
))

198 
	$d⁄tTouch
(
io
.
˝u
.
ª•
)

199 
	$d⁄tTouch
(
io
.
˝u
.
s1_d©a
)

201 
¥iv©e
 
vÆ
 
fifoM™agîs
 = 
edge
.
m™agî
.
m™agîs
.
	$fûãr
(
TLFIFOFixî
.
ÆlUnˇchóbÀ
)

202 
fifoM™agîs
.
f‹óch
 { 
m
 =>

203 
	`ªquúe
 (
m
.
fifoId
 =
fifoM™agîs
.
hód
.fifoId,

204 
s
"IOMSHRs must be FIFO forállÑegions withÉffects, but HellaCache sees ${m.nodePath.map(_.name)}")

206 
	}
}

210 
åaô
 
	gHasHñœCache
 { 
	gthis
: 
Ba£Tûe
 =>

211 
vÆ
 
moduÀ
: 
HasHñœCacheModuÀ


212 
im∂icô
 
vÆ
 
p
: 
P¨amëîs


213 
def
 
födS¸©ch∑dFromICache
: 
O±i⁄
[
AddªssSë
]

214 
v¨
 
nDCacheP‹ts
 = 0

215 
œzy
 
vÆ
 
dˇche
: 
HñœCache
 = 
LazyModuÀ
(

216 if(
tûeP¨ams
.
dˇche
.
gë
.
nMSHRs
 == 0) {

217 
√w
 
DCache
(
h¨tId
, 
födS¸©ch∑dFromICache
 
_
, 
p
(
RockëCrossögKey
).
hód
.
knownR©io
)

218 } { 
√w
 
N⁄BlockögDCache
(
h¨tId
) })

220 
éMa°îXb¨
.
node
 :
dˇche
.node

223 
åaô
 
HasHñœCacheModuÀ
 {

224 
vÆ
 
ouãr
: 
HasHñœCache
 
wôh
 
HasTûeP¨amëîs


225 
im∂icô
 
vÆ
 
p
: 
P¨amëîs


226 
vÆ
 
dˇcheP‹ts
 = 
Li°Buf„r
[
HñœCacheIO
]()

227 
vÆ
 
dˇcheArb
 = 
ModuÀ
(
√w
 
HñœCacheArbôî
(
ouãr
.
nDCacheP‹ts
)(ouãr.
p
))

228 
ouãr
.
dˇche
.
moduÀ
.
io
.
˝u
 <> 
dˇcheArb
.io.
mem


233 ˛as†
	cL1Mëad©a
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheBundÀ
()(
p
) {

234 
vÆ
 
coh
 = 
√w
 
Clõ¡Mëad©a


235 
vÆ
 
èg
 = 
	`UI¡
(
width
 = 
ègBôs
)

238 
obje˘
 
L1Mëad©a
 {

239 
def
 
	`≠∂y
(
èg
: 
Bôs
, 
coh
: 
Clõ¡Mëad©a
)(
im∂icô
 
p
: 
P¨amëîs
) = {

240 
vÆ
 
mëa
 = 
	`Wúe
(
√w
 
L1Mëad©a
)

241 
mëa
.
èg
 :=Åag

242 
mëa
.
coh
 := coh

243 
mëa


245 
	}
}

247 ˛as†
	cL1MëaRódReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheBundÀ
()(
p
) {

248 
vÆ
 
idx
 = 
	$UI¡
(
width
 = 
idxBôs
)

249 
vÆ
 
way_í
 = 
	$UI¡
(
width
 = 
nWays
)

250 
vÆ
 
èg
 = 
	`UI¡
(
width
 = 
ègBôs
)

253 ˛as†
	cL1MëaWrôeReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1MëaRódReq
()(
p
) {

254 
vÆ
 
d©a
 = 
√w
 
L1Mëad©a


257 
˛ass
 
L1Mëad©aAºay
[
T
 <: 
L1Mëad©a
](
⁄Re£t
: (Ë=> T)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

258 
vÆ
 
r°VÆ
 = 
	`⁄Re£t
()

259 
vÆ
 
io
 = 
√w
 
BundÀ
 {

260 
vÆ
 
ªad
 = 
	`Decou∂ed
(
√w
 
L1MëaRódReq
).
Êù


261 
vÆ
 
wrôe
 = 
	`Decou∂ed
(
√w
 
L1MëaWrôeReq
).
Êù


262 
vÆ
 
ª•
 = 
	`Vec
(
nWays
, 
r°VÆ
.
˛⁄eTy≥
).
asOuçut


264 
vÆ
 
r°_˙t
 = 
	`Reg
(
öô
=
	`UI¡
(0, 
	`log2Up
(
nSës
+1)))

265 
vÆ
 
r°
 = 
r°_˙t
 < 
	`UI¡
(
nSës
)

266 
vÆ
 
waddr
 = 
	`Mux
(
r°
, 
r°_˙t
, 
io
.
wrôe
.
bôs
.
idx
)

267 
vÆ
 
wd©a
 = 
	`Mux
(
r°
, 
r°VÆ
, 
io
.
wrôe
.
bôs
.
d©a
).
asUI¡


268 
vÆ
 
wmask
 = 
	`Mux
(
r°
 || 
	`Boﬁ
(
nWays
 =1), 
	`SI¡
(-1), 
io
.
wrôe
.
bôs
.
way_í
.
asSI¡
).
toBoﬁs


269 
vÆ
 
rmask
 = 
	`Mux
(
r°
 || 
	`Boﬁ
(
nWays
 =1), 
	`SI¡
(-1), 
io
.
ªad
.
bôs
.
way_í
.
asSI¡
).
toBoﬁs


270 
	`whí
 (
r°
Ë{ 
r°_˙t
 :r°_˙t+
	`UI¡
(1) }

272 
vÆ
 
mëabôs
 = 
r°VÆ
.
gëWidth


273 
vÆ
 
èg_¨øy
 = 
	`SeqMem
(
nSës
, 
	`Vec
(
nWays
, 
	`UI¡
(
width
 = 
mëabôs
)))

274 
vÆ
 
wí
 = 
r°
 || 
io
.
wrôe
.
vÆid


275 
	`whí
 (
wí
) {

276 
èg_¨øy
.
	`wrôe
(
waddr
, 
Vec
.
	`fûl
(
nWays
)(
wd©a
), 
wmask
)

278 
io
.
ª•
 :
èg_¨øy
.
	`ªad
(io.
ªad
.
bôs
.
idx
, io.ªad.
	`fúe
()).
	`m≠
(
r°VÆ
.
	`‰omBôs
(
_
))

280 
io
.
ªad
.
ªady
 :!
wí


281 
io
.
wrôe
.
ªady
 :!
r°


282 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCacheArbiter.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 ˛as†
	cHñœCacheArbôî
(
n
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ


11 
vÆ
 
io
 = 
√w
 
BundÀ
 {

12 
vÆ
 
ªque°‹
 = 
	`Vec
(
n
, 
√w
 
HñœCacheIO
).
Êù


13 
vÆ
 
mem
 = 
√w
 
HñœCacheIO


16 i‡(
n
 == 1) {

17 
io
.
mem
 <> io.
ªque°‹
.
hód


18 
	}
} {

19 
vÆ
 
s1_id
 = 
Reg
(
UI¡
())

20 
vÆ
 
s2_id
 = 
Reg
(
√xt
=
s1_id
)

22 
io
.
mem
.
kìp_˛ock_íabÀd
 :io.
ªque°‹
.
m≠
(
_
.kìp_˛ock_íabÀd).
ªdu˚
(_||_)

24 
io
.
mem
.
ªq
.
vÆid
 :io.
ªque°‹
.
m≠
(
_
.ªq.vÆid).
ªdu˚
(_||_)

25 
io
.
ªque°‹
(0).
ªq
.
ªady
 :io.
mem
.req.ready

26 
i
 <- 1 
u¡û
 
n
)

27 
io
.
ªque°‹
(
i
).
ªq
.
ªady
 :io.ªque°‹(i-1).ªq.ªady && !io.ªque°‹(i-1).ªq.
vÆid


29 
i
 <- 
n
-1 
to
 0 
by
 -1) {

30 
vÆ
 
ªq
 = 
io
.
ªque°‹
(
i
).req

31 
def
 
c⁄√˘_s0
() = {

32 
io
.
mem
.
ªq
.
bôs
.
cmd
 :=Ñeq.bits.cmd

33 
io
.
mem
.
ªq
.
bôs
.
typ
 :=Ñeq.bits.typ

34 
io
.
mem
.
ªq
.
bôs
.
addr
 :=Ñeq.bits.addr

35 
io
.
mem
.
ªq
.
bôs
.
phys
 :=Ñeq.bits.phys

36 
io
.
mem
.
ªq
.
bôs
.
èg
 :
C©
‘eq.bôs.èg, 
UI¡
(
i
, 
log2Up
(
n
)))

37 
	gs1_id
 :
UI¡
(
i
)

39 
def
 
c⁄√˘_s1
() = {

40 
io
.
mem
.
s1_kûl
 :io.
ªque°‹
(
i
).s1_kill

41 
io
.
mem
.
s1_d©a
 :io.
ªque°‹
(
i
).s1_data

43 
def
 
c⁄√˘_s2
() = {

44 
io
.
mem
.
s2_kûl
 :io.
ªque°‹
(
i
).s2_kill

47 i‡(
i
 =
n
-1) {

48 
c⁄√˘_s0
()

49 
c⁄√˘_s1
()

50 
c⁄√˘_s2
()

52 
whí
 (
ªq
.
vÆid
Ë{ 
c⁄√˘_s0
() }

53 
whí
 (
s1_id
 ==
UI¡
(
i
)Ë{ 
c⁄√˘_s1
() }

54 
whí
 (
s2_id
 ==
UI¡
(
i
)Ë{ 
c⁄√˘_s2
() }

58 
i
 <- 0 
u¡û
 
n
) {

59 
vÆ
 
ª•
 = 
io
.
ªque°‹
(
i
).resp

60 
vÆ
 
èg_hô
 = 
io
.
mem
.
ª•
.
bôs
.
èg
(
log2Up
(
n
)-1,0Ë==
UI¡
(
i
)

61 
ª•
.
vÆid
 :
io
.
mem
.ª•.vÆid && 
èg_hô


62 
io
.
ªque°‹
(
i
).
s2_x˝t
 :io.
mem
.s2_xcpt

63 
io
.
ªque°‹
(
i
).
‹dîed
 :io.
mem
.ordered

64 
io
.
ªque°‹
(
i
).
≥rf
 :io.
mem
.perf

65 
io
.
ªque°‹
(
i
).
s2_«ck
 :io.
mem
.s2_«ck && 
s2_id
 ==
UI¡
(i)

66 
io
.
ªque°‹
(
i
).
s2_«ck_ˇu£_øw
 :io.
mem
.s2_nack_cause_raw

67 
io
.
ªque°‹
(
i
).
˛ock_íabÀd
 :io.
mem
.clock_enabled

68 
ª•
.
bôs
 :
io
.
mem
.resp.bits

69 
ª•
.
bôs
.
èg
 :
io
.
mem
.ª•.bôs.èg >> 
log2Up
(
n
)

71 
io
.
ªque°‹
(
i
).
ª∂ay_√xt
 :io.
mem
.replay_next

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IBuf.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 ˛as†
	cIn°ru˘i⁄
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
P¨amëîizedBundÀ
 
wôh
 
HasC‹eP¨amëîs
 {

12 
vÆ
 
x˝t0
 = 
√w
 
Fr⁄ãndEx˚±i⁄s


13 
vÆ
 
x˝t1
 = 
√w
 
Fr⁄ãndEx˚±i⁄s


14 
vÆ
 
ª∂ay
 = 
	$Boﬁ
()

15 
vÆ
 
rvc
 = 
	$Boﬁ
()

16 
vÆ
 
ö°
 = 
√w
 
Ex∑ndedIn°ru˘i⁄


17 
vÆ
 
øw
 = 
	$UI¡
(
width
 = 32)

18 
	`ªquúe
(
c‹eIn°Bôs
 =(i‡(
usögCom¥es£d
) 16 32))

21 ˛as†
	cIBuf
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
C‹eModuÀ
 {

22 
vÆ
 
io
 = 
√w
 
BundÀ
 {

23 
vÆ
 
imem
 = 
	`Decou∂ed
(
√w
 
Fr⁄ãndRe•
).
Êù


24 
vÆ
 
kûl
 = 
	`Boﬁ
(
INPUT
)

25 
vÆ
 
pc
 = 
	`UI¡
(
OUTPUT
, 
vaddrBôsExãnded
)

26 
vÆ
 
btb_ª•
 = 
√w
 
	`BTBRe•
().
asOuçut


27 
vÆ
 
ö°
 = 
	`Vec
(
ªtúeWidth
, 
	`Decou∂ed
(
√w
 
In°ru˘i⁄
))

31 
	$ªquúe
(
decodeWidth
 == 1)

33 
vÆ
 
n
 = 
„tchWidth
 - 1

34 
vÆ
 
nBufVÆid
 = i‡(
n
 =0Ë
	$UI¡
(0Ë
	`Reg
(
öô
=
	`UI¡
(0, 
	$log2Ceû
(
„tchWidth
)))

35 
vÆ
 
buf
 = 
	$Reg
(
io
.
imem
.
bôs
)

36 
vÆ
 
ibufBTBRe•
 = 
	$Reg
(
√w
 
BTBRe•
)

37 
vÆ
 
pcW‹dMask
 = 
	`UI¡
(
c‹eIn°Byãs
*
„tchWidth
-1, 
vaddrBôsExãnded
)

39 
vÆ
 
pcW‹dBôs
 = 
io
.
imem
.
bôs
.
pc
.
	`exåa˘
(
	`log2Ceû
(
„tchWidth
*
c‹eIn°Byãs
)-1, 
	$log2Ceû
(
c‹eIn°Byãs
))

40 
vÆ
 
nRódy
 = 
	`Wúe
(
öô
 = 
	`UI¡
(0, 
	`log2Ceû
(
„tchWidth
+1)))

41 
vÆ
 
nIC
 = 
	`Mux
(
io
.
imem
.
bôs
.
btb
.
èkí
, io.imem.bôs.btb.
bridx
 +& 1, 
	`UI¡
(
„tchWidth
)Ë- 
pcW‹dBôs


42 
vÆ
 
nICRódy
 = 
nRódy
 - 
nBufVÆid


43 
vÆ
 
nVÆid
 = 
	`Mux
(
io
.
imem
.
vÆid
, 
nIC
, 
	`UI¡
(0)Ë+ 
nBufVÆid


44 
io
.
imem
.
ªady
 :io.
	`ö°
(0).ªady && 
nRódy
 >
nBufVÆid
 && (
nICRódy
 >
nIC
 || 
n
 >=ÇIC -ÇICReady)

46 i‡(
n
 > 0) {

47 
	`whí
 (
io
.
	`ö°
(0).
ªady
) {

48 
nBufVÆid
 :
	`Mux
(
nRódy
 >nBufVÆid, 
	`UI¡
(0),ÇBufValid -ÇReady)

49 i‡(
n
 > 1Ë
	`whí
 (
nRódy
 > 0 &&ÇRódy < 
nBufVÆid
) {

50 
vÆ
 
shi·edBuf
 = 
	`shi·In¢Right
(
buf
.
	`d©a
(
n
*
c‹eIn°Bôs
-1, c‹eIn°Bôs), (
nRódy
-1)(
	`log2Ceû
(n-1)-1,0))

51 
buf
.
d©a
 :
	`C©
(buf.
	`d©a
(
n
*
c‹eIn°Bôs
-1, (n-1)*c‹eIn°Bôs), 
	`shi·edBuf
((n-1)*coreInstBits-1, 0))

52 
buf
.
pc
 :buf.p¯& ~
pcW‹dMask
 | (buf.p¯+ (
nRódy
 << 
	`log2Ceû
(
c‹eIn°Byãs
))) &ÖcWordMask

54 
	`whí
 (
io
.
imem
.
vÆid
 && 
nRódy
 >
nBufVÆid
 && 
nICRódy
 < 
nIC
 && 
n
 >=ÇIC -ÇICReady) {

55 
vÆ
 
shamt
 = 
pcW‹dBôs
 + 
nICRódy


56 
nBufVÆid
 :
nIC
 - 
nICRódy


57 
buf
 :
io
.
imem
.
bôs


58 
buf
.
d©a
 :
	`shi·In¢Right
(
io
.
imem
.
bôs
.d©a, 
shamt
)(
n
*
c‹eIn°Bôs
-1,0)

59 
buf
.
pc
 :
io
.
imem
.
bôs
.p¯& ~
pcW‹dMask
 | (io.imem.bôs.p¯+ (
nICRódy
 << 
	`log2Ceû
(
c‹eIn°Byãs
))) &ÖcWordMask

60 
ibufBTBRe•
 :
io
.
imem
.
bôs
.
btb


63 
	`whí
 (
io
.
kûl
) {

64 
nBufVÆid
 := 0

66 
	}
}

68 
vÆ
 
icShi·Amt
 = (
„tchWidth
 + 
nBufVÆid
 - 
pcW‹dBôs
)(
log2Ceû
(fetchWidth), 0)

69 
vÆ
 
	gicD©a
 = 
shi·In¢Le·
(
C©
(
io
.
imem
.
bôs
.
d©a
, 
Fûl
(
„tchWidth
, io.imem.bôs.d©a(
c‹eIn°Bôs
-1, 0))), 
icShi·Amt
)

70 .
exåa˘
(3*
„tchWidth
*
c‹eIn°Bôs
-1, 2*fetchWidth*coreInstBits)

71 
vÆ
 
	gicMask
 = (~
UI¡
(0, 
„tchWidth
*
c‹eIn°Bôs
Ë<< (
	gnBufVÆid
 << 
	$log2Ceû
(
c‹eIn°Bôs
)))(
„tchWidth
*coreInstBits-1,0)

72 
vÆ
 
ö°
 = 
icD©a
 & 
icMask
 | 
buf
.
d©a
 & ~icMask

74 
vÆ
 
vÆid
 = (
	`UI¡ToOH
(
nVÆid
Ë- 1)(
„tchWidth
-1, 0)

75 
vÆ
 
bufMask
 = 
	`UI¡ToOH
(
nBufVÆid
) - 1

76 
vÆ
 
x˝t
 = (0 
u¡û
 
bufMask
.
gëWidth
).
	`m≠
(
i
 => 
	`Mux
(
	`bufMask
(i), 
buf
.x˝t, 
io
.
imem
.
bôs
.xcpt))

77 
vÆ
 
buf_ª∂ay
 = 
	`Mux
(
buf
.
ª∂ay
, 
bufMask
, 
	$UI¡
(0))

78 
vÆ
 
ic_ª∂ay
 = 
buf_ª∂ay
 | 
	`Mux
(
io
.
imem
.
bôs
.
ª∂ay
, 
vÆid
 & ~
bufMask
, 
	$UI¡
(0))

79 
	`as£π
(!
io
.
imem
.
vÆid
 || !io.imem.
bôs
.
btb
.
èkí
 || io.imem.bôs.btb.
bridx
 >
pcW‹dBôs
)

81 
io
.
btb_ª•
 :io.
imem
.
bôs
.
btb


82 
io
.
pc
 :
	`Mux
(
nBufVÆid
 > 0, 
buf
.pc, io.
imem
.
bôs
.pc)

83 
	$ex∑nd
(0, 0, 
ö°
)

85 
def
 
	$ex∑nd
(
i
: 
I¡
, 
j
: 
UI¡
, 
curIn°
: UI¡): 
Unô
 = i‡(ò< 
ªtúeWidth
) {

86 
vÆ
 
exp
 = 
	`ModuÀ
(
√w
 
RVCEx∑ndî
)

87 
exp
.
io
.
ö
 :
curIn°


88 
io
.
	`ö°
(
i
).
bôs
.
ö°
 :
exp
.io.
out


89 
io
.
	`ö°
(
i
).
bôs
.
øw
 :
curIn°


91 i‡(
usögCom¥es£d
) {

92 
vÆ
 
ª∂ay
 = 
	`ic_ª∂ay
(
j
Ë|| (!
exp
.
io
.
rvc
 && ic_replay(j+1))

93 
vÆ
 
fuŒ_ö¢
 = 
exp
.
io
.
rvc
 || 
	`vÆid
(
j
+1Ë|| 
	`buf_ª∂ay
(j)

94 
io
.
	`ö°
(
i
).
vÆid
 :
	`vÆid
(
j
Ë&& 
fuŒ_ö¢


95 
io
.
	`ö°
(
i
).
bôs
.
x˝t0
 :
	`x˝t
(
j
)

96 
io
.
	`ö°
(
i
).
bôs
.
x˝t1
 :
	`Mux
(
exp
.io.
rvc
, 0.U, 
	`x˝t
(
j
+1).
asUI¡
).
	`asTy≥Of
(
√w
 
Fr⁄ãndEx˚±i⁄s
)

97 
io
.
	`ö°
(
i
).
bôs
.
ª∂ay
 :=Ñeplay

98 
io
.
	`ö°
(
i
).
bôs
.
rvc
 :
exp
.io.rvc

100 
	`whí
 ((
	`bufMask
(
j
Ë&& 
exp
.
io
.
rvc
Ë|| bufMask(j+1)Ë{ io.
btb_ª•
 :
ibufBTBRe•
 }

102 
	`whí
 (
fuŒ_ö¢
 && (
i
 =0 || 
io
.
	`ö°
(i).
ªady
)Ë{ 
nRódy
 :
	`Mux
(
exp
.io.
rvc
, 
j
+1, j+2) }

104 
	`ex∑nd
(
i
+1, 
	`Mux
(
exp
.
io
.
rvc
, 
j
+1, j+2), Mux”xp.io.rvc, 
curIn°
 >> 16, curInst >> 32))

106 
	`whí
 (
i
 =0 || 
io
.
	`ö°
(i).
ªady
Ë{ 
nRódy
 := i+1 }

107 
io
.
	`ö°
(
i
).
vÆid
 :
	`vÆid
(i)

108 
io
.
	`ö°
(
i
).
bôs
.
x˝t0
 :
	`x˝t
(i)

109 
io
.
	`ö°
(
i
).
bôs
.
x˝t1
 :0.U.a
	`sTy≥Of
(
√w
 
Fr⁄ãndEx˚±i⁄s
)

110 
io
.
	`ö°
(
i
).
bôs
.
ª∂ay
 :
	`ic_ª∂ay
(i)

111 
io
.
	`ö°
(
i
).
bôs
.
rvc
 :
Ál£


113 
	`ex∑nd
(
i
+1, 
nuŒ
, 
curIn°
 >> 32)

115 
	}
}

117 
def
 
shi·In¢Le·
(
ö
: 
UI¡
, 
di°
: UInt) = {

118 
vÆ
 
r
 = 
ö
.
gëWidth
/
c‹eIn°Bôs


119 
ªquúe
(
ö
.
gëWidth
 % 
c‹eIn°Bôs
 == 0)

120 
vÆ
 
d©a
 = 
C©
(
Fûl
((1 << (
log2Ceû
(
r
Ë+ 1)Ë-Ñ, 
ö
 >> (r-1)*
c‹eIn°Bôs
), in)

121 
	gd©a
 << (
	gdi°
 << 
log2Ceû
(
c‹eIn°Bôs
))

124 
def
 
shi·In¢Right
(
ö
: 
UI¡
, 
di°
: UInt) = {

125 
vÆ
 
r
 = 
ö
.
gëWidth
/
c‹eIn°Bôs


126 
ªquúe
(
ö
.
gëWidth
 % 
c‹eIn°Bôs
 == 0)

127 
vÆ
 
d©a
 = 
C©
(
Fûl
((1 << (
log2Ceû
(
r
Ë+ 1)Ë-Ñ, 
ö
 >> (r-1)*
c‹eIn°Bôs
), in)

128 
	gd©a
 >> (
	gdi°
 << 
log2Ceû
(
c‹eIn°Bôs
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ICache.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gDes¸ibedSRAM
, 
	g_
}

13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


14 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


15 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
d⁄tTouch


17 
˛ass
 
	$ICacheP¨ams
(

18 
nSës
: 
I¡
 = 64,

19 
nWays
: 
I¡
 = 4,

20 
rowBôs
: 
I¡
 = 128,

21 
nTLBE¡rõs
: 
I¡
 = 32,

22 
ˇcheIdBôs
: 
I¡
 = 0,

23 
ègECC
: 
O±i⁄
[
Såög
] = 
N⁄e
,

24 
d©aECC
: 
O±i⁄
[
Såög
] = 
N⁄e
,

25 
ôimAddr
: 
O±i⁄
[
BigI¡
] = 
N⁄e
,

26 
¥e„tch
: 
Boﬁón
 = 
Ál£
,

27 
blockByãs
: 
I¡
 = 64,

28 
œãncy
: 
I¡
 = 2,

29 
„tchByãs
: 
I¡
 = 4Ë
exãnds
 
L1CacheP¨ams
 {

30 
def
 
ègCode
: 
Code
 = Code.
	`‰omSåög
(
ègECC
)

31 
def
 
d©aCode
: 
Code
 = Code.
	`‰omSåög
(
d©aECC
)

32 
def
 
ª∂a˚mít
 = 
√w
 
	`R™domRïœ˚mít
(
nWays
)

33 
	}
}

35 
åaô
 
HasL1ICacheP¨amëîs
 
exãnds
 
HasL1CacheP¨amëîs
 
wôh
 
HasC‹eP¨amëîs
 {

36 
vÆ
 
ˇcheP¨ams
 = 
tûeP¨ams
.
iˇche
.
gë


39 ˛as†
	cICacheReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
Ë
wôh
 
HasL1ICacheP¨amëîs
 {

40 
vÆ
 
addr
 = 
	`UI¡
(
width
 = 
vaddrBôs
)

43 ˛as†
	cICacheEº‹s
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
)

44 
wôh
 
HasL1ICacheP¨amëîs


45 
wôh
 
C™HaveEº‹s
 {

46 
vÆ
 
c‹ª˘abÀ
 = (
ˇcheP¨ams
.
ègCode
.
ˇnDëe˘
 || cacheP¨ams.
d©aCode
.ˇnDëe˘).
	`›ti⁄
(
	`VÆid
(
	$UI¡
(
width
 = 
∑ddrBôs
)))

47 
vÆ
 
unc‹ª˘abÀ
 = (
ˇcheP¨ams
.
ôimAddr
.
n⁄Em±y
 && cacheP¨ams.
d©aCode
.
ˇnDëe˘
).
	`›ti⁄
(
	`VÆid
(
	`UI¡
(
width
 = 
∑ddrBôs
)))

50 
˛ass
 
	$ICache
(
vÆ
 
iˇcheP¨ams
: 
ICacheP¨ams
, vÆ 
h¨tId
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

51 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`ICacheModuÀ
(
this
)

52 
vÆ
 
ma°îNode
 = 
	`TLClõ¡Node
(
	`Seq
(
	`TLClõ¡P‹tP¨amëîs
(Seq(
	`TLClõ¡P¨amëîs
(

53 
sour˚Id
 = 
	`IdR™ge
(0, 1 + 
iˇcheP¨ams
.
¥e„tch
.
toI¡
),

54 
«me
 = 
s
"Core ${hartId} ICache")))))

56 
vÆ
 
size
 = 
iˇcheP¨ams
.
nSës
 * iˇcheP¨ams.
nWays
 * iˇcheP¨ams.
blockByãs


57 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("ôim", 
	`Seq
("sifive,itim0"))

58 
¥iv©e
 
vÆ
 
w‹dByãs
 = 
iˇcheP¨ams
.
„tchByãs


59 
vÆ
 
¶aveNode
 =

60 
	`TLM™agîNode
(
iˇcheP¨ams
.
ôimAddr
.
toSeq
.
m≠
 { itimAdd∏=> 
	`TLM™agîP‹tP¨amëîs
(

61 
	`Seq
(
	`TLM™agîP¨amëîs
(

62 
addªss
 = 
	`Seq
(
	`AddªssSë
(
ôimAddr
, 
size
-1)),

63 
ªsour˚s
 = 
devi˚
.
	`ªg
("mem"),

64 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHEABLE
,

65 
execuèbÀ
 = 
åue
,

66 
suµ‹tsPutFuŒ
 = 
	`Tøns„rSizes
(1, 
w‹dByãs
),

67 
suµ‹tsPutP¨tül
 = 
	`Tøns„rSizes
(1, 
w‹dByãs
),

68 
suµ‹tsGë
 = 
	`Tøns„rSizes
(1, 
w‹dByãs
),

69 
fifoId
 = 
	`Some
(0))),

70 
bótByãs
 = 
w‹dByãs
,

71 
möL©ícy
 = 1)})

72 
	}
}

74 ˛as†
	cICacheRe•
(
ouãr
: 
ICache
Ë
exãnds
 
BundÀ
 {

75 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
ouãr
.
iˇcheP¨ams
.
„tchByãs
*8)

76 
vÆ
 
ª∂ay
 = 
	$Boﬁ
()

77 
vÆ
 
´
 = 
	$Boﬁ
()

79 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`ICacheRe•
(
ouãr
).
asIn°™˚Of
[
this
.
ty≥
]

82 ˛as†
	cICachePîfEvíts
 
exãnds
 
BundÀ
 {

83 
vÆ
 
acquúe
 = 
	`Boﬁ
()

86 
˛ass
 
	$ICacheBundÀ
(
vÆ
 
ouãr
: 
ICache
Ë
exãnds
 
	$C‹eBundÀ
()(
ouãr
.
p
) {

87 
vÆ
 
h¨tid
 = 
	`UI¡
(
INPUT
, 
h¨tIdLí
)

88 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
ICacheReq
).
Êù


89 
vÆ
 
s1_∑ddr
 = 
	`UI¡
(
INPUT
, 
∑ddrBôs
)

90 
vÆ
 
s2_vaddr
 = 
	`UI¡
(
INPUT
, 
vaddrBôs
)

91 
vÆ
 
s1_kûl
 = 
	`Boﬁ
(
INPUT
)

92 
vÆ
 
s2_kûl
 = 
	`Boﬁ
(
INPUT
)

93 
vÆ
 
s2_¥e„tch
 = 
	`Boﬁ
(
INPUT
)

95 
vÆ
 
ª•
 = 
	`VÆid
(
√w
 
	`ICacheRe•
(
ouãr
))

96 
vÆ
 
övÆid©e
 = 
	`Boﬁ
(
INPUT
)

98 
vÆ
 
îr‹s
 = 
√w
 
ICacheEº‹s


99 
vÆ
 
≥rf
 = 
√w
 
	`ICachePîfEvíts
().
asOuçut


101 
vÆ
 
˛ock_íabÀd
 = 
	`Boﬁ
(
INPUT
)

102 
vÆ
 
kìp_˛ock_íabÀd
 = 
	`Boﬁ
(
OUTPUT
)

103 
	}
}

105 ˛as†
	cICacheModuÀ
(
ouãr
: 
ICache
Ë
exãnds
 
	$LazyModuÀImp
(
ouãr
)

106 
wôh
 
HasL1ICacheP¨amëîs
 {

107 
ovîride
 
vÆ
 
ˇcheP¨ams
 = 
ouãr
.
iˇcheP¨ams


109 
vÆ
 
io
 = 
	`IO
(
√w
 
	$ICacheBundÀ
(
ouãr
))

110 
	`vÆ
 (
é_out
, 
edge_out
Ë
ouãr
.
ma°îNode
.
	$out
(0)

112 
	`vÆ
 (
é_ö
, 
edge_ö
Ë
ouãr
.
¶aveNode
.
ö
.
hódO±i⁄
.
unzù


114 
vÆ
 
tECC
 = 
ˇcheP¨ams
.
ègCode


115 
vÆ
 
dECC
 = 
ˇcheP¨ams
.
d©aCode


117 
	`ªquúe
(
	`isPow2
(
nSës
Ë&& 
	$isPow2
(
nWays
))

118 
	`ªquúe
(!
usögVM
 || 
pgIdxBôs
 >
u¡agBôs
)

120 
vÆ
 
s¸©ch∑dOn
 = 
	$RegInô
(
Ál£
.
B
)

121 
vÆ
 
s¸©ch∑dMax
 = 
é_ö
.
	`m≠
(
é
 => 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Ceû
(
nSës
 * (
nWays
 - 1)))))

122 
def
 
	`löeInS¸©ch∑d
(
löe
: 
UI¡
Ë
s¸©ch∑dMax
.
	`m≠
(
s¸©ch∑dOn
 &&Üöê<
_
).
	$gëOrEl£
(
Ál£
.
B
)

123 
vÆ
 
s¸©ch∑dBa£
 = 
ouãr
.
iˇcheP¨ams
.
ôimAddr
.
m≠
 { 
dummy
 =>

124 
	`p
(
LookupByH¨tId
)(
_
.
iˇche
.
	`Ê©M≠
(_.
ôimAddr
.
	`m≠
(_.
U
)), 
io
.
h¨tid
)

126 
def
 
	`addrMaybeInS¸©ch∑d
(
addr
: 
UI¡
Ë
s¸©ch∑dBa£
.
	`m≠
(
ba£
 =>ádd∏>ba£ &&ádd∏< ba£ + 
ouãr
.
size
).
	$gëOrEl£
(
Ál£
.
B
)

127 
def
 
	`addrInS¸©ch∑d
(
addr
: 
UI¡
Ë
	`addrMaybeInS¸©ch∑d
◊ddrË&& 
	`löeInS¸©ch∑d
(
	`addr
(
u¡agBôs
+
	`log2Ceû
(
nWays
)-1, 
blockOffBôs
))

128 
def
 
	`s¸©ch∑dWay
(
addr
: 
UI¡
Ëaddr.
	`exåa˘
(
u¡agBôs
+
	`log2Ceû
(
nWays
)-1, untagBits)

129 
def
 
	`s¸©ch∑dWayVÆid
(
way
: 
UI¡
Ëway < 
nWays
 - 1

130 
def
 
	`s¸©ch∑dLöe
(
addr
: 
UI¡
Ë
	`addr
(
u¡agBôs
+
	`log2Ceû
(
nWays
)-1, 
blockOffBôs
)

131 
vÆ
 
s0_¶aveVÆid
 = 
é_ö
.
	`m≠
(
_
.
a
.
	`fúe
()).
	$gëOrEl£
(
Ál£
.
B
)

132 
vÆ
 
s1_¶aveVÆid
 = 
	$RegNext
(
s0_¶aveVÆid
, 
Ál£
.
B
)

133 
vÆ
 
s2_¶aveVÆid
 = 
	$RegNext
(
s1_¶aveVÆid
, 
Ál£
.
B
)

134 
vÆ
 
s3_¶aveVÆid
 = 
	$RegNext
(
Ál£
.
B
)

136 
vÆ
 
s1_vÆid
 = 
	`Reg
(
öô
=
	$Boﬁ
(
Ál£
))

137 
vÆ
 
s1_èg_hô
 = 
	`Wúe
(
	`Vec
(
nWays
, 
	$Boﬁ
()))

138 
vÆ
 
s1_hô
 = 
s1_èg_hô
.
	`ªdu˚
(
_
||_Ë|| 
	`Mux
(
s1_¶aveVÆid
, 
åue
.
B
, 
	$addrMaybeInS¸©ch∑d
(
io
.
s1_∑ddr
))

139 
	$d⁄tTouch
(
s1_hô
)

140 
vÆ
 
s2_vÆid
 = 
	`RegNext
(
s1_vÆid
 && !
io
.
s1_kûl
, 
	$Boﬁ
(
Ál£
))

141 
vÆ
 
s2_hô
 = 
	$RegNext
(
s1_hô
)

143 
vÆ
 
övÆid©ed
 = 
	`Reg
(
	$Boﬁ
())

144 
vÆ
 
ªfûl_vÆid
 = 
	$RegInô
(
Ál£
.
B
)

145 
vÆ
 
£nd_höt
 = 
	$RegInô
(
Ál£
.
B
)

146 
vÆ
 
ªfûl_fúe
 = 
é_out
.
a
.
	`fúe
(Ë&& !
£nd_höt


147 
vÆ
 
höt_out°™dög
 = 
	$RegInô
(
Ál£
.
B
)

148 
vÆ
 
s2_miss
 = 
s2_vÆid
 && !
s2_hô
 && !
io
.
s2_kûl


149 
vÆ
 
s1_ˇn_ªque°_ªfûl
 = !(
s2_miss
 || 
ªfûl_vÆid
)

150 
vÆ
 
s2_ªque°_ªfûl
 = 
s2_miss
 && 
	$RegNext
(
s1_ˇn_ªque°_ªfûl
)

151 
vÆ
 
ªfûl_addr
 = 
	$RegE«bÀ
(
io
.
s1_∑ddr
, 
s1_vÆid
 && 
s1_ˇn_ªque°_ªfûl
)

152 
vÆ
 
ªfûl_èg
 = 
	`ªfûl_addr
(
ègBôs
+
u¡agBôs
-1,untagBits)

153 
vÆ
 
ªfûl_idx
 = 
	`ªfûl_addr
(
u¡agBôs
-1,
blockOffBôs
)

154 
vÆ
 
ªfûl_⁄e_bót
 = 
é_out
.
d
.
	`fúe
(Ë&& 
edge_out
.
	$hasD©a
(
é_out
.
d
.
bôs
)

156 
io
.
ªq
.
ªady
 :!(
ªfûl_⁄e_bót
 || 
s0_¶aveVÆid
 || 
s3_¶aveVÆid
)

157 
vÆ
 
s0_vÆid
 = 
io
.
ªq
.
	$fúe
()

158 
vÆ
 
s0_vaddr
 = 
io
.
ªq
.
bôs
.
addr


159 
s1_vÆid
 :
s0_vÆid


161 
	`vÆ
 (
_
, _, 
d_d⁄e
, 
ªfûl_˙t
Ë
edge_out
.
	$cou¡
(
é_out
.
d
)

162 
vÆ
 
ªfûl_d⁄e
 = 
ªfûl_⁄e_bót
 && 
d_d⁄e


163 
é_out
.
d
.
ªady
 :!
s3_¶aveVÆid


164 
	`ªquúe
 (
edge_out
.
m™agî
.
möL©ícy
 > 0)

166 
vÆ
 
ª∂_way
 = i‡(
isDM
Ë
	$UI¡
(0) {

168 
vÆ
 
v0
 = 
	`LFSR16
(
ªfûl_fúe
)(
	`log2Up
(
nWays
)-1,0)

169 
v¨
 
v
 = 
v0


170 
i
 <- 
	`log2Ceû
(
nWays
Ë- 1 
to
 0 
by
 -1) {

171 
vÆ
 
mask
 = 
nWays
 - (
	`BigI¡
(1Ë<< (
i
 + 1))

172 
v
 = v | (
	`löeInS¸©ch∑d
(
	`C©
(
v0
 | 
mask
.
U
, 
ªfûl_idx
)Ë<< 
i
)

174 
	`as£π
(!
	`löeInS¸©ch∑d
(
	`C©
(
v
, 
ªfûl_idx
)))

175 
v


176 
	}
}

178 
vÆ
 
	gèg_¨øy
 = 
Des¸ibedSRAM
(

179 
«me
 = "tag_array",

180 
desc
 = "ICache Tag Array",

181 
size
 = 
nSës
,

182 
d©a
 = 
Vec
(
nWays
, 
UI¡
(
width
 = 
tECC
.width(1 + 
ègBôs
)))

185 
vÆ
 
èg_rd©a
 = 
èg_¨øy
.
ªad
(
s0_vaddr
(
u¡agBôs
-1,
blockOffBôs
), !
ªfûl_d⁄e
 && 
s0_vÆid
)

186 
vÆ
 
	gac¸uedRefûlEº‹
 = 
Reg
(
	$Boﬁ
())

187 
	$whí
 (
ªfûl_d⁄e
) {

189 
vÆ
 
íc_èg
 = 
tECC
.
	`ícode
(
	`C©
(
é_out
.
d
.
bôs
.
c‹ru±
, 
ªfûl_èg
))

190 
èg_¨øy
.
	`wrôe
(
ªfûl_idx
, 
Vec
.
	`fûl
(
nWays
)(
íc_èg
), 
Seq
.
	`èbuœã
“Ways)(
ª∂_way
 ==
_
))

192 
	`ccovî
(
é_out
.
d
.
bôs
.
c‹ru±
, "D_CORRUPT", "I$ D-channel corrupt")

193 
	}
}

195 
vÆ
 
	gvb_¨øy
 = 
Reg
(
öô
=
	$Bôs
(0, 
nSës
*
nWays
))

196 
	$whí
 (
ªfûl_⁄e_bót
) {

198 
vb_¨øy
 :vb_¨øy.
	`bôSë
(
	`C©
(
ª∂_way
, 
ªfûl_idx
), 
ªfûl_d⁄e
 && !
övÆid©ed
)

199 
	}
}

200 
vÆ
 
	gövÆid©e
 = 
	$Wúe
(
öô
 = 
io
.
övÆid©e
)

201 
	$whí
 (
övÆid©e
) {

202 
vb_¨øy
 :
	`Bôs
(0)

203 
övÆid©ed
 :
	`Boﬁ
(
åue
)

204 
	}
}

206 
vÆ
 
s1_èg_di•¨ôy
 = 
Wúe
(
Vec
(
nWays
, 
	$Boﬁ
()))

207 
vÆ
 
s1_é_îr‹
 = 
	`Wúe
(
	`Vec
(
nWays
, 
	$Boﬁ
()))

208 
vÆ
 
w‹dBôs
 = 
ouãr
.
iˇcheP¨ams
.
„tchByãs
*8

209 
vÆ
 
s1_dout
 = 
	`Wúe
(
	`Vec
(
nWays
, 
	`UI¡
(
width
 = 
dECC
.
	$width
(
w‹dBôs
))))

211 
vÆ
 
s0_¶aveAddr
 = 
é_ö
.
	`m≠
(
_
.
a
.
bôs
.
addªss
).
	$gëOrEl£
(0.U)

212 
vÆ
 
s1s3_¶aveAddr
 = 
	`Reg
(
	`UI¡
(
width
 = 
	$log2Ceû
(
ouãr
.
size
)))

213 
vÆ
 
s1s3_¶aveD©a
 = 
	`Reg
(
	$UI¡
(
width
 = 
w‹dBôs
))

215 
i
 <- 0 
u¡û
 
nWays
) {

216 
vÆ
 
s1_idx
 = 
io
.
	`s1_∑ddr
(
u¡agBôs
-1,
blockOffBôs
)

217 
vÆ
 
s1_èg
 = 
io
.
	`s1_∑ddr
(
ègBôs
+
u¡agBôs
-1,untagBits)

218 
vÆ
 
s¸©ch∑dHô
 = 
	`s¸©ch∑dWayVÆid
(
i
) &&

219 
	`Mux
(
s1_¶aveVÆid
,

220 
	`löeInS¸©ch∑d
(
	`s¸©ch∑dLöe
(
s1s3_¶aveAddr
)Ë&& 
	`s¸©ch∑dWay
(s1s3_¶aveAddrË==
i
,

221 
	`addrInS¸©ch∑d
(
io
.
s1_∑ddr
Ë&& 
	`s¸©ch∑dWay
(io.s1_∑ddrË==
i
)

222 
vÆ
 
s1_vb
 = 
	`vb_¨øy
(
	`C©
(
	`UI¡
(
i
), 
s1_idx
)Ë&& !
s1_¶aveVÆid


223 
vÆ
 
íc_èg
 = 
tECC
.
	`decode
(
	`èg_rd©a
(
i
))

224 
	`vÆ
 (
é_îr‹
, 
èg
Ë
	`S∂ô
(
íc_èg
.
unc‹ª˘ed
, 
ègBôs
)

225 
vÆ
 
ègM©ch
 = 
s1_vb
 && 
èg
 ==
s1_èg


226 
	`s1_èg_di•¨ôy
(
i
Ë:
s1_vb
 && 
íc_èg
.
îr‹


227 
	`s1_é_îr‹
(
i
Ë:
ègM©ch
 && 
é_îr‹
.
toBoﬁ


228 
	`s1_èg_hô
(
i
Ë:
ègM©ch
 || 
s¸©ch∑dHô


229 
	}
}

230 
as£π
(!(
s1_vÆid
 || 
s1_¶aveVÆid
Ë|| 
P›Cou¡
(
s1_èg_hô
 
zù
 
s1_èg_di•¨ôy
 
m≠
 { (
h
, 
d
) => h && !d }) <= 1)

232 
ªquúe
(
é_out
.
d
.
bôs
.
d©a
.
gëWidth
 % 
w‹dBôs
 == 0)

234 
vÆ
 
d©a_¨øys
 = 
Seq
.
èbuœã
(
é_out
.
d
.
bôs
.
d©a
.
gëWidth
 / 
w‹dBôs
) {

235 
i
 =>

236 
Des¸ibedSRAM
(

237 
«me
 = 
s
"data_arrays_${i}",

238 
desc
 = "ICache Data Array",

239 
size
 = 
nSës
 * 
ªfûlCy˛es
,

240 
d©a
 = 
Vec
(
nWays
, 
UI¡
(
width
 = 
dECC
.width(
w‹dBôs
)))

244 (
	gd©a_¨øy
, 
	gi
Ë<- 
d©a_¨øys
 
	gzùWôhIndex
) {

245 
def
 
w‹dM©ch
(
addr
: 
UI¡
Ëaddr.
exåa˘
(
log2Ceû
(
é_out
.
d
.
bôs
.
d©a
.
gëWidth
/8)-1,Üog2Ceû(
w‹dBôs
/8)Ë==
i


246 
def
 
row
(
addr
: 
UI¡
Ëaddr(
u¡agBôs
-1, 
blockOffBôs
-
log2Ceû
(
ªfûlCy˛es
))

247 
vÆ
 
	gs0_ªn
 = (
s0_vÆid
 && 
w‹dM©ch
(
s0_vaddr
)Ë|| (
s0_¶aveVÆid
 && w‹dM©ch(
s0_¶aveAddr
))

248 
vÆ
 
wí
 = (
ªfûl_⁄e_bót
 && !
övÆid©ed
Ë|| (
s3_¶aveVÆid
 && 
w‹dM©ch
(
s1s3_¶aveAddr
))

249 
vÆ
 
mem_idx
 = 
Mux
(
ªfûl_⁄e_bót
, (
ªfûl_idx
 << 
log2Ceû
(
ªfûlCy˛es
)Ë| 
ªfûl_˙t
,

250 
Mux
(
s3_¶aveVÆid
, 
row
(
s1s3_¶aveAddr
),

251 
Mux
(
s0_¶aveVÆid
, 
row
(
s0_¶aveAddr
),

252 
row
(
s0_vaddr
))))

253 
whí
 (
wí
) {

254 
vÆ
 
	gd©a
 = 
Mux
(
s3_¶aveVÆid
, 
s1s3_¶aveD©a
, 
é_out
.
d
.
bôs
.
d©a
(
w‹dBôs
*(
i
+1)-1, wordBits*i))

255 
vÆ
 
	gway
 = 
Mux
(
s3_¶aveVÆid
, 
s¸©ch∑dWay
(
s1s3_¶aveAddr
), 
ª∂_way
)

256 
	gd©a_¨øy
.
wrôe
(
mem_idx
, 
Vec
.
fûl
(
nWays
)(
dECC
.
ícode
(
d©a
)), (0 
u¡û
ÇWays).
m≠
(
way
 ==
_
))

258 
vÆ
 
	gdout
 = 
d©a_¨øy
.
ªad
(
mem_idx
, !
wí
 && 
s0_ªn
)

259 
whí
 (
w‹dM©ch
(
Mux
(
s1_¶aveVÆid
, 
s1s3_¶aveAddr
, 
io
.
s1_∑ddr
))) {

260 
	gs1_dout
 :
dout


264 
vÆ
 
s1_˛k_í
 = 
s1_vÆid
 || 
s1_¶aveVÆid


265 
vÆ
 
s2_èg_hô
 = 
	$RegE«bÀ
(
s1_èg_hô
, 
s1_˛k_í
)

266 
vÆ
 
s2_hô_way
 = 
	$OHToUI¡
(
s2_èg_hô
)

267 
vÆ
 
s2_s¸©ch∑d_w‹d_addr
 = 
	`C©
(
s2_hô_way
, 
	$Mux
(
s2_¶aveVÆid
, 
s1s3_¶aveAddr
, 
io
.
s2_vaddr
)(
u¡agBôs
-1, 
	`log2Ceû
(
w‹dBôs
/8)), 
	`UI¡
(0,Üog2Ceil(wordBits/8)))

268 
vÆ
 
s2_dout
 = 
	$RegE«bÀ
(
s1_dout
, 
s1_˛k_í
)

269 
vÆ
 
s2_way_mux
 = 
	$Mux1H
(
s2_èg_hô
, 
s2_dout
)

271 
vÆ
 
s2_èg_di•¨ôy
 = 
	`RegE«bÀ
(
s1_èg_di•¨ôy
, 
s1_˛k_í
).
asUI¡
.
‹R


272 
vÆ
 
s2_é_îr‹
 = 
	$RegE«bÀ
(
s1_é_îr‹
.
asUI¡
.
‹R
, 
s1_˛k_í
)

273 
vÆ
 
s2_d©a_decoded
 = 
dECC
.
	$decode
(
s2_way_mux
)

274 
vÆ
 
s2_di•¨ôy
 = 
s2_èg_di•¨ôy
 || 
s2_d©a_decoded
.
îr‹


275 
vÆ
 
s2_fuŒ_w‹d_wrôe
 = 
	$Wúe
(
öô
 = 
Ál£
.
B
)

277 
vÆ
 
s1_s¸©ch∑d_hô
 = 
	`Mux
(
s1_¶aveVÆid
, 
	`löeInS¸©ch∑d
(
	`s¸©ch∑dLöe
(
s1s3_¶aveAddr
)), 
	$addrInS¸©ch∑d
(
io
.
s1_∑ddr
))

278 
vÆ
 
s2_s¸©ch∑d_hô
 = 
	$RegE«bÀ
(
s1_s¸©ch∑d_hô
, 
s1_˛k_í
)

279 
vÆ
 
s2_ªp‹t_unc‹ª˘abÀ_îr‹
 = 
s2_s¸©ch∑d_hô
 && 
s2_d©a_decoded
.
unc‹ª˘abÀ
 && (
s2_vÆid
 || (
s2_¶aveVÆid
 && !
s2_fuŒ_w‹d_wrôe
))

280 
vÆ
 
s2_îr‹_addr
 = 
s¸©ch∑dBa£
.
	`m≠
(
ba£
 => 
	`Mux
(
s2_s¸©ch∑d_hô
, ba£ + 
s2_s¸©ch∑d_w‹d_addr
, 0.U)).
	$gëOrEl£
(0.U)

283 
ouãr
.
iˇcheP¨ams
.
œãncy
 
m©ch
 {

285 
	`ªquúe
(
tECC
.
isIn°™˚Of
[
IdítôyCode
])

286 
	`ªquúe
(
dECC
.
isIn°™˚Of
[
IdítôyCode
])

287 
	`ªquúe
(
ouãr
.
iˇcheP¨ams
.
ôimAddr
.
isEm±y
)

288 
io
.
ª•
.
bôs
.
d©a
 :
	`Mux1H
(
s1_èg_hô
, 
s1_dout
)

289 
io
.
ª•
.
bôs
.
´
 :
s1_é_îr‹
.
asUI¡
.
‹R


290 
io
.
ª•
.
vÆid
 :
s1_vÆid
 && 
s1_hô


294 
	`whí
 (
s2_vÆid
 && 
s2_di•¨ôy
Ë{ 
övÆid©e
 :
åue
 }

296 
io
.
ª•
.
bôs
.
d©a
 :
s2_d©a_decoded
.
unc‹ª˘ed


297 
io
.
ª•
.
bôs
.
´
 :
s2_é_îr‹


298 
io
.
ª•
.
bôs
.
ª∂ay
 :
s2_di•¨ôy


299 
io
.
ª•
.
vÆid
 :
s2_vÆid
 && 
s2_hô


301 
io
.
îr‹s
.
c‹ª˘abÀ
.
f‹óch
 { 
c
 =>

302 
c
.
vÆid
 :(
s2_vÆid
 || 
s2_¶aveVÆid
Ë&& 
s2_di•¨ôy
 && !
s2_ªp‹t_unc‹ª˘abÀ_îr‹


303 
c
.
bôs
 :
s2_îr‹_addr


305 
io
.
îr‹s
.
unc‹ª˘abÀ
.
f‹óch
 { 
u
 =>

306 
u
.
vÆid
 :
s2_ªp‹t_unc‹ª˘abÀ_îr‹


307 
u
.
bôs
 :
s2_îr‹_addr


310 
é_ö
.
m≠
 { 
é
 =>

311 
vÆ
 
ª•VÆid
 = 
	`RegInô
(
Ál£
.
B
)

312 
é
.
a
.
ªady
 :!(
é_out
.
d
.
vÆid
 || 
s1_¶aveVÆid
 || 
s2_¶aveVÆid
 || 
s3_¶aveVÆid
 || 
ª•VÆid
 || !
io
.
˛ock_íabÀd
)

313 
vÆ
 
s1_a
 = 
	`RegE«bÀ
(
é
.
a
.
bôs
, 
s0_¶aveVÆid
)

314 
s2_fuŒ_w‹d_wrôe
 :
edge_ö
.
gë
.
	`hasD©a
(
s1_a
Ë&& s1_a.
mask
.
™dR


315 
	`whí
 (
s0_¶aveVÆid
) {

316 
vÆ
 
a
 = 
é
.a.
bôs


317 
s1s3_¶aveAddr
 :
é
.
a
.
bôs
.
addªss


318 
s1s3_¶aveD©a
 :
é
.
a
.
bôs
.
d©a


319 
	`whí
 (
edge_ö
.
gë
.
	`hasD©a
(
a
)) {

320 
vÆ
 
íabÀ
 = 
	`s¸©ch∑dWayVÆid
(
	`s¸©ch∑dWay
(
a
.
addªss
))

321 
	`whí
 (!
	`löeInS¸©ch∑d
(
	`s¸©ch∑dLöe
(
a
.
addªss
))) {

322 
s¸©ch∑dMax
.
gë
 :
	`s¸©ch∑dLöe
(
a
.
addªss
)

323 
övÆid©e
 :
åue


325 
s¸©ch∑dOn
 :
íabÀ


327 
vÆ
 
ôim_Æloˇãd
 = !
s¸©ch∑dOn
 && 
íabÀ


328 
vÆ
 
ôim_dóŒoˇãd
 = 
s¸©ch∑dOn
 && !
íabÀ


329 
vÆ
 
ôim_ö¸ó£
 = 
s¸©ch∑dOn
 && 
íabÀ
 && 
	`s¸©ch∑dLöe
(
a
.
addªss
Ë> 
s¸©ch∑dMax
.
gë


330 
vÆ
 
ªfûlög
 = 
ªfûl_vÆid
 && 
ªfûl_˙t
 > 0

331 
	`ccovî
(
ôim_Æloˇãd
, "ITIM_ALLOCATE", "ITIMállocated")

332 
	`ccovî
(
ôim_Æloˇãd
 && 
ªfûlög
, "ITIM_ALLOCATE_WHILE_REFILL", "ITIMállocated while I$Ñefill")

333 
	`ccovî
(
ôim_dóŒoˇãd
, "ITIM_DEALLOCATE", "ITIM deallocated")

334 
	`ccovî
(
ôim_dóŒoˇãd
 && 
ªfûlög
, "ITIM_DEALLOCATE_WHILE_REFILL", "ITIM deallocated while I$Ñefill")

335 
	`ccovî
(
ôim_ö¸ó£
, "ITIM_SIZE_INCREASE", "ITIM size increased")

336 
	`ccovî
(
ôim_ö¸ó£
 && 
ªfûlög
, "ITIM_SIZE_INCREASE_WHILE_REFILL", "ITIM size increased while I$Ñefill")

340 
	`as£π
(!
s2_vÆid
 || 
	`RegNext
(RegNext(
s0_vaddr
)Ë==
io
.
s2_vaddr
)

341 
	`whí
 (!(
é
.
a
.
vÆid
 || 
s1_¶aveVÆid
 || 
s2_¶aveVÆid
 || 
ª•VÆid
)

342 && 
s2_vÆid
 && 
s2_d©a_decoded
.
îr‹
 && !
s2_èg_di•¨ôy
) {

347 
s3_¶aveVÆid
 :
åue


348 
s1s3_¶aveD©a
 :
s2_d©a_decoded
.
c‹ª˘ed


349 
s1s3_¶aveAddr
 :
s2_s¸©ch∑d_w‹d_addr
 | 
	`s1s3_¶aveAddr
(
	`log2Ceû
(
w‹dBôs
/8)-1, 0)

352 
ª•VÆid
 :
s2_¶aveVÆid
 || (ª•VÆid && !
é
.
d
.
ªady
)

353 
vÆ
 
ª•Eº‹
 = 
	`RegE«bÀ
(
s2_s¸©ch∑d_hô
 && 
s2_d©a_decoded
.
unc‹ª˘abÀ
 && !
s2_fuŒ_w‹d_wrôe
, 
s2_¶aveVÆid
)

354 
	`whí
 (
s2_¶aveVÆid
) {

355 
	`whí
 (
edge_ö
.
gë
.
	`hasD©a
(
s1_a
Ë|| 
s2_d©a_decoded
.
îr‹
Ë{ 
s3_¶aveVÆid
 :
åue
 }

356 
def
 
	`byãEn
(
i
: 
I¡
Ë!(
edge_ö
.
gë
.
	`hasD©a
(
s1_a
Ë&& s1_a.
	`mask
(i))

357 
s1s3_¶aveD©a
 :(0 
u¡û
 
w‹dBôs
/8).
	`m≠
(
i
 => 
	`Mux
(
	`byãEn
(i), 
s2_d©a_decoded
.
c‹ª˘ed
, s1s3_¶aveD©a)(8*(i+1)-1, 8*i)).
asUI¡


360 
é
.
d
.
vÆid
 :
ª•VÆid


361 
é
.
d
.
bôs
 :
	`Mux
(
edge_ö
.
gë
.
	`hasD©a
(
s1_a
),

362 
edge_ö
.
gë
.
	`Ac˚ssAck
(
s1_a
),

363 
edge_ö
.
gë
.
	`Ac˚ssAck
(
s1_a
, 
	`UI¡
(0), 
díõd
 = 
	`Boﬁ
(
Ál£
), 
c‹ru±
 = 
ª•Eº‹
))

364 
é
.
d
.
bôs
.
d©a
 :
s1s3_¶aveD©a


367 
é
.
b
.
vÆid
 :
Ál£


368 
é
.
c
.
ªady
 :
åue


369 
é
.
e
.
ªady
 :
åue


371 
	`ccovî
(
s0_vÆid
 && 
s1_¶aveVÆid
, "CONCURRENT_ITIM_ACCESS_1", "ITIMáccessed,Åhen I$áccessedÇext cycle")

372 
	`ccovî
(
s0_vÆid
 && 
s2_¶aveVÆid
, "CONCURRENT_ITIM_ACCESS_2", "ITIMáccessed,Åhen I$áccessedÅwo cyclesÜater")

373 
	`ccovî
(
é
.
d
.
vÆid
 && !é.d.
ªady
, "ITIM_D_STALL", "ITIMÑesponse blocked by D-channel")

374 
	`ccovî
(
é_out
.
d
.
vÆid
 && !é_out.d.
ªady
, "ITIM_BLOCK_D", "D-channel blocked by ITIMáccess")

376 
	}
}

378 
	gé_out
.
	ga
.
	gvÆid
 :
s2_ªque°_ªfûl


379 
é_out
.
a
.
bôs
 :
edge_out
.
Gë
(

380 
‰omSour˚
 = 
UI¡
(0),

381 
toAddªss
 = (
ªfûl_addr
 >> 
blockOffBôs
) << blockOffBits,

382 
lgSize
 = 
lgCacheBlockByãs
).
_2


383 i‡(
ˇcheP¨ams
.
¥e„tch
) {

384 
vÆ
 (
¸os£s_∑ge
, 
√xt_block
Ë
S∂ô
(
ªfûl_addr
(
pgIdxBôs
-1, 
blockOffBôs
) +& 1,ÖgIdxBits-blockOffBits)

385 
whí
 (
é_out
.
a
.
fúe
()) {

386 
	g£nd_höt
 :!
höt_out°™dög
 && 
io
.
s2_¥e„tch
 && !
¸os£s_∑ge


387 
whí
 (
£nd_höt
) {

388 
£nd_höt
 :
Ál£


389 
höt_out°™dög
 :
åue


392 
whí
 (
ªfûl_d⁄e
) {

393 
£nd_höt
 :
Ál£


395 
whí
 (
é_out
.
d
.
fúe
(Ë&& !
ªfûl_⁄e_bót
) {

396 
höt_out°™dög
 :
Ál£


399 
whí
 (
£nd_höt
) {

400 
é_out
.
a
.
vÆid
 :
åue


401 
é_out
.
a
.
bôs
 :
edge_out
.
Höt
(

402 
‰omSour˚
 = 
UI¡
(1),

403 
toAddªss
 = 
C©
(
ªfûl_addr
 >> 
pgIdxBôs
, 
√xt_block
Ë<< 
blockOffBôs
,

404 
lgSize
 = 
lgCacheBlockByãs
,

405 
∑øm
 = 
TLHöts
.
PREFETCH_READ
).
_2


408 
ccovî
(
£nd_höt
 && !
é_out
.
a
.
ªady
, "PREFETCH_A_STALL", "I$Örefetch blocked by A-channel")

409 
ccovî
(
ªfûl_vÆid
 && (
é_out
.
d
.
fúe
(Ë&& !
ªfûl_⁄e_bót
), "PREFETCH_D_BEFORE_MISS_D", "I$ÖrefetchÑesolves before miss")

410 
ccovî
(!
ªfûl_vÆid
 && (
é_out
.
d
.
fúe
(Ë&& !
ªfûl_⁄e_bót
), "PREFETCH_D_AFTER_MISS_D", "I$ÖrefetchÑesolvesáfter miss")

411 
ccovî
(
é_out
.
a
.
fúe
(Ë&& 
höt_out°™dög
, "PREFETCH_D_AFTER_MISS_A", "I$ÖrefetchÑesolvesáfter second miss")

413 
	gé_out
.
	gb
.
	gªady
 :
	$Boﬁ
(
åue
)

414 
é_out
.
c
.
vÆid
 :
	$Boﬁ
(
Ál£
)

415 
é_out
.
e
.
vÆid
 :
	$Boﬁ
(
Ál£
)

416 
	`as£π
(!(
é_out
.
a
.
vÆid
 && 
	$addrMaybeInS¸©ch∑d
(
é_out
.
a
.
bôs
.
addªss
)))

418 
	`whí
 (!
ªfûl_vÆid
Ë{ 
övÆid©ed
 :
Ál£
.
B
 
	}
}

419 
	$whí
 (
ªfûl_fúe
Ë{ 
ªfûl_vÆid
 :
åue
.
B
 
	}
}

420 
	$whí
 (
ªfûl_d⁄e
Ë{ 
ªfûl_vÆid
 :
Ál£
.
B
}

422 
io
.
≥rf
.
acquúe
 :
ªfûl_fúe


423 
io
.
kìp_˛ock_íabÀd
 :=

424 
é_ö
.
m≠
(
é
 =>Ål.
a
.
vÆid
 ||Ål.
d
.vÆid || 
s1_¶aveVÆid
 || 
s2_¶aveVÆid
 || 
s3_¶aveVÆid
).
gëOrEl£
(
Ál£
.
B
) ||

425 
s1_vÆid
 || 
s2_vÆid
 || 
ªfûl_vÆid
 || 
£nd_höt
 || 
höt_out°™dög


427 
ccovî
(!
£nd_höt
 && (
é_out
.
a
.
vÆid
 && !é_out.a.
ªady
), "MISS_A_STALL", "I$ miss blocked by A-channel")

428 
ccovî
(
övÆid©e
 && 
ªfûl_vÆid
, "FLUSH_DURING_MISS", "I$ flushed during miss")

430 
def
 
	$ccovî
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

431 
	`covî
(
c⁄d
, 
s
"ICACHE_$œbñ", "Mem‹ySy°em;;" + 
desc
)

433 
vÆ
 
mem_a˘ive_vÆid
 = 
	`Seq
(
	`CovîBoﬁón
(
s2_vÆid
, Seq("mem_active")))

434 
vÆ
 
d©a_îr‹
 = 
	`Seq
(

435 
	`CovîBoﬁón
(!
s2_d©a_decoded
.
c‹ª˘abÀ
 && !s2_d©a_decoded.
unc‹ª˘abÀ
, 
	`Seq
("no_data_error")),

436 
	`CovîBoﬁón
(
s2_d©a_decoded
.
c‹ª˘abÀ
, 
	`Seq
("data_correctable_error")),

437 
	`CovîBoﬁón
(
s2_d©a_decoded
.
unc‹ª˘abÀ
, 
	`Seq
("data_uncorrectable_error")))

438 
vÆ
 
ªque°_sour˚
 = 
	`Seq
(

439 
	`CovîBoﬁón
(!
s2_¶aveVÆid
, 
	`Seq
("from_CPU")),

440 
	`CovîBoﬁón
(
s2_¶aveVÆid
, 
	`Seq
("from_TL"))

442 
vÆ
 
èg_îr‹
 = 
	`Seq
(

443 
	`CovîBoﬁón
(!
s2_èg_di•¨ôy
, 
	`Seq
("no_tag_error")),

444 
	`CovîBoﬁón
(
s2_èg_di•¨ôy
, 
	`Seq
("tag_error"))

446 
vÆ
 
mem_mode
 = 
	`Seq
(

447 
	`CovîBoﬁón
(
s2_s¸©ch∑d_hô
, 
	`Seq
("ITIM_mode")),

448 
	`CovîBoﬁón
(!
s2_s¸©ch∑d_hô
, 
	`Seq
("cache_mode"))

451 
vÆ
 
îr‹_¸oss_covîs
 = 
√w
 
	`CrossPr›îty
(

452 
	`Seq
(
mem_a˘ive_vÆid
, 
d©a_îr‹
, 
èg_îr‹
, 
ªque°_sour˚
, 
mem_mode
),

453 
	`Seq
(

455 
	`Seq
("tag_error", "ITIM_mode"),

457 
	`Seq
("from_TL", "cache_mode")

461 
	`covî
(
îr‹_¸oss_covîs
)

462 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IDecode.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
HasC‹eP¨amëîs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gscõ
.
SCIE


12 
imp‹t
 
	gIn°ru˘i⁄s
.
_


13 
imp‹t
 
	gALU
.
_


15 
ab°ø˘
 
åaô
 
DecodeC⁄°™ts
 
exãnds
 
	gHasC‹eP¨amëîs


17 
vÆ
 
	gèbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BitPat])]

20 ˛as†
	cI¡CålSigs
 
exãnds
 
	mBundÀ
 {

21 
vÆ
 
	mÀgÆ
 = 
	$Boﬁ
()

22 
vÆ
 
Â
 = 
	$Boﬁ
()

23 
vÆ
 
rocc
 = 
	$Boﬁ
()

24 
vÆ
 
bønch
 = 
	$Boﬁ
()

25 
vÆ
 
jÆ
 = 
	$Boﬁ
()

26 
vÆ
 
jÆr
 = 
	$Boﬁ
()

27 
vÆ
 
rxs2
 = 
	$Boﬁ
()

28 
vÆ
 
rxs1
 = 
	$Boﬁ
()

29 
vÆ
 
scõ
 = 
	$Boﬁ
()

30 
vÆ
 
£l_Æu2
 = 
	$Bôs
(
width
 = 
A2_X
.
gëWidth
)

31 
vÆ
 
£l_Æu1
 = 
	$Bôs
(
width
 = 
A1_X
.
gëWidth
)

32 
vÆ
 
£l_imm
 = 
	$Bôs
(
width
 = 
IMM_X
.
gëWidth
)

33 
vÆ
 
Æu_dw
 = 
	$Boﬁ
()

34 
vÆ
 
Æu_‚
 = 
	$Bôs
(
width
 = 
FN_X
.
gëWidth
)

35 
vÆ
 
mem
 = 
	$Boﬁ
()

36 
vÆ
 
mem_cmd
 = 
	$Bôs
(
width
 = 
M_SZ
)

37 
vÆ
 
mem_ty≥
 = 
	$Bôs
(
width
 = 
MT_SZ
)

38 
vÆ
 
rfs1
 = 
	$Boﬁ
()

39 
vÆ
 
rfs2
 = 
	$Boﬁ
()

40 
vÆ
 
rfs3
 = 
	$Boﬁ
()

41 
vÆ
 
wfd
 = 
	$Boﬁ
()

42 
vÆ
 
mul
 = 
	$Boﬁ
()

43 
vÆ
 
div
 = 
	$Boﬁ
()

44 
vÆ
 
wxd
 = 
	$Boﬁ
()

45 
vÆ
 
c§
 = 
	$Bôs
(
width
 = 
CSR
.
SZ
)

46 
vÆ
 
„n˚_i
 = 
	$Boﬁ
()

47 
vÆ
 
„n˚
 = 
	$Boﬁ
()

48 
vÆ
 
amo
 = 
	$Boﬁ
()

49 
vÆ
 
dp
 = 
	$Boﬁ
()

51 
def
 : 
Li°
[
BôP©
] =

60 
	$Li°
(
N
,
X
,X,X,X,X,X,X,X,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, X,X,X,X,X,X,X,
CSR
.X,X,X,X,X)

62 
def
 
	`decode
(
ö°
: 
UI¡
, 
èbÀ
: 
IãøbÀ
[(
BôP©
, 
Li°
[BitPat])]) = {

63 
vÆ
 
decodî
 = 
	`DecodeLogic
(
ö°
, , 
èbÀ
)

64 
vÆ
 
sigs
 = 
	`Seq
(
ÀgÆ
, 
Â
, 
rocc
, 
bønch
, 
jÆ
, 
jÆr
, 
rxs2
, 
rxs1
, 
scõ
, 
£l_Æu2
,

65 
£l_Æu1
, 
£l_imm
, 
Æu_dw
, 
Æu_‚
, 
mem
, 
mem_cmd
, 
mem_ty≥
,

66 
rfs1
, 
rfs2
, 
rfs3
, 
wfd
, 
mul
, 
div
, 
wxd
, 
c§
, 
„n˚_i
, 
„n˚
, 
amo
, 
dp
)

67 
sigs
 
zù
 
decodî
 
m≠
 {(
s
,
d
) => s := d}

68 
this


70 
	}
}

72 ˛as†
	cIDecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


74 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

75 
BNE
-> 
	`Li°
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SNE
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

76 
BEQ
-> 
	`Li°
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SEQ
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

77 
BLT
-> 
	`Li°
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SLT
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

78 
BLTU
-> 
	`Li°
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SLTU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

79 
BGE
-> 
	`Li°
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SGE
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

80 
BGEU
-> 
	`Li°
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SGEU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

82 
JAL
-> 
	`Li°
(
Y
,
N
,N,N,Y,N,N,N,N,
A2_SIZE
,
A1_PC
, 
IMM_UJ
,
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

83 
JALR
-> 
	`Li°
(
Y
,
N
,N,N,N,Y,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

84 
AUIPC
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_PC
, 
IMM_U
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

86 
LB
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_B
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

87 
LH
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_H
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

88 
LW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

89 
LBU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_BU
,N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

90 
LHU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_HU
,N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

91 
SB
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_B
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

92 
SH
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_H
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

93 
SW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_W
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

95 
LUI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_U
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

96 
ADDI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

97 
SLTI
 -> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SLT
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

98 
SLTIU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SLTU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

99 
ANDI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_AND
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

100 
ORI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_OR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

101 
XORI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_XOR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

102 
ADD
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

103 
SUB
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SUB
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

104 
SLT
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SLT
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

105 
SLTU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SLTU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

106 
AND
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_AND
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

107 
OR
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_OR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

108 
XOR
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_XOR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

109 
SLL
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

110 
SRL
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

111 
SRA
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

113 
FENCE
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,Y,N,N),

114 
FENCE_I
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, Y,
M_FLUSH_ALL
,
MT_X
, N,N,N,N,N,N,N,
CSR
.N,Y,N,N,N),

116 
SCALL
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

117 
SBREAK
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

118 
MRET
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

119 
WFI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

120 
CSRRW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
W
,N,N,N,N),

121 
CSRRS
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
S
,N,N,N,N),

122 
CSRRC
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
C
,N,N,N,N),

123 
CSRRWI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_Z
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
W
,N,N,N,N),

124 
CSRRSI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_Z
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
S
,N,N,N,N),

125 
CSRRCI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_Z
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
C
,N,N,N,N))

128 ˛as†
	cSDecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


130 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

131 
SFENCE_VMA
->
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_SFENCE
, 
MT_W
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

132 
SRET
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N))

135 ˛as†
	cDebugDecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


137 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

138 
DRET
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N))

141 ˛as†
	cI32Decode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


143 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

144 
SLLI_RV32
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

145 
SRLI_RV32
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

146 
SRAI_RV32
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

149 ˛as†
	cI64Decode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


151 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

152 
LD
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

153 
LWU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_WU
,N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

154 
SD
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_D
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

156 
SLLI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

157 
SRLI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

158 
SRAI
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

160 
ADDIW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

161 
SLLIW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

162 
SRLIW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

163 
SRAIW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

164 
ADDW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

165 
SUBW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SUB
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

166 
SLLW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

167 
SRLW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

168 
SRAW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

171 ˛as†
	cMDecode
(
pùñöedMul
: 
Boﬁón
)(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


173 
vÆ
 
M
 = i‡(
pùñöedMul
Ë
Y
 
N


174 
vÆ
 
D
 = i‡(
pùñöedMul
Ë
N
 
Y


175 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

176 
MUL
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MUL
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

177 
MULH
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MULH
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

178 
MULHU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MULHU
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

179 
MULHSU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MULHSU
,N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

181 
DIV
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_DIV
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

182 
DIVU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_DIVU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

183 
REM
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_REM
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

184 
REMU
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_REMU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N))

187 ˛as†
	cM64Decode
(
pùñöedMul
: 
Boﬁón
)(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


189 
vÆ
 
M
 = i‡(
pùñöedMul
Ë
Y
 
N


190 
vÆ
 
D
 = i‡(
pùñöedMul
Ë
N
 
Y


191 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

192 
MULW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_MUL
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

194 
DIVW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_DIV
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

195 
DIVUW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_DIVU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

196 
REMW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_REM
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

197 
REMUW
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_REMU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N))

200 ˛as†
	cADecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


202 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

203 
AMOADD_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_ADD
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

204 
AMOXOR_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_XOR
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

205 
AMOSWAP_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_SWAP
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

206 
AMOAND_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_AND
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

207 
AMOOR_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_OR
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

208 
AMOMIN_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MIN
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

209 
AMOMINU_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MINU
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

210 
AMOMAX_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAX
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

211 
AMOMAXU_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAXU
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

213 
LR_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XLR
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

214 
SC_W
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XSC
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N))

217 ˛as†
	cA64Decode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


219 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

220 
AMOADD_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_ADD
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

221 
AMOSWAP_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_SWAP
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

222 
AMOXOR_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_XOR
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

223 
AMOAND_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_AND
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

224 
AMOOR_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_OR
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

225 
AMOMIN_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MIN
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

226 
AMOMINU_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MINU
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

227 
AMOMAX_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAX
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

228 
AMOMAXU_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAXU
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

230 
LR_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XLR
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

231 
SC_D
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XSC
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N))

234 ˛as†
	cFDecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


236 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

237 
FSGNJ_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

238 
FSGNJX_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

239 
FSGNJN_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

240 
FMIN_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

241 
FMAX_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

242 
FADD_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

243 
FSUB_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

244 
FMUL_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

245 
FMADD_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

246 
FMSUB_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

247 
FNMADD_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

248 
FNMSUB_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

249 
FCLASS_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

250 
FMV_X_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

251 
FCVT_W_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

252 
FCVT_WU_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

253 
FEQ_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,N),

254 
FLT_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,N),

255 
FLE_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,N),

256 
FMV_S_X
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

257 
FCVT_S_W
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

258 
FCVT_S_WU
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

259 
FLW
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_W
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

260 
FSW
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_W
, N,Y,N,N,N,N,N,
CSR
.N,N,N,N,N),

261 
FDIV_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

262 
FSQRT_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N))

265 ˛as†
	cDDecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


267 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

268 
FCVT_S_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

269 
FCVT_D_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

270 
FSGNJ_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

271 
FSGNJX_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

272 
FSGNJN_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

273 
FMIN_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

274 
FMAX_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

275 
FADD_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

276 
FSUB_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

277 
FMUL_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

278 
FMADD_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

279 
FMSUB_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

280 
FNMADD_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

281 
FNMSUB_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

282 
FCLASS_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

283 
FCVT_W_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

284 
FCVT_WU_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

285 
FEQ_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

286 
FLT_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

287 
FLE_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

288 
FCVT_D_W
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

289 
FCVT_D_WU
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

290 
FLD
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_D
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

291 
FSD
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_D
, N,Y,N,N,N,N,N,
CSR
.N,N,N,N,Y),

292 
FDIV_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

293 
FSQRT_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y))

296 ˛as†
	cF64Decode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


298 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

299 
FCVT_L_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

300 
FCVT_LU_S
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

301 
FCVT_S_L
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

302 
FCVT_S_LU
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N))

305 ˛as†
	cD64Decode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


307 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

308 
FMV_X_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

309 
FCVT_L_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

310 
FCVT_LU_D
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

311 
FMV_D_X
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

312 
FCVT_D_L
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

313 
FCVT_D_LU
-> 
	`Li°
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y))

316 ˛as†
	cSCIEDecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


318 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

319 
SCIE
.
›code
-> 
	`Li°
(
Y
,
N
,N,N,N,N,Y,Y,Y,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

322 ˛as†
	cRoCCDecode
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
DecodeC⁄°™ts


324 
vÆ
 
èbÀ
: 
Aºay
[(
BôP©
, 
Li°
[BôP©])] = 
	`Aºay
(

325 
CUSTOM0
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

326 
CUSTOM0_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

327 
CUSTOM0_RS1_RS2
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

328 
CUSTOM0_RD
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

329 
CUSTOM0_RD_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

330 
CUSTOM0_RD_RS1_RS2
->
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

331 
CUSTOM1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

332 
CUSTOM1_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

333 
CUSTOM1_RS1_RS2
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

334 
CUSTOM1_RD
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

335 
CUSTOM1_RD_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

336 
CUSTOM1_RD_RS1_RS2
->
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

337 
CUSTOM2
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

338 
CUSTOM2_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

339 
CUSTOM2_RS1_RS2
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

340 
CUSTOM2_RD
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

341 
CUSTOM2_RD_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

342 
CUSTOM2_RD_RS1_RS2
->
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

343 
CUSTOM3
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

344 
CUSTOM3_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

345 
CUSTOM3_RS1_RS2
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

346 
CUSTOM3_RD
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

347 
CUSTOM3_RD_RS1
-> 
	`Li°
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

348 
CUSTOM3_RD_RS1_RS2
->
	`Li°
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Instructions.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


9 
obje˘
 
	gIn°ru˘i⁄s
 {

10 
def
 
	gBEQ
 = 
BôP©
("b?????????????????000?????1100011")

11 
def
 
BNE
 = 
BôP©
("b?????????????????001?????1100011")

12 
def
 
BLT
 = 
BôP©
("b?????????????????100?????1100011")

13 
def
 
BGE
 = 
BôP©
("b?????????????????101?????1100011")

14 
def
 
BLTU
 = 
BôP©
("b?????????????????110?????1100011")

15 
def
 
BGEU
 = 
BôP©
("b?????????????????111?????1100011")

16 
def
 
JALR
 = 
BôP©
("b?????????????????000?????1100111")

17 
def
 
JAL
 = 
BôP©
("b?????????????????????????1101111")

18 
def
 
LUI
 = 
BôP©
("b?????????????????????????0110111")

19 
def
 
AUIPC
 = 
BôP©
("b?????????????????????????0010111")

20 
def
 
ADDI
 = 
BôP©
("b?????????????????000?????0010011")

21 
def
 
SLLI
 = 
BôP©
("b000000???????????001?????0010011")

22 
def
 
SLTI
 = 
BôP©
("b?????????????????010?????0010011")

23 
def
 
SLTIU
 = 
BôP©
("b?????????????????011?????0010011")

24 
def
 
XORI
 = 
BôP©
("b?????????????????100?????0010011")

25 
def
 
SRLI
 = 
BôP©
("b000000???????????101?????0010011")

26 
def
 
SRAI
 = 
BôP©
("b010000???????????101?????0010011")

27 
def
 
ORI
 = 
BôP©
("b?????????????????110?????0010011")

28 
def
 
ANDI
 = 
BôP©
("b?????????????????111?????0010011")

29 
def
 
ADD
 = 
BôP©
("b0000000??????????000?????0110011")

30 
def
 
SUB
 = 
BôP©
("b0100000??????????000?????0110011")

31 
def
 
SLL
 = 
BôP©
("b0000000??????????001?????0110011")

32 
def
 
SLT
 = 
BôP©
("b0000000??????????010?????0110011")

33 
def
 
SLTU
 = 
BôP©
("b0000000??????????011?????0110011")

34 
def
 
XOR
 = 
BôP©
("b0000000??????????100?????0110011")

35 
def
 
SRL
 = 
BôP©
("b0000000??????????101?????0110011")

36 
def
 
SRA
 = 
BôP©
("b0100000??????????101?????0110011")

37 
def
 
OR
 = 
BôP©
("b0000000??????????110?????0110011")

38 
def
 
AND
 = 
BôP©
("b0000000??????????111?????0110011")

39 
def
 
ADDIW
 = 
BôP©
("b?????????????????000?????0011011")

40 
def
 
SLLIW
 = 
BôP©
("b0000000??????????001?????0011011")

41 
def
 
SRLIW
 = 
BôP©
("b0000000??????????101?????0011011")

42 
def
 
SRAIW
 = 
BôP©
("b0100000??????????101?????0011011")

43 
def
 
ADDW
 = 
BôP©
("b0000000??????????000?????0111011")

44 
def
 
SUBW
 = 
BôP©
("b0100000??????????000?????0111011")

45 
def
 
SLLW
 = 
BôP©
("b0000000??????????001?????0111011")

46 
def
 
SRLW
 = 
BôP©
("b0000000??????????101?????0111011")

47 
def
 
SRAW
 = 
BôP©
("b0100000??????????101?????0111011")

48 
def
 
LB
 = 
BôP©
("b?????????????????000?????0000011")

49 
def
 
LH
 = 
BôP©
("b?????????????????001?????0000011")

50 
def
 
LW
 = 
BôP©
("b?????????????????010?????0000011")

51 
def
 
LD
 = 
BôP©
("b?????????????????011?????0000011")

52 
def
 
LBU
 = 
BôP©
("b?????????????????100?????0000011")

53 
def
 
LHU
 = 
BôP©
("b?????????????????101?????0000011")

54 
def
 
LWU
 = 
BôP©
("b?????????????????110?????0000011")

55 
def
 
SB
 = 
BôP©
("b?????????????????000?????0100011")

56 
def
 
SH
 = 
BôP©
("b?????????????????001?????0100011")

57 
def
 
SW
 = 
BôP©
("b?????????????????010?????0100011")

58 
def
 
SD
 = 
BôP©
("b?????????????????011?????0100011")

59 
def
 
FENCE
 = 
BôP©
("b?????????????????000?????0001111")

60 
def
 
FENCE_I
 = 
BôP©
("b?????????????????001?????0001111")

61 
def
 
MUL
 = 
BôP©
("b0000001??????????000?????0110011")

62 
def
 
MULH
 = 
BôP©
("b0000001??????????001?????0110011")

63 
def
 
MULHSU
 = 
BôP©
("b0000001??????????010?????0110011")

64 
def
 
MULHU
 = 
BôP©
("b0000001??????????011?????0110011")

65 
def
 
DIV
 = 
BôP©
("b0000001??????????100?????0110011")

66 
def
 
DIVU
 = 
BôP©
("b0000001??????????101?????0110011")

67 
def
 
REM
 = 
BôP©
("b0000001??????????110?????0110011")

68 
def
 
REMU
 = 
BôP©
("b0000001??????????111?????0110011")

69 
def
 
MULW
 = 
BôP©
("b0000001??????????000?????0111011")

70 
def
 
DIVW
 = 
BôP©
("b0000001??????????100?????0111011")

71 
def
 
DIVUW
 = 
BôP©
("b0000001??????????101?????0111011")

72 
def
 
REMW
 = 
BôP©
("b0000001??????????110?????0111011")

73 
def
 
REMUW
 = 
BôP©
("b0000001??????????111?????0111011")

74 
def
 
AMOADD_W
 = 
BôP©
("b00000????????????010?????0101111")

75 
def
 
AMOXOR_W
 = 
BôP©
("b00100????????????010?????0101111")

76 
def
 
AMOOR_W
 = 
BôP©
("b01000????????????010?????0101111")

77 
def
 
AMOAND_W
 = 
BôP©
("b01100????????????010?????0101111")

78 
def
 
AMOMIN_W
 = 
BôP©
("b10000????????????010?????0101111")

79 
def
 
AMOMAX_W
 = 
BôP©
("b10100????????????010?????0101111")

80 
def
 
AMOMINU_W
 = 
BôP©
("b11000????????????010?????0101111")

81 
def
 
AMOMAXU_W
 = 
BôP©
("b11100????????????010?????0101111")

82 
def
 
AMOSWAP_W
 = 
BôP©
("b00001????????????010?????0101111")

83 
def
 
LR_W
 = 
BôP©
("b00010??00000?????010?????0101111")

84 
def
 
SC_W
 = 
BôP©
("b00011????????????010?????0101111")

85 
def
 
AMOADD_D
 = 
BôP©
("b00000????????????011?????0101111")

86 
def
 
AMOXOR_D
 = 
BôP©
("b00100????????????011?????0101111")

87 
def
 
AMOOR_D
 = 
BôP©
("b01000????????????011?????0101111")

88 
def
 
AMOAND_D
 = 
BôP©
("b01100????????????011?????0101111")

89 
def
 
AMOMIN_D
 = 
BôP©
("b10000????????????011?????0101111")

90 
def
 
AMOMAX_D
 = 
BôP©
("b10100????????????011?????0101111")

91 
def
 
AMOMINU_D
 = 
BôP©
("b11000????????????011?????0101111")

92 
def
 
AMOMAXU_D
 = 
BôP©
("b11100????????????011?????0101111")

93 
def
 
AMOSWAP_D
 = 
BôP©
("b00001????????????011?????0101111")

94 
def
 
LR_D
 = 
BôP©
("b00010??00000?????011?????0101111")

95 
def
 
SC_D
 = 
BôP©
("b00011????????????011?????0101111")

96 
def
 
ECALL
 = 
BôP©
("b00000000000000000000000001110011")

97 
def
 
EBREAK
 = 
BôP©
("b00000000000100000000000001110011")

98 
def
 
URET
 = 
BôP©
("b00000000001000000000000001110011")

99 
def
 
SRET
 = 
BôP©
("b00010000001000000000000001110011")

100 
def
 
MRET
 = 
BôP©
("b00110000001000000000000001110011")

101 
def
 
DRET
 = 
BôP©
("b01111011001000000000000001110011")

102 
def
 
SFENCE_VMA
 = 
BôP©
("b0001001??????????000000001110011")

103 
def
 
WFI
 = 
BôP©
("b00010000010100000000000001110011")

104 
def
 
CSRRW
 = 
BôP©
("b?????????????????001?????1110011")

105 
def
 
CSRRS
 = 
BôP©
("b?????????????????010?????1110011")

106 
def
 
CSRRC
 = 
BôP©
("b?????????????????011?????1110011")

107 
def
 
CSRRWI
 = 
BôP©
("b?????????????????101?????1110011")

108 
def
 
CSRRSI
 = 
BôP©
("b?????????????????110?????1110011")

109 
def
 
CSRRCI
 = 
BôP©
("b?????????????????111?????1110011")

110 
def
 
FADD_S
 = 
BôP©
("b0000000??????????????????1010011")

111 
def
 
FSUB_S
 = 
BôP©
("b0000100??????????????????1010011")

112 
def
 
FMUL_S
 = 
BôP©
("b0001000??????????????????1010011")

113 
def
 
FDIV_S
 = 
BôP©
("b0001100??????????????????1010011")

114 
def
 
FSGNJ_S
 = 
BôP©
("b0010000??????????000?????1010011")

115 
def
 
FSGNJN_S
 = 
BôP©
("b0010000??????????001?????1010011")

116 
def
 
FSGNJX_S
 = 
BôP©
("b0010000??????????010?????1010011")

117 
def
 
FMIN_S
 = 
BôP©
("b0010100??????????000?????1010011")

118 
def
 
FMAX_S
 = 
BôP©
("b0010100??????????001?????1010011")

119 
def
 
FSQRT_S
 = 
BôP©
("b010110000000?????????????1010011")

120 
def
 
FADD_D
 = 
BôP©
("b0000001??????????????????1010011")

121 
def
 
FSUB_D
 = 
BôP©
("b0000101??????????????????1010011")

122 
def
 
FMUL_D
 = 
BôP©
("b0001001??????????????????1010011")

123 
def
 
FDIV_D
 = 
BôP©
("b0001101??????????????????1010011")

124 
def
 
FSGNJ_D
 = 
BôP©
("b0010001??????????000?????1010011")

125 
def
 
FSGNJN_D
 = 
BôP©
("b0010001??????????001?????1010011")

126 
def
 
FSGNJX_D
 = 
BôP©
("b0010001??????????010?????1010011")

127 
def
 
FMIN_D
 = 
BôP©
("b0010101??????????000?????1010011")

128 
def
 
FMAX_D
 = 
BôP©
("b0010101??????????001?????1010011")

129 
def
 
FCVT_S_D
 = 
BôP©
("b010000000001?????????????1010011")

130 
def
 
FCVT_D_S
 = 
BôP©
("b010000100000?????????????1010011")

131 
def
 
FSQRT_D
 = 
BôP©
("b010110100000?????????????1010011")

132 
def
 
FADD_Q
 = 
BôP©
("b0000011??????????????????1010011")

133 
def
 
FSUB_Q
 = 
BôP©
("b0000111??????????????????1010011")

134 
def
 
FMUL_Q
 = 
BôP©
("b0001011??????????????????1010011")

135 
def
 
FDIV_Q
 = 
BôP©
("b0001111??????????????????1010011")

136 
def
 
FSGNJ_Q
 = 
BôP©
("b0010011??????????000?????1010011")

137 
def
 
FSGNJN_Q
 = 
BôP©
("b0010011??????????001?????1010011")

138 
def
 
FSGNJX_Q
 = 
BôP©
("b0010011??????????010?????1010011")

139 
def
 
FMIN_Q
 = 
BôP©
("b0010111??????????000?????1010011")

140 
def
 
FMAX_Q
 = 
BôP©
("b0010111??????????001?????1010011")

141 
def
 
FCVT_S_Q
 = 
BôP©
("b010000000011?????????????1010011")

142 
def
 
FCVT_Q_S
 = 
BôP©
("b010001100000?????????????1010011")

143 
def
 
FCVT_D_Q
 = 
BôP©
("b010000100011?????????????1010011")

144 
def
 
FCVT_Q_D
 = 
BôP©
("b010001100001?????????????1010011")

145 
def
 
FSQRT_Q
 = 
BôP©
("b010111100000?????????????1010011")

146 
def
 
FLE_S
 = 
BôP©
("b1010000??????????000?????1010011")

147 
def
 
FLT_S
 = 
BôP©
("b1010000??????????001?????1010011")

148 
def
 
FEQ_S
 = 
BôP©
("b1010000??????????010?????1010011")

149 
def
 
FLE_D
 = 
BôP©
("b1010001??????????000?????1010011")

150 
def
 
FLT_D
 = 
BôP©
("b1010001??????????001?????1010011")

151 
def
 
FEQ_D
 = 
BôP©
("b1010001??????????010?????1010011")

152 
def
 
FLE_Q
 = 
BôP©
("b1010011??????????000?????1010011")

153 
def
 
FLT_Q
 = 
BôP©
("b1010011??????????001?????1010011")

154 
def
 
FEQ_Q
 = 
BôP©
("b1010011??????????010?????1010011")

155 
def
 
FCVT_W_S
 = 
BôP©
("b110000000000?????????????1010011")

156 
def
 
FCVT_WU_S
 = 
BôP©
("b110000000001?????????????1010011")

157 
def
 
FCVT_L_S
 = 
BôP©
("b110000000010?????????????1010011")

158 
def
 
FCVT_LU_S
 = 
BôP©
("b110000000011?????????????1010011")

159 
def
 
FMV_X_W
 = 
BôP©
("b111000000000?????000?????1010011")

160 
def
 
FCLASS_S
 = 
BôP©
("b111000000000?????001?????1010011")

161 
def
 
FCVT_W_D
 = 
BôP©
("b110000100000?????????????1010011")

162 
def
 
FCVT_WU_D
 = 
BôP©
("b110000100001?????????????1010011")

163 
def
 
FCVT_L_D
 = 
BôP©
("b110000100010?????????????1010011")

164 
def
 
FCVT_LU_D
 = 
BôP©
("b110000100011?????????????1010011")

165 
def
 
FMV_X_D
 = 
BôP©
("b111000100000?????000?????1010011")

166 
def
 
FCLASS_D
 = 
BôP©
("b111000100000?????001?????1010011")

167 
def
 
FCVT_W_Q
 = 
BôP©
("b110001100000?????????????1010011")

168 
def
 
FCVT_WU_Q
 = 
BôP©
("b110001100001?????????????1010011")

169 
def
 
FCVT_L_Q
 = 
BôP©
("b110001100010?????????????1010011")

170 
def
 
FCVT_LU_Q
 = 
BôP©
("b110001100011?????????????1010011")

171 
def
 
FMV_X_Q
 = 
BôP©
("b111001100000?????000?????1010011")

172 
def
 
FCLASS_Q
 = 
BôP©
("b111001100000?????001?????1010011")

173 
def
 
FCVT_S_W
 = 
BôP©
("b110100000000?????????????1010011")

174 
def
 
FCVT_S_WU
 = 
BôP©
("b110100000001?????????????1010011")

175 
def
 
FCVT_S_L
 = 
BôP©
("b110100000010?????????????1010011")

176 
def
 
FCVT_S_LU
 = 
BôP©
("b110100000011?????????????1010011")

177 
def
 
FMV_W_X
 = 
BôP©
("b111100000000?????000?????1010011")

178 
def
 
FCVT_D_W
 = 
BôP©
("b110100100000?????????????1010011")

179 
def
 
FCVT_D_WU
 = 
BôP©
("b110100100001?????????????1010011")

180 
def
 
FCVT_D_L
 = 
BôP©
("b110100100010?????????????1010011")

181 
def
 
FCVT_D_LU
 = 
BôP©
("b110100100011?????????????1010011")

182 
def
 
FMV_D_X
 = 
BôP©
("b111100100000?????000?????1010011")

183 
def
 
FCVT_Q_W
 = 
BôP©
("b110101100000?????????????1010011")

184 
def
 
FCVT_Q_WU
 = 
BôP©
("b110101100001?????????????1010011")

185 
def
 
FCVT_Q_L
 = 
BôP©
("b110101100010?????????????1010011")

186 
def
 
FCVT_Q_LU
 = 
BôP©
("b110101100011?????????????1010011")

187 
def
 
FMV_Q_X
 = 
BôP©
("b111101100000?????000?????1010011")

188 
def
 
FLW
 = 
BôP©
("b?????????????????010?????0000111")

189 
def
 
FLD
 = 
BôP©
("b?????????????????011?????0000111")

190 
def
 
FLQ
 = 
BôP©
("b?????????????????100?????0000111")

191 
def
 
FSW
 = 
BôP©
("b?????????????????010?????0100111")

192 
def
 
FSD
 = 
BôP©
("b?????????????????011?????0100111")

193 
def
 
FSQ
 = 
BôP©
("b?????????????????100?????0100111")

194 
def
 
FMADD_S
 = 
BôP©
("b?????00??????????????????1000011")

195 
def
 
FMSUB_S
 = 
BôP©
("b?????00??????????????????1000111")

196 
def
 
FNMSUB_S
 = 
BôP©
("b?????00??????????????????1001011")

197 
def
 
FNMADD_S
 = 
BôP©
("b?????00??????????????????1001111")

198 
def
 
FMADD_D
 = 
BôP©
("b?????01??????????????????1000011")

199 
def
 
FMSUB_D
 = 
BôP©
("b?????01??????????????????1000111")

200 
def
 
FNMSUB_D
 = 
BôP©
("b?????01??????????????????1001011")

201 
def
 
FNMADD_D
 = 
BôP©
("b?????01??????????????????1001111")

202 
def
 
FMADD_Q
 = 
BôP©
("b?????11??????????????????1000011")

203 
def
 
FMSUB_Q
 = 
BôP©
("b?????11??????????????????1000111")

204 
def
 
FNMSUB_Q
 = 
BôP©
("b?????11??????????????????1001011")

205 
def
 
FNMADD_Q
 = 
BôP©
("b?????11??????????????????1001111")

206 
def
 
C_ADDI4SPN
 = 
BôP©
("b????????????????000???????????00")

207 
def
 
C_FLD
 = 
BôP©
("b????????????????001???????????00")

208 
def
 
C_LW
 = 
BôP©
("b????????????????010???????????00")

209 
def
 
C_FLW
 = 
BôP©
("b????????????????011???????????00")

210 
def
 
C_FSD
 = 
BôP©
("b????????????????101???????????00")

211 
def
 
C_SW
 = 
BôP©
("b????????????????110???????????00")

212 
def
 
C_FSW
 = 
BôP©
("b????????????????111???????????00")

213 
def
 
C_ADDI
 = 
BôP©
("b????????????????000???????????01")

214 
def
 
C_JAL
 = 
BôP©
("b????????????????001???????????01")

215 
def
 
C_LI
 = 
BôP©
("b????????????????010???????????01")

216 
def
 
C_LUI
 = 
BôP©
("b????????????????011???????????01")

217 
def
 
C_SRLI
 = 
BôP©
("b????????????????100?00????????01")

218 
def
 
C_SRAI
 = 
BôP©
("b????????????????100?01????????01")

219 
def
 
C_ANDI
 = 
BôP©
("b????????????????100?10????????01")

220 
def
 
C_SUB
 = 
BôP©
("b????????????????100011???00???01")

221 
def
 
C_XOR
 = 
BôP©
("b????????????????100011???01???01")

222 
def
 
C_OR
 = 
BôP©
("b????????????????100011???10???01")

223 
def
 
C_AND
 = 
BôP©
("b????????????????100011???11???01")

224 
def
 
C_SUBW
 = 
BôP©
("b????????????????100111???00???01")

225 
def
 
C_ADDW
 = 
BôP©
("b????????????????100111???01???01")

226 
def
 
C_J
 = 
BôP©
("b????????????????101???????????01")

227 
def
 
C_BEQZ
 = 
BôP©
("b????????????????110???????????01")

228 
def
 
C_BNEZ
 = 
BôP©
("b????????????????111???????????01")

229 
def
 
C_SLLI
 = 
BôP©
("b????????????????000???????????10")

230 
def
 
C_FLDSP
 = 
BôP©
("b????????????????001???????????10")

231 
def
 
C_LWSP
 = 
BôP©
("b????????????????010???????????10")

232 
def
 
C_FLWSP
 = 
BôP©
("b????????????????011???????????10")

233 
def
 
C_MV
 = 
BôP©
("b????????????????1000??????????10")

234 
def
 
C_ADD
 = 
BôP©
("b????????????????1001??????????10")

235 
def
 
C_FSDSP
 = 
BôP©
("b????????????????101???????????10")

236 
def
 
C_SWSP
 = 
BôP©
("b????????????????110???????????10")

237 
def
 
C_FSWSP
 = 
BôP©
("b????????????????111???????????10")

238 
def
 
C_NOP
 = 
BôP©
("b????????????????0000000000000001")

239 
def
 
C_ADDI16SP
 = 
BôP©
("b????????????????011?00010?????01")

240 
def
 
C_JR
 = 
BôP©
("b????????????????1000?????0000010")

241 
def
 
C_JALR
 = 
BôP©
("b????????????????1001?????0000010")

242 
def
 
C_EBREAK
 = 
BôP©
("b????????????????1001000000000010")

243 
def
 
C_LD
 = 
BôP©
("b????????????????011???????????00")

244 
def
 
C_SD
 = 
BôP©
("b????????????????111???????????00")

245 
def
 
C_ADDIW
 = 
BôP©
("b????????????????001???????????01")

246 
def
 
C_LDSP
 = 
BôP©
("b????????????????011???????????10")

247 
def
 
C_SDSP
 = 
BôP©
("b????????????????111???????????10")

248 
def
 
C_SLLI_RV32
 = 
BôP©
("b????????????????0000??????????10")

249 
def
 
C_SRLI_RV32
 = 
BôP©
("b????????????????100000????????01")

250 
def
 
C_SRAI_RV32
 = 
BôP©
("b????????????????100001????????01")

251 
def
 
CUSTOM0
 = 
BôP©
("b?????????????????000?????0001011")

252 
def
 
CUSTOM0_RS1
 = 
BôP©
("b?????????????????010?????0001011")

253 
def
 
CUSTOM0_RS1_RS2
 = 
BôP©
("b?????????????????011?????0001011")

254 
def
 
CUSTOM0_RD
 = 
BôP©
("b?????????????????100?????0001011")

255 
def
 
CUSTOM0_RD_RS1
 = 
BôP©
("b?????????????????110?????0001011")

256 
def
 
CUSTOM0_RD_RS1_RS2
 = 
BôP©
("b?????????????????111?????0001011")

257 
def
 
CUSTOM1
 = 
BôP©
("b?????????????????000?????0101011")

258 
def
 
CUSTOM1_RS1
 = 
BôP©
("b?????????????????010?????0101011")

259 
def
 
CUSTOM1_RS1_RS2
 = 
BôP©
("b?????????????????011?????0101011")

260 
def
 
CUSTOM1_RD
 = 
BôP©
("b?????????????????100?????0101011")

261 
def
 
CUSTOM1_RD_RS1
 = 
BôP©
("b?????????????????110?????0101011")

262 
def
 
CUSTOM1_RD_RS1_RS2
 = 
BôP©
("b?????????????????111?????0101011")

263 
def
 
CUSTOM2
 = 
BôP©
("b?????????????????000?????1011011")

264 
def
 
CUSTOM2_RS1
 = 
BôP©
("b?????????????????010?????1011011")

265 
def
 
CUSTOM2_RS1_RS2
 = 
BôP©
("b?????????????????011?????1011011")

266 
def
 
CUSTOM2_RD
 = 
BôP©
("b?????????????????100?????1011011")

267 
def
 
CUSTOM2_RD_RS1
 = 
BôP©
("b?????????????????110?????1011011")

268 
def
 
CUSTOM2_RD_RS1_RS2
 = 
BôP©
("b?????????????????111?????1011011")

269 
def
 
CUSTOM3
 = 
BôP©
("b?????????????????000?????1111011")

270 
def
 
CUSTOM3_RS1
 = 
BôP©
("b?????????????????010?????1111011")

271 
def
 
CUSTOM3_RS1_RS2
 = 
BôP©
("b?????????????????011?????1111011")

272 
def
 
CUSTOM3_RD
 = 
BôP©
("b?????????????????100?????1111011")

273 
def
 
CUSTOM3_RD_RS1
 = 
BôP©
("b?????????????????110?????1111011")

274 
def
 
CUSTOM3_RD_RS1_RS2
 = 
BôP©
("b?????????????????111?????1111011")

275 
def
 
SLLI_RV32
 = 
BôP©
("b0000000??????????001?????0010011")

276 
def
 
SRLI_RV32
 = 
BôP©
("b0000000??????????101?????0010011")

277 
def
 
SRAI_RV32
 = 
BôP©
("b0100000??????????101?????0010011")

278 
def
 
FRFLAGS
 = 
BôP©
("b00000000000100000010?????1110011")

279 
def
 
FSFLAGS
 = 
BôP©
("b000000000001?????001?????1110011")

280 
def
 
FSFLAGSI
 = 
BôP©
("b000000000001?????101?????1110011")

281 
def
 
FRRM
 = 
BôP©
("b00000000001000000010?????1110011")

282 
def
 
FSRM
 = 
BôP©
("b000000000010?????001?????1110011")

283 
def
 
FSRMI
 = 
BôP©
("b000000000010?????101?????1110011")

284 
def
 
FSCSR
 = 
BôP©
("b000000000011?????001?????1110011")

285 
def
 
FRCSR
 = 
BôP©
("b00000000001100000010?????1110011")

286 
def
 
RDCYCLE
 = 
BôP©
("b11000000000000000010?????1110011")

287 
def
 
RDTIME
 = 
BôP©
("b11000000000100000010?????1110011")

288 
def
 
RDINSTRET
 = 
BôP©
("b11000000001000000010?????1110011")

289 
def
 
RDCYCLEH
 = 
BôP©
("b11001000000000000010?????1110011")

290 
def
 
RDTIMEH
 = 
BôP©
("b11001000000100000010?????1110011")

291 
def
 
RDINSTRETH
 = 
BôP©
("b11001000001000000010?????1110011")

292 
def
 
SCALL
 = 
BôP©
("b00000000000000000000000001110011")

293 
def
 
SBREAK
 = 
BôP©
("b00000000000100000000000001110011")

294 
def
 
FMV_X_S
 = 
BôP©
("b111000000000?????000?????1010011")

295 
def
 
FMV_S_X
 = 
BôP©
("b111100000000?????000?????1010011")

296 
def
 
FENCE_TSO
 = 
BôP©
("b100000110011?????000?????0001111")

298 
obje˘
 
	gCau£s
 {

299 
vÆ
 
	gmißlig√d_„tch
 = 0x0

300 
vÆ
 
„tch_ac˚ss
 = 0x1

301 
vÆ
 
ûÀgÆ_ö°ru˘i⁄
 = 0x2

302 
vÆ
 
bªakpoöt
 = 0x3

303 
vÆ
 
mißlig√d_lﬂd
 = 0x4

304 
vÆ
 
lﬂd_ac˚ss
 = 0x5

305 
vÆ
 
mißlig√d_°‹e
 = 0x6

306 
vÆ
 
°‹e_ac˚ss
 = 0x7

307 
vÆ
 
u£r_eˇŒ
 = 0x8

308 
vÆ
 
su≥rvis‹_eˇŒ
 = 0x9

309 
vÆ
 
hy≥rvis‹_eˇŒ
 = 0xa

310 
vÆ
 
machöe_eˇŒ
 = 0xb

311 
vÆ
 
„tch_∑ge_Áu…
 = 0xc

312 
vÆ
 
lﬂd_∑ge_Áu…
 = 0xd

313 
vÆ
 
°‹e_∑ge_Áu…
 = 0xf

314 
vÆ
 
Æl
 = {

315 
vÆ
 
ªs
 = 
cﬁÀ˘i⁄
.
muèbÀ
.
AºayBuf„r
[
I¡
]()

316 
ªs
 +
mißlig√d_„tch


317 
ªs
 +
„tch_ac˚ss


318 
ªs
 +
ûÀgÆ_ö°ru˘i⁄


319 
ªs
 +
bªakpoöt


320 
ªs
 +
mißlig√d_lﬂd


321 
ªs
 +
lﬂd_ac˚ss


322 
ªs
 +
mißlig√d_°‹e


323 
ªs
 +
°‹e_ac˚ss


324 
ªs
 +
u£r_eˇŒ


325 
ªs
 +
su≥rvis‹_eˇŒ


326 
ªs
 +
hy≥rvis‹_eˇŒ


327 
ªs
 +
machöe_eˇŒ


328 
ªs
 +
„tch_∑ge_Áu…


329 
ªs
 +
lﬂd_∑ge_Áu…


330 
ªs
 +
°‹e_∑ge_Áu…


331 
ªs
.
toAºay


334 
obje˘
 
	gCSRs
 {

335 
vÆ
 
	gfÊags
 = 0x1

336 
vÆ
 
‰m
 = 0x2

337 
vÆ
 
fc§
 = 0x3

338 
vÆ
 
cy˛e
 = 0xc00

339 
vÆ
 
time
 = 0xc01

340 
vÆ
 
ö°ªt
 = 0xc02

341 
vÆ
 
hpmcou¡î3
 = 0xc03

342 
vÆ
 
hpmcou¡î4
 = 0xc04

343 
vÆ
 
hpmcou¡î5
 = 0xc05

344 
vÆ
 
hpmcou¡î6
 = 0xc06

345 
vÆ
 
hpmcou¡î7
 = 0xc07

346 
vÆ
 
hpmcou¡î8
 = 0xc08

347 
vÆ
 
hpmcou¡î9
 = 0xc09

348 
vÆ
 
hpmcou¡î10
 = 0xc0a

349 
vÆ
 
hpmcou¡î11
 = 0xc0b

350 
vÆ
 
hpmcou¡î12
 = 0xc0c

351 
vÆ
 
hpmcou¡î13
 = 0xc0d

352 
vÆ
 
hpmcou¡î14
 = 0xc0e

353 
vÆ
 
hpmcou¡î15
 = 0xc0f

354 
vÆ
 
hpmcou¡î16
 = 0xc10

355 
vÆ
 
hpmcou¡î17
 = 0xc11

356 
vÆ
 
hpmcou¡î18
 = 0xc12

357 
vÆ
 
hpmcou¡î19
 = 0xc13

358 
vÆ
 
hpmcou¡î20
 = 0xc14

359 
vÆ
 
hpmcou¡î21
 = 0xc15

360 
vÆ
 
hpmcou¡î22
 = 0xc16

361 
vÆ
 
hpmcou¡î23
 = 0xc17

362 
vÆ
 
hpmcou¡î24
 = 0xc18

363 
vÆ
 
hpmcou¡î25
 = 0xc19

364 
vÆ
 
hpmcou¡î26
 = 0xc1a

365 
vÆ
 
hpmcou¡î27
 = 0xc1b

366 
vÆ
 
hpmcou¡î28
 = 0xc1c

367 
vÆ
 
hpmcou¡î29
 = 0xc1d

368 
vÆ
 
hpmcou¡î30
 = 0xc1e

369 
vÆ
 
hpmcou¡î31
 = 0xc1f

370 
vÆ
 
s°©us
 = 0x100

371 
vÆ
 
sõ
 = 0x104

372 
vÆ
 
°vec
 = 0x105

373 
vÆ
 
scou¡îí
 = 0x106

374 
vÆ
 
ss¸©ch
 = 0x140

375 
vÆ
 
£pc
 = 0x141

376 
vÆ
 
sˇu£
 = 0x142

377 
vÆ
 
sbadaddr
 = 0x143

378 
vÆ
 
sù
 = 0x144

379 
vÆ
 
•tbr
 = 0x180

380 
vÆ
 
•codî™ge0
 = 0x190

381 
vÆ
 
•codî™ge1
 = 0x191

382 
vÆ
 
•codî™ge2
 = 0x192

383 
vÆ
 
•codî™ge3
 = 0x193

387 
vÆ
 
m°©us
 = 0x300

388 
vÆ
 
miß
 = 0x301

389 
vÆ
 
medñeg
 = 0x302

390 
vÆ
 
midñeg
 = 0x303

391 
vÆ
 
mõ
 = 0x304

392 
vÆ
 
mtvec
 = 0x305

393 
vÆ
 
mcou¡îí
 = 0x306

394 
vÆ
 
ms¸©ch
 = 0x340

395 
vÆ
 
mïc
 = 0x341

396 
vÆ
 
mˇu£
 = 0x342

397 
vÆ
 
mbadaddr
 = 0x343

398 
vÆ
 
mù
 = 0x344

399 
vÆ
 
pmpcfg0
 = 0x3a0

400 
vÆ
 
pmpcfg1
 = 0x3a1

401 
vÆ
 
pmpcfg2
 = 0x3a2

402 
vÆ
 
pmpcfg3
 = 0x3a3

403 
vÆ
 
pm∑ddr0
 = 0x3b0

404 
vÆ
 
pm∑ddr1
 = 0x3b1

405 
vÆ
 
pm∑ddr2
 = 0x3b2

406 
vÆ
 
pm∑ddr3
 = 0x3b3

407 
vÆ
 
pm∑ddr4
 = 0x3b4

408 
vÆ
 
pm∑ddr5
 = 0x3b5

409 
vÆ
 
pm∑ddr6
 = 0x3b6

410 
vÆ
 
pm∑ddr7
 = 0x3b7

411 
vÆ
 
pm∑ddr8
 = 0x3b8

412 
vÆ
 
pm∑ddr9
 = 0x3b9

413 
vÆ
 
pm∑ddr10
 = 0x3ba

414 
vÆ
 
pm∑ddr11
 = 0x3bb

415 
vÆ
 
pm∑ddr12
 = 0x3bc

416 
vÆ
 
pm∑ddr13
 = 0x3bd

417 
vÆ
 
pm∑ddr14
 = 0x3be

418 
vÆ
 
pm∑ddr15
 = 0x3bf

419 
vÆ
 
t£À˘
 = 0x7a0

420 
vÆ
 
td©a1
 = 0x7a1

421 
vÆ
 
td©a2
 = 0x7a2

422 
vÆ
 
td©a3
 = 0x7a3

423 
vÆ
 
dc§
 = 0x7b0

424 
vÆ
 
dpc
 = 0x7b1

425 
vÆ
 
ds¸©ch
 = 0x7b2

426 
vÆ
 
mcy˛e
 = 0xb00

427 
vÆ
 
mö°ªt
 = 0xb02

428 
vÆ
 
mhpmcou¡î3
 = 0xb03

429 
vÆ
 
mhpmcou¡î4
 = 0xb04

430 
vÆ
 
mhpmcou¡î5
 = 0xb05

431 
vÆ
 
mhpmcou¡î6
 = 0xb06

432 
vÆ
 
mhpmcou¡î7
 = 0xb07

433 
vÆ
 
mhpmcou¡î8
 = 0xb08

434 
vÆ
 
mhpmcou¡î9
 = 0xb09

435 
vÆ
 
mhpmcou¡î10
 = 0xb0a

436 
vÆ
 
mhpmcou¡î11
 = 0xb0b

437 
vÆ
 
mhpmcou¡î12
 = 0xb0c

438 
vÆ
 
mhpmcou¡î13
 = 0xb0d

439 
vÆ
 
mhpmcou¡î14
 = 0xb0e

440 
vÆ
 
mhpmcou¡î15
 = 0xb0f

441 
vÆ
 
mhpmcou¡î16
 = 0xb10

442 
vÆ
 
mhpmcou¡î17
 = 0xb11

443 
vÆ
 
mhpmcou¡î18
 = 0xb12

444 
vÆ
 
mhpmcou¡î19
 = 0xb13

445 
vÆ
 
mhpmcou¡î20
 = 0xb14

446 
vÆ
 
mhpmcou¡î21
 = 0xb15

447 
vÆ
 
mhpmcou¡î22
 = 0xb16

448 
vÆ
 
mhpmcou¡î23
 = 0xb17

449 
vÆ
 
mhpmcou¡î24
 = 0xb18

450 
vÆ
 
mhpmcou¡î25
 = 0xb19

451 
vÆ
 
mhpmcou¡î26
 = 0xb1a

452 
vÆ
 
mhpmcou¡î27
 = 0xb1b

453 
vÆ
 
mhpmcou¡î28
 = 0xb1c

454 
vÆ
 
mhpmcou¡î29
 = 0xb1d

455 
vÆ
 
mhpmcou¡î30
 = 0xb1e

456 
vÆ
 
mhpmcou¡î31
 = 0xb1f

457 
vÆ
 
mhpmevít3
 = 0x323

458 
vÆ
 
mhpmevít4
 = 0x324

459 
vÆ
 
mhpmevít5
 = 0x325

460 
vÆ
 
mhpmevít6
 = 0x326

461 
vÆ
 
mhpmevít7
 = 0x327

462 
vÆ
 
mhpmevít8
 = 0x328

463 
vÆ
 
mhpmevít9
 = 0x329

464 
vÆ
 
mhpmevít10
 = 0x32a

465 
vÆ
 
mhpmevít11
 = 0x32b

466 
vÆ
 
mhpmevít12
 = 0x32c

467 
vÆ
 
mhpmevít13
 = 0x32d

468 
vÆ
 
mhpmevít14
 = 0x32e

469 
vÆ
 
mhpmevít15
 = 0x32f

470 
vÆ
 
mhpmevít16
 = 0x330

471 
vÆ
 
mhpmevít17
 = 0x331

472 
vÆ
 
mhpmevít18
 = 0x332

473 
vÆ
 
mhpmevít19
 = 0x333

474 
vÆ
 
mhpmevít20
 = 0x334

475 
vÆ
 
mhpmevít21
 = 0x335

476 
vÆ
 
mhpmevít22
 = 0x336

477 
vÆ
 
mhpmevít23
 = 0x337

478 
vÆ
 
mhpmevít24
 = 0x338

479 
vÆ
 
mhpmevít25
 = 0x339

480 
vÆ
 
mhpmevít26
 = 0x33a

481 
vÆ
 
mhpmevít27
 = 0x33b

482 
vÆ
 
mhpmevít28
 = 0x33c

483 
vÆ
 
mhpmevít29
 = 0x33d

484 
vÆ
 
mhpmevít30
 = 0x33e

485 
vÆ
 
mhpmevít31
 = 0x33f

486 
vÆ
 
mvíd‹id
 = 0xf11

487 
vÆ
 
m¨chid
 = 0xf12

488 
vÆ
 
mimpid
 = 0xf13

489 
vÆ
 
mh¨tid
 = 0xf14

490 
vÆ
 
cy˛eh
 = 0xc80

491 
vÆ
 
timeh
 = 0xc81

492 
vÆ
 
ö°ªth
 = 0xc82

493 
vÆ
 
hpmcou¡î3h
 = 0xc83

494 
vÆ
 
hpmcou¡î4h
 = 0xc84

495 
vÆ
 
hpmcou¡î5h
 = 0xc85

496 
vÆ
 
hpmcou¡î6h
 = 0xc86

497 
vÆ
 
hpmcou¡î7h
 = 0xc87

498 
vÆ
 
hpmcou¡î8h
 = 0xc88

499 
vÆ
 
hpmcou¡î9h
 = 0xc89

500 
vÆ
 
hpmcou¡î10h
 = 0xc8a

501 
vÆ
 
hpmcou¡î11h
 = 0xc8b

502 
vÆ
 
hpmcou¡î12h
 = 0xc8c

503 
vÆ
 
hpmcou¡î13h
 = 0xc8d

504 
vÆ
 
hpmcou¡î14h
 = 0xc8e

505 
vÆ
 
hpmcou¡î15h
 = 0xc8f

506 
vÆ
 
hpmcou¡î16h
 = 0xc90

507 
vÆ
 
hpmcou¡î17h
 = 0xc91

508 
vÆ
 
hpmcou¡î18h
 = 0xc92

509 
vÆ
 
hpmcou¡î19h
 = 0xc93

510 
vÆ
 
hpmcou¡î20h
 = 0xc94

511 
vÆ
 
hpmcou¡î21h
 = 0xc95

512 
vÆ
 
hpmcou¡î22h
 = 0xc96

513 
vÆ
 
hpmcou¡î23h
 = 0xc97

514 
vÆ
 
hpmcou¡î24h
 = 0xc98

515 
vÆ
 
hpmcou¡î25h
 = 0xc99

516 
vÆ
 
hpmcou¡î26h
 = 0xc9a

517 
vÆ
 
hpmcou¡î27h
 = 0xc9b

518 
vÆ
 
hpmcou¡î28h
 = 0xc9c

519 
vÆ
 
hpmcou¡î29h
 = 0xc9d

520 
vÆ
 
hpmcou¡î30h
 = 0xc9e

521 
vÆ
 
hpmcou¡î31h
 = 0xc9f

522 
vÆ
 
mcy˛eh
 = 0xb80

523 
vÆ
 
mö°ªth
 = 0xb82

524 
vÆ
 
mhpmcou¡î3h
 = 0xb83

525 
vÆ
 
mhpmcou¡î4h
 = 0xb84

526 
vÆ
 
mhpmcou¡î5h
 = 0xb85

527 
vÆ
 
mhpmcou¡î6h
 = 0xb86

528 
vÆ
 
mhpmcou¡î7h
 = 0xb87

529 
vÆ
 
mhpmcou¡î8h
 = 0xb88

530 
vÆ
 
mhpmcou¡î9h
 = 0xb89

531 
vÆ
 
mhpmcou¡î10h
 = 0xb8a

532 
vÆ
 
mhpmcou¡î11h
 = 0xb8b

533 
vÆ
 
mhpmcou¡î12h
 = 0xb8c

534 
vÆ
 
mhpmcou¡î13h
 = 0xb8d

535 
vÆ
 
mhpmcou¡î14h
 = 0xb8e

536 
vÆ
 
mhpmcou¡î15h
 = 0xb8f

537 
vÆ
 
mhpmcou¡î16h
 = 0xb90

538 
vÆ
 
mhpmcou¡î17h
 = 0xb91

539 
vÆ
 
mhpmcou¡î18h
 = 0xb92

540 
vÆ
 
mhpmcou¡î19h
 = 0xb93

541 
vÆ
 
mhpmcou¡î20h
 = 0xb94

542 
vÆ
 
mhpmcou¡î21h
 = 0xb95

543 
vÆ
 
mhpmcou¡î22h
 = 0xb96

544 
vÆ
 
mhpmcou¡î23h
 = 0xb97

545 
vÆ
 
mhpmcou¡î24h
 = 0xb98

546 
vÆ
 
mhpmcou¡î25h
 = 0xb99

547 
vÆ
 
mhpmcou¡î26h
 = 0xb9a

548 
vÆ
 
mhpmcou¡î27h
 = 0xb9b

549 
vÆ
 
mhpmcou¡î28h
 = 0xb9c

550 
vÆ
 
mhpmcou¡î29h
 = 0xb9d

551 
vÆ
 
mhpmcou¡î30h
 = 0xb9e

552 
vÆ
 
mhpmcou¡î31h
 = 0xb9f

553 
vÆ
 
Æl
 = {

554 
vÆ
 
ªs
 = 
cﬁÀ˘i⁄
.
muèbÀ
.
AºayBuf„r
[
I¡
]()

555 
ªs
 +
fÊags


556 
ªs
 +
‰m


557 
ªs
 +
fc§


558 
ªs
 +
cy˛e


559 
ªs
 +
time


560 
ªs
 +
ö°ªt


561 
ªs
 +
hpmcou¡î3


562 
ªs
 +
hpmcou¡î4


563 
ªs
 +
hpmcou¡î5


564 
ªs
 +
hpmcou¡î6


565 
ªs
 +
hpmcou¡î7


566 
ªs
 +
hpmcou¡î8


567 
ªs
 +
hpmcou¡î9


568 
ªs
 +
hpmcou¡î10


569 
ªs
 +
hpmcou¡î11


570 
ªs
 +
hpmcou¡î12


571 
ªs
 +
hpmcou¡î13


572 
ªs
 +
hpmcou¡î14


573 
ªs
 +
hpmcou¡î15


574 
ªs
 +
hpmcou¡î16


575 
ªs
 +
hpmcou¡î17


576 
ªs
 +
hpmcou¡î18


577 
ªs
 +
hpmcou¡î19


578 
ªs
 +
hpmcou¡î20


579 
ªs
 +
hpmcou¡î21


580 
ªs
 +
hpmcou¡î22


581 
ªs
 +
hpmcou¡î23


582 
ªs
 +
hpmcou¡î24


583 
ªs
 +
hpmcou¡î25


584 
ªs
 +
hpmcou¡î26


585 
ªs
 +
hpmcou¡î27


586 
ªs
 +
hpmcou¡î28


587 
ªs
 +
hpmcou¡î29


588 
ªs
 +
hpmcou¡î30


589 
ªs
 +
hpmcou¡î31


590 
ªs
 +
s°©us


591 
ªs
 +
sõ


592 
ªs
 +
°vec


593 
ªs
 +
scou¡îí


594 
ªs
 +
ss¸©ch


595 
ªs
 +
£pc


596 
ªs
 +
sˇu£


597 
ªs
 +
sbadaddr


598 
ªs
 +
sù


599 
ªs
 +
•tbr


600 
ªs
 +
•codî™ge0


601 
ªs
 +
•codî™ge1


602 
ªs
 +
•codî™ge2


603 
ªs
 +
•codî™ge3


604 
ªs
 +
m°©us


605 
ªs
 +
miß


606 
ªs
 +
medñeg


607 
ªs
 +
midñeg


608 
ªs
 +
mõ


609 
ªs
 +
mtvec


610 
ªs
 +
mcou¡îí


611 
ªs
 +
ms¸©ch


612 
ªs
 +
mïc


613 
ªs
 +
mˇu£


614 
ªs
 +
mbadaddr


615 
ªs
 +
mù


616 
ªs
 +
pmpcfg0


617 
ªs
 +
pmpcfg1


618 
ªs
 +
pmpcfg2


619 
ªs
 +
pmpcfg3


620 
ªs
 +
pm∑ddr0


621 
ªs
 +
pm∑ddr1


622 
ªs
 +
pm∑ddr2


623 
ªs
 +
pm∑ddr3


624 
ªs
 +
pm∑ddr4


625 
ªs
 +
pm∑ddr5


626 
ªs
 +
pm∑ddr6


627 
ªs
 +
pm∑ddr7


628 
ªs
 +
pm∑ddr8


629 
ªs
 +
pm∑ddr9


630 
ªs
 +
pm∑ddr10


631 
ªs
 +
pm∑ddr11


632 
ªs
 +
pm∑ddr12


633 
ªs
 +
pm∑ddr13


634 
ªs
 +
pm∑ddr14


635 
ªs
 +
pm∑ddr15


636 
ªs
 +
t£À˘


637 
ªs
 +
td©a1


638 
ªs
 +
td©a2


639 
ªs
 +
td©a3


640 
ªs
 +
dc§


641 
ªs
 +
dpc


642 
ªs
 +
ds¸©ch


643 
ªs
 +
mcy˛e


644 
ªs
 +
mö°ªt


645 
ªs
 +
mhpmcou¡î3


646 
ªs
 +
mhpmcou¡î4


647 
ªs
 +
mhpmcou¡î5


648 
ªs
 +
mhpmcou¡î6


649 
ªs
 +
mhpmcou¡î7


650 
ªs
 +
mhpmcou¡î8


651 
ªs
 +
mhpmcou¡î9


652 
ªs
 +
mhpmcou¡î10


653 
ªs
 +
mhpmcou¡î11


654 
ªs
 +
mhpmcou¡î12


655 
ªs
 +
mhpmcou¡î13


656 
ªs
 +
mhpmcou¡î14


657 
ªs
 +
mhpmcou¡î15


658 
ªs
 +
mhpmcou¡î16


659 
ªs
 +
mhpmcou¡î17


660 
ªs
 +
mhpmcou¡î18


661 
ªs
 +
mhpmcou¡î19


662 
ªs
 +
mhpmcou¡î20


663 
ªs
 +
mhpmcou¡î21


664 
ªs
 +
mhpmcou¡î22


665 
ªs
 +
mhpmcou¡î23


666 
ªs
 +
mhpmcou¡î24


667 
ªs
 +
mhpmcou¡î25


668 
ªs
 +
mhpmcou¡î26


669 
ªs
 +
mhpmcou¡î27


670 
ªs
 +
mhpmcou¡î28


671 
ªs
 +
mhpmcou¡î29


672 
ªs
 +
mhpmcou¡î30


673 
ªs
 +
mhpmcou¡î31


674 
ªs
 +
mhpmevít3


675 
ªs
 +
mhpmevít4


676 
ªs
 +
mhpmevít5


677 
ªs
 +
mhpmevít6


678 
ªs
 +
mhpmevít7


679 
ªs
 +
mhpmevít8


680 
ªs
 +
mhpmevít9


681 
ªs
 +
mhpmevít10


682 
ªs
 +
mhpmevít11


683 
ªs
 +
mhpmevít12


684 
ªs
 +
mhpmevít13


685 
ªs
 +
mhpmevít14


686 
ªs
 +
mhpmevít15


687 
ªs
 +
mhpmevít16


688 
ªs
 +
mhpmevít17


689 
ªs
 +
mhpmevít18


690 
ªs
 +
mhpmevít19


691 
ªs
 +
mhpmevít20


692 
ªs
 +
mhpmevít21


693 
ªs
 +
mhpmevít22


694 
ªs
 +
mhpmevít23


695 
ªs
 +
mhpmevít24


696 
ªs
 +
mhpmevít25


697 
ªs
 +
mhpmevít26


698 
ªs
 +
mhpmevít27


699 
ªs
 +
mhpmevít28


700 
ªs
 +
mhpmevít29


701 
ªs
 +
mhpmevít30


702 
ªs
 +
mhpmevít31


703 
ªs
 +
mvíd‹id


704 
ªs
 +
m¨chid


705 
ªs
 +
mimpid


706 
ªs
 +
mh¨tid


707 
ªs
.
toAºay


709 
vÆ
 
	gÆl32
 = {

710 
vÆ
 
ªs
 = 
cﬁÀ˘i⁄
.
muèbÀ
.
AºayBuf„r
(
Æl
:
_
*)

711 
ªs
 +
cy˛eh


712 
ªs
 +
timeh


713 
ªs
 +
ö°ªth


714 
ªs
 +
hpmcou¡î3h


715 
ªs
 +
hpmcou¡î4h


716 
ªs
 +
hpmcou¡î5h


717 
ªs
 +
hpmcou¡î6h


718 
ªs
 +
hpmcou¡î7h


719 
ªs
 +
hpmcou¡î8h


720 
ªs
 +
hpmcou¡î9h


721 
ªs
 +
hpmcou¡î10h


722 
ªs
 +
hpmcou¡î11h


723 
ªs
 +
hpmcou¡î12h


724 
ªs
 +
hpmcou¡î13h


725 
ªs
 +
hpmcou¡î14h


726 
ªs
 +
hpmcou¡î15h


727 
ªs
 +
hpmcou¡î16h


728 
ªs
 +
hpmcou¡î17h


729 
ªs
 +
hpmcou¡î18h


730 
ªs
 +
hpmcou¡î19h


731 
ªs
 +
hpmcou¡î20h


732 
ªs
 +
hpmcou¡î21h


733 
ªs
 +
hpmcou¡î22h


734 
ªs
 +
hpmcou¡î23h


735 
ªs
 +
hpmcou¡î24h


736 
ªs
 +
hpmcou¡î25h


737 
ªs
 +
hpmcou¡î26h


738 
ªs
 +
hpmcou¡î27h


739 
ªs
 +
hpmcou¡î28h


740 
ªs
 +
hpmcou¡î29h


741 
ªs
 +
hpmcou¡î30h


742 
ªs
 +
hpmcou¡î31h


743 
ªs
 +
mcy˛eh


744 
ªs
 +
mö°ªth


745 
ªs
 +
mhpmcou¡î3h


746 
ªs
 +
mhpmcou¡î4h


747 
ªs
 +
mhpmcou¡î5h


748 
ªs
 +
mhpmcou¡î6h


749 
ªs
 +
mhpmcou¡î7h


750 
ªs
 +
mhpmcou¡î8h


751 
ªs
 +
mhpmcou¡î9h


752 
ªs
 +
mhpmcou¡î10h


753 
ªs
 +
mhpmcou¡î11h


754 
ªs
 +
mhpmcou¡î12h


755 
ªs
 +
mhpmcou¡î13h


756 
ªs
 +
mhpmcou¡î14h


757 
ªs
 +
mhpmcou¡î15h


758 
ªs
 +
mhpmcou¡î16h


759 
ªs
 +
mhpmcou¡î17h


760 
ªs
 +
mhpmcou¡î18h


761 
ªs
 +
mhpmcou¡î19h


762 
ªs
 +
mhpmcou¡î20h


763 
ªs
 +
mhpmcou¡î21h


764 
ªs
 +
mhpmcou¡î22h


765 
ªs
 +
mhpmcou¡î23h


766 
ªs
 +
mhpmcou¡î24h


767 
ªs
 +
mhpmcou¡î25h


768 
ªs
 +
mhpmcou¡î26h


769 
ªs
 +
mhpmcou¡î27h


770 
ªs
 +
mhpmcou¡î28h


771 
ªs
 +
mhpmcou¡î29h


772 
ªs
 +
mhpmcou¡î30h


773 
ªs
 +
mhpmcou¡î31h


774 
ªs
.
toAºay


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Multiplier.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	gALU
.
_


11 
˛ass
 
	$Mu…ùlõrReq
(
d©aBôs
: 
I¡
, 
ègBôs
: I¡Ë
exãnds
 
BundÀ
 {

12 
vÆ
 
‚
 = 
	`Bôs
(
width
 = 
SZ_ALU_FN
)

13 
vÆ
 
dw
 = 
	`Bôs
(
width
 = 
SZ_DW
)

14 
vÆ
 
ö1
 = 
	`Bôs
(
width
 = 
d©aBôs
)

15 
vÆ
 
ö2
 = 
	`Bôs
(
width
 = 
d©aBôs
)

16 
vÆ
 
èg
 = 
	`UI¡
(
width
 = 
ègBôs
)

17 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`Mu…ùlõrReq
(
d©aBôs
, 
ègBôs
).
asIn°™˚Of
[
this
.
ty≥
]

18 
	}
}

20 
˛ass
 
	$Mu…ùlõrRe•
(
d©aBôs
: 
I¡
, 
ègBôs
: I¡Ë
exãnds
 
BundÀ
 {

21 
vÆ
 
d©a
 = 
	`Bôs
(
width
 = 
d©aBôs
)

22 
vÆ
 
èg
 = 
	`UI¡
(
width
 = 
ègBôs
)

23 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`Mu…ùlõrRe•
(
d©aBôs
, 
ègBôs
).
asIn°™˚Of
[
this
.
ty≥
]

24 
	}
}

26 
˛ass
 
	$Mu…ùlõrIO
(
d©aBôs
: 
I¡
, 
ègBôs
: I¡Ë
exãnds
 
BundÀ
 {

27 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
	`Mu…ùlõrReq
(
d©aBôs
, 
ègBôs
)).
Êù


28 
vÆ
 
kûl
 = 
	`Boﬁ
(
INPUT
)

29 
vÆ
 
ª•
 = 
	`Decou∂ed
(
√w
 
	`Mu…ùlõrRe•
(
d©aBôs
, 
ègBôs
))

30 
	}
}

32 
˛ass
 
	$MulDivP¨ams
(

33 
mulUƒﬁl
: 
I¡
 = 1,

34 
divUƒﬁl
: 
I¡
 = 1,

35 
mulE¨lyOut
: 
Boﬁón
 = 
Ál£
,

36 
divE¨lyOut
: 
Boﬁón
 = 
Ál£
,

37 
divE¨lyOutGønuœrôy
: 
I¡
 = 1

40 
˛ass
 
	$MulDiv
(
cfg
: 
MulDivP¨ams
, 
width
: 
I¡
, 
nX¥
: I¡ = 32Ë
exãnds
 
ModuÀ
 {

41 
¥iv©e
 
def
 
möDivL©ícy
 = (
cfg
.
divUƒﬁl
 > 0).
	`›ti⁄
(i‡(cfg.
divE¨lyOut
Ë3 1 + 
w
/cfg.divUnroll)

42 
¥iv©e
 
def
 
möMulL©ícy
 = (
cfg
.
mulUƒﬁl
 > 0).
	`›ti⁄
(i‡(cfg.
mulE¨lyOut
Ë2 
w
/cfg.mulUnroll)

43 
def
 
möL©ícy
: 
I¡
 = (
möDivL©ícy
 ++ 
möMulL©ícy
).
mö


45 
vÆ
 
io
 = 
√w
 
	`Mu…ùlõrIO
(
width
, 
	`log2Up
(
nX¥
))

46 
vÆ
 
w
 = 
io
.
ªq
.
bôs
.
ö1
.
gëWidth


47 
vÆ
 
mulw
 = i‡(
cfg
.
mulUƒﬁl
 =0Ë
w
 (w + cfg.mulUnroll - 1) / cfg.mulUnroll * cfg.mulUnroll

48 
vÆ
 
Á°MulW
 = i‡(
cfg
.
mulUƒﬁl
 =0Ë
Ál£
 
w
/2 > cfg.mulUnroll && w % (2*cfg.mulUnroll) == 0

50 
vÆ
 
s_ªady
 :: 
s_√g_öputs
 :: 
s_mul
 :: 
s_div
 :: 
s_dummy
 :: 
s_√g_ouçut
 :: 
s_d⁄e_mul
 :: 
s_d⁄e_div
 :: 
Nû
 = 
	`Enum
(
	`UI¡
(), 8)

51 
vÆ
 
°©e
 = 
	`Reg
(
öô
=
s_ªady
)

53 
vÆ
 
ªq
 = 
	`Reg
(
io
.ªq.
bôs
)

54 
vÆ
 
cou¡
 = 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Ceû
(

55 ((
cfg
.
divUƒﬁl
 !0).
	`›ti⁄
(
w
/cfg.divUƒﬁ»+ 1).
toSeq
 ++

56 (
cfg
.
mulUƒﬁl
 !0).
	`›ti⁄
(
mulw
/cfg.mulUƒﬁl)).
	`ªdu˚
(
_
 
max
 _))))

57 
vÆ
 
√g_out
 = 
	`Reg
(
	`Boﬁ
())

58 
vÆ
 
isHi
 = 
	`Reg
(
	`Boﬁ
())

59 
vÆ
 
ªsHi
 = 
	`Reg
(
	`Boﬁ
())

60 
vÆ
 
divis‹
 = 
	`Reg
(
	`Bôs
(
width
 = 
w
+1))

61 
vÆ
 
ªmaödî
 = 
	`Reg
(
	`Bôs
(
width
 = 2*
mulw
+2))

63 
vÆ
 
mulDecode
 = 
	`Li°
(

64 
FN_MUL
 -> 
	`Li°
(
Y
, 
N
, 
X
, X),

65 
FN_MULH
 -> 
	`Li°
(
Y
, Y, Y, Y),

66 
FN_MULHU
 -> 
	`Li°
(
Y
, Y, 
N
, N),

67 
FN_MULHSU
 -> 
	`Li°
(
Y
, Y, Y, 
N
))

68 
vÆ
 
divDecode
 = 
	`Li°
(

69 
FN_DIV
 -> 
	`Li°
(
N
, N, 
Y
, Y),

70 
FN_REM
 -> 
	`Li°
(
N
, 
Y
, Y, Y),

71 
FN_DIVU
 -> 
	`Li°
(
N
, N, N, N),

72 
FN_REMU
 -> 
	`Li°
(
N
, 
Y
, N, N))

73 
vÆ
 
cmdMul
 :: 
cmdHi
 :: 
lhsSig√d
 :: 
rhsSig√d
 :: 
Nû
 =

74 
	`DecodeLogic
(
io
.
ªq
.
bôs
.
‚
, 
	`Li°
(
X
, X, X, X),

75 (i‡(
cfg
.
divUƒﬁl
 !0Ë
divDecode
 
Nû
Ë++ (i‡(cfg.
mulUƒﬁl
 !0Ë
mulDecode
 Nû)).
	`m≠
(
_
.
toBoﬁ
)

77 
	`ªquúe
(
w
 == 32 || w == 64)

78 
def
 
	`hÆfWidth
(
ªq
: 
Mu…ùlõrReq
Ë
	`Boﬁ
(
w
 > 32Ë&&Ñeq.
dw
 ==
DW_32


80 
def
 
	`£xt
(
x
: 
Bôs
, 
hÆfW
: 
Boﬁ
, signed: Bool) = {

81 
vÆ
 
sign
 = sig√d && 
	`Mux
(
hÆfW
, 
	`x
(
w
/2-1), x(w-1))

82 
vÆ
 
hi
 = 
	`Mux
(
hÆfW
, 
	`Fûl
(
w
/2, 
sign
), 
	`x
(w-1,w/2))

83 (
	`C©
(
hi
, 
	`x
(
w
/2-1,0)), 
sign
)

85 
	`vÆ
 (
lhs_ö
, 
lhs_sign
Ë
	`£xt
(
io
.
ªq
.
bôs
.
ö1
, 
	`hÆfWidth
(io.ªq.bôs), 
lhsSig√d
)

86 
	`vÆ
 (
rhs_ö
, 
rhs_sign
Ë
	`£xt
(
io
.
ªq
.
bôs
.
ö2
, 
	`hÆfWidth
(io.ªq.bôs), 
rhsSig√d
)

88 
vÆ
 
subåa˘‹
 = 
	`ªmaödî
(2*
w
,wË- 
divis‹


89 
vÆ
 
ªsu…
 = 
	`Mux
(
ªsHi
, 
	`ªmaödî
(2*
w
, w+1),Ñemainder(w-1, 0))

90 
vÆ
 
√g©ed_ªmaödî
 = -
ªsu…


92 i‡(
cfg
.
divUƒﬁl
 !0Ë
	`whí
 (
°©e
 ==
s_√g_öputs
) {

93 
	`whí
 (
	`ªmaödî
(
w
-1)) {

94 
ªmaödî
 :
√g©ed_ªmaödî


96 
	`whí
 (
	`divis‹
(
w
-1)) {

97 
divis‹
 :
subåa˘‹


99 
°©e
 :
s_div


101 i‡(
cfg
.
divUƒﬁl
 !0Ë
	`whí
 (
°©e
 ==
s_√g_ouçut
) {

102 
ªmaödî
 :
√g©ed_ªmaödî


103 
°©e
 :
s_d⁄e_div


104 
ªsHi
 :
Ál£


106 i‡(
cfg
.
mulUƒﬁl
 !0Ë
	`whí
 (
°©e
 ==
s_mul
) {

107 
vÆ
 
mulReg
 = 
	`C©
(
	`ªmaödî
(2*
mulw
+1,
w
+1),remainder(w-1,0))

108 
vÆ
 
m∂õrSign
 = 
	`ªmaödî
(
w
)

109 
vÆ
 
m∂õr
 = 
	`mulReg
(
mulw
-1,0)

110 
vÆ
 
accum
 = 
	`mulReg
(2*
mulw
,mulw).
asSI¡


111 
vÆ
 
mpˇnd
 = 
divis‹
.
asSI¡


112 
vÆ
 
¥od
 = 
	`C©
(
m∂õrSign
, 
	`m∂õr
(
cfg
.
mulUƒﬁl
-1, 0)).
asSI¡
 * 
mpˇnd
 + 
accum


113 
vÆ
 
√xtMulReg
 = 
	`C©
(
¥od
, 
	`m∂õr
(
mulw
-1, 
cfg
.
mulUƒﬁl
))

114 
vÆ
 
√xtM∂õrSign
 = 
cou¡
 ==
mulw
/
cfg
.
mulUƒﬁl
-2 && 
√g_out


116 
vÆ
 
eOutMask
 = (
	`SI¡
(
	`BigI¡
(-1Ë<< 
mulw
Ë>> (
cou¡
 * 
cfg
.
mulUƒﬁl
)(
	`log2Up
(mulw)-1,0))(mulw-1,0)

117 
vÆ
 
eOut
 = 
	`Boﬁ
(
cfg
.
mulE¨lyOut
Ë&& 
cou¡
 =/
mulw
/cfg.
mulUƒﬁl
-1 && count =/= 0 &&

118 !
isHi
 && (
m∂õr
 & ~
eOutMask
Ë==
	`UI¡
(0)

119 
vÆ
 
eOutRes
 = (
mulReg
 >> (
mulw
 - 
cou¡
 * 
cfg
.
mulUƒﬁl
)(
	`log2Up
(mulw)-1,0))

120 
vÆ
 
√xtMulReg1
 = 
	`C©
(
	`√xtMulReg
(2*
mulw
,mulw), 
	`Mux
(
eOut
, 
eOutRes
, 
√xtMulReg
)(mulw-1,0))

121 
ªmaödî
 :
	`C©
(
√xtMulReg1
 >> 
w
, 
√xtM∂õrSign
, 
	`√xtMulReg1
(w-1,0))

123 
cou¡
 := count + 1

124 
	`whí
 (
eOut
 || 
cou¡
 ==
mulw
/
cfg
.
mulUƒﬁl
-1) {

125 
°©e
 :
s_d⁄e_mul


126 
ªsHi
 :
isHi


129 i‡(
cfg
.
divUƒﬁl
 !0Ë
	`whí
 (
°©e
 ==
s_div
) {

130 
vÆ
 
uƒﬁls
 = ((0 
u¡û
 
cfg
.
divUƒﬁl
Ë
sˇnLe·
 
ªmaödî
Ë{ (
ªm
, 
i
) =>

132 
vÆ
 
dif„ªn˚
 = i‡(
i
 =0Ë
subåa˘‹
 
	`ªm
(2*
w
,wË- 
	`divis‹
(w-1,0)

133 
vÆ
 
Àss
 = 
	`dif„ªn˚
(
w
)

134 
	`C©
(
	`Mux
(
Àss
, 
	`ªm
(2*
w
-1,w), 
	`dif„ªn˚
(w-1,0)),Ñem(w-1,0), !less)

135 } 
èû


137 
ªmaödî
 :
uƒﬁls
.
œ°


138 
	`whí
 (
cou¡
 ==
w
/
cfg
.
divUƒﬁl
) {

139 
°©e
 :
	`Mux
(
√g_out
, 
s_√g_ouçut
, 
s_d⁄e_div
)

140 
ªsHi
 :
isHi


141 i‡(
w
 % 
cfg
.
divUƒﬁl
 < cfg.divUnroll - 1)

142 
ªmaödî
 :
	`uƒﬁls
(
w
 % 
cfg
.
divUƒﬁl
)

144 
cou¡
 := count + 1

146 
vÆ
 
divby0
 = 
cou¡
 ==0 && !
	`subåa˘‹
(
w
)

147 i‡(
cfg
.
divE¨lyOut
) {

148 
vÆ
 
Æign
 = 1 << 
	`log2Flo‹
(
cfg
.
divUƒﬁl
 
max
 cfg.
divE¨lyOutGønuœrôy
)

149 
vÆ
 
ÆignMask
 = ~
	`UI¡
(
Æign
-1, 
	`log2Ceû
(
w
))

150 
vÆ
 
divis‹MSB
 = 
	`Log2
(
	`divis‹
(
w
-1,0), wË& 
ÆignMask


151 
vÆ
 
dividídMSB
 = 
	`Log2
(
	`ªmaödî
(
w
-1,0), wË| ~
ÆignMask


152 
vÆ
 
eOutPos
 = ~(
dividídMSB
 - 
divis‹MSB
)

153 
vÆ
 
eOut
 = 
cou¡
 ==0 && !
divby0
 && 
eOutPos
 >
Æign


154 
	`whí
 (
eOut
) {

155 
ªmaödî
 :
	`ªmaödî
(
w
-1,0Ë<< 
eOutPos


156 
cou¡
 :
eOutPos
 >> 
	`log2Flo‹
(
cfg
.
divUƒﬁl
)

159 
	`whí
 (
divby0
 && !
isHi
Ë{ 
√g_out
 :
Ál£
 }

161 
	`whí
 (
io
.
ª•
.
	`fúe
(Ë|| io.
kûl
) {

162 
°©e
 :
s_ªady


164 
	`whí
 (
io
.
ªq
.
	`fúe
()) {

165 
°©e
 :
	`Mux
(
cmdMul
, 
s_mul
, Mux(
lhs_sign
 || 
rhs_sign
, 
s_√g_öputs
, 
s_div
))

166 
isHi
 :
cmdHi


167 
ªsHi
 :
Ál£


168 
cou¡
 :(i‡(
Á°MulW
Ë
Mux
[
UI¡
](
cmdMul
 && 
	`hÆfWidth
(
io
.
ªq
.
bôs
), 
w
/
cfg
.
mulUƒﬁl
/2, 0) 0)

169 
√g_out
 :
	`Mux
(
cmdHi
, 
lhs_sign
,Ühs_sig¿=/
rhs_sign
)

170 
divis‹
 :
	`C©
(
rhs_sign
, 
rhs_ö
)

171 
ªmaödî
 :
lhs_ö


172 
ªq
 :
io
.ªq.
bôs


175 
vÆ
 
outMul
 = (
°©e
 & (
s_d⁄e_mul
 ^ 
s_d⁄e_div
)) === (s_done_mul & ~s_done_div)

176 
vÆ
 
loOut
 = 
	`Mux
(
	`Boﬁ
(
Á°MulW
Ë&& 
	`hÆfWidth
(
ªq
Ë&& 
outMul
, 
	`ªsu…
(
w
-1,w/2),Ñesult(w/2-1,0))

177 
vÆ
 
hiOut
 = 
	`Mux
(
	`hÆfWidth
(
ªq
), 
	`Fûl
(
w
/2, 
	`loOut
(w/2-1)), 
	`ªsu…
(w-1,w/2))

178 
io
.
ª•
.
bôs
 <> 
ªq


179 
io
.
ª•
.
bôs
.
d©a
 :
	`C©
(
hiOut
, 
loOut
)

180 
io
.
ª•
.
vÆid
 :(
°©e
 ==
s_d⁄e_mul
 || sèã ==
s_d⁄e_div
)

181 
io
.
ªq
.
ªady
 :
°©e
 ==
s_ªady


182 
	}
}

184 
˛ass
 
	$PùñöedMu…ùlõr
(
width
: 
I¡
, 
œãncy
: I¡, 
nX¥
: I¡ = 32Ë
exãnds
 
ModuÀ
 
wôh
 
ShouldBeRëimed
 {

185 
vÆ
 
io
 = 
√w
 
BundÀ
 {

186 
vÆ
 
ªq
 = 
	`VÆid
(
√w
 
	`Mu…ùlõrReq
(
width
, 
	`log2Ceû
(
nX¥
))).
Êù


187 
vÆ
 
ª•
 = 
	`VÆid
(
√w
 
	`Mu…ùlõrRe•
(
width
, 
	`log2Ceû
(
nX¥
)))

190 
vÆ
 
ö
 = 
	`Pùe
(
io
.
ªq
)

192 
vÆ
 
decode
 = 
	`Li°
(

193 
FN_MUL
 -> 
	`Li°
(
N
, 
X
, X),

194 
FN_MULH
 -> 
	`Li°
(
Y
, Y, Y),

195 
FN_MULHU
 -> 
	`Li°
(
Y
, 
N
, N),

196 
FN_MULHSU
 -> 
	`Li°
(
Y
, Y, 
N
))

197 
vÆ
 
cmdHi
 :: 
lhsSig√d
 :: 
rhsSig√d
 :: 
Nû
 =

198 
	`DecodeLogic
(
ö
.
bôs
.
‚
, 
	`Li°
(
X
, X, X), 
decode
).
	`m≠
(
_
.
toBoﬁ
)

199 
vÆ
 
cmdHÆf
 = 
	`Boﬁ
(
width
 > 32Ë&& 
ö
.
bôs
.
dw
 ==
DW_32


201 
vÆ
 
lhs
 = 
	`C©
(
lhsSig√d
 && 
ö
.
bôs
.
	`ö1
(
width
-1), in.bôs.
ö1
).
asSI¡


202 
vÆ
 
rhs
 = 
	`C©
(
rhsSig√d
 && 
ö
.
bôs
.
	`ö2
(
width
-1), in.bôs.
ö2
).
asSI¡


203 
vÆ
 
¥od
 = 
lhs
 * 
rhs


204 
vÆ
 
muxed
 = 
	`Mux
(
cmdHi
, 
	`¥od
(2*
width
-1, width), Mux(
cmdHÆf
,Örod(width/2-1, 0).
	`£xtTo
(width),Örod(width-1, 0)))

206 
io
.
ª•
 :
	`Pùe
(
ö
, 
œãncy
-1)

207 
io
.
ª•
.
bôs
.
d©a
 :
	`Pùe
(
ö
.
vÆid
, 
muxed
, 
œãncy
-1).bits

208 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/NBDcache.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


13 
åaô
 
HasMissInfo
 
exãnds
 
	gHasL1HñœCacheP¨amëîs
 {

14 
vÆ
 
	gèg_m©ch
 = 
Boﬁ
()

15 
vÆ
 
ﬁd_mëa
 = 
√w
 
L1Mëad©a


16 
vÆ
 
way_í
 = 
Bôs
(
width
 = 
nWays
)

19 ˛as†
	cL1D©aRódReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheBundÀ
()(
p
) {

20 
vÆ
 
way_í
 = 
	$Bôs
(
width
 = 
nWays
)

21 
vÆ
 
addr
 = 
	`Bôs
(
width
 = 
u¡agBôs
)

24 ˛as†
	cL1D©aWrôeReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1D©aRódReq
()(
p
) {

25 
vÆ
 
wmask
 = 
	$Bôs
(
width
 = 
rowW‹ds
)

26 
vÆ
 
d©a
 = 
	`Bôs
(
width
 = 
ícRowBôs
)

29 ˛as†
	cL1RefûlReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1D©aRódReq
()(
p
)

31 ˛as†
	cRïœy
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$HñœCacheReqI¡î«l
()(
p
Ë
wôh
 
HasC‹eD©a


33 ˛as†
	cRïœyI¡î«l
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$HñœCacheReqI¡î«l
()(
p
)

34 
wôh
 
HasL1HñœCacheP¨amëîs
 {

35 
vÆ
 
sdq_id
 = 
	`UI¡
(
width
 = 
	`log2Up
(
cfg
.
nSDQ
))

38 ˛as†
	cMSHRReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$Rïœy
()(
p
Ë
wôh
 
HasMissInfo


40 ˛as†
	cMSHRReqI¡î«l
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$RïœyI¡î«l
()(
p
Ë
wôh
 
HasMissInfo


42 ˛as†
	cWrôebackReq
(
∑øms
: 
TLBundÀP¨amëîs
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheBundÀ
()(
p
) {

43 
vÆ
 
èg
 = 
	$Bôs
(
width
 = 
ègBôs
)

44 
vÆ
 
idx
 = 
	$Bôs
(
width
 = 
idxBôs
)

45 
vÆ
 
sour˚
 = 
	$UI¡
(
width
 = 
∑øms
.
sour˚Bôs
)

46 
vÆ
 
∑øm
 = 
	$UI¡
(
width
 = 
TLPîmissi⁄s
.
cWidth
)

47 
vÆ
 
way_í
 = 
	$Bôs
(
width
 = 
nWays
)

48 
vÆ
 
vﬁu¡¨y
 = 
	$Boﬁ
()

50 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	$WrôebackReq
(
∑øms
)(
p
).
asIn°™˚Of
[
this
.
ty≥
]

53 
˛ass
 
	$IOMSHR
(
id
: 
I¡
)(
im∂icô
 
edge
: 
TLEdgeOut
, 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

54 
vÆ
 
io
 = 
√w
 
BundÀ
 {

55 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
HñœCacheReq
).
Êù


56 
vÆ
 
ª•
 = 
	`Decou∂ed
(
√w
 
HñœCacheRe•
)

57 
vÆ
 
mem_ac˚ss
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀA
(
edge
.
bundÀ
))

58 
vÆ
 
mem_ack
 = 
	`VÆid
(
√w
 
	`TLBundÀD
(
edge
.
bundÀ
)).
Êù


59 
vÆ
 
ª∂ay_√xt
 = 
	`Boﬁ
(
OUTPUT
)

62 
def
 
	`bótOff£t
(
addr
: 
UI¡
Ëaddr.
	`exåa˘
(
bótOffBôs
 - 1, 
w‹dOffBôs
)

64 
def
 
	`w‹dFromBót
(
addr
: 
UI¡
, 
d©
: UInt) = {

65 
vÆ
 
shi·
 = 
	`C©
(
	`bótOff£t
(
addr
), 
	`UI¡
(0, 
w‹dOffBôs
 + 
	`log2Up
(
w‹dByãs
)))

66 (
d©
 >> 
shi·
)(
w‹dBôs
 - 1, 0)

69 
vÆ
 
ªq
 = 
	`Reg
(
√w
 
HñœCacheReq
)

70 
vÆ
 
gø¡_w‹d
 = 
	`Reg
(
	`UI¡
(
width
 = 
w‹dBôs
))

72 
vÆ
 
s_idÀ
 :: 
s_mem_ac˚ss
 :: 
s_mem_ack
 :: 
s_ª•
 :: 
Nû
 = 
	`Enum
(
	`Bôs
(), 4)

73 
vÆ
 
°©e
 = 
	`Reg
(
öô
 = 
s_idÀ
)

74 
io
.
ªq
.
ªady
 :(
°©e
 ==
s_idÀ
)

76 
vÆ
 
lﬂdgí
 = 
√w
 
	`LﬂdGí
(
ªq
.
typ
, 
	`mtSig√d
‘eq.typ),Ñeq.
addr
, 
gø¡_w‹d
, 
Ál£
.
B
, 
w‹dByãs
)

78 
vÆ
 
a_sour˚
 = 
	`UI¡
(
id
)

79 
vÆ
 
a_addªss
 = 
ªq
.
addr


80 
vÆ
 
a_size
 = 
	`mtSize
(
ªq
.
typ
)

81 
vÆ
 
a_d©a
 = 
	`Fûl
(
bótW‹ds
, 
ªq
.
d©a
)

83 
vÆ
 
gë
 = 
edge
.
	`Gë
(
a_sour˚
, 
a_addªss
, 
a_size
).
_2


84 
vÆ
 
put
 = 
edge
.
	`Put
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
).
_2


85 
vÆ
 
©omics
 = i‡(
edge
.
m™agî
.
™ySuµ‹tLogiˇl
) {

86 
	`MuxLookup
(
ªq
.
cmd
, 
	`Wúe
(
√w
 
	`TLBundÀA
(
edge
.
bundÀ
)), 
	`Aºay
(

87 
M_XA_SWAP
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
SWAP
).
_2
,

88 
M_XA_XOR
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
XOR
Ë.
_2
,

89 
M_XA_OR
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
OR
Ë.
_2
,

90 
M_XA_AND
 -> 
edge
.
	`Logiˇl
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
AND
Ë.
_2
,

91 
M_XA_ADD
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
ADD
).
_2
,

92 
M_XA_MIN
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MIN
).
_2
,

93 
M_XA_MAX
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAX
).
_2
,

94 
M_XA_MINU
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MINU
).
_2
,

95 
M_XA_MAXU
 -> 
edge
.
	`Arôhmëic
(
a_sour˚
, 
a_addªss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAXU
).
_2
))

98 
	`as£π
(
°©e
 ==
s_idÀ
 || !
	`isAMO
(
ªq
.
cmd
))

99 
	`Wúe
(
√w
 
	`TLBundÀA
(
edge
.
bundÀ
))

101 
	`as£π
(
°©e
 ==
s_idÀ
 || 
ªq
.
cmd
 =/
M_XSC
)

103 
io
.
mem_ac˚ss
.
vÆid
 :(
°©e
 ==
s_mem_ac˚ss
)

104 
io
.
mem_ac˚ss
.
bôs
 :
	`Mux
(
	`isAMO
(
ªq
.
cmd
), 
©omics
, Mux(
	`isRód
‘eq.cmd), 
gë
, 
put
))

106 
io
.
ª∂ay_√xt
 :(
°©e
 ==
s_mem_ack
Ë|| io.
ª•
.
vÆid
 && !io.ª•.
ªady


107 
io
.
ª•
.
vÆid
 :(
°©e
 ==
s_ª•
)

108 
io
.
ª•
.
bôs
 :
ªq


109 
io
.
ª•
.
bôs
.
has_d©a
 :
	`isRód
(
ªq
.
cmd
)

110 
io
.
ª•
.
bôs
.
d©a
 :
lﬂdgí
.data

111 
io
.
ª•
.
bôs
.
°‹e_d©a
 :
ªq
.
d©a


112 
io
.
ª•
.
bôs
.
ª∂ay
 :
	`Boﬁ
(
åue
)

114 
	`whí
 (
io
.
ªq
.
	`fúe
()) {

115 
ªq
 :
io
.ªq.
bôs


116 
°©e
 :
s_mem_ac˚ss


119 
	`whí
 (
io
.
mem_ac˚ss
.
	`fúe
()) {

120 
°©e
 :
s_mem_ack


123 
	`whí
 (
°©e
 ==
s_mem_ack
 && 
io
.
mem_ack
.
vÆid
) {

124 
°©e
 :
s_ª•


125 
	`whí
 (
	`isRód
(
ªq
.
cmd
)) {

126 
gø¡_w‹d
 :
	`w‹dFromBót
(
ªq
.
addr
, 
io
.
mem_ack
.
bôs
.
d©a
)

130 
	`whí
 (
io
.
ª•
.
	`fúe
()) {

131 
°©e
 :
s_idÀ


133 
	}
}

135 
˛ass
 
	$MSHR
(
id
: 
I¡
)(
im∂icô
 
edge
: 
TLEdgeOut
, 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

136 
vÆ
 
io
 = 
√w
 
BundÀ
 {

137 
vÆ
 
ªq_¥i_vÆ
 = 
	`Boﬁ
(
INPUT
)

138 
vÆ
 
ªq_¥i_rdy
 = 
	`Boﬁ
(
OUTPUT
)

139 
vÆ
 
ªq_£c_vÆ
 = 
	`Boﬁ
(
INPUT
)

140 
vÆ
 
ªq_£c_rdy
 = 
	`Boﬁ
(
OUTPUT
)

141 
vÆ
 
ªq_bôs
 = 
√w
 
	`MSHRReqI¡î«l
().
asI≈ut


143 
vÆ
 
idx_m©ch
 = 
	`Boﬁ
(
OUTPUT
)

144 
vÆ
 
èg
 = 
	`Bôs
(
OUTPUT
, 
ègBôs
)

146 
vÆ
 
mem_acquúe
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀA
(
edge
.
bundÀ
))

147 
vÆ
 
mem_gø¡
 = 
	`VÆid
(
√w
 
	`TLBundÀD
(
edge
.
bundÀ
)).
Êù


148 
vÆ
 
mem_föish
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀE
(
edge
.
bundÀ
))

150 
vÆ
 
ªfûl
 = 
√w
 
	`L1RefûlReq
().
asOuçut


151 
vÆ
 
mëa_ªad
 = 
	`Decou∂ed
(
√w
 
L1MëaRódReq
)

152 
vÆ
 
mëa_wrôe
 = 
	`Decou∂ed
(
√w
 
L1MëaWrôeReq
)

153 
vÆ
 
ª∂ay
 = 
	`Decou∂ed
(
√w
 
RïœyI¡î«l
)

154 
vÆ
 
wb_ªq
 = 
	`Decou∂ed
(
√w
 
	`WrôebackReq
(
edge
.
bundÀ
))

155 
vÆ
 
¥obe_rdy
 = 
	`Boﬁ
(
OUTPUT
)

158 
vÆ
 
s_övÆid
 :: 
s_wb_ªq
 :: 
s_wb_ª•
 :: 
s_mëa_˛ór
 :: 
s_ªfûl_ªq
 :: 
s_ªfûl_ª•
 :: 
s_mëa_wrôe_ªq
 :: 
s_mëa_wrôe_ª•
 :: 
s_døö_Ωq
 :: 
Nû
 = 
	`Enum
(
	`UI¡
(), 9)

159 
vÆ
 
°©e
 = 
	`Reg
(
öô
=
s_övÆid
)

161 
vÆ
 
ªq
 = 
	`Reg
(
√w
 
MSHRReqI¡î«l
)

162 
vÆ
 
ªq_idx
 = 
ªq
.
	`addr
(
u¡agBôs
-1,
blockOffBôs
)

163 
vÆ
 
ªq_èg
 = 
ªq
.
addr
 >> 
u¡agBôs


164 
vÆ
 
ªq_block_addr
 = (
ªq
.
addr
 >> 
blockOffBôs
) << blockOffBits

165 
vÆ
 
idx_m©ch
 = 
ªq_idx
 ==
io
.
ªq_bôs
.
	`addr
(
u¡agBôs
-1,
blockOffBôs
)

167 
vÆ
 
√w_coh
 = 
	`Reg
(
öô
=
Clõ¡Mëad©a
.
⁄Re£t
)

168 
	`vÆ
 (
_
, 
shrök_∑øm
, 
coh_⁄_˛ór
Ë
ªq
.
ﬁd_mëa
.
coh
.
	`⁄CacheC⁄åﬁ
(
M_FLUSH
)

169 
vÆ
 
grow_∑øm
 = 
√w_coh
.
	`⁄Ac˚ss
(
ªq
.
cmd
).
_2


170 
vÆ
 
coh_⁄_gø¡
 = 
√w_coh
.
	`⁄Gø¡
(
ªq
.
cmd
, 
io
.
mem_gø¡
.
bôs
.
∑øm
)

175 
	`vÆ
 (
cmd_ªquúes_£c⁄d_acquúe
, 
is_hô_agaö
, 
_
, 
dútõr_coh
, 
dútõr_cmd
) =

176 
√w_coh
.
	`⁄Sec⁄d¨yAc˚ss
(
ªq
.
cmd
, 
io
.
ªq_bôs
.cmd)

178 
vÆ
 
°©es_bef‹e_ªfûl
 = 
	`Seq
(
s_wb_ªq
, 
s_wb_ª•
, 
s_mëa_˛ór
)

179 
	`vÆ
 (
_
, _, 
ªfûl_d⁄e
, 
ªfûl_addªss_öc
Ë
edge
.
	`addr_öc
(
io
.
mem_gø¡
)

180 
vÆ
 
£c_rdy
 = 
idx_m©ch
 &&

181 (
°©e
.
	`isO√Of
(
°©es_bef‹e_ªfûl
) ||

182 (
°©e
.
	`isO√Of
(
s_ªfûl_ªq
, 
s_ªfûl_ª•
) &&

183 !
cmd_ªquúes_£c⁄d_acquúe
 && !
ªfûl_d⁄e
))

185 
vÆ
 
Ωq
 = 
	`ModuÀ
(
√w
 
	`Queue
“ew 
RïœyI¡î«l
, 
cfg
.
nRPQ
))

186 
Ωq
.
io
.
íq
.
vÆid
 :(io.
ªq_¥i_vÆ
 && io.
ªq_¥i_rdy
 || io.
ªq_£c_vÆ
 && 
£c_rdy
Ë&& !
	`isPª„tch
(io.
ªq_bôs
.
cmd
)

187 
Ωq
.
io
.
íq
.
bôs
 :io.
ªq_bôs


188 
Ωq
.
io
.
deq
.
ªady
 :(io.
ª∂ay
.ªady && 
°©e
 ==
s_døö_Ωq
Ë|| sèã ==
s_övÆid


190 
	`whí
 (
°©e
 ==
s_døö_Ωq
 && !
Ωq
.
io
.
deq
.
vÆid
) {

191 
°©e
 :
s_övÆid


193 
	`whí
 (
°©e
 ==
s_mëa_wrôe_ª•
) {

195 
°©e
 :
s_døö_Ωq


197 
	`whí
 (
°©e
 ==
s_mëa_wrôe_ªq
 && 
io
.
mëa_wrôe
.
ªady
) {

198 
°©e
 :
s_mëa_wrôe_ª•


200 
	`whí
 (
°©e
 ==
s_ªfûl_ª•
 && 
ªfûl_d⁄e
) {

201 
√w_coh
 :
coh_⁄_gø¡


202 
°©e
 :
s_mëa_wrôe_ªq


204 
	`whí
 (
io
.
mem_acquúe
.
	`fúe
()) {

205 
°©e
 :
s_ªfûl_ª•


207 
	`whí
 (
°©e
 ==
s_mëa_˛ór
 && 
io
.
mëa_wrôe
.
ªady
) {

208 
°©e
 :
s_ªfûl_ªq


210 
	`whí
 (
°©e
 ==
s_wb_ª•
 && 
io
.
mem_gø¡
.
vÆid
) {

211 
°©e
 :
s_mëa_˛ór


213 
	`whí
 (
io
.
wb_ªq
.
	`fúe
()) {

214 
°©e
 :
s_wb_ª•


216 
	`whí
 (
io
.
ªq_£c_vÆ
 && io.
ªq_£c_rdy
) {

220 
ªq
.
cmd
 :
dútõr_cmd


221 
	`whí
 (
is_hô_agaö
) {

222 
√w_coh
 :
dútõr_coh


225 
	`whí
 (
io
.
ªq_¥i_vÆ
 && io.
ªq_¥i_rdy
) {

226 
ªq
 :
io
.
ªq_bôs


227 
vÆ
 
ﬁd_coh
 = 
io
.
ªq_bôs
.
ﬁd_mëa
.
coh


228 
vÆ
 
√eds_wb
 = 
ﬁd_coh
.
	`⁄CacheC⁄åﬁ
(
M_FLUSH
).
_1


229 
	`vÆ
 (
is_hô
, 
_
, 
coh_⁄_hô
Ë
ﬁd_coh
.
	`⁄Ac˚ss
(
io
.
ªq_bôs
.
cmd
)

230 
	`whí
 (
io
.
ªq_bôs
.
èg_m©ch
) {

231 
	`whí
 (
is_hô
) {

232 
√w_coh
 :
coh_⁄_hô


233 
°©e
 :
s_mëa_wrôe_ªq


234 }.
Ÿhîwi£
 {

235 
√w_coh
 :
ﬁd_coh


236 
°©e
 :
s_ªfûl_ªq


238 }.
Ÿhîwi£
 {

239 
√w_coh
 :
Clõ¡Mëad©a
.
⁄Re£t


240 
°©e
 :
	`Mux
(
√eds_wb
, 
s_wb_ªq
, 
s_mëa_˛ór
)

244 
vÆ
 
gø¡ackq
 = 
	`ModuÀ
(
√w
 
	`Queue
(
io
.
mem_föish
.
bôs
, 1))

245 
vÆ
 
ˇn_föish
 = 
°©e
.
	`isO√Of
(
s_övÆid
, 
s_ªfûl_ªq
)

246 
gø¡ackq
.
io
.
íq
.
vÆid
 :
ªfûl_d⁄e
 && 
edge
.
	`isReque°
(io.
mem_gø¡
.
bôs
)

247 
gø¡ackq
.
io
.
íq
.
bôs
 :
edge
.
	`Gø¡Ack
(io.
mem_gø¡
.bits)

248 
io
.
mem_föish
.
vÆid
 :
gø¡ackq
.io.
deq
.vÆid && 
ˇn_föish


249 
io
.
mem_föish
.
bôs
 :
gø¡ackq
.io.
deq
.bits

250 
gø¡ackq
.
io
.
deq
.
ªady
 :io.
mem_föish
.ªady && 
ˇn_föish


252 
io
.
idx_m©ch
 :(
°©e
 =/
s_övÆid
) && idx_match

253 
io
.
ªfûl
.
way_í
 :
ªq
.way_en

254 
io
.
ªfûl
.
addr
 :
ªq_block_addr
 | 
ªfûl_addªss_öc


255 
io
.
èg
 :
ªq_èg


256 
io
.
ªq_¥i_rdy
 :
°©e
 ==
s_övÆid


257 
io
.
ªq_£c_rdy
 :
£c_rdy
 && 
Ωq
.io.
íq
.
ªady


259 
vÆ
 
mëa_haz¨d
 = 
	`Reg
(
öô
=
	`UI¡
(0,2))

260 
	`whí
 (
mëa_haz¨d
 =/
	`UI¡
(0)) { meta_hazard := meta_hazard + 1 }

261 
	`whí
 (
io
.
mëa_wrôe
.
	`fúe
()Ë{ 
mëa_haz¨d
 := 1 }

262 
io
.
¥obe_rdy
 :!
idx_m©ch
 || (!
°©e
.
	`isO√Of
(
°©es_bef‹e_ªfûl
Ë&& 
mëa_haz¨d
 === 0)

264 
io
.
mëa_wrôe
.
vÆid
 :
°©e
.
	`isO√Of
(
s_mëa_wrôe_ªq
, 
s_mëa_˛ór
)

265 
io
.
mëa_wrôe
.
bôs
.
idx
 :
ªq_idx


266 
io
.
mëa_wrôe
.
bôs
.
d©a
.
coh
 :
	`Mux
(
°©e
 ==
s_mëa_˛ór
, 
coh_⁄_˛ór
, 
√w_coh
)

267 
io
.
mëa_wrôe
.
bôs
.
d©a
.
èg
 := io.tag

268 
io
.
mëa_wrôe
.
bôs
.
way_í
 :
ªq
.way_en

270 
io
.
wb_ªq
.
vÆid
 :
°©e
 ==
s_wb_ªq


271 
io
.
wb_ªq
.
bôs
.
sour˚
 :
	`UI¡
(
id
)

272 
io
.
wb_ªq
.
bôs
.
èg
 :
ªq
.
ﬁd_mëa
.tag

273 
io
.
wb_ªq
.
bôs
.
idx
 :
ªq_idx


274 
io
.
wb_ªq
.
bôs
.
∑øm
 :
shrök_∑øm


275 
io
.
wb_ªq
.
bôs
.
way_í
 :
ªq
.way_en

276 
io
.
wb_ªq
.
bôs
.
vﬁu¡¨y
 :
	`Boﬁ
(
åue
)

278 
io
.
mem_acquúe
.
vÆid
 :
°©e
 ==
s_ªfûl_ªq
 && 
gø¡ackq
.io.
íq
.
ªady


279 
io
.
mem_acquúe
.
bôs
 :
edge
.
	`AcquúeBlock
(

280 
‰omSour˚
 = 
	`UI¡
(
id
),

281 
toAddªss
 = 
	`C©
(
io
.
èg
, 
ªq_idx
Ë<< 
blockOffBôs
,

282 
lgSize
 = 
lgCacheBlockByãs
,

283 
growPîmissi⁄s
 = 
grow_∑øm
).
_2


285 
io
.
mëa_ªad
.
vÆid
 :
°©e
 ==
s_døö_Ωq


286 
io
.
mëa_ªad
.
bôs
.
idx
 :
ªq_idx


287 
io
.
mëa_ªad
.
bôs
.
èg
 := io.tag

289 
io
.
ª∂ay
.
vÆid
 :
°©e
 ==
s_døö_Ωq
 && 
Ωq
.io.
deq
.valid

290 
io
.
ª∂ay
.
bôs
 :
Ωq
.io.
deq
.bits

291 
io
.
ª∂ay
.
bôs
.
phys
 :
	`Boﬁ
(
åue
)

292 
io
.
ª∂ay
.
bôs
.
addr
 :
	`C©
(io.
èg
, 
ªq_idx
, 
Ωq
.io.
deq
.bôs.
	`addr
(
blockOffBôs
-1,0))

294 
	`whí
 (!
io
.
mëa_ªad
.
ªady
) {

295 
Ωq
.
io
.
deq
.
ªady
 :
	`Boﬁ
(
Ál£
)

296 
io
.
ª∂ay
.
bôs
.
cmd
 :
M_FLUSH_ALL


298 
	}
}

300 
˛ass
 
	$MSHRFûe
(
im∂icô
 
edge
: 
TLEdgeOut
, 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

301 
vÆ
 
io
 = 
√w
 
BundÀ
 {

302 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
MSHRReq
).
Êù


303 
vÆ
 
ª•
 = 
	`Decou∂ed
(
√w
 
HñœCacheRe•
)

304 
vÆ
 
£c⁄d¨y_miss
 = 
	`Boﬁ
(
OUTPUT
)

306 
vÆ
 
mem_acquúe
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀA
(
edge
.
bundÀ
))

307 
vÆ
 
mem_gø¡
 = 
	`VÆid
(
√w
 
	`TLBundÀD
(
edge
.
bundÀ
)).
Êù


308 
vÆ
 
mem_föish
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀE
(
edge
.
bundÀ
))

310 
vÆ
 
ªfûl
 = 
√w
 
	`L1RefûlReq
().
asOuçut


311 
vÆ
 
mëa_ªad
 = 
	`Decou∂ed
(
√w
 
L1MëaRódReq
)

312 
vÆ
 
mëa_wrôe
 = 
	`Decou∂ed
(
√w
 
L1MëaWrôeReq
)

313 
vÆ
 
ª∂ay
 = 
	`Decou∂ed
(
√w
 
Rïœy
)

314 
vÆ
 
wb_ªq
 = 
	`Decou∂ed
(
√w
 
	`WrôebackReq
(
edge
.
bundÀ
))

316 
vÆ
 
¥obe_rdy
 = 
	`Boﬁ
(
OUTPUT
)

317 
vÆ
 
„n˚_rdy
 = 
	`Boﬁ
(
OUTPUT
)

318 
vÆ
 
ª∂ay_√xt
 = 
	`Boﬁ
(
OUTPUT
)

322 
vÆ
 
ˇchóbÀ
 = 
edge
.
m™agî
.
	`suµ‹tsAcquúeBFa°
(
io
.
ªq
.
bôs
.
addr
, 
lgCacheBlockByãs
)

324 
vÆ
 
sdq_vÆ
 = 
	`Reg
(
öô
=
	`Bôs
(0, 
cfg
.
nSDQ
))

325 
vÆ
 
sdq_Æloc_id
 = 
	`Pri‹ôyEncodî
(~
	`sdq_vÆ
(
cfg
.
nSDQ
-1,0))

326 
vÆ
 
sdq_rdy
 = !
sdq_vÆ
.
™dR


327 
vÆ
 
sdq_íq
 = 
io
.
ªq
.
vÆid
 && io.ªq.
ªady
 && 
ˇchóbÀ
 && 
	`isWrôe
(io.ªq.
bôs
.
cmd
)

328 
vÆ
 
sdq
 = 
	`Mem
(
cfg
.
nSDQ
, 
io
.
ªq
.
bôs
.
d©a
)

329 
	`whí
 (
sdq_íq
Ë{ 
	`sdq
(
sdq_Æloc_id
Ë:
io
.
ªq
.
bôs
.
d©a
 }

331 
vÆ
 
idxM©ch
 = 
	`Wúe
(
	`Vec
(
cfg
.
nMSHRs
, 
	`Boﬁ
()))

332 
vÆ
 
ègLi°
 = 
	`Wúe
(
	`Vec
(
cfg
.
nMSHRs
, 
	`Bôs
(
width
 = 
ègBôs
)))

333 
vÆ
 
èg_m©ch
 = 
	`Mux1H
(
idxM©ch
, 
ègLi°
Ë==
io
.
ªq
.
bôs
.
addr
 >> 
u¡agBôs


335 
vÆ
 
wbTagLi°
 = 
	`Wúe
(
	`Vec
(
cfg
.
nMSHRs
, 
	`Bôs
()))

336 
vÆ
 
ªfûlMux
 = 
	`Wúe
(
	`Vec
(
cfg
.
nMSHRs
, 
√w
 
L1RefûlReq
))

337 
vÆ
 
mëa_ªad_¨b
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
L1MëaRódReq
, 
cfg
.
nMSHRs
))

338 
vÆ
 
mëa_wrôe_¨b
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
L1MëaWrôeReq
, 
cfg
.
nMSHRs
))

339 
vÆ
 
wb_ªq_¨b
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
	`WrôebackReq
(
edge
.
bundÀ
), 
cfg
.
nMSHRs
))

340 
vÆ
 
ª∂ay_¨b
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
RïœyI¡î«l
, 
cfg
.
nMSHRs
))

341 
vÆ
 
Æloc_¨b
 = 
	`ModuÀ
(
√w
 
	`Arbôî
(
	`Boﬁ
(), 
cfg
.
nMSHRs
))

343 
v¨
 
idx_m©ch
 = 
	`Boﬁ
(
Ál£
)

344 
v¨
 
¥i_rdy
 = 
	`Boﬁ
(
Ál£
)

345 
v¨
 
£c_rdy
 = 
	`Boﬁ
(
Ál£
)

347 
io
.
„n˚_rdy
 :
åue


348 
io
.
¥obe_rdy
 :
åue


350 
vÆ
 
mshrs
 = (0 
u¡û
 
cfg
.
nMSHRs
Ë
m≠
 { 
i
 =>

351 
vÆ
 
mshr
 = 
	`ModuÀ
(
√w
 
	`MSHR
(
i
))

353 
	`idxM©ch
(
i
Ë:
mshr
.
io
.
idx_m©ch


354 
	`ègLi°
(
i
Ë:
mshr
.
io
.
èg


355 
	`wbTagLi°
(
i
Ë:
mshr
.
io
.
wb_ªq
.
bôs
.
èg


357 
Æloc_¨b
.
io
.
	`ö
(
i
).
vÆid
 :
mshr
.io.
ªq_¥i_rdy


358 
mshr
.
io
.
ªq_¥i_vÆ
 :
Æloc_¨b
.io.
	`ö
(
i
).
ªady


360 
mshr
.
io
.
ªq_£c_vÆ
 :io.
ªq
.
vÆid
 && 
sdq_rdy
 && 
èg_m©ch


361 
mshr
.
io
.
ªq_bôs
 :io.
ªq
.
bôs


362 
mshr
.
io
.
ªq_bôs
.
sdq_id
 :
sdq_Æloc_id


364 
mëa_ªad_¨b
.
io
.
	`ö
(
i
Ë<> 
mshr
.io.
mëa_ªad


365 
mëa_wrôe_¨b
.
io
.
	`ö
(
i
Ë<> 
mshr
.io.
mëa_wrôe


366 
wb_ªq_¨b
.
io
.
	`ö
(
i
Ë<> 
mshr
.io.
wb_ªq


367 
ª∂ay_¨b
.
io
.
	`ö
(
i
Ë<> 
mshr
.io.
ª∂ay


369 
mshr
.
io
.
mem_gø¡
.
vÆid
 :io.mem_gø¡.vÆid && io.mem_gø¡.
bôs
.
sour˚
 ==
	`UI¡
(
i
)

370 
mshr
.
io
.
mem_gø¡
.
bôs
 := io.mem_grant.bits

371 
	`ªfûlMux
(
i
Ë:
mshr
.
io
.
ªfûl


373 
¥i_rdy
 =Öri_rdy || 
mshr
.
io
.
ªq_¥i_rdy


374 
£c_rdy
 = sec_rdy || 
mshr
.
io
.
ªq_£c_rdy


375 
idx_m©ch
 = idx_m©ch || 
mshr
.
io
.idx_match

377 
	`whí
 (!
mshr
.
io
.
ªq_¥i_rdy
Ë{ io.
„n˚_rdy
 :
Ál£
 }

378 
	`whí
 (!
mshr
.
io
.
¥obe_rdy
Ë{ io.¥obe_rdy :
Ál£
 }

380 
mshr


384 
Æloc_¨b
.
io
.
out
.
ªady
 :io.
ªq
.
vÆid
 && 
sdq_rdy
 && 
ˇchóbÀ
 && !
idx_m©ch


386 
io
.
mëa_ªad
 <> 
mëa_ªad_¨b
.io.
out


387 
io
.
mëa_wrôe
 <> 
mëa_wrôe_¨b
.io.
out


388 
io
.
wb_ªq
 <> 
wb_ªq_¨b
.io.
out


390 
vÆ
 
mmio_Æloc_¨b
 = 
	`ModuÀ
(
√w
 
	`Arbôî
(
	`Boﬁ
(), 
nIOMSHRs
))

391 
vÆ
 
ª•_¨b
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
HñœCacheRe•
, 
nIOMSHRs
))

393 
v¨
 
mmio_rdy
 = 
	`Boﬁ
(
Ál£
)

394 
io
.
ª∂ay_√xt
 :
	`Boﬁ
(
Ál£
)

396 
vÆ
 
mmios
 = (0 
u¡û
 
nIOMSHRs
Ë
m≠
 { 
i
 =>

397 
vÆ
 
id
 = 
cfg
.
nMSHRs
 + 
i


398 
vÆ
 
mshr
 = 
	`ModuÀ
(
√w
 
	`IOMSHR
(
id
))

400 
mmio_Æloc_¨b
.
io
.
	`ö
(
i
).
vÆid
 :
mshr
.io.
ªq
.
ªady


401 
mshr
.
io
.
ªq
.
vÆid
 :
mmio_Æloc_¨b
.io.
	`ö
(
i
).
ªady


402 
mshr
.
io
.
ªq
.
bôs
 := io.req.bits

404 
mmio_rdy
 = mmio_rdy || 
mshr
.
io
.
ªq
.
ªady


406 
mshr
.
io
.
mem_ack
.
bôs
 :io.
mem_gø¡
.bits

407 
mshr
.
io
.
mem_ack
.
vÆid
 :io.
mem_gø¡
.vÆid && io.mem_gø¡.
bôs
.
sour˚
 ==
	`UI¡
(
id
)

409 
ª•_¨b
.
io
.
	`ö
(
i
Ë<> 
mshr
.io.
ª•


411 
	`whí
 (!
mshr
.
io
.
ªq
.
ªady
Ë{ io.
„n˚_rdy
 :
	`Boﬁ
(
Ál£
) }

412 
	`whí
 (
mshr
.
io
.
ª∂ay_√xt
Ë{ io.ª∂ay_√xà:
	`Boﬁ
(
åue
) }

414 
mshr


417 
mmio_Æloc_¨b
.
io
.
out
.
ªady
 :io.
ªq
.
vÆid
 && !
ˇchóbÀ


419 
TLArbôî
.
	`lowe°FromSeq
(
edge
, 
io
.
mem_acquúe
, 
mshrs
.
	`m≠
(
_
.io.mem_acquúeË++ 
mmios
.m≠(_.io.
mem_ac˚ss
))

420 
TLArbôî
.
	`lowe°FromSeq
(
edge
, 
io
.
mem_föish
, 
mshrs
.
	`m≠
(
_
.io.mem_finish))

422 
io
.
ª•
 <> 
ª•_¨b
.io.
out


423 
io
.
ªq
.
ªady
 :
	`Mux
(!
ˇchóbÀ
,

424 
mmio_rdy
,

425 
sdq_rdy
 && 
	`Mux
(
idx_m©ch
, 
èg_m©ch
 && 
£c_rdy
, 
¥i_rdy
))

426 
io
.
£c⁄d¨y_miss
 :
idx_m©ch


427 
io
.
ªfûl
 :
	`ªfûlMux
(io.
mem_gø¡
.
bôs
.
sour˚
)

429 
vÆ
 
‰ì_sdq
 = 
io
.
ª∂ay
.
	`fúe
(Ë&& 
	`isWrôe
(io.ª∂ay.
bôs
.
cmd
)

430 
io
.
ª∂ay
.
bôs
.
d©a
 :
	`sdq
(
	`RegE«bÀ
(
ª∂ay_¨b
.io.
out
.bôs.
sdq_id
, 
‰ì_sdq
))

431 
io
.
ª∂ay
 <> 
ª∂ay_¨b
.io.
out


433 
	`whí
 (
io
.
ª∂ay
.
vÆid
 || 
sdq_íq
) {

434 
sdq_vÆ
 :sdq_vÆ & ~(
	`UI¡ToOH
(
ª∂ay_¨b
.
io
.
out
.
bôs
.
sdq_id
Ë& 
	`Fûl
(
cfg
.
nSDQ
, 
‰ì_sdq
)) |

435 
	`Pri‹ôyEncodîOH
(~
	`sdq_vÆ
(
cfg
.
nSDQ
-1,0)Ë& 
	`Fûl
(cfg.nSDQ, 
sdq_íq
)

437 
	}
}

439 
˛ass
 
	$WrôebackUnô
(
im∂icô
 
edge
: 
TLEdgeOut
, 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

440 
vÆ
 
io
 = 
√w
 
BundÀ
 {

441 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
	`WrôebackReq
(
edge
.
bundÀ
)).
Êù


442 
vÆ
 
mëa_ªad
 = 
	`Decou∂ed
(
√w
 
L1MëaRódReq
)

443 
vÆ
 
d©a_ªq
 = 
	`Decou∂ed
(
√w
 
L1D©aRódReq
)

444 
vÆ
 
d©a_ª•
 = 
	`Bôs
(
INPUT
, 
ícRowBôs
)

445 
vÆ
 
ªÀa£
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀC
(
edge
.
bundÀ
))

448 
vÆ
 
ªq
 = 
	`Reg
(
√w
 
	`WrôebackReq
(
edge
.
bundÀ
))

449 
vÆ
 
a˘ive
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

450 
vÆ
 
r1_d©a_ªq_fúed
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

451 
vÆ
 
r2_d©a_ªq_fúed
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

452 
vÆ
 
d©a_ªq_˙t
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
width
 = 
	`log2Up
(
ªfûlCy˛es
+1)))

453 
	`vÆ
 (
_
, 
œ°_bót
, 
Æl_bóts_d⁄e
, 
bót_cou¡
Ë
edge
.
	`cou¡
(
io
.
ªÀa£
)

455 
io
.
ªÀa£
.
vÆid
 :
Ál£


456 
	`whí
 (
a˘ive
) {

457 
r1_d©a_ªq_fúed
 :
Ál£


458 
r2_d©a_ªq_fúed
 :
r1_d©a_ªq_fúed


459 
	`whí
 (
io
.
d©a_ªq
.
	`fúe
(Ë&& io.
mëa_ªad
.fire()) {

460 
r1_d©a_ªq_fúed
 :
åue


461 
d©a_ªq_˙t
 := data_req_cnt + 1

463 
	`whí
 (
r2_d©a_ªq_fúed
) {

464 
io
.
ªÀa£
.
vÆid
 :
åue


465 
	`whí
(!
io
.
ªÀa£
.
ªady
) {

466 
r1_d©a_ªq_fúed
 :
Ál£


467 
r2_d©a_ªq_fúed
 :
Ál£


468 
d©a_ªq_˙t
 :d©a_ªq_˙à- 
Mux
[
UI¡
](
	`Boﬁ
(
ªfûlCy˛es
 > 1Ë&& 
r1_d©a_ªq_fúed
, 2, 1)

470 
	`whí
(!
r1_d©a_ªq_fúed
) {

472 
a˘ive
 :
d©a_ªq_˙t
 < 
	`UI¡
(
ªfûlCy˛es
Ë|| !
io
.
ªÀa£
.
ªady


476 
	`whí
 (
io
.
ªq
.
	`fúe
()) {

477 
a˘ive
 :
åue


478 
d©a_ªq_˙t
 := 0

479 
ªq
 :
io
.ªq.
bôs


482 
io
.
ªq
.
ªady
 :!
a˘ive


484 
vÆ
 
fúe
 = 
a˘ive
 && 
d©a_ªq_˙t
 < 
	`UI¡
(
ªfûlCy˛es
)

487 
io
.
mëa_ªad
.
vÆid
 :
fúe


488 
io
.
mëa_ªad
.
bôs
.
idx
 :
ªq
.idx

489 
io
.
mëa_ªad
.
bôs
.
èg
 :
ªq
.tag

491 
io
.
d©a_ªq
.
vÆid
 :
fúe


492 
io
.
d©a_ªq
.
bôs
.
way_í
 :
ªq
.way_en

493 
io
.
d©a_ªq
.
bôs
.
addr
 :(if(
ªfûlCy˛es
 > 1)

494 
	`C©
(
ªq
.
idx
, 
	`d©a_ªq_˙t
(
	`log2Up
(
ªfûlCy˛es
)-1,0))

495 
ªq
.
idx
Ë<< 
rowOffBôs


497 
vÆ
 
r_addªss
 = 
	`C©
(
ªq
.
èg
,Ñeq.
idx
Ë<< 
blockOffBôs


498 
vÆ
 
¥obeRe•⁄£
 = 
edge
.
	`ProbeAck
(

499 
‰omSour˚
 = 
ªq
.
sour˚
,

500 
toAddªss
 = 
r_addªss
,

501 
lgSize
 = 
lgCacheBlockByãs
,

502 
ªp‹tPîmissi⁄s
 = 
ªq
.
∑øm
,

503 
d©a
 = 
io
.
d©a_ª•
)

505 
vÆ
 
vﬁu¡¨yRñó£
 = 
edge
.
	`Rñó£
(

506 
‰omSour˚
 = 
ªq
.
sour˚
,

507 
toAddªss
 = 
r_addªss
,

508 
lgSize
 = 
lgCacheBlockByãs
,

509 
shrökPîmissi⁄s
 = 
ªq
.
∑øm
,

510 
d©a
 = 
io
.
d©a_ª•
).
_2


512 
io
.
ªÀa£
.
bôs
 :
	`Mux
(
ªq
.
vﬁu¡¨y
, 
vﬁu¡¨yRñó£
, 
¥obeRe•⁄£
)

513 
	}
}

515 
˛ass
 
	$ProbeUnô
(
im∂icô
 
edge
: 
TLEdgeOut
, 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

516 
vÆ
 
io
 = 
√w
 
BundÀ
 {

517 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀB
(
edge
.
bundÀ
)).
Êù


518 
vÆ
 
ªp
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀC
(
edge
.
bundÀ
))

519 
vÆ
 
mëa_ªad
 = 
	`Decou∂ed
(
√w
 
L1MëaRódReq
)

520 
vÆ
 
mëa_wrôe
 = 
	`Decou∂ed
(
√w
 
L1MëaWrôeReq
)

521 
vÆ
 
wb_ªq
 = 
	`Decou∂ed
(
√w
 
	`WrôebackReq
(
edge
.
bundÀ
))

522 
vÆ
 
way_í
 = 
	`Bôs
(
INPUT
, 
nWays
)

523 
vÆ
 
mshr_rdy
 = 
	`Boﬁ
(
INPUT
)

524 
vÆ
 
block_°©e
 = 
√w
 
	`Clõ¡Mëad©a
().
asI≈ut


527 
	`vÆ
 (
s_övÆid
 :: 
s_mëa_ªad
 :: 
s_mëa_ª•
 :: 
s_mshr_ªq
 ::

528 
s_mshr_ª•
 :: 
s_ªÀa£
 :: 
s_wrôeback_ªq
 :: 
s_wrôeback_ª•
 ::

529 
s_mëa_wrôe
 :: 
Nû
Ë
	`Enum
(
	`UI¡
(), 9)

530 
vÆ
 
°©e
 = 
	`Reg
(
öô
=
s_övÆid
)

532 
vÆ
 
ªq
 = 
	`Reg
(
√w
 
	`TLBundÀB
(
edge
.
bundÀ
))

533 
vÆ
 
ªq_idx
 = 
ªq
.
	`addªss
(
idxMSB
, 
idxLSB
)

534 
vÆ
 
ªq_èg
 = 
ªq
.
addªss
 >> 
u¡agBôs


536 
vÆ
 
way_í
 = 
	`Reg
(
	`Bôs
())

537 
vÆ
 
èg_m©ches
 = 
way_í
.
‹R


538 
vÆ
 
ﬁd_coh
 = 
	`Reg
(
√w
 
Clõ¡Mëad©a
)

539 
vÆ
 
miss_coh
 = 
Clõ¡Mëad©a
.
⁄Re£t


540 
vÆ
 
ª∂y_coh
 = 
	`Mux
(
èg_m©ches
, 
ﬁd_coh
, 
miss_coh
)

541 
	`vÆ
 (
is_dúty
, 
ªp‹t_∑øm
, 
√w_coh
Ë
ª∂y_coh
.
	`⁄Probe
(
ªq
.
∑øm
)

543 
io
.
ªq
.
ªady
 :
°©e
 ==
s_övÆid


544 
io
.
ªp
.
vÆid
 :
°©e
 ==
s_ªÀa£


545 
io
.
ªp
.
bôs
 :
edge
.
	`ProbeAck
(
ªq
, 
ªp‹t_∑øm
)

547 
	`as£π
(!
io
.
ªp
.
vÆid
 || !
edge
.
	`hasD©a
(io.ªp.
bôs
),

550 
io
.
mëa_ªad
.
vÆid
 :
°©e
 ==
s_mëa_ªad


551 
io
.
mëa_ªad
.
bôs
.
idx
 :
ªq_idx


552 
io
.
mëa_ªad
.
bôs
.
èg
 :
ªq_èg


554 
io
.
mëa_wrôe
.
vÆid
 :
°©e
 ==
s_mëa_wrôe


555 
io
.
mëa_wrôe
.
bôs
.
way_í
 := way_en

556 
io
.
mëa_wrôe
.
bôs
.
idx
 :
ªq_idx


557 
io
.
mëa_wrôe
.
bôs
.
d©a
.
èg
 :
ªq_èg


558 
io
.
mëa_wrôe
.
bôs
.
d©a
.
coh
 :
√w_coh


560 
io
.
wb_ªq
.
vÆid
 :
°©e
 ==
s_wrôeback_ªq


561 
io
.
wb_ªq
.
bôs
.
sour˚
 :
ªq
.source

562 
io
.
wb_ªq
.
bôs
.
idx
 :
ªq_idx


563 
io
.
wb_ªq
.
bôs
.
èg
 :
ªq_èg


564 
io
.
wb_ªq
.
bôs
.
∑øm
 :
ªp‹t_∑øm


565 
io
.
wb_ªq
.
bôs
.
way_í
 := way_en

566 
io
.
wb_ªq
.
bôs
.
vﬁu¡¨y
 :
	`Boﬁ
(
Ál£
)

569 
	`whí
 (
io
.
ªq
.
	`fúe
()) {

570 
°©e
 :
s_mëa_ªad


571 
ªq
 :
io
.ªq.
bôs


575 
	`whí
 (
io
.
mëa_ªad
.
	`fúe
()) {

576 
°©e
 :
s_mëa_ª•


580 
	`whí
 (
°©e
 ==
s_mëa_ª•
) {

581 
°©e
 :
s_mshr_ªq


584 
	`whí
 (
°©e
 ==
s_mshr_ªq
) {

585 
ﬁd_coh
 :
io
.
block_°©e


586 
way_í
 :
io
.way_en

588 
°©e
 :
	`Mux
(
io
.
mshr_rdy
, 
s_mshr_ª•
, 
s_mëa_ªad
)

591 
	`whí
 (
°©e
 ==
s_mshr_ª•
) {

592 
°©e
 :
	`Mux
(
èg_m©ches
 && 
is_dúty
, 
s_wrôeback_ªq
, 
s_ªÀa£
)

595 
	`whí
 (
°©e
 ==
s_ªÀa£
 && 
io
.
ªp
.
ªady
) {

596 
°©e
 :
	`Mux
(
èg_m©ches
, 
s_mëa_wrôe
, 
s_övÆid
)

600 
	`whí
 (
io
.
wb_ªq
.
	`fúe
()) {

601 
°©e
 :
s_wrôeback_ª•


605 
	`whí
 (
°©e
 ==
s_wrôeback_ª•
 && 
io
.
wb_ªq
.
ªady
) {

606 
°©e
 :
s_mëa_wrôe


609 
	`whí
 (
io
.
mëa_wrôe
.
	`fúe
()) {

610 
°©e
 :
s_övÆid


612 
	}
}

614 ˛as†
	cD©aAºay
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$L1HñœCacheModuÀ
()(
p
) {

615 
vÆ
 
io
 = 
√w
 
BundÀ
 {

616 
vÆ
 
ªad
 = 
	`Decou∂ed
(
√w
 
L1D©aRódReq
).
Êù


617 
vÆ
 
wrôe
 = 
	`Decou∂ed
(
√w
 
L1D©aWrôeReq
).
Êù


618 
vÆ
 
ª•
 = 
	`Vec
(
nWays
, 
	`Bôs
(
OUTPUT
, 
ícRowBôs
))

621 
vÆ
 
waddr
 = 
io
.
wrôe
.
bôs
.
addr
 >> 
rowOffBôs


622 
vÆ
 
øddr
 = 
io
.
ªad
.
bôs
.
addr
 >> 
rowOffBôs


624 i‡(
doN¨rowRód
) {

625 
w
 <- 0 
u¡û
 
nWays
 
by
 
rowW‹ds
) {

626 
vÆ
 
wway_í
 = 
io
.
wrôe
.
bôs
.
	`way_í
(
w
+
rowW‹ds
-1,w)

627 
vÆ
 
rway_í
 = 
io
.
ªad
.
bôs
.
	`way_í
(
w
+
rowW‹ds
-1,w)

628 
vÆ
 
ª•
 = 
	`Wúe
(
	`Vec
(
rowW‹ds
, 
	`Bôs
(
width
 = 
ícRowBôs
)))

629 
vÆ
 
r_øddr
 = 
	`RegE«bÀ
(
io
.
ªad
.
bôs
.
addr
, io.ªad.
vÆid
)

630 
i
 <- 0 
u¡û
 
ª•
.
size
) {

631 
vÆ
 
¨øy
 = 
	`Des¸ibedSRAM
(

632 
«me
 = 
s
"array_${w}_${i}",

633 
desc
 = "Non-blocking DCache Data Array",

634 
size
 = 
nSës
 * 
ªfûlCy˛es
,

635 
d©a
 = 
	`Vec
(
rowW‹ds
, 
	`Bôs
(
width
=
ícD©aBôs
))

637 
	`whí
 (
wway_í
.
‹R
 && 
io
.
wrôe
.
vÆid
 && io.wrôe.
bôs
.
	`wmask
(
i
)) {

638 
vÆ
 
d©a
 = 
Vec
.
	`fûl
(
rowW‹ds
)(
io
.
wrôe
.
bôs
.
	`d©a
(
ícD©aBôs
*(
i
+1)-1,encDataBits*i))

639 
¨øy
.
	`wrôe
(
waddr
, 
d©a
, 
wway_í
.
toBoﬁs
)

641 
	`ª•
(
i
Ë:
¨øy
.
	`ªad
(
øddr
, 
rway_í
.
‹R
 && 
io
.
ªad
.
vÆid
).
asUI¡


643 
dw
 <- 0 
u¡û
 
rowW‹ds
) {

644 
vÆ
 
r
 = 
	`Vec
(
ª•
.
	`m≠
(
	`_
(
ícD©aBôs
*(
dw
+1)-1,encDataBits*dw)))

645 
vÆ
 
ª•_mux
 =

646 i‡(
r
.
size
 == 1)Ñ

647 
	`Vec
(
	`r
(
	`r_øddr
(
rowOffBôs
-1,
w‹dOffBôs
)), 
r
.
èû
:
_
*)

648 
io
.
	`ª•
(
w
+
dw
Ë:
ª•_mux
.
asUI¡


651 
	}
} {

652 
w
 <- 0 
u¡û
 
nWays
) {

653 
vÆ
 
¨øy
 = 
Des¸ibedSRAM
(

654 
«me
 = 
s
"array_${w}",

655 
desc
 = "Non-blocking DCache Data Array",

656 
size
 = 
nSës
 * 
ªfûlCy˛es
,

657 
d©a
 = 
Vec
(
rowW‹ds
, 
Bôs
(
width
=
ícD©aBôs
))

659 
whí
 (
io
.
wrôe
.
bôs
.
way_í
(
w
Ë&& io.wrôe.
vÆid
) {

660 
vÆ
 
d©a
 = 
Vec
.
èbuœã
(
rowW‹ds
)(
i
 => 
io
.
wrôe
.
bôs
.d©a(
ícD©aBôs
*(i+1)-1,encDataBits*i))

661 
	g¨øy
.
wrôe
(
waddr
, 
d©a
, 
io
.wrôe.
bôs
.
wmask
.
toBoﬁs
)

663 
	gio
.
ª•
(
w
Ë:
¨øy
.
ªad
(
øddr
, 
io
.ªad.
bôs
.
way_í
(wË&& io.ªad.
vÆid
).
	gasUI¡


667 
	gio
.
	gªad
.
	gªady
 :
	$Boﬁ
(
åue
)

668 
io
.
wrôe
.
ªady
 :
	`Boﬁ
(
åue
)

669 
	}
}

671 ˛as†
	cN⁄BlockögDCache
(
h¨tid
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$HñœCache
(
h¨tid
)(
p
) {

672 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`N⁄BlockögDCacheModuÀ
(
this
)

675 ˛as†
	cN⁄BlockögDCacheModuÀ
(
ouãr
: 
N⁄BlockögDCache
Ë
exãnds
 
	$HñœCacheModuÀ
(
ouãr
) {

677 
	`ªquúe
(
	$isPow2
(
nWays
))

678 
	$ªquúe
(
d©aS¸©ch∑dSize
 == 0)

679 
	`ªquúe
(!
usögVM
 || 
u¡agBôs
 <
pgIdxBôs
, 
s
"untagBits($untagBits) >ÖgIdxBits($pgIdxBits)")

682 
	$ªquúe
(
ˇcheP¨ams
.
ègCode
.
isIn°™˚Of
[
IdítôyCode
])

683 
vÆ
 
dECC
 = 
ˇcheP¨ams
.
d©aCode


685 
vÆ
 
wb
 = 
	$ModuÀ
(
√w
 
WrôebackUnô
)

686 
vÆ
 
¥obî
 = 
	$ModuÀ
(
√w
 
ProbeUnô
)

687 
vÆ
 
mshrs
 = 
	$ModuÀ
(
√w
 
MSHRFûe
)

689 
io
.
˝u
.
ªq
.
ªady
 :
	$Boﬁ
(
åue
)

690 
vÆ
 
s1_vÆid
 = 
	`Reg
(
√xt
=
io
.
˝u
.
ªq
.
	`fúe
(), 
öô
=
	$Boﬁ
(
Ál£
))

691 
vÆ
 
s1_ªq
 = 
	$Reg
(
io
.
˝u
.
ªq
.
bôs
)

692 
vÆ
 
s1_vÆid_masked
 = 
s1_vÆid
 && !
io
.
˝u
.
s1_kûl


693 
vÆ
 
s1_ª∂ay
 = 
	`Reg
(
öô
=
	$Boﬁ
(
Ál£
))

694 
vÆ
 
s1_˛k_í
 = 
	`Reg
(
	$Boﬁ
())

695 
vÆ
 
s1_s„n˚
 = 
s1_ªq
.
cmd
 ==
M_SFENCE


697 
vÆ
 
s2_vÆid
 = 
	`Reg
(
√xt
=
s1_vÆid_masked
 && !
s1_s„n˚
, 
öô
=
	`Boﬁ
(
Ál£
)Ë&& !
io
.
˝u
.
s2_x˝t
.
asUI¡
.
‹R


698 
vÆ
 
s2_ªq
 = 
	$Reg
(
io
.
˝u
.
ªq
.
bôs
)

699 
vÆ
 
s2_ª∂ay
 = 
	`Reg
(
√xt
=
s1_ª∂ay
, 
öô
=
	`Boﬁ
(
Ál£
)Ë&& 
s2_ªq
.
cmd
 =/
M_FLUSH_ALL


700 
vÆ
 
s2_ªcy˛e
 = 
	`Wúe
(
	$Boﬁ
())

701 
vÆ
 
s2_vÆid_masked
 = 
	`Wúe
(
	$Boﬁ
())

703 
vÆ
 
s3_vÆid
 = 
	`Reg
(
öô
=
	$Boﬁ
(
Ál£
))

704 
vÆ
 
s3_ªq
 = 
	$Reg
(
io
.
˝u
.
ªq
.
bôs
)

705 
vÆ
 
s3_way
 = 
	`Reg
(
	$Bôs
())

707 
vÆ
 
s1_ªcy˛ed
 = 
	`RegE«bÀ
(
s2_ªcy˛e
, 
	`Boﬁ
(
Ál£
), 
s1_˛k_í
)

708 
vÆ
 
s1_ªad
 = 
	$isRód
(
s1_ªq
.
cmd
)

709 
vÆ
 
s1_wrôe
 = 
	$isWrôe
(
s1_ªq
.
cmd
)

710 
vÆ
 
s1_ªadwrôe
 = 
s1_ªad
 || 
s1_wrôe
 || 
	$isPª„tch
(
s1_ªq
.
cmd
)

712 
	`as£π
(!
s1_vÆid
 || !
s1_ªq
.
cmd
.
	$isO√Of
(
M_PWR
))

714 
vÆ
 
déb
 = 
	`ModuÀ
(
√w
 
	`TLB
(
Ál£
, 
	`log2Ceû
(
c‹eD©aByãs
), 
	$TLBC⁄fig
(
nTLBE¡rõs
)))

715 
io
.
±w
 <> 
déb
.io.ptw

716 
déb
.
io
.
kûl
 :io.
˝u
.
s2_kûl


717 
déb
.
io
.
ªq
.
vÆid
 :
s1_vÆid
 && !io.
˝u
.
s1_kûl
 && 
s1_ªadwrôe


718 
déb
.
io
.
ªq
.
bôs
.
∑s°hrough
 :
s1_ªq
.
phys


719 
déb
.
io
.
ªq
.
bôs
.
vaddr
 :
s1_ªq
.
addr


720 
déb
.
io
.
ªq
.
bôs
.
size
 :
s1_ªq
.
typ


721 
déb
.
io
.
ªq
.
bôs
.
cmd
 :
s1_ªq
.cmd

722 
	`whí
 (!
déb
.
io
.
ªq
.
ªady
 && !io.
˝u
.ªq.
bôs
.
phys
Ë{ io.˝u.ªq.ªady :
	`Boﬁ
(
Ál£
) }

724 
déb
.
io
.
s„n˚
.
vÆid
 :
s1_vÆid
 && !io.
˝u
.
s1_kûl
 && 
s1_s„n˚


725 
déb
.
io
.
s„n˚
.
bôs
.
rs1
 :
s1_ªq
.
	$typ
(0)

726 
déb
.
io
.
s„n˚
.
bôs
.
rs2
 :
s1_ªq
.
	$typ
(1)

727 
déb
.
io
.
s„n˚
.
bôs
.
addr
 :
s1_ªq
.addr

728 
déb
.
io
.
s„n˚
.
bôs
.
asid
 :io.
˝u
.
s1_d©a
.
d©a


730 
	$whí
 (
io
.
˝u
.
ªq
.
vÆid
) {

731 
s1_ªq
 :
io
.
˝u
.
ªq
.
bôs


732 
	}
}

733 
	$whí
 (
wb
.
io
.
mëa_ªad
.
vÆid
) {

734 
s1_ªq
.
addr
 :
	`C©
(
wb
.
io
.
mëa_ªad
.
bôs
.
èg
, wb.io.mëa_ªad.bôs.
idx
Ë<< 
blockOffBôs


735 
s1_ªq
.
phys
 :
	`Boﬁ
(
åue
)

736 
	}
}

737 
	$whí
 (
¥obî
.
io
.
mëa_ªad
.
vÆid
) {

738 
s1_ªq
.
addr
 :
	`C©
(
¥obî
.
io
.
mëa_ªad
.
bôs
.
èg
,Örobî.io.mëa_ªad.bôs.
idx
Ë<< 
blockOffBôs


739 
s1_ªq
.
phys
 :
	`Boﬁ
(
åue
)

740 
	}
}

741 
	$whí
 (
mshrs
.
io
.
ª∂ay
.
vÆid
) {

742 
s1_ªq
 :
mshrs
.
io
.
ª∂ay
.
bôs


743 
	}
}

744 
	$whí
 (
s2_ªcy˛e
) {

745 
s1_ªq
 :
s2_ªq


746 
	}
}

747 
vÆ
 
s1_addr
 = 
déb
.
io
.
ª•
.
∑ddr


749 
	$whí
 (
s1_˛k_í
) {

750 
s2_ªq
.
typ
 :
s1_ªq
.typ

751 
s2_ªq
.
phys
 :
s1_ªq
.phys

752 
s2_ªq
.
addr
 :
s1_addr


753 
	`whí
 (
s1_wrôe
) {

754 
s2_ªq
.
d©a
 :
	`Mux
(
s1_ª∂ay
, 
mshrs
.
io
.
ª∂ay
.
bôs
.d©a, io.
˝u
.
s1_d©a
.data)

756 
	`whí
 (
s1_ªcy˛ed
Ë{ 
s2_ªq
.
d©a
 :
s1_ªq
.data }

757 
s2_ªq
.
èg
 :
s1_ªq
.tag

758 
s2_ªq
.
cmd
 :
s1_ªq
.cmd

759 
	}
}

762 
def
 
⁄Re£t
 = 
L1Mëad©a
(
UI¡
(0), 
Clõ¡Mëad©a
.onReset)

763 
vÆ
 
	gmëa
 = 
ModuÀ
(
√w
 
	$L1Mëad©aAºay
(
⁄Re£t
 
_
))

764 
vÆ
 
mëaRódArb
 = 
	`ModuÀ
(
√w
 
	$Arbôî
(
√w
 
L1MëaRódReq
, 5))

765 
vÆ
 
mëaWrôeArb
 = 
	`ModuÀ
(
√w
 
	$Arbôî
(
√w
 
L1MëaWrôeReq
, 2))

766 
mëa
.
io
.
ªad
 <> 
mëaRódArb
.io.
out


767 
mëa
.
io
.
wrôe
 <> 
mëaWrôeArb
.io.
out


770 
vÆ
 
d©a
 = 
	$ModuÀ
(
√w
 
D©aAºay
)

771 
vÆ
 
ªadArb
 = 
	`ModuÀ
(
√w
 
	$Arbôî
(
√w
 
L1D©aRódReq
, 4))

772 
vÆ
 
wrôeArb
 = 
	`ModuÀ
(
√w
 
	$Arbôî
(
√w
 
L1D©aWrôeReq
, 2))

773 
d©a
.
io
.
wrôe
.
vÆid
 :
wrôeArb
.io.
out
.valid

774 
wrôeArb
.
io
.
out
.
ªady
 :
d©a
.io.
wrôe
.ready

775 
d©a
.
io
.
wrôe
.
bôs
 :
wrôeArb
.io.
out
.bits

776 
vÆ
 
wd©a_ícoded
 = (0 
u¡û
 
rowW‹ds
).
	`m≠
(
i
 => 
dECC
.
	`ícode
(
wrôeArb
.
io
.
out
.
bôs
.
	`d©a
(
c‹eD©aBôs
*(i+1)-1,coreDataBits*i)))

777 
d©a
.
io
.
wrôe
.
bôs
.d©®:
wd©a_ícoded
.
asUI¡


780 
mëaRódArb
.
io
.
	`ö
(4).
vÆid
 :io.
˝u
.
ªq
.valid

781 
mëaRódArb
.
io
.
	`ö
(4).
bôs
.
idx
 :io.
˝u
.
ªq
.bôs.
addr
 >> 
blockOffBôs


782 
	`whí
 (!
mëaRódArb
.
io
.
	`ö
(4).
ªady
Ë{ io.
˝u
.
ªq
.ªady :
	`Boﬁ
(
Ál£
Ë
	}
}

785 
ªadArb
.
io
.
ö
(3).
vÆid
 :io.
˝u
.
ªq
.valid

786 
ªadArb
.
io
.
ö
(3).
bôs
.
addr
 :io.
˝u
.
ªq
.bits.addr

787 
ªadArb
.
io
.
ö
(3).
bôs
.
way_í
 :~
	$UI¡
(0, 
nWays
)

788 
	`whí
 (!
ªadArb
.
io
.
	`ö
(3).
ªady
Ë{ io.
˝u
.
ªq
.ªady :
	`Boﬁ
(
Ál£
Ë
	}
}

791 
mëaRódArb
.
io
.
ö
(0).
vÆid
 :
s2_ªcy˛e


792 
mëaRódArb
.
io
.
ö
(0).
bôs
.
idx
 :
s2_ªq
.
addr
 >> 
blockOffBôs


793 
ªadArb
.
io
.
ö
(0).
vÆid
 :
s2_ªcy˛e


794 
ªadArb
.
io
.
ö
(0).
bôs
.
addr
 :
s2_ªq
.addr

795 
ªadArb
.
io
.
ö
(0).
bôs
.
way_í
 :~
	$UI¡
(0, 
nWays
)

798 
def
 
wayM≠
[
T
 <: 
D©a
](
f
: 
I¡
 => TË
	`Vec
((0 
u¡û
 
nWays
).
	$m≠
(
f
))

799 
vÆ
 
s1_èg_eq_way
 = 
	`wayM≠
((
w
: 
I¡
Ë=> 
mëa
.
io
.
	`ª•
(w).
èg
 ==(
s1_addr
 >> 
u¡agBôs
)).
asUI¡


800 
vÆ
 
s1_èg_m©ch_way
 = 
	`wayM≠
((
w
: 
I¡
Ë=> 
	`s1_èg_eq_way
(wË&& 
mëa
.
io
.
	`ª•
(w).
coh
.
	`isVÆid
()).
asUI¡


801 
s1_˛k_í
 :
mëaRódArb
.
io
.
out
.
vÆid


802 
vÆ
 
s1_wrôeback
 = 
s1_˛k_í
 && !
s1_vÆid
 && !
s1_ª∂ay


803 
vÆ
 
s2_èg_m©ch_way
 = 
	$RegE«bÀ
(
s1_èg_m©ch_way
, 
s1_˛k_í
)

804 
vÆ
 
s2_èg_m©ch
 = 
s2_èg_m©ch_way
.
‹R


805 
vÆ
 
s2_hô_°©e
 = 
	`Mux1H
(
s2_èg_m©ch_way
, 
	`wayM≠
((
w
: 
I¡
Ë=> 
	`RegE«bÀ
(
mëa
.
io
.
	`ª•
(w).
coh
, 
s1_˛k_í
)))

806 
	`vÆ
 (
s2_has_≥rmissi⁄
, 
_
, 
s2_√w_hô_°©e
Ë
s2_hô_°©e
.
	$⁄Ac˚ss
(
s2_ªq
.
cmd
)

807 
vÆ
 
s2_hô
 = 
s2_èg_m©ch
 && 
s2_has_≥rmissi⁄
 && 
s2_hô_°©e
 ==
s2_√w_hô_°©e


810 
vÆ
 
Ãsc_cou¡
 = 
	`Reg
(
öô
=
	$UI¡
(0))

811 
vÆ
 
Ãsc_vÆid
 = 
Ãsc_cou¡
 > 
ÃscBackoff


812 
vÆ
 
Ãsc_addr
 = 
	`Reg
(
	$UI¡
())

813 
	`vÆ
 (
s2_Ã
, 
s2_sc
Ë(
s2_ªq
.
cmd
 ==
M_XLR
, s2_ªq.cmd ==
M_XSC
)

814 
vÆ
 
s2_Ãsc_addr_m©ch
 = 
Ãsc_vÆid
 && 
Ãsc_addr
 ==(
s2_ªq
.
addr
 >> 
blockOffBôs
)

815 
vÆ
 
s2_sc_Áû
 = 
s2_sc
 && !
s2_Ãsc_addr_m©ch


816 
	`whí
 (
Ãsc_cou¡
 > 0Ë{Ürsc_cou¡ :Ãsc_cou¡ - 1 
	}
}

817 
whí
 (
s2_vÆid_masked
 && 
s2_hô
 || 
s2_ª∂ay
) {

818 
whí
 (
s2_Ã
) {

819 
Ãsc_cou¡
 :
ÃscCy˛es
 - 1

820 
Ãsc_addr
 :
s2_ªq
.
addr
 >> 
blockOffBôs


822 
whí
 (
Ãsc_cou¡
 > 0) {

823 
Ãsc_cou¡
 := 0

827 
vÆ
 
s2_d©a
 = 
Wúe
(
Vec
(
nWays
, 
	$Bôs
(
width
=
ícRowBôs
)))

828 
w
 <- 0 
u¡û
 
nWays
) {

829 
vÆ
 
ªgs
 = 
	`Reg
(
	`Vec
(
rowW‹ds
, 
	`Bôs
(
width
 = 
ícD©aBôs
)))

830 
vÆ
 
í1
 = 
s1_˛k_í
 && 
	`s1_èg_eq_way
(
w
)

831 
i
 <- 0 
u¡û
 
ªgs
.
size
) {

832 
vÆ
 
í
 = 
í1
 && ((
	`Boﬁ
(
i
 =0Ë|| !Boﬁ(
doN¨rowRód
)Ë|| 
s1_wrôeback
)

833 
	`whí
 (
í
Ë{ 
	`ªgs
(
i
Ë:
d©a
.
io
.
	`ª•
(
w
Ë>> 
ícD©aBôs
*i }

835 
	`s2_d©a
(
w
Ë:
ªgs
.
asUI¡


836 
	}
}

837 
vÆ
 
s2_d©a_muxed
 = 
	$Mux1H
(
s2_èg_m©ch_way
, 
s2_d©a
)

838 
vÆ
 
s2_d©a_decoded
 = (0 
u¡û
 
rowW‹ds
).
	`m≠
(
i
 => 
dECC
.
	`decode
(
	`s2_d©a_muxed
(
ícD©aBôs
*(i+1)-1,encDataBits*i)))

839 
vÆ
 
s2_d©a_c‹ª˘ed
 = 
s2_d©a_decoded
.
	`m≠
(
_
.
c‹ª˘ed
).
asUI¡


840 
vÆ
 
s2_d©a_unc‹ª˘ed
 = 
s2_d©a_decoded
.
	`m≠
(
_
.
unc‹ª˘ed
).
asUI¡


841 
vÆ
 
s2_w‹d_idx
 = if(
doN¨rowRód
Ë
	$UI¡
(0Ë
s2_ªq
.
	`addr
(
	`log2Up
(
rowW‹ds
*
c‹eD©aByãs
)-1,
	$log2Up
(
w‹dByãs
))

842 
vÆ
 
s2_d©a_c‹ª˘abÀ
 = 
s2_d©a_decoded
.
	`m≠
(
_
.
c‹ª˘abÀ
).
	$asUI¡
()(
s2_w‹d_idx
)

845 
s3_vÆid
 :(
s2_vÆid_masked
 && 
s2_hô
 || 
s2_ª∂ay
Ë&& !
s2_sc_Áû
 && 
	$isWrôe
(
s2_ªq
.
cmd
)

846 
vÆ
 
amﬂlu
 = 
	`ModuÀ
(
√w
 
	$AMOALU
(
xLí
))

847 
	`whí
 ((
s2_vÆid
 || 
s2_ª∂ay
Ë&& (
	`isWrôe
(
s2_ªq
.
cmd
Ë|| 
s2_d©a_c‹ª˘abÀ
)) {

848 
s3_ªq
 :
s2_ªq


849 
s3_ªq
.
d©a
 :
	`Mux
(
s2_d©a_c‹ª˘abÀ
, 
s2_d©a_c‹ª˘ed
, 
amﬂlu
.
io
.
out
)

850 
s3_way
 :
s2_èg_m©ch_way


851 
	}
}

853 
wrôeArb
.
io
.
ö
(0).
bôs
.
addr
 :
s3_ªq
.addr

854 
wrôeArb
.
io
.
ö
(0).
bôs
.
wmask
 :
UI¡ToOH
(
s3_ªq
.
addr
.
exåa˘
(
rowOffBôs
-1,
off£ésb
))

855 
	gwrôeArb
.
	gio
.
ö
(0).
	gbôs
.
	gd©a
 :
	$Fûl
(
rowW‹ds
, 
s3_ªq
.
d©a
)

856 
wrôeArb
.
io
.
	`ö
(0).
vÆid
 :
s3_vÆid


857 
wrôeArb
.
io
.
	`ö
(0).
bôs
.
way_í
 :
s3_way


860 
vÆ
 
ª∂a˚r
 = 
ˇcheP¨ams
.
ª∂a˚mít


861 
vÆ
 
s1_ª∂a˚d_way_í
 = 
	$UI¡ToOH
(
ª∂a˚r
.
way
)

862 
vÆ
 
s2_ª∂a˚d_way_í
 = 
	`UI¡ToOH
(
	$RegE«bÀ
(
ª∂a˚r
.
way
, 
s1_˛k_í
))

863 
vÆ
 
s2_ª∂_mëa
 = 
	`Mux1H
(
s2_ª∂a˚d_way_í
, 
	`wayM≠
((
w
: 
I¡
Ë=> 
	`RegE«bÀ
(
mëa
.
io
.
	`ª•
(w), 
s1_˛k_í
 && 
	`s1_ª∂a˚d_way_í
(w))).
toSeq
)

866 
mshrs
.
io
.
ªq
.
vÆid
 :
s2_vÆid_masked
 && !
s2_hô
 && (
	`isPª„tch
(
s2_ªq
.
cmd
Ë|| 
	`isRód
(s2_ªq.cmdË|| 
	$isWrôe
(
s2_ªq
.
cmd
))

867 
mshrs
.
io
.
ªq
.
bôs
 :
s2_ªq


868 
mshrs
.
io
.
ªq
.
bôs
.
èg_m©ch
 :
s2_èg_m©ch


869 
mshrs
.
io
.
ªq
.
bôs
.
ﬁd_mëa
 :
	`Mux
(
s2_èg_m©ch
, 
	`L1Mëad©a
(
s2_ª∂_mëa
.
èg
, 
s2_hô_°©e
), s2_repl_meta)

870 
mshrs
.
io
.
ªq
.
bôs
.
way_í
 :
	$Mux
(
s2_èg_m©ch
, 
s2_èg_m©ch_way
, 
s2_ª∂a˚d_way_í
)

871 
mshrs
.
io
.
ªq
.
bôs
.
d©a
 :
s2_ªq
.data

872 
	`whí
 (
mshrs
.
io
.
ªq
.
	$fúe
()Ë{ 
ª∂a˚r
.
miss
 
	}
}

873 
é_out
.
a
 <> 
mshrs
.
io
.
mem_acquúe


876 
ªadArb
.
io
.
ö
(1).
vÆid
 :
mshrs
.io.
ª∂ay
.valid

877 
ªadArb
.
io
.
ö
(1).
bôs
 :
mshrs
.io.
ª∂ay
.bits

878 
ªadArb
.
io
.
ö
(1).
bôs
.
way_í
 :~
	$UI¡
(0, 
nWays
)

879 
mshrs
.
io
.
ª∂ay
.
ªady
 :
ªadArb
.io.
	`ö
(1).ready

880 
s1_ª∂ay
 :
mshrs
.
io
.
ª∂ay
.
vÆid
 && 
ªadArb
.io.
	`ö
(1).
ªady


881 
mëaRódArb
.
io
.
	`ö
(1Ë<> 
mshrs
.io.
mëa_ªad


882 
mëaWrôeArb
.
io
.
	`ö
(0Ë<> 
mshrs
.io.
mëa_wrôe


885 
¥obî
.
io
.
ªq
.
vÆid
 :
é_out
.
b
.vÆid && !
Ãsc_vÆid


886 
é_out
.
b
.
ªady
 :
¥obî
.
io
.
ªq
.ªady && !
Ãsc_vÆid


887 
¥obî
.
io
.
ªq
.
bôs
 :
é_out
.
b
.bits

888 
¥obî
.
io
.
way_í
 :
s2_èg_m©ch_way


889 
¥obî
.
io
.
block_°©e
 :
s2_hô_°©e


890 
mëaRódArb
.
io
.
	`ö
(2Ë<> 
¥obî
.io.
mëa_ªad


891 
mëaWrôeArb
.
io
.
	`ö
(1Ë<> 
¥obî
.io.
mëa_wrôe


892 
¥obî
.
io
.
mshr_rdy
 :
mshrs
.io.
¥obe_rdy


895 
vÆ
 
gø¡_has_d©a
 = 
edge
.
	$hasD©a
(
é_out
.
d
.
bôs
)

896 
mshrs
.
io
.
mem_gø¡
.
vÆid
 :
é_out
.
d
.
	$fúe
()

897 
mshrs
.
io
.
mem_gø¡
.
bôs
 :
é_out
.
d
.bits

898 
é_out
.
d
.
ªady
 :
wrôeArb
.
io
.
	`ö
(1).ªady || !
gø¡_has_d©a


902 
wrôeArb
.
io
.
	`ö
(1).
vÆid
 :
é_out
.
d
.vÆid && 
gø¡_has_d©a
 &&

903 
é_out
.
d
.
bôs
.
sour˚
 < 
	$UI¡
(
cfg
.
nMSHRs
)

904 
wrôeArb
.
io
.
	`ö
(1).
bôs
.
addr
 :
mshrs
.io.
ªfûl
.addr

905 
wrôeArb
.
io
.
	`ö
(1).
bôs
.
way_í
 :
mshrs
.io.
ªfûl
.way_en

906 
wrôeArb
.
io
.
	`ö
(1).
bôs
.
wmask
 :~
	$UI¡
(0, 
rowW‹ds
)

907 
wrôeArb
.
io
.
	`ö
(1).
bôs
.
d©a
 :
é_out
.
d
.bôs.
	`d©a
(
ícRowBôs
-1,0)

908 
d©a
.
io
.
ªad
 <> 
ªadArb
.io.
out


909 
ªadArb
.
io
.
out
.
ªady
 :!
é_out
.
d
.
vÆid
 ||Ål_out.d.ready

910 
é_out
.
e
 <> 
mshrs
.
io
.
mem_föish


913 
vÆ
 
wbArb
 = 
	`ModuÀ
(
√w
 
	`Arbôî
“ew 
	`WrôebackReq
(
edge
.
bundÀ
), 2))

914 
wbArb
.
io
.
	`ö
(0Ë<> 
¥obî
.io.
wb_ªq


915 
wbArb
.
io
.
	`ö
(1Ë<> 
mshrs
.io.
wb_ªq


916 
wb
.
io
.
ªq
 <> 
wbArb
.io.
out


917 
mëaRódArb
.
io
.
	`ö
(3Ë<> 
wb
.io.
mëa_ªad


918 
ªadArb
.
io
.
	`ö
(2Ë<> 
wb
.io.
d©a_ªq


919 
wb
.
io
.
d©a_ª•
 :
s2_d©a_c‹ª˘ed


920 
TLArbôî
.
	$lowe°
(
edge
, 
é_out
.
c
, 
wb
.
io
.
ªÀa£
, 
¥obî
.io.
ªp
)

923 
vÆ
 
s4_vÆid
 = 
	`Reg
(
√xt
=
s3_vÆid
, 
öô
=
	$Boﬁ
(
Ál£
))

924 
vÆ
 
s4_ªq
 = 
	$RegE«bÀ
(
s3_ªq
, 
s3_vÆid
 && 
mëaRódArb
.
io
.
out
.
vÆid
)

925 
vÆ
 
by∑s£s
 = 
	`Li°
(

926 ((
s2_vÆid_masked
 || 
s2_ª∂ay
Ë&& !
s2_sc_Áû
, 
s2_ªq
, 
amﬂlu
.
io
.
out
),

927 (
s3_vÆid
, 
s3_ªq
, s3_ªq.
d©a
),

928 (
s4_vÆid
, 
s4_ªq
, s4_ªq.
d©a
)

929 ).
	`m≠
(
r
 => (r.
_1
 && (
s1_addr
 >> 
w‹dOffBôs
 ==r.
_2
.
addr
 >> w‹dOffBôsË&& 
	`isWrôe
‘._2.
cmd
),Ñ.
_3
))

930 
vÆ
 
s2_°‹e_by∑ss_d©a
 = 
	`Reg
(
	$Bôs
(
width
 = 
c‹eD©aBôs
))

931 
vÆ
 
s2_°‹e_by∑ss
 = 
	`Reg
(
	$Boﬁ
())

932 
	$whí
 (
s1_˛k_í
) {

933 
s2_°‹e_by∑ss
 :
Ál£


934 
	`whí
 (
by∑s£s
.
	`m≠
(
_
.
_1
).
	`ªdu˚
(_||_)) {

935 
s2_°‹e_by∑ss_d©a
 :
	`Pri‹ôyMux
(
by∑s£s
)

936 
s2_°‹e_by∑ss
 :
åue


938 
	}
}

941 
vÆ
 
s2_d©a_w‹d_¥eby∑ss
 = 
s2_d©a_unc‹ª˘ed
 >> 
C©
(
s2_w‹d_idx
, 
Bôs
(0,
	$log2Up
(
c‹eD©aBôs
)))

942 
vÆ
 
s2_d©a_w‹d
 = 
	$Mux
(
s2_°‹e_by∑ss
, 
s2_°‹e_by∑ss_d©a
, 
s2_d©a_w‹d_¥eby∑ss
)

943 
vÆ
 
lﬂdgí
 = 
√w
 
	`LﬂdGí
(
s2_ªq
.
typ
, 
	`mtSig√d
(s2_ªq.typ), s2_ªq.
addr
, 
s2_d©a_w‹d
, 
s2_sc
, 
w‹dByãs
)

945 
amﬂlu
.
io
.
mask
 :
√w
 
	`St‹eGí
(
s2_ªq
.
typ
, s2_ªq.
addr
, 0.U, 
xLí
/8).mask

946 
amﬂlu
.
io
.
cmd
 :
s2_ªq
.cmd

947 
amﬂlu
.
io
.
lhs
 :
s2_d©a_w‹d


948 
amﬂlu
.
io
.
rhs
 :
s2_ªq
.
d©a


951 
vÆ
 
s1_«ck
 = 
déb
.
io
.
ªq
.
vÆid
 && déb.io.
ª•
.
miss
 ||

952 
s1_ªq
.
	`addr
(
idxMSB
,
idxLSB
Ë==
¥obî
.
io
.
mëa_wrôe
.
bôs
.
idx
 && !¥obî.io.
ªq
.
ªady


953 
vÆ
 
s2_«ck_hô
 = 
	`RegE«bÀ
(
s1_«ck
, 
s1_vÆid
 || 
s1_ª∂ay
)

954 
	$whí
 (
s2_«ck_hô
Ë{ 
mshrs
.
io
.
ªq
.
vÆid
 :
	`Boﬁ
(
Ál£
Ë
	}
}

955 
vÆ
 
s2_«ck_vi˘im
 = 
s2_hô
 && 
mshrs
.
io
.
£c⁄d¨y_miss


956 
vÆ
 
s2_«ck_miss
 = !
s2_hô
 && !
mshrs
.
io
.
ªq
.
ªady


957 
vÆ
 
s2_«ck
 = 
s2_«ck_hô
 || 
s2_«ck_vi˘im
 || 
s2_«ck_miss


958 
s2_vÆid_masked
 :
s2_vÆid
 && !
s2_«ck
 && !
io
.
˝u
.
s2_kûl


960 
vÆ
 
s2_ªcy˛e_ecc
 = (
s2_vÆid
 || 
s2_ª∂ay
Ë&& 
s2_hô
 && 
s2_d©a_c‹ª˘abÀ


961 
vÆ
 
s2_ªcy˛e_√xt
 = 
Reg
(
öô
=
	$Boﬁ
(
Ál£
))

962 
	`whí
 (
s1_vÆid
 || 
s1_ª∂ay
Ë{ 
s2_ªcy˛e_√xt
 :
s2_ªcy˛e_ecc
 
	}
}

963 
s2_ªcy˛e
 :
s2_ªcy˛e_ecc
 || 
s2_ªcy˛e_√xt


966 
vÆ
 
block_miss
 = 
Reg
(
öô
=
	$Boﬁ
(
Ál£
))

967 
block_miss
 :(
s2_vÆid
 || block_missË&& 
s2_«ck_miss


968 
	$whí
 (
block_miss
) {

969 
io
.
˝u
.
ªq
.
ªady
 :
	`Boﬁ
(
Ál£
)

970 
	}
}

972 
vÆ
 
ˇche_ª•
 = 
Wúe
(
	$VÆid
(
√w
 
HñœCacheRe•
))

973 
ˇche_ª•
.
vÆid
 :(
s2_ª∂ay
 || 
s2_vÆid_masked
 && 
s2_hô
Ë&& !
s2_d©a_c‹ª˘abÀ


974 
ˇche_ª•
.
bôs
 :
s2_ªq


975 
ˇche_ª•
.
bôs
.
has_d©a
 :
	$isRód
(
s2_ªq
.
cmd
)

976 
ˇche_ª•
.
bôs
.
d©a
 :
lﬂdgí
.d©®| 
s2_sc_Áû


977 
ˇche_ª•
.
bôs
.
°‹e_d©a
 :
s2_ªq
.
d©a


978 
ˇche_ª•
.
bôs
.
ª∂ay
 :
s2_ª∂ay


980 
vÆ
 
unˇche_ª•
 = 
	`Wúe
(
	$VÆid
(
√w
 
HñœCacheRe•
))

981 
unˇche_ª•
.
bôs
 :
mshrs
.
io
.
ª•
.bits

982 
unˇche_ª•
.
vÆid
 :
mshrs
.
io
.
ª•
.valid

983 
mshrs
.
io
.
ª•
.
ªady
 :
	`Reg
(
√xt
!(
s1_vÆid
 || 
s1_ª∂ay
))

985 
io
.
˝u
.
s2_«ck
 :
s2_vÆid
 && s2_nack

986 
io
.
˝u
.
ª•
 :
	$Mux
(
mshrs
.
io
.
ª•
.
ªady
, 
unˇche_ª•
, 
ˇche_ª•
)

987 
io
.
˝u
.
ª•
.
bôs
.
d©a_w‹d_by∑ss
 :
lﬂdgí
.
w‹dD©a


988 
io
.
˝u
.
ª•
.
bôs
.
d©a_øw
 :
s2_d©a_w‹d


989 
io
.
˝u
.
‹dîed
 :
mshrs
.io.
„n˚_rdy
 && !
s1_vÆid
 && !
s2_vÆid


990 
io
.
˝u
.
ª∂ay_√xt
 :(
s1_ª∂ay
 && 
s1_ªad
Ë|| 
mshrs
.io.replay_next

992 
vÆ
 
s1_x˝t_vÆid
 = 
déb
.
io
.
ªq
.
vÆid
 && !
s1_«ck


993 
vÆ
 
s1_x˝t
 = 
déb
.
io
.
ª•


994 
io
.
˝u
.
s2_x˝t
 :
	`Mux
(
	`RegNext
(
s1_x˝t_vÆid
), 
	`RegE«bÀ
(
s1_x˝t
, 
s1_˛k_í
), 0.U.a
	$sTy≥Of
(
s1_x˝t
))

997 
io
.
˝u
.
≥rf
.
acquúe
 :
edge
.
	$d⁄e
(
é_out
.
a
)

998 
io
.
˝u
.
≥rf
.
ªÀa£
 :
edge
.
	$d⁄e
(
é_out
.
c
)

999 
io
.
˝u
.
≥rf
.
ébMiss
 :io.
±w
.
ªq
.
	$fúe
()

1002 
io
.
˝u
.
˛ock_íabÀd
 :
åue


1003 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PMP.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 ˛as†
	cPMPC⁄fig
 
exãnds
 
	mBundÀ
 {

12 
vÆ
 
	ml
 = 
	$Boﬁ
()

13 
vÆ
 
ªs
 = 
	$UI¡
(
width
 = 2)

14 
vÆ
 
a
 = 
	$UI¡
(
width
 = 2)

15 
vÆ
 
x
 = 
	$Boﬁ
()

16 
vÆ
 
w
 = 
	$Boﬁ
()

17 
vÆ
 
r
 = 
	`Boﬁ
()

20 
obje˘
 
PMP
 {

21 
def
 
lgAlign
 = 2

23 
def
 
	`≠∂y
(
ªg
: 
PMPReg
): 
PMP
 = {

24 
vÆ
 
pmp
 = 
	`Wúe
(
√w
 
	`PMP
()(
ªg
.
p
))

25 
pmp
 :
ªg


26 
pmp
.
mask
 :pmp.
compuãMask


27 
pmp


29 
	}
}

31 ˛as†
	cPMPReg
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

32 
vÆ
 
cfg
 = 
√w
 
PMPC⁄fig


33 
vÆ
 
addr
 = 
	`UI¡
(
width
 = 
∑ddrBôs
 - 
PMP
.
lgAlign
)

35 
def
 
ªadAddr
 = i‡(
pmpGønuœrôy
.
log2
 =
PMP
.
lgAlign
Ë
addr
 {

36 
vÆ
 
mask
 = ((
	`BigI¡
(1Ë<< (
pmpGønuœrôy
.
log2
 - 
PMP
.
lgAlign
)Ë- 1).
U


37 
	`Mux
(
«pŸ
, 
addr
 | (
mask
 >> 1), ~(~addr | mask))

39 
def
 
«pŸ
 = 
cfg
.
	$a
(1)

40 
def
 
t‹NŸNAPOT
 = 
cfg
.
	$a
(0)

41 
def
 
t‹
 = !
«pŸ
 && 
t‹NŸNAPOT


42 
def
 
cfgLocked
 = 
cfg
.
l


43 
def
 
	`addrLocked
(
√xt
: 
PMPReg
Ë
cfgLocked
 ||Çext.cfgLocked &&Çext.
t‹


44 
	}
}

46 ˛as†
	cPMP
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
PMPReg
 {

47 
vÆ
 
mask
 = 
	$UI¡
(
width
 = 
∑ddrBôs
)

49 
imp‹t
 
PMP
.
_


50 
def
 
compuãMask
 = {

51 
vÆ
 
ba£
 = 
	`C©
(
addr
, 
cfg
.
	`a
(0)Ë| ((
pmpGønuœrôy
 - 1Ë>> 
lgAlign
)

52 
	`C©
(
ba£
 & ~(ba£ + 1), 
	`UI¡
((1 << 
lgAlign
) - 1))

54 
¥iv©e
 
def
 
com∑ønd
 = ~(~(
addr
 << 
lgAlign
Ë| (
pmpGønuœrôy
 - 1))

56 
¥iv©e
 
def
 
	`pow2M©ch
(
x
: 
UI¡
, 
lgSize
: UI¡, 
lgMaxSize
: 
I¡
) = {

57 
def
 
	`evÆ
(
a
: 
UI¡
, 
b
: UI¡, 
m
: UInt) = ((a ^ b) & ~m) === 0

58 i‡(
lgMaxSize
 <
pmpGønuœrôy
.
log2
) {

59 
	`evÆ
(
x
, 
com∑ønd
, 
mask
)

62 
vÆ
 
lsbMask
 = 
mask
 | 
	`UI¡ToOH1
(
lgSize
, 
lgMaxSize
)

63 
vÆ
 
msbM©ch
 = 
	`evÆ
(
x
 >> 
lgMaxSize
, 
com∑ønd
 >>ÜgMaxSize, 
mask
 >>ÜgMaxSize)

64 
vÆ
 
lsbM©ch
 = 
	`evÆ
(
	`x
(
lgMaxSize
-1, 0), 
	`com∑ønd
÷gMaxSize-1, 0), 
	`lsbMask
(lgMaxSize-1, 0))

65 
msbM©ch
 && 
lsbM©ch


67 
	}
}

69 
¥iv©e
 
def
 
boundM©ch
(
x
: 
UI¡
, 
lsbMask
: UI¡, 
lgMaxSize
: 
I¡
) = {

70 i‡(
lgMaxSize
 <
pmpGønuœrôy
.
log2
) {

71 
x
 < 
com∑ønd


74 
vÆ
 
msbsLess
 = (
x
 >> 
lgMaxSize
Ë< (
com∑ønd
 >>ÜgMaxSize)

75 
vÆ
 
msbsEquÆ
 = ((
x
 >> 
lgMaxSize
Ë^ (
com∑ønd
 >>ÜgMaxSize)) === 0

76 
vÆ
 
lsbsLess
 = (
x
(
lgMaxSize
-1, 0Ë| 
	glsbMask
Ë< 
com∑ønd
(lgMaxSize-1, 0)

77 
	gmsbsLess
 || (
	gmsbsEquÆ
 && 
	glsbsLess
)

81 
¥iv©e
 
def
 
lowîBoundM©ch
(
x
: 
UI¡
, 
lgSize
: UI¡, 
lgMaxSize
: 
I¡
) =

82 !
boundM©ch
(
x
, 
UI¡ToOH1
(
lgSize
, 
lgMaxSize
),ÜgMaxSize)

84 
¥iv©e
 
def
 
uµîBoundM©ch
(
x
: 
UI¡
, 
lgMaxSize
: 
I¡
) =

85 
	$boundM©ch
(
x
, 0.U, 
lgMaxSize
)

87 
¥iv©e
 
def
 
	`øngeM©ch
(
x
: 
UI¡
, 
lgSize
: UI¡, 
lgMaxSize
: 
I¡
, 
¥ev
: 
PMP
) =

88 
¥ev
.
	`lowîBoundM©ch
(
x
, 
lgSize
, 
lgMaxSize
Ë&& 
	$uµîBoundM©ch
(
x
, 
lgMaxSize
)

90 
¥iv©e
 
def
 
	`pow2Homogíeous
(
x
: 
UI¡
, 
pgLevñ
: UInt) = {

91 
vÆ
 
maskHomogíeous
 = 
pgLevñM≠
 { 
idxBôs
 => i‡(idxBô†> 
∑ddrBôs
Ë
Ál£
.
B
 
	`mask
(idxBô†- 1Ë} (
pgLevñ
)

92 
maskHomogíeous
 || (
pgLevñM≠
 { 
idxBôs
 => ((
x
 ^ 
com∑ønd
Ë>> idxBôsË=/0 } (
pgLevñ
))

93 
	}
}

95 
¥iv©e
 
def
 
pgLevñM≠
[
T
](
f
: 
I¡
 => TË(0 
u¡û
 
pgLevñs
).
m≠
 { 
i
 =>

96 
f
(
pgIdxBôs
 + (
pgLevñs
 - 1 - 
i
Ë* 
pgLevñBôs
)

99 
¥iv©e
 
def
 
øngeHomogíeous
(
x
: 
UI¡
, 
pgLevñ
: UI¡, 
¥ev
: 
PMP
) = {

100 
vÆ
 
begösA·îLowî
 = !(
x
 < 
¥ev
.
com∑ønd
)

101 
vÆ
 
begösA·îUµî
 = !(
x
 < 
com∑ønd
)

103 
vÆ
 
pgMask
 = 
pgLevñM≠
 { 
idxBôs
 => (((
BigI¡
(1Ë<< 
∑ddrBôs
Ë- (BigI¡(1Ë<< idxBôs)Ë
max
 0).
U
 } (
pgLevñ
)

104 
vÆ
 
ídsBef‹eLowî
 = (
x
 & 
pgMask
Ë< (
¥ev
.
com∑ønd
 &ÖgMask)

105 
vÆ
 
ídsBef‹eUµî
 = (
x
 & 
pgMask
Ë< (
com∑ønd
 &ÖgMask)

107 
ídsBef‹eLowî
 || 
begösA·îUµî
 || (
begösA·îLowî
 && 
ídsBef‹eUµî
)

111 
def
 
	$homogíeous
(
x
: 
UI¡
, 
pgLevñ
: UI¡, 
¥ev
: 
PMP
): 
Boﬁ
 =

112 
	`Mux
(
«pŸ
, 
	`pow2Homogíeous
(
x
, 
pgLevñ
), !
t‹NŸNAPOT
 || 
	$øngeHomogíeous
(
x
, 
pgLevñ
, 
¥ev
))

115 
def
 
	$Æig√d
(
x
: 
UI¡
, 
lgSize
: UI¡, 
lgMaxSize
: 
I¡
, 
¥ev
: 
PMP
): 
Boﬁ
 = i‡÷gMaxSizê<
pmpGønuœrôy
.
log2
Ë
åue
.
B
 {

116 
vÆ
 
lsbMask
 = 
	`UI¡ToOH1
(
lgSize
, 
lgMaxSize
)

117 
vÆ
 
°øddÀsLowîBound
 = ((
x
 >> 
lgMaxSize
Ë^ (
¥ev
.
com∑ønd
 >>ÜgMaxSize)Ë==0 && (¥ev.
	`com∑ønd
÷gMaxSize-1, 0Ë& ~
	`x
(lgMaxSize-1, 0)) =/= 0

118 
vÆ
 
°øddÀsUµîBound
 = ((
x
 >> 
lgMaxSize
Ë^ (
com∑ønd
 >>ÜgMaxSize)Ë==0 && (
	`com∑ønd
÷gMaxSize-1, 0Ë& (
	`x
÷gMaxSize-1, 0Ë| 
lsbMask
)) =/= 0

119 
vÆ
 
øngeAlig√d
 = !(
°øddÀsLowîBound
 || 
°øddÀsUµîBound
)

120 
vÆ
 
pow2Alig√d
 = (
lsbMask
 & ~
	`mask
(
lgMaxSize
-1, 0)) === 0

121 
	`Mux
(
«pŸ
, 
pow2Alig√d
, 
øngeAlig√d
)

122 
	}
}

125 
def
 
	$hô
(
x
: 
UI¡
, 
lgSize
: UI¡, 
lgMaxSize
: 
I¡
, 
¥ev
: 
PMP
): 
Boﬁ
 =

126 
	`Mux
(
«pŸ
, 
	`pow2M©ch
(
x
, 
lgSize
, 
lgMaxSize
), 
t‹NŸNAPOT
 && 
	`øngeM©ch
(x,ÜgSize,ÜgMaxSize, 
¥ev
))

127 
	}
}

129 
˛ass
 
	$PMPHomogíeôyCheckî
(
pmps
: 
Seq
[
PMP
])(
im∂icô
 
p
: 
P¨amëîs
) {

130 
def
 
	`≠∂y
(
addr
: 
UI¡
, 
pgLevñ
: UI¡): 
Boﬁ
 = {

131 ((
åue
.
B
, 0.U.a
	`sTy≥Of
(
√w
 
PMP
)Ë/: 
pmps
Ë{ ((
h
, 
¥ev
), 
pmp
) =>

132 (
h
 && 
pmp
.
	`homogíeous
(
addr
, 
pgLevñ
, 
¥ev
),Ömp)

133 }.
_1


135 
	}
}

137 ˛as†
	cPMPCheckî
(
lgMaxSize
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
)

138 
wôh
 
HasC‹eP¨amëîs
 {

139 
vÆ
 
io
 = 
√w
 
BundÀ
 {

140 
vÆ
 
¥v
 = 
	`UI¡
(
INPUT
, 
PRV
.
SZ
)

141 
vÆ
 
pmp
 = 
	`Vec
(
nPMPs
, 
√w
 
PMP
).
asI≈ut


142 
vÆ
 
addr
 = 
	`UI¡
(
INPUT
, 
∑ddrBôs
)

143 
vÆ
 
size
 = 
	`UI¡
(
INPUT
, 
	`log2Ceû
(
lgMaxSize
 + 1))

144 
vÆ
 
r
 = 
	`Boﬁ
(
OUTPUT
)

145 
vÆ
 
w
 = 
	`Boﬁ
(
OUTPUT
)

146 
vÆ
 
x
 = 
	`Boﬁ
(
OUTPUT
)

149 
vÆ
  = i‡(
io
.
pmp
.
isEm±y
Ë
åue
.
B
 io.
¥v
 > 
PRV
.
S


150 
vÆ
 
pmp0
 = 
	`Wúe
(
öô
 = 0.U.a
	$sTy≥Of
(
√w
 
PMP
))

151 
pmp0
.
cfg
.
r
 := 

152 
pmp0
.
cfg
.
w
 := 

153 
pmp0
.
cfg
.
x
 := 

155 
vÆ
 
ªs
 = (
pmp0
 /: (
io
.
pmp
 
	`zù
 (pmp0 +: io.pmp)).
ªvî£
Ë{ (
¥ev
, (pmp, 
¥evPMP
)) =>

156 
vÆ
 
hô
 = 
pmp
.
	`hô
(
io
.
addr
, io.
size
, 
lgMaxSize
, 
¥evPMP
)

157 
vÆ
 
ign‹e
 =  && !
pmp
.
cfg
.
l


158 
vÆ
 
Æig√d
 = 
pmp
.
	`Æig√d
(
io
.
addr
, io.
size
, 
lgMaxSize
, 
¥evPMP
)

159 
vÆ
 
cur
 = 
	`Wúe
(
öô
 = 
pmp
)

160 
cur
.
cfg
.
r
 :(
Æig√d
 && 
pmp
.cfg.rË|| 
ign‹e


161 
cur
.
cfg
.
w
 :(
Æig√d
 && 
pmp
.cfg.wË|| 
ign‹e


162 
cur
.
cfg
.
x
 :(
Æig√d
 && 
pmp
.cfg.xË|| 
ign‹e


163 
	`Mux
(
hô
, 
cur
, 
¥ev
)

164 
	}
}

166 
	gio
.
	gr
 :
ªs
.
cfg
.
r


167 
io
.
w
 :
ªs
.
cfg
.w

168 
io
.
x
 :
ªs
.
cfg
.x

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PTW.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
CacheBlockByãs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


14 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


15 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
_


16 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
Li°Buf„r


18 ˛as†
	cPTWReq
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

19 
vÆ
 
addr
 = 
	`UI¡
(
width
 = 
v≤Bôs
)

22 ˛as†
	cPTWRe•
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

23 
vÆ
 
´
 = 
	$Boﬁ
()

24 
vÆ
 
±e
 = 
√w
 
PTE


25 
vÆ
 
Àvñ
 = 
	`UI¡
(
width
 = 
	$log2Ceû
(
pgLevñs
))

26 
vÆ
 
‰agmíãd_su≥Ωage
 = 
	$Boﬁ
()

27 
vÆ
 
homogíeous
 = 
	`Boﬁ
()

30 ˛as†
	cTLBPTWIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
)

31 
wôh
 
HasC‹eP¨amëîs
 {

32 
vÆ
 
ªq
 = 
	`Decou∂ed
(
	$VÆid
(
√w
 
PTWReq
))

33 
vÆ
 
ª•
 = 
	`VÆid
(
√w
 
PTWRe•
).
Êù


34 
vÆ
 
±br
 = 
√w
 
	`PTBR
().
asI≈ut


35 
vÆ
 
°©us
 = 
√w
 
	`MSètus
().
asI≈ut


36 
vÆ
 
pmp
 = 
	`Vec
(
nPMPs
, 
√w
 
PMP
).
asI≈ut


37 
vÆ
 
cu°omCSRs
 = 
c‹eP¨ams
.cu°omCSRs.
asI≈ut


40 ˛as†
	cPTWPîfEvíts
 
exãnds
 
BundÀ
 {

41 
vÆ
 
l2miss
 = 
	`Boﬁ
()

44 ˛as†
	cD©≠©hPTWIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
)

45 
wôh
 
HasC‹eP¨amëîs
 {

46 
vÆ
 
±br
 = 
√w
 
	`PTBR
().
asI≈ut


47 
vÆ
 
s„n˚
 = 
	`VÆid
(
√w
 
SFí˚Req
).
Êù


48 
vÆ
 
°©us
 = 
√w
 
	`MSètus
().
asI≈ut


49 
vÆ
 
pmp
 = 
	`Vec
(
nPMPs
, 
√w
 
PMP
).
asI≈ut


50 
vÆ
 
≥rf
 = 
√w
 
	`PTWPîfEvíts
().
asOuçut


51 
vÆ
 
cu°omCSRs
 = 
c‹eP¨ams
.cu°omCSRs.
asI≈ut


55 
vÆ
 
pcode_ªq
 = 
	`VÆid
(
√w
 
PCodeUpd©e
).
Êù


56 
vÆ
 
pcode_ª•
 = 
	`VÆid
(
√w
 
PCodeUpd©e
)

61 ˛as†
	cPTE
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

62 
vÆ
 
µn
 = 
	$UI¡
(
width
 = 54)

63 
vÆ
 
ª£rved_f‹_so·w¨e
 = 
	$Bôs
(
width
 = 2)

64 
vÆ
 
d
 = 
	$Boﬁ
()

65 
vÆ
 
a
 = 
	$Boﬁ
()

66 
vÆ
 
g
 = 
	$Boﬁ
()

67 
vÆ
 
u
 = 
	$Boﬁ
()

68 
vÆ
 
x
 = 
	$Boﬁ
()

69 
vÆ
 
w
 = 
	$Boﬁ
()

70 
vÆ
 
r
 = 
	$Boﬁ
()

71 
vÆ
 
v
 = 
	$Boﬁ
()

73 
def
 
	`èbÀ
(
dummy
: 
I¡
 = 0Ë
v
 && !
r
 && !
w
 && !
x


74 
def
 
	`Àaf
(
dummy
: 
I¡
 = 0Ë
v
 && (
r
 || (
x
 && !
w
)Ë&& 
a


75 
def
 
	`ur
(
dummy
: 
I¡
 = 0Ë
	`§
(Ë&& 
u


76 
def
 
	`uw
(
dummy
: 
I¡
 = 0Ë
	`sw
(Ë&& 
u


77 
def
 
	`ux
(
dummy
: 
I¡
 = 0Ë
	`sx
(Ë&& 
u


78 
def
 
	`§
(
dummy
: 
I¡
 = 0Ë
	`Àaf
(Ë&& 
r


79 
def
 
	`sw
(
dummy
: 
I¡
 = 0Ë
	`Àaf
(Ë&& 
w
 && 
d


80 
def
 
	`sx
(
dummy
: 
I¡
 = 0Ë
	`Àaf
(Ë&& 
x


83 ˛as†
	cPCodeLockCfg
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

84 
	`ªquúe
(
∑ddrBôs
 > 12)

85 
vÆ
 
ba£
 = 
	`UI¡
(
width
 = 
∑ddrBôs
-12)

86 
vÆ
 
mask
 = 
	$UI¡
(
width
 = 10)

87 
vÆ
 
vÆid
 = 
	$Boﬁ
()

88 
vÆ
 
íabÀ
 = 
	`Boﬁ
()

92 ˛as†
	cPCodeLock
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()

93 
wôh
 
HasC‹eP¨amëîs
 {

94 
vÆ
 
io
 = 
√w
 
BundÀ
 {

95 
vÆ
 
ö
 = 
√w
 
	`PTE
().
asI≈ut


96 
vÆ
 
out
 = 
√w
 
	`PTE
().
asOuçut


98 
vÆ
 
cfg
 = 
	`Vec
(
numPCodeR™ges
, 
√w
 
PCodeLockCfg
).
asI≈ut


101 
	$ªquúe
(
∑ddrBôs
 == 32)

102 
io
.
out
 :io.
ö


104 
vÆ
 
íabÀ
 = 
io
.
cfg
.
	`fﬁdLe·
(
	$Boﬁ
(
åue
))((
l
, 
r
Ë=>Ü &&Ñ.
íabÀ
)

108 
def
 
µn_m©ched
 = 
io
.
cfg
.
	`m≠
(

109 
c
 => c.
vÆid
 && ((
	`C©
(
	`UI¡
(0xff,8),C©(c.
mask
, UI¡(0,
width
=2))Ë& 
io
.
ö
.
	`µn
(
∑ddrBôs
-13,0)Ë==c.
ba£
)

110 ).
	`fﬁd
(
	$Boﬁ
(
Ál£
))–(
l
: 
Boﬁ
,
r
: Bool) =>Ü ||Ñ)

114 
def
 
ö_pcode
 = 
íabÀ
 && 
io
.
ö
.
	`Àaf
(Ë&& 
µn_m©ched


115 
def
 
out_pcode
 = 
íabÀ
 && 
io
.
ö
.
	`Àaf
(Ë&& !
µn_m©ched


116 
def
 
by∑ss
 = !
íabÀ
 || !
io
.
ö
.
	$Àaf
()

119 
io
.
out
.
x
 :
	`Mux
(
by∑ss
 || io.
ö
.
u
, io.ö.x, Mux(
µn_m©ched
, 
	`Boﬁ
(
åue
), 
	$Boﬁ
(
Ál£
)))

120 
io
.
out
.
w
 :
	`Mux
(
by∑ss
, io.
ö
.w, Mux(
µn_m©ched
, 
	`Boﬁ
(
Ál£
), io.in.w))

137 
	}
}

139 @
chi£lName


140 
˛ass
 
	$PTW
(
n
: 
I¡
)(
im∂icô
 
edge
: 
TLEdgeOut
, 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
) {

141 
vÆ
 
io
 = 
√w
 
BundÀ
 {

142 
vÆ
 
ªque°‹
 = 
	`Vec
(
n
, 
√w
 
TLBPTWIO
).
Êù


143 
vÆ
 
mem
 = 
√w
 
HñœCacheIO


144 
vÆ
 
d∑th
 = 
√w
 
D©≠©hPTWIO


151 
vÆ
 
pcode_cfg
 = 
	`Reg
(
öô
 = 
Vec
.
	`fûl
(
numPCodeR™ges
){ 
√w
 
	`PCodeLockCfg
().
	`‰omBôs
(0)} )

152 
vÆ
 
pcode_ª•
 = 
	`Reg
(
	`VÆid
(
√w
 
PCodeUpd©e
))

154 i‡(
hasPrivCodeLock
) {

155 
	`ªquúe
(
numPCodeR™ges
 <= 4)

156 
	`ªquúe
(
∑ddrBôs
 == 32)

157 
io
.
d∑th
.
pcode_ª•
 :=Öcode_resp

158 
	`whí
(
io
.
d∑th
.
pcode_ªq
.
vÆid
) {

167 
	`pcode_cfg
(
io
.
d∑th
.
pcode_ªq
.
bôs
.
id
).
ba£
 :io.d∑th.pcode_ªq.bôs.
vÆue
.base

168 
	`pcode_cfg
(
io
.
d∑th
.
pcode_ªq
.
bôs
.
id
).
mask
 :io.d∑th.pcode_ªq.bôs.
vÆue
.mask

169 
	`pcode_cfg
(
io
.
d∑th
.
pcode_ªq
.
bôs
.
id
).
vÆid
 :io.d∑th.pcode_ªq.bôs.
vÆue
.valid

170 
	`pcode_cfg
(
io
.
d∑th
.
pcode_ªq
.
bôs
.
id
).
íabÀ
 :io.d∑th.pcode_ªq.bôs.
vÆue
.
locked


175 
pcode_ª•
.
bôs
 :
io
.
d∑th
.
pcode_ªq
.bits

180 
vÆ
 
s_ªady
 :: 
s_ªq
 :: 
s_waô1
 :: 
s_dummy1
 :: 
s_waô2
 :: 
s_waô3
 :: 
s_dummy2
 :: 
s_‰agmít_su≥Ωage
 :: 
Nû
 = 
	`Enum
(
	`UI¡
(), 8)

181 
vÆ
 
°©e
 = 
	`Reg
(
öô
=
s_ªady
)

183 
vÆ
 
¨b
 = 
	`ModuÀ
(
√w
 
	`RRArbôî
(
	`VÆid
“ew 
PTWReq
), 
n
))

184 
¨b
.
io
.
ö
 <> io.
ªque°‹
.
	`m≠
(
_
.
ªq
)

185 
¨b
.
io
.
out
.
ªady
 :
°©e
 ==
s_ªady


187 
vÆ
 
ª•_vÆid
 = 
	`Reg
(
√xt
 = 
Vec
.
	`fûl
(
io
.
ªque°‹
.
size
)(
	`Boﬁ
(
Ál£
)))

189 
vÆ
 
˛ock_í
 = 
°©e
 =/
s_ªady
 || 
¨b
.
io
.
out
.
vÆid
 || io.
d∑th
.
s„n˚
.vÆid || io.d∑th.
cu°omCSRs
.
dißbÀDCacheClockG©e


190 
vÆ
 
g©ed_˛ock
 =

191 i‡(!
usögVM
 || !
tûeP¨ams
.
dˇche
.
gë
.
˛ockG©e
Ë
˛ock


192 
	`ClockG©e
(
˛ock
, 
˛ock_í
, "ptw_clock_gate")

193 
	`wôhClock
 (
g©ed_˛ock
) {

195 
vÆ
 
övÆid©ed
 = 
	`Reg
(
	`Boﬁ
())

196 
vÆ
 
cou¡
 = 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Up
(
pgLevñs
)))

197 
vÆ
 
ª•_´
 = 
	`RegNext
(
Ál£
.
B
)

198 
vÆ
 
ª•_‰agmíãd_su≥Ωage
 = 
	`RegNext
(
Ál£
.
B
)

200 
vÆ
 
r_ªq
 = 
	`Reg
(
√w
 
PTWReq
)

201 
vÆ
 
r_ªq_de°
 = 
	`Reg
(
	`Bôs
())

202 
vÆ
 
r_±e
 = 
	`Reg
(
√w
 
PTE
)

204 
	`vÆ
 (
±e
, 
övÆid_∑ddr
) = {

205 
vÆ
 
tmp
 = 
√w
 
	`PTE
().
	`‰omBôs
(
io
.
mem
.
ª•
.
bôs
.
d©a_w‹d_by∑ss
)

206 
vÆ
 
ªs
 = 
	`Wúe
(
öô
 = 
√w
 
	`PTE
().
	`‰omBôs
(
io
.
mem
.
ª•
.
bôs
.
d©a_w‹d_by∑ss
))

207 
ªs
.
µn
 :
tmp
.
	`µn
(
µnBôs
-1, 0)

208 
	`whí
 (
tmp
.
r
 ||Åmp.
w
 ||Åmp.
x
) {

210 
i
 <- 0 
u¡û
 
pgLevñs
-1)

211 
	`whí
 (
cou¡
 <
i
 && 
tmp
.
	`µn
((
pgLevñs
-1-i)*
pgLevñBôs
-1, (pgLevñs-2-i)*pgLevñBôsË=/0Ë{ 
ªs
.
v
 :
Ál£
 }

213 (
ªs
, (
tmp
.
µn
 >> 
µnBôs
) =/= 0)

215 
vÆ
 
åavî£
 = 
±e
.
	`èbÀ
(Ë&& !
övÆid_∑ddr
 && 
cou¡
 < 
pgLevñs
-1

216 
vÆ
 
±e_addr
 = i‡(!
usögVM
) 0.U {

217 
vÆ
 
v≤_idxs
 = (0 
u¡û
 
pgLevñs
).
	`m≠
(
i
 => (
r_ªq
.
addr
 >> (pgLevñs-i-1)*
pgLevñBôs
)(pgLevelBits-1,0))

218 
vÆ
 
v≤_idx
 = 
	`v≤_idxs
(
cou¡
)

219 
	`C©
(
r_±e
.
µn
, 
v≤_idx
Ë<< 
	`log2Ceû
(
xLí
/8)

221 
vÆ
 
‰agmíãd_su≥Ωage_µn
 = {

222 
vÆ
 
choi˚s
 = (
pgLevñs
-1 
u¡û
 0 
by
 -1).
	`m≠
(
i
 => 
	`C©
(
r_±e
.
µn
 >> (pgLevñs*i), 
r_ªq
.
	`addr
(pgLevels*i-1, 0)))

223 
	`choi˚s
(
cou¡
)

226 
	`whí
 (
¨b
.
io
.
out
.
	`fúe
()) {

227 
r_ªq
 :
¨b
.
io
.
out
.
bôs
.bits

228 
r_ªq_de°
 :
¨b
.
io
.
cho£n


231 
	`vÆ
 (
±e_ˇche_hô
, 
±e_ˇche_d©a
) = {

232 
vÆ
 
size
 = 1 << 
	`log2Up
(
pgLevñs
 * 2)

233 
vÆ
 
∂ru
 = 
√w
 
	`P£udoLRU
(
size
)

234 
vÆ
 
övÆid
 = 
	`RegInô
(
åue
.
B
)

235 
vÆ
 
ªg_vÆid
 = 
	`Reg
(
	`UI¡
(
size
.
W
))

236 
vÆ
 
vÆid
 = 
	`Mux
(
övÆid
, 0.U, 
ªg_vÆid
)

237 
vÆ
 
ègs
 = 
	`Reg
(
	`Vec
(
size
, 
	`UI¡
(
width
 = 
∑ddrBôs
)))

238 
vÆ
 
d©a
 = 
	`Reg
(
	`Vec
(
size
, 
	`UI¡
(
width
 = 
µnBôs
)))

240 
vÆ
 
hôs
 = 
ègs
.
	`m≠
(
_
 ==
±e_addr
).
asUI¡
 & 
vÆid


241 
vÆ
 
hô
 = 
hôs
.
‹R


242 
	`whí
 ((
°©e
 ==
s_waô2
 || sèã ==
s_waô3
Ë&& 
åavî£
 && !
hô
 && !
övÆid©ed
) {

243 
vÆ
 
r
 = 
	`Mux
(
vÆid
.
™dR
, 
∂ru
.
ª∂a˚
, 
	`Pri‹ôyEncodî
(~valid))

244 
övÆid
 :
Ál£


245 
ªg_vÆid
 :
	`Mux
(
io
.
mem
.
ª•
.
vÆid
, vÆid | 
	`UI¡ToOH
(
r
), valid & ~UIntToOH(r))

246 
	`ègs
(
r
Ë:
±e_addr


247 
	`d©a
(
r
Ë:
±e
.
µn


249 
	`whí
 (
hô
 && 
°©e
 ==
s_ªq
Ë{ 
∂ru
.
	`ac˚ss
(
	`OHToUI¡
(
hôs
)) }

250 
	`whí
 (
io
.
d∑th
.
s„n˚
.
vÆid
 && !io.d∑th.s„n˚.
bôs
.
rs1
Ë{ 
övÆid
 :
åue
 }

252 
i
 <- 0 
u¡û
 
pgLevñs
-1)

253 
	`ccovî
(
hô
 && 
°©e
 ==
s_ªq
 && 
cou¡
 ==
i
, 
s
"PTE_CACHE_HIT_L$i", s"PTE cache hit,Üevel $i")

255 (
hô
 && 
cou¡
 < 
pgLevñs
-1, 
	`Mux1H
(
hôs
, 
d©a
))

258 
vÆ
 
l2_ªfûl
 = 
	`RegNext
(
Ál£
.
B
)

259 
io
.
d∑th
.
≥rf
.
l2miss
 :
Ál£


260 
	`vÆ
 (
l2_hô
, 
l2_vÆid
, 
l2_±e
, 
l2_éb_øm
Ëi‡(
c‹eP¨ams
.
nL2TLBE¡rõs
 =0Ë(
Ál£
.
B
, fÆ£.B, 
	`Wúe
(
√w
 
PTE
), 
N⁄e
) {

261 
vÆ
 
code
 = 
√w
 
P¨ôyCode


262 
	`ªquúe
(
	`isPow2
(
c‹eP¨ams
.
nL2TLBE¡rõs
))

263 
vÆ
 
idxBôs
 = 
	`log2Ceû
(
c‹eP¨ams
.
nL2TLBE¡rõs
)

264 
vÆ
 
ègBôs
 = 
v≤Bôs
 - 
idxBôs


266 ˛as†
	cE¡ry
 
exãnds
 
BundÀ
 {

267 
vÆ
 
èg
 = 
	`UI¡
(
width
 = 
ègBôs
)

268 
vÆ
 
µn
 = 
	`UI¡
(
width
 = 
µnBôs
)

269 
vÆ
 
d
 = 
	`Boﬁ
()

270 
vÆ
 
a
 = 
	`Boﬁ
()

271 
vÆ
 
u
 = 
	`Boﬁ
()

272 
vÆ
 
x
 = 
	`Boﬁ
()

273 
vÆ
 
w
 = 
	`Boﬁ
()

274 
vÆ
 
r
 = 
	`Boﬁ
()

276 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`E¡ry
().
asIn°™˚Of
[
this
.
ty≥
]

279 
vÆ
 
øm
 = 
	`Des¸ibedSRAM
(

280 
«me
 = "l2_tlb_ram",

281 
desc
 = "L2 TLB",

282 
size
 = 
c‹eP¨ams
.
nL2TLBE¡rõs
,

283 
d©a
 = 
	`UI¡
(
width
 = 
code
.
	`width
(
√w
 
	`E¡ry
().
gëWidth
))

286 
vÆ
 
g
 = 
	`Reg
(
	`UI¡
(
width
 = 
c‹eP¨ams
.
nL2TLBE¡rõs
))

287 
vÆ
 
vÆid
 = 
	`RegInô
(
	`UI¡
(0, 
c‹eP¨ams
.
nL2TLBE¡rõs
))

288 
	`vÆ
 (
r_èg
, 
r_idx
Ë
	`S∂ô
(
r_ªq
.
addr
, 
idxBôs
)

289 
	`whí
 (
l2_ªfûl
 && !
övÆid©ed
) {

290 
vÆ
 
íåy
 = 
	`Wúe
(
√w
 
E¡ry
)

291 
íåy
 :
r_±e


292 
íåy
.
èg
 :
r_èg


293 
øm
.
	`wrôe
(
r_idx
, 
code
.
	`ícode
(
íåy
.
asUI¡
))

295 
vÆ
 
mask
 = 
	`UI¡ToOH
(
r_idx
)

296 
vÆid
 :vÆid | 
mask


297 
g
 :
	`Mux
(
r_±e
.g, g | 
mask
, g & ~mask)

299 
	`whí
 (
io
.
d∑th
.
s„n˚
.
vÆid
) {

300 
vÆid
 :=

301 
	`Mux
(
io
.
d∑th
.
s„n˚
.
bôs
.
rs1
, 
vÆid
 & ~
	`UI¡ToOH
(io.d∑th.s„n˚.bôs.
	`addr
(
idxBôs
+
pgIdxBôs
-1,ÖgIdxBits)),

302 
	`Mux
(
io
.
d∑th
.
s„n˚
.
bôs
.
rs2
, 
vÆid
 & 
g
, 0.U))

305 
vÆ
 
s0_vÆid
 = !
l2_ªfûl
 && 
¨b
.
io
.
out
.
	`fúe
()

306 
vÆ
 
s1_vÆid
 = 
	`RegNext
(
s0_vÆid
 && 
¨b
.
io
.
out
.
bôs
.
vÆid
)

307 
vÆ
 
s2_vÆid
 = 
	`RegNext
(
s1_vÆid
)

308 
vÆ
 
s1_rd©a
 = 
øm
.
	`ªad
(
¨b
.
io
.
out
.
bôs
.bôs.
	`addr
(
idxBôs
-1, 0), 
s0_vÆid
)

309 
vÆ
 
s2_rd©a
 = 
code
.
	`decode
(
	`RegE«bÀ
(
s1_rd©a
, 
s1_vÆid
))

310 
vÆ
 
s2_vÆid_bô
 = 
	`RegE«bÀ
(
	`vÆid
(
r_idx
), 
s1_vÆid
)

311 
vÆ
 
s2_g
 = 
	`RegE«bÀ
(
	`g
(
r_idx
), 
s1_vÆid
)

312 
	`whí
 (
s2_vÆid
 && 
s2_vÆid_bô
 && 
s2_rd©a
.
îr‹
Ë{ 
vÆid
 := 0.U }

314 
vÆ
 
s2_íåy
 = 
s2_rd©a
.
unc‹ª˘ed
.
	`asTy≥Of
(
√w
 
E¡ry
)

315 
vÆ
 
s2_hô
 = 
s2_vÆid
 && 
s2_vÆid_bô
 && !
s2_rd©a
.
îr‹
 && 
r_èg
 ==
s2_íåy
.
èg


316 
io
.
d∑th
.
≥rf
.
l2miss
 :
s2_vÆid
 && !(
s2_vÆid_bô
 && 
r_èg
 ==
s2_íåy
.
èg
)

317 
vÆ
 
s2_±e
 = 
	`Wúe
(
√w
 
PTE
)

318 
s2_±e
 :
s2_íåy


319 
s2_±e
.
g
 :
s2_g


320 
s2_±e
.
v
 :
åue


322 
	`ccovî
(
s2_hô
, "L2_TLB_HIT", "L2 TLB hit")

324 (
s2_hô
, 
s2_vÆid
 && 
s2_vÆid_bô
, 
s2_±e
, 
	`Some
(
øm
))

328 
övÆid©ed
 :
io
.
d∑th
.
s„n˚
.
vÆid
 || (övÆid©ed && 
°©e
 =/
s_ªady
)

330 
io
.
mem
.
ªq
.
vÆid
 :
°©e
 ==
s_ªq
 || sèã ==
s_dummy1


331 
io
.
mem
.
ªq
.
bôs
.
phys
 :
	`Boﬁ
(
åue
)

332 
io
.
mem
.
ªq
.
bôs
.
cmd
 :
M_XRD


333 
io
.
mem
.
ªq
.
bôs
.
typ
 :
	`log2Ceû
(
xLí
/8)

334 
io
.
mem
.
ªq
.
bôs
.
addr
 :
±e_addr


335 
io
.
mem
.
s1_kûl
 :
l2_hô
 || 
°©e
 =/
s_waô1


336 
io
.
mem
.
s2_kûl
 :
	`Boﬁ
(
Ál£
)

338 
vÆ
 
∑geGønuœrôyPMPs
 = 
pmpGønuœrôy
 >(1 << 
pgIdxBôs
)

339 
vÆ
 
pmaPgLevñHomogíeous
 = (0 
u¡û
 
pgLevñs
Ë
m≠
 { 
i
 =>

340 
vÆ
 
pgSize
 = 
	`BigI¡
(1Ë<< (
pgIdxBôs
 + ((
pgLevñs
 - 1 - 
i
Ë* 
pgLevñBôs
))

341 i‡(
∑geGønuœrôyPMPs
 && 
i
 =
pgLevñs
 - 1) {

342 
	`ªquúe
(
TLBPageLookup
.
	`homogíeous
(
edge
.
m™agî
.
m™agîs
, 
pgSize
), 
s
"All memoryÑegions must be $pgSize-byteáligned")

343 
åue
.
B


345 
	`TLBPageLookup
(
edge
.
m™agî
.
m™agîs
, 
xLí
, 
	`p
(
CacheBlockByãs
), 
pgSize
)(
±e_addr
).
homogíeous


348 
vÆ
 
pmaHomogíeous
 = 
	`pmaPgLevñHomogíeous
(
cou¡
)

349 
vÆ
 
pmpHomogíeous
 = 
√w
 
	`PMPHomogíeôyCheckî
(
io
.
d∑th
.
pmp
).
	`≠∂y
(
±e_addr
 >> 
pgIdxBôs
 <<ÖgIdxBôs, 
cou¡
)

350 
vÆ
 
homogíeous
 = 
pmaHomogíeous
 && 
pmpHomogíeous


353 
i
 <- 0 
u¡û
 
io
.
ªque°‹
.
size
) {

357 
io
.
	`ªque°‹
(
i
).
ª•
.
vÆid
 :
	`ª•_vÆid
(i)

358 
io
.
	`ªque°‹
(
i
).
ª•
.
bôs
.
´
 :
ª•_´


359 
io
.
	`ªque°‹
(
i
).
ª•
.
bôs
.
±e
 :
r_±e


360 
io
.
	`ªque°‹
(
i
).
ª•
.
bôs
.
Àvñ
 :
cou¡


361 
io
.
	`ªque°‹
(
i
).
ª•
.
bôs
.
homogíeous
 :homogíeou†|| 
∑geGønuœrôyPMPs


362 
io
.
	`ªque°‹
(
i
).
ª•
.
bôs
.
‰agmíãd_su≥Ωage
 :
ª•_‰agmíãd_su≥Ωage
 && 
∑geGønuœrôyPMPs


363 
io
.
	`ªque°‹
(
i
).
±br
 :io.
d∑th
.ptbr

364 
io
.
	`ªque°‹
(
i
).
cu°omCSRs
 :io.
d∑th
.customCSRs

365 
io
.
	`ªque°‹
(
i
).
°©us
 :io.
d∑th
.status

366 
io
.
	`ªque°‹
(
i
).
pmp
 :io.
d∑th
.pmp

370 
vÆ
 
√xt_°©e
 = 
	`Wúe
(
öô
 = 
°©e
)

371 
°©e
 :
	`O±imiz©i⁄B¨rõr
(
√xt_°©e
)

373 
°©e
) {

374 
	`is
 (
s_ªady
) {

375 
	`whí
 (
¨b
.
io
.
out
.
	`fúe
()) {

376 
√xt_°©e
 :
	`Mux
(
¨b
.
io
.
out
.
bôs
.
vÆid
, 
s_ªq
, 
s_ªady
)

378 
cou¡
 :
	`UI¡
(0)

380 
	`is
 (
s_ªq
) {

381 
	`whí
 (
±e_ˇche_hô
) {

382 
cou¡
 := count + 1

383 }.
Ÿhîwi£
 {

384 
√xt_°©e
 :
	`Mux
(
io
.
mem
.
ªq
.
ªady
, 
s_waô1
, 
s_ªq
)

387 
	`is
 (
s_waô1
) {

388 
√xt_°©e
 :
s_waô2


390 
	`is
 (
s_waô2
) {

391 
√xt_°©e
 :
s_waô3


392 
	`whí
 (
io
.
mem
.
s2_x˝t
.
´
.
ld
) {

393 
ª•_´
 :
åue


394 
√xt_°©e
 :
s_ªady


395 
	`ª•_vÆid
(
r_ªq_de°
Ë:
åue


398 
	`is
 (
s_‰agmít_su≥Ωage
) {

399 
√xt_°©e
 :
s_ªady


400 
	`ª•_vÆid
(
r_ªq_de°
Ë:
åue


401 
ª•_´
 :
Ál£


402 
	`whí
 (!
homogíeous
) {

403 
cou¡
 :
pgLevñs
-1

404 
ª•_‰agmíãd_su≥Ωage
 :
åue


409 
def
 
	`makePTE
(
µn
: 
UI¡
, : 
PTE
) = {

410 
vÆ
 
±e
 = 
	`Wúe
(
öô
 = )

411 
±e
.
µn
 :=Öpn

412 
±e


414 
vÆ
 
pCodeLock
 = 
	`ModuÀ
(
√w
 
	`PCodeLock
())

445 
def
 
r_±e_¥e
 = 
	`O±imiz©i⁄B¨rõr
(

446 
	`Mux
(
io
.
mem
.
ª•
.
vÆid
, 
±e
,

447 
	`Mux
(
l2_hô
, 
l2_±e
,

448 
	`Mux
(
°©e
 ==
s_‰agmít_su≥Ωage
 && !
homogíeous
, 
	`makePTE
(
‰agmíãd_su≥Ωage_µn
, 
r_±e
),

449 
	`Mux
(
°©e
 ==
s_ªq
 && 
±e_ˇche_hô
, 
	`makePTE
(
±e_ˇche_d©a
, 
l2_±e
),

450 
	`Mux
(
¨b
.
io
.
out
.
	`fúe
(), 
	`makePTE
(io.
d∑th
.
±br
.
µn
, 
r_±e
),

451 
r_±e
))))))

453 
pCodeLock
.
io
.
cfg
 :
pcode_cfg


454 
pCodeLock
.
io
.
ö
 :
r_±e_¥e


455 
r_±e
 :
pCodeLock
.
io
.
out


458 
	`whí
 (
l2_hô
) {

459 
	`as£π
(
°©e
 ==
s_ªq
 || sèã ==
s_waô1
)

460 
√xt_°©e
 :
s_ªady


461 
	`ª•_vÆid
(
r_ªq_de°
Ë:
åue


462 
ª•_´
 :
Ál£


463 
cou¡
 :
pgLevñs
-1

465 
	`whí
 (
io
.
mem
.
s2_«ck
) {

466 
	`as£π
(
°©e
 ==
s_waô2
)

467 
√xt_°©e
 :
s_ªq


469 
	`whí
 (
io
.
mem
.
ª•
.
vÆid
) {

470 
	`as£π
(
°©e
 ==
s_waô2
 || sèã ==
s_waô3
)

471 
	`whí
 (
åavî£
) {

472 
√xt_°©e
 :
s_ªq


473 
cou¡
 := count + 1

474 }.
Ÿhîwi£
 {

475 
l2_ªfûl
 :
±e
.
v
 && !
övÆid_∑ddr
 && 
cou¡
 ==
pgLevñs
-1

476 
vÆ
 
´
 = 
±e
.
v
 && 
övÆid_∑ddr


477 
ª•_´
 :
´


478 
	`whí
 (
∑geGønuœrôyPMPs
 && 
cou¡
 =/
pgLevñs
-1 && !
´
) {

479 
√xt_°©e
 :
s_‰agmít_su≥Ωage


480 }.
Ÿhîwi£
 {

481 
√xt_°©e
 :
s_ªady


482 
	`ª•_vÆid
(
r_ªq_de°
Ë:
åue


487 
i
 <- 0 
u¡û
 
pgLevñs
) {

488 
vÆ
 
Àaf
 = 
io
.
mem
.
ª•
.
vÆid
 && !
åavî£
 && 
cou¡
 ==
i


489 
	`ccovî
(
Àaf
 && 
±e
.
v
 && !
övÆid_∑ddr
, 
s
"L$i", s"successfulÖage-tableáccess,Üevel $i")

490 
	`ccovî
(
Àaf
 && 
±e
.
v
 && 
övÆid_∑ddr
, 
s
"L${i}_BAD_PPN_MSB", s"PPNÅooÜarge,Üevel $i")

491 
	`ccovî
(
Àaf
 && !
io
.
mem
.
ª•
.
bôs
.
	`d©a_w‹d_by∑ss
(0), 
s
"L${i}_INVALID_PTE", s"pageÇotÖresent,Üevel $i")

492 i‡(
i
 !
pgLevñs
-1)

493 
	`ccovî
(
Àaf
 && !
±e
.
v
 && 
io
.
mem
.
ª•
.
bôs
.
	`d©a_w‹d_by∑ss
(0), 
s
"L${i}_BAD_PPN_LSB", s"PPN LSBsÇot zero,Üevel $i")

495 
	`ccovî
(
io
.
mem
.
ª•
.
vÆid
 && 
cou¡
 ==
pgLevñs
-1 && 
±e
.
	`èbÀ
(), 
s
"TOO_DEEP", s"pageÅableÅoo deep")

496 
	`ccovî
(
io
.
mem
.
s2_«ck
, "NACK", "D$ÇackedÖage-tableáccess")

497 
	`ccovî
(
°©e
 ==
s_waô2
 && 
io
.
mem
.
s2_x˝t
.
´
.
ld
, "AE", "accessÉxception while walkingÖageÅable")

499 
	}
}

501 
¥iv©e
 
def
 
	$ccovî
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

502 i‡(
usögVM
Ë
	`covî
(
c⁄d
, 
s
"PTW_$œbñ", "Mem‹ySy°em;;" + 
desc
)

503 
	}
}

506 
åaô
 
C™HavePTW
 
exãnds
 
HasTûeP¨amëîs
 
wôh
 
	gHasHñœCache
 { 
	gthis
: 
Ba£Tûe
 =>

507 
vÆ
 
moduÀ
: 
C™HavePTWModuÀ


508 
v¨
 
nPTWP‹ts
 = 1

509 
nDCacheP‹ts
 +
usögPTW
.
toI¡


512 
åaô
 
C™HavePTWModuÀ
 
exãnds
 
HasHñœCacheModuÀ
 {

513 
vÆ
 
ouãr
: 
C™HavePTW


514 
vÆ
 
±wP‹ts
 = 
Li°Buf„r
(
ouãr
.
dˇche
.
moduÀ
.
io
.
±w
)

515 
vÆ
 
±w
 = 
ModuÀ
(
√w
 
PTW
(
ouãr
.
nPTWP‹ts
)(ouãr.
dˇche
.
node
.
edges
.
out
(0), ouãr.
p
))

516 i‡(
	gouãr
.
	gusögPTW
)

517 
	gdˇcheP‹ts
 +
±w
.
io
.
mem


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RVC.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 ˛as†
	cEx∑ndedIn°ru˘i⁄
 
exãnds
 
	mBundÀ
 {

12 
vÆ
 
	mbôs
 = 
	$UI¡
(
width
 = 32)

13 
vÆ
 
rd
 = 
	$UI¡
(
width
 = 5)

14 
vÆ
 
rs1
 = 
	$UI¡
(
width
 = 5)

15 
vÆ
 
rs2
 = 
	$UI¡
(
width
 = 5)

16 
vÆ
 
rs3
 = 
	`UI¡
(
width
 = 5)

19 
˛ass
 
	$RVCDecodî
(
x
: 
UI¡
, 
xLí
: 
I¡
) {

20 
def
 
	`ö°
(
bôs
: 
UI¡
, 
rd
: UI¡ = 
	`x
(11,7), 
rs1
: UI¡ = x(19,15), 
rs2
: UI¡ = x(24,20), 
rs3
: UInt = x(31,27)) = {

21 
vÆ
 
ªs
 = 
	`Wúe
(
√w
 
Ex∑ndedIn°ru˘i⁄
)

22 
ªs
.
bôs
 := bits

23 
ªs
.
rd
 :=Ñd

24 
ªs
.
rs1
 :=Ñs1

25 
ªs
.
rs2
 :=Ñs2

26 
ªs
.
rs3
 :=Ñs3

27 
ªs


30 
def
 
rs1p
 = 
	`C©
(
	`UI¡
(1,2), 
	`x
(9,7))

31 
def
 
rs2p
 = 
	`C©
(
	`UI¡
(1,2), 
	`x
(4,2))

32 
def
 
rs2
 = 
	`x
(6,2)

33 
def
 
rd
 = 
	`x
(11,7)

34 
def
 
addi4•nImm
 = 
	`C©
(
	`x
(10,7), x(12,11), x(5), x(6), 
	`UI¡
(0,2))

35 
def
 
lwImm
 = 
	`C©
(
	`x
(5), x(12,10), x(6), 
	`UI¡
(0,2))

36 
def
 
ldImm
 = 
	`C©
(
	`x
(6,5), x(12,10), 
	`UI¡
(0,3))

37 
def
 
lw•Imm
 = 
	`C©
(
	`x
(3,2), x(12), x(6,4), 
	`UI¡
(0,2))

38 
def
 
ld•Imm
 = 
	`C©
(
	`x
(4,2), x(12), x(6,5), 
	`UI¡
(0,3))

39 
def
 
sw•Imm
 = 
	`C©
(
	`x
(8,7), x(12,9), 
	`UI¡
(0,2))

40 
def
 
sd•Imm
 = 
	`C©
(
	`x
(9,7), x(12,10), 
	`UI¡
(0,3))

41 
def
 
luiImm
 = 
	`C©
(
	`Fûl
(15, 
	`x
(12)), x(6,2), 
	`UI¡
(0,12))

42 
def
 
addi16•Imm
 = 
	`C©
(
	`Fûl
(3, 
	`x
(12)), x(4,3), x(5), x(2), x(6), 
	`UI¡
(0,4))

43 
def
 
addiImm
 = 
	`C©
(
	`Fûl
(7, 
	`x
(12)), x(6,2))

44 
def
 
jImm
 = 
	`C©
(
	`Fûl
(10, 
	`x
(12)), x(8), x(10,9), x(6), x(7), x(2), x(11), x(5,3), 
	`UI¡
(0,1))

45 
def
 
bImm
 = 
	`C©
(
	`Fûl
(5, 
	`x
(12)), x(6,5), x(2), x(11,10), x(4,3), 
	`UI¡
(0,1))

46 
def
 
shamt
 = 
	`C©
(
	`x
(12), x(6,2))

47 
def
 
x0
 = 
	`UI¡
(0,5)

48 
def
 
ø
 = 
	`UI¡
(1,5)

49 
def
 
•
 = 
	`UI¡
(2,5)

51 
def
 
q0
 = {

52 
def
 
addi4•n
 = {

53 
vÆ
 
›c
 = 
	`Mux
(
	`x
(12,5).
‹R
, 
	`UI¡
(0x13,7), UInt(0x1F,7))

54 
	`ö°
(
	`C©
(
addi4•nImm
, 
•
, 
	`UI¡
(0,3), 
rs2p
, 
›c
),Ñs2p, sp,Ñs2p)

56 
def
 
ld
 = 
	`ö°
(
	`C©
(
ldImm
, 
rs1p
, 
	`UI¡
(3,3), 
rs2p
, UInt(0x03,7)),Ñs2p,Ñs1p,Ñs2p)

57 
def
 
lw
 = 
	`ö°
(
	`C©
(
lwImm
, 
rs1p
, 
	`UI¡
(2,3), 
rs2p
, UInt(0x03,7)),Ñs2p,Ñs1p,Ñs2p)

58 
def
 
Êd
 = 
	`ö°
(
	`C©
(
ldImm
, 
rs1p
, 
	`UI¡
(3,3), 
rs2p
, UInt(0x07,7)),Ñs2p,Ñs1p,Ñs2p)

59 
def
 
Êw
 = {

60 i‡(
xLí
 =32Ë
	`ö°
(
	`C©
(
lwImm
, 
rs1p
, 
	`UI¡
(2,3), 
rs2p
, UInt(0x07,7)),Ñs2p,Ñs1p,Ñs2p)

61 
ld


63 
def
 
unimp
 = 
	`ö°
(
	`C©
(
lwImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UI¡
(2,3), 
	`lwImm
(4,0), UInt(0x3F,7)),Ñs2p,Ñs1p,Ñs2p)

64 
def
 
sd
 = 
	`ö°
(
	`C©
(
ldImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UI¡
(3,3), 
	`ldImm
(4,0), UInt(0x23,7)),Ñs2p,Ñs1p,Ñs2p)

65 
def
 
sw
 = 
	`ö°
(
	`C©
(
lwImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UI¡
(2,3), 
	`lwImm
(4,0), UInt(0x23,7)),Ñs2p,Ñs1p,Ñs2p)

66 
def
 
fsd
 = 
	`ö°
(
	`C©
(
ldImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UI¡
(3,3), 
	`ldImm
(4,0), UInt(0x27,7)),Ñs2p,Ñs1p,Ñs2p)

67 
def
 
fsw
 = {

68 i‡(
xLí
 =32Ë
	`ö°
(
	`C©
(
lwImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UI¡
(2,3), 
	`lwImm
(4,0), UInt(0x27,7)),Ñs2p,Ñs1p,Ñs2p)

69 
sd


71 
	`Seq
(
addi4•n
, 
Êd
, 
lw
, 
Êw
, 
unimp
, 
fsd
, 
sw
, 
fsw
)

74 
def
 
q1
 = {

75 
def
 
addi
 = 
	`ö°
(
	`C©
(
addiImm
, 
rd
, 
	`UI¡
(0,3),Ñd, UI¡(0x13,7)),Ñd,Ñd, 
rs2p
)

76 
def
 
addiw
 = {

77 
vÆ
 
›c
 = 
	`Mux
(
rd
.
‹R
, 
	`UI¡
(0x1B,7), UInt(0x1F,7))

78 
	`ö°
(
	`C©
(
addiImm
, 
rd
, 
	`UI¡
(0,3),Ñd, 
›c
),Ñd,Ñd, 
rs2p
)

80 
def
 
jÆ
 = {

81 i‡(
xLí
 =32Ë
	`ö°
(
	`C©
(
	`jImm
(20), jImm(10,1), jImm(11), jImm(19,12), 
ø
, 
	`UI¡
(0x6F,7)),Ña, 
rd
, 
rs2p
)

82 
addiw


84 
def
 
li
 = 
	`ö°
(
	`C©
(
addiImm
, 
x0
, 
	`UI¡
(0,3), 
rd
, UI¡(0x13,7)),Ñd, x0, 
rs2p
)

85 
def
 
addi16•
 = {

86 
vÆ
 
›c
 = 
	`Mux
(
addiImm
.
‹R
, 
	`UI¡
(0x13,7), UInt(0x1F,7))

87 
	`ö°
(
	`C©
(
addi16•Imm
, 
rd
, 
	`UI¡
(0,3),Ñd, 
›c
),Ñd,Ñd, 
rs2p
)

89 
def
 
lui
 = {

90 
vÆ
 
›c
 = 
	`Mux
(
addiImm
.
‹R
, 
	`UI¡
(0x37,7), UInt(0x3F,7))

91 
vÆ
 
me
 = 
	`ö°
(
	`C©
(
	`luiImm
(31,12), 
rd
, 
›c
),Ñd,Ñd, 
rs2p
)

92 
	`Mux
(
rd
 ==
x0
 ||Ñd ==
•
, 
addi16•
, 
me
)

94 
def
 
j
 = 
	`ö°
(
	`C©
(
	`jImm
(20), jImm(10,1), jImm(11), jImm(19,12), 
x0
, 
	`UI¡
(0x6F,7)), x0, 
rs1p
, 
rs2p
)

95 
def
 
beqz
 = 
	`ö°
(
	`C©
(
	`bImm
(12), bImm(10,5), 
x0
, 
rs1p
, 
	`UI¡
(0,3), bImm(4,1), bImm(11), UInt(0x63,7)),Ñs1p,Ñs1p, x0)

96 
def
 
b√z
 = 
	`ö°
(
	`C©
(
	`bImm
(12), bImm(10,5), 
x0
, 
rs1p
, 
	`UI¡
(1,3), bImm(4,1), bImm(11), UInt(0x63,7)), x0,Ñs1p, x0)

97 
def
 
¨ôh
 = {

98 
def
 
§li
 = 
	`C©
(
shamt
, 
rs1p
, 
	`UI¡
(5,3),Ñs1p, UInt(0x13,7))

99 
def
 
§ai
 = 
§li
 | 
	`UI¡
(1 << 30)

100 
def
 
™di
 = 
	`C©
(
addiImm
, 
rs1p
, 
	`UI¡
(7,3),Ñs1p, UInt(0x13,7))

101 
def
 
πy≥
 = {

102 
vÆ
 
fun˘
 = 
	`Seq
(0.U, 4.U, 6.U, 7.U, 0.U, 0.U, 2.U, 3.U)(
	`C©
(
	`x
(12), x(6,5)))

103 
vÆ
 
sub
 = 
	`Mux
(
	`x
(6,5Ë==
	`UI¡
(0), UInt(1 << 30), UInt(0))

104 
vÆ
 
›c
 = 
	`Mux
(
	`x
(12), 
	`UI¡
(0x3B,7), UInt(0x33,7))

105 
	`C©
(
rs2p
, 
rs1p
, 
fun˘
,Ñs1p, 
›c
Ë| 
sub


107 
	`ö°
(
	`Seq
(
§li
, 
§ai
, 
™di
, 
πy≥
)(
	`x
(11,10)), 
rs1p
,Ñs1p, 
rs2p
)

109 
	`Seq
(
addi
, 
jÆ
, 
li
, 
lui
, 
¨ôh
, 
j
, 
beqz
, 
b√z
)

112 
def
 
q2
 = {

113 
vÆ
 
lﬂd_›c
 = 
	`Mux
(
rd
.
‹R
, 
	`UI¡
(0x03,7), UInt(0x1F,7))

114 
def
 
¶li
 = 
	`ö°
(
	`C©
(
shamt
, 
rd
, 
	`UI¡
(1,3),Ñd, UI¡(0x13,7)),Ñd,Ñd, 
rs2
)

115 
def
 
ld•
 = 
	`ö°
(
	`C©
(
ld•Imm
, 
•
, 
	`UI¡
(3,3), 
rd
, 
lﬂd_›c
),Ñd, sp, 
rs2
)

116 
def
 
lw•
 = 
	`ö°
(
	`C©
(
lw•Imm
, 
•
, 
	`UI¡
(2,3), 
rd
, 
lﬂd_›c
),Ñd, sp, 
rs2
)

117 
def
 
Êd•
 = 
	`ö°
(
	`C©
(
ld•Imm
, 
•
, 
	`UI¡
(3,3), 
rd
, UI¡(0x07,7)),Ñd, sp, 
rs2
)

118 
def
 
Êw•
 = {

119 i‡(
xLí
 =32Ë
	`ö°
(
	`C©
(
lw•Imm
, 
•
, 
	`UI¡
(2,3), 
rd
, UI¡(0x07,7)),Ñd, sp, 
rs2
)

120 
ld•


122 
def
 
sd•
 = 
	`ö°
(
	`C©
(
sd•Imm
 >> 5, 
rs2
, 
•
, 
	`UI¡
(3,3), 
	`sd•Imm
(4,0), UI¡(0x23,7)), 
rd
, sp,Ñs2)

123 
def
 
sw•
 = 
	`ö°
(
	`C©
(
sw•Imm
 >> 5, 
rs2
, 
•
, 
	`UI¡
(2,3), 
	`sw•Imm
(4,0), UI¡(0x23,7)), 
rd
, sp,Ñs2)

124 
def
 
fsd•
 = 
	`ö°
(
	`C©
(
sd•Imm
 >> 5, 
rs2
, 
•
, 
	`UI¡
(3,3), 
	`sd•Imm
(4,0), UI¡(0x27,7)), 
rd
, sp,Ñs2)

125 
def
 
fsw•
 = {

126 i‡(
xLí
 =32Ë
	`ö°
(
	`C©
(
sw•Imm
 >> 5, 
rs2
, 
•
, 
	`UI¡
(2,3), 
	`sw•Imm
(4,0), UI¡(0x27,7)), 
rd
, sp,Ñs2)

127 
sd•


129 
def
 
jÆr
 = {

130 
vÆ
 
mv
 = 
	`ö°
(
	`C©
(
rs2
, 
x0
, 
	`UI¡
(0,3), 
rd
, UInt(0x33,7)),Ñd, x0,Ñs2)

131 
vÆ
 
add
 = 
	`ö°
(
	`C©
(
rs2
, 
rd
, 
	`UI¡
(0,3),Ñd, UInt(0x33,7)),Ñd,Ñd,Ñs2)

132 
vÆ
 
jr
 = 
	`C©
(
rs2
, 
rd
, 
	`UI¡
(0,3), 
x0
, UInt(0x67,7))

133 
vÆ
 
ª£rved
 = 
	`C©
(
jr
 >> 7, 
	`UI¡
(0x1F,7))

134 
vÆ
 
jr_ª£rved
 = 
	`ö°
(
	`Mux
(
rd
.
‹R
, 
jr
, 
ª£rved
), 
x0
,Ñd, 
rs2
)

135 
vÆ
 
jr_mv
 = 
	`Mux
(
rs2
.
‹R
, 
mv
, 
jr_ª£rved
)

136 
vÆ
 
jÆr
 = 
	`C©
(
rs2
, 
rd
, 
	`UI¡
(0,3), 
ø
, UInt(0x67,7))

137 
vÆ
 
ebªak
 = 
	`C©
(
jr
 >> 7, 
	`UI¡
(0x73,7)) | UInt(1 << 20)

138 
vÆ
 
jÆr_ebªak
 = 
	`ö°
(
	`Mux
(
rd
.
‹R
, 
jÆr
, 
ebªak
), 
ø
,Ñd, 
rs2
)

139 
vÆ
 
jÆr_add
 = 
	`Mux
(
rs2
.
‹R
, 
add
, 
jÆr_ebªak
)

140 
	`Mux
(
	`x
(12), 
jÆr_add
, 
jr_mv
)

142 
	`Seq
(
¶li
, 
Êd•
, 
lw•
, 
Êw•
, 
jÆr
, 
fsd•
, 
sw•
, 
fsw•
)

145 
def
 
q3
 = 
Seq
.
	`fûl
(8)(
∑s°hrough
)

147 
def
 
∑s°hrough
 = 
	`ö°
(
x
)

149 
def
 
decode
 = {

150 
vÆ
 
s
 = 
q0
 ++ 
q1
 ++ 
q2
 ++ 
q3


151 
	`s
(
	`C©
(
	`x
(1,0), x(15,13)))

153 
	}
}

155 ˛as†
	cRVCEx∑ndî
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 
wôh
 
HasC‹eP¨amëîs
 {

156 
vÆ
 
io
 = 
√w
 
BundÀ
 {

157 
vÆ
 
ö
 = 
	`UI¡
(
INPUT
, 32)

158 
vÆ
 
out
 = 
√w
 
Ex∑ndedIn°ru˘i⁄


159 
vÆ
 
rvc
 = 
	`Boﬁ
(
OUTPUT
)

162 i‡(
usögCom¥es£d
) {

163 
io
.
rvc
 :io.
	`ö
(1,0Ë=/
	`UI¡
(3)

164 
io
.
out
 :
√w
 
	`RVCDecodî
(io.
ö
, 
	`p
(
XLí
)).
decode


165 
	}
} {

166 
	gio
.
	grvc
 :
Boﬁ
(
Ál£
)

167 
io
.
out
 :
√w
 
RVCDecodî
(io.
ö
, 
p
(
XLí
)).
	g∑s°hrough


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RocketCore.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gscõ
.
_


14 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gimmuèbÀ
.
Li°M≠


15 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
AºayBuf„r


17 
˛ass
 
RockëC‹eP¨ams
(

18 
boŸFªqHz
: 
BigI¡
 = 0,

19 
u£VM
: 
Boﬁón
 = 
åue
,

20 
u£U£r
: 
Boﬁón
 = 
Ál£
,

21 
u£Debug
: 
Boﬁón
 = 
åue
,

22 
u£Atomics
: 
Boﬁón
 = 
åue
,

23 
u£AtomicsO∆yF‹IO
: 
Boﬁón
 = 
Ál£
,

24 
u£Com¥es£d
: 
Boﬁón
 = 
åue
,

25 
u£SCIE
: 
Boﬁón
 = 
Ál£
,

26 
nLoˇlI¡îru±s
: 
I¡
 = 0,

27 
nBªakpoöts
: 
I¡
 = 1,

28 
nPMPs
: 
I¡
 = 8,

29 
nPîfCou¡îs
: 
I¡
 = 0,

30 
haveBasicCou¡îs
: 
Boﬁón
 = 
åue
,

31 
mißWrôabÀ
: 
Boﬁón
 = 
åue
,

32 
nL2TLBE¡rõs
: 
I¡
 = 0,

33 
mtvecInô
: 
O±i⁄
[
BigI¡
] = 
Some
(BigInt(0)),

34 
mtvecWrôabÀ
: 
Boﬁón
 = 
åue
,

35 
Á°LﬂdW‹d
: 
Boﬁón
 = 
åue
,

36 
Á°LﬂdByã
: 
Boﬁón
 = 
Ál£
,

37 
bønchPªdi˘i⁄ModeCSR
: 
Boﬁón
 = 
Ál£
,

38 
tûeC⁄åﬁAddr
: 
O±i⁄
[
BigI¡
] = 
N⁄e
,

39 
˛ockG©e
: 
Boﬁón
 = 
Ál£
,

40 
mvíd‹id
: 
I¡
 = 0,

41 
mulDiv
: 
O±i⁄
[
MulDivP¨ams
] = 
Some
(MulDivParams()),

42 
Âu
: 
O±i⁄
[
FPUP¨ams
] = 
Some
(FPUParams()),

43 
ovîride
 
vÆ
 
hasPrivCodeLock
: 
Boﬁón
 = 
Ál£
,

44 
ovîride
 
vÆ
 
numPCodeR™ges
: 
I¡
 = 8

45 Ë
exãnds
 
C‹eP¨ams
 {

46 
vÆ
 
haveFSDúty
 = 
Ál£


47 
vÆ
 
pmpGønuœrôy
: 
I¡
 = 4

48 
vÆ
 
„tchWidth
: 
I¡
 = i‡(
u£Com¥es£d
) 2 1

50 
vÆ
 
decodeWidth
: 
I¡
 = 
„tchWidth
 / (i‡(
u£Com¥es£d
) 2 1)

51 
vÆ
 
ªtúeWidth
: 
I¡
 = 1

52 
vÆ
 
ö°Bôs
: 
I¡
 = i‡(
u£Com¥es£d
) 16 32

53 
vÆ
 
ÃscCy˛es
: 
I¡
 = 80

54 
ovîride
 
def
 
cu°omCSRs
(
im∂icô
 
p
: 
P¨amëîs
Ë
√w
 
RockëCu°omCSRs


57 
åaô
 
HasRockëC‹eP¨amëîs
 
exãnds
 
HasC‹eP¨amëîs
 {

58 
œzy
 
vÆ
 
rockëP¨ams
: 
RockëC‹eP¨ams
 = 
tûeP¨ams
.
c‹e
.
asIn°™˚Of
[RocketCoreParams]

60 
vÆ
 
Á°LﬂdW‹d
 = 
rockëP¨ams
.fastLoadWord

61 
vÆ
 
Á°LﬂdByã
 = 
rockëP¨ams
.fastLoadByte

63 
vÆ
 
mulDivP¨ams
 = 
rockëP¨ams
.
mulDiv
.
gëOrEl£
(
MulDivP¨ams
())

65 
ªquúe
(!
Á°LﬂdByã
 || 
Á°LﬂdW‹d
)

68 ˛as†
	cRockëCu°omCSRs
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
Cu°omCSRs
 
wôh
 
HasRockëC‹eP¨amëîs
 {

69 
ovîride
 
def
 
bpmCSR
 = {

70 
rockëP¨ams
.
bønchPªdi˘i⁄ModeCSR
.
	`›ti⁄
(
	`Cu°omCSR
(
bpmCSRId
, 
	`BigI¡
(1), 
	`Some
(BigInt(0))))

73 
ovîride
 
def
 
chickíCSR
 = {

74 
vÆ
 
mask
 = 
	`BigI¡
(

75 
tûeP¨ams
.
dˇche
.
gë
.
˛ockG©e
.
toI¡
 << 0 |

76 
rockëP¨ams
.
˛ockG©e
.
toI¡
 << 1 |

77 
rockëP¨ams
.
˛ockG©e
.
toI¡
 << 2

79 
	`Some
(
	`Cu°omCSR
(
chickíCSRId
, 
mask
, Some(mask)))

80 
	}
}

82 
def
 
	gm¨chid
 = 
Cu°omCSR
.
c⁄°™t
(
CSRs
.
m¨chid
, 
	$BigI¡
(1))

84 
def
 
mvíd‹id
 = 
Cu°omCSR
.
	`c⁄°™t
(
CSRs
.mvíd‹id, 
	$BigI¡
(
rockëP¨ams
.
mvíd‹id
))

93 
def
 
d©e°amp
 = 0x20181004

94 
def
 
mimpidVÆ
 = i‡(
hasPrivCodeLock
) {

95 0x04000000 & 
d©e°amp


96 
	}
} {

97 
d©e°amp


99 
def
 
mimpid
 = 
Cu°omCSR
.
c⁄°™t
(
CSRs
.mimpid, 
	$BigI¡
(
mimpidVÆ
))

101 
ovîride
 
def
 
de˛s
 = 
su≥r
.de˛†:+ 
m¨chid
 :+ 
mvíd‹id
 :+ 
mimpid


103 
	}
}

105 @
chi£lName


106 ˛as†
	cRockë
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
)

107 
wôh
 
HasRockëC‹eP¨amëîs


108 
wôh
 
HasC‹eIO
 {

110 
vÆ
 
˛ock_í_ªg
 = 
	$RegInô
(
åue
.
B
)

111 
vÆ
 
l⁄g_œãncy_°Æl
 = 
	`Reg
(
	$Boﬁ
())

112 
vÆ
 
imem_might_ªque°_ªg
 = 
	`Reg
(
	$Boﬁ
())

113 
vÆ
 
˛ock_í
 = 
	$Wúe
(
öô
=
åue
.
B
)

114 
vÆ
 
g©ed_˛ock
 =

115 i‡(!
rockëP¨ams
.
˛ockG©e
Ë
˛ock


116 
	`ClockG©e
(
˛ock
, 
˛ock_í
, "rocket_clock_gate")

118 @
chi£lName
 cœs†
	cRockëIm∂
 {

121 
def
 
pùñöeIDToWB
[
T
 <: 
D©a
](
x
: T): T =

122 
	`RegE«bÀ
(RegE«bÀ(RegE«bÀ(
x
, !
˘æ_kûld
), 
ex_pc_vÆid
), 
mem_pc_vÆid
)

123 
vÆ
 
≥rfEvíts
 = 
√w
 
	`EvítSës
(
	`Seq
(

124 
√w
 
	`EvítSë
((
mask
, 
hôs
Ë=> 
	`Mux
(
	`mask
(0), 
wb_x˝t
, 
wb_vÆid
 && 
	`pùñöeIDToWB
((mask & hôs).
‹R
)), 
	`Seq
(

125 ("ex˚±i⁄", (Ë=> 
Ál£
.
B
),

126 ("lﬂd", (Ë=> 
id_˘æ
.
mem
 && id_˘æ.
mem_cmd
 ==
M_XRD
 && !id_˘æ.
Â
),

127 ("°‹e", (Ë=> 
id_˘æ
.
mem
 && id_˘æ.
mem_cmd
 ==
M_XWR
 && !id_˘æ.
Â
),

128 ("amo", (Ë=> 
	`Boﬁ
(
usögAtomics
Ë&& 
id_˘æ
.
mem
 && (
	`isAMO
(id_˘æ.
mem_cmd
Ë|| id_˘æ.mem_cmd.
	`isO√Of
(
M_XLR
, 
M_XSC
))),

129 ("sy°em", (Ë=> 
id_˘æ
.
c§
 =/
CSR
.
N
),

130 ("¨ôh", (Ë=> 
id_˘æ
.
wxd
 && !(id_˘æ.
jÆ
 || id_˘æ.
jÆr
 || id_˘æ.
mem
 || id_˘æ.
Â
 || id_˘æ.
mul
 || id_˘æ.
div
 || id_˘æ.
c§
 =/
CSR
.
N
)),

131 ("bønch", (Ë=> 
id_˘æ
.
bønch
),

132 ("jÆ", (Ë=> 
id_˘æ
.
jÆ
),

133 ("jÆr", (Ë=> 
id_˘æ
.
jÆr
))

134 ++ (i‡(!
usögMulDiv
Ë
	`Seq
() Seq(

135 ("mul", (Ë=> i‡(
pùñöedMul
Ë
id_˘æ
.
mul
 id_˘æ.
div
 && (id_˘æ.
Æu_‚
 & 
ALU
.
FN_DIV
) =/= ALU.FN_DIV),

136 ("div", (Ë=> i‡(
pùñöedMul
Ë
id_˘æ
.
div
 id_˘æ.div && (id_˘æ.
Æu_‚
 & 
ALU
.
FN_DIV
) === ALU.FN_DIV)))

137 ++ (i‡(!
usögFPU
Ë
	`Seq
() Seq(

138 ("ÂÜﬂd", (Ë=> 
id_˘æ
.
Â
 && 
io
.
Âu
.
dec
.
ld°
 && io.Âu.dec.
wí
),

139 ("Â st‹e", (Ë=> 
id_˘æ
.
Â
 && 
io
.
Âu
.
dec
.
ld°
 && !io.Âu.dec.
wí
),

140 ("Âádd", (Ë=> 
id_˘æ
.
Â
 && 
io
.
Âu
.
dec
.
fma
 && io.Âu.dec.
sw≠23
),

141 ("Â mul", (Ë=> 
id_˘æ
.
Â
 && 
io
.
Âu
.
dec
.
fma
 && !io.Âu.dec.
sw≠23
 && !io.Âu.dec.
ªn3
),

142 ("Â mul-add", (Ë=> 
id_˘æ
.
Â
 && 
io
.
Âu
.
dec
.
fma
 && io.Âu.dec.
ªn3
),

143 ("Â div/sqπ", (Ë=> 
id_˘æ
.
Â
 && (
io
.
Âu
.
dec
.
div
 || io.Âu.dec.
sqπ
)),

144 ("Â othî", (Ë=> 
id_˘æ
.
Â
 && !(
io
.
Âu
.
dec
.
ld°
 || io.Âu.dec.
fma
 || io.Âu.dec.
div
 || io.Âu.dec.
sqπ
))))),

145 
√w
 
	`EvítSë
((
mask
, 
hôs
Ë=> (mask & hôs).
‹R
, 
	`Seq
(

146 ("lﬂd-u£ i¡îlock", (Ë=> 
id_ex_haz¨d
 && 
ex_˘æ
.
mem
 || 
id_mem_haz¨d
 && 
mem_˘æ
.mem || 
id_wb_haz¨d
 && 
wb_˘æ
.mem),

147 ("l⁄g-œãncy i¡îlock", (Ë=> 
id_sbﬂrd_haz¨d
),

148 ("c§ i¡îlock", (Ë=> 
id_ex_haz¨d
 && 
ex_˘æ
.
c§
 =/
CSR
.
N
 || 
id_mem_haz¨d
 && 
mem_˘æ
.c§ =/CSR.N || 
id_wb_haz¨d
 && 
wb_˘æ
.csr =/= CSR.N),

149 ("I$ blocked", (Ë=> 
iˇche_blocked
),

150 ("D$ blocked", (Ë=> 
id_˘æ
.
mem
 && 
dˇche_blocked
),

151 ("bønch mi•ªdi˘i⁄", (Ë=> 
èke_pc_mem
 && 
mem_dúe˘i⁄_mi•ªdi˘i⁄
),

152 ("c⁄åﬁ-ÊowÅ¨gë mi•ªdi˘i⁄", (Ë=> 
èke_pc_mem
 && 
mem_mi•ªdi˘i⁄
 && 
mem_cfi
 && !
mem_dúe˘i⁄_mi•ªdi˘i⁄
 && !
iˇche_blocked
),

153 ("Êush", (Ë=> 
wb_ªg_Êush_pùe
),

154 ("ª∂ay", (Ë=> 
ª∂ay_wb
))

155 ++ (i‡(!
usögMulDiv
Ë
	`Seq
() Seq(

156 ("mul/div i¡îlock", (Ë=> 
id_ex_haz¨d
 && (
ex_˘æ
.
mul
 ||Éx_˘æ.
div
Ë|| 
id_mem_haz¨d
 && (
mem_˘æ
.mu»|| mem_˘æ.divË|| 
id_wb_haz¨d
 && 
wb_˘æ
.div)))

157 ++ (i‡(!
usögFPU
Ë
	`Seq
() Seq(

158 ("Â i¡îlock", (Ë=> 
id_ex_haz¨d
 && 
ex_˘æ
.
Â
 || 
id_mem_haz¨d
 && 
mem_˘æ
.Â || 
id_wb_haz¨d
 && 
wb_˘æ
.Â || 
id_˘æ
.Â && 
id_°Æl_Âu
)))),

159 
√w
 
	`EvítSë
((
mask
, 
hôs
Ë=> (mask & hôs).
‹R
, 
	`Seq
(

160 ("I$ miss", (Ë=> 
io
.
imem
.
≥rf
.
acquúe
),

161 ("D$ miss", (Ë=> 
io
.
dmem
.
≥rf
.
acquúe
),

162 ("D$Ññó£", (Ë=> 
io
.
dmem
.
≥rf
.
ªÀa£
),

163 ("ITLB miss", (Ë=> 
io
.
imem
.
≥rf
.
ébMiss
),

164 ("DTLB miss", (Ë=> 
io
.
dmem
.
≥rf
.
ébMiss
),

165 ("L2 TLB miss", (Ë=> 
io
.
±w
.
≥rf
.
l2miss
)))))

167 
vÆ
 
pùñöedMul
 = 
usögMulDiv
 && 
mulDivP¨ams
.
mulUƒﬁl
 =
xLí


168 
vÆ
 
decode_èbÀ
 = {

169 
	`ªquúe
(!
usögRoCC
 || !
rockëP¨ams
.
u£SCIE
)

170 (i‡(
usögMulDiv
Ë
√w
 
	`MDecode
(
pùñöedMul
Ë+: (
xLí
 > 32).
	`›ti⁄
“ew 
	`M64Decode
’ùñöedMul)).
toSeq
 
Nû
) ++:

171 (i‡(
usögAtomics
Ë
√w
 
ADecode
 +: (
xLí
 > 32).
	`›ti⁄
“ew 
A64Decode
).
toSeq
 
Nû
) ++:

172 (i‡(
fLí
 >32Ë
√w
 
FDecode
 +: (
xLí
 > 32).
	`›ti⁄
“ew 
F64Decode
).
toSeq
 
Nû
) ++:

173 (i‡(
fLí
 >64Ë
√w
 
DDecode
 +: (
xLí
 > 32).
	`›ti⁄
“ew 
D64Decode
).
toSeq
 
Nû
) ++:

174 (
usögRoCC
.
	`›ti⁄
(
√w
 
RoCCDecode
)) ++:

175 (
rockëP¨ams
.
u£SCIE
.
	`›ti⁄
(
√w
 
SCIEDecode
)) ++:

176 (i‡(
xLí
 =32Ë
√w
 
I32Decode
 √w 
I64Decode
) +:

177 (
usögVM
.
	`›ti⁄
(
√w
 
SDecode
)) ++:

178 (
usögDebug
.
	`›ti⁄
(
√w
 
DebugDecode
)) ++:

179 
	`Seq
(
√w
 
IDecode
)

180 } 
	`Ê©M≠
(
_
.
èbÀ
)

182 
vÆ
 
ex_˘æ
 = 
	`Reg
(
√w
 
I¡CålSigs
)

183 
vÆ
 
mem_˘æ
 = 
	`Reg
(
√w
 
I¡CålSigs
)

184 
vÆ
 
wb_˘æ
 = 
	`Reg
(
√w
 
I¡CålSigs
)

186 
vÆ
 
ex_ªg_x˝t_öãºu±
 = 
	`Reg
(
	`Boﬁ
())

187 
vÆ
 
ex_ªg_vÆid
 = 
	`Reg
(
	`Boﬁ
())

188 
vÆ
 
ex_ªg_rvc
 = 
	`Reg
(
	`Boﬁ
())

189 
vÆ
 
ex_ªg_btb_ª•
 = 
	`Reg
(
√w
 
BTBRe•
)

190 
vÆ
 
ex_ªg_x˝t
 = 
	`Reg
(
	`Boﬁ
())

191 
vÆ
 
ex_ªg_Êush_pùe
 = 
	`Reg
(
	`Boﬁ
())

192 
vÆ
 
ex_ªg_lﬂd_u£
 = 
	`Reg
(
	`Boﬁ
())

193 
vÆ
 
ex_ªg_ˇu£
 = 
	`Reg
(
	`UI¡
())

194 
vÆ
 
ex_ªg_ª∂ay
 = 
	`Reg
(
	`Boﬁ
())

195 
vÆ
 
ex_ªg_pc
 = 
	`Reg
(
	`UI¡
())

196 
vÆ
 
ex_ªg_ö°
 = 
	`Reg
(
	`Bôs
())

197 
vÆ
 
ex_ªg_øw_ö°
 = 
	`Reg
(
	`UI¡
())

199 
vÆ
 
mem_ªg_x˝t_öãºu±
 = 
	`Reg
(
	`Boﬁ
())

200 
vÆ
 
mem_ªg_vÆid
 = 
	`Reg
(
	`Boﬁ
())

201 
vÆ
 
mem_ªg_rvc
 = 
	`Reg
(
	`Boﬁ
())

202 
vÆ
 
mem_ªg_btb_ª•
 = 
	`Reg
(
√w
 
BTBRe•
)

203 
vÆ
 
mem_ªg_x˝t
 = 
	`Reg
(
	`Boﬁ
())

204 
vÆ
 
mem_ªg_ª∂ay
 = 
	`Reg
(
	`Boﬁ
())

205 
vÆ
 
mem_ªg_Êush_pùe
 = 
	`Reg
(
	`Boﬁ
())

206 
vÆ
 
mem_ªg_ˇu£
 = 
	`Reg
(
	`UI¡
())

207 
vÆ
 
mem_ªg_¶ow_by∑ss
 = 
	`Reg
(
	`Boﬁ
())

208 
vÆ
 
mem_ªg_lﬂd
 = 
	`Reg
(
	`Boﬁ
())

209 
vÆ
 
mem_ªg_°‹e
 = 
	`Reg
(
	`Boﬁ
())

210 
vÆ
 
mem_ªg_s„n˚
 = 
	`Reg
(
	`Boﬁ
())

211 
vÆ
 
mem_ªg_pc
 = 
	`Reg
(
	`UI¡
())

212 
vÆ
 
mem_ªg_ö°
 = 
	`Reg
(
	`Bôs
())

213 
vÆ
 
mem_ªg_øw_ö°
 = 
	`Reg
(
	`UI¡
())

214 
vÆ
 
mem_ªg_wd©a
 = 
	`Reg
(
	`Bôs
())

215 
vÆ
 
mem_ªg_rs2
 = 
	`Reg
(
	`Bôs
())

216 
vÆ
 
mem_br_èkí
 = 
	`Reg
(
	`Boﬁ
())

217 
vÆ
 
èke_pc_mem
 = 
	`Wúe
(
	`Boﬁ
())

219 
vÆ
 
wb_ªg_vÆid
 = 
	`Reg
(
	`Boﬁ
())

220 
vÆ
 
wb_ªg_x˝t
 = 
	`Reg
(
	`Boﬁ
())

221 
vÆ
 
wb_ªg_ª∂ay
 = 
	`Reg
(
	`Boﬁ
())

222 
vÆ
 
wb_ªg_Êush_pùe
 = 
	`Reg
(
	`Boﬁ
())

223 
vÆ
 
wb_ªg_ˇu£
 = 
	`Reg
(
	`UI¡
())

224 
vÆ
 
wb_ªg_s„n˚
 = 
	`Reg
(
	`Boﬁ
())

225 
vÆ
 
wb_ªg_pc
 = 
	`Reg
(
	`UI¡
())

226 
vÆ
 
wb_ªg_ö°
 = 
	`Reg
(
	`Bôs
())

227 
vÆ
 
wb_ªg_øw_ö°
 = 
	`Reg
(
	`UI¡
())

228 
vÆ
 
wb_ªg_wd©a
 = 
	`Reg
(
	`Bôs
())

229 
vÆ
 
wb_ªg_rs2
 = 
	`Reg
(
	`Bôs
())

230 
vÆ
 
èke_pc_wb
 = 
	`Wúe
(
	`Boﬁ
())

232 
vÆ
 
èke_pc_mem_wb
 = 
èke_pc_wb
 || 
èke_pc_mem


233 
vÆ
 
èke_pc
 = 
èke_pc_mem_wb


236 
vÆ
 
ibuf
 = 
	`ModuÀ
(
√w
 
IBuf
)

237 
vÆ
 
id_ex∑nded_ö°
 = 
ibuf
.
io
.
ö°
.
	`m≠
(
_
.
bôs
.inst)

238 
vÆ
 
id_øw_ö°
 = 
ibuf
.
io
.
ö°
.
	`m≠
(
_
.
bôs
.
øw
)

239 
vÆ
 
id_ö°
 = 
id_ex∑nded_ö°
.
	`m≠
(
_
.
bôs
)

240 
ibuf
.
io
.
imem
 <> io.imem.
ª•


241 
ibuf
.
io
.
kûl
 :
èke_pc


243 
	`ªquúe
(
decodeWidth
 =1 && 
ªtúeWidth
 == decodeWidth)

244 
vÆ
 
id_˘æ
 = 
	`Wúe
(
√w
 
	`I¡CålSigs
()).
	`decode
(
	`id_ö°
(0), 
decode_èbÀ
)

245 
vÆ
 
id_øddr3
 = 
	`id_ex∑nded_ö°
(0).
rs3


246 
vÆ
 
id_øddr2
 = 
	`id_ex∑nded_ö°
(0).
rs2


247 
vÆ
 
id_øddr1
 = 
	`id_ex∑nded_ö°
(0).
rs1


248 
vÆ
 
id_waddr
 = 
	`id_ex∑nded_ö°
(0).
rd


249 
vÆ
 
id_lﬂd_u£
 = 
	`Wúe
(
	`Boﬁ
())

250 
vÆ
 
id_ªg_„n˚
 = 
	`Reg
(
öô
=
	`Boﬁ
(
Ál£
))

251 
vÆ
 
id_ªn
 = 
	`IndexedSeq
(
id_˘æ
.
rxs1
, id_˘æ.
rxs2
)

252 
vÆ
 
id_øddr
 = 
	`IndexedSeq
(
id_øddr1
, 
id_øddr2
)

253 
vÆ
 
rf
 = 
√w
 
	`RegFûe
(31, 
xLí
)

254 
vÆ
 
id_rs
 = 
id_øddr
.
	`m≠
(
rf
.
ªad
 
_
)

255 
vÆ
 
˘æ_kûld
 = 
	`Wúe
(
	`Boﬁ
())

256 
vÆ
 
id_≈c
 = (
ibuf
.
io
.
pc
.
asSI¡
 + 
	`ImmGí
(
IMM_UJ
, 
	`id_ö°
(0))).
asUI¡


257 
vÆ
 
c§
 = 
	`ModuÀ
(
√w
 
	`CSRFûe
(
≥rfEvíts
, 
c‹eP¨ams
.
cu°omCSRs
.
de˛s
))

258 
vÆ
 
id_c§_í
 = 
id_˘æ
.
c§
.
	`isO√Of
(
CSR
.
S
, CSR.
C
, CSR.
W
)

259 
vÆ
 
id_sy°em_ö¢
 = 
id_˘æ
.
c§
 ==
CSR
.
I


260 
vÆ
 
id_c§_ªn
 = 
id_˘æ
.
c§
.
	`isO√Of
(
CSR
.
S
, CSR.
C
Ë&& 
id_øddr1
 ==
	`UI¡
(0)

261 
vÆ
 
id_c§
 = 
	`Mux
(
id_c§_ªn
, 
CSR
.
R
, 
id_˘æ
.
c§
)

262 
vÆ
 
id_s„n˚
 = 
id_˘æ
.
mem
 && id_˘æ.
mem_cmd
 ==
M_SFENCE


263 
vÆ
 
id_c§_Êush
 = 
id_s„n˚
 || 
id_sy°em_ö¢
 || (
id_c§_í
 && !
id_c§_ªn
 && 
c§
.
io
.
	`decode
(0).
wrôe_Êush
)

268 
io
.
±w
.
pcode_ªq
 :
c§
.io.pcode_req

269 
c§
.
io
.
pcode_ª•
 :io.
±w
.pcode_resp

272 
vÆ
 
scõ_decodî
 = 
rockëP¨ams
.
u£SCIE
.
›ti⁄
 {

273 
vÆ
 
d
 = 
	`ModuÀ
(
√w
 
SCIEDecodî
)

274 
	`as£π
(!
d
.
io
.
pùñöed
 && !d.io.
mu…icy˛e
)

275 
d
.
io
.
ö¢
 :
	`id_øw_ö°
(0)

276 
d
.
io


278 
vÆ
 
id_ûÀgÆ_ö¢
 = !
id_˘æ
.
ÀgÆ
 ||

279 (
id_˘æ
.
mul
 || id_˘æ.
div
Ë&& !
c§
.
io
.
°©us
.
	`iß
('m'-'a') ||

280 
id_˘æ
.
amo
 && !
c§
.
io
.
°©us
.
	`iß
('a'-'a') ||

281 
id_˘æ
.
Â
 && (
c§
.
io
.
	`decode
(0).
Â_ûÀgÆ
 || io.
Âu
.
ûÀgÆ_rm
) ||

282 
id_˘æ
.
dp
 && !
c§
.
io
.
°©us
.
	`iß
('d'-'a') ||

283 
ibuf
.
io
.
	`ö°
(0).
bôs
.
rvc
 && !
c§
.io.
°©us
.
	`iß
('c'-'a') ||

284 
id_˘æ
.
rocc
 && 
c§
.
io
.
	`decode
(0).
rocc_ûÀgÆ
 ||

285 
id_˘æ
.
scõ
 && 
scõ_decodî
.
	`m≠
(!
_
.
u≈ùñöed
).
	`gëOrEl£
(
Ál£
.
B
) ||

286 
id_c§_í
 && (
c§
.
io
.
	`decode
(0).
ªad_ûÀgÆ
 || !
id_c§_ªn
 && c§.io.decode(0).
wrôe_ûÀgÆ
) ||

287 !
ibuf
.
io
.
	`ö°
(0).
bôs
.
rvc
 && ((
id_s„n˚
 || 
id_sy°em_ö¢
Ë&& 
c§
.io.
	`decode
(0).
sy°em_ûÀgÆ
)

289 
vÆ
 
id_amo_aq
 = 
	`id_ö°
(0)(26)

290 
vÆ
 
id_amo_æ
 = 
	`id_ö°
(0)(25)

291 
vÆ
 
id_„n˚_√xt
 = 
id_˘æ
.
„n˚
 || id_˘æ.
amo
 && 
id_amo_aq


292 
vÆ
 
id_mem_busy
 = !
io
.
dmem
.
‹dîed
 || io.dmem.
ªq
.
vÆid


293 
	`whí
 (!
id_mem_busy
Ë{ 
id_ªg_„n˚
 :
Ál£
 }

294 
vÆ
 
id_rocc_busy
 = 
	`Boﬁ
(
usögRoCC
) &&

295 (
io
.
rocc
.
busy
 || 
ex_ªg_vÆid
 && 
ex_˘æ
.rocc ||

296 
mem_ªg_vÆid
 && 
mem_˘æ
.
rocc
 || 
wb_ªg_vÆid
 && 
wb_˘æ
.rocc)

297 
vÆ
 
id_do_„n˚
 = 
	`Wúe
(
öô
 = 
id_rocc_busy
 && 
id_˘æ
.
„n˚
 ||

298 
id_mem_busy
 && (
id_˘æ
.
amo
 && 
id_amo_æ
 || id_˘æ.
„n˚_i
 || 
id_ªg_„n˚
 && (id_˘æ.
mem
 || id_˘æ.
rocc
)))

300 
vÆ
 
bpu
 = 
	`ModuÀ
(
√w
 
	`BªakpoötUnô
(
nBªakpoöts
))

301 
bpu
.
io
.
°©us
 :
c§
.io.status

302 
bpu
.
io
.
bp
 :
c§
.io.bp

303 
bpu
.
io
.
pc
 :
ibuf
.io.pc

304 
bpu
.
io
.
ó
 :
mem_ªg_wd©a


306 
vÆ
 
id_x˝t0
 = 
ibuf
.
io
.
	`ö°
(0).
bôs
.
x˝t0


307 
vÆ
 
id_x˝t1
 = 
ibuf
.
io
.
	`ö°
(0).
bôs
.
x˝t1


308 
	`vÆ
 (
id_x˝t
, 
id_ˇu£
Ë
	`checkEx˚±i⁄s
(
	`Li°
(

309 (
c§
.
io
.
öãºu±
, c§.io.
öãºu±_ˇu£
),

310 (
bpu
.
io
.
debug_if
, 
	`UI¡
(
CSR
.
debugTriggîCau£
)),

311 (
bpu
.
io
.
x˝t_if
, 
	`UI¡
(
Cau£s
.
bªakpoöt
)),

312 (
id_x˝t0
.
pf
.
ö°
, 
	`UI¡
(
Cau£s
.
„tch_∑ge_Áu…
)),

313 (
id_x˝t0
.
´
.
ö°
, 
	`UI¡
(
Cau£s
.
„tch_ac˚ss
)),

314 (
id_x˝t1
.
pf
.
ö°
, 
	`UI¡
(
Cau£s
.
„tch_∑ge_Áu…
)),

315 (
id_x˝t1
.
´
.
ö°
, 
	`UI¡
(
Cau£s
.
„tch_ac˚ss
)),

316 (
id_ûÀgÆ_ö¢
, 
	`UI¡
(
Cau£s
.
ûÀgÆ_ö°ru˘i⁄
))))

318 
vÆ
 
idCovîCau£s
 = 
	`Li°
(

319 (
CSR
.
debugTriggîCau£
, "DEBUG_TRIGGER"),

320 (
Cau£s
.
bªakpoöt
, "BREAKPOINT"),

321 (
Cau£s
.
„tch_∑ge_Áu…
, "FETCH_PAGE_FAULT"),

322 (
Cau£s
.
„tch_ac˚ss
, "FETCH_ACCESS"),

323 (
Cau£s
.
ûÀgÆ_ö°ru˘i⁄
, "ILLEGAL_INSTRUCTION")

325 
	`covîEx˚±i⁄s
(
id_x˝t
, 
id_ˇu£
, "DECODE", 
idCovîCau£s
)

327 
vÆ
 
dˇche_by∑ss_d©a
 =

328 i‡(
Á°LﬂdByã
Ë
io
.
dmem
.
ª•
.
bôs
.
	`d©a
(
xLí
-1, 0)

329 i‡(
Á°LﬂdW‹d
Ë
io
.
dmem
.
ª•
.
bôs
.
	`d©a_w‹d_by∑ss
(
xLí
-1, 0)

330 
wb_ªg_wd©a


333 
vÆ
 
ex_waddr
 = 
	`ex_ªg_ö°
(11,7)

334 
vÆ
 
mem_waddr
 = 
	`mem_ªg_ö°
(11,7)

335 
vÆ
 
wb_waddr
 = 
	`wb_ªg_ö°
(11,7)

336 
vÆ
 
by∑ss_sour˚s
 = 
	`IndexedSeq
(

337 (
	`Boﬁ
(
åue
), 
	`UI¡
(0), UInt(0)),

338 (
ex_ªg_vÆid
 && 
ex_˘æ
.
wxd
, 
ex_waddr
, 
mem_ªg_wd©a
),

339 (
mem_ªg_vÆid
 && 
mem_˘æ
.
wxd
 && !mem_˘æ.
mem
, 
mem_waddr
, 
wb_ªg_wd©a
),

340 (
mem_ªg_vÆid
 && 
mem_˘æ
.
wxd
, 
mem_waddr
, 
dˇche_by∑ss_d©a
))

341 
vÆ
 
id_by∑ss_§c
 = 
id_øddr
.
	`m≠
(
øddr
 => 
by∑ss_sour˚s
.m≠(
s
 => s.
_1
 && s.
_2
 ===Ñaddr))

344 
vÆ
 
by∑ss_mux
 = 
by∑ss_sour˚s
.
	`m≠
(
_
.
_3
)

345 
vÆ
 
ex_ªg_rs_by∑ss
 = 
	`Reg
(
	`Vec
(
id_øddr
.
size
, 
	`Boﬁ
()))

346 
vÆ
 
ex_ªg_rs_lsb
 = 
	`Reg
(
	`Vec
(
id_øddr
.
size
, 
	`UI¡
(
width
 = 
	`log2Ceû
(
by∑ss_sour˚s
.size))))

347 
vÆ
 
ex_ªg_rs_msb
 = 
	`Reg
(
	`Vec
(
id_øddr
.
size
, 
	`UI¡
()))

348 
vÆ
 
ex_rs
 = 
i
 <- 0 
u¡û
 
id_øddr
.
size
)

349 
yõld
 
	`Mux
(
	`ex_ªg_rs_by∑ss
(
i
), 
	`by∑ss_mux
(
	`ex_ªg_rs_lsb
(i)), 
	`C©
(
	`ex_ªg_rs_msb
(i),Éx_reg_rs_lsb(i)))

350 
vÆ
 
ex_imm
 = 
	`ImmGí
(
ex_˘æ
.
£l_imm
, 
ex_ªg_ö°
)

351 
vÆ
 
ex_›1
 = 
	`MuxLookup
(
ex_˘æ
.
£l_Æu1
, 
	`SI¡
(0), 
	`Seq
(

352 
A1_RS1
 -> 
	`ex_rs
(0).
asSI¡
,

353 
A1_PC
 -> 
ex_ªg_pc
.
asSI¡
))

354 
vÆ
 
ex_›2
 = 
	`MuxLookup
(
ex_˘æ
.
£l_Æu2
, 
	`SI¡
(0), 
	`Seq
(

355 
A2_RS2
 -> 
	`ex_rs
(1).
asSI¡
,

356 
A2_IMM
 -> 
ex_imm
,

357 
A2_SIZE
 -> 
	`Mux
(
ex_ªg_rvc
, 
	`SI¡
(2), SInt(4))))

359 
vÆ
 
Æu
 = 
	`ModuÀ
(
√w
 
ALU
)

360 
Æu
.
io
.
dw
 :
ex_˘æ
.
Æu_dw


361 
Æu
.
io
.
‚
 :
ex_˘æ
.
Æu_‚


362 
Æu
.
io
.
ö2
 :
ex_›2
.
asUI¡


363 
Æu
.
io
.
ö1
 :
ex_›1
.
asUI¡


365 
vÆ
 
scõ_u≈ùñöed
 = 
rockëP¨ams
.
u£SCIE
.
›ti⁄
 {

366 
vÆ
 
u
 = 
	`ModuÀ
(
√w
 
	`SCIEU≈ùñöed
(
xLí
))

367 
u
.
io
.
ö¢
 :
ex_ªg_ö°


368 
u
.
io
.
rs1
 :
	`ex_rs
(0)

369 
u
.
io
.
rs2
 :
	`ex_rs
(1)

370 
u
.
io
.
rd


374 
vÆ
 
div
 = 
	`ModuÀ
(
√w
 
	`MulDiv
(i‡(
pùñöedMul
Ë
mulDivP¨ams
.
	`c›y
(
mulUƒﬁl
 = 0ËmulDivP¨ams, 
width
 = 
xLí
))

375 
div
.
io
.
ªq
.
vÆid
 :
ex_ªg_vÆid
 && 
ex_˘æ
.div

376 
div
.
io
.
ªq
.
bôs
.
dw
 :
ex_˘æ
.
Æu_dw


377 
div
.
io
.
ªq
.
bôs
.
‚
 :
ex_˘æ
.
Æu_‚


378 
div
.
io
.
ªq
.
bôs
.
ö1
 :
	`ex_rs
(0)

379 
div
.
io
.
ªq
.
bôs
.
ö2
 :
	`ex_rs
(1)

380 
div
.
io
.
ªq
.
bôs
.
èg
 :
ex_waddr


381 
vÆ
 
mul
 = 
pùñöedMul
.
›ti⁄
 {

382 
vÆ
 
m
 = 
	`ModuÀ
(
√w
 
	`PùñöedMu…ùlõr
(
xLí
, 2))

383 
m
.
io
.
ªq
.
vÆid
 :
ex_ªg_vÆid
 && 
ex_˘æ
.
mul


384 
m
.
io
.
ªq
.
bôs
 :
div
.io.req.bits

385 
m


388 
ex_ªg_vÆid
 :!
˘æ_kûld


389 
ex_ªg_ª∂ay
 :!
èke_pc
 && 
ibuf
.
io
.
	`ö°
(0).
vÆid
 && ibuf.io.ö°(0).
bôs
.
ª∂ay


390 
ex_ªg_x˝t
 :!
˘æ_kûld
 && 
id_x˝t


391 
ex_ªg_x˝t_öãºu±
 :!
èke_pc
 && 
ibuf
.
io
.
	`ö°
(0).
vÆid
 && 
c§
.io.
öãºu±


393 
	`whí
 (!
˘æ_kûld
) {

394 
ex_˘æ
 :
id_˘æ


395 
ex_ªg_rvc
 :
ibuf
.
io
.
	`ö°
(0).
bôs
.
rvc


396 
ex_˘æ
.
c§
 :
id_c§


397 
	`whí
 (
id_„n˚_√xt
Ë{ 
id_ªg_„n˚
 :
åue
 }

398 
	`whí
 (
id_x˝t
) {

399 
ex_˘æ
.
Æu_‚
 :
ALU
.
FN_ADD


400 
ex_˘æ
.
Æu_dw
 :
DW_XPR


401 
ex_˘æ
.
£l_Æu1
 :
A1_RS1


402 
ex_˘æ
.
£l_Æu2
 :
A2_ZERO


403 
	`whí
 (
id_x˝t1
.
asUI¡
.
‹R
) {

404 
ex_˘æ
.
£l_Æu1
 :
A1_PC


405 
ex_˘æ
.
£l_Æu2
 :
A2_SIZE


406 
ex_ªg_rvc
 :
åue


408 
	`whí
 (
bpu
.
io
.
x˝t_if
 || 
id_x˝t0
.
asUI¡
.
‹R
) {

409 
ex_˘æ
.
£l_Æu1
 :
A1_PC


410 
ex_˘æ
.
£l_Æu2
 :
A2_ZERO


413 
ex_ªg_Êush_pùe
 :
id_˘æ
.
„n˚_i
 || 
id_c§_Êush


414 
ex_ªg_lﬂd_u£
 :
id_lﬂd_u£


415 
	`whí
 (
id_s„n˚
) {

416 
ex_˘æ
.
mem_ty≥
 :
	`C©
(
id_øddr2
 =/
	`UI¡
(0), 
id_øddr1
 =/= UInt(0))

419 
i
 <- 0 
u¡û
 
id_øddr
.
size
) {

420 
vÆ
 
do_by∑ss
 = 
	`id_by∑ss_§c
(
i
).
	`ªdu˚
(
_
||_)

421 
vÆ
 
by∑ss_§c
 = 
	`Pri‹ôyEncodî
(
	`id_by∑ss_§c
(
i
))

422 
	`ex_ªg_rs_by∑ss
(
i
Ë:
do_by∑ss


423 
	`ex_ªg_rs_lsb
(
i
Ë:
by∑ss_§c


424 
	`whí
 (
	`id_ªn
(
i
Ë&& !
do_by∑ss
) {

425 
	`ex_ªg_rs_lsb
(
i
Ë:
	`id_rs
(i)(
	`log2Ceû
(
by∑ss_sour˚s
.
size
)-1, 0)

426 
	`ex_ªg_rs_msb
(
i
Ë:
	`id_rs
(iË>> 
	`log2Ceû
(
by∑ss_sour˚s
.
size
)

429 
	`whí
 (
id_ûÀgÆ_ö¢
) {

430 
vÆ
 
ö°
 = 
	`Mux
(
ibuf
.
io
.
	`ö°
(0).
bôs
.
rvc
, 
	`id_øw_ö°
(0)(15, 0), id_raw_inst(0))

431 
	`ex_ªg_rs_by∑ss
(0Ë:
Ál£


432 
	`ex_ªg_rs_lsb
(0Ë:
	`ö°
(
	`log2Ceû
(
by∑ss_sour˚s
.
size
)-1, 0)

433 
	`ex_ªg_rs_msb
(0Ë:
ö°
 >> 
	`log2Ceû
(
by∑ss_sour˚s
.
size
)

436 
	`whí
 (!
˘æ_kûld
 || 
c§
.
io
.
öãºu±
 || 
ibuf
.io.
	`ö°
(0).
bôs
.
ª∂ay
) {

437 
ex_ªg_ˇu£
 :
id_ˇu£


438 
ex_ªg_ö°
 :
	`id_ö°
(0)

439 
ex_ªg_øw_ö°
 :
	`id_øw_ö°
(0)

440 
ex_ªg_pc
 :
ibuf
.
io
.
pc


441 
ex_ªg_btb_ª•
 :
ibuf
.
io
.
btb_ª•


445 
vÆ
 
ex_pc_vÆid
 = 
ex_ªg_vÆid
 || 
ex_ªg_ª∂ay
 || 
ex_ªg_x˝t_öãºu±


446 
vÆ
 
wb_dˇche_miss
 = 
wb_˘æ
.
mem
 && !
io
.
dmem
.
ª•
.
vÆid


447 
vÆ
 
ª∂ay_ex_°ru˘uøl
 = 
ex_˘æ
.
mem
 && !
io
.
dmem
.
ªq
.
ªady
 ||

448 
ex_˘æ
.
div
 && !div.
io
.
ªq
.
ªady


449 
vÆ
 
ª∂ay_ex_lﬂd_u£
 = 
wb_dˇche_miss
 && 
ex_ªg_lﬂd_u£


450 
vÆ
 
ª∂ay_ex
 = 
ex_ªg_ª∂ay
 || (
ex_ªg_vÆid
 && (
ª∂ay_ex_°ru˘uøl
 || 
ª∂ay_ex_lﬂd_u£
))

451 
vÆ
 
˘æ_kûlx
 = 
èke_pc_mem_wb
 || 
ª∂ay_ex
 || !
ex_ªg_vÆid


453 
vÆ
 
ex_¶ow_by∑ss
 = 
ex_˘æ
.
mem_cmd
 ==
M_XSC
 || 
	`Vec
(
MT_B
, 
MT_BU
, 
MT_H
, 
MT_HU
).
	`c⁄èös
”x_˘æ.
mem_ty≥
)

454 
vÆ
 
ex_s„n˚
 = 
	`Boﬁ
(
usögVM
Ë&& 
ex_˘æ
.
mem
 &&Éx_˘æ.
mem_cmd
 ==
M_SFENCE


456 
	`vÆ
 (
ex_x˝t
, 
ex_ˇu£
Ë
	`checkEx˚±i⁄s
(
	`Li°
(

457 (
ex_ªg_x˝t_öãºu±
 || 
ex_ªg_x˝t
, 
ex_ªg_ˇu£
)))

459 
vÆ
 
exCovîCau£s
 = 
idCovîCau£s


460 
	`covîEx˚±i⁄s
(
ex_x˝t
, 
ex_ˇu£
, "EXECUTE", 
exCovîCau£s
)

463 
vÆ
 
mem_pc_vÆid
 = 
mem_ªg_vÆid
 || 
mem_ªg_ª∂ay
 || 
mem_ªg_x˝t_öãºu±


464 
vÆ
 
mem_br_èrgë
 = 
mem_ªg_pc
.
asSI¡
 +

465 
	`Mux
(
mem_˘æ
.
bønch
 && 
mem_br_èkí
, 
	`ImmGí
(
IMM_SB
, 
mem_ªg_ö°
),

466 
	`Mux
(
mem_˘æ
.
jÆ
, 
	`ImmGí
(
IMM_UJ
, 
mem_ªg_ö°
),

467 
	`Mux
(
mem_ªg_rvc
, 
	`SI¡
(2), SInt(4))))

468 
vÆ
 
mem_≈c
 = (
	`Mux
(
mem_˘æ
.
jÆr
 || 
mem_ªg_s„n˚
, 
	`ícodeVútuÆAddªss
(
mem_ªg_wd©a
, mem_ªg_wd©a).
asSI¡
, 
mem_br_èrgë
Ë& 
	`SI¡
(-2)).
asUI¡


469 
vÆ
 
mem_wr⁄g_≈c
 =

470 
	`Mux
(
ex_pc_vÆid
, 
mem_≈c
 =/
ex_ªg_pc
,

471 
	`Mux
(
ibuf
.
io
.
	`ö°
(0).
vÆid
 || ibuf.io.
imem
.vÆid, 
mem_≈c
 =/ibuf.io.
pc
, 
	`Boﬁ
(
åue
)))

472 
vÆ
 
mem_≈c_mißlig√d
 = !
c§
.
io
.
°©us
.
	`iß
('c'-'a'Ë&& 
	`mem_≈c
(1Ë&& !
mem_ªg_s„n˚


473 
vÆ
 
mem_öt_wd©a
 = 
	`Mux
(!
mem_ªg_x˝t
 && (
mem_˘æ
.
jÆr
 ^ 
mem_≈c_mißlig√d
), 
mem_br_èrgë
, 
mem_ªg_wd©a
.
asSI¡
).
asUI¡


474 
vÆ
 
mem_cfi
 = 
mem_˘æ
.
bønch
 || mem_˘æ.
jÆr
 || mem_˘æ.
jÆ


475 
vÆ
 
mem_cfi_èkí
 = (
mem_˘æ
.
bønch
 && 
mem_br_èkí
Ë|| mem_˘æ.
jÆr
 || mem_˘æ.
jÆ


476 
vÆ
 
mem_dúe˘i⁄_mi•ªdi˘i⁄
 = 
mem_˘æ
.
bønch
 && 
mem_br_èkí
 =/(
usögBTB
 && 
mem_ªg_btb_ª•
.
èkí
)

477 
vÆ
 
mem_mi•ªdi˘i⁄
 = i‡(
usögBTB
Ë
mem_wr⁄g_≈c
 
mem_cfi_èkí


478 
èke_pc_mem
 :
mem_ªg_vÆid
 && (
mem_mi•ªdi˘i⁄
 || 
mem_ªg_s„n˚
)

480 
mem_ªg_vÆid
 :!
˘æ_kûlx


481 
mem_ªg_ª∂ay
 :!
èke_pc_mem_wb
 && 
ª∂ay_ex


482 
mem_ªg_x˝t
 :!
˘æ_kûlx
 && 
ex_x˝t


483 
mem_ªg_x˝t_öãºu±
 :!
èke_pc_mem_wb
 && 
ex_ªg_x˝t_öãºu±


487 
	`whí
 (
mem_ªg_vÆid
 && 
mem_ªg_Êush_pùe
) {

488 
mem_ªg_s„n˚
 :
Ál£


489 }.
	`ñ£whí
 (
ex_pc_vÆid
) {

490 
mem_˘æ
 :
ex_˘æ


491 
mem_ªg_rvc
 :
ex_ªg_rvc


492 
mem_ªg_lﬂd
 :
ex_˘æ
.
mem
 && 
	`isRód
”x_˘æ.
mem_cmd
)

493 
mem_ªg_°‹e
 :
ex_˘æ
.
mem
 && 
	`isWrôe
”x_˘æ.
mem_cmd
)

494 
mem_ªg_s„n˚
 :
ex_s„n˚


495 
mem_ªg_btb_ª•
 :
ex_ªg_btb_ª•


496 
mem_ªg_Êush_pùe
 :
ex_ªg_Êush_pùe


497 
mem_ªg_¶ow_by∑ss
 :
ex_¶ow_by∑ss


499 
mem_ªg_ˇu£
 :
ex_ˇu£


500 
mem_ªg_ö°
 :
ex_ªg_ö°


501 
mem_ªg_øw_ö°
 :
ex_ªg_øw_ö°


502 
mem_ªg_pc
 :
ex_ªg_pc


503 
mem_ªg_wd©a
 :
scõ_u≈ùñöed
.
	`m≠
(
u
 => 
	`Mux
(
ex_˘æ
.
scõ
, u, 
Æu
.
io
.
out
)).
	`gëOrEl£
(alu.io.out)

504 
mem_br_èkí
 :
Æu
.
io
.
cmp_out


506 
	`whí
 (
ex_˘æ
.
rxs2
 && (ex_˘æ.
mem
 ||Éx_˘æ.
rocc
 || 
ex_s„n˚
)) {

507 
vÆ
 
typ
 = 
	`Mux
(
ex_˘æ
.
rocc
, 
	`log2Ceû
(
xLí
/8).
U
,Éx_˘æ.
mem_ty≥
)

508 
mem_ªg_rs2
 :
√w
 
	`St‹eGí
(
typ
, 0.U, 
	`ex_rs
(1), 
c‹eD©aByãs
).
d©a


510 
	`whí
 (
ex_˘æ
.
jÆr
 && 
c§
.
io
.
°©us
.
debug
) {

512 
mem_˘æ
.
„n˚_i
 :
åue


513 
mem_ªg_Êush_pùe
 :
åue


517 
vÆ
 
mem_bªakpoöt
 = (
mem_ªg_lﬂd
 && 
bpu
.
io
.
x˝t_ld
Ë|| (
mem_ªg_°‹e
 && bpu.io.
x˝t_°
)

518 
vÆ
 
mem_debug_bªakpoöt
 = (
mem_ªg_lﬂd
 && 
bpu
.
io
.
debug_ld
Ë|| (
mem_ªg_°‹e
 && bpu.io.
debug_°
)

519 
	`vÆ
 (
mem_ld°_x˝t
, 
mem_ld°_ˇu£
Ë
	`checkEx˚±i⁄s
(
	`Li°
(

520 (
mem_debug_bªakpoöt
, 
	`UI¡
(
CSR
.
debugTriggîCau£
)),

521 (
mem_bªakpoöt
, 
	`UI¡
(
Cau£s
.
bªakpoöt
))))

523 
	`vÆ
 (
mem_x˝t
, 
mem_ˇu£
Ë
	`checkEx˚±i⁄s
(
	`Li°
(

524 (
mem_ªg_x˝t_öãºu±
 || 
mem_ªg_x˝t
, 
mem_ªg_ˇu£
),

525 (
mem_ªg_vÆid
 && 
mem_≈c_mißlig√d
, 
	`UI¡
(
Cau£s
.
mißlig√d_„tch
)),

526 (
mem_ªg_vÆid
 && 
mem_ld°_x˝t
, 
mem_ld°_ˇu£
)))

528 
vÆ
 
memCovîCau£s
 = (
exCovîCau£s
 ++ 
	`Li°
(

529 (
CSR
.
debugTriggîCau£
, "DEBUG_TRIGGER"),

530 (
Cau£s
.
bªakpoöt
, "BREAKPOINT"),

531 (
Cau£s
.
mißlig√d_„tch
, "MISALIGNED_FETCH")

532 )).
di°ö˘


533 
	`covîEx˚±i⁄s
(
mem_x˝t
, 
mem_ˇu£
, "MEMORY", 
memCovîCau£s
)

535 
vÆ
 
dˇche_kûl_mem
 = 
mem_ªg_vÆid
 && 
mem_˘æ
.
wxd
 && 
io
.
dmem
.
ª∂ay_√xt


536 
vÆ
 
Âu_kûl_mem
 = 
mem_ªg_vÆid
 && 
mem_˘æ
.
Â
 && 
io
.
Âu
.
«ck_mem


537 
vÆ
 
ª∂ay_mem
 = 
dˇche_kûl_mem
 || 
mem_ªg_ª∂ay
 || 
Âu_kûl_mem


538 
vÆ
 
kûlm_comm⁄
 = 
dˇche_kûl_mem
 || 
èke_pc_wb
 || 
mem_ªg_x˝t
 || !
mem_ªg_vÆid


539 
div
.
io
.
kûl
 :
kûlm_comm⁄
 && 
	`Reg
(
√xt
 = div.io.
ªq
.
	`fúe
())

540 
vÆ
 
˘æ_kûlm
 = 
kûlm_comm⁄
 || 
mem_x˝t
 || 
Âu_kûl_mem


543 
wb_ªg_vÆid
 :!
˘æ_kûlm


544 
wb_ªg_ª∂ay
 :
ª∂ay_mem
 && !
èke_pc_wb


545 
wb_ªg_x˝t
 :
mem_x˝t
 && !
èke_pc_wb


546 
wb_ªg_Êush_pùe
 :!
˘æ_kûlm
 && 
mem_ªg_Êush_pùe


547 
	`whí
 (
mem_pc_vÆid
) {

548 
wb_˘æ
 :
mem_˘æ


549 
wb_ªg_s„n˚
 :
mem_ªg_s„n˚


550 
wb_ªg_wd©a
 :
	`Mux
(!
mem_ªg_x˝t
 && 
mem_˘æ
.
Â
 && mem_˘æ.
wxd
, 
io
.
Âu
.
toöt_d©a
, 
mem_öt_wd©a
)

551 
	`whí
 (
mem_˘æ
.
rocc
 || 
mem_ªg_s„n˚
) {

552 
wb_ªg_rs2
 :
mem_ªg_rs2


554 
wb_ªg_ˇu£
 :
mem_ˇu£


555 
wb_ªg_ö°
 :
mem_ªg_ö°


556 
wb_ªg_øw_ö°
 :
mem_ªg_øw_ö°


557 
wb_ªg_pc
 :
mem_ªg_pc


560 
	`vÆ
 (
wb_x˝t
, 
wb_ˇu£
Ë
	`checkEx˚±i⁄s
(
	`Li°
(

561 (
wb_ªg_x˝t
, 
wb_ªg_ˇu£
),

562 (
wb_ªg_vÆid
 && 
wb_˘æ
.
mem
 && 
io
.
dmem
.
s2_x˝t
.
ma
.
°
, 
	`UI¡
(
Cau£s
.
mißlig√d_°‹e
)),

563 (
wb_ªg_vÆid
 && 
wb_˘æ
.
mem
 && 
io
.
dmem
.
s2_x˝t
.
ma
.
ld
, 
	`UI¡
(
Cau£s
.
mißlig√d_lﬂd
)),

564 (
wb_ªg_vÆid
 && 
wb_˘æ
.
mem
 && 
io
.
dmem
.
s2_x˝t
.
pf
.
°
, 
	`UI¡
(
Cau£s
.
°‹e_∑ge_Áu…
)),

565 (
wb_ªg_vÆid
 && 
wb_˘æ
.
mem
 && 
io
.
dmem
.
s2_x˝t
.
pf
.
ld
, 
	`UI¡
(
Cau£s
.
lﬂd_∑ge_Áu…
)),

566 (
wb_ªg_vÆid
 && 
wb_˘æ
.
mem
 && 
io
.
dmem
.
s2_x˝t
.
´
.
°
, 
	`UI¡
(
Cau£s
.
°‹e_ac˚ss
)),

567 (
wb_ªg_vÆid
 && 
wb_˘æ
.
mem
 && 
io
.
dmem
.
s2_x˝t
.
´
.
ld
, 
	`UI¡
(
Cau£s
.
lﬂd_ac˚ss
))

570 
vÆ
 
wbCovîCau£s
 = 
	`Li°
(

571 (
Cau£s
.
mißlig√d_°‹e
, "MISALIGNED_STORE"),

572 (
Cau£s
.
mißlig√d_lﬂd
, "MISALIGNED_LOAD"),

573 (
Cau£s
.
°‹e_∑ge_Áu…
, "STORE_PAGE_FAULT"),

574 (
Cau£s
.
lﬂd_∑ge_Áu…
, "LOAD_PAGE_FAULT"),

575 (
Cau£s
.
°‹e_ac˚ss
, "STORE_ACCESS"),

576 (
Cau£s
.
lﬂd_ac˚ss
, "LOAD_ACCESS")

578 
	`covîEx˚±i⁄s
(
wb_x˝t
, 
wb_ˇu£
, "WRITEBACK", 
wbCovîCau£s
)

580 
vÆ
 
wb_pc_vÆid
 = 
wb_ªg_vÆid
 || 
wb_ªg_ª∂ay
 || 
wb_ªg_x˝t


581 
vÆ
 
wb_wxd
 = 
wb_ªg_vÆid
 && 
wb_˘æ
.
wxd


582 
vÆ
 
wb_£t_sbﬂrd
 = 
wb_˘æ
.
div
 || 
wb_dˇche_miss
 || wb_˘æ.
rocc


583 
vÆ
 
ª∂ay_wb_comm⁄
 = 
io
.
dmem
.
s2_«ck
 || 
wb_ªg_ª∂ay


584 
vÆ
 
ª∂ay_wb_rocc
 = 
wb_ªg_vÆid
 && 
wb_˘æ
.
rocc
 && !
io
.rocc.
cmd
.
ªady


585 
vÆ
 
ª∂ay_wb
 = 
ª∂ay_wb_comm⁄
 || 
ª∂ay_wb_rocc


586 
èke_pc_wb
 :
ª∂ay_wb
 || 
wb_x˝t
 || 
c§
.
io
.
îë
 || 
wb_ªg_Êush_pùe


589 
vÆ
 
dmem_ª•_xpu
 = !
io
.
dmem
.
ª•
.
bôs
.
	`èg
(0).
toBoﬁ


590 
vÆ
 
dmem_ª•_Âu
 = 
io
.
dmem
.
ª•
.
bôs
.
	`èg
(0).
toBoﬁ


591 
vÆ
 
dmem_ª•_waddr
 = 
io
.
dmem
.
ª•
.
bôs
.
	`èg
(5, 1)

592 
vÆ
 
dmem_ª•_vÆid
 = 
io
.
dmem
.
ª•
.
vÆid
 && io.dmem.ª•.
bôs
.
has_d©a


593 
vÆ
 
dmem_ª•_ª∂ay
 = 
dmem_ª•_vÆid
 && 
io
.
dmem
.
ª•
.
bôs
.
ª∂ay


595 
div
.
io
.
ª•
.
ªady
 :!
wb_wxd


596 
vÆ
 
Œ_wd©a
 = 
	`Wúe
(
öô
 = 
div
.
io
.
ª•
.
bôs
.
d©a
)

597 
vÆ
 
Œ_waddr
 = 
	`Wúe
(
öô
 = 
div
.
io
.
ª•
.
bôs
.
èg
)

598 
vÆ
 
Œ_wí
 = 
	`Wúe
(
öô
 = 
div
.
io
.
ª•
.
	`fúe
())

599 i‡(
usögRoCC
) {

600 
io
.
rocc
.
ª•
.
ªady
 :!
wb_wxd


601 
	`whí
 (
io
.
rocc
.
ª•
.
	`fúe
()) {

602 
div
.
io
.
ª•
.
ªady
 :
	`Boﬁ
(
Ál£
)

603 
Œ_wd©a
 :
io
.
rocc
.
ª•
.
bôs
.
d©a


604 
Œ_waddr
 :
io
.
rocc
.
ª•
.
bôs
.
rd


605 
Œ_wí
 :
	`Boﬁ
(
åue
)

608 
	`whí
 (
dmem_ª•_ª∂ay
 && 
dmem_ª•_xpu
) {

609 
div
.
io
.
ª•
.
ªady
 :
	`Boﬁ
(
Ál£
)

610 i‡(
usögRoCC
)

611 
io
.
rocc
.
ª•
.
ªady
 :
	`Boﬁ
(
Ál£
)

612 
Œ_waddr
 :
dmem_ª•_waddr


613 
Œ_wí
 :
	`Boﬁ
(
åue
)

616 
vÆ
 
wb_vÆid
 = 
wb_ªg_vÆid
 && !
ª∂ay_wb
 && !
wb_x˝t


617 
vÆ
 
wb_wí
 = 
wb_vÆid
 && 
wb_˘æ
.
wxd


618 
vÆ
 
rf_wí
 = 
wb_wí
 || 
Œ_wí


619 
vÆ
 
rf_waddr
 = 
	`Mux
(
Œ_wí
, 
Œ_waddr
, 
wb_waddr
)

620 
vÆ
 
rf_wd©a
 = 
	`Mux
(
dmem_ª•_vÆid
 && 
dmem_ª•_xpu
, 
io
.
dmem
.
ª•
.
bôs
.
	`d©a
(
xLí
-1, 0),

621 
	`Mux
(
Œ_wí
, 
Œ_wd©a
,

622 
	`Mux
(
wb_˘æ
.
c§
 =/
CSR
.
N
, c§.
io
.
rw
.
rd©a
,

623 
	`Mux
(
wb_˘æ
.
mul
, mul.
	`m≠
(
_
.
io
.
ª•
.
bôs
.
d©a
).
	`gëOrEl£
(
wb_ªg_wd©a
),

624 
wb_ªg_wd©a
))))

625 
	`whí
 (
rf_wí
Ë{ 
rf
.
	`wrôe
(
rf_waddr
, 
rf_wd©a
) }

628 
c§
.
io
.
ung©ed_˛ock
 :
˛ock


629 
c§
.
io
.
	`decode
(0).c§ :
	`id_øw_ö°
(0)(31,20)

630 
c§
.
io
.
ex˚±i⁄
 :
wb_x˝t


631 
c§
.
io
.
ˇu£
 :
wb_ˇu£


632 
c§
.
io
.
ªtúe
 :
wb_vÆid


633 
c§
.
io
.
	`ö°
(0Ë:(i‡(
usögCom¥es£d
Ë
	`C©
(
	`Mux
(
	`wb_ªg_øw_ö°
(1, 0).
™dR
, 
wb_ªg_ö°
 >> 16, 0.U), wb_reg_raw_inst(15, 0)) wb_reg_inst)

634 
c§
.
io
.
öãºu±s
 := io.interrupts

635 
c§
.
io
.
h¨tid
 := io.hartid

636 
io
.
Âu
.
fc§_rm
 :
c§
.io.fcsr_rm

637 
c§
.
io
.
fc§_Êags
 :io.
Âu
.fcsr_flags

638 
c§
.
io
.
rocc_öãºu±
 :io.
rocc
.
öãºu±


639 
c§
.
io
.
pc
 :
wb_ªg_pc


640 
vÆ
 
tvÆ_vÆid
 = 
wb_x˝t
 && 
wb_ˇu£
.
	`isO√Of
(
Cau£s
.
ûÀgÆ_ö°ru˘i⁄
, Cau£s.
bªakpoöt
,

641 
Cau£s
.
mißlig√d_lﬂd
, Cau£s.
mißlig√d_°‹e
,

642 
Cau£s
.
lﬂd_ac˚ss
, Cau£s.
°‹e_ac˚ss
, Cau£s.
„tch_ac˚ss
,

643 
Cau£s
.
lﬂd_∑ge_Áu…
, Cau£s.
°‹e_∑ge_Áu…
, Cau£s.
„tch_∑ge_Áu…
)

644 
c§
.
io
.
tvÆ
 :
	`Mux
(
tvÆ_vÆid
, 
	`ícodeVútuÆAddªss
(
wb_ªg_wd©a
, wb_reg_wdata), 0.U)

645 
io
.
±w
.
±br
 :
c§
.io.ptbr

646 (
io
.
±w
.
cu°omCSRs
.
c§s
 
zù
 
c§
.io.cu°omCSRs).
m≠
 { (
lhs
, 
rhs
) =>Ühs :=Ñhs }

647 
io
.
±w
.
°©us
 :
c§
.io.status

648 
io
.
±w
.
pmp
 :
c§
.io.pmp

649 
c§
.
io
.
rw
.
addr
 :
	`wb_ªg_ö°
(31,20)

650 
c§
.
io
.
rw
.
cmd
 :
CSR
.
	`maskCmd
(
wb_ªg_vÆid
, 
wb_˘æ
.csr)

651 
c§
.
io
.
rw
.
wd©a
 :
wb_ªg_wd©a


652 
io
.
åa˚
 :
c§
.io.trace

654 
vÆ
 
haz¨d_èrgës
 = 
	`Seq
((
id_˘æ
.
rxs1
 && 
id_øddr1
 =/
	`UI¡
(0), id_raddr1),

655 (
id_˘æ
.
rxs2
 && 
id_øddr2
 =/
	`UI¡
(0), id_raddr2),

656 (
id_˘æ
.
wxd
 && 
id_waddr
 =/
	`UI¡
(0), id_waddr))

657 
vÆ
 
Â_haz¨d_èrgës
 = 
	`Seq
((
io
.
Âu
.
dec
.
ªn1
, 
id_øddr1
),

658 (
io
.
Âu
.
dec
.
ªn2
, 
id_øddr2
),

659 (
io
.
Âu
.
dec
.
ªn3
, 
id_øddr3
),

660 (
io
.
Âu
.
dec
.
wí
, 
id_waddr
))

662 
vÆ
 
sbﬂrd
 = 
√w
 
	`Sc‹ebﬂrd
(32, 
åue
)

663 
sbﬂrd
.
	`˛ór
(
Œ_wí
, 
Œ_waddr
)

664 
def
 
	`id_sbﬂrd_˛ór_by∑ss
(
r
: 
UI¡
) = {

666 i‡(!
tûeP¨ams
.
dˇche
.
gë
.
d©aECC
.
isDeföed
Ë
Œ_wí
 && 
Œ_waddr
 ==
r


667 
div
.
io
.
ª•
.
	`fúe
(Ë&& div.io.ª•.
bôs
.
èg
 ==
r
 || 
dmem_ª•_ª∂ay
 && 
dmem_ª•_xpu
 && 
dmem_ª•_waddr
 ===Ñ

669 
vÆ
 
id_sbﬂrd_haz¨d
 = 
	`checkHaz¨ds
(
haz¨d_èrgës
, 
rd
 => 
sbﬂrd
.
	`ªad
‘dË&& !
	`id_sbﬂrd_˛ór_by∑ss
(rd))

670 
sbﬂrd
.
	`£t
(
wb_£t_sbﬂrd
 && 
wb_wí
, 
wb_waddr
)

673 
vÆ
 
ex_ˇ¬Ÿ_by∑ss
 = 
ex_˘æ
.
c§
 =/
CSR
.
N
 ||Éx_˘æ.
jÆr
 ||Éx_˘æ.
mem
 ||Éx_˘æ.
mul
 ||Éx_˘æ.
div
 ||Éx_˘æ.
Â
 ||Éx_˘æ.
rocc


674 
vÆ
 
d©a_haz¨d_ex
 = 
ex_˘æ
.
wxd
 && 
	`checkHaz¨ds
(
haz¨d_èrgës
, 
_
 ==
ex_waddr
)

675 
vÆ
 
Â_d©a_haz¨d_ex
 = 
ex_˘æ
.
wfd
 && 
	`checkHaz¨ds
(
Â_haz¨d_èrgës
, 
_
 ==
ex_waddr
)

676 
vÆ
 
id_ex_haz¨d
 = 
ex_ªg_vÆid
 && (
d©a_haz¨d_ex
 && 
ex_ˇ¬Ÿ_by∑ss
 || 
Â_d©a_haz¨d_ex
)

679 
vÆ
 
mem_mem_cmd_bh
 =

680 i‡(
Á°LﬂdW‹d
Ë
	`Boﬁ
(!
Á°LﬂdByã
Ë&& 
mem_ªg_¶ow_by∑ss


681 
	`Boﬁ
(
åue
)

682 
vÆ
 
mem_ˇ¬Ÿ_by∑ss
 = 
mem_˘æ
.
c§
 =/
CSR
.
N
 || mem_˘æ.
mem
 && 
mem_mem_cmd_bh
 || mem_˘æ.
mul
 || mem_˘æ.
div
 || mem_˘æ.
Â
 || mem_˘æ.
rocc


683 
vÆ
 
d©a_haz¨d_mem
 = 
mem_˘æ
.
wxd
 && 
	`checkHaz¨ds
(
haz¨d_èrgës
, 
_
 ==
mem_waddr
)

684 
vÆ
 
Â_d©a_haz¨d_mem
 = 
mem_˘æ
.
wfd
 && 
	`checkHaz¨ds
(
Â_haz¨d_èrgës
, 
_
 ==
mem_waddr
)

685 
vÆ
 
id_mem_haz¨d
 = 
mem_ªg_vÆid
 && (
d©a_haz¨d_mem
 && 
mem_ˇ¬Ÿ_by∑ss
 || 
Â_d©a_haz¨d_mem
)

686 
id_lﬂd_u£
 :
mem_ªg_vÆid
 && 
d©a_haz¨d_mem
 && 
mem_˘æ
.
mem


689 
vÆ
 
d©a_haz¨d_wb
 = 
wb_˘æ
.
wxd
 && 
	`checkHaz¨ds
(
haz¨d_èrgës
, 
_
 ==
wb_waddr
)

690 
vÆ
 
Â_d©a_haz¨d_wb
 = 
wb_˘æ
.
wfd
 && 
	`checkHaz¨ds
(
Â_haz¨d_èrgës
, 
_
 ==
wb_waddr
)

691 
vÆ
 
id_wb_haz¨d
 = 
wb_ªg_vÆid
 && (
d©a_haz¨d_wb
 && 
wb_£t_sbﬂrd
 || 
Â_d©a_haz¨d_wb
)

693 
vÆ
 
id_°Æl_Âu
 = i‡(
usögFPU
) {

694 
vÆ
 
Â_sbﬂrd
 = 
√w
 
	`Sc‹ebﬂrd
(32)

695 
Â_sbﬂrd
.
	`£t
((
wb_dˇche_miss
 && 
wb_˘æ
.
wfd
 || 
io
.
Âu
.
sbﬂrd_£t
Ë&& 
wb_vÆid
, 
wb_waddr
)

696 
Â_sbﬂrd
.
	`˛ór
(
dmem_ª•_ª∂ay
 && 
dmem_ª•_Âu
, 
dmem_ª•_waddr
)

697 
Â_sbﬂrd
.
	`˛ór
(
io
.
Âu
.
sbﬂrd_˛r
, io.Âu.
sbﬂrd_˛ø
)

699 
	`checkHaz¨ds
(
Â_haz¨d_èrgës
, 
Â_sbﬂrd
.
ªad
 
_
)

700 } 
	`Boﬁ
(
Ál£
)

702 
vÆ
 
dˇche_blocked
 = {

704 
vÆ
 
blocked
 = 
	`Reg
(
	`Boﬁ
())

705 
blocked
 :!
io
.
dmem
.
ªq
.
ªady
 && io.dmem.
˛ock_íabÀd
 && !io.dmem.
≥rf
.
gø¡
 && (blocked || io.dmem.ªq.
vÆid
 || io.dmem.
s2_«ck
)

706 
blocked
 && !
io
.
dmem
.
≥rf
.
gø¡


708 
vÆ
 
rocc_blocked
 = 
	`Reg
(
	`Boﬁ
())

709 
rocc_blocked
 :!
wb_x˝t
 && !
io
.
rocc
.
cmd
.
ªady
 && (io.rocc.cmd.
vÆid
 ||Ñocc_blocked)

711 
vÆ
 
˘æ_°Æld
 =

712 
id_ex_haz¨d
 || 
id_mem_haz¨d
 || 
id_wb_haz¨d
 || 
id_sbﬂrd_haz¨d
 ||

713 
c§
.
io
.
sögÀSãp
 && (
ex_ªg_vÆid
 || 
mem_ªg_vÆid
 || 
wb_ªg_vÆid
) ||

714 
id_c§_í
 && 
c§
.
io
.
	`decode
(0).
Â_c§
 && !io.
Âu
.
fc§_rdy
 ||

715 
id_˘æ
.
Â
 && 
id_°Æl_Âu
 ||

716 
id_˘æ
.
mem
 && 
dˇche_blocked
 ||

717 
id_˘æ
.
rocc
 && 
rocc_blocked
 ||

718 
id_˘æ
.
div
 && (!(div.
io
.
ªq
.
ªady
 || (div.io.
ª•
.
vÆid
 && !
wb_wxd
)) || div.io.req.valid) ||

719 !
˛ock_í
 ||

720 
id_do_„n˚
 ||

721 
c§
.
io
.
c§_°Æl


722 
˘æ_kûld
 :!
ibuf
.
io
.
	`ö°
(0).
vÆid
 || ibuf.io.ö°(0).
bôs
.
ª∂ay
 || 
èke_pc_mem_wb
 || 
˘æ_°Æld
 || 
c§
.io.
öãºu±


724 
io
.
imem
.
ªq
.
vÆid
 :
èke_pc


725 
io
.
imem
.
ªq
.
bôs
.
•ecuœtive
 :!
èke_pc_wb


726 
io
.
imem
.
ªq
.
bôs
.
pc
 :=

727 
	`Mux
(
wb_x˝t
 || 
c§
.
io
.
îë
, c§.io.
evec
,

728 
	`Mux
(
ª∂ay_wb
, 
wb_ªg_pc
,

729 
mem_≈c
))

730 
io
.
imem
.
Êush_iˇche
 :
wb_ªg_vÆid
 && 
wb_˘æ
.
„n˚_i
 && !io.
dmem
.
s2_«ck


731 
io
.
imem
.
might_ªque°
 := {

732 
imem_might_ªque°_ªg
 :
ex_pc_vÆid
 || 
mem_pc_vÆid
 || 
io
.
±w
.
cu°omCSRs
.
dißbÀICacheClockG©e


733 
imem_might_ªque°_ªg


735 
io
.
imem
.
s„n˚
.
vÆid
 :
wb_ªg_vÆid
 && 
wb_ªg_s„n˚


736 
io
.
imem
.
s„n˚
.
bôs
.
rs1
 :
wb_˘æ
.
	`mem_ty≥
(0)

737 
io
.
imem
.
s„n˚
.
bôs
.
rs2
 :
wb_˘æ
.
	`mem_ty≥
(1)

738 
io
.
imem
.
s„n˚
.
bôs
.
addr
 :
wb_ªg_wd©a


739 
io
.
imem
.
s„n˚
.
bôs
.
asid
 :
wb_ªg_rs2


740 
io
.
±w
.
s„n˚
 :io.
imem
.sfence

742 
ibuf
.
io
.
	`ö°
(0).
ªady
 :!
˘æ_°Æld


744 
io
.
imem
.
btb_upd©e
.
vÆid
 :
mem_ªg_vÆid
 && !
èke_pc_wb
 && 
mem_wr⁄g_≈c
 && (!
mem_cfi
 || 
mem_cfi_èkí
)

745 
io
.
imem
.
btb_upd©e
.
bôs
.
isVÆid
 :
mem_cfi


746 
io
.
imem
.
btb_upd©e
.
bôs
.
cfiTy≥
 :=

747 
	`Mux
((
mem_˘æ
.
jÆ
 || mem_˘æ.
jÆr
Ë&& 
	`mem_waddr
(0), 
CFITy≥
.
ˇŒ
,

748 
	`Mux
(
mem_˘æ
.
jÆr
 && 
	`mem_ªg_ö°
(19,15Ë==
	`BôP©
("b00?01"), 
CFITy≥
.
ªt
,

749 
	`Mux
(
mem_˘æ
.
jÆ
 || mem_˘æ.
jÆr
, 
CFITy≥
.
jump
,

750 
CFITy≥
.
bønch
)))

751 
io
.
imem
.
btb_upd©e
.
bôs
.
èrgë
 :io.imem.
ªq
.bôs.
pc


752 
io
.
imem
.
btb_upd©e
.
bôs
.
br_pc
 :(i‡(
usögCom¥es£d
Ë
mem_ªg_pc
 + 
	`Mux
(
mem_ªg_rvc
, 
	`UI¡
(0), UInt(2)) mem_reg_pc)

753 
io
.
imem
.
btb_upd©e
.
bôs
.
pc
 :~(~io.imem.btb_upd©e.bôs.
br_pc
 | (
c‹eIn°Byãs
*
„tchWidth
-1))

754 
io
.
imem
.
btb_upd©e
.
bôs
.
¥edi˘i⁄
 :
mem_ªg_btb_ª•


756 
io
.
imem
.
bht_upd©e
.
vÆid
 :
mem_ªg_vÆid
 && !
èke_pc_wb


757 
io
.
imem
.
bht_upd©e
.
bôs
.
pc
 :io.imem.
btb_upd©e
.bits.pc

758 
io
.
imem
.
bht_upd©e
.
bôs
.
èkí
 :
mem_br_èkí


759 
io
.
imem
.
bht_upd©e
.
bôs
.
mi•ªdi˘
 :
mem_wr⁄g_≈c


760 
io
.
imem
.
bht_upd©e
.
bôs
.
bønch
 :
mem_˘æ
.branch

761 
io
.
imem
.
bht_upd©e
.
bôs
.
¥edi˘i⁄
 :
mem_ªg_btb_ª•
.
bht


763 
io
.
Âu
.
vÆid
 :!
˘æ_kûld
 && 
id_˘æ
.
Â


764 
io
.
Âu
.
kûlx
 :
˘æ_kûlx


765 
io
.
Âu
.
kûlm
 :
kûlm_comm⁄


766 
io
.
Âu
.
ö°
 :
	`id_ö°
(0)

767 
io
.
Âu
.
‰omöt_d©a
 :
	`ex_rs
(0)

768 
io
.
Âu
.
dmem_ª•_vÆ
 :
dmem_ª•_vÆid
 && 
dmem_ª•_Âu


769 
io
.
Âu
.
dmem_ª•_d©a
 :io.
dmem
.
ª•
.
bôs
.
d©a_w‹d_by∑ss


770 
io
.
Âu
.
dmem_ª•_ty≥
 :io.
dmem
.
ª•
.
bôs
.
typ


771 
io
.
Âu
.
dmem_ª•_èg
 :
dmem_ª•_waddr


772 
io
.
Âu
.
kìp_˛ock_íabÀd
 :io.
±w
.
cu°omCSRs
.
dißbÀC‹eClockG©e


774 
io
.
dmem
.
ªq
.
vÆid
 :
ex_ªg_vÆid
 && 
ex_˘æ
.
mem


775 
vÆ
 
ex_dˇche_èg
 = 
	`C©
(
ex_waddr
, 
ex_˘æ
.
Â
)

776 
	`ªquúe
(
c‹eDCacheReqTagBôs
 >
ex_dˇche_èg
.
gëWidth
)

777 
io
.
dmem
.
ªq
.
bôs
.
èg
 :
ex_dˇche_èg


778 
io
.
dmem
.
ªq
.
bôs
.
cmd
 :
ex_˘æ
.
mem_cmd


779 
io
.
dmem
.
ªq
.
bôs
.
typ
 :
ex_˘æ
.
mem_ty≥


780 
io
.
dmem
.
ªq
.
bôs
.
phys
 :
	`Boﬁ
(
Ál£
)

781 
io
.
dmem
.
ªq
.
bôs
.
addr
 :
	`ícodeVútuÆAddªss
(
	`ex_rs
(0), 
Æu
.io.
addî_out
)

782 
io
.
dmem
.
s1_d©a
.
d©a
 :(i‡(
fLí
 =0Ë
mem_ªg_rs2
 
	`Mux
(
mem_˘æ
.
Â
, 
	`Fûl
((
xLí
 
max
 fLíË/ fLí, io.
Âu
.
°‹e_d©a
), mem_reg_rs2))

783 
io
.
dmem
.
s1_kûl
 :
kûlm_comm⁄
 || 
mem_ld°_x˝t
 || 
Âu_kûl_mem


784 
io
.
dmem
.
s2_kûl
 :
Ál£


786 
io
.
dmem
.
kìp_˛ock_íabÀd
 :
ibuf
.io.
	`ö°
(0).
vÆid
 && 
id_˘æ
.
mem


788 
io
.
rocc
.
cmd
.
vÆid
 :
wb_ªg_vÆid
 && 
wb_˘æ
.roc¯&& !
ª∂ay_wb_comm⁄


789 
io
.
rocc
.
ex˚±i⁄
 :
wb_x˝t
 && 
c§
.io.
°©us
.
xs
.
‹R


790 
io
.
rocc
.
cmd
.
bôs
.
°©us
 :
c§
.io.status

791 
io
.
rocc
.
cmd
.
bôs
.
ö°
 :
√w
 
	`RoCCIn°ru˘i⁄
().
	`‰omBôs
(
wb_ªg_ö°
)

792 
io
.
rocc
.
cmd
.
bôs
.
rs1
 :
wb_ªg_wd©a


793 
io
.
rocc
.
cmd
.
bôs
.
rs2
 :
wb_ªg_rs2


796 i‡(
rockëP¨ams
.
˛ockG©e
) {

797 
l⁄g_œãncy_°Æl
 :
c§
.
io
.
c§_°Æl
 || io.
dmem
.
≥rf
.
blocked


798 
˛ock_í
 :
˛ock_í_ªg
 || (!
l⁄g_œãncy_°Æl
 && 
io
.
imem
.
ª•
.
vÆid
)

799 
˛ock_í_ªg
 :=

800 
ex_pc_vÆid
 || 
mem_pc_vÆid
 || 
wb_pc_vÆid
 ||

801 
io
.
±w
.
cu°omCSRs
.
dißbÀC‹eClockG©e
 ||

802 !
div
.
io
.
ªq
.
ªady
 ||

803 
usögFPU
 && !
io
.
Âu
.
fc§_rdy
 ||

804 
io
.
dmem
.
ª∂ay_√xt
 ||

805 (!
l⁄g_œãncy_°Æl
 && (
ibuf
.
io
.
	`ö°
(0).
vÆid
 || io.
imem
.
ª•
.valid))

807 
	`as£π
(!(
ex_pc_vÆid
 || 
mem_pc_vÆid
 || 
wb_pc_vÆid
Ë|| 
˛ock_í
)

811 
vÆ
 
iˇche_blocked
 = !(
io
.
imem
.
ª•
.
vÆid
 || 
	`RegNext
(io.imem.resp.valid))

812 
c§
.
io
.
cou¡îs
 
f‹óch
 { 
c
 => c.
öc
 :
	`RegNext
(
≥rfEvíts
.
	`evÆu©e
(c.
evítSñ
)) }

814 ˛as†
	cC‹eM⁄ô‹BundÀ
 
exãnds
 
BundÀ
 {

815 
vÆ
 
h¨tid
 = 
	`UI¡
(
width
 = 
h¨tIdLí
)

816 
vÆ
 
time
 = 
	`UI¡
(
width
 = 32)

817 
vÆ
 
vÆid
 = 
	`Boﬁ
()

818 
vÆ
 
pc
 = 
	`UI¡
(
width
 = 
vaddrBôsExãnded
)

819 
vÆ
 
wrd°
 = 
	`UI¡
(
width
 = 5)

820 
vÆ
 
wrd©a
 = 
	`UI¡
(
width
 = 
xLí
)

821 
vÆ
 
wªn
 = 
	`Boﬁ
()

822 
vÆ
 
rd0§c
 = 
	`UI¡
(
width
 = 5)

823 
vÆ
 
rd0vÆ
 = 
	`UI¡
(
width
 = 
xLí
)

824 
vÆ
 
rd1§c
 = 
	`UI¡
(
width
 = 5)

825 
vÆ
 
rd1vÆ
 = 
	`UI¡
(
width
 = 
xLí
)

826 
vÆ
 
ö°
 = 
	`UI¡
(
width
 = 32)

828 
vÆ
 
c‹eM⁄ô‹BundÀ
 = 
	`Wúe
(
√w
 
C‹eM⁄ô‹BundÀ
)

830 
c‹eM⁄ô‹BundÀ
.
h¨tid
 :
io
.hartid

831 
c‹eM⁄ô‹BundÀ
.
time
 :
c§
.
io
.
	`time
(31,0)

832 
c‹eM⁄ô‹BundÀ
.
vÆid
 :
c§
.
io
.
	`åa˚
(0).vÆid && !c§.io.åa˚(0).
ex˚±i⁄


833 
c‹eM⁄ô‹BundÀ
.
pc
 :
c§
.
io
.
	`åa˚
(0).
	`üddr
(
vaddrBôsExãnded
-1, 0)

834 
c‹eM⁄ô‹BundÀ
.
wrd°
 :
	`Mux
(
rf_wí
 && !(
wb_£t_sbﬂrd
 && 
wb_wí
), 
rf_waddr
, 
	`UI¡
(0))

835 
c‹eM⁄ô‹BundÀ
.
wrd©a
 :
rf_wd©a


836 
c‹eM⁄ô‹BundÀ
.
wªn
 :
rf_wí


837 
c‹eM⁄ô‹BundÀ
.
rd0§c
 :
	`wb_ªg_ö°
(19,15)

838 
c‹eM⁄ô‹BundÀ
.
rd0vÆ
 :
	`Reg
(
√xt
=Reg“ext=
	`ex_rs
(0)))

839 
c‹eM⁄ô‹BundÀ
.
rd1§c
 :
	`wb_ªg_ö°
(24,20)

840 
c‹eM⁄ô‹BundÀ
.
rd1vÆ
 :
	`Reg
(
√xt
=Reg“ext=
	`ex_rs
(1)))

841 
c‹eM⁄ô‹BundÀ
.
ö°
 :
c§
.
io
.
	`åa˚
(0).
ö¢


843 
	`p
(
BundÀM⁄ô‹Key
).
f‹óch
 { 
	`_
 ("rockë_c‹e_m⁄ô‹", 
c‹eM⁄ô‹BundÀ
) }

845 i‡(
íabÀCommôLog
) {

846 
vÆ
 
t
 = 
c§
.
io
.
	`åa˚
(0)

847 
vÆ
 
rd
 = 
wb_waddr


848 
vÆ
 
wfd
 = 
wb_˘æ
.wfd

849 
vÆ
 
wxd
 = 
wb_˘æ
.wxd

850 
vÆ
 
has_d©a
 = 
wb_wí
 && !
wb_£t_sbﬂrd


852 
	`whí
 (
t
.
vÆid
 && !t.
ex˚±i⁄
) {

853 
	`whí
 (
wfd
) {

854 
	`¥ötf
 ("%d 0x%x (0x%xËf%dÖ%d 0xXXXXXXXXXXXXXXXX\n", 
t
.
¥iv
,Å.
üddr
,Å.
ö¢
, 
rd
,Ñd+
	`UI¡
(32))

856 .
	`ñ£whí
 (
wxd
 && 
rd
 =/
	`UI¡
(0Ë&& 
has_d©a
) {

857 
	`¥ötf
 ("%d 0x%x (0x%xËx%d 0x%x\n", 
t
.
¥iv
,Å.
üddr
,Å.
ö¢
, 
rd
, 
rf_wd©a
)

859 .
	`ñ£whí
 (
wxd
 && 
rd
 =/
	`UI¡
(0Ë&& !
has_d©a
) {

860 
	`¥ötf
 ("%d 0x%x (0x%xËx%dÖ%d 0xXXXXXXXXXXXXXXXX\n", 
t
.
¥iv
,Å.
üddr
,Å.
ö¢
, 
rd
,Ñd)

862 .
Ÿhîwi£
 {

863 
	`¥ötf
 ("%d 0x%x (0x%x)\n", 
t
.
¥iv
,Å.
üddr
,Å.
ö¢
)

867 
	`whí
 (
Œ_wí
 && 
rf_waddr
 =/
	`UI¡
(0)) {

868 
	`¥ötf
 ("x%dÖ%d 0x%x\n", 
rf_waddr
,Ñf_waddr, 
rf_wd©a
)

881 
PlusArg
.
	`timeout
(

882 
«me
 = "max_core_cycles",

883 
doc°rög
 = "KillÅheÉmulationáfter INTÑdtime cycles. Off if 0."

884 )(
c§
.
io
.
time
)

887 
	$wôhClock
 (
g©ed_˛ock
Ë{ 
√w
 
RockëIm∂
 
	}
}

889 
def
 
checkEx˚±i⁄s
(
x
: 
Seq
[(
Boﬁ
, 
UI¡
)]) =

890 (
x
.
m≠
(
_
.
_1
).
ªdu˚
(_||_), 
	$Pri‹ôyMux
(
x
))

892 
def
 
	`covîEx˚±i⁄s
(
ex˚±i⁄VÆid
: 
Boﬁ
, 
ˇu£
: 
UI¡
, 
œbñPªfix
: 
Såög
, 
covîCau£sLabñs
: 
Seq
[(
I¡
, Såög)]): 
Unô
 = {

893 (
covîCau£
, 
œbñ
Ë<- 
covîCau£sLabñs
) {

894 
	`covî
(
ex˚±i⁄VÆid
 && (
ˇu£
 ==
	`UI¡
(
covîCau£
)), 
s
"${labelPrefix}_${label}")

896 
	}
}

898 
def
 
checkHaz¨ds
(
èrgës
: 
Seq
[(
Boﬁ
, 
UI¡
)], 
c⁄d
: UInt => Bool) =

899 
èrgës
.
m≠
(
h
 => h.
_1
 && 
c⁄d
(h.
_2
)).
ªdu˚
(
_
||_)

901 
def
 
ícodeVútuÆAddªss
(
a0
: 
UI¡
, 
ó
: UI¡Ëi‡(
vaddrBôsExãnded
 =
vaddrBôs
)Éa {

904 
vÆ
 
a
 = 
a0
.
asSI¡
 >> 
vaddrBôs


905 
vÆ
 
msb
 = 
Mux
(
a
 ==0.
S
 ||á ==-1.S, 
ó
(
vaddrBôs
), !ea(vaddrBits-1))

906 
C©
(
msb
, 
ó
(
vaddrBôs
-1,0))

909 
˛ass
 
	$Sc‹ebﬂrd
(
n
: 
I¡
, 
zîo
: 
Boﬁón
 = 
Ál£
)

911 
def
 
	`£t
(
í
: 
Boﬁ
, 
addr
: 
UI¡
): 
Unô
 = 
	`upd©e
”n, 
_√xt
 | 
	`mask
(en,áddr))

912 
def
 
	`˛ór
(
í
: 
Boﬁ
, 
addr
: 
UI¡
): 
Unô
 = 
	`upd©e
”n, 
_√xt
 & ~
	`mask
(en,áddr))

913 
def
 
	`ªad
(
addr
: 
UI¡
): 
Boﬁ
 = 
	`r
(addr)

914 
def
 
	`ªadBy∑s£d
(
addr
: 
UI¡
): 
Boﬁ
 = 
	`_√xt
(addr)

916 
¥iv©e
 
vÆ
 
_r
 = 
	`Reg
(
öô
=
	`Bôs
(0, 
n
))

917 
¥iv©e
 
vÆ
 
r
 = i‡(
zîo
Ë(
_r
 >> 1 << 1) _r

918 
¥iv©e
 
v¨
 
_√xt
 = 
r


919 
¥iv©e
 
v¨
 
ís
 = 
	`Boﬁ
(
Ál£
)

920 
¥iv©e
 
def
 
	`mask
(
í
: 
Boﬁ
, 
addr
: 
UI¡
Ë
	`Mux
”n, 
	`UI¡
(1) <<áddr, UInt(0))

921 
¥iv©e
 
def
 
	`upd©e
(
í
: 
Boﬁ
, 
upd©e
: 
UI¡
) = {

922 
_√xt
 = 
upd©e


923 
ís
 =Én†|| 
í


924 
	`whí
 (
ís
Ë{ 
_r
 :
_√xt
 }

926 
	}
}

929 
˛ass
 
	$RegFûe
(
n
: 
I¡
, 
w
: I¡, 
zîo
: 
Boﬁón
 = 
Ál£
) {

930 
¥iv©e
 
vÆ
 
rf
 = 
	`Mem
(
n
, 
	`UI¡
(
width
 = 
w
))

931 
¥iv©e
 
def
 
	`ac˚ss
(
addr
: 
UI¡
Ë
	`rf
(~
	`addr
(
	`log2Up
(
n
)-1,0))

932 
¥iv©e
 
vÆ
 
ªads
 = 
AºayBuf„r
[(
UI¡
,UInt)]()

933 
¥iv©e
 
v¨
 
ˇnRód
 = 
åue


934 
def
 
	`ªad
(
addr
: 
UI¡
) = {

935 
	`ªquúe
(
ˇnRód
)

936 
ªads
 +
addr
 -> 
	`Wúe
(
	`UI¡
())

937 
ªads
.
œ°
.
_2
 :
	`Mux
(
	`Boﬁ
(
zîo
Ë&& 
addr
 ==
	`UI¡
(0), UI¡(0), 
	`ac˚ss
(addr))

938 
ªads
.
œ°
.
_2


940 
def
 
	`wrôe
(
addr
: 
UI¡
, 
d©a
: UInt) = {

941 
ˇnRód
 = 
Ál£


942 
	`whí
 (
addr
 =/
	`UI¡
(0)) {

943 
	`ac˚ss
(
addr
Ë:
d©a


944 (
øddr
, 
rd©a
Ë<- 
ªads
)

945 
	`whí
 (
addr
 ==
øddr
Ë{ 
rd©a
 :
d©a
 }

948 
	}
}

950 
obje˘
 
ImmGí
 {

951 
def
 
≠∂y
(
£l
: 
UI¡
, 
ö°
: UInt) = {

952 
vÆ
 
sign
 = 
Mux
(
£l
 ==
IMM_Z
, 
SI¡
(0), 
ö°
(31).
asSI¡
)

953 
vÆ
 
	gb30_20
 = 
Mux
(
£l
 ==
IMM_U
, 
ö°
(30,20).
asSI¡
, 
sign
)

954 
vÆ
 
	gb19_12
 = 
Mux
(
£l
 =/
IMM_U
 && sñ =/
IMM_UJ
, 
sign
, 
ö°
(19,12).
asSI¡
)

955 
vÆ
 
	gb11
 = 
Mux
(
£l
 ==
IMM_U
 || sñ ==
IMM_Z
, 
SI¡
(0),

956 
Mux
(
£l
 ==
IMM_UJ
, 
ö°
(20).
asSI¡
,

957 
Mux
(
£l
 ==
IMM_SB
, 
ö°
(7).
asSI¡
, 
sign
)))

958 
vÆ
 
	gb10_5
 = 
Mux
(
£l
 ==
IMM_U
 || sñ ==
IMM_Z
, 
Bôs
(0), 
ö°
(30,25))

959 
vÆ
 
	gb4_1
 = 
Mux
(
£l
 ==
IMM_U
, 
Bôs
(0),

960 
Mux
(
£l
 ==
IMM_S
 || sñ ==
IMM_SB
, 
ö°
(11,8),

961 
Mux
(
£l
 ==
IMM_Z
, 
ö°
(19,16), inst(24,21))))

962 
vÆ
 
	gb0
 = 
Mux
(
£l
 ==
IMM_S
, 
ö°
(7),

963 
Mux
(
£l
 ==
IMM_I
, 
ö°
(20),

964 
Mux
(
£l
 ==
IMM_Z
, 
ö°
(15), 
Bôs
(0))))

966 
C©
(
sign
, 
b30_20
, 
b19_12
, 
b11
, 
b10_5
, 
b4_1
, 
b0
).
	gasSI¡


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ScratchpadSlavePort.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


15 
˛ass
 
	$S¸©ch∑dSœveP‹t
(
addªss
: 
AddªssSë
, 
c‹eD©aByãs
: 
I¡
, 
usögAtomics
: 
Boﬁón
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

16 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
("dtim", 
	`Seq
("sifive,dtim0"))

17 
vÆ
 
node
 = 
	`TLM™agîNode
(
	`Seq
(
	`TLM™agîP‹tP¨amëîs
(

18 
	`Seq
(
	`TLM™agîP¨amëîs
(

19 
addªss
 = 
	`Li°
(address),

20 
ªsour˚s
 = 
devi˚
.
	`ªg
("mem"),

21 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHEABLE
,

22 
execuèbÀ
 = 
åue
,

23 
suµ‹tsArôhmëic
 = i‡(
usögAtomics
Ë
	`Tøns„rSizes
(4, 
c‹eD©aByãs
Ë
Tøns„rSizes
.
n⁄e
,

24 
suµ‹tsLogiˇl
 = i‡(
usögAtomics
Ë
	`Tøns„rSizes
(4, 
c‹eD©aByãs
Ë
Tøns„rSizes
.
n⁄e
,

25 
suµ‹tsPutP¨tül
 = 
	`Tøns„rSizes
(1, 
c‹eD©aByãs
),

26 
suµ‹tsPutFuŒ
 = 
	`Tøns„rSizes
(1, 
c‹eD©aByãs
),

27 
suµ‹tsGë
 = 
	`Tøns„rSizes
(1, 
c‹eD©aByãs
),

28 
fifoId
 = 
	`Some
(0))),

29 
bótByãs
 = 
c‹eD©aByãs
,

30 
möL©ícy
 = 1)))

32 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

33 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

34 
vÆ
 
dmem
 = 
√w
 
HñœCacheIO


37 
	`vÆ
 (
é_ö
, 
edge
Ë
node
.
	`ö
(0)

39 
vÆ
 
s_ªady
 :: 
s_waô1
 :: 
s_waô2
 :: 
s_ª∂ay
 :: 
s_gø¡
 :: 
Nû
 = 
	`Enum
(
	`UI¡
(), 5)

40 
vÆ
 
°©e
 = 
	`Reg
(
öô
 = 
s_ªady
)

41 
vÆ
 
dmem_ªq_vÆid
 = 
	`Wúe
(
	`Boﬁ
())

42 
	`whí
 (
°©e
 ==
s_waô1
Ë{ sèã :
s_waô2
 }

43 
	`whí
 (
io
.
dmem
.
ª•
.
vÆid
Ë{ 
°©e
 :
s_gø¡
 }

44 
	`whí
 (
é_ö
.
d
.
	`fúe
()Ë{ 
°©e
 :
s_ªady
 }

45 
	`whí
 (
io
.
dmem
.
s2_«ck
Ë{ 
°©e
 :
s_ª∂ay
 }

46 
	`whí
 (
dmem_ªq_vÆid
 && 
io
.
dmem
.
ªq
.
ªady
Ë{ 
°©e
 :
s_waô1
 }

48 
vÆ
 
acq
 = 
	`Reg
(
é_ö
.
a
.
bôs
)

49 
	`whí
 (
é_ö
.
a
.
	`fúe
()Ë{ 
acq
 :é_ö.a.
bôs
 }

51 
def
 
	`f‹mCacheReq
(
a
: 
TLBundÀA
) = {

52 
vÆ
 
ªq
 = 
	`Wúe
(
√w
 
HñœCacheReq
)

53 
ªq
.
cmd
 :
	`MuxLookup
(
a
.
›code
, 
	`Wúe
(
M_XRD
), 
	`Aºay
(

54 
TLMesßges
.
PutFuŒD©a
 -> 
M_XWR
,

55 
TLMesßges
.
PutP¨tülD©a
 -> 
M_PWR
,

56 
TLMesßges
.
ArôhmëicD©a
 -> 
	`MuxLookup
(
a
.
∑øm
, 
	`Wúe
(
M_XRD
), 
	`Aºay
(

57 
TLAtomics
.
MIN
 -> 
M_XA_MIN
,

58 
TLAtomics
.
MAX
 -> 
M_XA_MAX
,

59 
TLAtomics
.
MINU
 -> 
M_XA_MINU
,

60 
TLAtomics
.
MAXU
 -> 
M_XA_MAXU
,

61 
TLAtomics
.
ADD
 -> 
M_XA_ADD
)),

62 
TLMesßges
.
LogiˇlD©a
 -> 
	`MuxLookup
(
a
.
∑øm
, 
	`Wúe
(
M_XRD
), 
	`Aºay
(

63 
TLAtomics
.
XOR
 -> 
M_XA_XOR
,

64 
TLAtomics
.
OR
 -> 
M_XA_OR
,

65 
TLAtomics
.
AND
 -> 
M_XA_AND
,

66 
TLAtomics
.
SWAP
 -> 
M_XA_SWAP
)),

67 
TLMesßges
.
Gë
 -> 
M_XRD
))

68 
ªq
.
typ
 :
a
.
size


69 
ªq
.
addr
 :
a
.
addªss


70 
ªq
.
èg
 :
	`UI¡
(0)

71 
ªq
.
phys
 :
åue


72 
ªq


78 
vÆ
 
ªady_likñy
 = 
°©e
 ==
s_ªady
 || sèã ==
s_waô2


79 
vÆ
 
ªady
 = 
°©e
 ==
s_ªady
 || sèã ==
s_waô2
 && 
io
.
dmem
.
ª•
.
vÆid
 && 
é_ö
.
d
.ready

80 
dmem_ªq_vÆid
 :(
é_ö
.
a
.
vÆid
 && 
ªady
Ë|| 
°©e
 ==
s_ª∂ay


81 
vÆ
 
dmem_ªq_vÆid_likñy
 = (
é_ö
.
a
.
vÆid
 && 
ªady_likñy
Ë|| 
°©e
 ==
s_ª∂ay


83 
io
.
dmem
.
ªq
.
vÆid
 :
dmem_ªq_vÆid_likñy


84 
é_ö
.
a
.
ªady
 :
io
.
dmem
.
ªq
.ready &&Ñeady

85 
io
.
dmem
.
ªq
.
bôs
 :
	`f‹mCacheReq
(
	`Mux
(
°©e
 ==
s_ª∂ay
, 
acq
, 
é_ö
.
a
.bits))

86 
io
.
dmem
.
s1_d©a
.
d©a
 :
acq
.data

87 
io
.
dmem
.
s1_d©a
.
mask
 :
acq
.mask

88 
io
.
dmem
.
s1_kûl
 :
°©e
 =/
s_waô1


89 
io
.
dmem
.
s2_kûl
 :
Ál£


91 
é_ö
.
d
.
vÆid
 :
io
.
dmem
.
ª•
.vÆid || 
°©e
 ==
s_gø¡


92 
é_ö
.
d
.
bôs
 :
	`Mux
(
acq
.
›code
.
	`isO√Of
(
TLMesßges
.
PutFuŒD©a
, TLMesßges.
PutP¨tülD©a
),

93 
edge
.
	`Ac˚ssAck
(
acq
),

94 
edge
.
	`Ac˚ssAck
(
acq
, 
	`UI¡
(0)))

95 
é_ö
.
d
.
bôs
.
d©a
 :
io
.
dmem
.
ª•
.bôs.
d©a_øw
.
	`hﬁdU∆ess
(
°©e
 ==
s_waô2
)

98 
é_ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

99 
é_ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

100 
é_ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

102 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/SimpleHellaCacheIF.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


18 ˛as†
	cSim∂eHñœCacheIFRïœyQueue
(
dïth
: 
I¡
)

19 (
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ


20 
wôh
 
HasL1HñœCacheP¨amëîs
 {

21 
vÆ
 
io
 = 
√w
 
BundÀ
 {

22 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
HñœCacheReq
).
Êù


23 
vÆ
 
«ck
 = 
	`VÆid
(
	`Bôs
(
width
 = 
c‹eDCacheReqTagBôs
)).
Êù


24 
vÆ
 
ª•
 = 
	`VÆid
(
√w
 
HñœCacheRe•
).
Êù


25 
vÆ
 
ª∂ay
 = 
	`Decou∂ed
(
√w
 
HñœCacheReq
)

34 
vÆ
 
öÊight
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 
dïth
))

35 
vÆ
 
ªqs
 = 
	`Reg
(
	$Vec
(
dïth
, 
√w
 
HñœCacheReq
))

44 
vÆ
 
«ckq
 = 
	`ModuÀ
(
√w
 
	`Queue
(
	`UI¡
(
width
 = 
	`log2Up
(
dïth
)), depth))

45 
vÆ
 
ª∂ayög
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

47 
vÆ
 
√xt_öÊight_⁄ehŸ
 = 
	`Pri‹ôyEncodîOH
(~
öÊight
)

48 
vÆ
 
√xt_öÊight
 = 
	$OHToUI¡
(
√xt_öÊight_⁄ehŸ
)

50 
vÆ
 
√xt_ª∂ay
 = 
«ckq
.
io
.
deq
.
bôs


51 
vÆ
 
√xt_ª∂ay_⁄ehŸ
 = 
	$UI¡ToOH
(
√xt_ª∂ay
)

52 
vÆ
 
√xt_ª∂ay_ªq
 = 
	$ªqs
(
√xt_ª∂ay
)

55 
io
.
ª∂ay
.
vÆid
 :
«ckq
.io.
deq
.vÆid && !
ª∂ayög


56 
io
.
ª∂ay
.
bôs
 :
√xt_ª∂ay_ªq


59 
io
.
ªq
.
ªady
 :!
öÊight
.
™dR
 && !
«ckq
.io.
deq
.
vÆid
 && !io.
«ck
.valid

62 
vÆ
 
«ck_⁄ehŸ
 = 
	`C©
(
ªqs
.
	`m≠
(
_
.
èg
 ==
io
.
«ck
.
bôs
).
ªvî£
Ë& 
öÊight


63 
vÆ
 
ª•_⁄ehŸ
 = 
	`C©
(
ªqs
.
	`m≠
(
_
.
èg
 ==
io
.
ª•
.
bôs
.èg).
ªvî£
Ë& 
öÊight


65 
vÆ
 
ª∂ay_com∂ëe
 = 
io
.
ª•
.
vÆid
 && 
ª∂ayög
 && io.ª•.
bôs
.
èg
 ==
√xt_ª∂ay_ªq
.tag

66 
vÆ
 
«ck_hód
 = 
io
.
«ck
.
vÆid
 && 
«ckq
.io.
deq
.vÆid && io.«ck.
bôs
 ==
√xt_ª∂ay_ªq
.
èg


70 
«ckq
.
io
.
íq
.
vÆid
 :io.
«ck
.vÆid && !
«ck_hód


71 
«ckq
.
io
.
íq
.
bôs
 :
	$OHToUI¡
(
«ck_⁄ehŸ
)

72 
	`as£π
(!
«ckq
.
io
.
íq
.
vÆid
 ||Çackq.io.íq.
ªady
,

76 
«ckq
.
io
.
deq
.
ªady
 :
ª∂ay_com∂ëe


77 
	`as£π
(!
«ckq
.
io
.
deq
.
ªady
 ||Çackq.io.deq.
vÆid
,

82 
öÊight
 :(öÊighà| 
	`Mux
(
io
.
ªq
.
	`fúe
(), 
√xt_öÊight_⁄ehŸ
, 
	`UI¡
(0))) &

83 ~
	`Mux
(
io
.
ª•
.
vÆid
, 
ª•_⁄ehŸ
, 
	$UI¡
(0))

85 
	`whí
 (
io
.
ªq
.
	$fúe
()) {

86 
	`ªqs
(
√xt_öÊight
Ë:
io
.
ªq
.
bôs


87 
	}
}

90 
whí
 (
io
.
ª∂ay
.
	$fúe
()Ë{ 
ª∂ayög
 :
	`Boﬁ
(
åue
Ë
	}
}

91 
whí
 (
«ck_hód
 || 
ª∂ay_com∂ëe
Ë{ 
ª∂ayög
 :
Boﬁ
(
Ál£
) }

95 ˛as†
	cSim∂eHñœCacheIF
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ


97 
vÆ
 
io
 = 
√w
 
BundÀ
 {

98 
vÆ
 
ªque°‹
 = 
√w
 
	`HñœCacheIO
().
Êù


99 
vÆ
 
ˇche
 = 
√w
 
HñœCacheIO


102 
vÆ
 
ª∂ayq
 = 
	`ModuÀ
(
√w
 
	$Sim∂eHñœCacheIFRïœyQueue
(2))

103 
vÆ
 
ªq_¨b
 = 
	`ModuÀ
(
√w
 
	$Arbôî
(
√w
 
HñœCacheReq
, 2))

105 
vÆ
 
ªq_hñ≥r
 = 
	`Decou∂edHñ≥r
(

106 
ªq_¨b
.
io
.
	`ö
(1).
ªady
,

107 
ª∂ayq
.
io
.
ªq
.
ªady
,

108 
io
.
ªque°‹
.
ªq
.
vÆid
)

110 
ªq_¨b
.
io
.
	`ö
(0Ë<> 
ª∂ayq
.io.
ª∂ay


111 
ªq_¨b
.
io
.
	`ö
(1).
vÆid
 :
ªq_hñ≥r
.
	`fúe
‘eq_¨b.io.ö(1).
ªady
)

112 
ªq_¨b
.
io
.
	`ö
(1).
bôs
 :io.
ªque°‹
.
ªq
.bits

113 
io
.
ªque°‹
.
ªq
.
ªady
 :
ªq_hñ≥r
.
	$fúe
(
io
.
ªque°‹
.
ªq
.
vÆid
)

114 
ª∂ayq
.
io
.
ªq
.
vÆid
 :
ªq_hñ≥r
.
	$fúe
(
ª∂ayq
.
io
.
ªq
.
ªady
)

115 
ª∂ayq
.
io
.
ªq
.
bôs
 :io.
ªque°‹
.req.bits

117 
vÆ
 
s0_ªq_fúe
 = 
io
.
ˇche
.
ªq
.
	$fúe
()

118 
vÆ
 
s1_ªq_fúe
 = 
	$Reg
(
√xt
 = 
s0_ªq_fúe
)

119 
vÆ
 
s2_ªq_fúe
 = 
	$Reg
(
√xt
 = 
s1_ªq_fúe
)

120 
vÆ
 
s1_ªq_èg
 = 
	$Reg
(
√xt
 = 
io
.
ˇche
.
ªq
.
bôs
.
èg
)

121 
vÆ
 
s2_ªq_èg
 = 
	$Reg
(
√xt
 = 
s1_ªq_èg
)

122 
vÆ
 
s2_kûl
 = 
	$Reg
(
√xt
 = 
io
.
ˇche
.
s1_kûl
)

124 
io
.
ˇche
.
ªq
 <> 
ªq_¨b
.io.
out


125 
io
.
ˇche
.
s1_kûl
 :io.ˇche.
s2_«ck


126 
io
.
ˇche
.
s1_d©a
.
d©a
 :
	$RegE«bÀ
(
ªq_¨b
.
io
.
out
.
bôs
.
d©a
, 
s0_ªq_fúe
)

127 
io
.
ˇche
.
s2_kûl
 :
Ál£
.
B


129 
ª∂ayq
.
io
.
«ck
.
vÆid
 :(io.
ˇche
.
s2_«ck
 || 
s2_kûl
Ë&& 
s2_ªq_fúe


130 
ª∂ayq
.
io
.
«ck
.
bôs
 :
s2_ªq_èg


131 
ª∂ayq
.
io
.
ª•
 :io.
ˇche
.resp

132 
io
.
ªque°‹
.
ª•
 :io.
ˇche
.resp

134 
	`as£π
(!
	`RegNext
(RegNext(
io
.
ˇche
.
ªq
.
	`fúe
())Ë|| !io.ˇche.
s2_x˝t
.
asUI¡
.
‹R
,

136 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLB.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
CacheBlockByãs


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
Regi⁄Ty≥


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.{
	gXLí
, 
	gC‹eModuÀ
, 
	gC‹eBundÀ
}

13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


15 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


16 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


18 
obje˘
 
PgLevñs
 
exãnds
 
	gFõld
[
I¡
](2)

19 
obje˘
 
ASIdBôs
 
exãnds
 
	gFõld
[
I¡
](0)

21 ˛as†
	cSFí˚Req
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

22 
vÆ
 
rs1
 = 
	$Boﬁ
()

23 
vÆ
 
rs2
 = 
	$Boﬁ
()

24 
vÆ
 
addr
 = 
	$UI¡
(
width
 = 
vaddrBôs
)

25 
vÆ
 
asid
 = 
	`UI¡
(
width
 = 
asIdBôs
 
max
 1)

28 ˛as†
	cTLBReq
(
lgMaxSize
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

29 
vÆ
 
vaddr
 = 
	$UI¡
(
width
 = 
vaddrBôsExãnded
)

30 
vÆ
 
∑s°hrough
 = 
	$Boﬁ
()

31 
vÆ
 
size
 = 
	`UI¡
(
width
 = 
	`log2Ceû
(
lgMaxSize
 + 1))

32 
vÆ
 
cmd
 = 
	$Bôs
(
width
 = 
M_SZ
)

34 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`TLBReq
(
lgMaxSize
).
asIn°™˚Of
[
this
.
ty≥
]

37 ˛as†
	cTLBEx˚±i⁄s
 
exãnds
 
BundÀ
 {

38 
vÆ
 
ld
 = 
	$Boﬁ
()

39 
vÆ
 
°
 = 
	$Boﬁ
()

40 
vÆ
 
ö°
 = 
	`Boﬁ
()

43 ˛as†
	cTLBRe•
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

45 
vÆ
 
miss
 = 
	$Boﬁ
()

46 
vÆ
 
∑ddr
 = 
	$UI¡
(
width
 = 
∑ddrBôs
)

47 
vÆ
 
pf
 = 
√w
 
TLBEx˚±i⁄s


48 
vÆ
 
´
 = 
√w
 
TLBEx˚±i⁄s


49 
vÆ
 
ma
 = 
√w
 
TLBEx˚±i⁄s


50 
vÆ
 
ˇchóbÀ
 = 
	$Boﬁ
()

51 
vÆ
 
¥e„tchabÀ
 = 
	`Boﬁ
()

54 
˛ass
 
	$TLBC⁄fig
(

55 
nE¡rõs
: 
I¡
,

56 
nSe˘‹s
: 
I¡
 = 4,

57 
nSu≥ΩageE¡rõs
: 
I¡
 = 4)

59 
˛ass
 
	$TLB
(
ö°ru˘i⁄
: 
Boﬁón
, 
lgMaxSize
: 
I¡
, 
cfg
: 
TLBC⁄fig
)(
im∂icô
 
edge
: 
TLEdgeOut
, 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
) {

60 
vÆ
 
io
 = 
√w
 
BundÀ
 {

61 
vÆ
 
ªq
 = 
	`Decou∂ed
(
√w
 
	`TLBReq
(
lgMaxSize
)).
Êù


62 
vÆ
 
ª•
 = 
√w
 
	`TLBRe•
().
asOuçut


63 
vÆ
 
s„n˚
 = 
	`VÆid
(
√w
 
SFí˚Req
).
asI≈ut


64 
vÆ
 
±w
 = 
√w
 
TLBPTWIO


65 
vÆ
 
kûl
 = 
	`Boﬁ
(
INPUT
)

68 ˛as†
	cE¡ryD©a
 
exãnds
 
BundÀ
 {

69 
vÆ
 
µn
 = 
	`UI¡
(
width
 = 
µnBôs
)

70 
vÆ
 
u
 = 
	`Boﬁ
()

71 
vÆ
 
g
 = 
	`Boﬁ
()

72 
vÆ
 
´
 = 
	`Boﬁ
()

73 
vÆ
 
sw
 = 
	`Boﬁ
()

74 
vÆ
 
sx
 = 
	`Boﬁ
()

75 
vÆ
 
§
 = 
	`Boﬁ
()

76 
vÆ
 
pw
 = 
	`Boﬁ
()

77 
vÆ
 
px
 = 
	`Boﬁ
()

78 
vÆ
 
¥
 = 
	`Boﬁ
()

79 
vÆ
 
∑l
 = 
	`Boﬁ
()

80 
vÆ
 
∑a
 = 
	`Boﬁ
()

81 
vÆ
 
eff
 = 
	`Boﬁ
()

82 
vÆ
 
c
 = 
	`Boﬁ
()

83 
vÆ
 
‰agmíãd_su≥Ωage
 = 
	`Boﬁ
()

84 
	}
}

86 
˛ass
 
	$E¡ry
(
vÆ
 
nSe˘‹s
: 
I¡
, vÆ 
su≥Ωage
: 
Boﬁón
, vÆ 
su≥ΩageO∆y
: BoﬁónË
exãnds
 
BundÀ
 {

87 
	`ªquúe
(
nSe˘‹s
 =1 || !
su≥Ωage
)

88 
	`ªquúe
(!
su≥ΩageO∆y
 || 
su≥Ωage
)

90 
vÆ
 
Àvñ
 = 
	`UI¡
(
width
 = 
	`log2Ceû
(
pgLevñs
))

91 
vÆ
 
èg
 = 
	`UI¡
(
width
 = 
v≤Bôs
)

92 
vÆ
 
d©a
 = 
	`Vec
(
nSe˘‹s
, 
	`UI¡
(
width
 = 
√w
 
	`E¡ryD©a
().
gëWidth
))

93 
vÆ
 
vÆid
 = 
	`Vec
(
nSe˘‹s
, 
	`Boﬁ
())

94 
def
 
íåy_d©a
 = 
d©a
.
	`m≠
(
_
.
	`asTy≥Of
(
√w
 
E¡ryD©a
))

96 
¥iv©e
 
def
 
	`£˘‹Idx
(
v≤
: 
UI¡
Ëv≤.
	`exåa˘
(
nSe˘‹s
.
log2
-1, 0)

97 
def
 
	`gëD©a
(
v≤
: 
UI¡
Ë
	`d©a
(
	`£˘‹Idx
(v≤)).
	`asTy≥Of
(
√w
 
E¡ryD©a
)

98 
def
 
	`£˘‹Hô
(
v≤
: 
UI¡
Ë
vÆid
.
‹R
 && 
	`£˘‹TagM©ch
(vpn)

99 
def
 
	`£˘‹TagM©ch
(
v≤
: 
UI¡
Ë((
èg
 ^ v≤Ë>> 
nSe˘‹s
.
log2
) === 0

100 
def
 
	`hô
(
v≤
: 
UI¡
) = {

101 i‡(
su≥Ωage
 && 
usögVM
) {

102 
v¨
 
ègM©ch
 = 
vÆid
.
hód


103 
j
 <- 0 
u¡û
 
pgLevñs
) {

104 
vÆ
 
ba£
 = 
v≤Bôs
 - (
j
 + 1Ë* 
pgLevñBôs


105 
vÆ
 
ign‹e
 = 
Àvñ
 < 
j
 || 
su≥ΩageO∆y
 && j =
pgLevñs
 - 1

106 
ègM©ch
 =ÅagM©ch && (
ign‹e
 || 
	`èg
(
ba£
 + 
pgLevñBôs
 - 1, ba£Ë==
	`v≤
(base +ÖgLevelBits - 1, base))

108 
ègM©ch


110 
vÆ
 
idx
 = 
	`£˘‹Idx
(
v≤
)

111 
	`vÆid
(
idx
Ë&& 
	`£˘‹TagM©ch
(
v≤
)

114 
def
 
	`µn
(
v≤
: 
UI¡
) = {

115 
vÆ
 
d©a
 = 
	`gëD©a
(
v≤
)

116 i‡(
su≥Ωage
 && 
usögVM
) {

117 
v¨
 
ªs
 = 
d©a
.
µn
 >> 
pgLevñBôs
*(
pgLevñs
 - 1)

118 
j
 <- 1 
u¡û
 
pgLevñs
) {

119 
vÆ
 
ign‹e
 = 
Àvñ
 < 
j
 || 
su≥ΩageO∆y
 && j =
pgLevñs
 - 1

120 
ªs
 = 
	`C©
‘es, (
	`Mux
(
ign‹e
, 
v≤
, 0.UË| 
d©a
.
µn
)(
v≤Bôs
 - 
j
*
pgLevñBôs
 - 1, vpnBits - (j + 1)*pgLevelBits))

122 
ªs


124 
d©a
.
µn


128 
def
 
	`ö£π
(
èg
: 
UI¡
, 
Àvñ
: UI¡, 
íåy
: 
E¡ryD©a
) {

129 
this
.
èg
 :=Åag

130 
this
.
Àvñ
 :Àvñ.
	`exåa˘
(
	`log2Ceû
(
pgLevñs
 - 
su≥ΩageO∆y
.
toI¡
)-1, 0)

132 
vÆ
 
idx
 = 
	`£˘‹Idx
(
èg
)

133 
	`vÆid
(
idx
Ë:
åue


134 
	`d©a
(
idx
Ë:
íåy
.
asUI¡


137 
def
 
	`övÆid©e
(Ë{ 
vÆid
.
	`f‹óch
(
_
 :
Ál£
) }

138 
def
 
	`övÆid©eVPN
(
v≤
: 
UI¡
) {

139 i‡(
su≥Ωage
) {

140 
	`whí
 (
	`hô
(
v≤
)Ë{ 
	`övÆid©e
() }

142 
	`whí
 (
	`£˘‹TagM©ch
(
v≤
)Ë{ 
	`vÆid
(
	`£˘‹Idx
(v≤)Ë:
Ál£
 }

146 
	`whí
 (((
èg
 ^ 
v≤
Ë>> (
pgLevñBôs
 * (
pgLevñs
 - 1))) === 0) {

147 (
v
, 
e
Ë<- 
vÆid
 
zù
 
íåy_d©a
)

148 
	`whí
 (
e
.
‰agmíãd_su≥Ωage
Ë{ 
v
 :
Ál£
 }

152 
def
 
	`övÆid©eN⁄GlobÆ
() {

153 (
v
, 
e
Ë<- 
vÆid
 
zù
 
íåy_d©a
)

154 
	`whí
 (!
e
.
g
Ë{ 
v
 :
Ál£
 }

156 
	}
}

158 
vÆ
 
∑geGønuœrôyPMPs
 = 
pmpGønuœrôy
 >(1 << 
pgIdxBôs
)

159 
vÆ
 
£˘‹ed_íåõs
 = 
Reg
(
Vec
(
cfg
.
nE¡rõs
 / cfg.
nSe˘‹s
, 
√w
 
	$E¡ry
(
cfg
.
nSe˘‹s
, 
Ál£
, false)))

160 
vÆ
 
su≥Ωage_íåõs
 = 
	`Reg
(
	`Vec
(
cfg
.
nSu≥ΩageE¡rõs
, 
√w
 
	$E¡ry
(1, 
åue
,Årue)))

161 
vÆ
 
•ecül_íåy
 = (!
∑geGønuœrôyPMPs
).
	`›ti⁄
(
	`Reg
(
√w
 
	$E¡ry
(1, 
åue
, 
Ál£
)))

162 
def
 
‹dö¨y_íåõs
 = 
£˘‹ed_íåõs
 ++ 
su≥Ωage_íåõs


163 
def
 
Æl_íåõs
 = 
‹dö¨y_íåõs
 ++ 
•ecül_íåy


165 
vÆ
 
s_ªady
 :: 
s_ªque°
 :: 
s_waô
 :: 
s_waô_övÆid©e
 :: 
Nû
 = 
	`Enum
(
	`UI¡
(), 4)

166 
vÆ
 
°©e
 = 
	$Reg
(
öô
=
s_ªady
)

167 
vÆ
 
r_ªfûl_èg
 = 
	`Reg
(
	$UI¡
(
width
 = 
v≤Bôs
))

168 
vÆ
 
r_su≥Ωage_ª∂_addr
 = 
	`Reg
(
	`UI¡
(
	`log2Ceû
(
su≥Ωage_íåõs
.
size
).
W
))

169 
vÆ
 
r_£˘‹ed_ª∂_addr
 = 
	`Reg
(
	`UI¡
(
	`log2Ceû
(
£˘‹ed_íåõs
.
size
).
W
))

170 
vÆ
 
r_£˘‹ed_hô_addr
 = 
	`Reg
(
	`UI¡
(
	`log2Ceû
(
£˘‹ed_íåõs
.
size
).
W
))

171 
vÆ
 
r_£˘‹ed_hô
 = 
	`Reg
(
	$Boﬁ
())

173 
vÆ
 
¥iv
 = i‡(
ö°ru˘i⁄
Ë
io
.
±w
.
°©us
.
¥v
 io.±w.°©us.
d¥v


174 
vÆ
 
¥iv_s
 = 
	$¥iv
(0)

175 
vÆ
 
¥iv_u£s_vm
 = 
¥iv
 <
PRV
.
S


176 
vÆ
 
vm_íabÀd
 = 
	`Boﬁ
(
usögVM
Ë&& 
io
.
±w
.
±br
.
	`mode
(io.±w.±br.
mode
.
gëWidth
-1Ë&& 
¥iv_u£s_vm
 && !io.
ªq
.
bôs
.
∑s°hrough


179 
vÆ
 
v≤
 = 
io
.
ªq
.
bôs
.
	`vaddr
(
vaddrBôs
-1, 
pgIdxBôs
)

180 
vÆ
 
ªfûl_µn
 = 
io
.
±w
.
ª•
.
bôs
.
±e
.
	`µn
(
µnBôs
-1, 0)

181 
vÆ
 
do_ªfûl
 = 
	`Boﬁ
(
usögVM
Ë&& 
io
.
±w
.
ª•
.
vÆid


182 
vÆ
 
övÆid©e_ªfûl
 = 
°©e
.
	$isO√Of
(
s_ªque°
 , 
s_waô_övÆid©e
)

183 
vÆ
 
mpu_µn
 = 
	`Mux
(
do_ªfûl
, 
ªfûl_µn
,

184 
	`Mux
(
vm_íabÀd
 && 
•ecül_íåy
.
n⁄Em±y
, s≥cül_íåy.
	`m≠
(
_
.
	`µn
(
v≤
)).
	`gëOrEl£
(0.U), 
io
.
ªq
.
bôs
.
vaddr
 >> 
pgIdxBôs
))

185 
vÆ
 
mpu_phyßddr
 = 
	`C©
(
mpu_µn
, 
io
.
ªq
.
bôs
.
	`vaddr
(
pgIdxBôs
-1, 0))

186 
vÆ
 
pmp
 = 
	`ModuÀ
(
√w
 
	$PMPCheckî
(
lgMaxSize
))

187 
pmp
.
io
.
addr
 :
mpu_phyßddr


188 
pmp
.
io
.
size
 :io.
ªq
.
bôs
.size

189 
pmp
.
io
.pm∞:(io.
±w
.pmp: 
Seq
[
PMP
])

190 
pmp
.
io
.
¥v
 :
	`Mux
(
	`Boﬁ
(
usögVM
Ë&& (
do_ªfûl
 || io.
ªq
.
bôs
.
∑s°hrough
 ), 
PRV
.
S
, 
¥iv
)

191 
vÆ
 
ÀgÆ_addªss
 = 
edge
.
m™agî
.
	`födSa„
(
mpu_phyßddr
).
	`ªdu˚
(
_
||_)

192 
def
 
	`Á°Check
(
membî
: 
TLM™agîP¨amëîs
 => 
Boﬁón
) =

193 
ÀgÆ_addªss
 && 
edge
.
m™agî
.
	`Á°Pr›îty
(
mpu_phyßddr
, 
membî
, (
b
:
Boﬁón
Ë=> 
	$Boﬁ
(
b
))

194 
vÆ
 
ˇchóbÀ
 = 
	`Á°Check
(
_
.
suµ‹tsAcquúeT
Ë&& (
ö°ru˘i⁄
 || !
usögD©aS¸©ch∑d
)

195 
vÆ
 
homogíeous
 = 
	`TLBPageLookup
(
edge
.
m™agî
.
m™agîs
, 
xLí
, 
	`p
(
CacheBlockByãs
), 
	`BigI¡
(1Ë<< 
pgIdxBôs
)(
mpu_phyßddr
).homogeneous

196 
vÆ
 
¥Ÿ_r
 = 
	`Á°Check
(
_
.
suµ‹tsGë
Ë&& 
pmp
.
io
.
r


197 
vÆ
 
¥Ÿ_w
 = 
	`Á°Check
(
_
.
suµ‹tsPutFuŒ
Ë&& 
pmp
.
io
.
w


198 
vÆ
 
¥Ÿ_Æ
 = 
	`Á°Check
(
_
.
suµ‹tsLogiˇl
Ë|| (
ˇchóbÀ
 && 
usögAtomicsInCache
)

199 
vÆ
 
¥Ÿ_Ø
 = 
	`Á°Check
(
_
.
suµ‹tsArôhmëic
Ë|| (
ˇchóbÀ
 && 
usögAtomicsInCache
)

200 
vÆ
 
¥Ÿ_x
 = 
	`Á°Check
(
_
.
execuèbÀ
Ë&& 
pmp
.
io
.
x


201 
vÆ
 
¥Ÿ_eff
 = 
	`Á°Check
(
	$Seq
(
Regi⁄Ty≥
.
PUT_EFFECTS
, Regi⁄Ty≥.
GET_EFFECTS
Ë
c⁄èös
 
_
.
ªgi⁄Ty≥
)

203 
vÆ
 
£˘‹_hôs
 = 
£˘‹ed_íåõs
.
	`m≠
(
_
.
	$£˘‹Hô
(
v≤
))

204 
vÆ
 
su≥Ωage_hôs
 = 
su≥Ωage_íåõs
.
	`m≠
(
_
.
	$hô
(
v≤
))

205 
vÆ
 
hôsVec
 = 
Æl_íåõs
.
	`m≠
(
vm_íabÀd
 && 
_
.
	$hô
(
v≤
))

206 
vÆ
 
ªÆ_hôs
 = 
hôsVec
.
asUI¡


207 
vÆ
 
hôs
 = 
	`C©
(!
vm_íabÀd
, 
ªÆ_hôs
)

208 
vÆ
 
µn
 = 
	`Mux1H
(
hôsVec
 :+ !
vm_íabÀd
, 
Æl_íåõs
.
	`m≠
(
_
.
	$µn
(
v≤
)Ë:+ 
	`v≤
(
µnBôs
-1, 0))

211 
	`whí
 (
do_ªfûl
 && !
övÆid©e_ªfûl
) {

212 
vÆ
 
±e
 = 
io
.
±w
.
ª•
.
bôs
.pte

213 
vÆ
 
√wE¡ry
 = 
	`Wúe
(
√w
 
E¡ryD©a
)

214 
√wE¡ry
.
µn
 :
±e
.ppn

215 
√wE¡ry
.
c
 :
ˇchóbÀ


216 
√wE¡ry
.
u
 :
±e
.u

217 
√wE¡ry
.
g
 :
±e
.g

218 
√wE¡ry
.
´
 :
io
.
±w
.
ª•
.
bôs
.ae

219 
√wE¡ry
.
§
 :
±e
.
	`§
()

220 
√wE¡ry
.
sw
 :
±e
.
	`sw
()

221 
√wE¡ry
.
sx
 :
±e
.
	`sx
()

222 
√wE¡ry
.
¥
 :
¥Ÿ_r


223 
√wE¡ry
.
pw
 :
¥Ÿ_w


224 
√wE¡ry
.
px
 :
¥Ÿ_x


225 
√wE¡ry
.
∑l
 :
¥Ÿ_Æ


226 
√wE¡ry
.
∑a
 :
¥Ÿ_Ø


227 
√wE¡ry
.
eff
 :
¥Ÿ_eff


228 
√wE¡ry
.
‰agmíãd_su≥Ωage
 :
io
.
±w
.
ª•
.
bôs
.fragmented_superpage

230 
	`whí
 (
•ecül_íåy
.
n⁄Em±y
 && !
io
.
±w
.
ª•
.
bôs
.
homogíeous
) {

231 
•ecül_íåy
.
	`f‹óch
(
_
.
	`ö£π
(
r_ªfûl_èg
, 
io
.
±w
.
ª•
.
bôs
.
Àvñ
, 
√wE¡ry
))

232 }.
	`ñ£whí
 (
io
.
±w
.
ª•
.
bôs
.
Àvñ
 < 
pgLevñs
-1) {

233 (
e
, 
i
Ë<- 
su≥Ωage_íåõs
.
zùWôhIndex
Ë
	`whí
 (
r_su≥Ωage_ª∂_addr
 === i) {

234 
e
.
	`ö£π
(
r_ªfûl_èg
, 
io
.
±w
.
ª•
.
bôs
.
Àvñ
, 
√wE¡ry
)

236 }.
Ÿhîwi£
 {

237 
vÆ
 
waddr
 = 
	`Mux
(
r_£˘‹ed_hô
, 
r_£˘‹ed_hô_addr
, 
r_£˘‹ed_ª∂_addr
)

238 (
e
, 
i
Ë<- 
£˘‹ed_íåõs
.
zùWôhIndex
Ë
	`whí
 (
waddr
 === i) {

239 
	`whí
 (!
r_£˘‹ed_hô
Ë{ 
e
.
	`övÆid©e
() }

240 
e
.
	`ö£π
(
r_ªfûl_èg
, 0.U, 
√wE¡ry
)

243 
	}
}

245 
vÆ
 
	gíåõs
 = 
Æl_íåõs
.
m≠
(
_
.
	$gëD©a
(
v≤
))

246 
vÆ
 
n‹mÆ_íåõs
 = 
‹dö¨y_íåõs
.
	`m≠
(
_
.
	$gëD©a
(
v≤
))

247 
vÆ
 
nPhysiˇlE¡rõs
 = 1 + 
•ecül_íåy
.
size


248 
vÆ
 
±w_´_¨øy
 = 
	`C©
(
Ál£
.
B
, 
íåõs
.
	`m≠
(
_
.
´
).
asUI¡
)

249 
vÆ
 
¥iv_rw_ok
 = 
	`Mux
(!
¥iv_s
 || 
io
.
±w
.
°©us
.
sum
, 
íåõs
.
	`m≠
(
_
.
u
).
asUI¡
, 0.U) | Mux(priv_s, ~entries.map(_.u).asUInt, 0.U)

250 
vÆ
 
¥iv_x_ok
 = 
	`Mux
(
¥iv_s
, ~
íåõs
.
	`m≠
(
_
.
u
).
asUI¡
,Éntries.map(_.u).asUInt)

251 
vÆ
 
r_¨øy
 = 
	`C©
(
åue
.
B
, 
¥iv_rw_ok
 & (
íåõs
.
	`m≠
(
_
.
§
).
asUI¡
 | 
	`Mux
(
io
.
±w
.
°©us
.
mxr
,É¡rõs.m≠(_.
sx
).asUI¡, 
	$UI¡
(0))))

252 
vÆ
 
w_¨øy
 = 
	`C©
(
åue
.
B
, 
¥iv_rw_ok
 & 
íåõs
.
	`m≠
(
_
.
sw
).
asUI¡
)

253 
vÆ
 
x_¨øy
 = 
	`C©
(
åue
.
B
, 
¥iv_x_ok
 & 
íåõs
.
	`m≠
(
_
.
sx
).
asUI¡
)

254 
vÆ
 
¥_¨øy
 = 
	`C©
(
	`Fûl
(
nPhysiˇlE¡rõs
, 
¥Ÿ_r
), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
¥
).
asUI¡
Ë| 
±w_´_¨øy


255 
vÆ
 
pw_¨øy
 = 
	`C©
(
	`Fûl
(
nPhysiˇlE¡rõs
, 
¥Ÿ_w
), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
pw
).
asUI¡
Ë| 
±w_´_¨øy


256 
vÆ
 
px_¨øy
 = 
	`C©
(
	`Fûl
(
nPhysiˇlE¡rõs
, 
¥Ÿ_x
), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
px
).
asUI¡
Ë| 
±w_´_¨øy


257 
vÆ
 
∑a_¨øy
 = 
	`C©
(
	`Fûl
(
nPhysiˇlE¡rõs
, 
¥Ÿ_Ø
), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
∑a
).
asUI¡
)

258 
vÆ
 
∑l_¨øy
 = 
	`C©
(
	`Fûl
(
nPhysiˇlE¡rõs
, 
¥Ÿ_Æ
), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
∑l
).
asUI¡
)

259 
vÆ
 
eff_¨øy
 = 
	`C©
(
	`Fûl
(
nPhysiˇlE¡rõs
, 
¥Ÿ_eff
), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
eff
).
asUI¡
)

260 
vÆ
 
c_¨øy
 = 
	`C©
(
	`Fûl
(
nPhysiˇlE¡rõs
, 
ˇchóbÀ
), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
c
).
asUI¡
)

261 
vÆ
 
¥e„tchabÀ_¨øy
 = 
	`C©
((
ˇchóbÀ
 && 
homogíeous
Ë<< (
nPhysiˇlE¡rõs
-1), 
n‹mÆ_íåõs
.
	`m≠
(
_
.
c
).
asUI¡
)

263 
vÆ
 
mißlig√d
 = (
io
.
ªq
.
bôs
.
vaddr
 & (
	`UI¡ToOH
(io.ªq.bôs.
size
Ë- 1)).
‹R


264 
vÆ
 
bad_va
 = 
vm_íabÀd
 &&

265 (i‡(
v≤Bôs
 =
v≤BôsExãnded
Ë
	$Boﬁ
(
Ál£
)

266 (
io
.
ªq
.
bôs
.
vaddr
.
asSI¡
 < 0.
S
Ë=/(
v≤
.asSInt < 0.S))

268 
vÆ
 
ÃscAŒowed
 = 
	`Mux
(
	`Boﬁ
(
usögD©aS¸©ch∑d
 || 
usögAtomicsO∆yF‹IO
), 0.U, 
c_¨øy
)

269 
vÆ
 
´_¨øy
 =

270 
	`Mux
(
mißlig√d
, 
eff_¨øy
, 0.U) |

271 
	`Mux
(
	`Boﬁ
(
usögAtomics
Ë&& 
io
.
ªq
.
bôs
.
cmd
.
	`isO√Of
(
M_XLR
, 
M_XSC
), ~
ÃscAŒowed
, 0.U)

272 
vÆ
 
´_ld_¨øy
 = 
	`Mux
(
	`isRód
(
io
.
ªq
.
bôs
.
cmd
), 
´_¨øy
 | ~
¥_¨øy
, 0.U)

273 
vÆ
 
´_°_¨øy
 =

274 
	`Mux
(
	`isWrôe
(
io
.
ªq
.
bôs
.
cmd
), 
´_¨øy
 | ~
pw_¨øy
, 0.U) |

275 
	`Mux
(
	`Boﬁ
(
usögAtomics
Ë&& 
	`isAMOLogiˇl
(
io
.
ªq
.
bôs
.
cmd
), ~
∑l_¨øy
, 0.U) |

276 
	`Mux
(
	`Boﬁ
(
usögAtomics
Ë&& 
	`isAMOArôhmëic
(
io
.
ªq
.
bôs
.
cmd
), ~
∑a_¨øy
, 0.U)

277 
vÆ
 
ma_ld_¨øy
 = 
	`Mux
(
mißlig√d
 && 
	`isRód
(
io
.
ªq
.
bôs
.
cmd
), ~
eff_¨øy
, 0.U)

278 
vÆ
 
ma_°_¨øy
 = 
	`Mux
(
mißlig√d
 && 
	`isWrôe
(
io
.
ªq
.
bôs
.
cmd
), ~
eff_¨øy
, 0.U)

279 
vÆ
 
pf_ld_¨øy
 = 
	`Mux
(
	`isRód
(
io
.
ªq
.
bôs
.
cmd
), ~(
r_¨øy
 | 
±w_´_¨øy
), 0.U)

280 
vÆ
 
pf_°_¨øy
 = 
	`Mux
(
	`isWrôe
(
io
.
ªq
.
bôs
.
cmd
), ~(
w_¨øy
 | 
±w_´_¨øy
), 0.U)

281 
vÆ
 
pf_ö°_¨øy
 = ~(
x_¨øy
 | 
±w_´_¨øy
)

283 
vÆ
 
éb_hô
 = 
ªÆ_hôs
.
‹R


284 
vÆ
 
éb_miss
 = 
vm_íabÀd
 && !
bad_va
 && !
éb_hô


286 
vÆ
 
£˘‹ed_∂ru
 = 
√w
 
	$P£udoLRU
(
£˘‹ed_íåõs
.
size
)

287 
vÆ
 
su≥Ωage_∂ru
 = 
√w
 
	$P£udoLRU
(
su≥Ωage_íåõs
.
size
)

288 
	$whí
 (
io
.
ªq
.
vÆid
 && 
vm_íabÀd
) {

289 
	`whí
 (
£˘‹_hôs
.
‹R
Ë{ 
£˘‹ed_∂ru
.
	`ac˚ss
(
	`OHToUI¡
(sector_hits)) }

290 
	`whí
 (
su≥Ωage_hôs
.
‹R
Ë{ 
su≥Ωage_∂ru
.
	`ac˚ss
(
	`OHToUI¡
(superpage_hits)) }

291 
	}
}

298 
vÆ
 
mu…ùÀHôs
 = 
	$P›Cou¡AtLó°
(
ªÆ_hôs
, 2)

300 
io
.
ªq
.
ªady
 :
°©e
 ==
s_ªady


301 
io
.
ª•
.
pf
.
ld
 :(
bad_va
 && 
	`isRód
(io.
ªq
.
bôs
.
cmd
)Ë|| (
pf_ld_¨øy
 & 
hôs
).
‹R


302 
io
.
ª•
.
pf
.
°
 :(
bad_va
 && 
	`isWrôe
(io.
ªq
.
bôs
.
cmd
)Ë|| (
pf_°_¨øy
 & 
hôs
).
‹R


303 
io
.
ª•
.
pf
.
ö°
 :
bad_va
 || (
pf_ö°_¨øy
 & 
hôs
).
‹R


304 
io
.
ª•
.
´
.
ld
 :(
´_ld_¨øy
 & 
hôs
).
‹R


305 
io
.
ª•
.
´
.
°
 :(
´_°_¨øy
 & 
hôs
).
‹R


306 
io
.
ª•
.
´
.
ö°
 :(~
px_¨øy
 & 
hôs
).
‹R


307 
io
.
ª•
.
ma
.
ld
 :(
ma_ld_¨øy
 & 
hôs
).
‹R


308 
io
.
ª•
.
ma
.
°
 :(
ma_°_¨øy
 & 
hôs
).
‹R


309 
io
.
ª•
.
ma
.
ö°
 :
Ál£


310 
io
.
ª•
.
ˇchóbÀ
 :(
c_¨øy
 & 
hôs
).
‹R


311 
io
.
ª•
.
¥e„tchabÀ
 :(
¥e„tchabÀ_¨øy
 & 
hôs
).
‹R
 && 
edge
.
m™agî
.
m™agîs
.
	`f‹Æl
(
m
 => !m.
suµ‹tsAcquúeB
 || m.
suµ‹tsHöt
)

312 
io
.
ª•
.
miss
 :
do_ªfûl
 || 
éb_miss
 || 
mu…ùÀHôs


313 
io
.
ª•
.
∑ddr
 :
	`C©
(
µn
, io.
ªq
.
bôs
.
	`vaddr
(
pgIdxBôs
-1, 0))

315 
io
.
±w
.
ªq
.
vÆid
 :
°©e
 ==
s_ªque°


316 
io
.
±w
.
ªq
.
bôs
.
vÆid
 :!io.
kûl


317 
io
.
±w
.
ªq
.
bôs
.bôs.
addr
 :
r_ªfûl_èg


319 i‡(
usögVM
) {

320 
vÆ
 
s„n˚
 = 
io
.s„n˚.
vÆid


321 
	`whí
 (
io
.
ªq
.
	`fúe
(Ë&& 
éb_miss
) {

322 
°©e
 :
s_ªque°


323 
r_ªfûl_èg
 :
v≤


325 
r_su≥Ωage_ª∂_addr
 :
	`ª∂a˚mítE¡ry
(
su≥Ωage_íåõs
, 
su≥Ωage_∂ru
.
ª∂a˚
)

326 
r_£˘‹ed_ª∂_addr
 :
	`ª∂a˚mítE¡ry
(
£˘‹ed_íåõs
, 
£˘‹ed_∂ru
.
ª∂a˚
)

327 
r_£˘‹ed_hô_addr
 :
	`OHToUI¡
(
£˘‹_hôs
)

328 
r_£˘‹ed_hô
 :
£˘‹_hôs
.
‹R


330 
	`whí
 (
°©e
 ==
s_ªque°
) {

331 
	`whí
 (
s„n˚
Ë{ 
°©e
 :
s_ªady
 }

332 
	`whí
 (
io
.
±w
.
ªq
.
ªady
Ë{ 
°©e
 :
	`Mux
(
s„n˚
, 
s_waô_övÆid©e
, 
s_waô
) }

333 
	`whí
 (
io
.
kûl
Ë{ 
°©e
 :
s_ªady
 }

335 
	`whí
 (
°©e
 ==
s_waô
 && 
s„n˚
) {

336 
°©e
 :
s_waô_övÆid©e


338 
	`whí
 (
io
.
±w
.
ª•
.
vÆid
) {

339 
°©e
 :
s_ªady


342 
	`whí
 (
s„n˚
) {

343 
	`as£π
(!
io
.
s„n˚
.
bôs
.
rs1
 || (io.s„n˚.bôs.
addr
 >> 
pgIdxBôs
Ë==
v≤
)

344 
e
 <- 
Æl_íåõs
) {

345 
	`whí
 (
io
.
s„n˚
.
bôs
.
rs1
Ë{ 
e
.
	`övÆid©eVPN
(
v≤
) }

346 .
	`ñ£whí
 (
io
.
s„n˚
.
bôs
.
rs2
Ë{ 
e
.
	`övÆid©eN⁄GlobÆ
() }

347 .
Ÿhîwi£
 { 
e
.
	`övÆid©e
() }

350 
	`whí
 (
mu…ùÀHôs
 || 
ª£t
) {

351 
Æl_íåõs
.
	`f‹óch
(
_
.
	`övÆid©e
())

354 
	`ccovî
(
io
.
±w
.
ªq
.
	`fúe
(), "MISS", "TLB miss")

355 
	`ccovî
(
io
.
±w
.
ªq
.
vÆid
 && !io.±w.ªq.
ªady
, "PTW_STALL", "TLB miss, but PTW busy")

356 
	`ccovî
(
°©e
 ==
s_waô_övÆid©e
, "SFENCE_DURING_REFILL", "flush TLB during TLBÑefill")

357 
	`ccovî
(
s„n˚
 && !
io
.s„n˚.
bôs
.
rs1
 && !io.s„n˚.bôs.
rs2
, "SFENCE_ALL", "flush TLB")

358 
	`ccovî
(
s„n˚
 && !
io
.s„n˚.
bôs
.
rs1
 && io.s„n˚.bôs.
rs2
, "SFENCE_ASID", "flush TLB ASID")

359 
	`ccovî
(
s„n˚
 && 
io
.s„n˚.
bôs
.
rs1
 && !io.s„n˚.bôs.
rs2
, "SFENCE_LINE", "flush TLBÜine")

360 
	`ccovî
(
s„n˚
 && 
io
.s„n˚.
bôs
.
rs1
 && io.s„n˚.bôs.
rs2
, "SFENCE_LINE_ASID", "flush TLBÜine/ASID")

361 
	`ccovî
(
mu…ùÀHôs
, "MULTIPLE_HITS", "Two matchingÅranslations in TLB")

362 
	}
}

364 
def
 
	$ccovî
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

365 
	`covî
(
c⁄d
, 
s
"${i‡(ö°ru˘i⁄Ë"
I
"Él£ "
D
"}TLB_$œbñ", "Mem‹ySy°em;;" + 
desc
)

367 
def
 
	`ª∂a˚mítE¡ry
(
£t
: 
Seq
[
E¡ry
], 
Æt
: 
UI¡
) = {

368 
vÆ
 
vÆids
 = 
£t
.
	`m≠
(
_
.
vÆid
.
‹R
).
asUI¡


369 
	`Mux
(
vÆids
.
™dR
, 
Æt
, 
	`Pri‹ôyEncodî
(~valids))

370 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLBPermissions.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
rockë


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
˛ass
 
	$TLBPîmissi⁄s
(

11 
homogíeous
: 
Boﬁ
,

12 
r
: 
Boﬁ
,

13 
w
: 
Boﬁ
,

14 
x
: 
Boﬁ
,

15 
c
: 
Boﬁ
,

16 
a
: 
Boﬁ
,

17 
l
: 
Boﬁ
)

19 
obje˘
 
TLBPageLookup


21 
¥iv©e
 
˛ass
 
	`TLBFixedPîmissi⁄s
(

22 
e
: 
Boﬁón
,

23 
r
: 
Boﬁón
,

24 
w
: 
Boﬁón
,

25 
x
: 
Boﬁón
,

26 
c
: 
Boﬁón
,

27 
a
: 
Boﬁón
,

28 
l
: 
Boﬁón
) {

29 
vÆ
 
u£ful
 = 
r
 || 
w
 || 
x
 || 
c
 || 
a
 || 
l


32 
¥iv©e
 
def
 
	`groupRegi⁄s
(
m™agîs
: 
Seq
[
TLM™agîP¨amëîs
]): 
M≠
[
TLBFixedPîmissi⁄s
, Seq[
AddªssSë
]] = {

33 
vÆ
 
≥rmissi⁄s
 = 
m™agîs
.
m≠
 { 
m
 =>

34 (
m
.
addªss
, 
	`TLBFixedPîmissi⁄s
(

35 
e
 = 
	`Seq
(
Regi⁄Ty≥
.
PUT_EFFECTS
, Regi⁄Ty≥.
GET_EFFECTS
Ë
c⁄èös
 
m
.
ªgi⁄Ty≥
,

36 
r
 = 
m
.
suµ‹tsGë
 || m.
suµ‹tsAcquúeB
,

37 
w
 = 
m
.
suµ‹tsPutFuŒ
 || m.
suµ‹tsAcquúeT
,

38 
x
 = 
m
.
execuèbÀ
,

39 
c
 = 
m
.
suµ‹tsAcquúeB
,

40 
a
 = 
m
.
suµ‹tsArôhmëic
,

41 
l
 = 
m
.
suµ‹tsLogiˇl
))

44 
≥rmissi⁄s


45 .
	`fûãr
(
_
.
_2
.
u£ful
)

46 .
	`groupBy
(
_
.
_2
)

47 .
	`m≠VÆues
(
£q
 =>

48 
AddªssSë
.
	`unify
(
£q
.
	`Ê©M≠
(
_
.
_1
)))

52 
def
 
	`≠∂y
(
m™agîs
: 
Seq
[
TLM™agîP¨amëîs
], 
xLí
: 
I¡
, 
ˇcheBlockByãs
: I¡, 
∑geSize
: 
BigI¡
): 
UI¡
 => 
TLBPîmissi⁄s
 = {

53 
	`ªquúe
 (
	`isPow2
(
xLí
) && xLen >= 8)

54 
	`ªquúe
 (
	`isPow2
(
ˇcheBlockByãs
Ë&& cacheBlockByã†>
xLí
/8)

55 
	`ªquúe
 (
	`isPow2
(
∑geSize
Ë&&ÖageSizê>
ˇcheBlockByãs
)

57 
vÆ
 
x„rSizes
 = 
	`Tøns„rSizes
(
ˇcheBlockByãs
, cacheBlockBytes)

58 
vÆ
 
ÆlSizes
 = 
	`Tøns„rSizes
(1, 
ˇcheBlockByãs
)

59 
vÆ
 
amoSizes
 = 
	`Tøns„rSizes
(4, 
xLí
/8)

61 
vÆ
 
≥rmissi⁄s
 = 
m™agîs
.
f‹óch
 { 
m
 =>

62 
	`ªquúe
 (!
m
.
suµ‹tsGë
 || m.suµ‹tsGë .
	`c⁄èös
(
ÆlSizes
), 
s
"MemoryÑegion '${m.name}'át ${m.address} only supports ${m.supportsGet} Get, but must support ${allSizes}")

63 
	`ªquúe
 (!
m
.
suµ‹tsPutFuŒ
 || m.suµ‹tsPutFuŒ .
	`c⁄èös
(
ÆlSizes
), 
s
"MemoryÑegion '${m.name}'át ${m.address} only supports ${m.supportsPutFull} PutFull, but must support ${allSizes}")

64 
	`ªquúe
 (!
m
.
suµ‹tsAcquúeB
 || m.suµ‹tsAcquúeB .
	`c⁄èös
(
x„rSizes
), 
s
"MemoryÑegion '${m.name}'át ${m.address} only supports ${m.supportsAcquireB} AcquireB, but must support ${xferSizes}")

65 
	`ªquúe
 (!
m
.
suµ‹tsAcquúeT
 || m.suµ‹tsAcquúeT .
	`c⁄èös
(
x„rSizes
), 
s
"MemoryÑegion '${m.name}'át ${m.address} only supports ${m.supportsAcquireT} AcquireT, but must support ${xferSizes}")

66 
	`ªquúe
 (!
m
.
suµ‹tsLogiˇl
 || m.suµ‹tsLogiˇ».
	`c⁄èös
(
amoSizes
), 
s
"MemoryÑegion '${m.name}'át ${m.address} only supports ${m.supportsLogical} Logical, but must support ${amoSizes}")

67 
	`ªquúe
 (!
m
.
suµ‹tsArôhmëic
 || m.suµ‹tsArôhmëic.
	`c⁄èös
(
amoSizes
), 
s
"MemoryÑegion '${m.name}'át ${m.address} only supports ${m.supportsArithmetic} Arithmetic, but must support ${amoSizes}")

70 
vÆ
 
grou≥d
 = 
	`groupRegi⁄s
(
m™agîs
)

71 .
	`m≠VÆues
(
_
.
	`fûãr
(_.
Æignmít
 >
∑geSize
))

73 
def
 
	`lowCo°Pr›îty
(
¥›
: 
TLBFixedPîmissi⁄s
 => 
Boﬁón
): 
UI¡
 => 
Boﬁ
 = {

74 
	`vÆ
 (
yesm
, 
nom
Ë
grou≥d
.
∑πôi⁄
 { (
k
, 
eq
Ë=> 
	`¥›
(k) }

75 
	`vÆ
 (
yes
, 
no
Ë(
yesm
.
vÆues
.
Ê©ãn
.
toLi°
, 
nom
.values.flatten.toList)

77 
vÆ
 
decisi⁄Mask
 = 
	`AddªssDecodî
(
	`Seq
(
yes
, 
no
))

78 
def
 
	`sim∂ify
(
x
: 
Seq
[
AddªssSë
]ËAddªssSë.
	`unify
(x.
	`m≠
(
_
.
	`widí
(~
decisi⁄Mask
)).
di°ö˘
)

79 
	`vÆ
 (
yesf
, 
nof
Ë(
	`sim∂ify
(
yes
), sim∂ify(
no
))

80 i‡(
yesf
.
size
 < 
no
.size) {

81 (
x
: 
UI¡
Ë=> 
yesf
.
	`m≠
(
_
.
	`c⁄èös
(x)).
	`fﬁdLe·
(
Ál£
.
B
)(_ || _)

83 (
x
: 
UI¡
Ë=> !
nof
.
	`m≠
(
_
.
	`c⁄èös
(x)).
	`fﬁdLe·
(
Ál£
.
B
)(_ || _)

88 
vÆ
 
r‚
 = 
	`lowCo°Pr›îty
(
_
.
r
)

89 
vÆ
 
w‚
 = 
	`lowCo°Pr›îty
(
_
.
w
)

90 
vÆ
 
x‚
 = 
	`lowCo°Pr›îty
(
_
.
x
)

91 
vÆ
 
c‚
 = 
	`lowCo°Pr›îty
(
_
.
c
)

92 
vÆ
 
a‚
 = 
	`lowCo°Pr›îty
(
_
.
a
)

93 
vÆ
 
l‚
 = 
	`lowCo°Pr›îty
(
_
.
l
)

95 
vÆ
 
homo
 = 
AddªssSë
.
	`unify
(
grou≥d
.
vÆues
.
Ê©ãn
.
toLi°
)

96 (
x
: 
UI¡
Ë=> 
	`TLBPîmissi⁄s
(

97 
homogíeous
 = 
homo
.
	`m≠
(
_
.
	`c⁄èös
(
x
)).
	`fﬁdLe·
(
Ál£
.
B
)(_ || _),

98 
r
 = 
	`r‚
(
x
),

99 
w
 = 
	`w‚
(
x
),

100 
x
 = 
	`x‚
(x),

101 
c
 = 
	`c‚
(
x
),

102 
a
 = 
	`a‚
(
x
),

103 
l
 = 
	`l‚
(
x
))

107 
def
 
	`homogíeous
(
m™agîs
: 
Seq
[
TLM™agîP¨amëîs
], 
∑geSize
: 
BigI¡
): 
Boﬁón
 = {

108 
	`groupRegi⁄s
(
m™agîs
).
vÆues
.
	`f‹Æl
(
_
.f‹Æl(_.
Æignmít
 >
∑geSize
))

110 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
∑ckage
 
obje˘
 
rockë
 
exãnds
 
	grockë
.
	gc⁄°™ts
.
SˇœrOpC⁄°™ts
 
wôh
Ñockë.c⁄°™ts.
	gMem‹yOpC⁄°™ts


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/scie/SCIE.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
scõ


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.{
	gBôP©
, 
	gHasBœckBoxI∆öe
}

7 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.{
	gI¡P¨am
, 
	g‰omI¡ToI¡P¨am
}

9 
obje˘
 
	gSCIE
 {

10 
vÆ
 
	g›code
 = 
BôP©
("b?????????????????????????0?01011")

11 
vÆ
 
iLí
 = 32

14 ˛as†
	cSCIEDecodîI¡îÁ˚
 
exãnds
 
	mBundÀ
 {

15 
vÆ
 
	mö¢
 = 
I≈ut
(
	$UI¡
(
SCIE
.
iLí
.
W
))

16 
vÆ
 
u≈ùñöed
 = 
	`Ouçut
(
	$Boﬁ
())

17 
vÆ
 
pùñöed
 = 
	`Ouçut
(
	$Boﬁ
())

18 
vÆ
 
mu…icy˛e
 = 
	`Ouçut
(
	`Boﬁ
())

21 ˛as†
	cSCIEDecodî
 
exãnds
 
BœckBox
 
wôh
 
HasBœckBoxI∆öe
 {

22 
vÆ
 
io
 = 
	$IO
(
√w
 
SCIEDecodîI¡îÁ˚
)

24 
	`£tI∆öe
("SCIEDecoder.v",

25 
s
"""

26 |
moduÀ
 
	`SCIEDecodî
 (

27 | 
öput
 [
$
{
SCIE
.
iLí
-1}:0] 
ö¢
,

28 | 
ouçut
 
u≈ùñöed
,

29 | 
ouçut
 
pùñöed
,

30 | 
ouçut
 
mu…icy˛e
);

43 | 
assign
 
u≈ùñöed
 = (
ö¢
[14:12] <= 3'b1);

44 | 
assign
 
pùñöed
 = 1'b0;

45 | 
assign
 
mu…icy˛e
 = 1'b0;

47 |
ídmoduÀ


49 
	}
}

51 ˛as†
	cSCIEU≈ùñöedI¡îÁ˚
(
xLí
: 
I¡
Ë
exãnds
 
BundÀ
 {

52 
vÆ
 
ö¢
 = 
	`I≈ut
(
	$UI¡
(
SCIE
.
iLí
.
W
))

53 
vÆ
 
rs1
 = 
	`I≈ut
(
	$UI¡
(
xLí
.
W
))

54 
vÆ
 
rs2
 = 
	`I≈ut
(
	$UI¡
(
xLí
.
W
))

55 
vÆ
 
rd
 = 
	`Ouçut
(
	`UI¡
(
xLí
.
W
))

58 
˛ass
 
	$SCIEU≈ùñöed
(
xLí
: 
I¡
Ë
exãnds
 
	`BœckBox
(
	`M≠
("XLEN" -> xLí)Ë
wôh
 
HasBœckBoxI∆öe
 {

59 
vÆ
 
io
 = 
	`IO
(
√w
 
	`SCIEU≈ùñöedI¡îÁ˚
(
xLí
))

61 
	`£tI∆öe
("SCIEUnpipelined.v",

62 
s
"""

63 |
moduÀ
 
SCIEU≈ùñöed
 #(
∑ømëî
 
XLEN
 = 32) (

64 | 
öput
 [
$
{
SCIE
.
iLí
-1}:0] 
ö¢
,

65 | 
öput
 [
XLEN
-1:0] 
rs1
,

66 | 
öput
 [
XLEN
-1:0] 
rs2
,

67 | 
ouçut
 [
XLEN
-1:0] 
rd
);

81 | 
wúe
 
u£_immedüã
 = 
ö¢
[5];

82 | 
wúe
 
pick_smÆÀr
 = !
ö¢
[12];

85 | 
wúe
 [
XLEN
-1:0] 
immedüã
 = {{(XLEN-12){
ö¢
[31]}}, insn[31:20]};

86 | 
wúe
 [
XLEN
-1:0] 
rhs
 = 
u£_immedüã
 ? 
immedüã
 : 
rs2
;

87 | 
wúe
 [
XLEN
-1:0] 
lhs
 = 
rs1
;

90 | 
wúe
 
lhs_smÆÀr
 = 
	`$$sig√d
(
lhs
Ë< $$sig√d(
rhs
);

91 | 
wúe
 [
XLEN
-1:0] 
ªsu…
 = 
lhs_smÆÀr
 =
pick_smÆÀr
 ? 
lhs
 : 
rhs
;

94 | 
assign
 
rd
 = 
ªsu…
;

96 |
ídmoduÀ


98 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/BaseSubsystem.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gP¨amëîs
, 
	gFõld
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
obje˘
 
BuûdSy°emBus
 
exãnds
 
	gFõld
[
P¨amëîs
 => 
Sy°emBus
](
p
 => 
√w
 Sy°emBus(
	$p
(
Sy°emBusKey
))(
p
))

14 
ab°ø˘
 cœs†
	cB¨eSubsy°em
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 
wôh
 
BödögSc›e
 {

15 
œzy
 
vÆ
 
dts
 = 
	$DTS
(
bödögTªe
)

16 
œzy
 
vÆ
 
dtb
 = 
	$DTB
(
dts
)

17 
œzy
 
vÆ
 
js⁄
 = 
	`JSON
(
bödögTªe
)

20 
ab°ø˘
 
˛ass
 
B¨eSubsy°emModuÀImp
[+
L
 <: 
B¨eSubsy°em
](
_ouãr
: LË
exãnds
 
	$LazyModuÀImp
(
_ouãr
) {

21 
vÆ
 
ouãr
 = 
_ouãr


22 
Eœb‹©i⁄AπeÁ˘s
.
	`add
("gøphml", 
ouãr
.
gøphML
)

23 
Eœb‹©i⁄AπeÁ˘s
.
	`add
("dts", 
ouãr
.
dts
)

24 
Eœb‹©i⁄AπeÁ˘s
.
	`add
("js⁄", 
ouãr
.
js⁄
)

25 
Eœb‹©i⁄AπeÁ˘s
.
	`add
("∂usArgs", 
PlusArgAπeÁ˘s
.
£rülize_cHódî
)

26 
	`¥öén
(
ouãr
.
dts
)

27 
	}
}

30 
ab°ø˘
 cœs†
	cBa£Subsy°em
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
B¨eSubsy°em
 {

31 
ovîride
 
vÆ
 
moduÀ
: 
Ba£Subsy°emModuÀImp
[
Ba£Subsy°em
]

35 
vÆ
 
ibus
 = 
√w
 
	$I¡îru±BusWøµî
()

36 
vÆ
 
sbus
 = 
	`LazyModuÀ
(
	$p
(
BuûdSy°emBus
)(
p
))

37 
vÆ
 
pbus
 = 
	`LazyModuÀ
(
√w
 
	`PîùhîyBus
(
	$p
(
PîùhîyBusKey
)))

38 
vÆ
 
fbus
 = 
	`LazyModuÀ
(
√w
 
	`Fr⁄tBus
(
	$p
(
Fr⁄tBusKey
)))

41 
pbus
.
¸ossFromC⁄åﬁBus
 { 
sbus
.
c⁄åﬁ_bus
.
	`toSœveBus
("pbus") }

44 
FlùRídîög
 { 
im∂icô
 
p
 =>

45 
fbus
.
¸ossToSy°emBus
 { 
sbus
.
	`‰omMa°îBus
("fbus") }

46 
	}
}

49 
¥iv©e
 
vÆ
 
mbusP¨ams
 = 
	$p
(
Mem‹yBusKey
)

50 
¥iv©e
 
vÆ
 
l2P¨ams
 = 
	$p
(
B™kedL2Key
)

51 
vÆ
 
	`Mem‹yBusP¨ams
(
memBusBótByãs
, 
memBusBlockByãs
, 
_
, _Ë
mbusP¨ams


52 
vÆ
 
	`B™kedL2P¨ams
(
nB™ks
, 
cohîí˚M™agî
Ë
l2P¨ams


53 
vÆ
 
ˇcheBlockByãs
 = 
memBusBlockByãs


56 
¥iv©e
 
	`vÆ
 (
ö
, 
out
, 
hÆt
Ë
	$cohîí˚M™agî
(
this
)

57 
def
 
memBusC™Cau£HÆt
: (Ë=> 
O±i⁄
[
Boﬁ
] = 
hÆt


59 
	`ªquúe
 (
	`isPow2
(
nB™ks
) ||ÇBanks == 0)

60 
	`ªquúe
 (
	$isPow2
(
memBusBlockByãs
))

62 
vÆ
 
mbus
 = 
	`LazyModuÀ
(
√w
 
	$Mem‹yBus
(
mbusP¨ams
))

63 i‡(
nB™ks
 != 0) {

64 
sbus
.
	`cou∂eTo
("mbus"Ë{ 
ö
 :*
_
 }

65 
mbus
.
	`cou∂eFrom
(
s
"cohîí˚_m™agî"Ë{ 
_
 :=* 
	`B™kBödî
(
ˇcheBlockByãs
 * (
nB™ks
-1)Ë:*
out
 }

66 
	}
}

68 
œzy
 
vÆ
 
t›M™agîs
 = 
	$M™agîUnifiˇti⁄
(
sbus
.
busVõw
.
m™agî
.
m™agîs
)

69 
Resour˚Bödög
 {

70 
vÆ
 
m™agîs
 = 
t›M™agîs


71 
vÆ
 
max
 = 
m™agîs
.
	`Ê©M≠
(
_
.
addªss
).
	`m≠
(_.max).max

72 
vÆ
 
width
 = 
	`Resour˚I¡
((
	`log2Ceû
(
max
)+31) / 32)

73 
vÆ
 
modñ
 = 
	`p
(
DTSModñ
)

74 
vÆ
 
com∑t
 = 
	`p
(
DTSCom∑t
)

75 
vÆ
 
devCom∑t
 = (
modñ
 +: 
com∑t
).
	`m≠
(
s
 => 
	`Resour˚Såög
(s + "-dev"))

76 
vÆ
 
socCom∑t
 = (
modñ
 +: 
com∑t
).
	`m≠
(
s
 => 
	`Resour˚Såög
(s + "-soc"))

77 
devCom∑t
.
f‹óch
 { 
	`Resour˚
(
Resour˚Anch‹s
.
roŸ
, "com∑t").
	`böd
(
_
) }

78 
socCom∑t
.
f‹óch
 { 
	`Resour˚
(
Resour˚Anch‹s
.
soc
, "com∑t").
	`böd
(
_
) }

79 
	`Resour˚
(
Resour˚Anch‹s
.
roŸ
, "modñ").
	`böd
(
	`Resour˚Såög
(
modñ
))

80 
	`Resour˚
(
Resour˚Anch‹s
.
roŸ
, "width").
	`böd
(
width
)

81 
	`Resour˚
(
Resour˚Anch‹s
.
soc
, "width").
	`böd
(
width
)

82 
	`Resour˚
(
Resour˚Anch‹s
.
˝us
, "width").
	`böd
(
	`Resour˚I¡
(1))

84 
m™agîs
.
f‹óch
 { 
m™agî
 =>

85 
vÆ
 
vÆue
 = 
m™agî
.
toResour˚


86 
m™agî
.
ªsour˚s
.
f‹óch
 { 
ªsour˚
 =>

87 
ªsour˚
.
	`böd
(
vÆue
)

90 
	}
}

94 
ab°ø˘
 
˛ass
 
	gBa£Subsy°emModuÀImp
[+
L
 <: 
Ba£Subsy°em
](
_ouãr
: LË
exãnds
 
	$B¨eSubsy°emModuÀImp
(
_ouãr
) {

95 
¥iv©e
 
vÆ
 
m≠pög
: 
Seq
[
AddªssM≠E¡ry
] = 
A¬Ÿ©ed
.
	`addªssM≠pög
(
this
, {

96 
ouãr
.
cﬁÀ˘Resour˚Addªs£s
.
	`groupBy
(
_
.
_2
).
toLi°
.
Ê©M≠
 { (
key
, 
£q
) =>

97 
AddªssR™ge
.
	`‰omSës
(
key
.
addªss
).
m≠
 { 
r
 => 
	`AddªssM≠E¡ry
‘, key.
≥rmissi⁄s
, 
£q
.
	`m≠
(
_
.
_1
)) }

98 }.
	`s‹tBy
(
_
.
ønge
)

101 
A¬Ÿ©ed
.
	`addªssM≠pög
(
this
, 
m≠pög
)

103 
	`¥öén
("Generated Address Map")

104 
m≠pög
.
	`m≠
(
íåy
 => 
	`¥öén
”¡ry.
	`toSåög
((
ouãr
.
sbus
.
busVõw
.
bundÀ
.
addªssBôs
-1)/4 + 1)))

105 
	`¥öén
("")

107 
Eœb‹©i⁄AπeÁ˘s
.
	`add
("memm≠.js⁄", 
s
"""{"
m≠pög
":[${mapping.map(_.toJSON).mkString(",")}]}""")

110 
¥iv©e
 
vÆ
 
dtsR™ges
 = 
AddªssR™ge
.
	`unify
(
m≠pög
.
	`m≠
(
_
.
ønge
))

111 
¥iv©e
 
vÆ
 
ÆlR™ges
 = 
AddªssR™ge
.
	`unify
(
ouãr
.
t›M™agîs
.
Ê©M≠
 { 
m
 => AddªssR™ge.
	`‰omSës
(m.
addªss
) })

113 i‡(
dtsR™ges
 !
ÆlR™ges
) {

114 
	`¥öén
("Address map described by DTS differs fromÖhysical implementation:")

115 
AddªssR™ge
.
	`subåa˘
(
ÆlR™ges
, 
dtsR™ges
).
f‹óch
 { 
r
 =>

116 
	`¥öén
(
s
"\texists, but undescribed by DTS: ${r}")

118 
AddªssR™ge
.
	`subåa˘
(
dtsR™ges
, 
ÆlR™ges
).
f‹óch
 { 
r
 =>

119 
	`¥öén
(
s
"\tdoesÇotÉxist, but described by DTS: ${r}")

121 
	`¥öén
("")

123 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Configs.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


16 
˛ass
 
Ba£Subsy°emC⁄fig
 
exãnds
 
C⁄fig
 ((
sôe
, 
hîe
, 
up
) => {

18 
PgLevñs
 => i‡(
sôe
(
XLí
) == 64) 3 2

19 
XLí
 => 64

20 
MaxH¨tIdBôs
 => 
log2Up
(
sôe
(
RockëTûesKey
).
size
)

22 
Sy°emBusKey
 => 
Sy°emBusP¨ams
(
bótByãs
 = 
sôe
(
XLí
)/8, 
blockByãs
 = sôe(
CacheBlockByãs
))

23 
PîùhîyBusKey
 => 
PîùhîyBusP¨ams
(

24 
bótByãs
 = 
sôe
(
XLí
)/8,

25 
blockByãs
 = 
sôe
(
CacheBlockByãs
),

26 
îr‹Devi˚
 = 
Some
(
DevNuŒP¨ams
(
Li°
(
AddªssSë
(0x3000, 0xfff)), 
maxAtomic
=
sôe
(
XLí
)/8, 
maxTøns„r
=4096)))

27 
Mem‹yBusKey
 => 
Mem‹yBusP¨ams
(
bótByãs
 = 
sôe
(
XLí
)/8, 
blockByãs
 = sôe(
CacheBlockByãs
))

28 
Fr⁄tBusKey
 => 
Fr⁄tBusP¨ams
(
bótByãs
 = 
sôe
(
XLí
)/8, 
blockByãs
 = sôe(
CacheBlockByãs
))

30 
BoŸROMP¨ams
 => BoŸROMP¨ams(
c⁄ã¡FûeName
 = "./bootrom/bootrom.img")

31 
DebugModuÀP¨ams
 => 
DeÁu…DebugModuÀP¨ams
(
sôe
(
XLí
))

32 
CLINTKey
 => 
Some
(
CLINTP¨ams
())

33 
PLICKey
 => 
Some
(
PLICP¨ams
())

38 
˛ass
 
	$WôhNBigC‹es
(
n
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

39 
RockëTûesKey
 => {

40 
vÆ
 
big
 = 
	`RockëTûeP¨ams
(

41 
c‹e
 = 
	`RockëC‹eP¨ams
(
mulDiv
 = 
	`Some
(
	`MulDivP¨ams
(

42 
mulUƒﬁl
 = 8,

43 
mulE¨lyOut
 = 
åue
,

44 
divE¨lyOut
 = 
åue
))),

45 
dˇche
 = 
	`Some
(
	`DCacheP¨ams
(

46 
rowBôs
 = 
	`sôe
(
Sy°emBusKey
).
bótBôs
,

47 
nMSHRs
 = 0,

48 
blockByãs
 = 
	`sôe
(
CacheBlockByãs
))),

49 
iˇche
 = 
	`Some
(
	`ICacheP¨ams
(

50 
rowBôs
 = 
	`sôe
(
Sy°emBusKey
).
bótBôs
,

51 
blockByãs
 = 
	`sôe
(
CacheBlockByãs
))))

52 
Li°
.
	`èbuœã
(
n
)(
i
 => 
big
.
	`c›y
(
h¨tId
 = i))

54 
	}
})

56 
˛ass
 
	$WôhNSmÆlC‹es
(
n
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

57 
RockëTûesKey
 => {

58 
vÆ
 
smÆl
 = 
	`RockëTûeP¨ams
(

59 
c‹e
 = 
	`RockëC‹eP¨ams
(
u£VM
 = 
Ál£
, 
Âu
 = 
N⁄e
),

60 
btb
 = 
N⁄e
,

61 
dˇche
 = 
	`Some
(
	`DCacheP¨ams
(

62 
rowBôs
 = 
	`sôe
(
Sy°emBusKey
).
bótBôs
,

63 
nSës
 = 64,

64 
nWays
 = 1,

65 
nTLBE¡rõs
 = 4,

66 
nMSHRs
 = 0,

67 
blockByãs
 = 
	`sôe
(
CacheBlockByãs
))),

68 
iˇche
 = 
	`Some
(
	`ICacheP¨ams
(

69 
rowBôs
 = 
	`sôe
(
Sy°emBusKey
).
bótBôs
,

70 
nSës
 = 64,

71 
nWays
 = 1,

72 
nTLBE¡rõs
 = 4,

73 
blockByãs
 = 
	`sôe
(
CacheBlockByãs
))))

74 
Li°
.
	`èbuœã
(
n
)(
i
 => 
smÆl
.
	`c›y
(
h¨tId
 = i))

76 
	}
})

78 
˛ass
 
Wôh1TöyC‹e
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

79 
XLí
 => 32

80 
RockëTûesKey
 => 
Li°
(
RockëTûeP¨ams
(

81 
c‹e
 = 
RockëC‹eP¨ams
(

82 
u£VM
 = 
Ál£
,

83 
Âu
 = 
N⁄e
,

84 
mulDiv
 = 
Some
(
MulDivP¨ams
(
mulUƒﬁl
 = 8))),

85 
btb
 = 
N⁄e
,

86 
dˇche
 = 
Some
(
DCacheP¨ams
(

87 
rowBôs
 = 
sôe
(
Sy°emBusKey
).
bótBôs
,

88 
nSës
 = 256,

89 
nWays
 = 1,

90 
nTLBE¡rõs
 = 4,

91 
nMSHRs
 = 0,

92 
blockByãs
 = 
sôe
(
CacheBlockByãs
),

93 
s¸©ch
 = 
Some
(0x80000000L))),

94 
iˇche
 = 
Some
(
ICacheP¨ams
(

95 
rowBôs
 = 
sôe
(
Sy°emBusKey
).
bótBôs
,

96 
nSës
 = 64,

97 
nWays
 = 1,

98 
nTLBE¡rõs
 = 4,

99 
blockByãs
 = 
sôe
(
CacheBlockByãs
)))))

100 
RockëCrossögKey
 => 
Li°
(
RockëCrossögP¨ams
(

101 
¸ossögTy≥
 = 
Synchr⁄ousCrossög
(),

102 
ma°î
 = 
TûeMa°îP‹tP¨ams
()

106 
˛ass
 
	$WôhNB™ks
(
n
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

107 
B™kedL2Key
 => 
	`up
(B™kedL2Key, 
sôe
).
	`c›y
(
nB™ks
 = 
n
)

108 
	}
})

110 
˛ass
 
	$WôhNTøckîsPîB™k
(
n
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

111 
Brﬂdˇ°Key
 => 
	`up
(Brﬂdˇ°Key, 
sôe
).
	`c›y
(
nTøckîs
 = 
n
)

112 
	}
})

115 
˛ass
 
	$WôhL1ICacheSës
(
£ts
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

116 
RockëTûesKey
 => 
	`up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

117 
r
.
	`c›y
(
iˇche
 =Ñ.iˇche.
	`m≠
(
_
.c›y(
nSës
 = 
£ts
))) }

118 
	}
})

121 
˛ass
 
	$WôhL1DCacheSës
(
£ts
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

122 
RockëTûesKey
 => 
	`up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

123 
r
.
	`c›y
(
dˇche
 =Ñ.dˇche.
	`m≠
(
_
.c›y(
nSës
 = 
£ts
))) }

124 
	}
})

126 
˛ass
 
	$WôhL1ICacheWays
(
ways
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

127 
RockëTûesKey
 => 
	`up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

128 
r
.
	`c›y
(
iˇche
 =Ñ.iˇche.
	`m≠
(
_
.c›y(
nWays
 = 
ways
)))

130 
	}
})

132 
˛ass
 
	$WôhL1DCacheWays
(
ways
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

133 
RockëTûesKey
 => 
	`up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

134 
r
.
	`c›y
(
dˇche
 =Ñ.dˇche.
	`m≠
(
_
.c›y(
nWays
 = 
ways
)))

136 
	}
})

138 
˛ass
 
	$WôhCacheBlockByãs
(
löesize
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

139 
CacheBlockByãs
 => 
löesize


140 
	}
})

142 
˛ass
 
WôhBuf„æessBrﬂdˇ°Hub
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

143 
Brﬂdˇ°Key
 => 
up
(Brﬂdˇ°Key, 
sôe
).
c›y
(
buf„æess
 = 
åue
)

158 
˛ass
 
WôhIncohîítTûes
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

159 
RockëCrossögKey
 => 
up
(RockëCrossögKey, 
sôe
Ë
m≠
 { 
r
 =>

160 
r
.
c›y
(
ma°î
 =Ñ.ma°î.c›y(
c‹k
 = 
Some
(
åue
)))

162 
B™kedL2Key
 => 
up
(B™kedL2Key, 
sôe
).
c›y
(
cohîí˚M™agî
 = { 
subsy°em
 =>

163 
vÆ
 
ww
 = 
LazyModuÀ
(
√w
 
TLWidthWidgë
(
subsy°em
.
sbus
.
bótByãs
)(subsy°em.
p
))

164 (
ww
.
node
, ww.node, (Ë=> 
N⁄e
)

168 
˛ass
 
WôhRV32
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

169 
XLí
 => 32

170 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

171 
r
.
c›y
(
c‹e
 =Ñ.core.copy(

172 
Âu
 = 
r
.
c‹e
.Âu.
m≠
(
_
.
c›y
(
fLí
 = 32)),

173 
mulDiv
 = 
Some
(
MulDivP¨ams
(
mulUƒﬁl
 = 8))))

177 
˛ass
 
	$WôhN⁄blockögL1
(
nMSHRs
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

178 
RockëTûesKey
 => 
	`up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

179 
r
.
	`c›y
(
dˇche
 =Ñ.dˇche.
	`m≠
(
_
.c›y(
nMSHRs
 =ÇMSHRs)))

181 
	}
})

183 
˛ass
 
	$WôhNBªakpoöts
(
hwbp
: 
I¡
Ë
exãnds
 
	`C⁄fig
 ((
sôe
, 
hîe
, 
up
) => {

184 
RockëTûesKey
 => 
	`up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

185 
r
.
	`c›y
(
c‹e
 =Ñ.c‹e.c›y(
nBªakpoöts
 = 
hwbp
))

187 
	}
})

189 
˛ass
 
WôhRoccExam∂e
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

190 
BuûdRoCC
 => 
Li°
(

191 (
p
: 
P¨amëîs
) => {

192 
vÆ
 
accumuœt‹
 = 
LazyModuÀ
(
√w
 
Accumuœt‹Exam∂e
(
OpcodeSë
.
cu°om0
, 
n
 = 4)(
p
))

193 
accumuœt‹


195 (
p
: 
P¨amëîs
) => {

196 
vÆ
 
å™¶©‹
 = 
LazyModuÀ
(
√w
 
Tøn¶©‹Exam∂e
(
OpcodeSë
.
cu°om1
)(
p
))

197 
å™¶©‹


199 (
p
: 
P¨amëîs
) => {

200 
vÆ
 
cou¡î
 = 
LazyModuÀ
(
√w
 
Ch¨a˘îCou¡Exam∂e
(
OpcodeSë
.
cu°om2
)(
p
))

201 
cou¡î


205 
˛ass
 
WôhDeÁu…Btb
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

206 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

207 
r
.
c›y
(
btb
 = 
Some
(
BTBP¨ams
()))

211 
˛ass
 
WôhFa°MulDiv
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

212 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

213 
r
.
c›y
(
c‹e
 =Ñ.c‹e.c›y(
mulDiv
 = 
Some
(

214 
MulDivP¨ams
(
mulUƒﬁl
 = 8, 
mulE¨lyOut
 = (
sôe
(
XLí
Ë> 32), 
divE¨lyOut
 = 
åue
)

218 
˛ass
 
WôhoutMulDiv
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

219 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

220 
r
.
c›y
(
c‹e
 =Ñ.c‹e.c›y(
mulDiv
 = 
N⁄e
))

224 
˛ass
 
WôhoutFPU
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

225 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

226 
r
.
c›y
(
c‹e
 =Ñ.c‹e.c›y(
Âu
 = 
N⁄e
))

230 
˛ass
 
WôhFPUWôhoutDivSqπ
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

231 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

232 
r
.
c›y
(
c‹e
 =Ñ.c‹e.c›y(
Âu
 =Ñ.c‹e.Âu.
m≠
(
_
.c›y(
divSqπ
 = 
Ál£
))))

236 
˛ass
 
	$WôhBoŸROMFûe
(
boŸROMFûe
: 
Såög
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

237 
BoŸROMP¨ams
 => 
	`up
(BoŸROMP¨ams, 
sôe
).
	`c›y
(
c⁄ã¡FûeName
 = 
boŸROMFûe
)

238 
	}
})

240 
˛ass
 
WôhSynchr⁄ousRockëTûes
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

241 
RockëCrossögKey
 => 
up
(RockëCrossögKey, 
sôe
Ë
m≠
 { 
r
 =>

242 
r
.
c›y
(
¸ossögTy≥
 = 
Synchr⁄ousCrossög
())

246 
˛ass
 
	$WôhAsynchr⁄ousRockëTûes
(
dïth
: 
I¡
, 
sync
: I¡Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

247 
RockëCrossögKey
 => 
	`up
(RockëCrossögKey, 
sôe
Ë
m≠
 { 
r
 =>

248 
r
.
	`c›y
(
¸ossögTy≥
 = 
	`Asynchr⁄ousCrossög
(
dïth
, 
sync
))

250 
	}
})

252 
˛ass
 
WôhR©i⁄ÆRockëTûes
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

253 
RockëCrossögKey
 => 
up
(RockëCrossögKey, 
sôe
Ë
m≠
 { 
r
 =>

254 
r
.
c›y
(
¸ossögTy≥
 = 
R©i⁄ÆCrossög
())

258 
˛ass
 
	$WôhEdgeD©aBôs
(
d©aBôs
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

259 
Mem‹yBusKey
 => 
	`up
(Mem‹yBusKey, 
sôe
).
	`c›y
(
bótByãs
 = 
d©aBôs
/8)

260 
ExtIn
 => 
	`up
(ExtIn, 
sôe
).
	`m≠
(
_
.
	`c›y
(
bótByãs
 = 
d©aBôs
/8))

262 
	}
})

264 
˛ass
 
WôhJègDTM
 
exãnds
 
C⁄fig
 ((
sôe
, 
hîe
, 
up
) => {

265 
In˛udeJègDTM
 => 
åue


268 
˛ass
 
WôhDebugSBA
 
exãnds
 
C⁄fig
 ((
sôe
, 
hîe
, 
up
) => {

269 
DebugModuÀP¨ams
 => 
up
(DebugModuÀP¨ams).
c›y
(
hasBusMa°î
 = 
åue
)

272 
˛ass
 
	$WôhNBôPîùhîyBus
(
nBôs
: 
I¡
Ë
exãnds
 
	`C⁄fig
 ((
sôe
, 
hîe
, 
up
) => {

273 
PîùhîyBusKey
 => 
	`up
(PîùhîyBusKey, 
sôe
).
	`c›y
(
bótByãs
 = 
nBôs
/8)

274 
	}
})

276 
˛ass
 
WôhoutTLM⁄ô‹s
 
exãnds
 
C⁄fig
 ((
sôe
, 
hîe
, 
up
) => {

277 
M⁄ô‹sE«bÀd
 => 
Ál£


280 
˛ass
 
	$WôhNExtT›I¡îru±s
(
nExtI¡s
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

281 
NExtT›I¡îru±s
 => 
nExtI¡s


282 
	}
})

284 
˛ass
 
	$WôhNMem‹yCh™√ls
(
n
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

285 
ExtMem
 => 
	`up
(ExtMem, 
sôe
).
	`m≠
(
_
.
	`c›y
(
nMem‹yCh™√ls
 = 
n
))

286 
	}
})

288 
˛ass
 
	$WôhExtMemSize
(
n
: 
L⁄g
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

289 
ExtMem
 => 
	`up
(ExtMem, 
sôe
).
	`m≠
(
x
 => x.
	`c›y
(
ma°î
 = x.ma°î.c›y(
size
 = 
n
)))

290 
	}
})

292 
˛ass
 
	$WôhDTS
(
modñ
: 
Såög
, 
com∑t
: 
Seq
[Såög]Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

293 
DTSModñ
 => 
modñ


294 
DTSCom∑t
 => 
com∑t


295 
	}
})

297 
˛ass
 
	$WôhTimeba£
(
hîtz
: 
BigI¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

298 
DTSTimeba£
 => 
hîtz


299 
	}
})

301 
˛ass
 
WôhDeÁu…MemP‹t
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

302 
ExtMem
 => 
Some
(
Mem‹yP‹tP¨ams
(
Ma°îP‹tP¨ams
(

303 
ba£
 = 
x
"8000_0000",

304 
size
 = 
x
"1000_0000",

305 
bótByãs
 = 
sôe
(
Mem‹yBusKey
).beatBytes,

306 
idBôs
 = 4), 1))

309 
˛ass
 
WôhNoMemP‹t
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

310 
ExtMem
 => 
N⁄e


313 
˛ass
 
WôhDeÁu…MMIOP‹t
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

314 
ExtBus
 => 
Some
(
Ma°îP‹tP¨ams
(

315 
ba£
 = 
x
"6000_0000",

316 
size
 = 
x
"2000_0000",

317 
bótByãs
 = 
sôe
(
Mem‹yBusKey
).beatBytes,

318 
idBôs
 = 4))

321 
˛ass
 
WôhNoMMIOP‹t
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

322 
ExtBus
 => 
N⁄e


325 
˛ass
 
WôhDeÁu…SœveP‹t
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

326 
ExtIn
 => 
Some
(
SœveP‹tP¨ams
(
bótByãs
 = 8, 
idBôs
 = 8, 
sour˚Bôs
 = 4))

329 
˛ass
 
WôhNoSœveP‹t
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

330 
ExtIn
 => 
N⁄e


333 
˛ass
 
WôhS¸©ch∑dsO∆y
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

334 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

335 
r
.
c›y
(

336 
c‹e
 = 
r
.c‹e.
c›y
(
u£VM
 = 
Ál£
),

337 
dˇche
 = 
r
.dˇche.
m≠
(
_
.
c›y
(

338 
nSës
 = 256,

339 
nWays
 = 1,

340 
s¸©ch
 = 
Some
(0x80000000L))))

344 
˛ass
 
WôhPrivCodeLock1
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

345 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

346 
r
.
c›y
(

347 
c‹e
 = 
r
.c‹e.
c›y
(

348 
hasPrivCodeLock
 = 
åue
,

349 
numPCodeR™ges
 = 1

355 
˛ass
 
WôhPrivCodeLock
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

356 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

357 
r
.
c›y
(

358 
c‹e
 = 
r
.c‹e.
c›y
(

359 
hasPrivCodeLock
 = 
åue
,

360 
numPCodeR™ges
 = 4

366 
˛ass
 
WôhPrivCodeLock3
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

367 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

368 
r
.
c›y
(

369 
c‹e
 = 
r
.c‹e.
c›y
(

370 
hasPrivCodeLock
 = 
åue
,

371 
numPCodeR™ges
 = 3

377 
˛ass
 
WôhPrivCodeLock2
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

378 
RockëTûesKey
 => 
up
(RockëTûesKey, 
sôe
Ë
m≠
 { 
r
 =>

379 
r
.
c›y
(

380 
c‹e
 = 
r
.c‹e.
c›y
(

381 
hasPrivCodeLock
 = 
åue
,

382 
numPCodeR™ges
 = 4

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/CrossingWrapper.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	gaxi4
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
	g_


12 @
dïªˇãd
("Only useÅhisÅrait if youáre confident you island will onlyÉver be crossedÅoá single clock", "rocket-chip 1.3")

13 
åaô
 
HasCrossög
 
exãnds
 
	gCros£sToO∆yO√ClockDomaö
 { 
	gthis
: 
LazyModuÀ
 => }

20 
åaô
 
Cros£sToO∆yO√ClockDomaö
 
exãnds
 
HasClockDomaöCrossög
 { 
this
: 
LazyModuÀ
 =>

22 
def
 
¸ossög
: 
ClockCrossögTy≥


24 
def
 
¸ossTLIn
(
n
: 
TLInw¨dNode
)(
im∂icô
 
p
: 
P¨amëîs
): TLInwardNode = {

25 
vÆ
 
éInXög
 = 
this
.
¸ossIn
(
n
)

26 
éInXög
(
¸ossög
)

29 
def
 
¸ossTLOut
(
n
: 
TLOutw¨dNode
)(
im∂icô
 
p
: 
P¨amëîs
): TLOutwardNode = {

30 
vÆ
 
éOutXög
 = 
this
.
¸ossOut
(
n
)

31 
éOutXög
(
¸ossög
)

34 
def
 
¸ossAXI4In
(
n
: 
AXI4Inw¨dNode
)(
im∂icô
 
p
: 
P¨amëîs
): AXI4InwardNode = {

35 
vÆ
 
axi4InXög
 = 
this
.
¸ossIn
(
n
)

36 
axi4InXög
(
¸ossög
)

39 
def
 
¸ossAXI4Out
(
n
: 
AXI4Outw¨dNode
)(
im∂icô
 
p
: 
P¨amëîs
): AXI4OutwardNode = {

40 
vÆ
 
axi4OutXög
 = 
this
.
¸ossOut
(
n
)

41 
axi4OutXög
(
¸ossög
)

44 
def
 
¸ossI¡In
(
n
: 
I¡Inw¨dNode
)(
im∂icô
 
p
: 
P¨amëîs
): IntInwardNode = {

45 
vÆ
 
ötInXög
 = 
this
.
¸ossIn
(
n
)

46 
ötInXög
(
¸ossög
)

49 
def
 
¸ossI¡Out
(
n
: 
I¡Outw¨dNode
)(
im∂icô
 
p
: 
P¨amëîs
): IntOutwardNode = {

50 
vÆ
 
ötOutXög
 = 
this
.
¸ossOut
(
n
)

51 
ötOutXög
(
¸ossög
)

56 
˛ass
 
	$CrossögWøµî
(
vÆ
 
¸ossög
: 
ClockCrossögTy≥
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
Sim∂eLazyModuÀ
 
wôh
 
Cros£sToO∆yO√ClockDomaö


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/FrontBus.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
˛ass
 
Fr⁄tBusP¨ams
(

12 
bótByãs
: 
I¡
,

13 
blockByãs
: 
I¡
,

14 
sbusCrossög
: 
ClockCrossögTy≥
 = 
Synchr⁄ousCrossög
(),

15 
sbusBuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
Ë
exãnds
 
HasTLBusP¨ams


17 
obje˘
 
Fr⁄tBusKey
 
exãnds
 
Fõld
[
Fr⁄tBusP¨ams
]

19 
˛ass
 
	$Fr⁄tBus
(
∑øms
: 
Fr⁄tBusP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
)

20 
exãnds
 
	`TLBusWøµî
(
∑øms
, "front_bus")

21 
wôh
 
HasClockDomaöCrossög


22 
wôh
 
C™AâachTLMa°îs


23 
wôh
 
HasTLXb¨Phy
 {

25 
def
 
	`‰omCohîítChù
(
gí
: => 
TLNode
): 
TLInw¨dNode
 = {

26 
	`‰om
("cohîít_subsy°em"Ë{ 
öw¨dNode
 :=* 
gí
 }

29 
def
 
	`¸ossToSy°emBus
(
gí
: (=> 
TLOutw¨dNode
Ë=> 
NoH™dÀ
) {

30 
	`to
("sbus") {

31 
vÆ
 
é_xög
 = 
this
.
	`¸ossOut
(
	`TLBuf„r
(
∑øms
.
sbusBuf„r
Ë:=* 
outw¨dNode
)

32 
	`gí
(
	`é_xög
(
∑øms
.
sbusCrossög
))

35 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/HasTiles.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
d⁄tTouch


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.
TLDebugModuÀ


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.{
	gBasicBusBlockî
, 
	gBasicBusBlockîP¨ams
, 
	gCLINT
, 
	gCLINTC⁄°s
, 
	gTLPLIC
, 
	gPLICKey
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.{
	gBa£Tûe
, 
	gLookupByH¨tId
, 
	gLookupByH¨tIdIm∂
, 
	gTûeKey
, 
	gTûeP¨ams
, 
	gSh¨edMem‹yTLEdge
, 
	gHasExã∫ÆlyDrivíTûeC⁄°™ts
}

13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


16 ˛as†
	cClockedTûeI≈uts
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
P¨amëîizedBundÀ


17 
wôh
 
HasExã∫ÆlyDrivíTûeC⁄°™ts


18 
wôh
 
Clocked


20 
åaô
 
HasTûes
 { 
this
: 
Ba£Subsy°em
 =>

21 
im∂icô
 
vÆ
 
p
: 
P¨amëîs


22 
vÆ
 
tûes
: 
Seq
[
Ba£Tûe
]

23 
¥Ÿe˘ed
 
def
 
tûeP¨ams
: 
Seq
[
TûeP¨ams
] = 
tûes
.
	$m≠
(
_
.
tûeP¨ams
)

24 
def
 
nTûes
: 
I¡
 = 
tûeP¨ams
.
size


25 
def
 
h¨tIdLi°
: 
Seq
[
I¡
] = 
tûeP¨ams
.
	$m≠
(
_
.
h¨tId
)

26 
def
 
loˇlI¡Cou¡s
: 
Seq
[
I¡
] = 
tûeP¨ams
.
	$m≠
(
_
.
c‹e
.
nLoˇlI¡îru±s
)

27 
def
 
sh¨edMem‹yTLEdge
 = 
sbus
.
busVõw


28 
vÆ
 
meùNode
 = 
	$p
(
PLICKey
Ë
m©ch
 {

29 
	`Some
(
_
Ë=> 
N⁄e


30 
N⁄e
 => 
	`Some
(
	`I¡Sour˚Node
(
	`I¡Sour˚P‹tSim∂e
(
num
 = 1, 
p‹ts
 = 1, 
sour˚s
 = 1)))

33 
¥iv©e
 
vÆ
 
lookupByH¨tId
 = 
√w
 
LookupByH¨tIdIm∂
 {

34 
def
 
≠∂y
[
T
 <: 
D©a
](
f
: 
TûeP¨ams
 => 
O±i⁄
[T], 
h¨tId
: 
UI¡
): T =

35 
	`Pri‹ôyMux
(
tûeP¨ams
.
cﬁÀ˘
 { 
t
 
	`f
—).
isDeföed
 => (t.
h¨tId
.
U
 ==h¨tIdË-> f—).
gë
 })

36 
	}
}

38 
¥Ÿe˘ed
 
def
 
	$augmíãdTûeP¨amëîs
(
ç
: 
TûeP¨ams
): 
P¨amëîs
 = 
p
.
ÆãrP¨tül
 {

41 
TûeKey
 => 
ç


42 
Sh¨edMem‹yTLEdge
 => 
sh¨edMem‹yTLEdge


43 
LookupByH¨tId
 => 
lookupByH¨tId


44 
	}
}

46 
¥Ÿe˘ed
 
def
 
	$c⁄√˘Ma°îP‹tsToSBus
(
tûe
: 
Ba£Tûe
, 
¸ossög
: 
RockëCrossögP¨ams
) {

47 
sbus
.
	`‰omTûe
(
tûe
.
tûeP¨ams
.
«me
, 
¸ossög
.
ma°î
.
buf„rs
) {

48 
¸ossög
.
ma°î
.
c‹k


49 .
m≠
 { 
u
 => 
	`TLCacheC‹k
(
unß„
 = u) }

50 .
m≠
 { 
_
 :=* 
tûe
.
	`¸ossMa°îP‹t
() }

51 .
gëOrEl£
 { 
tûe
.
	`¸ossMa°îP‹t
() }

53 
	}
}

55 
¥Ÿe˘ed
 
def
 
	$c⁄√˘SœveP‹tsToCBus
(
tûe
: 
Ba£Tûe
, 
¸ossög
: 
RockëCrossögP¨ams
)(
im∂icô
 
vÆName
: 
VÆName
) {

57 
DißbÀM⁄ô‹s
 { 
im∂icô
 
p
 =>

58 
sbus
.
c⁄åﬁ_bus
.
	`toTûe
(
tûe
.
tûeP¨ams
.
«me
) {

59 
¸ossög
.
¶ave
.
blockîCålAddr


60 .
m≠
 { 
	`BasicBusBlockîP¨ams
(
_
, 
pbus
.
bótByãs
, 
sbus
.beatBytes) }

61 .
m≠
 { 
bbbp
 => 
	`LazyModuÀ
(
√w
 
	`BasicBusBlockî
(bbbp)) }

62 .
m≠
 { 
bbb
 =>

63 
sbus
.
c⁄åﬁ_bus
.
	`toV¨übÀWidthSœve
(
	`Some
("bus_blockî")Ë{ 
bbb
.
c⁄åﬁNode
 }

64 
tûe
.
	`¸ossSœveP‹t
(Ë:*
bbb
.
node


65 } .
gëOrEl£
 { 
tûe
.
	`¸ossSœveP‹t
() }

68 
	}
}

70 
¥Ÿe˘ed
 
def
 
	$c⁄√˘I¡îru±s
(
tûe
: 
Ba£Tûe
, 
debugO±
: 
O±i⁄
[
TLDebugModuÀ
], 
˛ötO±
: O±i⁄[
CLINT
], 
∂icO±
: O±i⁄[
TLPLIC
]) {

77 
tûe
.
ötInw¨dNode
 :=

78 
debugO±


79 .
m≠
 { 
tûe
 { 
	`I¡SyncCrossögSök
(3Ë} :
_
.
öäode
 }

80 .
gëOrEl£
 { 
	`NuŒI¡Sour˚
() }

86 
tûe
.
	`¸ossI¡In
() :=

87 
˛ötO±
.
m≠
 { 
_
.
öäode
 }

88 .
gëOrEl£
 { 
	`NuŒI¡Sour˚
(
sour˚s
 = 
CLINTC⁄°s
.
öts
) }

91 
tûe
.
	`¸ossI¡In
() :=

92 
∂icO±
 .
m≠
 { 
_
.
öäode
 }

93 .
gëOrEl£
 { 
meùNode
.
gë
 }

96 i‡(
tûe
.
tûeP¨ams
.
c‹e
.
u£VM
) {

97 
tûe
.
	`¸ossI¡In
() :=

98 
∂icO±
 .
m≠
 { 
_
.
öäode
 }

99 .
gëOrEl£
 { 
	`NuŒI¡Sour˚
() }

107 
∂icO±
.
f‹óch
 { 
∂ic
 =>

108 
FlùRídîög
 { 
im∂icô
 
p
 =>

109 
∂ic
.
öäode
 :=* 
tûe
.
	`¸ossI¡Out
()

112 
	}
}

114 
¥Ÿe˘ed
 
def
 
≥rTûeOrGlobÆSëtög
[
T
](
ö
: 
Seq
[T], 
	gn
: 
I¡
): Seq[T] = in.
size
 
m©ch
 {

115 1 => 
Li°
.
fûl
(
n
)(
ö
.
hód
)

116 
x
 x =
n
 => 
ö


117 
_
 => 
throw
 
√w
 
Ex˚±i⁄
("mustÖrovideÉxactly 1 or #tiles ofÅhis key")

121 
åaô
 
HasTûesBundÀ
 {

122 
vÆ
 
tûe_öputs
: 
Vec
[
ClockedTûeI≈uts
]

125 
åaô
 
HasTûesModuÀImp
 
exãnds
 
LazyModuÀImp


126 
wôh
 
HasTûesBundÀ


127 
wôh
 
HasRe£tVe˘‹Wúe
 {

128 
vÆ
 
ouãr
: 
HasTûes


130 
def
 
ª£tVe˘‹Bôs
: 
I¡
 = {

132 
vÆ
 
ve˘‹s
 = 
ouãr
.
tûes
.
m≠
(
_
.
moduÀ
.
c⁄°™ts
.
ª£t_ve˘‹
)

133 
ªquúe
(
ve˘‹s
.
èû
.
f‹Æl
(
_
.
gëWidth
 =ve˘‹s.
hód
.getWidth))

134 
ve˘‹s
.
hód
.
gëWidth


137 
vÆ
 
tûe_öputs
 = 
d⁄tTouch
(
Wúe
(
Vec
(
ouãr
.
nTûes
, 
√w
 
ClockedTûeI≈uts
()(
p
.
ÆãrP¨tül
 {

138 
Sh¨edMem‹yTLEdge
 => 
ouãr
.
sh¨edMem‹yTLEdge


142 
	gouãr
.
	gtûes
.
m≠
(
_
.
moduÀ
).
zù
(
tûe_öputs
).
	gf‹óch
 { (
	gtûe
, 
	gwúe
) =>

143 
tûe
.
˛ock
 :
wúe
.clock

144 
tûe
.
ª£t
 :
wúe
.reset

145 
tûe
.
c⁄°™ts
.
h¨tid
 :
wúe
.hartid

146 
tûe
.
c⁄°™ts
.
ª£t_ve˘‹
 :
wúe
.reset_vector

149 
vÆ
 
meù
 = if(
ouãr
.
meùNode
.
isDeföed
Ë
Some
(
IO
(
Boﬁ
(
INPUT
))Ë
N⁄e


150 
meù
.
f‹óch
 { (
ouãr
.
meùNode
.
gë
.
out
(0).
_1
)(0Ë:
_
 }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/InterruptBus.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


11 ˛as†
	cI¡îru±BusWøµî
(
im∂icô
 
p
: 
P¨amëîs
) {

13 
vÆ
 
öt_bus
 = 
	$LazyModuÀ
(
√w
 
I¡Xb¨
)

15 
¥iv©e
 
def
 
	$synchr⁄ize
(
sync
: 
I¡
): 
I¡Inw¨dNode
 = {

16 
vÆ
 
asyncXög
 = 
	`LazyModuÀ
(
√w
 
	`I¡Xög
(
sync
))

17 
öt_bus
.
öäode
 :
asyncXög
.intnode

18 
asyncXög
.
öäode


21 
def
 
‰omAsync
: 
I¡Inw¨dNode
 = 
	$synchr⁄ize
(3)

22 
def
 
‰omR©i⁄Æ
: 
I¡Inw¨dNode
 = 
	$synchr⁄ize
(1)

23 
def
 
‰omSync
: 
I¡Inw¨dNode
 = 
öt_bus
.
öäode


24 
def
 
toPLIC
: 
I¡Outw¨dNode
 = 
öt_bus
.
öäode


25 
	}
}

28 
obje˘
 
NExtT›I¡îru±s
 
exãnds
 
Fõld
[
I¡
](0)

34 
ab°ø˘
 
åaô
 
HasExtI¡îru±s
 { 
this
: 
Ba£Subsy°em
 =>

35 
¥iv©e
 
vÆ
 
devi˚
 = 
√w
 
Devi˚
 
wôh
 
Devi˚I¡îru±s
 {

36 
def
 
des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

37 
Des¸ùti⁄
("soc/exã∫Æ-öãºu±s", 
des¸ibeI¡îru±s
(
ªsour˚s
))

41 
vÆ
 
	gnExtI¡îru±s
 = 
p
(
NExtT›I¡îru±s
)

42 
vÆ
 
extI¡îru±s
 = 
I¡Sour˚Node
(
I¡Sour˚P‹tSim∂e
(
num
 = 
nExtI¡îru±s
, 
ªsour˚s
 = 
devi˚
.))

48 
åaô
 
HasAsyncExtI¡îru±s
 
exãnds
 
	gHasExtI¡îru±s
 { 
	gthis
: 
Ba£Subsy°em
 =>

49 i‡(
nExtI¡îru±s
 > 0) {

50 
ibus
.
‰omAsync
 :
extI¡îru±s


57 
åaô
 
HasSyncExtI¡îru±s
 
exãnds
 
HasExtI¡îru±s
 { 
this
: 
Ba£Subsy°em
 =>

58 i‡(
nExtI¡îru±s
 > 0) {

59 
ibus
.
‰omSync
 :
extI¡îru±s


64 
åaô
 
HasExtI¡îru±sBundÀ
 {

65 
vÆ
 
öãºu±s
: 
UI¡


67 
def
 
tõOffI¡îru±s
(
dummy
: 
I¡
 = 1) {

68 
öãºu±s
 :
UI¡
(0)

75 
åaô
 
HasExtI¡îru±sModuÀImp
 
exãnds
 
LazyModuÀImp
 
wôh
 
HasExtI¡îru±sBundÀ
 {

76 
vÆ
 
ouãr
: 
HasExtI¡îru±s


77 
vÆ
 
öãºu±s
 = 
IO
(
UI¡
(
INPUT
, 
width
 = 
ouãr
.
nExtI¡îru±s
))

79 
ouãr
.
extI¡îru±s
.
out
.
m≠
(
_
.
_1
).
Ê©ãn
.
zùWôhIndex
.
f‹óch
 { (
o
, 
i
Ë=> o :
öãºu±s
(i) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/MemoryBus.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.{
	gDevNuŒP¨ams
, 
	gTLEº‹
, 
	gTLZîo
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


13 
obje˘
 
CacheBlockByãs
 
exãnds
 
	gFõld
[
I¡
](64)

16 
˛ass
 
	$Brﬂdˇ°P¨ams
(

17 
nTøckîs
: 
I¡
 = 4,

18 
buf„æess
: 
Boﬁón
 = 
Ál£
)

20 
obje˘
 
Brﬂdˇ°Key
 
exãnds
 
	`Fõld
(
	$Brﬂdˇ°P¨ams
())

23 
˛ass
 
	`B™kedL2P¨ams
(

24 
nB™ks
: 
I¡
 = 1,

25 
cohîí˚M™agî
: 
Ba£Subsy°em
 => (
TLInw¨dNode
, 
TLOutw¨dNode
, (Ë=> 
O±i⁄
[
Boﬁ
]Ë{ 
subsy°em
 =>

26 
im∂icô
 
vÆ
 
p
 = 
subsy°em
.p

27 
vÆ
 
	`Brﬂdˇ°P¨ams
(
nTøckîs
, 
buf„æess
Ë
	`p
(
Brﬂdˇ°Key
)

28 
vÆ
 
bh
 = 
	`LazyModuÀ
(
√w
 
	`TLBrﬂdˇ°
(
subsy°em
.
memBusBlockByãs
, 
nTøckîs
, 
buf„æess
))

29 
vÆ
 
ww
 = 
	`LazyModuÀ
(
√w
 
	`TLWidthWidgë
(
subsy°em
.
sbus
.
bótByãs
))

30 
ww
.
node
 :*
bh
.node

31 (
bh
.
node
, 
ww
.node, (Ë=> 
N⁄e
)

32 
	}
}) {

35 
obje˘
 
B™kedL2Key
 
exãnds
 
Fõld
(
	$B™kedL2P¨ams
())

38 
˛ass
 
	$Mem‹yBusP¨ams
(

39 
bótByãs
: 
I¡
,

40 
blockByãs
: 
I¡
,

41 
zîoDevi˚
: 
O±i⁄
[
AddªssSë
] = 
N⁄e
,

42 
îr‹Devi˚
: 
O±i⁄
[
DevNuŒP¨ams
] = 
N⁄e
Ë
exãnds
 
HasTLBusP¨ams


44 
obje˘
 
Mem‹yBusKey
 
exãnds
 
Fõld
[
Mem‹yBusP¨ams
]

47 
˛ass
 
	$Mem‹yBus
(
∑øms
: 
Mem‹yBusP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
)

48 
exãnds
 
	`TLBusWøµî
(
∑øms
, "mem‹y_bus")(
p
)

49 
wôh
 
C™AâachTLSœves
 {

51 
¥iv©e
 
vÆ
 
xb¨
 = 
	`LazyModuÀ
(
√w
 
TLXb¨
).
	`sugge°Name
(
busName
 + "_xbar")

52 
def
 
öw¨dNode
: 
TLInw¨dNode
 = 
xb¨
.
node


53 
def
 
outw¨dNode
: 
TLOutw¨dNode
 = 
	`ProbePickî
(Ë:*
xb¨
.
node


55 
∑øms
.
zîoDevi˚
.
f‹óch
 { 
addr
 => 
	`LazySc›e
("wrapped_zero_device") {

56 
vÆ
 
zîo
 = 
	`LazyModuÀ
(
√w
 
	`TLZîo
(

57 
addªss
 = 
addr
,

58 
bótByãs
 = 
∑øms
.beatBytes))

59 
zîo
.
node
 :
	`TLFøgmíãr
(
∑øms
.
bótByãs
,Ö¨ams.
blockByãs
Ë:
	`TLBuf„r
(Ë:
outw¨dNode


62 
∑øms
.
îr‹Devi˚
.
f‹óch
 { 
d≈
 => 
	`LazySc›e
("wrapped_error_device") {

63 
vÆ
 
îr‹
 = 
	`LazyModuÀ
(
√w
 
	`TLEº‹
(

64 
∑øms
 = 
d≈
,

65 
bótByãs
 = 
∑øms
.beatBytes))

66 
îr‹
.
node
 :
	`TLBuf„r
(Ë:
outw¨dNode


69 
def
 
toDRAMC⁄åﬁÀr
[
D
,
U
,
E
,
B
 <: 
D©a
]

70 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
buf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

71 (
gí
: => 
NodeH™dÀ
[ 
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
, 
D
,
U
,
E
,
B
] =

72 
	`TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

73 
	`to
("mem‹y_c⁄åﬁÀr" 
«med
 
«me
Ë{ 
gí
 :
	`TLBuf„r
(
buf„r
Ë:
outw¨dNode
 }

75 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/PeripheryBus.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.{
	gDevNuŒP¨ams
, 
	gTLEº‹
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
˛ass
 
	$BusAtomics
(

13 
¨ôhmëic
: 
Boﬁón
 = 
åue
,

14 
buf„r
: 
Buf„rP¨ams
 = BufferParams.

17 
˛ass
 
	`PîùhîyBusP¨ams
(

18 
bótByãs
: 
I¡
,

19 
blockByãs
: 
I¡
,

20 
©omics
: 
O±i⁄
[
BusAtomics
] = 
	`Some
(
	`BusAtomics
()),

21 
sbusCrossögTy≥
: 
ClockCrossögTy≥
 = 
	`Synchr⁄ousCrossög
(),

22 
‰equícy
: 
BigI¡
 = 
	`BigI¡
(100000000),

23 
îr‹Devi˚
: 
O±i⁄
[
DevNuŒP¨ams
] = 
N⁄e


24 Ë
exãnds
 
HasTLBusP¨ams


26 
obje˘
 
PîùhîyBusKey
 
exãnds
 
Fõld
[
PîùhîyBusP¨ams
]

28 
˛ass
 
	$PîùhîyBus
(
∑øms
: 
PîùhîyBusP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
)

29 
exãnds
 
	`TLBusWøµî
(
∑øms
, "periphery_bus")

30 
wôh
 
HasClockDomaöCrossög


31 
wôh
 
C™AâachTLSœves
 {

33 
¥iv©e
 
vÆ
 
ö_xb¨
 = 
	`LazyModuÀ
(
√w
 
TLXb¨
)

34 
¥iv©e
 
vÆ
 
out_xb¨
 = 
	`LazyModuÀ
(
√w
 
TLXb¨
)

35 
¥iv©e
 
vÆ
 
©omics
 = 
∑øms
.©omics.
m≠
 { 
∑
 =>

36 
	`TLBuf„r
(
∑
.
buf„r
Ë:*
	`TLAtomicAutom©a
(
¨ôhmëic
 =Öa.arithmetic)

37 }.
	`gëOrEl£
(
	`TLNameNode
("no_atomics"))

39 
out_xb¨
.
node
 :*
©omics
 :*
ö_xb¨
.node

41 
def
 
öw¨dNode
: 
TLInw¨dNode
 = 
ö_xb¨
.
node


42 
def
 
outw¨dNode
: 
TLOutw¨dNode
 = 
out_xb¨
.
node


44 
∑øms
.
îr‹Devi˚
.
f‹óch
 { 
d≈
 => 
	`LazySc›e
("wrapped_error_device") {

45 
vÆ
 
îr‹
 = 
	`LazyModuÀ
(
√w
 
	`TLEº‹
(
∑øms
 = 
d≈
, 
bótByãs
 =Öarams.beatBytes))

46 
îr‹
.
node
 :
outw¨dNode


49 
def
 
	`¸ossFromSy°emBus
(
gí
: (=> 
TLInw¨dNode
Ë=> 
NoH™dÀ
) {

50 
	`‰om
("sbus") {

51 
vÆ
 
‰om_sbus
 = 
this
.
	`¸ossIn
(
öw¨dNode
)

52 
	`gí
(
	`‰om_sbus
(
∑øms
.
sbusCrossögTy≥
))

56 
def
 
	`¸ossFromC⁄åﬁBus
(
gí
: (=> 
TLInw¨dNode
Ë=> 
NoH™dÀ
) {

57 
	`‰om
("cbus") {

58 
vÆ
 
‰om_cbus
 = 
this
.
	`¸ossIn
(
öw¨dNode
)

59 
	`gí
(
	`‰om_cbus
(
∑øms
.
sbusCrossögTy≥
))

63 
def
 
‰omOthîMa°î
[
D
,
U
,
E
,
B
 <: 
D©a
]

64 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
buf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

65 (
gí
: => 
NodeH™dÀ
[
D
,
U
,
E
,
B
,
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeOut
,
TLBundÀ
] =

66 
	`TLNameNode
(
«me
)): 
Inw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

67 
	`‰om
("ma°î" 
«med
 
«me
) {

68 
öw¨dNode
 :=* 
	`TLBuf„r
(
buf„r
Ë:=* 
gí


72 
def
 
toTûe


73 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
buf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

74 (
gí
: => 
TLInw¨dNode
): 
NoH™dÀ
 = {

75 
	`to
("tûe" 
«med
 
«me
Ë{ 
FlùRídîög
 { 
im∂icô
 
p
 =>

76 
gí
 :*
	`TLBuf„r
(
buf„r
Ë:*
outw¨dNode


80 
def
 
	`toSœveBus
(
«me
: 
Såög
): (=> 
TLInw¨dNode
Ë=> 
NoH™dÀ
 =

81 
gí
 => 
	`to
(
s
"bus_named_$name") {

82 (
gí


83 :*
	`TLWidthWidgë
(
∑øms
.
bótByãs
)

84 :*
outw¨dNode
)

86 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Ports.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	gaxi4
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


13 
˛ass
 
	$Ma°îP‹tP¨ams
(

14 
ba£
: 
BigI¡
,

15 
size
: 
BigI¡
,

16 
bótByãs
: 
I¡
,

17 
idBôs
: 
I¡
,

18 
maxX„rByãs
: 
I¡
 = 256,

19 
execuèbÀ
: 
Boﬁón
 = 
åue
)

22 
˛ass
 
	$SœveP‹tP¨ams
(
bótByãs
: 
I¡
, 
idBôs
: I¡, 
sour˚Bôs
: Int)

23 
˛ass
 
	$Mem‹yP‹tP¨ams
(
ma°î
: 
Ma°îP‹tP¨ams
, 
nMem‹yCh™√ls
: 
I¡
)

25 
obje˘
 
ExtMem
 
exãnds
 
Fõld
[
O±i⁄
[
Mem‹yP‹tP¨ams
]](
N⁄e
)

26 
obje˘
 
ExtBus
 
exãnds
 
Fõld
[
O±i⁄
[
Ma°îP‹tP¨ams
]](
N⁄e
)

27 
obje˘
 
ExtIn
 
exãnds
 
Fõld
[
O±i⁄
[
SœveP‹tP¨ams
]](
N⁄e
)

32 
åaô
 
C™HaveMa°îAXI4MemP‹t
 { 
this
: 
Ba£Subsy°em
 =>

33 
vÆ
 
moduÀ
: 
C™HaveMa°îAXI4MemP‹tModuÀImp


35 
vÆ
 
memAXI4Node
 = 
	`p
(
ExtMem
).
m≠
 { 
	`Mem‹yP‹tP¨ams
(
memP‹tP¨ams
, 
nMem‹yCh™√ls
) =>

36 
vÆ
 
p‹tName
 = "axi4"

37 
vÆ
 
devi˚
 = 
√w
 
Mem‹yDevi˚


39 
vÆ
 
memAXI4Node
 = 
	`AXI4SœveNode
(
Seq
.
	`èbuœã
(
nMem‹yCh™√ls
Ë{ 
ch™√l
 =>

40 
vÆ
 
ba£
 = 
	`AddªssSë
(
memP‹tP¨ams
.ba£, memP‹tP¨ams.
size
-1)

41 
vÆ
 
fûãr
 = 
	`AddªssSë
(
ch™√l
 * 
ˇcheBlockByãs
, ~((
nMem‹yCh™√ls
-1) * cacheBlockBytes))

43 
	`AXI4SœveP‹tP¨amëîs
(

44 
¶aves
 = 
	`Seq
(
	`AXI4SœveP¨amëîs
(

45 
addªss
 = 
ba£
.
	`öãr£˘
(
fûãr
).
toLi°
,

46 
ªsour˚s
 = 
devi˚
.
ªg
,

47 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

48 
execuèbÀ
 = 
åue
,

49 
suµ‹tsWrôe
 = 
	`Tøns„rSizes
(1, 
ˇcheBlockByãs
),

50 
suµ‹tsRód
 = 
	`Tøns„rSizes
(1, 
ˇcheBlockByãs
),

51 
öãæóvedId
 = 
	`Some
(0))),

52 
bótByãs
 = 
memP‹tP¨ams
.beatBytes)

55 
memAXI4Node
 :
mbus
.
	`toDRAMC⁄åﬁÀr
(
	`Some
(
p‹tName
)) {

56 
	`AXI4U£rY™kî
(Ë:
	`AXI4IdIndexî
(
memP‹tP¨ams
.
idBôs
Ë:
	`TLToAXI4
()

59 
memAXI4Node


61 
	}
}

64 
åaô
 
C™HaveMa°îAXI4MemP‹tModuÀImp
 
exãnds
 
LazyModuÀImp
 {

65 
vÆ
 
ouãr
: 
C™HaveMa°îAXI4MemP‹t


67 
vÆ
 
mem_axi4
 = 
ouãr
.
memAXI4Node
.
m≠
(
x
 => 
IO
(
HëîogíeousBag
.
‰omNode
(x.
ö
)))

68 (
mem_axi4
 
zù
 
ouãr
.
memAXI4Node
Ë
f‹óch
 { (
io
, 
node
) =>

69 (
io
 
zù
 
node
.
ö
).
f‹óch
 { (io, (
bundÀ
, 
_
)) => io <> bundle }

72 
def
 
c⁄√˘SimAXIMem
() {

73 (
mem_axi4
 
zù
 
	gouãr
.
	gmemAXI4Node
).
	gf‹óch
 { (
	gio
, 
	gnode
) =>

74 (
io
 
zù
 
node
.
ö
).
f‹óch
 { (io, (
_
, 
edge
)) =>

75 
vÆ
 
mem
 = 
LazyModuÀ
(
√w
 
SimAXIMem
(
edge
, 
size
 = 
p
(
ExtMem
).
gë
.
ma°î
.size))

76 
ModuÀ
(
mem
.
moduÀ
).
io
.
axi4
.
hód
 <> io

83 
åaô
 
	gC™HaveMa°îAXI4MMIOP‹t
 { 
	gthis
: 
Ba£Subsy°em
 =>

84 
¥iv©e
 
vÆ
 
mmioP‹tP¨amsO±
 = 
p
(
ExtBus
)

85 
¥iv©e
 
vÆ
 
p‹tName
 = "mmio_port_axi4"

86 
¥iv©e
 
vÆ
 
devi˚
 = 
√w
 
Sim∂eBus
(
p‹tName
.
kebab
, 
Nû
)

88 
vÆ
 
	gmmioAXI4Node
 = 
AXI4SœveNode
(

89 
mmioP‹tP¨amsO±
.
m≠
(
∑øms
 =>

90 
AXI4SœveP‹tP¨amëîs
(

91 
¶aves
 = 
Seq
(
AXI4SœveP¨amëîs
(

92 
addªss
 = 
AddªssSë
.
mißlig√d
(
∑øms
.
ba£
,Ö¨ams.
size
),

93 
ªsour˚s
 = 
devi˚
.
ønges
,

94 
execuèbÀ
 = 
∑øms
.executable,

95 
suµ‹tsWrôe
 = 
Tøns„rSizes
(1, 
∑øms
.
maxX„rByãs
),

96 
suµ‹tsRód
 = 
Tøns„rSizes
(1, 
∑øms
.
maxX„rByãs
))),

97 
bótByãs
 = 
∑øms
.bótByãs)).
toSeq
)

99 
mmioP‹tP¨amsO±
.
m≠
 { 
∑øms
 =>

100 
mmioAXI4Node
 :
sbus
.
toFixedWidthP‹t
(
Some
(
p‹tName
)) {

101 (
AXI4Buf„r
()

102 :
AXI4U£rY™kî
()

103 :
AXI4Deöãæóvî
(
sbus
.
blockByãs
)

104 :
AXI4IdIndexî
(
∑øms
.
idBôs
)

105 :
TLToAXI4
())

111 
åaô
 
C™HaveMa°îAXI4MMIOP‹tModuÀImp
 
exãnds
 
LazyModuÀImp
 {

112 
vÆ
 
ouãr
: 
C™HaveMa°îAXI4MMIOP‹t


113 
vÆ
 
mmio_axi4
 = 
IO
(
HëîogíeousBag
.
‰omNode
(
ouãr
.
mmioAXI4Node
.
ö
))

115 (
mmio_axi4
 
zù
 
ouãr
.
mmioAXI4Node
.
ö
Ë
f‹óch
 { (
io
, (
bundÀ
, 
_
)) => io <> bundle }

117 
def
 
c⁄√˘SimAXIMMIO
() {

118 (
mmio_axi4
 
zù
 
	gouãr
.
	gmmioAXI4Node
.
	gö
Ë
	gf‹óch
 { (
	gio
, (
	g_
, 
	gedge
)) =>

119 
vÆ
 
mmio_mem
 = 
LazyModuÀ
(
√w
 
SimAXIMem
(
edge
, 
size
 = 4096))

120 
ModuÀ
(
mmio_mem
.
moduÀ
).
io
.
axi4
.
hód
 <> io

126 
åaô
 
	gC™HaveSœveAXI4P‹t
 { 
	gthis
: 
Ba£Subsy°em
 =>

127 
¥iv©e
 
vÆ
 
¶aveP‹tP¨amsO±
 = 
p
(
ExtIn
)

128 
¥iv©e
 
vÆ
 
p‹tName
 = "slave_port_axi4"

129 
¥iv©e
 
vÆ
 
fifoBôs
 = 1

131 
vÆ
 
l2Fr⁄ãndAXI4Node
 = 
AXI4Ma°îNode
(

132 
¶aveP‹tP¨amsO±
.
m≠
(
∑øms
 =>

133 
AXI4Ma°îP‹tP¨amëîs
(

134 
ma°îs
 = 
Seq
(
AXI4Ma°îP¨amëîs
(

135 
«me
 = 
p‹tName
.
kebab
,

136 
id
 = 
IdR™ge
(0, 1 << 
∑øms
.
idBôs
))))).
toSeq
)

138 
	g¶aveP‹tP¨amsO±
.
	gm≠
 { 
	g∑øms
 =>

139 
fbus
.
‰omP‹t
(
Some
(
p‹tName
), 
buf„r
 = 
Buf„rP¨ams
.) {

140 (
TLWidthWidgë
(
∑øms
.
bótByãs
)

141 :
AXI4ToTL
()

142 :
AXI4U£rY™kî
(
Some
(1 << (
∑øms
.
sour˚Bôs
 - 
fifoBôs
 - 1)))

143 :
AXI4Føgmíãr
()

144 :
AXI4IdIndexî
(
fifoBôs
))

145 } :
l2Fr⁄ãndAXI4Node


150 
åaô
 
C™HaveSœveAXI4P‹tModuÀImp
 
exãnds
 
LazyModuÀImp
 {

151 
vÆ
 
ouãr
: 
C™HaveSœveAXI4P‹t


152 
vÆ
 
l2_‰⁄ãnd_bus_axi4
 = 
IO
(
HëîogíeousBag
.
‰omNode
(
ouãr
.
l2Fr⁄ãndAXI4Node
.
out
).
Êù
)

153 (
ouãr
.
l2Fr⁄ãndAXI4Node
.
out
 
zù
 
l2_‰⁄ãnd_bus_axi4
Ë
f‹óch
 { ((
bundÀ
, 
_
), 
io
) => bundle <> io }

157 
åaô
 
	gC™HaveMa°îTLMMIOP‹t
 { 
	gthis
: 
Ba£Subsy°em
 =>

158 
¥iv©e
 
vÆ
 
mmioP‹tP¨amsO±
 = 
p
(
ExtBus
)

159 
¥iv©e
 
vÆ
 
p‹tName
 = "mmio_port_tl"

160 
¥iv©e
 
vÆ
 
devi˚
 = 
√w
 
Sim∂eBus
(
p‹tName
.
kebab
, 
Nû
)

162 
vÆ
 
	gmmioTLNode
 = 
TLM™agîNode
(

163 
mmioP‹tP¨amsO±
.
m≠
(
∑øms
 =>

164 
TLM™agîP‹tP¨amëîs
(

165 
m™agîs
 = 
Seq
(
TLM™agîP¨amëîs
(

166 
addªss
 = 
AddªssSë
.
mißlig√d
(
∑øms
.
ba£
,Ö¨ams.
size
),

167 
ªsour˚s
 = 
devi˚
.
ønges
,

168 
execuèbÀ
 = 
∑øms
.executable,

169 
suµ‹tsGë
 = 
Tøns„rSizes
(1, 
sbus
.
blockByãs
),

170 
suµ‹tsPutFuŒ
 = 
Tøns„rSizes
(1, 
sbus
.
blockByãs
),

171 
suµ‹tsPutP¨tül
 = 
Tøns„rSizes
(1, 
sbus
.
blockByãs
))),

172 
bótByãs
 = 
∑øms
.bótByãs)).
toSeq
)

174 
mmioP‹tP¨amsO±
.
m≠
 { 
∑øms
 =>

175 
mmioTLNode
 :
sbus
.
toFixedWidthP‹t
(
Some
(
p‹tName
)) {

176 
TLBuf„r
(Ë:
TLSour˚Shrökî
(1 << 
∑øms
.
idBôs
)

183 
åaô
 
C™HaveMa°îTLMMIOP‹tModuÀImp
 
exãnds
 
LazyModuÀImp
 {

184 
vÆ
 
ouãr
: 
C™HaveMa°îTLMMIOP‹t


185 
vÆ
 
mmio_é
 = 
IO
(
HëîogíeousBag
.
‰omNode
(
ouãr
.
mmioTLNode
.
ö
))

186 (
mmio_é
 
zù
 
ouãr
.
mmioTLNode
.
ö
Ë
f‹óch
 { (
io
, (
bundÀ
, 
_
)) => io <> bundle }

192 
åaô
 
	gC™HaveSœveTLP‹t
 { 
	gthis
: 
Ba£Subsy°em
 =>

193 
¥iv©e
 
vÆ
 
¶aveP‹tP¨amsO±
 = 
p
(
ExtIn
)

194 
¥iv©e
 
vÆ
 
p‹tName
 = "slave_port_tl"

196 
vÆ
 
l2Fr⁄ãndTLNode
 = 
TLClõ¡Node
(

197 
¶aveP‹tP¨amsO±
.
m≠
(
∑øms
 =>

198 
TLClõ¡P‹tP¨amëîs
(

199 
˛õ¡s
 = 
Seq
(
TLClõ¡P¨amëîs
(

200 
«me
 = 
p‹tName
.
kebab
,

201 
sour˚Id
 = 
IdR™ge
(0, 1 << 
∑øms
.
idBôs
))))).
toSeq
)

203 
	g¶aveP‹tP¨amsO±
.
	gm≠
 { 
	g∑øms
 =>

204 
sbus
.
‰omP‹t
(
Some
(
p‹tName
)) {

205 
TLSour˚Shrökî
(1 << 
∑øms
.
sour˚Bôs
Ë:
TLWidthWidgë
’¨ams.
bótByãs
)

206 } :
l2Fr⁄ãndTLNode


211 
åaô
 
C™HaveSœveTLP‹tModuÀImp
 
exãnds
 
LazyModuÀImp
 {

212 
vÆ
 
ouãr
: 
C™HaveSœveTLP‹t


213 
vÆ
 
l2_‰⁄ãnd_bus_é
 = 
IO
(
HëîogíeousBag
.
‰omNode
(
ouãr
.
l2Fr⁄ãndTLNode
.
out
).
Êù
)

214 (
ouãr
.
l2Fr⁄ãndTLNode
.
out
 
zù
 
l2_‰⁄ãnd_bus_é
Ë
f‹óch
 { ((
bundÀ
, 
_
), 
io
) => bundle <> io }

218 
˛ass
 
	$SimAXIMem
(
edge
: 
AXI4EdgeP¨amëîs
, 
size
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

219 
vÆ
 
node
 = 
	`AXI4Ma°îNode
(
	`Li°
(
edge
.
ma°î
))

221 
vÆ
 
§am
 = 
	`LazyModuÀ
(
√w
 
	`AXI4RAM
(
	`AddªssSë
(0, 
size
-1), 
bótByãs
 = 
edge
.
bundÀ
.
d©aBôs
/8))

222 
§am
.
node
 :
	`AXI4Buf„r
(Ë:
	`AXI4Føgmíãr
() :=Çode

224 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

225 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 { vÆ 
axi4
 = 
HëîogíeousBag
.
	`‰omNode
(
node
.
out
).
Êù
 })

226 (
node
.
out
 
zù
 
io
.
axi4
Ë
f‹óch
 { ((
bundÀ
, 
_
), io) => bundle <> io }

228 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RTC.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.{
	gLazyModuÀImp
, 
	gDTSTimeba£
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
C™HavePîùhîyCLINT


9 
åaô
 
HasRTCModuÀImp
 
exãnds
 
	gLazyModuÀImp
 {

10 
vÆ
 
	gouãr
: 
Ba£Subsy°em
 
wôh
 
C™HavePîùhîyCLINT


11 
¥iv©e
 
vÆ
 
pbusFªq
 = 
ouãr
.
p
(
PîùhîyBusKey
).
‰equícy


12 
¥iv©e
 
vÆ
 
πcFªq
 = 
ouãr
.
p
(
DTSTimeba£
)

13 
¥iv©e
 
vÆ
 
öã∫ÆPîiod
: 
BigI¡
 = 
pbusFªq
 / 
πcFªq


16 
ªquúe
(
öã∫ÆPîiod
 > 0)

18 
ªquúe
((
pbusFªq
 - 
πcFªq
 * 
öã∫ÆPîiod
) * 100 /ÖbusFreq <= 5)

21 
vÆ
 (
_
, 
öt_πc_tick
Ë
Cou¡î
(
åue
.
B
, 
öã∫ÆPîiod
.
toI¡
)

23 
	gouãr
.
	g˛ötO±
.
	gf‹óch
 { 
	g˛öt
 =>

24 
˛öt
.
moduÀ
.
io
.
πcTick
 :
öt_πc_tick


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/ResetVector.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


8 
åaô
 
	gHasRe£tVe˘‹Wúe
 {

9 
def
 
	gª£tVe˘‹Bôs
: 
I¡


10 
vÆ
 
globÆ_ª£t_ve˘‹
 = 
Wúe
(
UI¡
(
width
 = 
ª£tVe˘‹Bôs
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RocketSubsystem.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.{
	gHasPîùhîyDebug
, 
	gHasPîùhîyDebugModuÀImp
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


17 
˛ass
 
	$TûeMa°îP‹tP¨ams
(
buf„rs
: 
I¡
 = 0, 
c‹k
: 
O±i⁄
[
Boﬁón
] = 
N⁄e
)

18 
˛ass
 
	$TûeSœveP‹tP¨ams
(
buf„rs
: 
I¡
 = 0, 
blockîCålAddr
: 
O±i⁄
[
BigI¡
] = 
N⁄e
)

20 
˛ass
 
	`RockëCrossögP¨ams
(

21 
¸ossögTy≥
: 
ClockCrossögTy≥
 = 
	`Synchr⁄ousCrossög
(),

22 
ma°î
: 
TûeMa°îP‹tP¨ams
 = 
	`TûeMa°îP‹tP¨ams
(),

23 
¶ave
: 
TûeSœveP‹tP¨ams
 = 
	$TûeSœveP‹tP¨ams
()) {

24 
def
 
knownR©io
: 
O±i⁄
[
I¡
] = 
¸ossögTy≥
 
m©ch
 {

25 
	`R©i⁄ÆCrossög
(
_
Ë=> 
	`Some
(2)

26 
_
 => 
N⁄e


28 
	}
}

30 
obje˘
 
RockëTûesKey
 
exãnds
 
Fõld
[
Seq
[
RockëTûeP¨ams
]](
Nû
)

31 
obje˘
 
RockëCrossögKey
 
exãnds
 
Fõld
[
Seq
[
RockëCrossögP¨ams
]](
Li°
(
	$RockëCrossögP¨ams
()))

33 
åaô
 
HasRockëTûes
 
exãnds
 
HasTûes


34 
wôh
 
C™HavePîùhîyPLIC


35 
wôh
 
C™HavePîùhîyCLINT


36 
wôh
 
HasPîùhîyDebug
 { 
this
: 
Ba£Subsy°em
 =>

37 
vÆ
 
moduÀ
: 
HasRockëTûesModuÀImp


39 
¥Ÿe˘ed
 
vÆ
 
rockëTûeP¨ams
 = 
	`p
(
RockëTûesKey
)

40 
¥iv©e
 
vÆ
 
¸ossögs
 = 
	`≥rTûeOrGlobÆSëtög
(
	`p
(
RockëCrossögKey
), 
rockëTûeP¨ams
.
size
)

46 
vÆ
 
rockëTûes
 = 
rockëTûeP¨ams
.
	`zù
(
¸ossögs
).
m≠
 { (
ç
, 
¸ossög
) =>

47 
vÆ
 
rockë
 = 
	`LazyModuÀ
(
√w
 
	`RockëTûe
(
ç
, 
¸ossög
.
¸ossögTy≥
)(
	`augmíãdTûeP¨amëîs
(tp)))

48 .
	`sugge°Name
(
ç
.
«me
)

50 
	`c⁄√˘Ma°îP‹tsToSBus
(
rockë
, 
¸ossög
)

51 
	`c⁄√˘SœveP‹tsToCBus
(
rockë
, 
¸ossög
)

52 
	`c⁄√˘I¡îru±s
(
rockë
, 
	`Some
(
debug
), 
˛ötO±
, 
∂icO±
)

54 
rockë


56 
	}
}

58 
åaô
 
HasRockëTûesModuÀImp
 
exãnds
 
HasTûesModuÀImp


59 
wôh
 
	gHasPîùhîyDebugModuÀImp
 {

60 
vÆ
 
	gouãr
: 
HasRockëTûes


63 ˛as†
	cRockëSubsy°em
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
Ba£Subsy°em


64 
wôh
 
HasRockëTûes
 {

65 
vÆ
 
tûes
 = 
rockëTûes


66 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`RockëSubsy°emModuÀImp
(
this
)

69 
˛ass
 
RockëSubsy°emModuÀImp
[+
L
 <: 
RockëSubsy°em
](
_ouãr
: LË
exãnds
 
	$Ba£Subsy°emModuÀImp
(
_ouãr
)

70 
wôh
 
HasRockëTûesModuÀImp
 {

71 
tûe_öputs
.
	`zù
(
ouãr
.
h¨tIdLi°
).
f‹óch
 { (
wúe
, 
i
) =>

72 
wúe
.
˛ock
 := clock

73 
wúe
.
ª£t
 :=Ñeset

74 
wúe
.
h¨tid
 :
	`UI¡
(
i
)

75 
wúe
.
ª£t_ve˘‹
 :
globÆ_ª£t_ve˘‹


77 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/SystemBus.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
subsy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.{
	gDevNuŒP¨ams
, 
	gTLEº‹
, 
	gTLZîo
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
˛ass
 
Sy°emBusP¨ams
(

13 
bótByãs
: 
I¡
,

14 
blockByãs
: 
I¡
,

15 
©omics
: 
O±i⁄
[
BusAtomics
] = 
Some
(BusAtomics()),

16 
pbusBuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
,

17 
pﬁicy
: 
TLArbôî
.
Pﬁicy
 = TLArbôî.
roundRobö
,

18 
îr‹Devi˚
: 
O±i⁄
[
DevNuŒP¨ams
] = 
N⁄e
Ë
exãnds
 
HasTLBusP¨ams


20 
obje˘
 
Sy°emBusKey
 
exãnds
 
Fõld
[
Sy°emBusP¨ams
]

22 
˛ass
 
	$Sy°emBus
(
∑øms
: 
Sy°emBusP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
)

23 
exãnds
 
	`TLBusWøµî
(
∑øms
, "system_bus")

24 
wôh
 
C™AâachTLSœves


25 
wôh
 
C™AâachTLMa°îs


26 
wôh
 
HasTLXb¨Phy
 {

28 
vÆ
 
cbus_∑øms
 = 
√w
 
	`PîùhîyBusP¨ams
(

29 
	`p
(
PîùhîyBusKey
).
bótByãs
,

30 
∑øms
.
blockByãs
,

31 
∑øms
.
©omics
,

32 
NoCrossög
)

33 
vÆ
 
c⁄åﬁ_bus
 = 
	`LazyModuÀ
(
√w
 
	`PîùhîyBus
(
cbus_∑øms
))

34 
c⁄åﬁ_bus
.
¸ossFromSy°emBus
 { 
this
.
	`toSœveBus
("cbus") }

36 
¥iv©e
 
vÆ
 
ma°î_•lôãr
 = 
	`LazyModuÀ
(
√w
 
TLS∂ôãr
)

37 
öw¨dNode
 :=* 
ma°î_•lôãr
.
node


39 
∑øms
.
îr‹Devi˚
.
f‹óch
 { 
d≈
 => 
	`LazySc›e
("wrapped_error_device") {

40 
vÆ
 
îr‹
 = 
	`LazyModuÀ
(
√w
 
	`TLEº‹
(
∑øms
 = 
d≈
, 
bótByãs
 =Öarams.beatBytes))

41 
îr‹
.
node
 :
	`TLBuf„r
(Ë:
outw¨dNode


43 
def
 
busVõw
 = 
ma°î_•lôãr
.
node
.
edges
.
ö
.
hód


45 
def
 
	`toSœveBus
(
«me
: 
Såög
): (=> 
TLInw¨dNode
Ë=> 
NoH™dÀ
 =

46 
gí
 => 
	`to
(
s
"bus_named_$name") {

47 (
gí


48 :*
	`TLFIFOFixî
(
TLFIFOFixî
.
Æl
)

49 :*
	`TLWidthWidgë
(
∑øms
.
bótByãs
)

50 :*
	`TLBuf„r
(
∑øms
.
pbusBuf„r
)

51 :*
outw¨dNode
)

54 
def
 
	`‰omMa°îBus
(
«me
: 
Såög
): (=> 
TLOutw¨dNode
Ë=> 
NoH™dÀ
 =

55 
gí
 => 
	`‰om
(
s
"bus_«med_$«me"Ë{ 
ma°î_•lôãr
.
node
 :=* gen }

57 
def
 
toS∂ôSœve
[
D
,
U
,
E
,
B
 <: 
D©a
]

58 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
)

59 (
gí
: => 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
,
D
,
U
,
E
,
B
] =

60 
	`TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

61 
	`to
("¶ave" 
«med
 
«me
Ë{ 
gí
 :=* 
ma°î_•lôãr
.
node
 }

64 
def
 
‰omTûe


65 (
«me
: 
O±i⁄
[
Såög
], 
buf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
, 
c‹k
: O±i⁄[
Boﬁón
] = 
N⁄e
)

66 (
gí
: => 
TLOutw¨dNode
): 
NoH™dÀ
 = {

67 
	`‰om
("tûe" 
«med
 
«me
) {

68 
ma°î_•lôãr
.
node
 :=* 
	`TLBuf„r
(
buf„r
Ë:=* 
	`TLFIFOFixî
(
TLFIFOFixî
.
ÆlUnˇchóbÀ
Ë:=* 
gí


71 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Configs.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
sy°em


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
C⁄fig


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.{
	gIn˛udeJègDTM
, 
	gJègDTMKey
}

10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


12 
˛ass
 
WôhJègDTMSy°em
 
exãnds
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
WôhJègDTM


13 
˛ass
 
WôhDebugSBASy°em
 
exãnds
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
WôhDebugSBA


15 
˛ass
 
Ba£C⁄fig
 
exãnds
 
C⁄fig
(

16 
√w
 
WôhDeÁu…MemP‹t
() ++

17 
√w
 
WôhDeÁu…MMIOP‹t
() ++

18 
√w
 
WôhDeÁu…SœveP‹t
() ++

19 
√w
 
WôhTimeba£
(
BigI¡
(1000000)) ++

20 
√w
 
WôhDTS
("‰ìchùs,rockëchù-unknown", 
Nû
) ++

21 
√w
 
WôhNExtT›I¡îru±s
(2) ++

22 
√w
 
	$Ba£Subsy°emC⁄fig
()

25 
˛ass
 
DeÁu…C⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNBigC‹es
(4Ë++Çew 
Ba£C⁄fig
)

26 
˛ass
 
DeÁu…PCLC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
WôhPrivCodeLock
 ++Çew 
DeÁu…C⁄fig
)

27 
˛ass
 
DeÁu…PCL1C⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
WôhPrivCodeLock1
 ++Çew 
DeÁu…C⁄fig
)

28 
˛ass
 
DeÁu…PCL2C⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
WôhPrivCodeLock2
 ++Çew 
DeÁu…C⁄fig
)

29 
˛ass
 
DeÁu…PCL3C⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
WôhPrivCodeLock3
 ++Çew 
DeÁu…C⁄fig
)

31 
˛ass
 
DeÁu…Buf„æessC⁄fig
 
exãnds
 
	`C⁄fig
(

32 
√w
 
WôhBuf„æessBrﬂdˇ°Hub
 ++Çew 
	`WôhNBigC‹es
(1Ë++Çew 
Ba£C⁄fig
)

34 
˛ass
 
DeÁu…SmÆlC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNSmÆlC‹es
(1Ë++Çew 
Ba£C⁄fig
)

35 
˛ass
 
DeÁu…RV32C⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
WôhRV32
 ++Çew 
DeÁu…C⁄fig
)

37 
˛ass
 
DuÆB™kC⁄fig
 
exãnds
 
	`C⁄fig
(

38 
√w
 
	`WôhNB™ks
(2Ë++Çew 
Ba£C⁄fig
)

40 
˛ass
 
DuÆCh™√lC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNMem‹yCh™√ls
(2Ë++Çew 
Ba£C⁄fig
)

42 
˛ass
 
DuÆCh™√lDuÆB™kC⁄fig
 
exãnds
 
	`C⁄fig
(

43 
√w
 
	`WôhNMem‹yCh™√ls
(2) ++

44 
√w
 
	`WôhNB™ks
(4Ë++Çew 
Ba£C⁄fig
)

46 
˛ass
 
RoccExam∂eC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
WôhRoccExam∂e
 ++Çew 
DeÁu…C⁄fig
)

48 
˛ass
 
Edge128BôC⁄fig
 
exãnds
 
	`C⁄fig
(

49 
√w
 
	`WôhEdgeD©aBôs
(128Ë++Çew 
Ba£C⁄fig
)

50 
˛ass
 
Edge32BôC⁄fig
 
exãnds
 
	`C⁄fig
(

51 
√w
 
	`WôhEdgeD©aBôs
(32Ë++Çew 
Ba£C⁄fig
)

53 
˛ass
 
SögÀCh™√lBíchm¨kC⁄fig
 
exãnds
 
	$C⁄fig
(
√w
 
DeÁu…C⁄fig
)

54 
˛ass
 
DuÆCh™√lBíchm¨kC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNMem‹yCh™√ls
(2Ë++Çew 
SögÀCh™√lBíchm¨kC⁄fig
)

55 
˛ass
 
QuadCh™√lBíchm¨kC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNMem‹yCh™√ls
(4Ë++Çew 
SögÀCh™√lBíchm¨kC⁄fig
)

56 
˛ass
 
O˘oCh™√lBíchm¨kC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNMem‹yCh™√ls
(8Ë++Çew 
SögÀCh™√lBíchm¨kC⁄fig
)

58 
˛ass
 
EightCh™√lC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNMem‹yCh™√ls
(8Ë++Çew 
Ba£C⁄fig
)

60 
˛ass
 
DuÆC‹eC⁄fig
 
exãnds
 
	`C⁄fig
(

61 
√w
 
	`WôhNBigC‹es
(2Ë++Çew 
Ba£C⁄fig
)

63 
˛ass
 
TöyC⁄fig
 
exãnds
 
	`C⁄fig
(

64 
√w
 
WôhNoMemP‹t
 ++

65 
√w
 
	`WôhNMem‹yCh™√ls
(0) ++

66 
√w
 
	`WôhNB™ks
(0) ++

67 
√w
 
Wôh1TöyC‹e
 ++

68 
√w
 
Ba£C⁄fig
)

70 
˛ass
 
MemP‹tO∆yC⁄fig
 
exãnds
 
	`C⁄fig
(

71 
√w
 
WôhNoMMIOP‹t
 ++

72 
√w
 
WôhNoSœveP‹t
 ++

73 
√w
 
DeÁu…C⁄fig


76 
˛ass
 
MMIOP‹tO∆yC⁄fig
 
exãnds
 
	`C⁄fig
(

77 
√w
 
WôhNoSœveP‹t
 ++

78 
√w
 
WôhNoMemP‹t
 ++

79 
√w
 
	`WôhNMem‹yCh™√ls
(0) ++

80 
√w
 
	`WôhNB™ks
(0) ++

81 
√w
 
WôhIncohîítTûes
 ++

82 
√w
 
WôhS¸©ch∑dsO∆y
 ++

83 
√w
 
DeÁu…C⁄fig


86 
˛ass
 
Ba£FPGAC⁄fig
 
exãnds
 
	$C⁄fig
(
√w
 
Ba£C⁄fig
)

88 
˛ass
 
DeÁu…FPGAC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
	`WôhNSmÆlC‹es
(1Ë++Çew 
Ba£FPGAC⁄fig
)

89 
˛ass
 
DeÁu…FPGASmÆlC⁄fig
 
exãnds
 
	`C⁄fig
(
√w
 
DeÁu…FPGAC⁄fig
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/ExampleRocketSystem.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
sy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
D⁄tTouch


14 ˛as†
	cExam∂eRockëSy°em
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
RockëSubsy°em


15 
wôh
 
HasAsyncExtI¡îru±s


16 
wôh
 
C™HaveMa°îAXI4MemP‹t


17 
wôh
 
C™HaveMa°îAXI4MMIOP‹t


18 
wôh
 
C™HaveSœveAXI4P‹t


19 
wôh
 
HasPîùhîyBoŸROM
 {

20 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`Exam∂eRockëSy°emModuÀImp
(
this
)

23 
˛ass
 
Exam∂eRockëSy°emModuÀImp
[+
L
 <: 
Exam∂eRockëSy°em
](
_ouãr
: LË
exãnds
 
	$RockëSubsy°emModuÀImp
(
_ouãr
)

24 
wôh
 
HasRTCModuÀImp


25 
wôh
 
HasExtI¡îru±sModuÀImp


26 
wôh
 
C™HaveMa°îAXI4MemP‹tModuÀImp


27 
wôh
 
C™HaveMa°îAXI4MMIOP‹tModuÀImp


28 
wôh
 
C™HaveSœveAXI4P‹tModuÀImp


29 
wôh
 
HasPîùhîyBoŸROMModuÀImp


30 
wôh
 
D⁄tTouch


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Generator.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
sy°em


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
RockëTûesKey


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûe
.
XLí


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
Gíî©‹Aµ


9 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
LökedHashSë


12 
obje˘
 
Gíî©‹
 
exãnds
 
	gGíî©‹Aµ
 {

14 
vÆ
 
	grv64RegrTe°Names
 = 
LökedHashSë
(

41 
vÆ
 
	grv32RegrTe°Names
 = 
LökedHashSë
(

50 
ovîride
 
def
 
	gaddTe°Suôes
 {

51 
imp‹t
 
	gDeÁu…Te°Suôes
.
_


52 
vÆ
 
	gxÀn
 = 
∑øms
(
XLí
)

54 
vÆ
 
tûeP¨ams
 = 
∑øms
(
RockëTûesKey
).
hód


55 
vÆ
 
c‹eP¨ams
 = 
tûeP¨ams
.
c‹e


56 
vÆ
 
vm
 = 
c‹eP¨ams
.
u£VM


57 
vÆ
 
ív
 = i‡(
vm
Ë
Li°
("p","v") List("p")

58 
	gc‹eP¨ams
.
Âu
 
	gf‹óch
 { 
	gcfg
 =>

59 i‡(
xÀn
 == 32) {

60 
Te°Gíî©i⁄
.
addSuôes
(
ív
.
m≠
(
rv32uf
))

61 i‡(
cfg
.
fLí
 >= 64)

62 
Te°Gíî©i⁄
.
addSuôes
(
ív
.
m≠
(
rv32ud
))

64 
	gTe°Gíî©i⁄
.
addSuôe
(
rv32udBíchm¨ks
)

65 
	gTe°Gíî©i⁄
.
addSuôes
(
ív
.
m≠
(
rv64uf
))

66 i‡(
	gcfg
.
	gfLí
 >= 64)

67 
Te°Gíî©i⁄
.
addSuôes
(
ív
.
m≠
(
rv64ud
))

70 i‡(
	gc‹eP¨ams
.
	gu£Atomics
) {

71 i‡(
	gtûeP¨ams
.
	gdˇche
.
Ê©M≠
(
_
.
s¸©ch
).
	gisEm±y
)

72 
	gTe°Gíî©i⁄
.
addSuôes
(
ív
.
m≠
(i‡(
xÀn
 =64Ë
rv64ua
 
rv32ua
))

74 
Te°Gíî©i⁄
.
addSuôes
(
ív
.
m≠
(i‡(
xÀn
 =64Ë
rv64uaS™sLRSC
 
rv32uaS™sLRSC
))

76 i‡(
	gc‹eP¨ams
.
	gu£Com¥es£d
Ë
	gTe°Gíî©i⁄
.
addSuôes
(
ív
.
m≠
(i‡(
xÀn
 =64Ë
rv64uc
 
rv32uc
))

77 
vÆ
 (
rvi
, 
rvu
) =

78 i‡(
xÀn
 =64Ë((i‡(
vm
Ë
rv64i
 
rv64pi
), 
	grv64u
)

79 ((i‡(
	gvm
Ë
rv32i
 
	grv32pi
), 
	grv32u
)

81 
	gTe°Gíî©i⁄
.
addSuôes
(
rvi
.
m≠
(
_
("p")))

82 
	gTe°Gíî©i⁄
.
addSuôes
((i‡(
vm
Ë
Li°
("v"ËLi°()).
Ê©M≠
(
ív
 => 
rvu
.
m≠
(
_
(env))))

83 
Te°Gíî©i⁄
.
addSuôe
(
bíchm¨ks
)

84 
Te°Gíî©i⁄
.
addSuôe
(
√w
 
Regªssi⁄Te°Suôe
(i‡(
xÀn
 =64Ë
rv64RegrTe°Names
 
rv32RegrTe°Names
))

87 
vÆ
 
	gl⁄gName
 = 
«mes
.
c⁄figProje˘
 + "." +Çames.
c⁄figs


88 
gíî©eFúπl


89 
gíî©eA¬o


90 
gíî©eTe°SuôeMake‰ags


91 
gíî©eROMs


92 
gíî©eAπeÁ˘s


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/RocketTestSuite.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
sy°em


6 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
LökedHashSë


8 
ab°ø˘
 cœs†
	cRockëTe°Suôe
 {

9 
vÆ
 
	mdú
: 
Såög


10 
vÆ
 
makeT¨gëName
: 
Såög


11 
vÆ
 
«mes
: 
LökedHashSë
[
Såög
]

12 
vÆ
 
ívName
: 
Såög


13 
def
 
köd
: 
Såög


14 
def
 
po°S¸ùt
 = 
s
"""

16 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .
hex
, 
	$$$
(
$makeT¨gëName
))): 
	`$$
(
ouçut_dú
)/%.
hex
: 
$dú
/%.hex

17 \
tmkdú
 -
p
 
	`$$
(
ouçut_dú
)

18 \
én
 -
fs
 
$$
< $$@

20 
	`$$
(
add¥efix
 $$(
ouçut_dú
)/, 
	$$$
(
$makeT¨gëName
)): 
	`$$
(
ouçut_dú
)/%: 
$dú
/%

21 \
tmkdú
 -
p
 
	`$$
(
ouçut_dú
)

22 \
én
 -
fs
 
$$
< $$@

24 
run
-
$makeT¨gëName
: 
	`$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .
out
, $$($makeTargetName)))

25 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
^ /
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

27 
run
-
$makeT¨gëName
-
debug
: 
	`$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .
vpd
, $$($makeTargetName)))

28 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
	`$$
(
∑tsub°
 %.
vpd
,%.
out
,
$$
^Ë/
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

30 
run
-
$makeT¨gëName
-
f°
: 
	`$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .fst, $$($makeTargetName)))

31 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
	`$$
(
∑tsub°
 %.
f°
,%.
out
,
$$
^Ë/
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

35 
˛ass
 
	$As£mblyTe°Suôe
(
¥efix
: 
Såög
, 
vÆ
 
«mes
: 
LökedHashSë
[Såög])(vÆ 
ívName
: SåögË
exãnds
 
RockëTe°Suôe
 {

36 
vÆ
 
dú
 = "$(RISCV)/riscv64-unknown-elf/share/riscv-tests/isa"

37 
vÆ
 
makeT¨gëName
 = 
¥efix
 + "-" + 
ívName
 + "-asm-tests"

38 
def
 
köd
 = "asm"

39 
ovîride
 
def
 
toSåög
 = 
s
"$makeT¨gëNamê\\\n" + 
«mes
.
	`m≠
(
n
 => s"\t$¥efix-$ívName-$n").
	`mkSåög
(" \\\n"Ë+ 
po°S¸ùt


40 
	}
}

42 
˛ass
 
	$Bíchm¨kTe°Suôe
(
makePªfix
: 
Såög
, 
vÆ
 
dú
: Såög, vÆ 
«mes
: 
LökedHashSë
[Såög]Ë
exãnds
 
RockëTe°Suôe
 {

43 
vÆ
 
ívName
 = ""

44 
vÆ
 
makeT¨gëName
 = 
makePªfix
 + "-bmark-tests"

45 
def
 
köd
 = "bmark"

46 
ovîride
 
def
 
toSåög
 = 
s
"$makeT¨gëNamê\\\n" + 
«mes
.
	`m≠
(
n
 => s"\t$n.riscv").
	`mkSåög
(" \\\n"Ë+ 
po°S¸ùt


47 
	}
}

49 
˛ass
 
	$Regªssi⁄Te°Suôe
(
vÆ
 
«mes
: 
LökedHashSë
[
Såög
]Ë
exãnds
 
RockëTe°Suôe
 {

50 
vÆ
 
ívName
 = ""

51 
vÆ
 
dú
 = "$(RISCV)/riscv64-unknown-elf/share/riscv-tests/isa"

52 
vÆ
 
makeT¨gëName
 = "regression-tests"

53 
def
 
köd
 = "regression"

54 
ovîride
 
def
 
toSåög
 = 
s
"$makeT¨gëNamê\\\n" + 
«mes
.
	`mkSåög
(" \\\n")

55 
	}
}

57 
obje˘
 
Te°Gíî©i⁄
 {

58 
¥iv©e
 
vÆ
 
suôes
 = 
cﬁÀ˘i⁄
.
muèbÀ
.
Li°M≠
[
Såög
, 
RockëTe°Suôe
]()

60 
def
 
addSuôe
(
s
: 
RockëTe°Suôe
Ë{ 
suôes
 +(s.
makeT¨gëName
 -> s) }

62 
def
 
addSuôes
(
s
: 
Seq
[
RockëTe°Suôe
]Ë{ s.
f‹óch
(
addSuôe
) }

64 
def
 
gíî©eMake‰ag
: 
Såög
 = {

65 
def
 
gí
(
köd
: 
Såög
, 
s
: 
Seq
[
RockëTe°Suôe
]) = {

66 if(
s
.
Àngth
 > 0) {

67 
vÆ
 
ívs
 = 
s
.
groupBy
(
_
.
ívName
)

68 
vÆ
 
èrgës
 = 
s
.
m≠
(
t
 => s"$$(${t.makeT¨gëName})").
mkSåög
(" ")

69 
s
.
m≠
(
_
.
toSåög
).
mkSåög
("\n") +

70 
ívs
.
fûãrKeys
(
_
 !"").
m≠
( {

71 (
ív
,
ívsuôes
) => {

72 
vÆ
 
suôes
 = 
ívsuôes
.
m≠
(
t
 => 
s
"$$(${t.makeT¨gëName})").
mkSåög
(" ")

73 
s
"""

74 
run
-
$köd
-
$ív
-
ã°s
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .
out
, 
$suôes
))

75 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
^ /
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

76 
run
-
$köd
-
$ív
-
ã°s
-
debug
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .
vpd
, 
$suôes
))

77 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
(
∑tsub°
 %.
vpd
,%.
out
,$$^Ë/
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

78 
run
-
$köd
-
$ív
-
ã°s
-
f°
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .f°, 
$suôes
))

79 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
(
∑tsub°
 %.
f°
,%.
out
,$$^Ë/
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

80 
run
-
$köd
-
$ív
-
ã°s
-
Á°
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .run, 
$suôes
))

81 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
^ /
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

82 """} } ).mkSåög("\
n
") + s"""

83 
run
-
$köd
-
ã°s
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .
out
, 
$èrgës
))

84 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
^ /
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

85 
run
-
$köd
-
ã°s
-
debug
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .
vpd
, 
$èrgës
))

86 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
(
∑tsub°
 %.
vpd
,%.
out
,$$^Ë/
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

87 
run
-
$köd
-
ã°s
-
f°
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .f°, 
$èrgës
))

88 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
(
∑tsub°
 %.
f°
,%.
out
,$$^Ë/
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

89 
run
-
$köd
-
ã°s
-
Á°
: 
$$
(
add¥efix
 $$(
ouçut_dú
)/, $$(
addsuffix
 .run, 
$èrgës
))

90 \
t
@
echo
; 
≥æ
 -
√
 '¥öà" [$$$$1] $$$$ARGV \\t$$$$2\\n" if–/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/ò)' 
$$
^ /
dev
/
nuŒ
 |Öî»-
≥
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {Éxit($$$$failed) }'

95 
suôes
.
vÆues
.
toSeq
.
groupBy
(
_
.
köd
).
m≠
 { (köd, 
s
Ë=> 
gí
(köd, sË}.
mkSåög
("\n")

100 
obje˘
 
DeÁu…Te°Suôes
 {

101 
vÆ
 
rv32uiNames
 = 
LökedHashSë
(

105 
vÆ
 
rv32ui
 = 
√w
 
As£mblyTe°Suôe
("rv32ui", 
rv32uiNames
)(
_
)

107 
vÆ
 
rv32ucNames
 = 
LökedHashSë
("rvc")

108 
vÆ
 
rv32uc
 = 
√w
 
As£mblyTe°Suôe
("rv32uc", 
rv32ucNames
)(
_
)

110 
vÆ
 
rv32umNames
 = 
LökedHashSë
("mul", "mulh", "mulhsu", "mulhu", "div", "divu", "rem", "remu")

111 
vÆ
 
rv32um
 = 
√w
 
As£mblyTe°Suôe
("rv32um", 
rv32umNames
)(
_
)

113 
vÆ
 
rv32uaS™sLRSCNames
 = 
LökedHashSë
("amoadd_w", "amoand_w", "amoor_w", "amoxor_w", "amoswap_w", "amomax_w", "amomaxu_w", "amomin_w", "amominu_w")

114 
vÆ
 
rv32uaS™sLRSC
 = 
√w
 
As£mblyTe°Suôe
("rv32ua", 
rv32uaS™sLRSCNames
)(
_
)

116 
vÆ
 
rv32uaNames
 = 
rv32uaS™sLRSCNames
 + "lrsc"

117 
vÆ
 
rv32ua
 = 
√w
 
As£mblyTe°Suôe
("rv32ua", 
rv32uaNames
)(
_
)

119 
vÆ
 
rv32siNames
 = 
LökedHashSë
("csr", "ma_fetch", "scall", "sbreak", "wfi", "dirty")

120 
vÆ
 
rv32si
 = 
√w
 
As£mblyTe°Suôe
("rv32si", 
rv32siNames
)(
_
)

122 
vÆ
 
rv32miNames
 = 
LökedHashSë
("csr", "mcsr", "illegal", "ma_addr", "ma_fetch", "sbreak", "scall")

123 
vÆ
 
rv32mi
 = 
√w
 
As£mblyTe°Suôe
("rv32mi", 
rv32miNames
)(
_
)

125 
vÆ
 
rv32u
 = 
Li°
(
rv32ui
, 
rv32um
)

126 
vÆ
 
rv32i
 = 
Li°
(
rv32ui
, 
rv32si
, 
rv32mi
)

127 
vÆ
 
rv32pi
 = 
Li°
(
rv32ui
, 
rv32mi
)

129 
vÆ
 
rv64uiNames
 = 
LökedHashSë
("addw", "addiw", "ld", "lwu", "sd", "slliw", "sllw", "sltiu", "sltu", "sraiw", "sraw", "srliw", "srlw", "subw")

130 
vÆ
 
rv64ui
 = 
√w
 
As£mblyTe°Suôe
("rv64ui", 
rv32uiNames
 ++ 
rv64uiNames
)(
_
)

132 
vÆ
 
rv64umNames
 = 
LökedHashSë
("divuw", "divw", "mulw", "remuw", "remw")

133 
vÆ
 
rv64um
 = 
√w
 
As£mblyTe°Suôe
("rv64um", 
rv32umNames
 ++ 
rv64umNames
)(
_
)

135 
vÆ
 
rv64uaS™sLRSCNames
 = 
rv32uaS™sLRSCNames
.
m≠
(
_
.
ª∂a˚AŒ
("_w","_d"))

136 
vÆ
 
rv64uaS™sLRSC
 = 
√w
 
As£mblyTe°Suôe
("rv64ua", 
rv32uaS™sLRSCNames
 ++ 
rv64uaS™sLRSCNames
)(
_
)

138 
vÆ
 
rv64uaNames
 = 
rv64uaS™sLRSCNames
 + "lrsc"

139 
vÆ
 
rv64ua
 = 
√w
 
As£mblyTe°Suôe
("rv64ua", 
rv32uaNames
 ++ 
rv64uaNames
)(
_
)

141 
vÆ
 
rv64ucNames
 = 
rv32ucNames


142 
vÆ
 
rv64uc
 = 
√w
 
As£mblyTe°Suôe
("rv64uc", 
rv64ucNames
)(
_
)

144 
vÆ
 
rv64ufNames
 = 
LökedHashSë
("ldst", "move", "fcmp", "fcvt", "fcvt_w", "fclass", "fadd", "fdiv", "fmin", "fmadd")

145 
vÆ
 
rv64uf
 = 
√w
 
As£mblyTe°Suôe
("rv64uf", 
rv64ufNames
)(
_
)

147 
vÆ
 
rv32uf
 = 
√w
 
As£mblyTe°Suôe
("rv32uf", 
rv64ufNames
)(
_
)

148 
vÆ
 
rv32ud
 = 
√w
 
As£mblyTe°Suôe
("rv32ud", 
rv64ufNames
 - "move")(
_
)

150 
vÆ
 
rv64udNames
 = 
rv64ufNames
 + "structural"

151 
vÆ
 
rv64ud
 = 
√w
 
As£mblyTe°Suôe
("rv64ud", 
rv64udNames
)(
_
)

153 
vÆ
 
rv64siNames
 = 
rv32siNames


154 
vÆ
 
rv64si
 = 
√w
 
As£mblyTe°Suôe
("rv64si", 
rv64siNames
)(
_
)

156 
vÆ
 
rv64miNames
 = 
rv32miNames
 + "breakpoint" + "access"

157 
vÆ
 
rv64mi
 = 
√w
 
As£mblyTe°Suôe
("rv64mi", 
rv64miNames
)(
_
)

159 
vÆ
 
groundã°Names
 = 
LökedHashSë
("simple")

160 
vÆ
 
groundã°64
 = 
√w
 
As£mblyTe°Suôe
("rv64ui", 
groundã°Names
)(
_
)

161 
vÆ
 
groundã°32
 = 
√w
 
As£mblyTe°Suôe
("rv32ui", 
groundã°Names
)(
_
)

163 
vÆ
 
rv64u
 = 
Li°
(
rv64ui
, 
rv64um
)

164 
vÆ
 
rv64i
 = 
Li°
(
rv64ui
, 
rv64si
, 
rv64mi
)

165 
vÆ
 
rv64pi
 = 
Li°
(
rv64ui
, 
rv64mi
)

167 
vÆ
 
bíchm¨ks
 = 
√w
 
Bíchm¨kTe°Suôe
("rvi", "$(RISCV)/riscv64-unknown-ñf/sh¨e/riscv-ã°s/bíchm¨ks", 
LökedHashSë
(

170 
vÆ
 
rv32udBíchm¨ks
 = 
√w
 
Bíchm¨kTe°Suôe
("rvd", "$(RISCV)/riscv64-unknown-ñf/sh¨e/riscv-ã°s/bíchm¨ks", 
LökedHashSë
(

173 
vÆ
 
em±yBm¨ks
 = 
√w
 
Bíchm¨kTe°Suôe
("empty",

174 "$(RISCV)/riscv64-unknown-ñf/sh¨e/riscv-ã°s/bíchm¨ks", 
LökedHashSë
.
em±y
)

176 
vÆ
 
sögÀRegªssi⁄
 = 
√w
 
Regªssi⁄Te°Suôe
(
LökedHashSë
("rv64ui-p-simple"))

178 
vÆ
 
mtBm¨ks
 = 
√w
 
Bíchm¨kTe°Suôe
("mt", "$(RISCV)/riscv64-unknown-elf/share/riscv-tests/mt",

179 
LökedHashSë
(((0 
to
 4).
m≠
("vvadd"+
_
) ++

180 
Li°
("ad","ae","af","ag","ai","ak","al","am","an","ap","aq","ar","at","av","ay","az",

182 "cm","cs","cv","cy","dc","df","dm","do","dr","ds","du","dv").
m≠
(
_
+"_matmul")): _*))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/TestHarness.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
sy°em


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gdebug
.
Debug


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
LazyModuÀ


10 ˛as†
	cTe°H¨√ss
()(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

11 
vÆ
 
io
 = 
√w
 
BundÀ
 {

12 
vÆ
 
suc˚ss
 = 
	`Boﬁ
(
OUTPUT
)

15 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
Exam∂eRockëSy°em
).
moduÀ
)

16 
dut
.
ª£t
 :ª£à| dut.
debug
.
ndª£t


18 
dut
.
	$d⁄tTouchP‹ts
()

19 
dut
.
	$tõOffI¡îru±s
()

20 
dut
.
	$c⁄√˘SimAXIMem
()

21 
dut
.
	$c⁄√˘SimAXIMMIO
()

22 
dut
.
l2_‰⁄ãnd_bus_axi4
.
	$f‹óch
(
_
.
tõoff
)

23 
Debug
.
	`c⁄√˘Debug
(
dut
.
debug
, 
˛ock
, 
ª£t
, 
io
.
suc˚ss
)

24 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/BaseTile.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


15 
obje˘
 
Sh¨edMem‹yTLEdge
 
exãnds
 
	gFõld
[
TLEdgeOut
]

16 
obje˘
 
TûeKey
 
exãnds
 
	gFõld
[
TûeP¨ams
]

17 
obje˘
 
Re£tVe˘‹Bôs
 
exãnds
 
	gFõld
[
I¡
]

18 
obje˘
 
MaxH¨tIdBôs
 
exãnds
 
	gFõld
[
I¡
]

20 
ab°ø˘
 cœs†
	cLookupByH¨tIdIm∂
 {

21 
def
 
	m≠∂y
[
T
 <: 
D©a
](
f
: 
TûeP¨ams
 => 
O±i⁄
[T], 
	mh¨tId
: 
UI¡
): T

23 
obje˘
 
LookupByH¨tId
 
exãnds
 
Fõld
[
LookupByH¨tIdIm∂
]

25 
åaô
 
TûeP¨ams
 {

26 
vÆ
 
c‹e
: 
C‹eP¨ams


27 
vÆ
 
iˇche
: 
O±i⁄
[
ICacheP¨ams
]

28 
vÆ
 
dˇche
: 
O±i⁄
[
DCacheP¨ams
]

29 
vÆ
 
btb
: 
O±i⁄
[
BTBP¨ams
]

30 
vÆ
 
åa˚
: 
Boﬁón


31 
vÆ
 
h¨tId
: 
I¡


32 
vÆ
 
blockîCålAddr
: 
O±i⁄
[
BigI¡
]

33 
vÆ
 
«me
: 
O±i⁄
[
Såög
]

36 
åaô
 
HasTûeP¨amëîs
 {

37 
im∂icô
 
vÆ
 
p
: 
P¨amëîs


38 
def
 
tûeP¨ams
: 
TûeP¨ams
 = 
p
(
TûeKey
)

40 
def
 
usögVM
: 
Boﬁón
 = 
tûeP¨ams
.
c‹e
.
u£VM


41 
def
 
usögU£r
: 
Boﬁón
 = 
tûeP¨ams
.
c‹e
.
u£U£r
 || 
usögVM


42 
def
 
usögDebug
: 
Boﬁón
 = 
tûeP¨ams
.
c‹e
.
u£Debug


43 
def
 
usögRoCC
: 
Boﬁón
 = !
p
(
BuûdRoCC
).
isEm±y


44 
def
 
usögBTB
: 
Boﬁón
 = 
tûeP¨ams
.
btb
.
isDeföed
 &&ÅûeP¨ams.btb.
gë
.
nE¡rõs
 > 0

45 
def
 
usögPTW
: 
Boﬁón
 = 
usögVM


46 
def
 
usögD©aS¸©ch∑d
: 
Boﬁón
 = 
tûeP¨ams
.
dˇche
.
Ê©M≠
(
_
.
s¸©ch
).
isDeföed


48 
def
 
xLí
: 
I¡
 = 
p
(
XLí
)

49 
def
 
xByãs
: 
I¡
 = 
xLí
 / 8

50 
def
 
iLí
: 
I¡
 = 32

51 
def
 
pgIdxBôs
: 
I¡
 = 12

52 
def
 
pgLevñBôs
: 
I¡
 = 10 - 
log2Ceû
(
xLí
 / 32)

53 
def
 
vaddrBôs
: 
I¡
 =

54 i‡(
usögVM
) {

55 
vÆ
 
v
 = 
pgIdxBôs
 + 
pgLevñs
 * 
pgLevñBôs


56 
ªquúe
(
v
 =
xLí
 || xLí > v && v > 
∑ddrBôs
)

57 
v


61 (
∑ddrBôs
 + 1Ë
mö
 
xLí


63 
def
 
∑ddrBôs
: 
I¡
 = 
p
(
Sh¨edMem‹yTLEdge
).
bundÀ
.
addªssBôs


64 
def
 
v≤Bôs
: 
I¡
 = 
vaddrBôs
 - 
pgIdxBôs


65 
def
 
µnBôs
: 
I¡
 = 
∑ddrBôs
 - 
pgIdxBôs


66 
def
 
pgLevñs
: 
I¡
 = 
p
(
PgLevñs
)

67 
def
 
asIdBôs
: 
I¡
 = 
p
(
ASIdBôs
)

68 
def
 
v≤BôsExãnded
: 
I¡
 = 
v≤Bôs
 + (
vaddrBôs
 < 
xLí
).
toI¡


69 
def
 
vaddrBôsExãnded
: 
I¡
 = 
v≤BôsExãnded
 + 
pgIdxBôs


70 
def
 
maxPAddrBôs
: 
I¡
 = 
xLí
 
m©ch
 { 32 => 34; 64 => 56 }

72 
def
 
	gh¨tId
: 
I¡
 = 
tûeP¨ams
.
h¨tId


73 
def
 
h¨tIdLí
: 
I¡
 = 
p
(
MaxH¨tIdBôs
)

74 
def
 
ª£tVe˘‹Lí
: 
I¡
 = 
∑ddrBôs


76 
def
 
ˇcheBlockByãs
 = 
p
(
CacheBlockByãs
)

77 
def
 
lgCacheBlockByãs
 = 
log2Up
(
ˇcheBlockByãs
)

78 
def
 
ma°îP‹tBótByãs
 = 
p
(
Sy°emBusKey
).
bótByãs


82 
def
 
dˇcheArbP‹ts
 = 1 + 
usögVM
.
toI¡
 + 
usögD©aS¸©ch∑d
.toI¡ + 
p
(
BuûdRoCC
).
size


85 
def
 
ißDTS
: 
Såög
 = {

86 
vÆ
 
m
 = i‡(
tûeP¨ams
.
c‹e
.
mulDiv
.
n⁄Em±y
) "m" ""

87 
vÆ
 
a
 = i‡(
tûeP¨ams
.
c‹e
.
u£Atomics
) "a" ""

88 
vÆ
 
f
 = i‡(
tûeP¨ams
.
c‹e
.
Âu
.
n⁄Em±y
) "f" ""

89 
vÆ
 
d
 = i‡(
tûeP¨ams
.
c‹e
.
Âu
.
n⁄Em±y
 &&ÅûeP¨ams.c‹e.Âu.
gë
.
fLí
 > 32) "d" ""

90 
vÆ
 
c
 = i‡(
tûeP¨ams
.
c‹e
.
u£Com¥es£d
) "c" ""

91 
s
"rv${p(XLen)}i$m$a$f$d$c"

94 
def
 
tûePr›îtõs
: 
Pr›îtyM≠
 = {

95 
vÆ
 
dˇche
 = 
tûeP¨ams
.dˇche.
fûãr
(!
_
.
s¸©ch
.
isDeföed
).
m≠
(
d
 => 
M≠
(

96 "d-ˇche-block-size" -> 
ˇcheBlockByãs
.
asPr›îty
,

97 "d-ˇche-£ts" -> 
d
.
nSës
.
asPr›îty
,

98 "d-ˇche-size" -> (
d
.
nSës
 * d.
nWays
 * 
ˇcheBlockByãs
).
asPr›îty
)

99 ).
gëOrEl£
(
Nû
)

101 
vÆ
 
	göcohîít
 = i‡(!
tûeP¨ams
.
c‹e
.
u£AtomicsO∆yF‹IO
Ë
Nû
 
M≠
(

102 "sifive,d-ˇche-öcohîít" -> 
Nû
)

104 
vÆ
 
iˇche
 = 
tûeP¨ams
.iˇche.
m≠
(
i
 => 
M≠
(

105 "i-ˇche-block-size" -> 
ˇcheBlockByãs
.
asPr›îty
,

106 "i-ˇche-£ts" -> 
i
.
nSës
.
asPr›îty
,

107 "i-ˇche-size" -> (
i
.
nSës
 * i.
nWays
 * 
ˇcheBlockByãs
).
asPr›îty
)

108 ).
gëOrEl£
(
Nû
)

110 
vÆ
 
	gdéb
 = 
tûeP¨ams
.
dˇche
.
fûãr
(
_
 =>ÅûeP¨ams.
c‹e
.
u£VM
).
m≠
(
d
 => 
M≠
(

111 "d-éb-size" -> 
d
.
nTLBE¡rõs
.
asPr›îty
,

112 "d-éb-£ts" -> 1.a
sPr›îty
)).
gëOrEl£
(
Nû
)

114 
vÆ
 
	gôlb
 = 
tûeP¨ams
.
iˇche
.
fûãr
(
_
 =>ÅûeP¨ams.
c‹e
.
u£VM
).
m≠
(
i
 => 
M≠
(

115 "i-éb-size" -> 
i
.
nTLBE¡rõs
.
asPr›îty
,

116 "i-éb-£ts" -> 1.a
sPr›îty
)).
gëOrEl£
(
Nû
)

118 
vÆ
 
	gmmu
 = i‡(!
tûeP¨ams
.
c‹e
.
u£VM
Ë
Nû
 
M≠
(

119 "éb-•lô" -> 
Nû
,

120 "mmu-ty≥" -> (
p
(
PgLevñs
Ë
m©ch
 {

124 }).
asPr›îty
)

126 
	gdˇche
 ++ 
	giˇche
 ++ 
	gdéb
 ++ 
	gôlb
 ++ 
	gmmu
 ++ 
	göcohîít


132 
ab°ø˘
 
˛ass
 
	$Ba£Tûe
(
tûeP¨ams
: 
TûeP¨ams
, 
vÆ
 
¸ossög
: 
ClockCrossögTy≥
)

133 (
im∂icô
 
p
: 
P¨amëîs
)

134 
exãnds
 
LazyModuÀ
 
wôh
 
Cros£sToO∆yO√ClockDomaö
 wôh 
HasTûeP¨amëîs
 {

135 
def
 
moduÀ
: 
Ba£TûeModuÀImp
[
Ba£Tûe
]

136 
def
 
ma°îNode
: 
TLOutw¨dNode


137 
def
 
¶aveNode
: 
TLInw¨dNode


138 
def
 
ötInw¨dNode
: 
I¡Inw¨dNode


139 
def
 
ötOutw¨dNode
: 
I¡Outw¨dNode


141 
¥Ÿe˘ed
 
vÆ
 
éOthîMa°îsNode
 = 
	`TLIdítôyNode
()

142 
¥Ÿe˘ed
 
vÆ
 
éMa°îXb¨
 = 
	`LazyModuÀ
(
√w
 
TLXb¨
)

143 
¥Ÿe˘ed
 
vÆ
 
éSœveXb¨
 = 
	`LazyModuÀ
(
√w
 
TLXb¨
)

144 
¥Ÿe˘ed
 
vÆ
 
ötXb¨
 = 
	`LazyModuÀ
(
√w
 
I¡Xb¨
)

146 
def
 
	`c⁄√˘TLSœve
(
node
: 
TLNode
, 
byãs
: 
I¡
) {

147 
DißbÀM⁄ô‹s
 { 
im∂icô
 
p
 =>

148 (
	`Seq
(
node
, 
	`TLFøgmíãr
(
byãs
, 
ˇcheBlockByãs
, 
óæyAck
=
E¨lyAck
.
PutFuŒs
))

149 ++ (
xByãs
 !
byãs
).
	`›ti⁄
(
	`TLWidthWidgë
(xBytes)))

150 .
	`fﬁdRight
(
éSœveXb¨
.
node
:
TLOutw¨dNode
)(
_
 :*= _)

155 
def
 
√xtLevñCachePr›îty
: 
Pr›îtyO±i⁄
 = {

156 
vÆ
 
ouãr
 = 
éMa°îXb¨
.
node
.
edges
.
out


157 .
	`Ê©M≠
(
_
.
m™agî
.
m™agîs
)

158 .
	`fûãr
(
_
.
suµ‹tsAcquúeB
)

159 .
	`Ê©M≠
(
_
.
ªsour˚s
.
hódO±i⁄
)

160 .
	`m≠
(
_
.
ow√r
.
œbñ
)

161 .
di°ö˘


162 i‡(
ouãr
.
isEm±y
Ë
N⁄e


163 
	`Some
("√xt-Àvñ-ˇche" -> 
ouãr
.
	`m≠
(
l
 => 
	`Resour˚Re„ªn˚
÷)).
toLi°
)

166 
def
 
˝uPr›îtõs
: 
Pr›îtyM≠
 = 
	`M≠
(

167 "devi˚_ty≥" -> "˝u".
asPr›îty
,

168 "°©us" -> "okay".
asPr›îty
,

169 "˛ock-‰equícy" -> 
tûeP¨ams
.
c‹e
.
boŸFªqHz
.
asPr›îty
,

170 "riscv,iß" -> 
ißDTS
.
asPr›îty
,

171 "timeba£-‰equícy" -> 
	`p
(
DTSTimeba£
).
asPr›îty
)

175 
¥Ÿe˘ed
 
def
 
	`makeMa°îBound¨yBuf„rs
(
im∂icô
 
p
: 
P¨amëîs
Ë
	`TLBuf„r
(
Buf„rP¨ams
.
n⁄e
)

176 
def
 
	`¸ossMa°îP‹t
(): 
TLOutw¨dNode
 = {

177 
vÆ
 
éMa°îXög
 = 
this
.
	`¸ossOut
(
¸ossög
 
m©ch
 {

178 
	`R©i⁄ÆCrossög
(
_
Ë=> 
this
 { 
makeMa°îBound¨yBuf„rs
 } :=* 
ma°îNode


179 
_
 => 
ma°îNode


181 
	`éMa°îXög
(
¸ossög
)

184 
¥Ÿe˘ed
 
def
 
	`makeSœveBound¨yBuf„rs
(
im∂icô
 
p
: 
P¨amëîs
Ë
	`TLBuf„r
(
Buf„rP¨ams
.
n⁄e
)

185 
def
 
	`¸ossSœveP‹t
(): 
TLInw¨dNode
 = { 
DißbÀM⁄ô‹s
 { 
im∂icô
 
p
 =>

186 
vÆ
 
éSœveXög
 = 
this
.
	`¸ossIn
(
¸ossög
 
m©ch
 {

187 
	`R©i⁄ÆCrossög
(
_
Ë=> 
¶aveNode
 :*
this
 { 
makeSœveBound¨yBuf„rs
 }

188 
_
 => 
¶aveNode


190 
	`éSœveXög
(
¸ossög
)

193 
def
 
	`¸ossI¡In
(): 
I¡Inw¨dNode
 = crossI¡In(
ötInw¨dNode
)

194 
def
 
	`¸ossI¡Out
(): 
I¡Outw¨dNode
 = crossI¡Out(
ötOutw¨dNode
)

195 
	}
}

197 
ab°ø˘
 
˛ass
 
Ba£TûeModuÀImp
[+
L
 <: 
Ba£Tûe
](
vÆ
 
ouãr
: LË
exãnds
 
	$LazyModuÀImp
(
ouãr
Ë
wôh
 
HasTûeP¨amëîs
 {

199 
	`ªquúe
(
xLí
 == 32 || xLen == 64)

200 
	`ªquúe
(
∑ddrBôs
 <
maxPAddrBôs
)

201 
	`ªquúe
(
ª£tVe˘‹Lí
 <
xLí
)

202 
	`ªquúe
(
ª£tVe˘‹Lí
 <
vaddrBôsExãnded
)

203 
	`ªquúe
 (
	`log2Up
(
h¨tId
 + 1Ë<
h¨tIdLí
, 
s
"p(MaxHartIdBits) of $hartIdLen isÇotÉnough for hartid $hartId")

205 
vÆ
 
åa˚
 = 
tûeP¨ams
.åa˚.
	`›ti⁄
(
	`IO
(
	`Vec
—ûeP¨ams.
c‹e
.
ªtúeWidth
, 
√w
 
Tø˚dIn°ru˘i⁄
).
asOuçut
))

206 
vÆ
 
c⁄°™ts
 = 
	`IO
(
√w
 
TûeI≈utC⁄°™ts
)

208 
vÆ
 
hÆt_™d_ˇtch_fúe
: 
O±i⁄
[
Boﬁ
]

209 
	}
}

212 
åaô
 
HasExã∫ÆlyDrivíTûeC⁄°™ts
 
exãnds
 
BundÀ
 
wôh
 
HasTûeP¨amëîs
 {

213 
vÆ
 
h¨tid
 = 
UI¡
(
INPUT
, 
h¨tIdLí
)

214 
vÆ
 
	gª£t_ve˘‹
 = 
UI¡
(
INPUT
, 
ª£tVe˘‹Lí
)

217 
˛ass
 
	$TûeI≈utC⁄°™ts
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
P¨amëîizedBundÀ
 
wôh
 
HasExã∫ÆlyDrivíTûeC⁄°™ts


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Core.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
obje˘
 
XLí
 
exãnds
 
	gFõld
[
I¡
]

14 
åaô
 
	gC‹eP¨ams
 {

15 
vÆ
 
	gboŸFªqHz
: 
BigI¡


16 
vÆ
 
u£VM
: 
Boﬁón


17 
vÆ
 
u£U£r
: 
Boﬁón


18 
vÆ
 
u£Debug
: 
Boﬁón


19 
vÆ
 
u£Atomics
: 
Boﬁón


20 
vÆ
 
u£AtomicsO∆yF‹IO
: 
Boﬁón


21 
vÆ
 
u£Com¥es£d
: 
Boﬁón


22 
vÆ
 
u£SCIE
: 
Boﬁón


23 
vÆ
 
mulDiv
: 
O±i⁄
[
MulDivP¨ams
]

24 
vÆ
 
Âu
: 
O±i⁄
[
FPUP¨ams
]

25 
vÆ
 
„tchWidth
: 
I¡


26 
vÆ
 
decodeWidth
: 
I¡


27 
vÆ
 
ªtúeWidth
: 
I¡


28 
vÆ
 
ö°Bôs
: 
I¡


29 
vÆ
 
nLoˇlI¡îru±s
: 
I¡


30 
vÆ
 
nPMPs
: 
I¡


31 
vÆ
 
pmpGønuœrôy
: 
I¡


32 
vÆ
 
nBªakpoöts
: 
I¡


33 
vÆ
 
nPîfCou¡îs
: 
I¡


34 
vÆ
 
haveBasicCou¡îs
: 
Boﬁón


35 
vÆ
 
haveFSDúty
: 
Boﬁón


36 
vÆ
 
mißWrôabÀ
: 
Boﬁón


37 
vÆ
 
nL2TLBE¡rõs
: 
I¡


38 
vÆ
 
mtvecInô
: 
O±i⁄
[
BigI¡
]

39 
vÆ
 
mtvecWrôabÀ
: 
Boﬁón


40 
vÆ
 
tûeC⁄åﬁAddr
: 
O±i⁄
[
BigI¡
]

41 
def
 
cu°omCSRs
(
im∂icô
 
p
: 
P¨amëîs
): 
Cu°omCSRs
 = 
√w
 CustomCSRs

42 
vÆ
 
hasPrivCodeLock
: 
Boﬁón
 = 
Ál£


43 
vÆ
 
numPCodeR™ges
: 
I¡
 = 4

44 
def
 
ö°Byãs
: 
I¡
 = 
ö°Bôs
 / 8

45 
def
 
„tchByãs
: 
I¡
 = 
„tchWidth
 * 
ö°Byãs


46 
def
 
ÃscCy˛es
: 
I¡


49 
åaô
 
HasC‹eP¨amëîs
 
exãnds
 
HasTûeP¨amëîs
 {

50 
vÆ
 
c‹eP¨ams
: 
C‹eP¨ams
 = 
tûeP¨ams
.
c‹e


52 
vÆ
 
fLí
 = 
c‹eP¨ams
.
Âu
.
m≠
(
_
.fLí).
gëOrEl£
(0)

54 
vÆ
 
usögMulDiv
 = 
c‹eP¨ams
.
mulDiv
.
n⁄Em±y


55 
vÆ
 
usögFPU
 = 
c‹eP¨ams
.
Âu
.
n⁄Em±y


56 
vÆ
 
usögAtomics
 = 
c‹eP¨ams
.
u£Atomics


57 
vÆ
 
usögAtomicsO∆yF‹IO
 = 
c‹eP¨ams
.
u£AtomicsO∆yF‹IO


58 
vÆ
 
usögAtomicsInCache
 = 
usögAtomics
 && !
usögAtomicsO∆yF‹IO


59 
vÆ
 
usögCom¥es£d
 = 
c‹eP¨ams
.
u£Com¥es£d


60 
vÆ
 
usögSCIE
 = 
c‹eP¨ams
.
u£SCIE


62 
vÆ
 
ªtúeWidth
 = 
c‹eP¨ams
.retireWidth

63 
vÆ
 
„tchWidth
 = 
c‹eP¨ams
.fetchWidth

64 
vÆ
 
decodeWidth
 = 
c‹eP¨ams
.decodeWidth

66 
vÆ
 
„tchByãs
 = 
c‹eP¨ams
.fetchBytes

67 
vÆ
 
c‹eIn°Bôs
 = 
c‹eP¨ams
.
ö°Bôs


68 
vÆ
 
c‹eIn°Byãs
 = 
c‹eIn°Bôs
/8

69 
vÆ
 
c‹eD©aBôs
 = 
xLí
 
max
 
fLí


70 
vÆ
 
c‹eD©aByãs
 = 
c‹eD©aBôs
/8

71 
vÆ
 
c‹eMaxAddrBôs
 = 
∑ddrBôs
 
max
 
vaddrBôsExãnded


73 
vÆ
 
nBªakpoöts
 = 
c‹eP¨ams
.nBreakpoints

74 
vÆ
 
nPMPs
 = 
c‹eP¨ams
.nPMPs

75 
vÆ
 
pmpGønuœrôy
 = 
c‹eP¨ams
.pmpGranularity

76 
vÆ
 
nPîfCou¡îs
 = 
c‹eP¨ams
.nPerfCounters

77 
vÆ
 
mtvecInô
 = 
c‹eP¨ams
.mtvecInit

78 
vÆ
 
mtvecWrôabÀ
 = 
c‹eP¨ams
.mtvecWritable

80 
vÆ
 
c‹eDCacheReqTagBôs
 = 6

81 
vÆ
 
dˇcheReqTagBôs
 = 
c‹eDCacheReqTagBôs
 + 
log2Ceû
(
dˇcheArbP‹ts
)

85 
vÆ
 
íabÀCommôLog
 = 
Ál£


87 
def
 
hasPrivCodeLock
 = 
c‹eP¨ams
.hasPrivCodeLock

88 
def
 
numPCodeR™ges
 = 
c‹eP¨ams
.numPCodeRanges

91 
ab°ø˘
 cœs†
	cC‹eModuÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ


92 
wôh
 
HasC‹eP¨amëîs


94 
ab°ø˘
 cœs†
	cC‹eBundÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
)

95 
wôh
 
HasC‹eP¨amëîs


97 ˛as†
	cC‹eI¡îru±s
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$TûeI¡îru±s
()(
p
) {

98 
vÆ
 
bu£º‹
 = 
c‹eP¨ams
.
tûeC⁄åﬁAddr
.
	`m≠
(
a
 => 
	`Boﬁ
())

101 
åaô
 
HasC‹eIO
 
exãnds
 
HasTûeP¨amëîs
 {

102 
im∂icô
 
vÆ
 
p
: 
P¨amëîs


103 
vÆ
 
io
 = 
√w
 
	`C‹eBundÀ
()(
p
Ë
wôh
 
HasExã∫ÆlyDrivíTûeC⁄°™ts
 {

104 
vÆ
 
öãºu±s
 = 
√w
 
	`C‹eI¡îru±s
().
asI≈ut


105 
vÆ
 
imem
 = 
√w
 
Fr⁄ãndIO


106 
vÆ
 
dmem
 = 
√w
 
HñœCacheIO


107 
vÆ
 
±w
 = 
√w
 
	`D©≠©hPTWIO
().
Êù


108 
vÆ
 
Âu
 = 
√w
 
	`FPUC‹eIO
().
Êù


109 
vÆ
 
rocc
 = 
√w
 
	`RoCCC‹eIO
().
Êù


110 
vÆ
 
åa˚
 = 
	`Vec
(
c‹eP¨ams
.
ªtúeWidth
, 
√w
 
Tø˚dIn°ru˘i⁄
).
asOuçut


112 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/CustomCSRs.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


5 
imp‹t
 
	gchi£l3
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
˛ass
 
	$Cu°omCSR
(
id
: 
I¡
, 
mask
: 
BigI¡
, 
öô
: 
O±i⁄
[BigInt])

11 
obje˘
 
Cu°omCSR
 {

12 
def
 
	`c⁄°™t
(
id
: 
I¡
, 
vÆue
: 
BigI¡
): 
Cu°omCSR
 = 
	`Cu°omCSR
(id, 
	`BigI¡
(0), 
	`Some
(value))

13 
	}
}

15 ˛as†
	cCu°omCSRIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
C‹eBundÀ
 {

16 
vÆ
 
wí
 = 
	$Boﬁ
()

17 
vÆ
 
wd©a
 = 
	$UI¡
(
xLí
.
W
)

18 
vÆ
 
vÆue
 = 
	`UI¡
(
xLí
.
W
)

21 ˛as†
	cCu°omCSRs
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
C‹eBundÀ
 {

24 
¥Ÿe˘ed
 
def
 
bpmCSRId
 = 0x7c0

25 
¥Ÿe˘ed
 
def
 
bpmCSR
: 
O±i⁄
[
Cu°omCSR
] = 
N⁄e


27 
¥Ÿe˘ed
 
def
 
chickíCSRId
 = 0x7c1

28 
¥Ÿe˘ed
 
def
 
chickíCSR
: 
O±i⁄
[
Cu°omCSR
] = 
N⁄e


31 
def
 
de˛s
: 
Seq
[
Cu°omCSR
] = 
bpmCSR
.
toSeq
 ++ 
chickíCSR


33 
vÆ
 
c§s
 = 
	$Vec
(
de˛s
.
size
, 
√w
 
Cu°omCSRIO
)

35 
def
 
ÊushBTB
 = 
	$gëOrEl£
(
bpmCSR
, 
_
.
wí
, 
Ál£
.
B
)

36 
def
 
bpmSètic
 = 
	`gëOrEl£
(
bpmCSR
, 
_
.
	`vÆue
(0), 
Ál£
.
B
)

37 
def
 
dißbÀDCacheClockG©e
 = 
	`gëOrEl£
(
chickíCSR
, 
_
.
	`vÆue
(0), 
åue
.
B
)

38 
def
 
dißbÀICacheClockG©e
 = 
	`gëOrEl£
(
chickíCSR
, 
_
.
	`vÆue
(1), 
åue
.
B
)

39 
def
 
dißbÀC‹eClockG©e
 = 
	`gëOrEl£
(
chickíCSR
, 
_
.
	`vÆue
(2), 
åue
.
B
)

41 
¥Ÿe˘ed
 
def
 
gëByIdOrEl£
[
T
](
id
: 
I¡
, 
f
: 
Cu°omCSRIO
 => T, 
Æt
: T): T = {

42 
vÆ
 
idx
 = 
de˛s
.
	`ödexWhîe
(
_
.
id
 == id)

43 i‡(
idx
 < 0Ë
Æt
 
	`f
(
	`c§s
(idx))

46 
¥Ÿe˘ed
 
def
 
gëOrEl£
[
T
](
c§
: 
O±i⁄
[
Cu°omCSR
], 
f
: 
Cu°omCSRIO
 => T, 
Æt
: T): T =

47 
c§
.
	`m≠
(
c
 => 
	`gëByIdOrEl£
(c.
id
, 
f
, 
Æt
)).
	`gëOrEl£
(alt)

48 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/FPU.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gChi£l
.
	gIm∂icôC⁄vîsi⁄s
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
	gIn°ru˘i⁄s
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


14 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


15 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
_


17 
˛ass
 
	$FPUP¨ams
(

18 
fLí
: 
I¡
 = 64,

19 
divSqπ
: 
Boﬁón
 = 
åue
,

20 
sfmaL©ícy
: 
I¡
 = 3,

21 
dfmaL©ícy
: 
I¡
 = 4

24 
obje˘
 
FPC⁄°™ts


26 
vÆ
 
RM_SZ
 = 3

27 
vÆ
 
FLAGS_SZ
 = 5

28 
	}
}

29 
imp‹t
 
FPC⁄°™ts
.
_


31 
åaô
 
HasFPUCålSigs
 {

32 
vÆ
 
ld°
 = 
Boﬁ
()

33 
vÆ
 
wí
 = 
Boﬁ
()

34 
vÆ
 
ªn1
 = 
Boﬁ
()

35 
vÆ
 
ªn2
 = 
Boﬁ
()

36 
vÆ
 
ªn3
 = 
Boﬁ
()

37 
vÆ
 
sw≠12
 = 
Boﬁ
()

38 
vÆ
 
sw≠23
 = 
Boﬁ
()

39 
vÆ
 
sögÀIn
 = 
Boﬁ
()

40 
vÆ
 
sögÀOut
 = 
Boﬁ
()

41 
vÆ
 
‰omöt
 = 
Boﬁ
()

42 
vÆ
 
toöt
 = 
Boﬁ
()

43 
vÆ
 
Á°pùe
 = 
Boﬁ
()

44 
vÆ
 
fma
 = 
Boﬁ
()

45 
vÆ
 
div
 = 
Boﬁ
()

46 
vÆ
 
sqπ
 = 
Boﬁ
()

47 
vÆ
 
wÊags
 = 
Boﬁ
()

50 ˛as†
	cFPUCålSigs
 
exãnds
 
BundÀ
 
wôh
 
HasFPUCålSigs


52 ˛as†
	cFPUDecodî
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$FPUModuÀ
()(
p
) {

53 
vÆ
 
io
 = 
√w
 
BundÀ
 {

54 
vÆ
 
ö°
 = 
	`Bôs
(
INPUT
, 32)

55 
vÆ
 
sigs
 = 
√w
 
	`FPUCålSigs
().
asOuçut


58 
vÆ
  = 
	$Li°
(
X
,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X)

59 
vÆ
 
f
 =

60 
	`Aºay
(
FLW
 -> 
	`Li°
(
Y
,Y,
N
,N,N,
X
,X,X,X,N,N,N,N,N,N,N),

61 
FSW
 -> 
	`Li°
(
Y
,
N
,N,Y,N,Y,
X
,N,Y,N,Y,N,N,N,N,N),

62 
FMV_S_X
 -> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,Y,N,Y,N,N,N,N,N,N),

63 
FCVT_S_W
 -> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

64 
FCVT_S_WU
-> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

65 
FCVT_S_L
 -> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

66 
FCVT_S_LU
-> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

67 
FMV_X_S
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,N,Y,N,Y,N,N,N,N,N),

68 
FCLASS_S
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,N),

69 
FCVT_W_S
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

70 
FCVT_WU_S
-> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

71 
FCVT_L_S
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

72 
FCVT_LU_S
-> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

73 
FEQ_S
 -> 
	`Li°
(
N
,N,
Y
,Y,N,N,N,Y,Y,N,Y,N,N,N,N,Y),

74 
FLT_S
 -> 
	`Li°
(
N
,N,
Y
,Y,N,N,N,Y,Y,N,Y,N,N,N,N,Y),

75 
FLE_S
 -> 
	`Li°
(
N
,N,
Y
,Y,N,N,N,Y,Y,N,Y,N,N,N,N,Y),

76 
FSGNJ_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,N),

77 
FSGNJN_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,N),

78 
FSGNJX_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,N),

79 
FMIN_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,Y),

80 
FMAX_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,Y),

81 
FADD_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,Y,Y,Y,N,N,N,Y,N,N,Y),

82 
FSUB_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,Y,Y,Y,N,N,N,Y,N,N,Y),

83 
FMUL_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,N,Y,N,N,Y),

84 
FMADD_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

85 
FMSUB_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

86 
FNMADD_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

87 
FNMSUB_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

88 
FDIV_S
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,N,N,Y,N,Y),

89 
FSQRT_S
 -> 
	$Li°
(
N
,
Y
,Y,N,N,N,
X
,Y,Y,N,N,N,N,N,Y,Y))

90 
vÆ
 
d
 =

91 
	`Aºay
(
FLD
 -> 
	`Li°
(
Y
,Y,
N
,N,N,
X
,X,X,N,N,N,N,N,N,N,N),

92 
FSD
 -> 
	`Li°
(
Y
,
N
,N,Y,N,Y,
X
,N,N,N,Y,N,N,N,N,N),

93 
FMV_D_X
 -> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,X,N,Y,N,N,N,N,N,N),

94 
FCVT_D_W
 -> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

95 
FCVT_D_WU
-> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

96 
FCVT_D_L
 -> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

97 
FCVT_D_LU
-> 
	`Li°
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

98 
FMV_X_D
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,N),

99 
FCLASS_D
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,N),

100 
FCVT_W_D
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

101 
FCVT_WU_D
-> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

102 
FCVT_L_D
 -> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

103 
FCVT_LU_D
-> 
	`Li°
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

104 
FCVT_S_D
 -> 
	`Li°
(
N
,
Y
,Y,N,N,N,
X
,N,Y,N,N,Y,N,N,N,Y),

105 
FCVT_D_S
 -> 
	`Li°
(
N
,
Y
,Y,N,N,N,
X
,Y,N,N,N,Y,N,N,N,Y),

106 
FEQ_D
 -> 
	`Li°
(
N
,N,
Y
,Y,N,N,N,N,N,N,Y,N,N,N,N,Y),

107 
FLT_D
 -> 
	`Li°
(
N
,N,
Y
,Y,N,N,N,N,N,N,Y,N,N,N,N,Y),

108 
FLE_D
 -> 
	`Li°
(
N
,N,
Y
,Y,N,N,N,N,N,N,Y,N,N,N,N,Y),

109 
FSGNJ_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,N),

110 
FSGNJN_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,N),

111 
FSGNJX_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,N),

112 
FMIN_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,Y),

113 
FMAX_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,Y),

114 
FADD_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,Y,N,N,N,N,N,Y,N,N,Y),

115 
FSUB_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,Y,N,N,N,N,N,Y,N,N,Y),

116 
FMUL_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,N,Y,N,N,Y),

117 
FMADD_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

118 
FMSUB_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

119 
FNMADD_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

120 
FNMSUB_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

121 
FDIV_D
 -> 
	`Li°
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,N,N,Y,N,Y),

122 
FSQRT_D
 -> 
	$Li°
(
N
,
Y
,Y,N,N,N,
X
,N,N,N,N,N,N,N,Y,Y))

124 
vÆ
 
ö¢s
 = 
fLí
 
m©ch
 {

125 32 => 
f


126 64 => 
f
 ++ 
d


127 
	}
}

128 
vÆ
 
	gdecodî
 = 
	$DecodeLogic
(
io
.
ö°
, , 
ö¢s
)

129 
vÆ
 
s
 = 
io
.
sigs


130 
vÆ
 
sigs
 = 
	$Seq
(
s
.
ld°
, s.
wí
, s.
ªn1
, s.
ªn2
, s.
ªn3
, s.
sw≠12
,

131 
s
.
sw≠23
, s.
sögÀIn
, s.
sögÀOut
, s.
‰omöt
, s.
toöt
,

132 
s
.
Á°pùe
, s.
fma
, s.
div
, s.
sqπ
, s.
wÊags
)

133 
sigs
 
zù
 
decodî
 
m≠
 {(
s
,
d
Ë=> s :
	}
d}

136 ˛as†
	cFPUC‹eIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

137 
vÆ
 
ö°
 = 
	$Bôs
(
INPUT
, 32)

138 
vÆ
 
‰omöt_d©a
 = 
	$Bôs
(
INPUT
, 
xLí
)

140 
vÆ
 
fc§_rm
 = 
	$Bôs
(
INPUT
, 
FPC⁄°™ts
.
RM_SZ
)

141 
vÆ
 
fc§_Êags
 = 
	`VÆid
(
	$Bôs
(
width
 = 
FPC⁄°™ts
.
FLAGS_SZ
))

143 
vÆ
 
°‹e_d©a
 = 
	$Bôs
(
OUTPUT
, 
fLí
)

144 
vÆ
 
toöt_d©a
 = 
	$Bôs
(
OUTPUT
, 
xLí
)

146 
vÆ
 
dmem_ª•_vÆ
 = 
	$Boﬁ
(
INPUT
)

147 
vÆ
 
dmem_ª•_ty≥
 = 
	$Bôs
(
INPUT
, 3)

148 
vÆ
 
dmem_ª•_èg
 = 
	$UI¡
(
INPUT
, 5)

149 
vÆ
 
dmem_ª•_d©a
 = 
	$Bôs
(
INPUT
, 
fLí
)

151 
vÆ
 
vÆid
 = 
	$Boﬁ
(
INPUT
)

152 
vÆ
 
fc§_rdy
 = 
	$Boﬁ
(
OUTPUT
)

153 
vÆ
 
«ck_mem
 = 
	$Boﬁ
(
OUTPUT
)

154 
vÆ
 
ûÀgÆ_rm
 = 
	$Boﬁ
(
OUTPUT
)

155 
vÆ
 
kûlx
 = 
	$Boﬁ
(
INPUT
)

156 
vÆ
 
kûlm
 = 
	$Boﬁ
(
INPUT
)

157 
vÆ
 
dec
 = 
√w
 
	`FPUCålSigs
().
asOuçut


158 
vÆ
 
sbﬂrd_£t
 = 
	$Boﬁ
(
OUTPUT
)

159 
vÆ
 
sbﬂrd_˛r
 = 
	$Boﬁ
(
OUTPUT
)

160 
vÆ
 
sbﬂrd_˛ø
 = 
	$UI¡
(
OUTPUT
, 5)

162 
vÆ
 
kìp_˛ock_íabÀd
 = 
	`Boﬁ
(
INPUT
)

165 ˛as†
	cFPUIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$FPUC‹eIO
 ()(
p
) {

166 
vÆ
 
˝_ªq
 = 
	`Decou∂ed
(
√w
 
	`FPI≈ut
()).
Êù


167 
vÆ
 
˝_ª•
 = 
	`Decou∂ed
(
√w
 
	`FPResu…
())

170 ˛as†
	cFPResu…
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

171 
vÆ
 
d©a
 = 
	`Bôs
(
width
 = 
fLí
+1)

172 
vÆ
 
exc
 = 
	`Bôs
(
width
 = 
FPC⁄°™ts
.
FLAGS_SZ
)

175 ˛as†
	cI¡ToFPI≈ut
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
Ë
wôh
 
HasFPUCålSigs
 {

176 
vÆ
 
rm
 = 
	$Bôs
(
width
 = 
FPC⁄°™ts
.
RM_SZ
)

177 
vÆ
 
typ
 = 
	$Bôs
(
width
 = 2)

178 
vÆ
 
ö1
 = 
	`Bôs
(
width
 = 
xLí
)

181 ˛as†
	cFPI≈ut
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
Ë
wôh
 
HasFPUCålSigs
 {

182 
vÆ
 
rm
 = 
	$Bôs
(
width
 = 
FPC⁄°™ts
.
RM_SZ
)

183 
vÆ
 
fmaCmd
 = 
	$Bôs
(
width
 = 2)

184 
vÆ
 
typ
 = 
	$Bôs
(
width
 = 2)

185 
vÆ
 
ö1
 = 
	`Bôs
(
width
 = 
fLí
+1)

186 
vÆ
 
ö2
 = 
	`Bôs
(
width
 = 
fLí
+1)

187 
vÆ
 
ö3
 = 
	`Bôs
(
width
 = 
fLí
+1)

189 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`FPI≈ut
().
asIn°™˚Of
[
this
.
ty≥
]

192 
˛ass
 
	$FTy≥
(
exp
: 
I¡
, 
sig
: Int) {

193 
def
 
õìWidth
 = 
exp
 + 
sig


194 
def
 
ªcodedWidth
 = 
õìWidth
 + 1

196 
def
 
qNaN
 = 
	`UI¡
((
	`BigI¡
(7Ë<< (
exp
 + 
sig
 - 3)) + (BigInt(1) << (sig - 2)),Éxp + sig + 1)

197 
def
 
	`isNaN
(
x
: 
UI¡
Ë
	`x
(
sig
 + 
exp
 - 1, sig +Éx∞- 3).
™dR


198 
def
 
	`isSNaN
(
x
: 
UI¡
Ë
	`isNaN
(xË&& !
	`x
(
sig
 - 2)

200 
def
 
	`˛assify
(
x
: 
UI¡
) = {

201 
vÆ
 
sign
 = 
	`x
(
sig
 + 
exp
)

202 
vÆ
 
code
 = 
	`x
(
exp
 + 
sig
 - 1,Éxp + sig - 3)

203 
vÆ
 
codeHi
 = 
	`code
(2, 1)

204 
vÆ
 
isS≥cül
 = 
codeHi
 ==
	`UI¡
(3)

206 
vÆ
 
isHighSubn‹mÆIn
 = 
	`x
(
exp
 + 
sig
 - 3, sig - 1Ë< 
	`UI¡
(2)

207 
vÆ
 
isSubn‹mÆ
 = 
code
 ==
	`UI¡
(1Ë|| 
codeHi
 ==UI¡(1Ë&& 
isHighSubn‹mÆIn


208 
vÆ
 
isN‹mÆ
 = 
codeHi
 ==
	`UI¡
(1Ë&& !
isHighSubn‹mÆIn
 || codeHi === UInt(2)

209 
vÆ
 
isZîo
 = 
code
 ==
	`UI¡
(0)

210 
vÆ
 
isInf
 = 
isS≥cül
 && !
	`code
(0)

211 
vÆ
 
isNaN
 = 
code
.
™dR


212 
vÆ
 
isSNaN
 = 
isNaN
 && !
	`x
(
sig
-2)

213 
vÆ
 
isQNaN
 = 
isNaN
 && 
	`x
(
sig
-2)

215 
	`C©
(
isQNaN
, 
isSNaN
, 
isInf
 && !
sign
, 
isN‹mÆ
 && !sign,

216 
isSubn‹mÆ
 && !
sign
, 
isZîo
 && !sign, isZero && sign,

217 
isSubn‹mÆ
 && 
sign
, 
isN‹mÆ
 && sign, 
isInf
 && sign)

221 
def
 
	`unß„C⁄vît
(
x
: 
UI¡
, 
to
: 
FTy≥
Ëi‡(
this
 ==Åo) x {

222 
vÆ
 
sign
 = 
	`x
(
sig
 + 
exp
)

223 
vÆ
 
‰a˘In
 = 
	`x
(
sig
 - 2, 0)

224 
vÆ
 
expIn
 = 
	`x
(
sig
 + 
exp
 - 1, sig - 1)

225 
vÆ
 
‰a˘Out
 = 
‰a˘In
 << 
to
.
sig
 >> sig

226 
vÆ
 
expOut
 = {

227 
vÆ
 
expCode
 = 
	`expIn
(
exp
,Éxp - 2)

228 
vÆ
 
comm⁄Ca£
 = (
expIn
 + (1 << 
to
.
exp
)) - (1 <<Éxp)

229 
	`Mux
(
expCode
 ==0 ||ÉxpCodê>6, 
	`C©
”xpCode, 
	`comm⁄Ca£
(
to
.
exp
 - 3, 0)), commonCase(to.exp, 0))

231 
	`C©
(
sign
, 
expOut
, 
‰a˘Out
)

234 
def
 
	`ªcode
(
x
: 
UI¡
Ë
h¨dÊﬂt
.
	`ªcFNFromFN
(
exp
, 
sig
, x)

235 
def
 
	`õì
(
x
: 
UI¡
Ë
h¨dÊﬂt
.
	`fNFromRecFN
(
exp
, 
sig
, x)

236 
	}
}

238 
obje˘
 
	gFTy≥
 {

239 
vÆ
 
	gS
 = 
√w
 
FTy≥
(8, 24)

240 
vÆ
 
	gD
 = 
√w
 
FTy≥
(11, 53)

242 
vÆ
 
	gÆl
 = 
Li°
(
S
, 
D
)

245 
åaô
 
	gHasFPUP¨amëîs
 {

246 
ªquúe
(
fLí
 == 32 || fLen == 64)

247 
vÆ
 
fLí
: 
I¡


248 
def
 
xLí
: 
I¡


249 
vÆ
 
möXLí
 = 32

250 
vÆ
 
nI¡Ty≥s
 = 
log2Ceû
(
xLí
/
möXLí
) + 1

251 
vÆ
 
ÊﬂtTy≥s
 = 
FTy≥
.
Æl
.
fûãr
(
_
.
õìWidth
 <
fLí
)

252 
vÆ
 
möTy≥
 = 
ÊﬂtTy≥s
.
hód


253 
vÆ
 
maxTy≥
 = 
ÊﬂtTy≥s
.
œ°


254 
def
 
¥evTy≥
(
t
: 
FTy≥
Ë
ÊﬂtTy≥s
(
ty≥Tag
(t) - 1)

255 
vÆ
 
maxExpWidth
 = 
maxTy≥
.
exp


256 
vÆ
 
maxSigWidth
 = 
maxTy≥
.
sig


257 
def
 
ty≥Tag
(
t
: 
FTy≥
Ë
ÊﬂtTy≥s
.
ödexOf
(t)

259 
¥iv©e
 
def
 
isBox
(
x
: 
UI¡
, 
t
: 
FTy≥
): 
Boﬁ
 = x—.
sig
 +Å.
exp
,Å.sig +Å.ex∞- 4).
™dR


261 
¥iv©e
 
def
 
box
(
x
: 
UI¡
, 
xt
: 
FTy≥
, 
y
: UI¡, 
yt
: FType): UInt = {

262 
ªquúe
(
xt
.
õìWidth
 =2 * 
yt
.ieeeWidth)

263 
vÆ
 
swizzÀdNaN
 = 
C©
(

264 
x
(
xt
.
sig
 + xt.
exp
, xt.sig + xt.exp - 3),

265 
x
(
xt
.
sig
 - 2, 
yt
.
ªcodedWidth
 - 1).
™dR
,

266 
x
(
xt
.
sig
 + xt.
exp
 - 5, xt.sig),

267 
y
(
yt
.
ªcodedWidth
 - 2),

268 
x
(
xt
.
sig
 - 2, 
yt
.
ªcodedWidth
 - 1),

269 
y
(
yt
.
ªcodedWidth
 - 1),

270 
y
(
yt
.
ªcodedWidth
 - 3, 0))

271 
Mux
(
xt
.
isNaN
(
x
), 
swizzÀdNaN
, x)

275 
def
 
unbox
(
x
: 
UI¡
, 
èg
: UI¡, 
exa˘Ty≥
: 
O±i⁄
[
FTy≥
]): UInt = {

276 
vÆ
 
outTy≥
 = 
exa˘Ty≥
.
gëOrEl£
(
maxTy≥
)

277 
def
 
hñ≥r
(
x
: 
UI¡
, 
t
: 
FTy≥
): 
Seq
[(
Boﬁ
, UInt)] = {

278 
vÆ
 
¥ev
 =

279 i‡(
t
 =
möTy≥
) {

280 
Seq
()

282 
vÆ
 
¥evT
 = 
¥evTy≥
(
t
)

283 
vÆ
 
unswizzÀd
 = 
C©
(

284 
x
(
¥evT
.
sig
 +ÖªvT.
exp
 - 1),

285 
x
(
t
.
sig
 - 1),

286 
x
(
¥evT
.
sig
 +ÖªvT.
exp
 - 2, 0))

287 
vÆ
 
	g¥ev
 = 
hñ≥r
(
unswizzÀd
, 
¥evT
)

288 
vÆ
 
	gisbox
 = 
isBox
(
x
, 
t
)

289 
	g¥ev
.
m≠
(
p
 => (
isbox
 &&Ö.
_1
,Ö.
_2
))

291 
	g¥ev
 :+ (
åue
.
B
, 
	gt
.
unß„C⁄vît
(
x
, 
outTy≥
))

294 
vÆ
 (
oks
, 
Êﬂts
Ë
hñ≥r
(
x
, 
maxTy≥
).
unzù


295 i‡(
	gexa˘Ty≥
.
	gisEm±y
 || 
	gÊﬂtTy≥s
.
	gsize
 == 1) {

296 
Mux
(
oks
(
èg
), 
Êﬂts
—ag), 
maxTy≥
.
qNaN
)

298 
vÆ
 
t
 = 
exa˘Ty≥
.
gë


299 
Êﬂts
(
ty≥Tag
(
t
)Ë| 
Mux
(
oks
—y≥Tag—)), 0.U,Å.
qNaN
)

304 
def
 
c⁄si°ít
(
x
: 
UI¡
): 
Boﬁ
 = {

305 
def
 
hñ≥r
(
x
: 
UI¡
, 
t
: 
FTy≥
): 
Boﬁ
 = i‡(
ty≥Tag
—Ë=0Ë
åue
.
B
 {

306 
vÆ
 
¥evT
 = 
¥evTy≥
(
t
)

307 
vÆ
 
unswizzÀd
 = 
C©
(

308 
x
(
¥evT
.
sig
 +ÖªvT.
exp
 - 1),

309 
x
(
t
.
sig
 - 1),

310 
x
(
¥evT
.
sig
 +ÖªvT.
exp
 - 2, 0))

311 
vÆ
 
	g¥evOK
 = !
isBox
(
x
, 
t
Ë|| 
hñ≥r
(
unswizzÀd
, 
¥evT
)

312 
vÆ
 
	gcurOK
 = !
t
.
isNaN
(
x
Ë|| x—.
sig
 +Å.
exp
 - 4Ë==x—.sig - 2, 
¥evT
.
ªcodedWidth
 - 1).
™dR


313 
	g¥evOK
 && 
	gcurOK


315 
hñ≥r
(
x
, 
maxTy≥
)

319 
def
 
box
(
x
: 
UI¡
, 
t
: 
FTy≥
): UInt = {

320 i‡(
t
 =
maxTy≥
) {

321 
x


323 
vÆ
 
¡
 = 
ÊﬂtTy≥s
(
ty≥Tag
(
t
) + 1)

324 
vÆ
 
biggî
 = 
box
(
UI¡
((
BigI¡
(1Ë<< 
¡
.
ªcodedWidth
)-1),Çt, 
x
, 
t
)

325 
	gbiggî
 | 
UI¡
((
BigI¡
(1Ë<< 
maxTy≥
.
ªcodedWidth
Ë- (BigI¡(1Ë<< 
¡
.recodedWidth))

330 
def
 
box
(
x
: 
UI¡
, 
èg
: UInt): UInt = {

331 
vÆ
 
›ts
 = 
ÊﬂtTy≥s
.
m≠
(
t
 => 
box
(
x
,Å))

332 
›ts
(
èg
)

336 
def
 
ßnôizeNaN
(
x
: 
UI¡
, 
t
: 
FTy≥
): UInt = {

337 i‡(
ty≥Tag
(
t
) == 0) {

338 
x


340 
vÆ
 
maskedNaN
 = 
x
 & ~
UI¡
((
BigI¡
(1Ë<< (
t
.
sig
-1)Ë| (BigI¡(1Ë<< (t.sig+t.
exp
-4)),Å.
ªcodedWidth
)

341 
Mux
(
t
.
isNaN
(
x
), 
maskedNaN
, x)

346 
def
 
ªcode
(
x
: 
UI¡
, 
èg
: UInt): UInt = {

347 
def
 
hñ≥r
(
x
: 
UI¡
, 
t
: 
FTy≥
): UInt = {

348 i‡(
ty≥Tag
(
t
) == 0) {

349 
t
.
ªcode
(
x
)

351 
vÆ
 
¥evT
 = 
¥evTy≥
(
t
)

352 
box
(
t
.
ªcode
(
x
),Å, 
hñ≥r
(x, 
¥evT
),ÖrevT)

357 
vÆ
 
	gboxes
 = 
ÊﬂtTy≥s
.
m≠
(
t
 => 
UI¡
((
BigI¡
(1Ë<< 
maxTy≥
.
õìWidth
) - (BigInt(1) <<Å.ieeeWidth)))

358 
hñ≥r
(
boxes
(
èg
Ë| 
x
, 
maxTy≥
)

362 
def
 
õì
(
x
: 
UI¡
, 
t
: 
FTy≥
 = 
maxTy≥
): UInt = {

363 i‡(
ty≥Tag
(
t
) == 0) {

364 
t
.
õì
(
x
)

366 
vÆ
 
uƒecoded
 = 
t
.
õì
(
x
)

367 
vÆ
 
¥evT
 = 
¥evTy≥
(
t
)

368 
vÆ
 
¥evRecoded
 = 
C©
(

369 
x
(
¥evT
.
ªcodedWidth
-2),

370 
x
(
t
.
sig
-1),

371 
x
(
¥evT
.
ªcodedWidth
-3, 0))

372 
vÆ
 
	g¥evUƒecoded
 = 
õì
(
¥evRecoded
, 
¥evT
)

373 
C©
(
uƒecoded
 >> 
¥evT
.
õìWidth
, 
Mux
(
t
.
isNaN
(
x
), 
¥evUƒecoded
, unrecoded(prevT.ieeeWidth-1, 0)))

378 
ab°ø˘
 cœs†
	cFPUModuÀ
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eModuÀ
()(
p
Ë
wôh
 
HasFPUP¨amëîs


380 ˛as†
	cFPToI¡
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$FPUModuÀ
()(
p
Ë
wôh
 
ShouldBeRëimed
 {

381 ˛as†
	cOuçut
 
exãnds
 
BundÀ
 {

382 
vÆ
 
ö
 = 
√w
 
FPI≈ut


383 
vÆ
 
…
 = 
	`Boﬁ
()

384 
vÆ
 
°‹e
 = 
	`Bôs
(
width
 = 
fLí
)

385 
vÆ
 
toöt
 = 
	`Bôs
(
width
 = 
xLí
)

386 
vÆ
 
exc
 = 
	`Bôs
(
width
 = 
FPC⁄°™ts
.
FLAGS_SZ
)

387 
ovîride
 
def
 
˛⁄eTy≥
 = 
√w
 
	`Ouçut
().
asIn°™˚Of
[
this
.
ty≥
]

389 
vÆ
 
io
 = 
√w
 
BundÀ
 {

390 
vÆ
 
ö
 = 
	`VÆid
(
√w
 
FPI≈ut
).
Êù


391 
vÆ
 
out
 = 
	`VÆid
(
√w
 
Ouçut
)

392 
	}
}

394 
vÆ
 
ö
 = 
	$RegE«bÀ
(
io
.
ö
.
bôs
, io.ö.
vÆid
)

395 
vÆ
 
vÆid
 = 
	$Reg
(
√xt
=
io
.
ö
.
vÆid
)

397 
vÆ
 
dcmp
 = 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	$Com∑ªRecFN
(
maxExpWidth
, 
maxSigWidth
))

398 
dcmp
.
io
.
a
 :
ö
.
ö1


399 
dcmp
.
io
.
b
 :
ö
.
ö2


400 
dcmp
.
io
.
sig«lög
 :!
ö
.
	$rm
(1)

402 
vÆ
 
èg
 = !
ö
.
sögÀOut


403 
vÆ
 
°‹e
 = 
	$õì
(
ö
.
ö1
)

404 
vÆ
 
toöt
 = 
	$Wúe
(
öô
 = 
°‹e
)

405 
vÆ
 
ötTy≥
 = 
	$Wúe
(
öô
 = 
èg
)

406 
io
.
out
.
bôs
.
°‹e
 :(
ÊﬂtTy≥s
.
	`m≠
(
t
 => 
	`Fûl
(
maxTy≥
.
õìWidth
 /Å.õìWidth, 
	`°‹e
—.õìWidth - 1, 0))): 
Seq
[
UI¡
])(
èg
)

407 
io
.
out
.
bôs
.
toöt
 :((0 
u¡û
 
nI¡Ty≥s
).
	`m≠
(
i
 => 
	`toöt
((
möXLí
 << iË- 1, 0).
	$£xtTo
(
xLí
)): 
Seq
[
UI¡
])(
ötTy≥
)

408 
io
.
out
.
bôs
.
exc
 :
	$Bôs
(0)

410 
	`whí
 (
ö
.
	$rm
(0)) {

411 
vÆ
 
˛assify_out
 = (
ÊﬂtTy≥s
.
	`m≠
(
t
 =>Å.
	`˛assify
(
maxTy≥
.
	`unß„C⁄vît
(
ö
.
ö1
,Å))): 
Seq
[
UI¡
])(
èg
)

412 
toöt
 :
˛assify_out
 | (
°‹e
 >> 
möXLí
 << minXLen)

413 
ötTy≥
 := 0

414 
	}
}

416 
	$whí
 (
ö
.
wÊags
) {

417 
toöt
 :(~
ö
.
rm
 & 
	`C©
(
dcmp
.
io
.
…
, dcmp.io.
eq
)).
‹R
 | (
°‹e
 >> 
möXLí
 << minXLen)

418 
io
.
out
.
bôs
.
exc
 :
dcmp
.io.
ex˚±i⁄Fœgs


419 
ötTy≥
 := 0

421 
	`whí
 (!
ö
.
ªn2
) {

422 
vÆ
 
cvtTy≥
 = 
ö
.
typ
.
	`exåa˘
(
	`log2Ceû
(
nI¡Ty≥s
), 1)

423 
ötTy≥
 :
cvtTy≥


425 
vÆ
 
c⁄v
 = 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	`RecFNToIN
(
maxExpWidth
, 
maxSigWidth
, 
xLí
))

426 
c⁄v
.
io
.
ö
 :ö.
ö1


427 
c⁄v
.
io
.
roundögMode
 :
ö
.
rm


428 
c⁄v
.
io
.
sig√dOut
 :~
ö
.
	`typ
(0)

429 
toöt
 :
c⁄v
.
io
.
out


430 
io
.
out
.
bôs
.
exc
 :
	`C©
(
c⁄v
.io.
	`ötEx˚±i⁄Fœgs
(2, 1).
‹R
, 
	`UI¡
(0, 3), conv.io.intExceptionFlags(0))

432 
i
 <- 0 
u¡û
 
nI¡Ty≥s
-1) {

433 
vÆ
 
w
 = 
möXLí
 << 
i


434 
	`whí
 (
cvtTy≥
 ==
i
) {

435 
vÆ
 
«ºow
 = 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	`RecFNToIN
(
maxExpWidth
, 
maxSigWidth
, 
w
))

436 
«ºow
.
io
.
ö
 :ö.
ö1


437 
«ºow
.
io
.
roundögMode
 :
ö
.
rm


438 
«ºow
.
io
.
sig√dOut
 :~
ö
.
	`typ
(0)

440 
vÆ
 
excSign
 = 
ö
.
	`ö1
(
maxExpWidth
 + 
maxSigWidth
Ë&& !
maxTy≥
.
	`isNaN
(ö.
ö1
)

441 
vÆ
 
excOut
 = 
	`C©
(
c⁄v
.
io
.
sig√dOut
 ==
excSign
, 
	`Fûl
(
w
-1, !excSign))

442 
vÆ
 
övÆid
 = 
c⁄v
.
io
.
	`ötEx˚±i⁄Fœgs
(2Ë|| 
«ºow
.io.intExceptionFlags(1)

443 
	`whí
 (
övÆid
Ë{ 
toöt
 :
	`C©
(
c⁄v
.
io
.
out
 >> 
w
, 
excOut
) }

444 
io
.
out
.
bôs
.
exc
 :
	`C©
(
övÆid
, 
	`UI¡
(0, 3), !övÆid && 
c⁄v
.io.
	`ötEx˚±i⁄Fœgs
(0))

448 
	}
}

450 
	gio
.
	gout
.
	gvÆid
 :
vÆid


451 
io
.
out
.
bôs
.
…
 :
dcmp
.io.… || (dcmp.io.
a
.
asSI¡
 < 0.
S
 && dcmp.io.
b
.asSInt >= 0.S)

452 
io
.
out
.
bôs
.
ö
 := in

455 ˛as†
	cI¡ToFP
(
vÆ
 
œãncy
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$FPUModuÀ
()(
p
Ë
wôh
 
ShouldBeRëimed
 {

456 
vÆ
 
io
 = 
√w
 
BundÀ
 {

457 
vÆ
 
ö
 = 
	`VÆid
(
√w
 
I¡ToFPI≈ut
).
Êù


458 
vÆ
 
out
 = 
	`VÆid
(
√w
 
FPResu…
)

461 
vÆ
 
ö
 = 
	$Pùe
(
io
.
ö
)

462 
vÆ
 
èg
 = !
ö
.
bôs
.
sögÀIn


464 
vÆ
 
mux
 = 
	$Wúe
(
√w
 
FPResu…
)

465 
mux
.
exc
 :
	$Bôs
(0)

466 
mux
.
d©a
 :
	`ªcode
(
ö
.
bôs
.
ö1
, !ö.bôs.
sögÀIn
)

468 
vÆ
 
ötVÆue
 = {

469 
vÆ
 
ªs
 = 
	`Wúe
(
öô
 = 
ö
.
bôs
.
ö1
.
asSI¡
)

470 
i
 <- 0 
u¡û
 
nI¡Ty≥s
-1) {

471 
vÆ
 
smÆlI¡
 = 
ö
.
bôs
.
	`ö1
((
möXLí
 << 
i
) - 1, 0)

472 
	`whí
 (
ö
.
bôs
.
typ
.
	`exåa˘
(
	`log2Ceû
(
nI¡Ty≥s
), 1Ë==
i
) {

473 
ªs
 :
	`Mux
(
ö
.
bôs
.
	`typ
(0), 
smÆlI¡
.
zext
, smÆlI¡.
asSI¡
)

476 
ªs
.
asUI¡


477 
	}
}

479 
	$whí
 (
ö
.
bôs
.
wÊags
) {

482 
vÆ
 
i2fResu…s
 = 
t
 <- 
ÊﬂtTy≥s
Ë
yõld
 {

483 
vÆ
 
i2f
 = 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	`INToRecFN
(
xLí
, 
t
.
exp
,Å.
sig
))

484 
i2f
.
io
.
sig√dIn
 :~
ö
.
bôs
.
	`typ
(0)

485 
i2f
.
io
.
ö
 :
ötVÆue


486 
i2f
.
io
.
roundögMode
 :
ö
.
bôs
.
rm


487 
i2f
.
io
.
dëe˘Tööess
 :
h¨dÊﬂt
.
c⁄°s
.
tööess_a·îRoundög


488 (
	`ßnôizeNaN
(
i2f
.
io
.
out
, 
t
), i2f.io.
ex˚±i⁄Fœgs
)

491 
	`vÆ
 (
d©a
, 
exc
Ë
i2fResu…s
.
unzù


492 
vÆ
 
d©aPadded
 = 
d©a
.
öô
.
	`m≠
(
d
 => 
	`C©
(d©a.
œ°
 >> d.
gëWidth
, d)) :+ data.last

493 
mux
.
d©a
 :
	`d©aPadded
(
èg
)

494 
mux
.
exc
 :
	`exc
(
èg
)

495 
	}
}

497 
io
.
out
 <> 
Pùe
(
ö
.
vÆid
, 
mux
, 
œãncy
-1)

500 ˛as†
	cFPToFP
(
vÆ
 
œãncy
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$FPUModuÀ
()(
p
Ë
wôh
 
ShouldBeRëimed
 {

501 
vÆ
 
io
 = 
√w
 
BundÀ
 {

502 
vÆ
 
ö
 = 
	`VÆid
(
√w
 
FPI≈ut
).
Êù


503 
vÆ
 
out
 = 
	`VÆid
(
√w
 
FPResu…
)

504 
vÆ
 
…
 = 
	`Boﬁ
(
INPUT
)

507 
vÆ
 
ö
 = 
	$Pùe
(
io
.
ö
)

509 
vÆ
 
signNum
 = 
	`Mux
(
ö
.
bôs
.
	`rm
(1), in.bôs.
ö1
 ^ in.bôs.
ö2
, Mux(in.bits.rm(0), ~in.bits.in2, in.bits.in2))

510 
vÆ
 
fsgnj
 = 
	`C©
(
	`signNum
(
fLí
), 
ö
.
bôs
.
	`ö1
(fLen-1, 0))

512 
vÆ
 
fsgnjMux
 = 
	$Wúe
(
√w
 
FPResu…
)

513 
fsgnjMux
.
exc
 :
	$UI¡
(0)

514 
fsgnjMux
.
d©a
 :
fsgnj


516 
	$whí
 (
ö
.
bôs
.
wÊags
) {

517 
vÆ
 
i¢™1
 = 
maxTy≥
.
	`isNaN
(
ö
.
bôs
.
ö1
)

518 
vÆ
 
i¢™2
 = 
maxTy≥
.
	`isNaN
(
ö
.
bôs
.
ö2
)

519 
vÆ
 
isInvÆid
 = 
maxTy≥
.
	`isSNaN
(
ö
.
bôs
.
ö1
Ë|| maxTy≥.isSNaN(ö.bôs.
ö2
)

520 
vÆ
 
isNaNOut
 = 
i¢™1
 && 
i¢™2


521 
vÆ
 
isLHS
 = 
i¢™2
 || 
ö
.
bôs
.
	`rm
(0Ë=/
io
.
…
 && !
i¢™1


522 
fsgnjMux
.
exc
 :
isInvÆid
 << 4

523 
fsgnjMux
.
d©a
 :
	`Mux
(
isNaNOut
, 
maxTy≥
.
qNaN
, Mux(
isLHS
, 
ö
.
bôs
.
ö1
, in.bôs.
ö2
))

524 
	}
}

526 
vÆ
 
	göTag
 = !
ö
.
bôs
.
sögÀIn


527 
vÆ
 
outTag
 = !
ö
.
bôs
.
sögÀOut


528 
vÆ
 
mux
 = 
	$Wúe
(
öô
 = 
fsgnjMux
)

529 
t
 <- 
ÊﬂtTy≥s
.
öô
) {

530 
	`whí
 (
outTag
 ==
	`ty≥Tag
(
t
)) {

531 
mux
.
d©a
 :
	`C©
(
fsgnjMux
.d©®>> 
t
.
ªcodedWidth
, 
maxTy≥
.
	`unß„C⁄vît
(fsgnjMux.data,Å))

533 
	}
}

535 
whí
 (
ö
.
bôs
.
wÊags
 && !ö.bôs.
ªn2
) {

536 i‡(
	gÊﬂtTy≥s
.
	gsize
 > 1) {

538 
vÆ
 
	gwidíed
 = 
Mux
(
maxTy≥
.
isNaN
(
ö
.
bôs
.
ö1
), maxTy≥.
qNaN
, in.bits.in1)

539 
	gfsgnjMux
.
	gd©a
 :
widíed


540 
fsgnjMux
.
exc
 :
maxTy≥
.
isSNaN
(
ö
.
bôs
.
ö1
) << 4

545 
outTy≥
 <- 
ÊﬂtTy≥s
.
öô
Ë
whí
 (
outTag
 ==
ty≥Tag
(outTy≥Ë&& (ty≥Tag(outTy≥Ë=0 || outTag < 
öTag
)) {

546 
vÆ
 
«ºowî
 = 
ModuÀ
(
√w
 
h¨dÊﬂt
.
RecFNToRecFN
(
maxTy≥
.
exp
, maxTy≥.
sig
, 
outTy≥
.exp, outType.sig))

547 
	g«ºowî
.
	gio
.
	gö
 :
ö
.
bôs
.
ö1


548 
«ºowî
.
io
.
roundögMode
 :
ö
.
bôs
.
rm


549 
«ºowî
.
io
.
dëe˘Tööess
 :
h¨dÊﬂt
.
c⁄°s
.
tööess_a·îRoundög


550 
vÆ
 
«ºowed
 = 
ßnôizeNaN
(
«ºowî
.
io
.
out
, 
outTy≥
)

551 
	gmux
.
	gd©a
 :
C©
(
fsgnjMux
.
d©a
 >> 
«ºowed
.
gëWidth
,Çarrowed)

552 
	gmux
.
	gexc
 :
«ºowî
.
io
.
ex˚±i⁄Fœgs


557 
io
.
out
 <> 
Pùe
(
ö
.
vÆid
, 
mux
, 
œãncy
-1)

560 
˛ass
 
	$MulAddRecFNPùe
(
œãncy
: 
I¡
, 
expWidth
: I¡, 
sigWidth
: I¡Ë
exãnds
 
ModuÀ


562 
	`ªquúe
(
œãncy
<=2)

564 
vÆ
 
io
 = 
√w
 
BundÀ
 {

565 
vÆ
 
vÆidö
 = 
	`Boﬁ
(
INPUT
)

566 
vÆ
 
›
 = 
	`Bôs
(
INPUT
, 2)

567 
vÆ
 
a
 = 
	`Bôs
(
INPUT
, 
expWidth
 + 
sigWidth
 + 1)

568 
vÆ
 
b
 = 
	`Bôs
(
INPUT
, 
expWidth
 + 
sigWidth
 + 1)

569 
vÆ
 
c
 = 
	`Bôs
(
INPUT
, 
expWidth
 + 
sigWidth
 + 1)

570 
vÆ
 
roundögMode
 = 
	`UI¡
(
INPUT
, 3)

571 
vÆ
 
dëe˘Tööess
 = 
	`UI¡
(
INPUT
, 1)

572 
vÆ
 
out
 = 
	`Bôs
(
OUTPUT
, 
expWidth
 + 
sigWidth
 + 1)

573 
vÆ
 
ex˚±i⁄Fœgs
 = 
	`Bôs
(
OUTPUT
, 5)

574 
vÆ
 
vÆidout
 = 
	`Boﬁ
(
OUTPUT
)

579 
vÆ
 
mulAddRecFNToRaw_¥eMul
 =

580 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	`MulAddRecFNToRaw_¥eMul
(
expWidth
, 
sigWidth
))

581 
vÆ
 
mulAddRecFNToRaw_po°Mul
 =

582 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	`MulAddRecFNToRaw_po°Mul
(
expWidth
, 
sigWidth
))

584 
mulAddRecFNToRaw_¥eMul
.
io
.
›
 := io.op

585 
mulAddRecFNToRaw_¥eMul
.
io
.
a
 := io.a

586 
mulAddRecFNToRaw_¥eMul
.
io
.
b
 := io.b

587 
mulAddRecFNToRaw_¥eMul
.
io
.
c
 := io.c

589 
vÆ
 
mulAddResu…
 =

590 (
mulAddRecFNToRaw_¥eMul
.
io
.
mulAddA
 *

591 
mulAddRecFNToRaw_¥eMul
.
io
.
mulAddB
) +&

592 
mulAddRecFNToRaw_¥eMul
.
io
.
mulAddC


594 
vÆ
 
vÆid_°age0
 = 
	`Wúe
(
	`Boﬁ
())

595 
vÆ
 
roundögMode_°age0
 = 
	`Wúe
(
	`UI¡
(
width
=3))

596 
vÆ
 
dëe˘Tööess_°age0
 = 
	`Wúe
(
	`UI¡
(
width
=1))

598 
vÆ
 
po°mul_ªgs
 = if(
œãncy
>0) 1 0

599 
mulAddRecFNToRaw_po°Mul
.
io
.
‰omPªMul
 :
	`Pùe
(io.
vÆidö
, 
mulAddRecFNToRaw_¥eMul
.io.
toPo°Mul
, 
po°mul_ªgs
).
bôs


600 
mulAddRecFNToRaw_po°Mul
.
io
.
mulAddResu…
 :
	`Pùe
(io.
vÆidö
, mulAddResu…, 
po°mul_ªgs
).
bôs


601 
mulAddRecFNToRaw_po°Mul
.
io
.
roundögMode
 :
	`Pùe
(io.
vÆidö
, io.roundögMode, 
po°mul_ªgs
).
bôs


602 
roundögMode_°age0
 :
	`Pùe
(
io
.
vÆidö
, io.
roundögMode
, 
po°mul_ªgs
).
bôs


603 
dëe˘Tööess_°age0
 :
	`Pùe
(
io
.
vÆidö
, io.
dëe˘Tööess
, 
po°mul_ªgs
).
bôs


604 
vÆid_°age0
 :
	`Pùe
(
io
.
vÆidö
, 
Ál£
.
B
, 
po°mul_ªgs
).
vÆid


608 
vÆ
 
roundRawFNToRecFN
 = 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	`RoundRawFNToRecFN
(
expWidth
, 
sigWidth
, 0))

610 
vÆ
 
round_ªgs
 = if(
œãncy
==2) 1 0

611 
roundRawFNToRecFN
.
io
.
övÆidExc
 :
	`Pùe
(
vÆid_°age0
, 
mulAddRecFNToRaw_po°Mul
.io.övÆidExc, 
round_ªgs
).
bôs


612 
roundRawFNToRecFN
.
io
.
ö
 :
	`Pùe
(
vÆid_°age0
, 
mulAddRecFNToRaw_po°Mul
.io.
øwOut
, 
round_ªgs
).
bôs


613 
roundRawFNToRecFN
.
io
.
roundögMode
 :
	`Pùe
(
vÆid_°age0
, 
roundögMode_°age0
, 
round_ªgs
).
bôs


614 
roundRawFNToRecFN
.
io
.
dëe˘Tööess
 :
	`Pùe
(
vÆid_°age0
, 
dëe˘Tööess_°age0
, 
round_ªgs
).
bôs


615 
io
.
vÆidout
 :
	`Pùe
(
vÆid_°age0
, 
Ál£
.
B
, 
round_ªgs
).
vÆid


617 
roundRawFNToRecFN
.
io
.
öföôeExc
 :
	`Boﬁ
(
Ál£
)

619 
io
.
out
 :
roundRawFNToRecFN
.io.out

620 
io
.
ex˚±i⁄Fœgs
 :
roundRawFNToRecFN
.io.exceptionFlags

621 
	}
}

623 
˛ass
 
	$FPUFMAPùe
(
vÆ
 
œãncy
: 
I¡
, vÆ 
t
: 
FTy≥
)

624 (
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$FPUModuÀ
()(
p
Ë
wôh
 
ShouldBeRëimed
 {

625 
	`ªquúe
(
œãncy
>0)

627 
vÆ
 
io
 = 
√w
 
BundÀ
 {

628 
vÆ
 
ö
 = 
	`VÆid
(
√w
 
FPI≈ut
).
Êù


629 
vÆ
 
out
 = 
	`VÆid
(
√w
 
FPResu…
)

632 
vÆ
 
vÆid
 = 
	`Reg
(
√xt
=
io
.
ö
.valid)

633 
vÆ
 
ö
 = 
	`Reg
(
√w
 
FPI≈ut
)

634 
	`whí
 (
io
.
ö
.
vÆid
) {

635 
vÆ
 
⁄e
 = 
	`UI¡
(1Ë<< (
t
.
sig
 +Å.
exp
 - 1)

636 
vÆ
 
zîo
 = (
io
.
ö
.
bôs
.
ö1
 ^ io.ö.bôs.
ö2
Ë& (
	`UI¡
(1Ë<< (
t
.
sig
 +Å.
exp
))

637 
vÆ
 
cmd_fma
 = 
io
.
ö
.
bôs
.
ªn3


638 
vÆ
 
cmd_addsub
 = 
io
.
ö
.
bôs
.
sw≠23


639 
ö
 :
io
.ö.
bôs


640 
	`whí
 (
cmd_addsub
Ë{ 
ö
.
ö2
 :
⁄e
 }

641 
	`whí
 (!(
cmd_fma
 || 
cmd_addsub
)Ë{ 
ö
.
ö3
 :
zîo
 }

644 
vÆ
 
fma
 = 
	`ModuÀ
(
√w
 
	`MulAddRecFNPùe
((
œãncy
-1Ë
mö
 2, 
t
.
exp
,Å.
sig
))

645 
fma
.
io
.
vÆidö
 :
vÆid


646 
fma
.
io
.
›
 :
ö
.
fmaCmd


647 
fma
.
io
.
roundögMode
 :
ö
.
rm


648 
fma
.
io
.
dëe˘Tööess
 :
h¨dÊﬂt
.
c⁄°s
.
tööess_a·îRoundög


649 
fma
.
io
.
a
 :
ö
.
ö1


650 
fma
.
io
.
b
 :
ö
.
ö2


651 
fma
.
io
.
c
 :
ö
.
ö3


653 
vÆ
 
ªs
 = 
	`Wúe
(
√w
 
FPResu…
)

654 
ªs
.
d©a
 :
	`ßnôizeNaN
(
fma
.
io
.
out
, 
t
)

655 
ªs
.
exc
 :
fma
.
io
.
ex˚±i⁄Fœgs


657 
io
.
out
 :
	`Pùe
(
fma
.io.
vÆidout
, 
ªs
, (
œãncy
-3Ë
max
 0)

658 
	}
}

660 @
chi£lName


661 ˛as†
	cFPU
(
cfg
: 
FPUP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$FPUModuÀ
()(
p
) {

662 
vÆ
 
io
 = 
√w
 
FPUIO


664 
vÆ
 
u£ClockG©ög
 = 
c‹eP¨ams
 
m©ch
 {

665 
r
: 
RockëC‹eP¨ams
 =>Ñ.
˛ockG©e


666 
_
 => 
Ál£


668 
vÆ
 
˛ock_í_ªg
 = 
	`Reg
(
	$Boﬁ
())

669 
vÆ
 
˛ock_í
 = 
˛ock_í_ªg
 || 
io
.
˝_ªq
.
vÆid


670 
vÆ
 
g©ed_˛ock
 =

671 i‡(!
u£ClockG©ög
Ë
˛ock


672 
	`ClockG©e
(
˛ock
, 
˛ock_í
, "fpu_clock_gate")

674 
vÆ
 
Â_decodî
 = 
	$ModuÀ
(
√w
 
FPUDecodî
)

675 
Â_decodî
.
io
.
ö°
 := io.inst

676 
vÆ
 
id_˘æ
 = 
Â_decodî
.
io
.
sigs


678 
vÆ
 
ex_ªg_vÆid
 = 
	`Reg
(
√xt
=
io
.
vÆid
, 
öô
=
	$Boﬁ
(
Ál£
))

679 
vÆ
 
ex_ªg_ö°
 = 
	$RegE«bÀ
(
io
.
ö°
, io.
vÆid
)

680 
vÆ
 
ex_ªg_˘æ
 = 
	$RegE«bÀ
(
id_˘æ
, 
io
.
vÆid
)

681 
vÆ
 
ex_ø
 = 
Li°
.
	$fûl
(3)(
	`Reg
(
	$UI¡
()))

683 
	$wôhClock
 (
g©ed_˛ock
) {

685 
vÆ
 
ªq_vÆid
 = 
ex_ªg_vÆid
 || 
io
.
˝_ªq
.
vÆid


686 
vÆ
 
ex_˝_vÆid
 = 
io
.
˝_ªq
.
	`fúe
()

687 
vÆ
 
mem_˝_vÆid
 = 
	`Reg
(
√xt
=
ex_˝_vÆid
, 
öô
=
	`Boﬁ
(
Ál£
))

688 
vÆ
 
wb_˝_vÆid
 = 
	`Reg
(
√xt
=
mem_˝_vÆid
, 
öô
=
	`Boﬁ
(
Ál£
))

689 
vÆ
 
mem_ªg_vÆid
 = 
	`RegInô
(
Ál£
.
B
)

690 
vÆ
 
kûlm
 = (
io
.kûlm || io.
«ck_mem
Ë&& !
mem_˝_vÆid


694 
vÆ
 
kûlx
 = 
io
.kûlx || 
mem_ªg_vÆid
 && 
kûlm


695 
mem_ªg_vÆid
 :
ex_ªg_vÆid
 && !
kûlx
 || 
ex_˝_vÆid


696 
vÆ
 
mem_ªg_ö°
 = 
	`RegE«bÀ
(
ex_ªg_ö°
, 
ex_ªg_vÆid
)

697 
vÆ
 
wb_ªg_vÆid
 = 
	`Reg
(
√xt
=
mem_ªg_vÆid
 && (!
kûlm
 || 
mem_˝_vÆid
), 
öô
=
	`Boﬁ
(
Ál£
))

699 
vÆ
 
˝_˘æ
 = 
	`Wúe
(
√w
 
FPUCålSigs
)

700 
˝_˘æ
 <> 
io
.
˝_ªq
.
bôs


701 
io
.
˝_ª•
.
vÆid
 :
	`Boﬁ
(
Ál£
)

702 
io
.
˝_ª•
.
bôs
.
d©a
 :
	`UI¡
(0)

704 
vÆ
 
ex_˘æ
 = 
	`Mux
(
ex_˝_vÆid
, 
˝_˘æ
, 
ex_ªg_˘æ
)

705 
vÆ
 
mem_˘æ
 = 
	`RegE«bÀ
(
ex_˘æ
, 
ªq_vÆid
)

706 
vÆ
 
wb_˘æ
 = 
	`RegE«bÀ
(
mem_˘æ
, 
mem_ªg_vÆid
)

709 
vÆ
 
lﬂd_wb
 = 
	`Reg
(
√xt
=
io
.
dmem_ª•_vÆ
)

710 
vÆ
 
lﬂd_wb_doubÀ
 = 
	`RegE«bÀ
(
io
.
	`dmem_ª•_ty≥
(0), io.
dmem_ª•_vÆ
)

711 
vÆ
 
lﬂd_wb_d©a
 = 
	`RegE«bÀ
(
io
.
dmem_ª•_d©a
, io.
dmem_ª•_vÆ
)

712 
vÆ
 
lﬂd_wb_èg
 = 
	`RegE«bÀ
(
io
.
dmem_ª•_èg
, io.
dmem_ª•_vÆ
)

715 
vÆ
 
ªgfûe
 = 
	`Mem
(32, 
	`Bôs
(
width
 = 
fLí
+1))

716 
	`whí
 (
lﬂd_wb
) {

717 
vÆ
 
wd©a
 = 
	`ªcode
(
lﬂd_wb_d©a
, 
lﬂd_wb_doubÀ
)

718 
	`ªgfûe
(
lﬂd_wb_èg
Ë:
wd©a


719 
	`as£π
(
	`c⁄si°ít
(
wd©a
))

720 i‡(
íabÀCommôLog
)

721 
	`¥ötf
("f%dÖ%d 0x%x\n", 
lﬂd_wb_èg
,Üﬂd_wb_èg + 32, 
lﬂd_wb_d©a
)

724 
vÆ
 
ex_rs
 = 
ex_ø
.
	`m≠
(
a
 => 
	`ªgfûe
(a))

725 
	`whí
 (
io
.
vÆid
) {

726 
	`whí
 (
id_˘æ
.
ªn1
) {

727 
	`whí
 (!
id_˘æ
.
sw≠12
Ë{ 
	`ex_ø
(0Ë:
io
.
	`ö°
(19,15) }

728 
	`whí
 (
id_˘æ
.
sw≠12
Ë{ 
	`ex_ø
(1Ë:
io
.
	`ö°
(19,15) }

730 
	`whí
 (
id_˘æ
.
ªn2
) {

731 
	`whí
 (
id_˘æ
.
sw≠12
Ë{ 
	`ex_ø
(0Ë:
io
.
	`ö°
(24,20) }

732 
	`whí
 (
id_˘æ
.
sw≠23
Ë{ 
	`ex_ø
(2Ë:
io
.
	`ö°
(24,20) }

733 
	`whí
 (!
id_˘æ
.
sw≠12
 && !id_˘æ.
sw≠23
Ë{ 
	`ex_ø
(1Ë:
io
.
	`ö°
(24,20) }

735 
	`whí
 (
id_˘æ
.
ªn3
Ë{ 
	`ex_ø
(2Ë:
io
.
	`ö°
(31,27) }

737 
vÆ
 
ex_rm
 = 
	`Mux
(
	`ex_ªg_ö°
(14,12Ë==
	`Bôs
(7), 
io
.
fc§_rm
,Éx_reg_inst(14,12))

739 
def
 
	`fuI≈ut
(
möT
: 
O±i⁄
[
FTy≥
]): 
FPI≈ut
 = {

740 
vÆ
 
ªq
 = 
	`Wúe
(
√w
 
FPI≈ut
)

741 
vÆ
 
èg
 = !
ex_˘æ
.
sögÀIn


742 
ªq
 :
ex_˘æ


743 
ªq
.
rm
 :
ex_rm


744 
ªq
.
ö1
 :
	`unbox
(
	`ex_rs
(0), 
èg
, 
möT
)

745 
ªq
.
ö2
 :
	`unbox
(
	`ex_rs
(1), 
èg
, 
möT
)

746 
ªq
.
ö3
 :
	`unbox
(
	`ex_rs
(2), 
èg
, 
möT
)

747 
ªq
.
typ
 :
	`ex_ªg_ö°
(21,20)

748 
ªq
.
fmaCmd
 :
	`ex_ªg_ö°
(3,2Ë| (!
ex_˘æ
.
ªn3
 &&Éx_reg_inst(27))

749 
	`whí
 (
ex_˝_vÆid
) {

750 
ªq
 :
io
.
˝_ªq
.
bôs


751 
	`whí
 (
io
.
˝_ªq
.
bôs
.
sw≠23
) {

752 
ªq
.
ö2
 :
io
.
˝_ªq
.
bôs
.
ö3


753 
ªq
.
ö3
 :
io
.
˝_ªq
.
bôs
.
ö2


756 
ªq


759 
vÆ
 
sfma
 = 
	`ModuÀ
(
√w
 
	`FPUFMAPùe
(
cfg
.
sfmaL©ícy
, 
FTy≥
.
S
))

760 
sfma
.
io
.
ö
.
vÆid
 :
ªq_vÆid
 && 
ex_˘æ
.
fma
 &&Éx_˘æ.
sögÀOut


761 
sfma
.
io
.
ö
.
bôs
 :
	`fuI≈ut
(
	`Some
(sfma.
t
))

763 
vÆ
 
Âiu
 = 
	`ModuÀ
(
√w
 
FPToI¡
)

764 
Âiu
.
io
.
ö
.
vÆid
 :
ªq_vÆid
 && (
ex_˘æ
.
toöt
 ||Éx_˘æ.
div
 ||Éx_˘æ.
sqπ
 || (ex_˘æ.
Á°pùe
 &&Éx_˘æ.
wÊags
))

765 
Âiu
.
io
.
ö
.
bôs
 :
	`fuI≈ut
(
N⁄e
)

766 
io
.
°‹e_d©a
 :
Âiu
.io.
out
.
bôs
.
°‹e


767 
io
.
toöt_d©a
 :
Âiu
.io.
out
.
bôs
.
toöt


768 
	`whí
(
Âiu
.
io
.
out
.
vÆid
 && 
mem_˝_vÆid
 && 
mem_˘æ
.
toöt
){

769 
io
.
˝_ª•
.
bôs
.
d©a
 :
Âiu
.io.
out
.bôs.
toöt


770 
io
.
˝_ª•
.
vÆid
 :
	`Boﬁ
(
åue
)

773 
vÆ
 
iÂu
 = 
	`ModuÀ
(
√w
 
	`I¡ToFP
(2))

774 
iÂu
.
io
.
ö
.
vÆid
 :
ªq_vÆid
 && 
ex_˘æ
.
‰omöt


775 
iÂu
.
io
.
ö
.
bôs
 :
Âiu
.io.in.bits

776 
iÂu
.
io
.
ö
.
bôs
.
ö1
 :
	`Mux
(
ex_˝_vÆid
, io.
˝_ªq
.bôs.ö1, io.
‰omöt_d©a
)

778 
vÆ
 
Âmu
 = 
	`ModuÀ
(
√w
 
	`FPToFP
(2))

779 
Âmu
.
io
.
ö
.
vÆid
 :
ªq_vÆid
 && 
ex_˘æ
.
Á°pùe


780 
Âmu
.
io
.
ö
.
bôs
 :
Âiu
.io.in.bits

781 
Âmu
.
io
.
…
 :
Âiu
.io.
out
.
bôs
.lt

783 
vÆ
 
divSqπ_wí
 = 
	`Wúe
(
öô
 = 
Ál£
.
B
)

784 
vÆ
 
divSqπ_öFlight
 = 
	`Wúe
(
öô
 = 
Ál£
.
B
)

785 
vÆ
 
divSqπ_waddr
 = 
	`Reg
(
	`UI¡
(
width
 = 5))

786 
vÆ
 
divSqπ_ty≥Tag
 = 
	`Wúe
(
	`UI¡
(
width
 = 
	`log2Up
(
ÊﬂtTy≥s
.
size
)))

787 
vÆ
 
divSqπ_wd©a
 = 
	`Wúe
(
	`UI¡
(
width
 = 
fLí
+1))

788 
vÆ
 
divSqπ_Êags
 = 
	`Wúe
(
	`UI¡
(
width
 = 
FPC⁄°™ts
.
FLAGS_SZ
))

791 
˛ass
 
	`Pùe
(
p
: 
ModuÀ
, 
œt
: 
I¡
, 
c⁄d
: (
FPUCålSigs
Ë=> 
Boﬁ
, 
ªs
: 
FPResu…
)

792 
vÆ
 
pùes
 = 
	`Li°
(

793 
	`Pùe
(
Âmu
, fpmu.
œãncy
, (
c
: 
FPUCålSigs
Ë=> c.
Á°pùe
, fpmu.
io
.
out
.
bôs
),

794 
	`Pùe
(
iÂu
, iÂu.
œãncy
, (
c
: 
FPUCålSigs
Ë=> c.
‰omöt
, iÂu.
io
.
out
.
bôs
),

795 
	`Pùe
(
sfma
, sfma.
œãncy
, (
c
: 
FPUCålSigs
Ë=> c.
fma
 && c.
sögÀOut
, sfma.
io
.
out
.
bôs
)) ++

796 (
fLí
 > 32).
	`›ti⁄
({

797 
vÆ
 
dfma
 = 
	`ModuÀ
(
√w
 
	`FPUFMAPùe
(
cfg
.
dfmaL©ícy
, 
FTy≥
.
D
))

798 
dfma
.
io
.
ö
.
vÆid
 :
ªq_vÆid
 && 
ex_˘æ
.
fma
 && !ex_˘æ.
sögÀOut


799 
dfma
.
io
.
ö
.
bôs
 :
	`fuI≈ut
(
	`Some
(dfma.
t
))

800 
	`Pùe
(
dfma
, dfma.
œãncy
, (
c
: 
FPUCålSigs
Ë=> c.
fma
 && !c.
sögÀOut
, dfma.
io
.
out
.
bôs
)

802 
def
 
	`œãncyMask
(
c
: 
FPUCålSigs
, 
off£t
: 
I¡
) = {

803 
	`ªquúe
(
pùes
.
	`f‹Æl
(
_
.
œt
 >
off£t
))

804 
pùes
.
	`m≠
(
p
 => 
	`Mux
’.
	`c⁄d
(
c
), 
	`UI¡
(1 <<Ö.
œt
-
off£t
), UI¡(0))).
	`ªdu˚
(
_
|_)

806 
def
 
	`pùeid
(
c
: 
FPUCålSigs
Ë
pùes
.
zùWôhIndex
.
	`m≠
(
p
 => 
	`Mux
’.
_1
.
	`c⁄d
(c), 
	`UI¡
’.
_2
), UI¡(0))).
	`ªdu˚
(
_
|_)

807 
vÆ
 
maxL©ícy
 = 
pùes
.
	`m≠
(
_
.
œt
).
max


808 
vÆ
 
memL©ícyMask
 = 
	`œãncyMask
(
mem_˘æ
, 2)

810 ˛as†
	cWBInfo
 
exãnds
 
BundÀ
 {

811 
vÆ
 
rd
 = 
	`UI¡
(
width
 = 5)

812 
vÆ
 
sögÀ
 = 
	`Boﬁ
()

813 
vÆ
 
˝
 = 
	`Boﬁ
()

814 
vÆ
 
pùeid
 = 
	`UI¡
(
width
 = 
	`log2Ceû
(
pùes
.
size
))

815 
ovîride
 
def
 
˛⁄eTy≥
: 
this
.
ty≥
 = 
√w
 
	`WBInfo
().
asIn°™˚Of
[this.type]

818 
vÆ
 
wí
 = 
	`Reg
(
öô
=
	`Bôs
(0, 
maxL©ícy
-1))

819 
vÆ
 
wbInfo
 = 
	`Reg
(
	`Vec
(
maxL©ícy
-1, 
√w
 
WBInfo
))

820 
vÆ
 
mem_wí
 = 
mem_ªg_vÆid
 && (
mem_˘æ
.
fma
 || mem_˘æ.
Á°pùe
 || mem_˘æ.
‰omöt
)

821 
vÆ
 
wrôe_p‹t_busy
 = 
	`RegE«bÀ
(
mem_wí
 && (
memL©ícyMask
 & 
	`œãncyMask
(
ex_˘æ
, 1)).
‹R
 || (
wí
 &Ü©ícyMask”x_˘æ, 0)).‹R, 
ªq_vÆid
)

822 
	`ccovî
(
mem_ªg_vÆid
 && 
wrôe_p‹t_busy
, "WB_STRUCTURAL", "structural hazard on writeback")

824 
i
 <- 0 
u¡û
 
maxL©ícy
-2) {

825 
	`whí
 (
	`wí
(
i
+1)Ë{ 
	`wbInfo
(i) := wbInfo(i+1) }

827 
wí
 := wen >> 1

828 
	`whí
 (
mem_wí
) {

829 
	`whí
 (!
kûlm
) {

830 
wí
 :wí >> 1 | 
memL©ícyMask


832 
i
 <- 0 
u¡û
 
maxL©ícy
-1) {

833 
	`whí
 (!
wrôe_p‹t_busy
 && 
	`memL©ícyMask
(
i
)) {

834 
	`wbInfo
(
i
).
˝
 :
mem_˝_vÆid


835 
	`wbInfo
(
i
).
sögÀ
 :
mem_˘æ
.
sögÀOut


836 
	`wbInfo
(
i
).
pùeid
 :
	`pùeid
(
mem_˘æ
)

837 
	`wbInfo
(
i
).
rd
 :
	`mem_ªg_ö°
(11,7)

842 
vÆ
 
waddr
 = 
	`Mux
(
divSqπ_wí
, 
divSqπ_waddr
, 
	`wbInfo
(0).
rd
)

843 
vÆ
 
wdoubÀ
 = 
	`Mux
(
divSqπ_wí
, 
divSqπ_ty≥Tag
, !
	`wbInfo
(0).
sögÀ
)

844 
vÆ
 
wd©a
 = 
	`box
(
	`Mux
(
divSqπ_wí
, 
divSqπ_wd©a
, (
pùes
.
	`m≠
(
_
.
ªs
.
d©a
): 
Seq
[
UI¡
])(
	`wbInfo
(0).
pùeid
)), 
wdoubÀ
)

845 
vÆ
 
wexc
 = (
pùes
.
	`m≠
(
_
.
ªs
.
exc
): 
Seq
[
UI¡
])(
	`wbInfo
(0).
pùeid
)

846 
	`whí
 ((!
	`wbInfo
(0).
˝
 && 
	`wí
(0)Ë|| 
divSqπ_wí
) {

847 
	`as£π
(
	`c⁄si°ít
(
wd©a
))

848 
	`ªgfûe
(
waddr
Ë:
wd©a


849 i‡(
íabÀCommôLog
) {

850 
	`¥ötf
("f%dÖ%d 0x%x\n", 
waddr
, wadd∏+ 32, 
	`õì
(
wd©a
))

853 
	`whí
 (
	`wbInfo
(0).
˝
 && 
	`wí
(0)) {

854 
io
.
˝_ª•
.
bôs
.
d©a
 :
wd©a


855 
io
.
˝_ª•
.
vÆid
 :
	`Boﬁ
(
åue
)

857 
io
.
˝_ªq
.
ªady
 :!
ex_ªg_vÆid


859 
vÆ
 
wb_toöt_vÆid
 = 
wb_ªg_vÆid
 && 
wb_˘æ
.
toöt


860 
vÆ
 
wb_toöt_exc
 = 
	`RegE«bÀ
(
Âiu
.
io
.
out
.
bôs
.
exc
, 
mem_˘æ
.
toöt
)

861 
io
.
fc§_Êags
.
vÆid
 :
wb_toöt_vÆid
 || 
divSqπ_wí
 || 
	`wí
(0)

862 
io
.
fc§_Êags
.
bôs
 :=

863 
	`Mux
(
wb_toöt_vÆid
, 
wb_toöt_exc
, 
	`UI¡
(0)) |

864 
	`Mux
(
divSqπ_wí
, 
divSqπ_Êags
, 
	`UI¡
(0)) |

865 
	`Mux
(
	`wí
(0), 
wexc
, 
	`UI¡
(0))

867 
vÆ
 
divSqπ_wrôe_p‹t_busy
 = (
mem_˘æ
.
div
 || mem_˘æ.
sqπ
Ë&& 
wí
.
‹R


868 
io
.
fc§_rdy
 :!(
ex_ªg_vÆid
 && 
ex_˘æ
.
wÊags
 || 
mem_ªg_vÆid
 && 
mem_˘æ
.wÊag†|| 
wb_ªg_vÆid
 && 
wb_˘æ
.
toöt
 || 
wí
.
‹R
 || 
divSqπ_öFlight
)

869 
io
.
«ck_mem
 :
wrôe_p‹t_busy
 || 
divSqπ_wrôe_p‹t_busy
 || 
divSqπ_öFlight


870 
io
.
dec
 <> 
Â_decodî
.io.
sigs


871 
def
 
	`u£Sc‹ebﬂrd
(
f
: ((
Pùe
, 
I¡
)Ë=> 
Boﬁ
Ë
pùes
.
zùWôhIndex
.
	`fûãr
(
_
.
_1
.
œt
 > 3).
	`m≠
(
x
 => 
	`f
(x)).
	`fﬁd
(
	`Boﬁ
(
Ál£
))(_||_)

872 
io
.
sbﬂrd_£t
 :
wb_ªg_vÆid
 && !
wb_˝_vÆid
 && 
	`Reg
(
√xt
=
	`u£Sc‹ebﬂrd
(
_
.
_1
.
	`c⁄d
(
mem_˘æ
)Ë|| mem_˘æ.
div
 || mem_˘æ.
sqπ
)

873 
io
.
sbﬂrd_˛r
 :!
wb_˝_vÆid
 && (
divSqπ_wí
 || (
	`wí
(0Ë&& 
	`u£Sc‹ebﬂrd
(
x
 => 
	`wbInfo
(0).
pùeid
 ==
	`UI¡
(x.
_2
))))

874 
io
.
sbﬂrd_˛ø
 :
waddr


875 
	`ccovî
(
io
.
sbﬂrd_˛r
 && 
lﬂd_wb
, "DUAL_WRITEBACK", "loadánd FMA writeback on same cycle")

877 
io
.
ûÀgÆ_rm
 :io.
	`ö°
(14,12).
	`isO√Of
(5, 6Ë|| io.ö°(14,12Ë==7 && io.
fc§_rm
 >= 5

879 i‡(
cfg
.
divSqπ
) {

880 
vÆ
 
divSqπ_kûÀd
 = 
	`Reg
(
	`Boﬁ
())

881 
	`ccovî
(
divSqπ_öFlight
 && 
divSqπ_kûÀd
, "DIV_KILLED", "divide killedáfter issuedÅo divider")

882 
	`ccovî
(
divSqπ_öFlight
 && 
mem_ªg_vÆid
 && (
mem_˘æ
.
div
 || mem_˘æ.
sqπ
), "DIV_BUSY", "divider structural hazard")

883 
	`ccovî
(
mem_ªg_vÆid
 && 
divSqπ_wrôe_p‹t_busy
, "DIV_WB_STRUCTURAL", "structural hazard on division writeback")

885 
t
 <- 
ÊﬂtTy≥s
) {

886 
vÆ
 
èg
 = !
mem_˘æ
.
sögÀOut


887 
vÆ
 
divSqπ
 = 
	`ModuÀ
(
√w
 
h¨dÊﬂt
.
	`DivSqπRecFN_smÆl
(
t
.
exp
,Å.
sig
, 0))

888 
divSqπ
.
io
.
öVÆid
 :
mem_ªg_vÆid
 && 
èg
 ==
	`ty≥Tag
(
t
Ë&& (
mem_˘æ
.
div
 || mem_˘æ.
sqπ
Ë&& !
divSqπ_öFlight


889 
divSqπ
.
io
.
sqπOp
 :
mem_˘æ
.
sqπ


890 
divSqπ
.
io
.
a
 :
maxTy≥
.
	`unß„C⁄vît
(
Âiu
.io.
out
.
bôs
.
ö
.
ö1
, 
t
)

891 
divSqπ
.
io
.
b
 :
maxTy≥
.
	`unß„C⁄vît
(
Âiu
.io.
out
.
bôs
.
ö
.
ö2
, 
t
)

892 
divSqπ
.
io
.
roundögMode
 :
Âiu
.io.
out
.
bôs
.
ö
.
rm


893 
divSqπ
.
io
.
dëe˘Tööess
 :
h¨dÊﬂt
.
c⁄°s
.
tööess_a·îRoundög


895 
	`whí
 (!
divSqπ
.
io
.
öRódy
Ë{ 
divSqπ_öFlight
 :
åue
 }

897 
	`whí
 (
divSqπ
.
io
.
öVÆid
 && divSqπ.io.
öRódy
) {

898 
divSqπ_kûÀd
 :
kûlm


899 
divSqπ_waddr
 :
	`mem_ªg_ö°
(11,7)

902 
	`whí
 (
divSqπ
.
io
.
outVÆid_div
 || divSqπ.io.
outVÆid_sqπ
) {

903 
divSqπ_wí
 :!
divSqπ_kûÀd


904 
divSqπ_wd©a
 :
	`ßnôizeNaN
(
divSqπ
.
io
.
out
, 
t
)

905 
divSqπ_Êags
 :
divSqπ
.
io
.
ex˚±i⁄Fœgs


906 
divSqπ_ty≥Tag
 :
	`ty≥Tag
(
t
)

910 
	`whí
 (
id_˘æ
.
div
 || id_˘æ.
sqπ
Ë{ 
io
.
ûÀgÆ_rm
 :
åue
 }

914 
˛ock_í_ªg
 :=

915 
io
.
kìp_˛ock_íabÀd
 ||

916 
io
.
vÆid
 ||

917 
ªq_vÆid
 ||

918 
mem_ªg_vÆid
 || 
mem_˝_vÆid
 ||

919 
wb_ªg_vÆid
 || 
wb_˝_vÆid
 ||

920 
wí
.
‹R
 || 
divSqπ_öFlight
 ||

921 
io
.
dmem_ª•_vÆ


923 
	}
}

925 
def
 
	$ccovî
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
desc
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) =

926 
	`covî
(
c⁄d
, 
s
"FPU_$œbñ", "C‹e;;" + 
desc
)

927 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Interrupts.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 ˛as†
	cTûeI¡îru±s
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

13 
vÆ
 
debug
 = 
	$Boﬁ
()

14 
vÆ
 
mtù
 = 
	$Boﬁ
()

15 
vÆ
 
msù
 = 
	$Boﬁ
()

16 
vÆ
 
meù
 = 
	$Boﬁ
()

17 
vÆ
 
£ù
 = 
usögVM
.
	`›ti⁄
(
	$Boﬁ
())

18 
vÆ
 
lù
 = 
	`Vec
(
c‹eP¨ams
.
nLoˇlI¡îru±s
, 
	`Boﬁ
())

22 
åaô
 
HasExã∫ÆI¡îru±s
 { 
this
: 
Ba£Tûe
 =>

24 
vÆ
 
ötInw¨dNode
 = 
ötXb¨
.
öäode
 :=* 
	`I¡IdítôyNode
()(
	`VÆName
("int_local"))

25 
¥Ÿe˘ed
 
vÆ
 
ötSökNode
 = 
	`I¡SökNode
(
	`I¡SökP‹tSim∂e
())

26 
ötSökNode
 :
ötXb¨
.
öäode


28 
def
 
˝uDevi˚
: 
Devi˚


29 
vÆ
 
ötcDevi˚
 = 
√w
 
Devi˚Snù≥t
 {

30 
ovîride
 
def
 
∑ª¡
 = 
	`Some
(
˝uDevi˚
)

31 
def
 
	`des¸ibe
(): 
Des¸ùti⁄
 = {

32 
	`Des¸ùti⁄
("öãºu±-c⁄åﬁÀr", 
	`M≠
(

33 "com∑tibÀ" -> "riscv,˝u-ötc".
asPr›îty
,

34 "öãºu±-c⁄åﬁÀr" -> 
Nû
,

35 "#öãºu±-˚Œs" -> 1.a
sPr›îty
))

39 
Resour˚Bödög
 {

40 
ötSökNode
.
edges
.
ö
.
	`Ê©M≠
(
_
.
sour˚
.
sour˚s
).
m≠
 { 
s
 =>

41 
i
 <- 
s
.
ønge
.
°¨t
 
u¡û
 s.ønge.
íd
) {

42 
c§I¡M≠
.
	`li·
(
i
).
f‹óch
 { 
j
 =>

43 
s
.
ªsour˚s
.
f‹óch
 { 
r
 =>

44 
r
.
	`böd
(
ötcDevi˚
, 
	`Resour˚I¡
(
j
))

56 
def
 
c§I¡M≠
: 
Li°
[
I¡
] = {

57 
vÆ
 
∆ùs
 = 
tûeP¨ams
.
c‹e
.
nLoˇlI¡îru±s


58 
vÆ
 
£ù
 = i‡(
usögVM
Ë
	`Seq
(9Ë
Nû


59 
	`Li°
(65535, 3, 7, 11Ë++ 
£ù
 ++ 
Li°
.
	`èbuœã
(
∆ùs
)(
_
 + 16)

63 
def
 
	`decodeC‹eI¡îru±s
(
c‹e
: 
TûeI¡îru±s
) {

64 
vÆ
 
async_ùs
 = 
	`Seq
(
c‹e
.
debug
)

65 
vÆ
 
≥rùh_ùs
 = 
	`Seq
(

66 
c‹e
.
msù
,

67 
c‹e
.
mtù
,

68 
c‹e
.
meù
)

70 
vÆ
 
£ù
 = i‡(
c‹e
.£ù.
isDeföed
Ë
	`Seq
(c‹e.£ù.
gë
Ë
Nû


72 
vÆ
 
c‹e_ùs
 = 
c‹e
.
lù


74 
	`vÆ
 (
öãºu±s
, 
_
Ë
ötSökNode
.
	`ö
(0)

75 (
async_ùs
 ++ 
≥rùh_ùs
 ++ 
£ù
 ++ 
c‹e_ùs
).
	`zù
(
öãºu±s
).
f‹óch
 { (
c
, 
i
) => c := i }

77 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/L1Cache.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gP¨amëîs
, 
	gFõld
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
CacheBlockByãs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
Clõ¡Mëad©a


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


12 
åaô
 
	gL1CacheP¨ams
 {

13 
def
 
	gnSës
: 
I¡


14 
def
 
nWays
: 
I¡


15 
def
 
rowBôs
: 
I¡


16 
def
 
nTLBE¡rõs
: 
I¡


17 
def
 
blockByãs
: 
I¡


20 
åaô
 
HasL1CacheP¨amëîs
 
exãnds
 
HasTûeP¨amëîs
 {

21 
vÆ
 
ˇcheP¨ams
: 
L1CacheP¨ams


22 
¥iv©e
 
vÆ
 
bundÀP¨ams
 = 
p
(
Sh¨edMem‹yTLEdge
).
bundÀ


24 
def
 
nSës
 = 
ˇcheP¨ams
.nSets

25 
def
 
blockOffBôs
 = 
lgCacheBlockByãs


26 
def
 
idxBôs
 = 
log2Up
(
ˇcheP¨ams
.
nSës
)

27 
def
 
u¡agBôs
 = 
blockOffBôs
 + 
idxBôs


28 
def
 
ègBôs
 = 
bundÀP¨ams
.
addªssBôs
 - (i‡(
usögVM
Ë
u¡agBôs
 
mö
 
pgIdxBôs
 untagBits)

29 
def
 
nWays
 = 
ˇcheP¨ams
.nWays

30 
def
 
wayBôs
 = 
log2Up
(
nWays
)

31 
def
 
isDM
 = 
nWays
 == 1

32 
def
 
rowBôs
 = 
ˇcheP¨ams
.rowBits

33 
def
 
rowByãs
 = 
rowBôs
/8

34 
def
 
rowOffBôs
 = 
log2Up
(
rowByãs
)

35 
def
 
nTLBE¡rõs
 = 
ˇcheP¨ams
.nTLBEntries

37 
def
 
ˇcheD©aBôs
 = 
bundÀP¨ams
.
d©aBôs


38 
def
 
ˇcheD©aBóts
 = (
ˇcheBlockByãs
 * 8Ë/ 
ˇcheD©aBôs


39 
def
 
ªfûlCy˛es
 = 
ˇcheD©aBóts


42 
ab°ø˘
 
˛ass
 
	$L1CacheModuÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ


43 
wôh
 
HasL1CacheP¨amëîs


45 
ab°ø˘
 
˛ass
 
	$L1CacheBundÀ
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
	$P¨amëîizedBundÀ
()(
p
)

46 
wôh
 
HasL1CacheP¨amëîs


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/LazyRoCC.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


6 
imp‹t
 
	gChi£l
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
InOrdîArbôî


15 
obje˘
 
BuûdRoCC
 
exãnds
 
	gFõld
[
Seq
[
P¨amëîs
 => 
LazyRoCC
]](
Nû
)

17 ˛as†
	cRoCCIn°ru˘i⁄
 
exãnds
 
BundÀ
 {

18 
vÆ
 
fun˘
 = 
	$Bôs
(
width
 = 7)

19 
vÆ
 
rs2
 = 
	$Bôs
(
width
 = 5)

20 
vÆ
 
rs1
 = 
	$Bôs
(
width
 = 5)

21 
vÆ
 
xd
 = 
	$Boﬁ
()

22 
vÆ
 
xs1
 = 
	$Boﬁ
()

23 
vÆ
 
xs2
 = 
	$Boﬁ
()

24 
vÆ
 
rd
 = 
	$Bôs
(
width
 = 5)

25 
vÆ
 
›code
 = 
	`Bôs
(
width
 = 7)

28 ˛as†
	cRoCCComm™d
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

29 
vÆ
 
ö°
 = 
√w
 
RoCCIn°ru˘i⁄


30 
vÆ
 
rs1
 = 
	$Bôs
(
width
 = 
xLí
)

31 
vÆ
 
rs2
 = 
	$Bôs
(
width
 = 
xLí
)

32 
vÆ
 
°©us
 = 
√w
 
MSètus


35 ˛as†
	cRoCCRe•⁄£
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

36 
vÆ
 
rd
 = 
	$Bôs
(
width
 = 5)

37 
vÆ
 
d©a
 = 
	`Bôs
(
width
 = 
xLí
)

40 ˛as†
	cRoCCC‹eIO
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$C‹eBundÀ
()(
p
) {

41 
vÆ
 
cmd
 = 
	`Decou∂ed
(
√w
 
RoCCComm™d
).
Êù


42 
vÆ
 
ª•
 = 
	$Decou∂ed
(
√w
 
RoCCRe•⁄£
)

43 
vÆ
 
mem
 = 
√w
 
HñœCacheIO


44 
vÆ
 
busy
 = 
	$Boﬁ
(
OUTPUT
)

45 
vÆ
 
öãºu±
 = 
	$Boﬁ
(
OUTPUT
)

46 
vÆ
 
ex˚±i⁄
 = 
	`Boﬁ
(
INPUT
)

49 ˛as†
	cRoCCIO
(
vÆ
 
nPTWP‹ts
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$RoCCC‹eIO
()(
p
) {

50 
vÆ
 
±w
 = 
	$Vec
(
nPTWP‹ts
, 
√w
 
TLBPTWIO
)

51 
vÆ
 
Âu_ªq
 = 
	$Decou∂ed
(
√w
 
FPI≈ut
)

52 
vÆ
 
Âu_ª•
 = 
	`Decou∂ed
(
√w
 
FPResu…
).
Êù


56 
ab°ø˘
 
˛ass
 
	$LazyRoCC
(

57 
vÆ
 
›codes
: 
OpcodeSë
,

58 
vÆ
 
nPTWP‹ts
: 
I¡
 = 0,

59 
vÆ
 
u£sFPU
: 
Boﬁón
 = 
Ál£


60 )(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

61 
vÆ
 
moduÀ
: 
LazyRoCCModuÀImp


62 
vÆ
 
©lNode
: 
TLNode
 = 
	`TLIdítôyNode
()

63 
vÆ
 
éNode
: 
TLNode
 = 
	`TLIdítôyNode
()

64 
	}
}

66 ˛as†
	cLazyRoCCModuÀImp
(
ouãr
: 
LazyRoCC
Ë
exãnds
 
	$LazyModuÀImp
(
ouãr
) {

67 
vÆ
 
io
 = 
	`IO
(
√w
 
	`RoCCIO
(
ouãr
.
nPTWP‹ts
))

72 
åaô
 
HasLazyRoCC
 
exãnds
 
C™HavePTW
 { 
this
: 
Ba£Tûe
 =>

73 
vÆ
 
roccs
 = 
	`p
(
BuûdRoCC
).
	`m≠
(
	`_
(
p
))

75 
roccs
.
	`m≠
(
_
.
©lNode
).
f‹óch
 { 
©l
 => 
éMa°îXb¨
.
node
 :=*átl }

76 
roccs
.
	`m≠
(
_
.
éNode
).
f‹óch
 { 
é
 => 
éOthîMa°îsNode
 :=*Ål }

78 
nPTWP‹ts
 +
roccs
.
	`m≠
(
_
.nPTWP‹ts).
	`fﬁdLe·
(0)(_ + _)

79 
nDCacheP‹ts
 +
roccs
.
size


80 
	}
}

82 
åaô
 
HasLazyRoCCModuÀ
 
exãnds
 
C™HavePTWModuÀ


83 
wôh
 
HasC‹eP¨amëîs
 { 
this
: 
RockëTûeModuÀImp
 wôh 
HasFpuO±
 =>

85 
vÆ
 (
ª•Arb
, 
cmdRouãr
Ëif(
ouãr
.
roccs
.
size
 > 0) {

86 
vÆ
 
ª•Arb
 = 
ModuÀ
(
√w
 
RRArbôî
“ew 
RoCCRe•⁄£
()(
ouãr
.
p
), ouãr.
roccs
.
size
))

87 
vÆ
 
	gcmdRouãr
 = 
ModuÀ
(
√w
 
RoccComm™dRouãr
(
ouãr
.
roccs
.
m≠
(
_
.
›codes
))(ouãr.
p
))

88 
ouãr
.
roccs
.
zùWôhIndex
.
f‹óch
 { (
rocc
, 
i
) =>

89 
±wP‹ts
 ++
rocc
.
moduÀ
.
io
.
±w


90 
rocc
.
moduÀ
.
io
.
cmd
 <> 
cmdRouãr
.io.
out
(
i
)

91 
vÆ
 
dcIF
 = 
ModuÀ
(
√w
 
Sim∂eHñœCacheIF
()(
ouãr
.
p
))

92 
dcIF
.
io
.
ªque°‹
 <> 
rocc
.
moduÀ
.io.
mem


93 
dˇcheP‹ts
 +
dcIF
.
io
.
ˇche


94 
ª•Arb
.
io
.
ö
(
i
Ë<> 
Queue
(
rocc
.
moduÀ
.io.
ª•
)

97 
ÂuO±
 
	gf‹óch
 { 
	gÂu
 =>

98 
vÆ
 
nFPUP‹ts
 = 
ouãr
.
roccs
.
fûãr
(
_
.
u£sFPU
).
size


99 i‡(
usögFPU
 && 
nFPUP‹ts
 > 0) {

100 
vÆ
 
ÂArb
 = 
ModuÀ
(
√w
 
InOrdîArbôî
“ew 
FPI≈ut
()(
ouãr
.
p
),Çew 
FPResu…
()(ouãr.p), 
nFPUP‹ts
))

101 
vÆ
 
	gÂ_rocc_ios
 = 
ouãr
.
roccs
.
fûãr
(
_
.
u£sFPU
).
m≠
(_.
moduÀ
.
io
)

102 
ÂArb
.
io
.
ö_ªq
 <> 
Â_rocc_ios
.
m≠
(
_
.
Âu_ªq
)

103 
Â_rocc_ios
.
zù
(
ÂArb
.
io
.
ö_ª•
).
f‹óch
 {

104 (
rocc
, 
¨b
Ë=>Ñocc.
Âu_ª•
 <>árb

106 
	gÂu
.
	gio
.
	g˝_ªq
 <> 
	gÂArb
.io.
out_ªq


107 
	gÂArb
.
	gio
.
	gout_ª•
 <> 
	gÂu
.io.
	g˝_ª•


109 
	gÂu
.
	gio
.
	g˝_ªq
.
	gvÆid
 :
Boﬁ
(
Ál£
)

110 
Âu
.
io
.
˝_ª•
.
ªady
 :
Boﬁ
(
Ál£
)

113 (
Some
(
ª•Arb
), Some(
cmdRouãr
))

115 (
	gN⁄e
, None)

119 
˛ass
 
	$Accumuœt‹Exam∂e
(
›codes
: 
OpcodeSë
, 
vÆ
 
n
: 
I¡
 = 4)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$LazyRoCC
(
›codes
) {

120 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`Accumuœt‹Exam∂eModuÀImp
(
this
)

121 
	}
}

123 ˛as†
	cAccumuœt‹Exam∂eModuÀImp
(
ouãr
: 
Accumuœt‹Exam∂e
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$LazyRoCCModuÀImp
(
ouãr
)

124 
wôh
 
HasC‹eP¨amëîs
 {

125 
vÆ
 
ªgfûe
 = 
	`Mem
(
ouãr
.
n
, 
	$UI¡
(
width
 = 
xLí
))

126 
vÆ
 
busy
 = 
	`Reg
(
öô
 = 
Vec
.
	$fûl
(
ouãr
.
n
){
	`Boﬁ
(
Ál£
)})

128 
vÆ
 
cmd
 = 
	$Queue
(
io
.
cmd
)

129 
vÆ
 
fun˘
 = 
cmd
.
bôs
.
ö°
.funct

130 
vÆ
 
addr
 = 
cmd
.
bôs
.
	`rs2
(
	`log2Up
(
ouãr
.
n
)-1,0)

131 
vÆ
 
doWrôe
 = 
fun˘
 ==
	$UI¡
(0)

132 
vÆ
 
doRód
 = 
fun˘
 ==
	$UI¡
(1)

133 
vÆ
 
doLﬂd
 = 
fun˘
 ==
	$UI¡
(2)

134 
vÆ
 
doAccum
 = 
fun˘
 ==
	$UI¡
(3)

135 
vÆ
 
memRe•Tag
 = 
io
.
mem
.
ª•
.
bôs
.
	`èg
(
	`log2Up
(
ouãr
.
n
)-1,0)

138 
vÆ
 
addíd
 = 
cmd
.
bôs
.
rs1


139 
vÆ
 
accum
 = 
	$ªgfûe
(
addr
)

140 
vÆ
 
wd©a
 = 
	`Mux
(
doWrôe
, 
addíd
, 
accum
 +áddend)

142 
	`whí
 (
cmd
.
	`fúe
(Ë&& (
doWrôe
 || 
doAccum
)) {

143 
	`ªgfûe
(
addr
Ë:
wd©a


144 
	}
}

146 
	$whí
 (
io
.
mem
.
ª•
.
vÆid
) {

147 
	`ªgfûe
(
memRe•Tag
Ë:
io
.
mem
.
ª•
.
bôs
.
d©a


148 
	`busy
(
memRe•Tag
Ë:
	`Boﬁ
(
Ál£
)

149 
	}
}

152 
whí
 (
io
.
mem
.
ªq
.
	$fúe
()) {

153 
	`busy
(
addr
Ë:
	`Boﬁ
(
åue
)

154 
	}
}

156 
vÆ
 
doRe•
 = 
cmd
.
bôs
.
ö°
.
xd


157 
vÆ
 
°ÆlReg
 = 
	$busy
(
addr
)

158 
vÆ
 
°ÆlLﬂd
 = 
doLﬂd
 && !
io
.
mem
.
ªq
.
ªady


159 
vÆ
 
°ÆlRe•
 = 
doRe•
 && !
io
.
ª•
.
ªady


161 
cmd
.
ªady
 :!
°ÆlReg
 && !
°ÆlLﬂd
 && !
°ÆlRe•


165 
io
.
ª•
.
vÆid
 :
cmd
.vÆid && 
doRe•
 && !
°ÆlReg
 && !
°ÆlLﬂd


167 
io
.
ª•
.
bôs
.
rd
 :
cmd
.bôs.
ö°
.rd

169 
io
.
ª•
.
bôs
.
d©a
 :
accum


172 
io
.
busy
 :
cmd
.
vÆid
 || busy.
	`ªdu˚
(
_
||_)

174 
io
.
öãºu±
 :
	$Boﬁ
(
Ál£
)

178 
io
.
mem
.
ªq
.
vÆid
 :
cmd
.vÆid && 
doLﬂd
 && !
°ÆlReg
 && !
°ÆlRe•


179 
io
.
mem
.
ªq
.
bôs
.
addr
 :
addíd


180 
io
.
mem
.
ªq
.
bôs
.
èg
 :
addr


181 
io
.
mem
.
ªq
.
bôs
.
cmd
 :
M_XRD


182 
io
.
mem
.
ªq
.
bôs
.
typ
 :
MT_D


183 
io
.
mem
.
ªq
.
bôs
.
d©a
 :
	$Bôs
(0)

184 
io
.
mem
.
ªq
.
bôs
.
phys
 :
	`Boﬁ
(
Ál£
)

185 
	}
}

187 
˛ass
 
	$Tøn¶©‹Exam∂e
(
›codes
: 
OpcodeSë
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$LazyRoCC
(
›codes
, 
nPTWP‹ts
 = 1) {

188 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`Tøn¶©‹Exam∂eModuÀImp
(
this
)

189 
	}
}

191 ˛as†
	cTøn¶©‹Exam∂eModuÀImp
(
ouãr
: 
Tøn¶©‹Exam∂e
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$LazyRoCCModuÀImp
(
ouãr
)

192 
wôh
 
HasC‹eP¨amëîs
 {

193 
vÆ
 
ªq_addr
 = 
	`Reg
(
	$UI¡
(
width
 = 
c‹eMaxAddrBôs
))

194 
vÆ
 
ªq_rd
 = 
	$Reg
(
io
.
ª•
.
bôs
.
rd
)

195 
vÆ
 
ªq_off£t
 = 
	`ªq_addr
(
pgIdxBôs
 - 1, 0)

196 
vÆ
 
ªq_v≤
 = 
	`ªq_addr
(
c‹eMaxAddrBôs
 - 1, 
pgIdxBôs
)

197 
vÆ
 
±e
 = 
	$Reg
(
√w
 
PTE
)

199 
vÆ
 
s_idÀ
 :: 
s_±w_ªq
 :: 
s_±w_ª•
 :: 
s_ª•
 :: 
Nû
 = 
	`Enum
(
	`Bôs
(), 4)

200 
vÆ
 
°©e
 = 
	$Reg
(
öô
 = 
s_idÀ
)

202 
io
.
cmd
.
ªady
 :(
°©e
 ==
s_idÀ
)

204 
	`whí
 (
io
.
cmd
.
	$fúe
()) {

205 
ªq_rd
 :
io
.
cmd
.
bôs
.
ö°
.
rd


206 
ªq_addr
 :
io
.
cmd
.
bôs
.
rs1


207 
°©e
 :
s_±w_ªq


210 
¥iv©e
 
vÆ
 
±w
 = 
io
.
	$±w
(0)

212 
	`whí
 (
±w
.
ªq
.
	$fúe
()Ë{ 
°©e
 :
s_±w_ª•
 
	}
}

214 
	$whí
 (
°©e
 ==
s_±w_ª•
 && 
±w
.
ª•
.
vÆid
) {

215 
±e
 :
±w
.
ª•
.
bôs
.pte

216 
°©e
 :
s_ª•


217 
	}
}

219 
whí
 (
io
.
ª•
.
	$fúe
()Ë{ 
°©e
 :
s_idÀ
 
	}
}

221 
±w
.
ªq
.
vÆid
 :(
°©e
 ==
s_±w_ªq
)

222 
±w
.
ªq
.
bôs
.
vÆid
 :
åue
.
B


223 
±w
.
ªq
.
bôs
.bôs.
addr
 :
ªq_v≤


225 
io
.
ª•
.
vÆid
 :(
°©e
 ==
s_ª•
)

226 
io
.
ª•
.
bôs
.
rd
 :
ªq_rd


227 
io
.
ª•
.
bôs
.
d©a
 :
Mux
(
±e
.
Àaf
(), 
C©
’ã.
µn
, 
ªq_off£t
), 
SI¡
(-1, 
xLí
).
asUI¡
)

229 
	gio
.
	gbusy
 :(
°©e
 =/
s_idÀ
)

230 
io
.
öãºu±
 :
	$Boﬁ
(
Ál£
)

231 
io
.
mem
.
ªq
.
vÆid
 :
	`Boﬁ
(
Ál£
)

232 
	}
}

234 ˛as†
	cCh¨a˘îCou¡Exam∂e
(
›codes
: 
OpcodeSë
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$LazyRoCC
(
›codes
) {

235 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$Ch¨a˘îCou¡Exam∂eModuÀImp
(
this
)

236 
ovîride
 
vÆ
 
©lNode
 = 
	`TLClõ¡Node
(
	`Seq
(
	`TLClõ¡P‹tP¨amëîs
(Seq(
	`TLClõ¡P¨amëîs
("CharacterCountRoCC")))))

239 ˛as†
	cCh¨a˘îCou¡Exam∂eModuÀImp
(
ouãr
: 
Ch¨a˘îCou¡Exam∂e
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$LazyRoCCModuÀImp
(
ouãr
)

240 
wôh
 
HasC‹eP¨amëîs


241 
wôh
 
HasL1CacheP¨amëîs
 {

242 
vÆ
 
ˇcheP¨ams
 = 
tûeP¨ams
.
iˇche
.
gë


244 
¥iv©e
 
vÆ
 
blockOff£t
 = 
blockOffBôs


245 
¥iv©e
 
vÆ
 
bótOff£t
 = 
	`log2Up
(
ˇcheD©aBôs
/8)

247 
vÆ
 
√edÀ
 = 
	`Reg
(
	$UI¡
(
width
 = 8))

248 
vÆ
 
addr
 = 
	`Reg
(
	$UI¡
(
width
 = 
c‹eMaxAddrBôs
))

249 
vÆ
 
cou¡
 = 
	`Reg
(
	$UI¡
(
width
 = 
xLí
))

250 
vÆ
 
ª•_rd
 = 
	$Reg
(
io
.
ª•
.
bôs
.
rd
)

252 
vÆ
 
addr_block
 = 
	`addr
(
c‹eMaxAddrBôs
 - 1, 
blockOff£t
)

253 
vÆ
 
off£t
 = 
	`addr
(
blockOff£t
 - 1, 0)

254 
vÆ
 
√xt_addr
 = (
addr_block
 + 
	`UI¡
(1)Ë<< 
	$UI¡
(
blockOff£t
)

256 
vÆ
 
s_idÀ
 :: 
s_acq
 :: 
s_g¡
 :: 
s_check
 :: 
s_ª•
 :: 
Nû
 = 
	`Enum
(
	`Bôs
(), 5)

257 
vÆ
 
°©e
 = 
	$Reg
(
öô
 = 
s_idÀ
)

259 
	`vÆ
 (
é_out
, 
edgesOut
Ë
ouãr
.
©lNode
.
	$out
(0)

260 
vÆ
 
g¡
 = 
é_out
.
d
.
bôs


261 
vÆ
 
ªcv_d©a
 = 
	`Reg
(
	$UI¡
(
width
 = 
ˇcheD©aBôs
))

262 
vÆ
 
ªcv_bót
 = 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Up
(
ˇcheD©aBóts
+1)), 
öô
 = 
	$UI¡
(0))

264 
vÆ
 
d©a_byãs
 = 
Vec
.
	`èbuœã
(
ˇcheD©aBôs
/8Ë{ 
i
 => 
	`ªcv_d©a
(8 * (i + 1) - 1, 8 * i) }

265 
vÆ
 
zîo_m©ch
 = 
d©a_byãs
.
	`m≠
(
_
 ==
	$UI¡
(0))

266 
vÆ
 
√edÀ_m©ch
 = 
d©a_byãs
.
	$m≠
(
_
 ==
√edÀ
)

267 
vÆ
 
fú°_zîo
 = 
	$Pri‹ôyEncodî
(
zîo_m©ch
)

269 
vÆ
 
ch¨s_found
 = 
	`P›Cou¡
(
√edÀ_m©ch
.
zùWôhIndex
.
m≠
 {

270 (
m©ches
, 
i
) =>

271 
vÆ
 
idx
 = 
	`C©
(
ªcv_bót
 - 
	`UI¡
(1), UI¡(
i
, 
bótOff£t
))

272 
m©ches
 && 
idx
 >
off£t
 && 
	`UI¡
(
i
Ë<
fú°_zîo


273 
	}
})

274 
vÆ
 
	gzîo_found
 = 
zîo_m©ch
.
ªdu˚
(
_
 || _)

275 
vÆ
 
föished
 = 
Reg
(
	$Boﬁ
())

277 
io
.
cmd
.
ªady
 :(
°©e
 ==
s_idÀ
)

278 
io
.
ª•
.
vÆid
 :(
°©e
 ==
s_ª•
)

279 
io
.
ª•
.
bôs
.
rd
 :
ª•_rd


280 
io
.
ª•
.
bôs
.
d©a
 :
cou¡


281 
é_out
.
a
.
vÆid
 :(
°©e
 ==
s_acq
)

282 
é_out
.
a
.
bôs
 :
edgesOut
.
	`Gë
(

283 
‰omSour˚
 = 
	`UI¡
(0),

284 
toAddªss
 = 
addr_block
 << 
blockOff£t
,

285 
lgSize
 = 
	`UI¡
(
lgCacheBlockByãs
)).
_2


286 
é_out
.
d
.
ªady
 :(
°©e
 ==
s_g¡
)

288 
	`whí
 (
io
.
cmd
.
	$fúe
()) {

289 
addr
 :
io
.
cmd
.
bôs
.
rs1


290 
√edÀ
 :
io
.
cmd
.
bôs
.
rs2


291 
ª•_rd
 :
io
.
cmd
.
bôs
.
ö°
.
rd


292 
cou¡
 :
	`UI¡
(0)

293 
föished
 :
	`Boﬁ
(
Ál£
)

294 
°©e
 :
s_acq


295 
	}
}

297 
whí
 (
é_out
.
a
.
	$fúe
()Ë{ 
°©e
 :
s_g¡
 
	}
}

299 
whí
 (
é_out
.
d
.
	$fúe
()) {

300 
ªcv_bót
 :ªcv_bóà+ 
	`UI¡
(1)

301 
ªcv_d©a
 :
g¡
.
d©a


302 
°©e
 :
s_check


303 
	}
}

305 
	$whí
 (
°©e
 ==
s_check
) {

306 
	`whí
 (!
föished
) {

307 
cou¡
 :cou¡ + 
ch¨s_found


309 
	`whí
 (
zîo_found
Ë{ 
föished
 :
	`Boﬁ
(
åue
) }

310 
	`whí
 (
ªcv_bót
 ==
	`UI¡
(
ˇcheD©aBóts
)) {

311 
addr
 :
√xt_addr


312 
°©e
 :
	`Mux
(
zîo_found
 || 
föished
, 
s_ª•
, 
s_acq
)

313 } .
Ÿhîwi£
 {

314 
°©e
 :
s_g¡


316 
	}
}

318 
whí
 (
io
.
ª•
.
	$fúe
()Ë{ 
°©e
 :
s_idÀ
 
	}
}

320 
io
.
busy
 :(
°©e
 =/
s_idÀ
)

321 
io
.
öãºu±
 :
	$Boﬁ
(
Ál£
)

322 
io
.
mem
.
ªq
.
vÆid
 :
	$Boﬁ
(
Ál£
)

324 
é_out
.
b
.
ªady
 :
	$Boﬁ
(
åue
)

325 
é_out
.
c
.
vÆid
 :
	$Boﬁ
(
Ál£
)

326 
é_out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

327 
	}
}

329 
˛ass
 
	$OpcodeSë
(
vÆ
 
›codes
: 
Seq
[
UI¡
]) {

330 
def
 |(
£t
: 
OpcodeSë
) =

331 
√w
 
	`OpcodeSë
(
this
.
›codes
 ++ 
£t
.opcodes)

333 
def
 
	`m©ches
(
oc
: 
UI¡
Ë
›codes
.
	`m≠
(
_
 ==oc).
	`ªdu˚
(_ || _)

334 
	}
}

336 
obje˘
 
OpcodeSë
 {

337 
def
 
cu°om0
 = 
√w
 
OpcodeSë
(
Seq
(
Bôs
("b0001011")))

338 
def
 
cu°om1
 = 
√w
 
OpcodeSë
(
Seq
(
Bôs
("b0101011")))

339 
def
 
cu°om2
 = 
√w
 
OpcodeSë
(
Seq
(
Bôs
("b1011011")))

340 
def
 
cu°om3
 = 
√w
 
OpcodeSë
(
Seq
(
Bôs
("b1111011")))

341 
def
 
Æl
 = 
cu°om0
 | 
cu°om1
 | 
cu°om2
 | 
cu°om3


344 
˛ass
 
	$RoccComm™dRouãr
(
›codes
: 
Seq
[
OpcodeSë
])(
im∂icô
 
p
: 
P¨amëîs
)

345 
exãnds
 
	$C‹eModuÀ
()(
p
) {

346 
vÆ
 
io
 = 
√w
 
BundÀ
 {

347 
vÆ
 
ö
 = 
	`Decou∂ed
(
√w
 
RoCCComm™d
).
Êù


348 
vÆ
 
out
 = 
	`Vec
(
›codes
.
size
, 
	`Decou∂ed
(
√w
 
RoCCComm™d
))

349 
vÆ
 
busy
 = 
	`Boﬁ
(
OUTPUT
)

352 
vÆ
 
cmd
 = 
	`Queue
(
io
.
ö
)

353 
vÆ
 
cmdRódys
 = 
io
.
out
.
	`zù
(
›codes
).
m≠
 { (out, 
›code
) =>

354 
vÆ
 
me
 = 
›code
.
	`m©ches
(
cmd
.
bôs
.
ö°
.opcode)

355 
out
.
vÆid
 :
cmd
.vÆid && 
me


356 
out
.
bôs
 :
cmd
.bits

357 
out
.
ªady
 && 
me


359 
cmd
.
ªady
 :
cmdRódys
.
	`ªdu˚
(
_
 || _)

360 
io
.
busy
 :
cmd
.
vÆid


362 
	`as£π
(
	`P›Cou¡
(
cmdRódys
Ë<
	`UI¡
(1),

364 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/RocketTile.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûe


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


15 
˛ass
 
RockëTûeP¨ams
(

16 
c‹e
: 
RockëC‹eP¨ams
 = RocketCoreParams(),

17 
iˇche
: 
O±i⁄
[
ICacheP¨ams
] = 
Some
(ICacheParams()),

18 
dˇche
: 
O±i⁄
[
DCacheP¨ams
] = 
Some
(DCacheParams()),

19 
btb
: 
O±i⁄
[
BTBP¨ams
] = 
Some
(BTBParams()),

20 
d©aS¸©ch∑dByãs
: 
I¡
 = 0,

21 
åa˚
: 
Boﬁón
 = 
Ál£
,

22 
hcfOnUnc‹ª˘abÀ
: 
Boﬁón
 = 
Ál£
,

23 
«me
: 
O±i⁄
[
Såög
] = 
Some
("tile"),

24 
h¨tId
: 
I¡
 = 0,

25 
blockîCålAddr
: 
O±i⁄
[
BigI¡
] = 
N⁄e
,

26 
bound¨yBuf„rs
: 
Boﬁón
 = 
Ál£


27 Ë
exãnds
 
TûeP¨ams
 {

28 
ªquúe
(
iˇche
.
isDeföed
)

29 
ªquúe
(
dˇche
.
isDeföed
)

32 
˛ass
 
	$RockëTûe
(

33 
vÆ
 
rockëP¨ams
: 
RockëTûeP¨ams
,

34 
¸ossög
: 
ClockCrossögTy≥
)

35 (
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$Ba£Tûe
(
rockëP¨ams
, 
¸ossög
)(
p
)

36 
wôh
 
HasExã∫ÆI¡îru±s


37 
wôh
 
HasLazyRoCC


38 
wôh
 
HasHñœCache


39 
wôh
 
HasICacheFr⁄ãnd
 {

41 
vÆ
 
ötOutw¨dNode
 = 
	`I¡IdítôyNode
()

42 
vÆ
 
¶aveNode
 = 
	`TLIdítôyNode
()

43 
vÆ
 
ma°îNode
 = 
	`TLIdítôyNode
()

45 
vÆ
 
dtim_ad≠ãr
 = 
tûeP¨ams
.
dˇche
.
Ê©M≠
 { 
d
 => d.
s¸©ch
.
	`m≠
(
s
 =>

46 
	`LazyModuÀ
(
√w
 
	`S¸©ch∑dSœveP‹t
(
	`AddªssSë
(
s
, 
d
.
d©aS¸©ch∑dByãs
-1), 
xByãs
, 
tûeP¨ams
.
c‹e
.
u£Atomics
 && !tûeP¨ams.c‹e.
u£AtomicsO∆yF‹IO
)))

48 
dtim_ad≠ãr
.
	`f‹óch
(
lm
 => 
	`c⁄√˘TLSœve
÷m.
node
, 
xByãs
))

50 
vÆ
 
bus_îr‹_unô
 = 
tûeP¨ams
.
c‹e
.
tûeC⁄åﬁAddr
 
m≠
 { 
a
 =>

51 
vÆ
 
beu
 = 
	`LazyModuÀ
(
√w
 
	`BusEº‹Unô
“ew 
L1BusEº‹s
, 
	`BusEº‹UnôP¨ams
(
a
)))

52 
ötOutw¨dNode
 :
beu
.
ötNode


53 
	`c⁄√˘TLSœve
(
beu
.
node
, 
xByãs
)

54 
beu


57 
vÆ
 
tûe_ma°î_blockî
 =

58 
tûeP¨ams
.
blockîCålAddr


59 .
	`m≠
(
	`BasicBusBlockîP¨ams
(
_
, 
xByãs
, 
ma°îP‹tBótByãs
, 
dódlock
 = 
åue
))

60 .
	`m≠
(
bp
 => 
	`LazyModuÀ
(
√w
 
	`BasicBusBlockî
(bp)))

62 
tûe_ma°î_blockî
.
	`f‹óch
(
lm
 => 
	`c⁄√˘TLSœve
÷m.
c⁄åﬁNode
, 
xByãs
))

65 
éOthîMa°îsNode
 :
tûe_ma°î_blockî
.
m≠
 { 
_
.
node
 :
éMa°îXb¨
.nodê} 
gëOrEl£
 {ÅlMasterXbar.node }

66 
ma°îNode
 :=* 
éOthîMa°îsNode


67 
DißbÀM⁄ô‹s
 { 
im∂icô
 
p
 => 
éSœveXb¨
.
node
 :*
¶aveNode
 }

69 
def
 
födS¸©ch∑dFromICache
: 
O±i⁄
[
AddªssSë
] = 
dtim_ad≠ãr
.
m≠
 { 
s
 =>

70 
vÆ
 
föÆNode
 = 
‰⁄ãnd
.
ma°îNode
.
edges
.
out
.
hód
.
m™agî
.
m™agîs
.
	`föd
(
_
.
nodeP©h
.
œ°
 =
s
.
node
)

71 
	`ªquúe
 (
föÆNode
.
isDeföed
, "CouldÇot findÅhe scratchÖad;ÇotÑeachable via icache?")

72 
	`ªquúe
 (
föÆNode
.
gë
.
addªss
.
size
 == 1, "Scratchpadáddress space was fragmented!")

73 
föÆNode
.
gë
.
	`addªss
(0)

76 
nDCacheP‹ts
 +1 + (
dtim_ad≠ãr
.
isDeföed
).
toI¡


78 
vÆ
 
dtimPr›îty
 = 
dtim_ad≠ãr
.
	`m≠
(
d
 => 
	`M≠
(

79 "sifive,dtim" -> 
d
.
devi˚
.
asPr›îty
)).
	`gëOrEl£
(
Nû
)

81 
vÆ
 
ôimPr›îty
 = 
tûeP¨ams
.
iˇche
.
	`Ê©M≠
(
_
.
ôimAddr
.
	`m≠
(
i
 => 
	`M≠
(

82 "sifive,ôim" -> 
‰⁄ãnd
.
iˇche
.
devi˚
.
asPr›îty
))).
	`gëOrEl£
(
Nû
)

84 
vÆ
 
˝uDevi˚
 = 
√w
 
	`Sim∂eDevi˚
("˝u", 
	`Seq
("sifive,rocket0", "riscv")) {

85 
ovîride
 
def
 
∑ª¡
 = 
	`Some
(
Resour˚Anch‹s
.
˝us
)

86 
ovîride
 
def
 
	`des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

87 
vÆ
 
	`Des¸ùti⁄
(
«me
, 
m≠pög
Ë
su≥r
.
	`des¸ibe
(
ªsour˚s
)

88 
	`Des¸ùti⁄
(
«me
, 
m≠pög
 ++ 
˝uPr›îtõs
 ++ 
√xtLevñCachePr›îty
 ++ 
tûePr›îtõs
 ++ 
dtimPr›îty
 ++ 
ôimPr›îty
)

92 
Resour˚Bödög
 {

93 
	`Resour˚
(
˝uDevi˚
, "ªg").
	`böd
(
	`Resour˚Addªss
(
h¨tId
))

96 
ovîride
 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`RockëTûeModuÀImp
(
this
)

98 
ovîride
 
def
 
	`makeMa°îBound¨yBuf„rs
(
im∂icô
 
p
: 
P¨amëîs
) = {

99 i‡(!
rockëP¨ams
.
bound¨yBuf„rs
Ë
su≥r
.
makeMa°îBound¨yBuf„rs


100 
	`TLBuf„r
(
Buf„rP¨ams
.
n⁄e
, Buf„rP¨ams.
Êow
, Buf„rP¨ams.n⁄e, Buf„rP¨ams.Êow, 
	`Buf„rP¨ams
(1))

103 
ovîride
 
def
 
	`makeSœveBound¨yBuf„rs
(
im∂icô
 
p
: 
P¨amëîs
) = {

104 i‡(!
rockëP¨ams
.
bound¨yBuf„rs
Ë
su≥r
.
makeSœveBound¨yBuf„rs


105 
	`TLBuf„r
(
Buf„rP¨ams
.
Êow
, Buf„rP¨ams.
n⁄e
, BufferParams.none, BufferParams.none, BufferParams.none)

107 
	}
}

109 ˛as†
	cRockëTûeModuÀImp
(
ouãr
: 
RockëTûe
Ë
exãnds
 
	$Ba£TûeModuÀImp
(
ouãr
)

110 
wôh
 
HasFpuO±


111 
wôh
 
HasLazyRoCCModuÀ


112 
wôh
 
HasICacheFr⁄ãndModuÀ
 {

113 
A¬Ÿ©ed
.
	$∑øms
(
this
, 
ouãr
.
rockëP¨ams
)

115 
vÆ
 
c‹e
 = 
	`ModuÀ
(
√w
 
	$Rockë
()(
ouãr
.
p
))

117 
vÆ
 
unc‹ª˘abÀ
 = 
	`RegInô
(
	$Boﬁ
(
Ál£
))

118 
vÆ
 
hÆt_™d_ˇtch_fúe
 = 
ouãr
.
rockëP¨ams
.
hcfOnUnc‹ª˘abÀ
.
	`›ti⁄
(
	`IO
(
	$Boﬁ
(
OUTPUT
)))

120 
ouãr
.
bus_îr‹_unô
.
f‹óch
 { 
lm
 =>

121 
lm
.
moduÀ
.
io
.
îr‹s
.
dˇche
 :
ouãr
.dcache.module.io.errors

122 
lm
.
moduÀ
.
io
.
îr‹s
.
iˇche
 :
ouãr
.
‰⁄ãnd
.module.io.errors

125 
ouãr
.
	$decodeC‹eI¡îru±s
(
c‹e
.
io
.
öãºu±s
)

126 
ouãr
.
bus_îr‹_unô
.
f‹óch
 { 
beu
 => 
c‹e
.
io
.
öãºu±s
.
bu£º‹
.
gë
 :beu.
moduÀ
.io.
öãºu±
 
	}
}

127 
c‹e
.
io
.
h¨tid
 :
c⁄°™ts
.hartid

128 
åa˚
.
f‹óch
 { 
_
 :
c‹e
.
io
.trace }

129 
hÆt_™d_ˇtch_fúe
.
f‹óch
 { 
_
 :
unc‹ª˘abÀ
 }

130 
ouãr
.
‰⁄ãnd
.
moduÀ
.
io
.
˝u
 <> 
c‹e
.io.
imem


131 
ouãr
.
‰⁄ãnd
.
moduÀ
.
io
.
ª£t_ve˘‹
 :
c⁄°™ts
.reset_vector

132 
ouãr
.
‰⁄ãnd
.
moduÀ
.
io
.
h¨tid
 :
c⁄°™ts
.hartid

133 
ouãr
.
dˇche
.
moduÀ
.
io
.
h¨tid
 :
c⁄°™ts
.hartid

134 
dˇcheP‹ts
 +
c‹e
.
io
.
dmem


135 
ÂuO±
 
f‹óch
 { 
Âu
 => 
c‹e
.
io
.fpu <> fpu.io }

141 
c‹e
.
io
.
±w
 <>Ötw.io.
d∑th


143 i‡(
ouãr
.
roccs
.
size
 > 0) {

144 
cmdRouãr
.
gë
.
io
.
ö
 <> 
c‹e
.io.
rocc
.
cmd


145 
ouãr
.
roccs
.
f‹óch
(
_
.
moduÀ
.
io
.
ex˚±i⁄
 :
c‹e
.io.
rocc
.exception)

146 
c‹e
.
io
.
rocc
.
ª•
 <> 
ª•Arb
.
gë
.io.
out


147 
c‹e
.
io
.
rocc
.
busy
 <> (
cmdRouãr
.
gë
.io.busy || 
ouãr
.
roccs
.
m≠
(
_
.
moduÀ
.io.busy).
ªdu˚
(_ || _))

148 
c‹e
.
io
.
rocc
.
öãºu±
 :
ouãr
.
roccs
.
m≠
(
_
.
moduÀ
.io.öãºu±).
ªdu˚
(_ || _)

152 
ouãr
.
dtim_ad≠ãr
.
f‹óch
 { 
lm
 => 
dˇcheP‹ts
 +lm.
moduÀ
.
io
.
dmem
 }

154 
whí
(!
unc‹ª˘abÀ
) { uncorrectable :=

155 
Li°
(
ouãr
.
‰⁄ãnd
.
moduÀ
.
io
.
îr‹s
, ouãr.
dˇche
.module.io.errors)

156 .
	gÊ©M≠
 { 
	ge
 => 
e
.
unc‹ª˘abÀ
.
m≠
(
_
.
vÆid
) }

157 .
ªdu˚O±i⁄
(
_
||_)

158 .
gëOrEl£
(
Ál£
.
B
)

162 
vÆ
 
	gh
 = 
dˇcheP‹ts
.
size


163 
vÆ
 
c
 = 
c‹e
.
dˇcheArbP‹ts


164 
vÆ
 
o
 = 
ouãr
.
nDCacheP‹ts


165 
ªquúe
(
h
 =
c
, 
s
"portÜist size was $h, coreÉxpected $c")

166 
ªquúe
(
h
 =
o
, 
s
"portÜist size was $h, outer counted $o")

168 
	gdˇcheArb
.
	gio
.
	gªque°‹
 <> 
dˇcheP‹ts


169 
	g±w
.
	gio
.
	gªque°‹
 <> 
	g±wP‹ts


172 
åaô
 
	gHasFpuO±
 { 
	gthis
: 
RockëTûeModuÀImp
 =>

173 
vÆ
 
ÂuO±
 = 
ouãr
.
tûeP¨ams
.
c‹e
.
Âu
.
m≠
(
∑øms
 => 
ModuÀ
(
√w
 
FPU
’¨ams)(ouãr.
p
)))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AddressAdjuster.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 ˛as†
	cAddªssAdju°î
(
mask
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

13 
vÆ
 
bôs
 = 
AddªssSë
.
	$íumî©eBôs
(
mask
)

15 
vÆ
 
ids
 = 
AddªssSë
.
	$íumî©eMask
(
mask
)

17 
vÆ
 
node
 = 
	`TLNexusNode
(

18 
˛õ¡Fn
 = { 
˝
 => 
	`˝
(0) },

19 
m™agîFn
 = { 
mp
 =>

20 
	`ªquúe
 (
mp
.
size
 == 2)

21 
vÆ
 
ªmŸe
 = 
	`mp
(0)

22 
vÆ
 
loˇl
 = 
	`mp
(1)

25 
def
 
	`checkMask
(
m
: 
TLM™agîP¨amëîs
) = {

26 
vÆ
 
s‹ãd
 = 
m
.
addªss
.sorted

27 
bôs
.
f‹óch
 { 
b
 =>

28 
vÆ
 
Êù≥d
 = 
m
.
addªss
.
	`m≠
(
a
 => 
	`AddªssSë
(◊.
ba£
 ^ 
b
Ë& ~a.
mask
,á.mask)).
s‹ãd


29 
	`ªquúe
 (
s‹ãd
 =
Êù≥d
, 
s
"AddressSets for ${m.name} (${sorted}) doÇotÑepeat with bit ${b} (${flipped})")

32 
loˇl
 .
m™agîs
.
f‹óch
 { 
z
 => 
	`checkMask
(z) }

33 
ªmŸe
.
m™agîs
.
f‹óch
 { 
z
 => 
	`checkMask
(z) }

36 
vÆ
 
îr‹Devs
 = 
loˇl
.
m™agîs
.
	`fûãr
(
_
.
nodeP©h
.
œ°
.
œzyModuÀ
.
˛assName
 == "TLError")

37 
	`ªquúe
 (!
îr‹Devs
.
isEm±y
, 
s
"There isÇo TLErrorÑeachable from ${name}. One must be instantiated.")

38 
vÆ
 
îr‹Dev
 = 
îr‹Devs
.
hód


41 
ªmŸe
.
m™agîs
.
f‹óch
 { 
r
 =>

42 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsAcquúeT
 .
	`c⁄èös
(
r
.suµ‹tsAcquúeT ), 
s
"Error device cannot cover ${r.name}'s AcquireT")

43 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsAcquúeB
 .
	`c⁄èös
(
r
.suµ‹tsAcquúeB ), 
s
"Error device cannot cover ${r.name}'s AcquireB")

44 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsArôhmëic
.
	`c⁄èös
(
r
.suµ‹tsArôhmëic), 
s
"Error device cannot cover ${r.name}'s Arithmetic")

45 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsLogiˇl
 .
	`c⁄èös
(
r
.suµ‹tsLogiˇ»), 
s
"Error device cannot cover ${r.name}'s Logical")

46 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsGë
 .
	`c⁄èös
(
r
.suµ‹tsGë ), 
s
"Error device cannot cover ${r.name}'s Get")

47 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsPutFuŒ
 .
	`c⁄èös
(
r
.suµ‹tsPutFuŒ ), 
s
"Error device cannot cover ${r.name}'s PutFull")

48 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsPutP¨tül
.
	`c⁄èös
(
r
.suµ‹tsPutP¨tül), 
s
"Error device cannot cover ${r.name}'s PutPartial")

49 
	`ªquúe
 (
îr‹Dev
.
suµ‹tsHöt
 .
	`c⁄èös
(
r
.suµ‹tsHöà), 
s
"Error device cannot cover ${r.name}'s Hint")

53 
ªmŸe
.
	`ªquúeFifo
()

54 
loˇl
.
	`ªquúeFifo
()

57 
vÆ
 
hﬁes
 = {

58 
vÆ
 
ø
 = 
ªmŸe
.
m™agîs
.
	`Ê©M≠
(
_
.
addªss
).Ê©M≠(_.
	`öãr£˘
(
	`AddªssSë
(0, ~
mask
)))

59 
vÆ
 
œ
 = 
loˇl
 .
m™agîs
.
	`Ê©M≠
(
_
.
addªss
).Ê©M≠(_.
	`öãr£˘
(
	`AddªssSë
(0, ~
mask
)))

60 
œ
.
	`fﬁdLe·
(
ø
Ë{ (
hﬁes
,ÜaË=> hﬁes.
	`Ê©M≠
(
_
.
	`subåa˘
(la)) }

64 
vÆ
 
√wLoˇl
 = 
loˇl
.
m™agîs
.
m≠
 { 
l
 =>

65 
vÆ
 
c⁄èöî
 = 
ªmŸe
.
m™agîs
.
föd
 { 
r
 => 
l
.
addªss
.
f‹Æl
 { 
œ
 =>Ñ.addªss.
	`exi°s
(
_
.
	`c⁄èös
(la)) } }

66 
	`ªquúe
 (!
c⁄èöî
.
isEm±y
, 
s
"There isÇoÑemote manager which containsÅheáddresses of ${l.name} (${l.address})")

67 
vÆ
 
r
 = 
c⁄èöî
.
gë


68 
	`ªquúe
 (
l
.
ªgi⁄Ty≥
 <
r
.ªgi⁄Ty≥, 
s
"Device ${l.name} cannot be ${l.regionType} when ${r.name} is ${r.regionType}")

69 
	`ªquúe
 (!
l
.
execuèbÀ
 || 
r
.execuèbÀ, 
s
"Device ${l.name} cannot beÉxecutable if ${r.name} isÇot")

70 
	`ªquúe
 (!
l
.
mayDíyPut
 || 
r
.mayDíyPut, 
s
"Device ${l.name} cannot deny Put if ${r.name} doesÇot")

71 
	`ªquúe
 (!
l
.
mayDíyGë
 || 
r
.mayDíyGë, 
s
"Device ${l.name} cannot deny Get if ${r.name} doesÇot")

72 
	`ªquúe
 (
l
.
ÆwaysGø¡sT
 || !
r
.ÆwaysGø¡sT, 
s
"Device ${l.name} mustálways GrantÅoT if ${r.name} does")

74 
	`ªquúe
 (!
l
.
suµ‹tsAcquúeT
 || 
r
.suµ‹tsAcquúeT, 
s
"Device ${l.name} (${l.address})Üoses AcquireT suppport because ${r.name} doesÇot support it")

75 
	`ªquúe
 (!
l
.
suµ‹tsAcquúeB
 || 
r
.suµ‹tsAcquúeB, 
s
"Device ${l.name} (${l.address})Üoses AcquireB support because ${r.name} doesÇot support it")

76 
	`ªquúe
 (!
l
.
suµ‹tsArôhmëic
 || 
r
.suµ‹tsArôhmëic, 
s
"Device ${l.name} (${l.address})Üoses Arithmetic support because ${r.name} doesÇot support it")

77 
	`ªquúe
 (!
l
.
suµ‹tsLogiˇl
 || 
r
.suµ‹tsLogiˇl, 
s
"Device ${l.name} (${l.address})Üoses Logical support because ${r.name} doesÇot support it")

78 
	`ªquúe
 (!
l
.
suµ‹tsGë
 || 
r
.suµ‹tsGë, 
s
"Device ${l.name} (${l.address})Üoses Get support because ${r.name} doesÇot support it")

79 
	`ªquúe
 (!
l
.
suµ‹tsPutFuŒ
 || 
r
.suµ‹tsPutFuŒ, 
s
"Device ${l.name} (${l.address})Üoses PutFull support because ${r.name} doesÇot support it")

80 
	`ªquúe
 (!
l
.
suµ‹tsPutP¨tül
 || 
r
.suµ‹tsPutP¨tül, 
s
"Device ${l.name} (${l.address})Üoses PutPartial support because ${r.name} doesÇot support it")

81 
	`ªquúe
 (!
l
.
suµ‹tsHöt
 || 
r
.suµ‹tsHöt, 
s
"Device ${l.name} (${l.address})Üoses Hint support because ${r.name} doesÇot support it")

82 
l
.
	`c›y
(

84 
addªss
 = 
AddªssSë
.
	`unify
(
l
.addªss.
	`Ê©M≠
(
_
.
	`öãr£˘
(
	`AddªssSë
(0, ~
mask
))) ++

85 (i‡(
l
 =
îr‹Dev
Ë
hﬁes
 
Nû
)),

86 
ªgi⁄Ty≥
 = 
r
.regionType,

87 
execuèbÀ
 = 
r
.executable,

88 
suµ‹tsAcquúeT
 = 
r
.supportsAcquireT,

89 
suµ‹tsAcquúeB
 = 
r
.supportsAcquireB,

90 
suµ‹tsArôhmëic
 = 
r
.supportsArithmetic,

91 
suµ‹tsLogiˇl
 = 
r
.supportsLogical,

92 
suµ‹tsGë
 = 
r
.supportsGet,

93 
suµ‹tsPutFuŒ
 = 
r
.supportsPutFull,

94 
suµ‹tsPutP¨tül
 = 
r
.supportsPutPartial,

95 
suµ‹tsHöt
 = 
r
.supportsHint,

96 
mayDíyGë
 = 
r
.mayDenyGet,

97 
mayDíyPut
 = 
r
.mayDenyPut,

98 
ÆwaysGø¡sT
 = 
r
.alwaysGrantsT,

99 
fifoId
 = 
	`Some
(0))

102 
vÆ
 
√wRemŸe
 = 
ids
.
èû
.
zùWôhIndex
.
Ê©M≠
 { (
id
, 
i
Ë=> 
ªmŸe
.
m™agîs
.
m≠
 { 
r
 =>

103 
r
.
	`c›y
(

104 
addªss
 = 
AddªssSë
.
	`unify
(
r
.addªss.
	`Ê©M≠
(
_
.
	`öãr£˘
(
	`AddªssSë
(
id
, ~
mask
)))),

105 
fifoId
 = 
	`Some
(
i
+1))

108 
loˇl
.
	`c›y
(

109 
m™agîs
 = 
√wLoˇl
 ++ 
√wRemŸe
,

110 
ídSökId
 = 
loˇl
.ídSökId + 
ªmŸe
.endSinkId,

111 
möL©ícy
 = 
loˇl
.möL©ícy 
mö
 
ªmŸe
.minLatency)

112 
	}
})

114 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

115 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

116 
vÆ
 
loˇl_addªss
 = 
	`UI¡
(
bôs
.
size
.
W
)

119 
	`ªquúe
 (
node
.
edges
.
ö
.
size
 == 1)

120 
	`ªquúe
 (
node
.
edges
.
out
.
size
 == 2)

122 
	`vÆ
 (
∑ª¡
, 
∑ª¡Edge
Ë
node
.
	`ö
(0)

123 
	`vÆ
 (
ªmŸe
, 
ªmŸeEdge
Ë
node
.
	`out
(0)

124 
	`vÆ
 (
loˇl
, 
loˇlEdge
Ë
node
.
	`out
(1)

125 
	`ªquúe
 (
loˇlEdge
.
m™agî
.
bótByãs
 =
ªmŸeEdge
.manager.beatBytes)

128 
vÆ
 
loˇl_addªss
 = (
bôs
 
zù
 
io
.loˇl_addªss.
toBoﬁs
).
	`fﬁdLe·
(0.U) {

129 (
acc
, (
bô
, 
£l
)Ë=>ác¯| 
	`Mux
(£l, 0.U, bô.
U
)

133 
vÆ
 
a_loˇl
 = 
loˇl_addªss
 ==(
∑ª¡
.
a
.
bôs
.
addªss
 & 
mask
.
U
)

134 
∑ª¡
.
a
.
ªady
 :
	`Mux
(
a_loˇl
, 
loˇl
.a.ªady, 
ªmŸe
.a.ready)

135 
loˇl
 .
a
.
vÆid
 :
∑ª¡
.a.vÆid && 
a_loˇl


136 
ªmŸe
.
a
.
vÆid
 :
∑ª¡
.a.vÆid && !
a_loˇl


137 
loˇl
 .
a
.
bôs
 :
∑ª¡
.a.bits

138 
ªmŸe
.
a
.
bôs
 :
∑ª¡
.a.bits

140 
vÆ
 
a_rouèbÀ
 = 
AddªssSë
.
	`unify
(
loˇlEdge
.
m™agî
.
m™agîs
.
	`Ê©M≠
(
_
.
addªss
))

141 
vÆ
 
a_c⁄èöed
 = 
a_rouèbÀ
.
	`m≠
(
_
.
	`c⁄èös
(
∑ª¡
.
a
.
bôs
.
addªss
)).
	`ªdu˚
(_ || _)

143 
vÆ
 
acquúeOk
 =

144 
	`Mux
(
∑ª¡
.
a
.
bôs
.
∑øm
 ==
TLPîmissi⁄s
.
toT
,

145 
loˇlEdge
.
m™agî
.
	`suµ‹tsAcquúeTFa°
(
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
),

146 
loˇlEdge
.
m™agî
.
	`suµ‹tsAcquúeBFa°
(
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
))

148 
vÆ
 
a_suµ‹t
 = 
	`VecInô
(

149 
loˇlEdge
.
m™agî
.
	`suµ‹tsPutFuŒFa°
 (
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
),

150 
loˇlEdge
.
m™agî
.
	`suµ‹tsPutP¨tülFa°
(
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
),

151 
loˇlEdge
.
m™agî
.
	`suµ‹tsArôhmëicFa°
(
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
),

152 
loˇlEdge
.
m™agî
.
	`suµ‹tsLogiˇlFa°
 (
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
),

153 
loˇlEdge
.
m™agî
.
	`suµ‹tsGëFa°
 (
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
),

154 
loˇlEdge
.
m™agî
.
	`suµ‹tsHötFa°
 (
∑ª¡
.
a
.
bôs
.
addªss
,Ö¨ít.a.bôs.
size
),

155 
acquúeOk
,ácquúeOk)(
∑ª¡
.
a
.
bôs
.
›code
)

157 
vÆ
 
îr‹Së
 = 
loˇlEdge
.
m™agî
.
m™agîs
.
	`fûãr
(
_
.
nodeP©h
.
œ°
.
œzyModuÀ
.
˛assName
 ="TLEº‹").
hód
.
addªss
.head

158 
vÆ
 
a_îr‹
 = !
a_c⁄èöed
 || !
a_suµ‹t


159 
loˇl
.
a
.
bôs
.
addªss
 :
	`C©
(

160 
	`Mux
(!
a_îr‹
, 
∑ª¡
.
a
.
bôs
.
addªss
, 
îr‹Së
.
ba£
.
U
Ë>> 
	`log2Ceû
”º‹Së.
Æignmít
),

161 
∑ª¡
.
a
.
bôs
.
	`addªss
(
	`log2Ceû
(
îr‹Së
.
Æignmít
)-1, 0))

164 
vÆ
 
sök_thªshﬁd
 = 
loˇlEdge
.
m™agî
.
ídSökId
.
U


165 
vÆ
 
loˇl_d
 = 
	`WúeInô
(
	`chi£lTy≥Of
(
∑ª¡
.
d
), 
loˇl
.d)

166 
vÆ
 
ªmŸe_d
 = 
	`WúeInô
(
	`chi£lTy≥Of
(
∑ª¡
.
d
), 
ªmŸe
.d)

167 
ªmŸe_d
.
bôs
.
sök
 :
ªmŸe
.
d
.bôs.sök + 
sök_thªshﬁd


168 
TLArbôî
.
	`robö
(
∑ª¡Edge
, 
∑ª¡
.
d
, 
loˇl_d
, 
ªmŸe_d
)

170 i‡(
∑ª¡Edge
.
m™agî
.
™ySuµ‹tAcquúeB
 &&Ö¨ítEdge.
˛õ¡
.
™ySuµ‹tProbe
) {

172 
	`as£π
 (!
loˇl
 .
b
.
vÆid
 || (÷oˇ».b.
bôs
.
addªss
 & 
mask
.
U
Ë==
loˇl_addªss
))

173 
	`as£π
 (!
ªmŸe
.
b
.
vÆid
 || (‘emŸe.b.
bôs
.
addªss
 & 
mask
.
U
Ë=/
loˇl_addªss
))

174 
TLArbôî
.
	`robö
(
∑ª¡Edge
, 
∑ª¡
.
b
, 
loˇl
.b, 
ªmŸe
.b)

177 
vÆ
 
c_loˇl
 = 
loˇl_addªss
 ==(
∑ª¡
.
c
.
bôs
.
addªss
 & 
mask
.
U
)

178 
∑ª¡
.
c
.
ªady
 :
	`Mux
(
c_loˇl
, 
loˇl
.c.ªady, 
ªmŸe
.c.ready)

179 
loˇl
 .
c
.
vÆid
 :
∑ª¡
.c.vÆid && 
c_loˇl


180 
ªmŸe
.
c
.
vÆid
 :
∑ª¡
.c.vÆid && !
c_loˇl


181 
loˇl
 .
c
.
bôs
 :
∑ª¡
.c.bits

182 
ªmŸe
.
c
.
bôs
 :
∑ª¡
.c.bits

185 
vÆ
 
e_loˇl
 = 
∑ª¡
.
e
.
bôs
.
sök
 < 
sök_thªshﬁd


186 
∑ª¡
.
e
.
ªady
 :
	`Mux
(
e_loˇl
, 
loˇl
.e.ªady, 
ªmŸe
.e.ready)

187 
loˇl
 .
e
.
vÆid
 :
∑ª¡
.e.vÆid && 
e_loˇl


188 
ªmŸe
.
e
.
vÆid
 :
∑ª¡
.e.vÆid && !
e_loˇl


189 
loˇl
 .
e
.
bôs
 :
∑ª¡
.e.bits

190 
ªmŸe
.
e
.
bôs
 :
∑ª¡
.e.bits

192 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Arbiter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
obje˘
 
	gTLArbôî


13 
ty≥
 
	gPﬁicy
 = (
I¡egî
, 
	gUI¡
, 
	gBoﬁ
Ë=> 
UI¡


15 
vÆ
 
lowe°IndexFú°
: 
Pﬁicy
 = (
width
, 
	gvÆids
, 
	g£À˘
Ë=> ~(
À·OR
(
vÆids
) << 1)(width-1, 0)

17 
vÆ
 
	groundRobö
: 
Pﬁicy
 = (
width
, 
	gvÆids
, 
	g£À˘
Ë=> i‡(width =1Ë
UI¡
(1, width=1) {

18 
vÆ
 
vÆid
 = 
vÆids
(
width
-1, 0)

19 
as£π
 (
vÆid
 ==
vÆids
)

20 
vÆ
 
mask
 = 
RegInô
(~
UI¡
(0, 
width
=width))

21 
vÆ
 
fûãr
 = 
C©
(
vÆid
 & ~
mask
, valid)

22 
vÆ
 
	guƒódy
 = (
rightOR
(
fûãr
, 
width
*2, widthË>> 1Ë| (
	gmask
 << 
	gwidth
)

23 
vÆ
 
	gªadys
 = ~((
uƒódy
 >> 
width
) & unready(width-1, 0))

24 
whí
 (
£À˘
 && 
vÆid
.
‹R
) {

25 
	gmask
 :
À·OR
(
ªadys
 & 
vÆid
, 
width
)

27 
ªadys
(
width
-1, 0)

30 
def
 
	glowe°FromSeq
[
T
 <: 
TLCh™√l
](
edge
: 
TLEdge
, 
	gsök
: 
Decou∂edIO
[T], 
	gsour˚s
: 
Seq
[DecoupledIO[T]]) {

31 
≠∂y
(
lowe°IndexFú°
)(
sök
, 
	gsour˚s
.
m≠
(
s
 => (
edge
.
numBóts1
(s.
bôs
), s)):
_
*)

34 
def
 
lowe°
[
T
 <: 
TLCh™√l
](
edge
: 
TLEdge
, 
	gsök
: 
Decou∂edIO
[T], 
	gsour˚s
: DecoupledIO[T]*) {

35 
≠∂y
(
lowe°IndexFú°
)(
sök
, 
	gsour˚s
.
	gtoLi°
.
m≠
(
s
 => (
edge
.
numBóts1
(s.
bôs
), s)):
_
*)

38 
def
 
robö
[
T
 <: 
TLCh™√l
](
edge
: 
TLEdge
, 
	gsök
: 
Decou∂edIO
[T], 
	gsour˚s
: DecoupledIO[T]*) {

39 
≠∂y
(
roundRobö
)(
sök
, 
	gsour˚s
.
	gtoLi°
.
m≠
(
s
 => (
edge
.
numBóts1
(s.
bôs
), s)):
_
*)

42 
def
 
≠∂y
[
T
 <: 
D©a
](
pﬁicy
: 
Pﬁicy
)(
sök
: 
Decou∂edIO
[T], 
	gsour˚s
: (
UI¡
, 
	gDecou∂edIO
[T])*) {

43 i‡(
	gsour˚s
.
	gisEm±y
) {

44 
	gsök
.
	gvÆid
 :
Boﬁ
(
Ál£
)

45 } i‡(
sour˚s
.
size
 == 1) {

46 
sök
 <> 
sour˚s
.
hód
.
_2


48 
vÆ
 
∑ús
 = 
sour˚s
.
toLi°


49 
vÆ
 
bótsIn
 = 
∑ús
.
m≠
(
_
.
_1
)

50 
vÆ
 
sour˚sIn
 = 
∑ús
.
m≠
(
_
.
_2
)

53 
vÆ
 
bótsLe·
 = 
RegInô
(
UI¡
(0))

54 
vÆ
 
idÀ
 = 
bótsLe·
 ==
UI¡
(0)

55 
vÆ
 
œtch
 = 
idÀ
 && 
sök
.
ªady


58 
vÆ
 
vÆids
 = 
sour˚sIn
.
m≠
(
_
.
vÆid
)

60 
vÆ
 
ªadys
 = 
Vec
(
pﬁicy
(
vÆids
.
size
, 
C©
(vÆids.
ªvî£
), 
œtch
).
toBoﬁs
)

62 
vÆ
 
	gwö√r
 = 
Vec
((
ªadys
 
zù
 
vÆids
Ë
m≠
 { (
r
,
v
) =>Ñ&&v })

65 
ªquúe
 (
ªadys
.
size
 =
vÆids
.size)

67 
vÆ
 
¥efixOR
 = 
wö√r
.
sˇnLe·
(
Boﬁ
(
Ál£
))(
_
||_).
öô


68 
as£π
((
¥efixOR
 
zù
 
wö√r
Ë
m≠
 { (
p
,
w
Ë=> !∞|| !w } 
ªdu˚
 {
_
 && _})

70 
as£π
 (!
vÆids
.
ªdu˚
(
_
||_Ë|| 
wö√r
.reduce(_||_))

73 
vÆ
 
	gmaskedBóts
 = (
wö√r
 
zù
 
bótsIn
Ë
m≠
 { (
w
,
b
Ë=> 
Mux
(w, b, 
UI¡
(0)) }

74 
vÆ
 
	göôBóts
 = 
maskedBóts
.
ªdu˚
(
_
 | _)

75 
bótsLe·
 :
Mux
(
œtch
, 
öôBóts
, bótsLe· - 
sök
.
fúe
())

78 
vÆ
 
	g°©e
 = 
RegInô
(
Vec
.
fûl
(
sour˚s
.
size
)(
Boﬁ
(
Ál£
)))

79 
vÆ
 
muxSèã
 = 
Mux
(
idÀ
, 
wö√r
, 
°©e
)

80 
	g°©e
 :
muxSèã


82 
vÆ
 
Ælowed
 = 
Mux
(
idÀ
, 
ªadys
, 
°©e
)

83 (
sour˚sIn
 
zù
 
	gÆlowed
Ë
	gf‹óch
 { (
	gs
, 
	gr
) =>

84 
s
.
ªady
 :
sök
.ªady && 
r


86 
sök
.
vÆid
 :
Mux
(
idÀ
, 
vÆids
.
ªdu˚
(
_
||_), 
Mux1H
(
°©e
, valids))

87 
	gsök
.
	gbôs
 :
Mux1H
(
muxSèã
, 
sour˚sIn
.
m≠
(
_
.
bôs
))

93 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


95 
˛ass
 
	$Te°Robö
(
txns
: 
I¡
 = 128, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

96 
vÆ
 
sour˚s
 = 
	`Wúe
(
	`Vec
(6, 
	`Decou∂edIO
(
	`UI¡
(
width
=3))))

97 
vÆ
 
sök
 = 
	`Wúe
(
	`Decou∂edIO
(
	`UI¡
(
width
=3)))

98 
vÆ
 
cou¡
 = 
	`RegInô
(
	`UI¡
(0, 
width
=8))

100 
vÆ
 
lf§
 = 
	`LFSR16
(
	`Boﬁ
(
åue
))

101 
vÆ
 
vÆid
 = 
	`lf§
(0)

102 
vÆ
 
ªady
 = 
	`lf§
(15)

104 
sour˚s
.
zùWôhIndex
.
m≠
 { (
z
, 
i
Ë=> z.
bôs
 :
	`UI¡
(i) }

105 
	`sour˚s
(0).
vÆid
 := valid

106 
	`sour˚s
(1).
vÆid
 :
	`Boﬁ
(
Ál£
)

107 
	`sour˚s
(2).
vÆid
 := valid

108 
	`sour˚s
(3).
vÆid
 := valid

109 
	`sour˚s
(4).
vÆid
 :
	`Boﬁ
(
Ál£
)

110 
	`sour˚s
(5).
vÆid
 := valid

111 
sök
.
ªady
 :=Ñeady

113 
	`TLArbôî
(
TLArbôî
.
roundRobö
)(
sök
, 
sour˚s
.
zùWôhIndex
.
m≠
 { (
z
, 
i
Ë=> (
	`UI¡
(i), zË}:
_
*)

114 
	`whí
 (
sök
.
	`fúe
()Ë{ 
	`¥ötf
("Te°Robö: %d\n", sök.
bôs
) }

115 
	`whí
 (!
sök
.
	`fúe
()Ë{ 
	`¥ötf
("Te°Robö: idÀ (%d %d)\n", 
vÆid
, 
ªady
) }

117 
cou¡
 :cou¡ + 
	`UI¡
(1)

118 
io
.
föished
 :
cou¡
 >
	`UI¡
(
txns
)

119 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AsyncCrossing.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.
CrossögWøµî


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


12 
˛ass
 
	$TLAsyncCrossögSour˚
(
sync
: 
O±i⁄
[
I¡
])(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
def
 
	`this
(
x
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ëthis(
	`Some
(x))

15 
def
 
	`this
()(
im∂icô
 
p
: 
P¨amëîs
Ëthis(
N⁄e
)

17 
vÆ
 
node
 = 
	`TLAsyncSour˚Node
(
sync
)

19 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

20 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

21 
vÆ
 
b˚
 = 
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeIn.
˛õ¡
.
™ySuµ‹tProbe


22 
vÆ
 
psync
 = 
sync
.
	`gëOrEl£
(
edgeOut
.
m™agî
.
async
.sync)

23 
vÆ
 
∑øms
 = 
edgeOut
.
m™agî
.
async
.
	`c›y
(
sync
 = 
psync
)

25 
out
.
a
 <> 
	`ToAsyncBundÀ
(
ö
.a, 
∑øms
)

26 
ö
.
d
 <> 
	`FromAsyncBundÀ
(
out
.d, 
psync
)

27 
	`covî
(
ö
.
a
, "TL_ASYNC_CROSSING_SOURCE_A", "MemorySystem;;TLAsyncCrossingSource Channel A")

28 
	`covî
(
ö
.
d
, "TL_ASYNC_CROSSING_SOURCE_D", "MemorySystem;;TLAsyncCrossingSource Channel D")

30 i‡(
b˚
) {

31 
ö
.
b
 <> 
	`FromAsyncBundÀ
(
out
.b, 
psync
)

32 
out
.
c
 <> 
	`ToAsyncBundÀ
(
ö
.c, 
∑øms
)

33 
out
.
e
 <> 
	`ToAsyncBundÀ
(
ö
.e, 
∑øms
)

34 
	`covî
(
ö
.
b
, "TL_ASYNC_CROSSING_SOURCE_B", "MemorySystem;;TLAsyncCrossingSource Channel B")

35 
	`covî
(
ö
.
c
, "TL_ASYNC_CROSSING_SOURCE_C", "MemorySystem;;TLAsyncCrossingSource Channel C")

36 
	`covî
(
ö
.
e
, "TL_ASYNC_CROSSING_SOURCE_E", "MemorySystem;;TLAsyncCrossingSource Channel E")

38 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

39 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

40 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

41 
out
.
b
.
ridx
 :
	`UI¡
(0)

42 
out
.
c
.
widx
 :
	`UI¡
(0)

43 
out
.
e
.
widx
 :
	`UI¡
(0)

47 
	}
}

49 
˛ass
 
TLAsyncCrossögSök
(
∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
())(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


51 
vÆ
 
node
 = 
	`TLAsyncSökNode
(
∑øms
)

53 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

54 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

55 
vÆ
 
b˚
 = 
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeOut.
˛õ¡
.
™ySuµ‹tProbe


57 
out
.
a
 <> 
	`FromAsyncBundÀ
(
ö
.a, 
∑øms
.
sync
)

58 
ö
.
d
 <> 
	`ToAsyncBundÀ
(
out
.d, 
∑øms
)

59 
	`covî
(
out
.
a
, "TL_ASYNC_CROSSING_SINK_A", "MemorySystem;;TLAsyncCrossingSink Channel A")

60 
	`covî
(
out
.
d
, "TL_ASYNC_CROSSING_SINK_D", "MemorySystem;;TLAsyncCrossingSink Channel D")

62 i‡(
b˚
) {

63 
ö
.
b
 <> 
	`ToAsyncBundÀ
(
out
.b, 
∑øms
)

64 
out
.
c
 <> 
	`FromAsyncBundÀ
(
ö
.c, 
∑øms
.
sync
)

65 
out
.
e
 <> 
	`FromAsyncBundÀ
(
ö
.e, 
∑øms
.
sync
)

66 
	`covî
(
out
.
b
, "TL_ASYNC_CROSSING_SINK_B", "MemorySystem;;TLAsyncCrossingSinkChannel B")

67 
	`covî
(
out
.
c
, "TL_ASYNC_CROSSING_SINK_C", "MemorySystem;;TLAsyncCrossingSink Channel C")

68 
	`covî
(
out
.
e
, "TL_ASYNC_CROSSING_SINK_E", "MemorySystem;;TLAsyncCrossingSink Channel E")

70 
ö
.
b
.
widx
 :
	`UI¡
(0)

71 
ö
.
c
.
ridx
 :
	`UI¡
(0)

72 
ö
.
e
.
ridx
 :
	`UI¡
(0)

73 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

74 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

75 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

79 
	}
}

81 
obje˘
 
TLAsyncCrossögSour˚


83 
def
 
≠∂y
()(
im∂icô
 
p
: 
P¨amëîs
): 
TLAsyncSour˚Node
 =áµly(
N⁄e
)

84 
def
 
≠∂y
(
sync
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLAsyncSour˚Node
 =áµly(
Some
(sync))

85 
def
 
≠∂y
(
sync
: 
O±i⁄
[
I¡
])(
im∂icô
 
p
: 
P¨amëîs
): 
TLAsyncSour˚Node
 =

87 
vÆ
 
asour˚
 = 
LazyModuÀ
(
√w
 
TLAsyncCrossögSour˚
(
sync
))

88 
asour˚
.
node


92 
obje˘
 
TLAsyncCrossögSök


94 
def
 
≠∂y
(
∑øms
: 
AsyncQueueP¨ams
 = AsyncQueueP¨ams())(
im∂icô
 
p
: 
P¨amëîs
) =

96 
vÆ
 
asök
 = 
LazyModuÀ
(
√w
 
TLAsyncCrossögSök
(
∑øms
))

97 
asök
.
node


101 @
dïªˇãd
("TLAsyncCrossing is fragile. Use TLAsyncCrossingSourceánd TLAsyncCrossingSink", "rocket-chip 1.2")

102 
˛ass
 
TLAsyncCrossög
(
∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
())(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


104 
vÆ
 
sour˚
 = 
	`LazyModuÀ
(
√w
 
	`TLAsyncCrossögSour˚
())

105 
vÆ
 
sök
 = 
	`LazyModuÀ
(
√w
 
	`TLAsyncCrossögSök
(
∑øms
))

106 
vÆ
 
node
 = 
	`NodeH™dÀ
(
sour˚
.node, 
sök
.node)

108 
sök
.
node
 :
sour˚
.node

110 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

111 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

112 
vÆ
 
ö_˛ock
 = 
	`Clock
(
INPUT
)

113 
vÆ
 
ö_ª£t
 = 
	`Boﬁ
(
INPUT
)

114 
vÆ
 
out_˛ock
 = 
	`Clock
(
INPUT
)

115 
vÆ
 
out_ª£t
 = 
	`Boﬁ
(
INPUT
)

118 
sour˚
.
moduÀ
.
˛ock
 :
io
.
ö_˛ock


119 
sour˚
.
moduÀ
.
ª£t
 :
io
.
ö_ª£t


120 
sök
.
moduÀ
.
˛ock
 :
io
.
out_˛ock


121 
sök
.
moduÀ
.
ª£t
 :
io
.
out_ª£t


123 
	}
}

126 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


128 
˛ass
 
TLRAMAsyncCrossög
(
txns
: 
I¡
, 
∑øms
: 
Asynchr⁄ousCrossög
 = 
	$Asynchr⁄ousCrossög
())(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

129 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AsyncCrossing"))

130 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

131 
vÆ
 
i¶™d
 = 
	`LazyModuÀ
(
√w
 
	`CrossögWøµî
(
∑øms
))

132 
vÆ
 
øm
 = 
i¶™d
 { 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0x0, 0x3ff))) }

134 
i¶™d
.
	`¸ossTLIn
(
øm
.
node
Ë:
	`TLFøgmíãr
(4, 256Ë:
	`TLDñayî
(0.1Ë:
modñ
.nodê:
fuzz
.node

136 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

137 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

140 
vÆ
 
˛ocks
 = 
	`ModuÀ
(
√w
 
	`Pow2ClockDividî
(2))

141 
i¶™d
.
moduÀ
.
˛ock
 :
˛ocks
.
io
.
˛ock_out


143 
	}
}

145 
˛ass
 
	$TLRAMAsyncCrossögTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

146 
vÆ
 
dut_wide
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMAsyncCrossög
(
txns
)).
moduÀ
)

147 
vÆ
 
dut_«ºow
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMAsyncCrossög
(
txns
, 
	`Asynchr⁄ousCrossög
(
ß„
 = 
Ál£
, 
«ºow
 = 
åue
))).
moduÀ
)

148 
io
.
föished
 :
dut_wide
.io.föished && 
dut_«ºow
.io.finished

149 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AtomicAutomata.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

13 
˛ass
 
	$TLAtomicAutom©a
(
logiˇl
: 
Boﬁón
 = 
åue
, 
¨ôhmëic
: Boﬁó¿åue, 
c⁄cuºícy
: 
I¡
 = 1, 
∑s°hrough
: Boﬁó¿åue)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


15 
	`ªquúe
 (
c⁄cuºícy
 >= 1)

17 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

18 
m™agîFn
 = { 
mp
 => mp.
	`c›y
(
m™agîs
 = mp.m™agîs.
m≠
 { 
m
 =>

19 
vÆ
 
ourSuµ‹t
 = 
	`Tøns„rSizes
(1, 
mp
.
bótByãs
)

20 
def
 
	`widí
(
x
: 
Tøns„rSizes
Ëi‡(
∑s°hrough
 && x.
mö
 <2*
mp
.
bótByãs
Ë
	`Tøns„rSizes
(1, 
	`max
(mp.bótByãs, x.
max
)Ë
ourSuµ‹t


21 
vÆ
 
ˇnDoô
 = 
m
.
suµ‹tsPutFuŒ
.
	`c⁄èös
(
ourSuµ‹t
Ë&& m.
suµ‹tsGë
.contains(ourSupport)

23 
	`ªquúe
 (!
m
.
suµ‹tsPutFuŒ
 || !m.
suµ‹tsGë
 || 
ˇnDoô
, 
s
"${m.name} has $ourSupport,Çeeded PutFull(${m.supportsPutFull}) or Get(${m.supportsGet})")

24 
m
.
	`c›y
(

25 
suµ‹tsArôhmëic
 = i‡(!
¨ôhmëic
 || !
ˇnDoô
Ë
m
.suµ‹tsArôhmëi¯
	`widí
(m.supportsArithmetic),

26 
suµ‹tsLogiˇl
 = i‡(!
logiˇl
 || !
ˇnDoô
Ë
m
.suµ‹tsLogiˇ»
	`widí
(m.supportsLogical),

27 
mayDíyGë
 = 
m
.mayDíyGë || m.
mayDíyPut
)

30 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

31 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

32 
vÆ
 
m™agîs
 = 
edgeOut
.
m™agî
.managers

33 
vÆ
 
bótByãs
 = 
edgeOut
.
m™agî
.beatBytes

36 
edgeOut
.
m™agî
.
	`födTªeViﬁ©i⁄
(Ë
m©ch
 {

37 
N⁄e
 => ()

38 
	`Some
(
node
Ë=> 
	`ªquúe
(
edgeOut
.
m™agî
.
isTªe
, 
s
"AtomicAutomata can only beÖlaced infront ofáÅree of diplomaticÇodes (${node.name} hasÖarents ${node.inputs.map(_._1.name)})")

43 
vÆ
 
ourSuµ‹t
 = 
	`Tøns„rSizes
(1, 
edgeOut
.
m™agî
.
bótByãs
)

44 
vÆ
 
m™agîsNìdögHñp
 = 
m™agîs
.
fûãr
 { 
m
 =>

45 
m
.
suµ‹tsPutFuŒ
.
	`c⁄èös
(
ourSuµ‹t
) &&

46 
m
.
suµ‹tsGë
.
	`c⁄èös
(
ourSuµ‹t
) &&

47 ((
logiˇl
 && !
m
.
suµ‹tsLogiˇl
 .
	`c⁄èös
(
ourSuµ‹t
)) ||

48 (
¨ôhmëic
 && !
m
.
suµ‹tsArôhmëic
.
	`c⁄èös
(
ourSuµ‹t
)) ||

49 !
∑s°hrough
)

52 
m™agîsNìdögHñp
 
f‹óch
 { 
m
 => 
	`ªquúe
 (m.
fifoId
.
isDeföed
) }

57 
vÆ
 
domaösNìdögHñp
 = 
m™agîsNìdögHñp
.
	`m≠
(
_
.
fifoId
.
gë
).
di°ö˘


59 
vÆ
 
ˇmSize
 = 
	`mö
(
domaösNìdögHñp
.
size
, 
c⁄cuºícy
)

61 
def
 
	`ˇmFifoId
(
m
: 
TLM™agîP¨amëîs
Ëm.
fifoId
.
	`m≠
(
id
 => 
	`max
(0, 
domaösNìdögHñp
.
	`ödexOf
(id))).
	`gëOrEl£
(0)

64 
vÆ
 
FREE
 = 
	`UI¡
(0)

65 
vÆ
 
GET
 = 
	`UI¡
(3)

66 
vÆ
 
AMO
 = 
	`UI¡
(2)

67 
vÆ
 
ACK
 = 
	`UI¡
(1)

69 
vÆ
 
∑øms
 = 
TLAtomicAutom©a
.
	`CAMP¨ams
(
out
.
a
.
bôs
.∑øms, 
domaösNìdögHñp
.
size
)

71 i‡(
ˇmSize
 > 0) {

72 
vÆ
 
öôvÆ
 = 
	`Wúe
(
√w
 
TLAtomicAutom©a
.
	`CAM_S
(
∑øms
))

73 
öôvÆ
.
°©e
 :
FREE


74 
vÆ
 
ˇm_s
 = 
	`RegInô
(
Vec
.
	`fûl
(
ˇmSize
)(
öôvÆ
))

75 
vÆ
 
ˇm_a
 = 
	`Reg
(
	`Vec
(
ˇmSize
, 
√w
 
TLAtomicAutom©a
.
	`CAM_A
(
∑øms
)))

76 
vÆ
 
ˇm_d
 = 
	`Reg
(
	`Vec
(
ˇmSize
, 
√w
 
TLAtomicAutom©a
.
	`CAM_D
(
∑øms
)))

78 
vÆ
 
ˇm_‰ì
 = 
ˇm_s
.
	`m≠
(
_
.
°©e
 ==
FREE
)

79 
vÆ
 
ˇm_amo
 = 
ˇm_s
.
	`m≠
(
_
.
°©e
 ==
AMO
)

80 
vÆ
 
ˇm_abusy
 = 
ˇm_s
.
	`m≠
(
e
 =>É.
°©e
 ==
GET
 ||É.°©ê==
AMO
)

81 
vÆ
 
ˇm_dm©ch
 = 
ˇm_s
.
	`m≠
(
e
 =>É.
°©e
 =/
FREE
)

84 
vÆ
 
a_addªss
 = 
edgeIn
.
	`addªss
(
ö
.
a
.
bôs
)

85 
vÆ
 
a_size
 = 
edgeIn
.
	`size
(
ö
.
a
.
bôs
)

86 
vÆ
 
a_ˇnLogiˇl
 = 
	`Boﬁ
(
∑s°hrough
Ë&& 
edgeOut
.
m™agî
.
	`suµ‹tsLogiˇlFa°
 (
a_addªss
, 
a_size
)

87 
vÆ
 
a_ˇnArôhmëic
 = 
	`Boﬁ
(
∑s°hrough
Ë&& 
edgeOut
.
m™agî
.
	`suµ‹tsArôhmëicFa°
(
a_addªss
, 
a_size
)

88 
vÆ
 
a_isLogiˇl
 = 
ö
.
a
.
bôs
.
›code
 ==
TLMesßges
.
LogiˇlD©a


89 
vÆ
 
a_isArôhmëic
 = 
ö
.
a
.
bôs
.
›code
 ==
TLMesßges
.
ArôhmëicD©a


90 
vÆ
 
a_isSuµ‹ãd
 = 
	`Mux
(
a_isLogiˇl
, 
a_ˇnLogiˇl
, Mux(
a_isArôhmëic
, 
a_ˇnArôhmëic
, 
	`Boﬁ
(
åue
)))

93 
vÆ
 
a_ˇm_™y_put
 = 
ˇm_amo
.
	`ªdu˚
(
_
 || _)

94 
vÆ
 
a_ˇm_p‹_put
 = 
ˇm_amo
.
	`sˇnLe·
(
	`Boﬁ
(
Ál£
))(
_
||_).
öô


95 
vÆ
 
a_ˇm_£l_put
 = (
ˇm_amo
 
zù
 
a_ˇm_p‹_put
Ë
m≠
 { (
a
, 
b
) =>á && !b }

96 
vÆ
 
a_ˇm_a
 = 
	`Pri‹ôyMux
(
ˇm_amo
, 
ˇm_a
)

97 
vÆ
 
a_ˇm_d
 = 
	`Pri‹ôyMux
(
ˇm_amo
, 
ˇm_d
)

98 
vÆ
 
a_a
 = 
a_ˇm_a
.
bôs
.
d©a


99 
vÆ
 
a_d
 = 
a_ˇm_d
.
d©a


102 
vÆ
 
a_fifoId
 = 
edgeOut
.
m™agî
.
	`Á°Pr›îty
(
a_addªss
, 
ˇmFifoId
 
_
, (
i
:
I¡
Ë=> 
	`UI¡
(i))

103 
vÆ
 
a_ˇm_busy
 = (
ˇm_abusy
 
zù
 
ˇm_a
.
	`m≠
(
_
.
fifoId
 ==
a_fifoId
)Ë
m≠
 { (
a
,
b
Ë=>á&&b } 
	`ªdu˚
 (_||_)

106 
vÆ
 
a_ˇm_™y_‰ì
 = 
ˇm_‰ì
.
	`ªdu˚
(
_
 || _)

107 
vÆ
 
a_ˇm_p‹_‰ì
 = 
ˇm_‰ì
.
	`sˇnLe·
(
	`Boﬁ
(
Ál£
))(
_
||_).
öô


108 
vÆ
 
a_ˇm_£l_‰ì
 = (
ˇm_‰ì
 
zù
 
a_ˇm_p‹_‰ì
Ë
m≠
 { (
a
,
b
) =>á && !b }

111 
vÆ
 
ödexes
 = 
Seq
.
	`èbuœã
(
bótByãs
*8Ë{ 
i
 => 
	`C©
(
	`a_a
(i,i), 
	`a_d
(i,i)) }

112 
vÆ
 
logic_out
 = 
	`C©
(
ödexes
.
	`m≠
(
x
 => 
a_ˇm_a
.
	`lut
(x).
asUI¡
).
ªvî£
)

115 
vÆ
 
a_ˇm_a
.
bôs
.
	`∑øm
(1)

116 
vÆ
 
èke_max
 = 
a_ˇm_a
.
bôs
.
	`∑øm
(0)

117 
vÆ
 
addî
 = 
a_ˇm_a
.
bôs
.
	`∑øm
(2)

118 
vÆ
 
mask
 = 
a_ˇm_a
.
bôs
.mask

119 
vÆ
 
signSñ
 = ~(~
mask
 | (mask >> 1))

120 
vÆ
 
signbôs_a
 = 
	`C©
(
Seq
.
	`èbuœã
(
bótByãs
Ë{ 
i
 => 
	`a_a
(8*i+7,8*i+7Ë} .
ªvî£
)

121 
vÆ
 
signbôs_d
 = 
	`C©
(
Seq
.
	`èbuœã
(
bótByãs
Ë{ 
i
 => 
	`a_d
(8*i+7,8*i+7Ë} .
ªvî£
)

123 
vÆ
 
signbô_a
 = ((
signbôs_a
 & 
signSñ
Ë<< 1)(
bótByãs
-1, 0)

124 
vÆ
 
signbô_d
 = ((
signbôs_d
 & 
signSñ
Ë<< 1)(
bótByãs
-1, 0)

125 
vÆ
 
sig√xt_a
 = 
	`FûlI¡îÀaved
(8, 
	`À·OR
(
signbô_a
))

126 
vÆ
 
sig√xt_d
 = 
	`FûlI¡îÀaved
(8, 
	`À·OR
(
signbô_d
))

128 
vÆ
 
wide_mask
 = 
	`FûlI¡îÀaved
(8, 
mask
)

129 
vÆ
 
a_a_ext
 = (
a_a
 & 
wide_mask
Ë| 
sig√xt_a


130 
vÆ
 
a_d_ext
 = (
a_d
 & 
wide_mask
Ë| 
sig√xt_d


131 
vÆ
 
a_d_öv
 = 
	`Mux
(
addî
, 
a_d_ext
, ~a_d_ext)

132 
vÆ
 
addî_out
 = 
a_a_ext
 + 
a_d_öv


133 
vÆ
 
h
 = 8*
bótByãs
-1

134 
vÆ
 
a_biggî_u√q
 = ==
	`a_a_ext
(
h
)

135 
vÆ
 
a_biggî
 = 
	`Mux
(
	`a_a_ext
(
h
Ë==
	`a_d_ext
(h), !
	`addî_out
(h), 
a_biggî_u√q
)

136 
vÆ
 
pick_a
 = 
èke_max
 ==
a_biggî


137 
vÆ
 
¨ôh_out
 = 
	`Mux
(
addî
, 
addî_out
, Mux(
pick_a
, 
a_a
, 
a_d
))

140 
vÆ
 
amo_d©a
 =

141 i‡(!
logiˇl
Ë
¨ôh_out
 

142 i‡(!
¨ôhmëic
Ë
logic_out
 

143 
	`Mux
(
a_ˇm_a
.
bôs
.
	`›code
(0), 
logic_out
, 
¨ôh_out
)

146 
vÆ
 
sour˚_i
 = 
	`Wúe
(
ö
.
a
)

147 
vÆ
 
a_Ælow
 = !
a_ˇm_busy
 && (
a_isSuµ‹ãd
 || 
a_ˇm_™y_‰ì
)

148 
ö
.
a
.
ªady
 :
sour˚_i
.ªady && 
a_Ælow


149 
sour˚_i
.
vÆid
 :
ö
.
a
.vÆid && 
a_Ælow


150 
sour˚_i
.
bôs
 :
ö
.
a
.bits

151 
	`whí
 (!
a_isSuµ‹ãd
) {

152 
sour˚_i
.
bôs
.
›code
 :
TLMesßges
.
Gë


153 
sour˚_i
.
bôs
.
∑øm
 :
	`UI¡
(0)

157 
vÆ
 
sour˚_c
 = 
	`Wúe
(
ö
.
a
)

158 
sour˚_c
.
vÆid
 :
a_ˇm_™y_put


159 
sour˚_c
.
bôs
 :
edgeOut
.
	`Put
(

160 
‰omSour˚
 = 
a_ˇm_a
.
bôs
.
sour˚
,

161 
toAddªss
 = 
edgeIn
.
	`addªss
(
a_ˇm_a
.
bôs
),

162 
lgSize
 = 
a_ˇm_a
.
bôs
.
size
,

163 
d©a
 = 
amo_d©a
,

164 
c‹ru±
 = 
a_ˇm_a
.
bôs
.c‹ru± || 
a_ˇm_d
.c‹ru±).
_2


167 
	`TLArbôî
(
TLArbôî
.
lowe°IndexFú°
)(
out
.
a
, (
	`UI¡
(0), 
sour˚_c
), (
edgeOut
.
	`numBóts1
(
ö
.a.
bôs
), 
sour˚_i
))

170 
	`whí
 (
sour˚_i
.
	`fúe
(Ë&& !
a_isSuµ‹ãd
) {

171 (
a_ˇm_£l_‰ì
 
zù
 
ˇm_a
Ë
f‹óch
 { (
í
, 
r
) =>

172 
	`whí
 (
í
) {

173 
r
.
fifoId
 :
a_fifoId


174 
r
.
bôs
 :
ö
.
a
.bits

175 
r
.
lut
 :
	`MuxLookup
(
ö
.
a
.
bôs
.
	`∑øm
(1, 0), 
	`UI¡
(0, 
width
 = 4), 
	`Aºay
(

176 
TLAtomics
.
AND
 -> 
	`UI¡
(0x8),

177 
TLAtomics
.
OR
 -> 
	`UI¡
(0xe),

178 
TLAtomics
.
XOR
 -> 
	`UI¡
(0x6),

179 
TLAtomics
.
SWAP
 -> 
	`UI¡
(0xc)))

182 (
a_ˇm_£l_‰ì
 
zù
 
ˇm_s
Ë
f‹óch
 { (
í
, 
r
) =>

183 
	`whí
 (
í
) {

184 
r
.
°©e
 :
GET


190 
	`whí
 (
sour˚_c
.
	`fúe
()) {

191 (
a_ˇm_£l_put
 
zù
 
ˇm_s
Ë
f‹óch
 { (
í
, 
r
) =>

192 
	`whí
 (
í
) {

193 
r
.
°©e
 :
ACK


199 
vÆ
 
d_fú°
 = 
edgeOut
.
	`fú°
(
out
.
d
)

200 
vÆ
 
d_ˇm_£l_øw
 = 
ˇm_a
.
	`m≠
(
_
.
bôs
.
sour˚
 ==
ö
.
d
.bits.source)

201 
vÆ
 
d_ˇm_£l_m©ch
 = (
d_ˇm_£l_øw
 
zù
 
ˇm_dm©ch
Ë
m≠
 { (
a
,
b
) =>á&&b }

202 
vÆ
 
d_ˇm_d©a
 = 
	`Mux1H
(
d_ˇm_£l_m©ch
, 
ˇm_d
.
	`m≠
(
_
.
d©a
))

203 
vÆ
 
d_ˇm_díõd
 = 
	`Mux1H
(
d_ˇm_£l_m©ch
, 
ˇm_d
.
	`m≠
(
_
.
díõd
))

204 
vÆ
 
d_ˇm_c‹ru±
 = 
	`Mux1H
(
d_ˇm_£l_m©ch
, 
ˇm_d
.
	`m≠
(
_
.
c‹ru±
))

205 
vÆ
 
d_ˇm_£l_by∑ss
 = i‡(
edgeOut
.
m™agî
.
möL©ícy
 > 0Ë
	`Boﬁ
(
Ál£
) 

206 
out
.
d
.
bôs
.
sour˚
 ==
ö
.
a
.bôs.sour˚ && in.a.
vÆid
 && !
a_isSuµ‹ãd


207 
vÆ
 
d_ˇm_£l
 = (
a_ˇm_£l_‰ì
 
zù
 
d_ˇm_£l_m©ch
Ë
m≠
 { (
a
,
d
Ë=> 
	`Mux
(
d_ˇm_£l_by∑ss
,á, d) }

208 
vÆ
 
d_ˇm_£l_™y
 = 
d_ˇm_£l_by∑ss
 || 
d_ˇm_£l_m©ch
.
	`ªdu˚
(
_
 || _)

209 
vÆ
 
d_ackd
 = 
out
.
d
.
bôs
.
›code
 ==
TLMesßges
.
Ac˚ssAckD©a


210 
vÆ
 
d_ack
 = 
out
.
d
.
bôs
.
›code
 ==
TLMesßges
.
Ac˚ssAck


212 
	`whí
 (
out
.
d
.
	`fúe
(Ë&& 
d_fú°
) {

213 (
d_ˇm_£l
 
zù
 
ˇm_d
Ë
f‹óch
 { (
í
, 
r
) =>

214 
	`whí
 (
í
 && 
d_ackd
) {

215 
r
.
d©a
 :
out
.
d
.
bôs
.data

216 
r
.
díõd
 :
out
.
d
.
bôs
.denied

217 
r
.
c‹ru±
 :
out
.
d
.
bôs
.corrupt

220 (
d_ˇm_£l
 
zù
 
ˇm_s
Ë
f‹óch
 { (
í
, 
r
) =>

221 
	`whí
 (
í
) {

223 
r
.
°©e
 :
	`Mux
(
d_ackd
, 
AMO
, 
FREE
)

228 
vÆ
 
d_dr›
 = 
d_fú°
 && 
d_ackd
 && 
d_ˇm_£l_™y


229 
vÆ
 
d_ª∂a˚
 = 
d_fú°
 && 
d_ack
 && 
d_ˇm_£l_m©ch
.
	`ªdu˚
(
_
 || _)

231 
ö
.
d
.
vÆid
 :
out
.d.vÆid && !
d_dr›


232 
out
.
d
.
ªady
 :
ö
.d.ªady || 
d_dr›


234 
ö
.
d
.
bôs
 :
out
.d.bits

235 
	`whí
 (
d_ª∂a˚
) {

236 
ö
.
d
.
bôs
.
›code
 :
TLMesßges
.
Ac˚ssAckD©a


237 
ö
.
d
.
bôs
.
d©a
 :
d_ˇm_d©a


238 
ö
.
d
.
bôs
.
c‹ru±
 :
d_ˇm_c‹ru±
 || 
out
.d.bôs.
díõd


239 
ö
.
d
.
bôs
.
díõd
 :
d_ˇm_díõd
 || 
out
.d.bits.denied

242 
out
.
a
.
vÆid
 :
ö
.a.valid

243 
ö
.
a
.
ªady
 :
out
.a.ready

244 
out
.
a
.
bôs
 :
ö
.a.bits

246 
ö
.
d
.
vÆid
 :
out
.d.valid

247 
out
.
d
.
ªady
 :
ö
.d.ready

248 
ö
.
d
.
bôs
 :
out
.d.bits

251 i‡(
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 && 
edgeIn
.
˛õ¡
.
™ySuµ‹tProbe
) {

252 
ö
.
b
.
vÆid
 :
out
.b.valid

253 
out
.
b
.
ªady
 :
ö
.b.ready

254 
ö
.
b
.
bôs
 :
out
.b.bits

256 
out
.
c
.
vÆid
 :
ö
.c.valid

257 
ö
.
c
.
ªady
 :
out
.c.ready

258 
out
.
c
.
bôs
 :
ö
.c.bits

260 
out
.
e
.
vÆid
 :
ö
.e.valid

261 
ö
.
e
.
ªady
 :
out
.e.ready

262 
out
.
e
.
bôs
 :
ö
.e.bits

264 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

265 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

266 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

267 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

268 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

269 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

273 
	}
}

275 
obje˘
 
TLAtomicAutom©a


277 
def
 
≠∂y
(
logiˇl
: 
Boﬁón
 = 
åue
, 
¨ôhmëic
: Boﬁó¿åue, 
c⁄cuºícy
: 
I¡
 = 1, 
∑s°hrough
: Boﬁó¿åue)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

279 
vÆ
 
©omics
 = 
LazyModuÀ
(
√w
 
TLAtomicAutom©a
(
logiˇl
, 
¨ôhmëic
, 
c⁄cuºícy
, 
∑s°hrough
))

280 
	g©omics
.
	gnode


283 
˛ass
 
CAMP¨ams
(
a
: 
TLBundÀP¨amëîs
, 
domaösNìdögHñp
: 
I¡
)

285 ˛as†
	cCAM_S
(
∑øms
: 
CAMP¨ams
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
) {

286 
vÆ
 
°©e
 = 
	`UI¡
(
width
 = 2)

287 
	}
}

288 ˛as†
	cCAM_A
(
∑øms
: 
CAMP¨ams
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
) {

289 
vÆ
 
bôs
 = 
√w
 
	`TLBundÀA
(
∑øms
.
a
)

290 
vÆ
 
fifoId
 = 
	`UI¡
(
width
 = 
	`log2Up
(
∑øms
.
domaösNìdögHñp
))

291 
vÆ
 
lut
 = 
	`UI¡
(
width
 = 4)

292 
	}
}

293 ˛as†
	cCAM_D
(
∑øms
: 
CAMP¨ams
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
) {

294 
vÆ
 
d©a
 = 
	`UI¡
(
width
 = 
∑øms
.
a
.
d©aBôs
)

295 
vÆ
 
díõd
 = 
	`Boﬁ
()

296 
vÆ
 
c‹ru±
 = 
	`Boﬁ
()

297 
	}
}

301 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


303 ˛as†
	cTLRAMAtomicAutom©a
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

304 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

305 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("AtomicAutomata"))

306 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	$AddªssSë
(0x0, 0x3ff)))

309 
imp‹t
 
TLMesßges
.
_


310 
vÆ
 
ã°
 = 
√w
 
	`Reque°P©ã∫
({
a
: 
TLBundÀA
 =>

311 
vÆ
 
d€sA
 = 
a
.
›code
 ==
ArôhmëicD©a
 ||á.›codê==
LogiˇlD©a


312 
vÆ
 
d€sR
 = 
a
.
›code
 ==
Gë
 || 
d€sA


313 
vÆ
 
d€sW
 = 
a
.
›code
 ==
PutFuŒD©a
 ||á.›codê==
PutP¨tülD©a
 || 
d€sA


314 (
d€sR
 && 
Reque°P©ã∫
.
	`ovîœps
(
	`Seq
(
	`AddªssSë
(0x08, ~0x08)))(
a
)) ||

315 (
d€sW
 && 
Reque°P©ã∫
.
	`ovîœps
(
	`Seq
(
	`AddªssSë
(0x10, ~0x10)))(
a
))

318 (
øm
.
node


319 :
	$TLEº‹EvÆu©‹
(
ã°
)

320 :
	$TLFøgmíãr
(4, 256)

321 :
	$TLDñayî
(0.1)

322 :
	$TLAtomicAutom©a
()

323 :
	$TLDñayî
(0.1)

324 :
	$TLEº‹EvÆu©‹
(
ã°
, 
ã°On
=
åue
, 
ã°Off
=true)

325 :
modñ
.
node


326 :
fuzz
.
node
)

328 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

329 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

330 
	}
}

333 
˛ass
 
	$TLRAMAtomicAutom©aTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

334 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMAtomicAutom©a
(
txns
)).
moduÀ
)

335 
io
.
föished
 :
dut
.io.finished

336 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Atomics.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gTLMesßges
.
_


8 
imp‹t
 
	gTLPîmissi⁄s
.
_


10 ˛as†
	cAtomics
(
∑øms
: 
TLBundÀP¨amëîs
Ë
exãnds
 
ModuÀ


12 
vÆ
 
io
 = 
√w
 
BundÀ
 {

13 
vÆ
 
wrôe
 = 
	`Boﬁ
().
Êù


14 
vÆ
 
a
 = 
√w
 
	`TLBundÀA
(
∑øms
).
Êù


15 
vÆ
 
d©a_ö
 = 
	`UI¡
(
width
 = 
∑øms
.
d©aBôs
).
Êù


16 
vÆ
 
d©a_out
 = 
	`UI¡
(
width
 = 
∑øms
.
d©aBôs
)

20 
vÆ
 
addî
 = 
io
.
a
.
	$∑øm
(2)

21 
vÆ
 
io
.
a
.
	$∑øm
(1)

22 
vÆ
 
èke_max
 = 
io
.
a
.
	$∑øm
(0)

24 
vÆ
 
signBô
 = 
io
.
a
.
mask
 & 
	`C©
(
	`UI¡
(1), ~io.a.mask >> 1)

25 
vÆ
 
öv_d
 = 
	`Mux
(
addî
, 
io
.
d©a_ö
, ~io.data_in)

26 
vÆ
 
sum
 = (
	`FûlI¡îÀaved
(8, 
io
.
a
.
mask
Ë& io.a.
d©a
Ë+ 
öv_d


27 
def
 
	$sign
(
x
: 
UI¡
): 
Boﬁ
 = (
	`C©
(x.
toBoﬁs
.
	`grou≥d
(8).
	`m≠
(
_
.
œ°
).
toLi°
.
ªvî£
Ë& 
signBô
).
	$‹R
()

28 
vÆ
 
sign_a
 = 
	$sign
(
io
.
a
.
d©a
)

29 
vÆ
 
sign_d
 = 
	$sign
(
io
.
d©a_ö
)

30 
vÆ
 
sign_s
 = 
	$sign
(
sum
)

31 
vÆ
 
a_biggî_u√q
 = ==
sign_a


32 
vÆ
 
a_biggî
 = 
	`Mux
(
sign_a
 ==
sign_d
, !
sign_s
, 
a_biggî_u√q
)

33 
vÆ
 
pick_a
 = 
èke_max
 ==
a_biggî


36 
vÆ
 
lut
 = 
	`Vec
(
	`Seq
(

37 
	`UI¡
(0x6),

38 
	`UI¡
(0xe),

39 
	`UI¡
(0x8),

40 
	$UI¡
(0xc)))(

41 
io
.
a
.
	$∑øm
(1,0))

42 
vÆ
 
logiˇl
 = 
	`C©
((
io
.
a
.
d©a
.
toBoﬁs
 
zù
 io.
d©a_ö
.toBoﬁs).
m≠
 { ◊, 
d
) =>

43 
	`lut
(
	`C©
(
a
, 
d
))

44 
	}
}.
	gªvî£
)

47 
vÆ
 
	g£À˘
 = 
Mux
(
io
.
wrôe
, 
UI¡
(1), 
Vec
(
Seq
(

48 
UI¡
(1),

49 
UI¡
(1),

50 
Mux
(
addî
, 
UI¡
(2), Mux(
pick_a
, UInt(1), UInt(0))),

51 
UI¡
(3),

52 
UI¡
(0),

53 
UI¡
(0),

54 
UI¡
(0),

55 
	$UI¡
(0)))(

56 
io
.
a
.
›code
))

59 
vÆ
 
£À˘s
 = 
io
.
a
.
mask
.
toBoﬁs
.
	`m≠
(
b
 => 
	`Mux
(b, 
£À˘
, 
	$UI¡
(0)))

60 
io
.
d©a_out
 :
	`C©
(
£À˘s
.
zùWôhIndex
.
m≠
 { (
s
, 
i
) =>

61 
	`Vec
(
	`Seq
(
io
.
d©a_ö
, io.
a
.
d©a
, 
sum
, 
logiˇl
).
	`m≠
(
	`_
((
i
 + 1Ë* 8 - 1, i * 8)))(
s
)

62 
	}
}.
	gªvî£
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BankBinder.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 ˛as†
	cB™kBödîNode
(
mask
: 
BigI¡
)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
TLCu°omNode


11 
¥iv©e
 
vÆ
 
bô
 = 
mask
 & -mask

12 
vÆ
 
maxX„r
 = 
	`Tøns„rSizes
(1, i‡(
bô
 =0 || bô > 4096Ë4096 bô.
toI¡
)

13 
vÆ
 
ids
 = 
AddªssSë
.
	$íumî©eMask
(
mask
)

15 
def
 
	$ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

16 
vÆ
 
p‹ts
 = 
ids
.
size


17 
vÆ
 
oSèr
 = i‡(
oSèrs
 =0Ë0 (
p‹ts
 - 
oKnown
) / oStars

18 
vÆ
 
iSèr
 = i‡(
iSèrs
 =0Ë0 (
p‹ts
 - 
iKnown
) / iStars

19 
	`ªquúe
 (
p‹ts
 =
iKnown
 + 
iSèr
*
iSèrs
, 
s
"${name} must have ${ports} inputs, but has ${iKnown} + ${iStar}*${iStars}$lazyModule.line}")

20 
	`ªquúe
 (
p‹ts
 =
oKnown
 + 
oSèr
*
oSèrs
, 
s
"${name} must have ${ports} outputs, but has ${iKnown} + ${iStar}*${iStars}$lazyModule.line}")

21 (
iSèr
, 
oSèr
)

24 
def
 
	$m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
TLClõ¡P‹tP¨amëîs
]): Seq[TLClientPortParameters] =

25 (
p
 
zù
 
ids
Ë
m≠
 { (
˝
, 
id
Ë=> cp.
	`c›y
(
˛õ¡s
 = cp.˛õ¡s.m≠ { 
c
 => c.copy(

26 
visibûôy
 = 
c
.visibûôy.
Ê©M≠
 { 
a
 =>á.
	`öãr£˘
(
	`AddªssSë
(
id
, ~
mask
))},

27 
suµ‹tsProbe
 = 
c
.suµ‹tsProbê
öãr£˘
 
maxX„r
,

28 
suµ‹tsArôhmëic
 = 
c
.suµ‹tsArôhmëi¯
öãr£˘
 
maxX„r
,

29 
suµ‹tsLogiˇl
 = 
c
.suµ‹tsLogiˇ»
öãr£˘
 
maxX„r
,

30 
suµ‹tsGë
 = 
c
.suµ‹tsGë 
öãr£˘
 
maxX„r
,

31 
suµ‹tsPutFuŒ
 = 
c
.suµ‹tsPutFuŒ 
öãr£˘
 
maxX„r
,

32 
suµ‹tsPutP¨tül
 = 
c
.suµ‹tsPutP¨tü»
öãr£˘
 
maxX„r
,

33 
suµ‹tsHöt
 = 
c
.suµ‹tsHöà
öãr£˘
 
maxX„r
)})
	}
}

35 
def
 
	$m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
TLM™agîP‹tP¨amëîs
]): Seq[TLManagerPortParameters] =

36 (
p
 
zù
 
ids
Ë
m≠
 { (
mp
, 
id
Ë=> mp.
	`c›y
(
m™agîs
 = mp.m™agîs.m≠ { 
m
 => m.copy(

37 
addªss
 = 
m
.addªss.
Ê©M≠
 { 
a
 =>á.
	`öãr£˘
(
	`AddªssSë
(
id
, ~
mask
))},

38 
suµ‹tsAcquúeT
 = 
m
.suµ‹tsAcquúeT 
öãr£˘
 
maxX„r
,

39 
suµ‹tsAcquúeB
 = 
m
.suµ‹tsAcquúeB 
öãr£˘
 
maxX„r
,

40 
suµ‹tsArôhmëic
 = 
m
.suµ‹tsArôhmëi¯
öãr£˘
 
maxX„r
,

41 
suµ‹tsLogiˇl
 = 
m
.suµ‹tsLogiˇ»
öãr£˘
 
maxX„r
,

42 
suµ‹tsGë
 = 
m
.suµ‹tsGë 
öãr£˘
 
maxX„r
,

43 
suµ‹tsPutFuŒ
 = 
m
.suµ‹tsPutFuŒ 
öãr£˘
 
maxX„r
,

44 
suµ‹tsPutP¨tül
 = 
m
.suµ‹tsPutP¨tü»
öãr£˘
 
maxX„r
,

45 
suµ‹tsHöt
 = 
m
.suµ‹tsHöà
öãr£˘
 
maxX„r
)})
	}
}

49 ˛as†
	cB™kBödî
(
mask
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


51 
vÆ
 
node
 = 
	$B™kBödîNode
(
mask
)

53 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

54 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

55 
out
 <> 
ö


58 
	}
}

60 
obje˘
 
	gB™kBödî


62 
def
 
≠∂y
(
mask
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 = {

63 
vÆ
 
bödî
 = 
LazyModuÀ
(
√w
 
B™kBödî
(
mask
))

64 
bödî
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Broadcast.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

11 
˛ass
 
	$TLBrﬂdˇ°
(
löeByãs
: 
I¡
, 
numTøckîs
: I¡ = 4, 
buf„æess
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


13 
	`ªquúe
 (
löeByãs
 > 0 && 
	`isPow2
(lineBytes))

14 
	`ªquúe
 (
numTøckîs
 > 0)

16 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

17 
˛õ¡Fn
 = { 
˝
 =>

18 
˝
.
	`c›y
(
˛õ¡s
 = 
	`Seq
(
	`TLClõ¡P¨amëîs
(

19 
«me
 = "TLBroadcast",

20 
sour˚Id
 = 
	`IdR™ge
(0, 1 << 
	`log2Ceû
(
˝
.
ídSour˚Id
*4)))))

22 
m™agîFn
 = { 
mp
 =>

23 
mp
.
	`c›y
(

24 
ídSökId
 = 
numTøckîs
,

25 
m™agîs
 = 
mp
.m™agîs.
m≠
 { 
m
 =>

27 
	`ªquúe
 (!
m
.
suµ‹tsAcquúeB
)

29 i‡(
m
.
ªgi⁄Ty≥
 =
Regi⁄Ty≥
.
UNCACHED
) {

31 
vÆ
 
lowîBound
 = 
	`max
(
m
.
suµ‹tsPutFuŒ
.
mö
, m.
suµ‹tsGë
.min)

32 
	`ªquúe
 (!
m
.
suµ‹tsPutFuŒ
 || m.suµ‹tsPutFuŒ.
	`c⁄èös
(
löeByãs
), 
s
"${m.name} only supports PutFull(${m.supportsPutFull}), which doesÇot include $lineBytes")

33 
	`ªquúe
 (!
m
.
suµ‹tsGë
 || m.suµ‹tsGë .
	`c⁄èös
(
löeByãs
), 
s
"${m.name} only supports Get(${m.supportsGet}), which doesÇot include $lineBytes")

34 
m
.
	`c›y
(

35 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
TRACKED
,

36 
suµ‹tsAcquúeB
 = 
	`Tøns„rSizes
(
lowîBound
, 
löeByãs
),

37 
suµ‹tsAcquúeT
 = i‡(
m
.
suµ‹tsPutFuŒ
Ë
	`Tøns„rSizes
(
lowîBound
, 
löeByãs
Ë
Tøns„rSizes
.
n⁄e
,

38 
ÆwaysGø¡sT
 = 
Ál£
,

40 
suµ‹tsPutFuŒ
 = 
	`Tøns„rSizes
(
m
.suµ‹tsPutFuŒ .
mö
, 
	`mö
(m.suµ‹tsPutFuŒ .
max
, 
löeByãs
)),

41 
suµ‹tsPutP¨tül
 = 
	`Tøns„rSizes
(
m
.suµ‹tsPutP¨tül.
mö
, 
	`mö
(m.suµ‹tsPutP¨tül.
max
, 
löeByãs
)),

42 
suµ‹tsGë
 = 
	`Tøns„rSizes
(
m
.suµ‹tsGë .
mö
, 
	`mö
(m.suµ‹tsGë .
max
, 
löeByãs
)),

43 
suµ‹tsHöt
 = 
	`Tøns„rSizes
(
m
.suµ‹tsHöà.
mö
, 
	`mö
(m.suµ‹tsHöà.
max
, 
löeByãs
)),

44 
suµ‹tsArôhmëic
 = 
	`Tøns„rSizes
(
m
.suµ‹tsArôhmëic.
mö
, 
	`mö
(m.suµ‹tsArôhmëic.
max
, 
löeByãs
)),

45 
suµ‹tsLogiˇl
 = 
	`Tøns„rSizes
(
m
.suµ‹tsLogiˇ».
mö
, 
	`mö
(m.suµ‹tsLogiˇ».
max
, 
löeByãs
)),

46 
fifoId
 = 
N⁄e


49 
m


56 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

57 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

58 
vÆ
 
˛õ¡s
 = 
edgeIn
.
˛õ¡
.clients

59 
vÆ
 
m™agîs
 = 
edgeOut
.
m™agî
.managers

60 
vÆ
 
löeShi·
 = 
	`log2Ceû
(
löeByãs
)

62 
imp‹t
 
TLBrﬂdˇ°C⁄°™ts
.
_


64 
	`ªquúe
 (
löeByãs
 >
edgeOut
.
m™agî
.
bótByãs
)

66 
vÆ
 
ˇches
 = 
˛õ¡s
.
	`fûãr
(
_
.
suµ‹tsProbe
).
	`m≠
(_.
sour˚Id
)

67 
vÆ
 
ˇche_èrgës
 = 
ˇches
.
	`m≠
(
c
 => 
	`UI¡
(c.
°¨t
))

70 
vÆ
 
åackîs
 = 
Seq
.
	`èbuœã
(
numTøckîs
Ë{ 
id
 =>

71 
	`ModuÀ
(
√w
 
	`TLBrﬂdˇ°Tøckî
(
id
, 
löeByãs
, 
	`log2Up
(
ˇches
.
size
+1), 
buf„æess
, 
edgeIn
, 
edgeOut
)).
io


75 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

76 (
åackîs
 
zù
 
	`UI¡ToOH
(
ö
.
e
.
bôs
.
sök
).
toBoﬁs
Ë
f‹óch
 { (
åackî
, 
£À˘
) =>

77 
åackî
.
e_œ°
 :
£À˘
 && 
ö
.
e
.
	`fúe
()

81 
vÆ
 
d_high
 = 
	`log2Ceû
(
edgeIn
.
˛õ¡
.
ídSour˚Id
)

82 
vÆ
 
d_wh©
 = 
out
.
d
.
bôs
.
	`sour˚
(
d_high
+1, d_high)

83 
vÆ
 
d_dr›
 = 
d_wh©
 ==
DROP


84 
vÆ
 
d_hasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
bôs
)

85 
vÆ
 
d_n‹mÆ
 = 
	`Wúe
(
ö
.
d
)

86 
vÆ
 
d_åackîOH
 = 
	`Vec
(
åackîs
.
m≠
 { 
t
 => !t.
idÀ
 &&Å.
sour˚
 ==
d_n‹mÆ
.
bôs
.sour˚ }).
asUI¡


88 
	`as£π
 (!
out
.
d
.
vÆid
 || !
d_dr›
 || out.d.
bôs
.
›code
 ==
TLMesßges
.
Ac˚ssAck
)

90 
out
.
d
.
ªady
 :
d_n‹mÆ
.ªady || 
d_dr›


91 
d_n‹mÆ
.
vÆid
 :
out
.
d
.vÆid && !
d_dr›


92 
d_n‹mÆ
.
bôs
 :
out
.
d
.bits

93 
	`whí
 (
	`d_wh©
(1)) {

94 
d_n‹mÆ
.
bôs
.
›code
 :
	`Mux
(
d_hasD©a
, 
TLMesßges
.
Gø¡D©a
, TLMesßges.
Rñó£Ack
)

95 
d_n‹mÆ
.
bôs
.
∑øm
 :
	`Mux
(
d_hasD©a
, Mux(
	`d_wh©
(0), 
TLPîmissi⁄s
.
toT
, TLPîmissi⁄s.
toB
), 
	`UI¡
(0))

97 
d_n‹mÆ
.
bôs
.
sök
 :
	`OHToUI¡
(
d_åackîOH
)

98 
	`as£π
 (!
d_n‹mÆ
.
vÆid
 || (
d_åackîOH
.
	`‹R
(Ë|| d_n‹mÆ.
bôs
.
›code
 ==
TLMesßges
.
Rñó£Ack
))

101 
vÆ
 
d_ª•⁄£
 = 
d_hasD©a
 || !
	`d_wh©
(1)

102 
vÆ
 
d_œ°
 = 
edgeIn
.
	`œ°
(
d_n‹mÆ
)

103 (
åackîs
 
zù
 
d_åackîOH
.
toBoﬁs
Ë
f‹óch
 { (
åackî
, 
£À˘
) =>

104 
åackî
.
d_œ°
 :
£À˘
 && 
d_n‹mÆ
.
	`fúe
(Ë&& 
d_ª•⁄£
 && d_last

105 
åackî
.
¥obedack
 :
£À˘
 && 
out
.
d
.
	`fúe
(Ë&& 
d_dr›


114 
vÆ
 
c_¥obóck
 = 
ö
.
c
.
bôs
.
›code
 ==
TLMesßges
.
ProbeAck


115 
vÆ
 
c_¥obóckd©a
 = 
ö
.
c
.
bôs
.
›code
 ==
TLMesßges
.
ProbeAckD©a


116 
vÆ
 
c_ªÀa£d©a
 = 
ö
.
c
.
bôs
.
›code
 ==
TLMesßges
.
Rñó£D©a


117 
vÆ
 
c_ªÀa£
 = 
ö
.
c
.
bôs
.
›code
 ==
TLMesßges
.
Rñó£


118 
vÆ
 
c_åackîOH
 = 
åackîs
.
m≠
 { 
t
 =>Å.
löe
 ==(
ö
.
c
.
bôs
.
addªss
 >> 
löeShi·
) }

119 
vÆ
 
c_åackîSrc
 = 
	`Mux1H
(
c_åackîOH
, 
åackîs
.
m≠
 { 
_
.
sour˚
 })

122 (
åackîs
 
zù
 
c_åackîOH
Ë
f‹óch
 { (
åackî
, 
£À˘
) =>

123 
åackî
.
¥obíack
 :
ö
.
c
.
	`fúe
(Ë&& 
c_¥obóck
 && 
£À˘


126 
vÆ
 
ªÀa£ack
 = 
	`Wúe
(
ö
.
d
)

127 
vÆ
 
putfuŒ
 = 
	`Wúe
(
out
.
a
)

129 
ö
.
c
.
ªady
 :
c_¥obóck
 || 
	`Mux
(
c_ªÀa£
, 
ªÀa£ack
.ªady, 
putfuŒ
.ready)

131 
ªÀa£ack
.
vÆid
 :
ö
.
c
.vÆid && 
c_ªÀa£


132 
ªÀa£ack
.
bôs
 :
edgeIn
.
	`Rñó£Ack
(
ö
.
c
.bits)

134 
vÆ
 
put_wh©
 = 
	`Mux
(
c_ªÀa£d©a
, 
TRANSFORM_B
, 
DROP
)

135 
vÆ
 
put_who
 = 
	`Mux
(
c_ªÀa£d©a
, 
ö
.
c
.
bôs
.
sour˚
, 
c_åackîSrc
)

136 
putfuŒ
.
vÆid
 :
ö
.
c
.vÆid && (
c_¥obóckd©a
 || 
c_ªÀa£d©a
)

137 
putfuŒ
.
bôs
 :
edgeOut
.
	`Put
(
	`C©
(
put_wh©
, 
put_who
), 
ö
.
c
.bôs.
addªss
, in.c.bôs.
size
, in.c.bôs.
d©a
).
_2


140 
TLArbôî
.
	`lowe°
(
edgeOut
, 
ö
.
d
, 
ªÀa£ack
, 
d_n‹mÆ
)

142 
TLArbôî
.
	`lowe°FromSeq
(
edgeOut
, 
out
.
a
, 
putfuŒ
 +: 
åackîs
.
	`m≠
(
_
.
out_a
))

145 
vÆ
 
¥obe_todo
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
	`max
(1, 
ˇches
.
size
)))

146 
vÆ
 
¥obe_löe
 = 
	`Reg
(
	`UI¡
())

147 
vÆ
 
¥obe_≥rms
 = 
	`Reg
(
	`UI¡
(
width
 = 2))

148 
vÆ
 
¥obe_√xt
 = 
¥obe_todo
 & ~(
	`À·OR
(probe_todo) << 1)

149 
vÆ
 
¥obe_busy
 = 
¥obe_todo
.
	`‹R
()

150 
vÆ
 
¥obe_èrgë
 = i‡(
ˇches
.
size
 =0Ë
	`UI¡
(0Ë
	`Mux1H
(
¥obe_√xt
, 
ˇche_èrgës
)

153 
ö
.
b
.
vÆid
 :
¥obe_busy


154 i‡(
ˇches
.
size
 != 0) {

155 
ö
.
b
.
bôs
 :
edgeIn
.
	`Probe
(
¥obe_löe
 << 
löeShi·
, 
¥obe_èrgë
, 
	`UI¡
÷öeShi·), 
¥obe_≥rms
).
_2


157 
	`whí
 (
ö
.
b
.
	`fúe
()Ë{ 
¥obe_todo
 :¥obe_todÿ& ~
¥obe_√xt
 }

160 
vÆ
 
a_ˇche
 = i‡(
ˇches
.
size
 =0Ë
	`UI¡
(1Ë
	`Vec
(ˇches.
	`m≠
(
_
.
	`c⁄èös
(
ö
.
a
.
bôs
.
sour˚
))).
asUI¡


161 
vÆ
 
a_fú°
 = 
edgeIn
.
	`fú°
(
ö
.
a
)

164 
vÆ
 
‰ìTøckîs
 = 
	`Vec
(
åackîs
.
m≠
 { 
t
 =>Å.
idÀ
 }).
asUI¡


165 
vÆ
 
‰ìTøckî
 = 
‰ìTøckîs
.
	`‹R
()

166 
vÆ
 
m©chTøckîs
 = 
	`Vec
(
åackîs
.
m≠
 { 
t
 =>Å.
löe
 ==
ö
.
a
.
bôs
.
addªss
 >> 
löeShi·
 }).
asUI¡


167 
vÆ
 
m©chTøckî
 = 
m©chTøckîs
.
	`‹R
()

168 
vÆ
 
ÆlocTøckî
 = 
‰ìTøckîs
 & ~(
	`À·OR
(freeTrackers) << 1)

169 
vÆ
 
£À˘Tøckî
 = 
	`Mux
(
m©chTøckî
, 
m©chTøckîs
, 
ÆlocTøckî
)

171 
vÆ
 
åackîRódy
 = 
	`Vec
(
åackîs
.
	`m≠
(
_
.
ö_a
.
ªady
)).
asUI¡


172 
ö
.
a
.
ªady
 :(!
a_fú°
 || !
¥obe_busy
Ë&& (
£À˘Tøckî
 & 
åackîRódy
).
	`‹R
()

173 (
åackîs
 
zù
 
£À˘Tøckî
.
toBoﬁs
Ë
f‹óch
 { (
t
, 
£À˘
) =>

174 
t
.
ö_a
.
vÆid
 :
ö
.
a
.vÆid && 
£À˘
 && (!
a_fú°
 || !
¥obe_busy
)

175 
t
.
ö_a
.
bôs
 :
ö
.
a
.bits

176 
t
.
ö_a_fú°
 :
a_fú°


177 
t
.
¥obe
 :(i‡(
ˇches
.
size
 =0Ë
	`UI¡
(0Ë
	`Mux
(
a_ˇche
.
	`‹R
(), UInt(caches.size-1), UInt(caches.size)))

180 
vÆ
 
acq_≥rms
 = 
	`MuxLookup
(
ö
.
a
.
bôs
.
∑øm
, 
	`Wúe
(
	`UI¡
(
width
 = 2)), 
	`Aºay
(

181 
TLPîmissi⁄s
.
NtoB
 -> TLPîmissi⁄s.
toB
,

182 
TLPîmissi⁄s
.
NtoT
 -> TLPîmissi⁄s.
toN
,

183 
TLPîmissi⁄s
.
BtoT
 -> TLPîmissi⁄s.
toN
))

185 
	`whí
 (
ö
.
a
.
	`fúe
(Ë&& 
a_fú°
) {

186 
¥obe_todo
 :~
a_ˇche


187 
¥obe_löe
 :
ö
.
a
.
bôs
.
addªss
 >> 
löeShi·


188 
¥obe_≥rms
 :
	`MuxLookup
(
ö
.
a
.
bôs
.
›code
, 
	`Wúe
(
	`UI¡
(
width
 = 2)), 
	`Aºay
(

189 
TLMesßges
.
PutFuŒD©a
 -> 
TLPîmissi⁄s
.
toN
,

190 
TLMesßges
.
PutP¨tülD©a
 -> 
TLPîmissi⁄s
.
toN
,

191 
TLMesßges
.
ArôhmëicD©a
 -> 
TLPîmissi⁄s
.
toN
,

192 
TLMesßges
.
LogiˇlD©a
 -> 
TLPîmissi⁄s
.
toN
,

193 
TLMesßges
.
Gë
 -> 
TLPîmissi⁄s
.
toB
,

194 
TLMesßges
.
Höt
 -> 
	`MuxLookup
(
ö
.
a
.
bôs
.
∑øm
, 
	`Wúe
(
	`UI¡
(
width
 = 2)), 
	`Aºay
(

195 
TLHöts
.
PREFETCH_READ
 -> 
TLPîmissi⁄s
.
toB
,

196 
TLHöts
.
PREFETCH_WRITE
 -> 
TLPîmissi⁄s
.
toN
)),

197 
TLMesßges
.
AcquúeBlock
 -> 
acq_≥rms
,

198 
TLMesßges
.
AcquúePîm
 -> 
acq_≥rms
))

202 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

203 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

204 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

207 
	}
}

209 
obje˘
 
TLBrﬂdˇ°


211 
def
 
≠∂y
(
löeByãs
: 
I¡
, 
numTøckîs
: I¡ = 4, 
buf„æess
: 
Boﬁón
 = 
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

213 
vÆ
 
brﬂdˇ°
 = 
LazyModuÀ
(
√w
 
TLBrﬂdˇ°
(
löeByãs
, 
numTøckîs
, 
buf„æess
))

214 
	gbrﬂdˇ°
.
	gnode


218 
˛ass
 
	$TLBrﬂdˇ°Tøckî
(
id
: 
I¡
, 
löeByãs
: I¡, 
¥obeCou¡Bôs
: I¡, 
buf„æess
: 
Boﬁón
, 
edgeIn
: 
TLEdgeIn
, 
edgeOut
: 
TLEdgeOut
Ë
exãnds
 
ModuÀ


220 
vÆ
 
io
 = 
√w
 
BundÀ
 {

221 
vÆ
 
ö_a_fú°
 = 
	`Boﬁ
(
INPUT
)

222 
vÆ
 
ö_a
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀA
(
edgeIn
.
bundÀ
)).
Êù


223 
vÆ
 
out_a
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀA
(
edgeOut
.
bundÀ
))

224 
vÆ
 
¥obe
 = 
	`UI¡
(
INPUT
, 
width
 = 
¥obeCou¡Bôs
)

225 
vÆ
 
¥obíack
 = 
	`Boﬁ
(
INPUT
)

226 
vÆ
 
¥obedack
 = 
	`Boﬁ
(
INPUT
)

227 
vÆ
 
d_œ°
 = 
	`Boﬁ
(
INPUT
)

228 
vÆ
 
e_œ°
 = 
	`Boﬁ
(
INPUT
)

229 
vÆ
 
sour˚
 = 
	`UI¡
(
OUTPUT
)

230 
vÆ
 
löe
 = 
	`UI¡
(
OUTPUT
)

231 
vÆ
 
idÀ
 = 
	`Boﬁ
(
OUTPUT
)

234 
vÆ
 
löeShi·
 = 
	`log2Ceû
(
löeByãs
)

235 
imp‹t
 
TLBrﬂdˇ°C⁄°™ts
.
_


239 
vÆ
 
gŸ_e
 = 
	`RegInô
(
	`Boﬁ
(
åue
))

240 
vÆ
 
£¡_d
 = 
	`RegInô
(
	`Boﬁ
(
åue
))

241 
vÆ
 
›code
 = 
	`Reg
(
io
.
ö_a
.
bôs
.opcode)

242 
vÆ
 
∑øm
 = 
	`Reg
(
io
.
ö_a
.
bôs
.param)

243 
vÆ
 
size
 = 
	`Reg
(
io
.
ö_a
.
bôs
.size)

244 
vÆ
 
sour˚
 = 
	`Reg
(
io
.
ö_a
.
bôs
.source)

245 
vÆ
 
addªss
 = 
	`RegInô
(
	`UI¡
(
id
 << 
löeShi·
, 
width
 = 
io
.
ö_a
.
bôs
.addªss.
gëWidth
))

246 
vÆ
 
cou¡
 = 
	`Reg
(
	`UI¡
(
width
 = 
¥obeCou¡Bôs
))

247 
vÆ
 
idÀ
 = 
gŸ_e
 && 
£¡_d


249 
	`whí
 (
io
.
ö_a
.
	`fúe
(Ë&& io.
ö_a_fú°
) {

250 
	`as£π
 (
idÀ
)

251 
£¡_d
 :
	`Boﬁ
(
Ál£
)

252 
gŸ_e
 :
io
.
ö_a
.
bôs
.
›code
 =/
TLMesßges
.
AcquúeBlock
 && io.ö_a.bôs.›codê=/TLMesßges.
AcquúePîm


253 
›code
 :
io
.
ö_a
.
bôs
.opcode

254 
∑øm
 :
io
.
ö_a
.
bôs
.param

255 
size
 :
io
.
ö_a
.
bôs
.size

256 
sour˚
 :
io
.
ö_a
.
bôs
.source

257 
addªss
 :
io
.
ö_a
.
bôs
.address

258 
cou¡
 :
io
.
¥obe


260 
	`whí
 (
io
.
d_œ°
) {

261 
	`as£π
 (!
£¡_d
)

262 
£¡_d
 :
	`Boﬁ
(
åue
)

264 
	`whí
 (
io
.
e_œ°
) {

265 
	`as£π
 (!
gŸ_e
)

266 
gŸ_e
 :
	`Boﬁ
(
åue
)

269 
	`whí
 (
io
.
¥obíack
 || io.
¥obedack
) {

270 
	`as£π
 (
cou¡
 > 
	`UI¡
(0))

271 
cou¡
 :cou¡ - 
	`Mux
(
io
.
¥obíack
 && io.
¥obedack
, 
	`UI¡
(2), UInt(1))

274 
io
.
idÀ
 := idle

275 
io
.
sour˚
 := source

276 
io
.
löe
 :
addªss
 >> 
löeShi·


278 
vÆ
 
i_d©a
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`TLBrﬂdˇ°D©a
(
edgeIn
.
bundÀ
)))

279 
vÆ
 
o_d©a
 = 
	`Queue
(
i_d©a
, i‡(
buf„æess
Ë1 (
löeByãs
 / 
edgeIn
.
m™agî
.
bótByãs
), 
pùe
=bufferless)

281 
io
.
ö_a
.
ªady
 :(
idÀ
 || !io.
ö_a_fú°
Ë&& 
i_d©a
.ready

282 
i_d©a
.
vÆid
 :(
idÀ
 || !
io
.
ö_a_fú°
Ë&& io.
ö_a
.valid

283 
i_d©a
.
bôs
.
mask
 :
io
.
ö_a
.bits.mask

284 
i_d©a
.
bôs
.
d©a
 :
io
.
ö_a
.bits.data

286 
vÆ
 
¥obe_d⁄e
 = 
cou¡
 ==
	`UI¡
(0)

287 
vÆ
 
acquúe
 = 
›code
 ==
TLMesßges
.
AcquúeBlock
 || opcodê==TLMesßges.
AcquúePîm


289 
vÆ
 
å™sf‹m
 = 
	`MuxLookup
(
∑øm
, 
	`Wúe
(
	`UI¡
(
width
 = 2)), 
	`Aºay
(

290 
TLPîmissi⁄s
.
NtoB
 -> 
TRANSFORM_B
,

291 
TLPîmissi⁄s
.
NtoT
 -> 
TRANSFORM_T
,

292 
TLPîmissi⁄s
.
BtoT
 -> 
TRANSFORM_T
))

294 
o_d©a
.
ªady
 :
io
.
out_a
.ªady && 
¥obe_d⁄e


295 
io
.
out_a
.
vÆid
 :
o_d©a
.vÆid && 
¥obe_d⁄e


296 
io
.
out_a
.
bôs
.
›code
 :
	`Mux
(
acquúe
, 
TLMesßges
.
Gë
, opcode)

297 
io
.
out_a
.
bôs
.
∑øm
 :
	`Mux
(
acquúe
, 
	`UI¡
(0),Öaram)

298 
io
.
out_a
.
bôs
.
size
 := size

299 
io
.
out_a
.
bôs
.
sour˚
 :
	`C©
(
	`Mux
(
acquúe
, 
å™sf‹m
, 
PASS
), source)

300 
io
.
out_a
.
bôs
.
addªss
 :=áddress

301 
io
.
out_a
.
bôs
.
mask
 :
o_d©a
.bits.mask

302 
io
.
out_a
.
bôs
.
d©a
 :
o_d©a
.bits.data

303 
io
.
out_a
.
bôs
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

304 
	}
}

306 
obje˘
 
TLBrﬂdˇ°C⁄°™ts


308 
def
 
TRANSFORM_T
 = 
UI¡
(3)

309 
def
 
TRANSFORM_B
 = 
UI¡
(2)

310 
def
 
DROP
 = 
UI¡
(1)

311 
def
 
PASS
 = 
UI¡
(0)

314 ˛as†
	cTLBrﬂdˇ°D©a
(
∑øms
: 
TLBundÀP¨amëîs
Ë
exãnds
 
	$TLBundÀBa£
(
∑øms
)

316 
vÆ
 
mask
 = 
	`UI¡
(
width
 = 
∑øms
.
d©aBôs
/8)

317 
vÆ
 
d©a
 = 
	`UI¡
(
width
 = 
∑øms
.
d©aBôs
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Buffer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

10 
˛ass
 
	$TLBuf„rNode
 (

11 
a
: 
Buf„rP¨ams
,

12 
b
: 
Buf„rP¨ams
,

13 
c
: 
Buf„rP¨ams
,

14 
d
: 
Buf„rP¨ams
,

15 
e
: 
Buf„rP¨ams
)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	`TLAd≠ãrNode
(

16 
˛õ¡Fn
 = { 
p
 =>Ö.
	`c›y
(
möL©ícy
 =Ö.möL©ícy + 
b
.
œãncy
 + 
c
.œãncyË
	}
},

17 
	gm™agîFn
 = { 
p
 =>Ö.
c›y
(
möL©ícy
 =Ö.möL©ícy + 
a
.
œãncy
 + 
d
.latency) }

19 
ovîride
 
œzy
 
vÆ
 
	gnodedebug°rög
 = 
s
"a:${a.toString}, b:${b.toString}, c:${c.toString}, d:${d.toString},É:${e.toString}"

23 
˛ass
 
	$TLBuf„r
(

24 
a
: 
Buf„rP¨ams
,

25 
b
: 
Buf„rP¨ams
,

26 
c
: 
Buf„rP¨ams
,

27 
d
: 
Buf„rP¨ams
,

28 
e
: 
Buf„rP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


30 
def
 
	`this
(
a˚
: 
Buf„rP¨ams
, 
bd
: Buf„rP¨ams)(
im∂icô
 
p
: 
P¨amëîs
) =Åhis(ace, bd,áce, bd,áce)

31 
def
 
	`this
(
abcde
: 
Buf„rP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
) =Åhis(abcde,ábcde)

32 
def
 
	`this
()(
im∂icô
 
p
: 
P¨amëîs
Ëthis(
Buf„rP¨ams
.)

34 
vÆ
 
node
 = 
√w
 
	`TLBuf„rNode
(
a
, 
b
, 
c
, 
d
, 
e
)

36 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

37 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

38 
out
.
a
 <> 
	`a
(
ö
 .a)

39 
ö
 .
d
 <> 
	`d
(
out
.d)

41 i‡(
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeOut.
˛õ¡
.
™ySuµ‹tProbe
) {

42 
ö
 .
b
 <> 
	`b
(
out
.b)

43 
out
.
c
 <> 
	`c
(
ö
 .c)

44 
out
.
e
 <> 
	`e
(
ö
 .e)

46 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

47 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

48 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

49 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

50 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

51 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

55 
	}
}

57 
obje˘
 
TLBuf„r


59 
def
 
≠∂y
(Ë(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =áµly(
Buf„rP¨ams
.)

60 
def
 
≠∂y
(
abcde
: 
Buf„rP¨ams
Ë(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =ápply(abcde,ábcde)

61 
def
 
≠∂y
(
a˚
: 
Buf„rP¨ams
, 
bd
: Buf„rP¨ams)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =ápply(ace, bd,áce, bd,áce)

62 
def
 
≠∂y
(

63 
a
: 
Buf„rP¨ams
,

64 
b
: 
Buf„rP¨ams
,

65 
c
: 
Buf„rP¨ams
,

66 
d
: 
Buf„rP¨ams
,

67 
e
: 
Buf„rP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

69 
vÆ
 
buf„r
 = 
LazyModuÀ
(
√w
 
TLBuf„r
(
a
, 
b
, 
c
, 
d
, 
e
))

70 
	gbuf„r
.
	gnode


73 
def
 
chaö
(
dïth
: 
I¡
, 
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
): 
Seq
[
TLNode
] = {

74 
vÆ
 
buf„rs
 = 
Seq
.
fûl
(
dïth
Ë{ 
LazyModuÀ
(
√w
 
TLBuf„r
()) }

75 
«me
.
f‹óch
 { 
n
 => 
buf„rs
.
zùWôhIndex
.f‹óch { (
b
, 
i
Ë=> b.
sugge°Name
(
s
"${n}_${i}") } }

76 
	gbuf„rs
.
m≠
(
_
.
node
)

79 
def
 
chaöNode
(
dïth
: 
I¡
, 
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 = {

80 
chaö
(
dïth
, 
«me
)

81 .
ªdu˚Le·O±i⁄
(
_
 :*=* _)

82 .
gëOrEl£
(
TLNameNode
("no_buffer"))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Bundles.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.{
	gRódyVÆidIO
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
ab°ø˘
 cœs†
	cTLBundÀBa£
(
∑øms
: 
TLBundÀP¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

16 
obje˘
 
TLMesßges


19 
def
 
PutFuŒD©a
 = 
	$UI¡
(0)

20 
def
 
PutP¨tülD©a
 = 
	$UI¡
(1)

21 
def
 
ArôhmëicD©a
 = 
	$UI¡
(2)

22 
def
 
LogiˇlD©a
 = 
	$UI¡
(3)

23 
def
 
Gë
 = 
	$UI¡
(4)

24 
def
 
Höt
 = 
	$UI¡
(5)

25 
def
 
AcquúeBlock
 = 
	$UI¡
(6)

26 
def
 
AcquúePîm
 = 
	$UI¡
(7)

27 
def
 
Probe
 = 
	$UI¡
(6)

28 
def
 
Ac˚ssAck
 = 
	$UI¡
(0)

29 
def
 
Ac˚ssAckD©a
 = 
	$UI¡
(1)

30 
def
 
HötAck
 = 
	$UI¡
(2)

31 
def
 
ProbeAck
 = 
	$UI¡
(4)

32 
def
 
ProbeAckD©a
 = 
	$UI¡
(5)

33 
def
 
Rñó£
 = 
	$UI¡
(6)

34 
def
 
Rñó£D©a
 = 
	$UI¡
(7)

35 
def
 
Gø¡
 = 
	$UI¡
(4)

36 
def
 
Gø¡D©a
 = 
	$UI¡
(5)

37 
def
 
Rñó£Ack
 = 
	$UI¡
(6)

38 
def
 
Gø¡Ack
 = 
	$UI¡
(0)

40 
def
 
	`isA
(
x
: 
UI¡
Ëx <
AcquúePîm


41 
def
 
	`isB
(
x
: 
UI¡
Ëx <
Probe


42 
def
 
	`isC
(
x
: 
UI¡
Ëx <
Rñó£D©a


43 
def
 
	`isD
(
x
: 
UI¡
Ëx <
Rñó£Ack


45 
def
 
adRe•⁄£
 = 
	$Vec
(
Ac˚ssAck
, Ac˚ssAck, 
Ac˚ssAckD©a
, Ac˚ssAckD©a, Ac˚ssAckD©a, 
HötAck
, 
Gø¡
, Grant)

46 
def
 
bcRe•⁄£
 = 
	$Vec
(
Ac˚ssAck
, Ac˚ssAck, 
Ac˚ssAckD©a
, Ac˚ssAckD©a, Ac˚ssAckD©a, 
HötAck
, 
ProbeAck
, ProbeAck)

48 
def
 
a
 = 
	`Seq
–("PutFuŒD©a",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

49 ("PutP¨tülD©a",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

50 ("ArôhmëicD©a",
TLAtomics
.
ArôhMsg
),

51 ("LogiˇlD©a",
TLAtomics
.
LogicMsg
),

52 ("Gë",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

53 ("Höt",
TLHöts
.
HötsMsg
),

54 ("AcquúeBlock",
TLPîmissi⁄s
.
PîmMsgGrow
),

55 ("AcquúePîm",
TLPîmissi⁄s
.
PîmMsgGrow
))

57 
def
 
b
 = 
	`Seq
–("PutFuŒD©a",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

58 ("PutP¨tülD©a",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

59 ("ArôhmëicD©a",
TLAtomics
.
ArôhMsg
),

60 ("LogiˇlD©a",
TLAtomics
.
LogicMsg
),

61 ("Gë",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

62 ("Höt",
TLHöts
.
HötsMsg
),

63 ("Probe",
TLPîmissi⁄s
.
PîmMsgC≠
))

65 
def
 
c
 = 
	`Seq
–("Ac˚ssAck",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

66 ("Ac˚ssAckD©a",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

67 ("HötAck",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

68 ("InvÆid Opcode",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

69 ("ProbeAck",
TLPîmissi⁄s
.
PîmMsgRï‹t
),

70 ("ProbeAckD©a",
TLPîmissi⁄s
.
PîmMsgRï‹t
),

71 ("Rñó£",
TLPîmissi⁄s
.
PîmMsgRï‹t
),

72 ("Rñó£D©a",
TLPîmissi⁄s
.
PîmMsgRï‹t
))

74 
def
 
d
 = 
	`Seq
–("Ac˚ssAck",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

75 ("Ac˚ssAckD©a",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

76 ("HötAck",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

77 ("InvÆid Opcode",
TLPîmissi⁄s
.
PîmMsgRe£rved
),

78 ("Gø¡",
TLPîmissi⁄s
.
PîmMsgC≠
),

79 ("Gø¡D©a",
TLPîmissi⁄s
.
PîmMsgC≠
),

80 ("Rñó£Ack",
TLPîmissi⁄s
.
PîmMsgRe£rved
))

93 
obje˘
 
TLPîmissi⁄s


95 
vÆ
 
aWidth
 = 2

96 
vÆ
 
bdWidth
 = 2

97 
vÆ
 
cWidth
 = 3

100 
def
 
toT
 = 
	`UI¡
(0, 
bdWidth
)

101 
def
 
toB
 = 
	`UI¡
(1, 
bdWidth
)

102 
def
 
toN
 = 
	`UI¡
(2, 
bdWidth
)

103 
def
 
	`isC≠
(
x
: 
UI¡
Ëx <
toN


106 
def
 
NtoB
 = 
	`UI¡
(0, 
aWidth
)

107 
def
 
NtoT
 = 
	`UI¡
(1, 
aWidth
)

108 
def
 
BtoT
 = 
	`UI¡
(2, 
aWidth
)

109 
def
 
	`isGrow
(
x
: 
UI¡
Ëx <
BtoT


112 
def
 
TtoB
 = 
	`UI¡
(0, 
cWidth
)

113 
def
 
TtoN
 = 
	`UI¡
(1, 
cWidth
)

114 
def
 
BtoN
 = 
	`UI¡
(2, 
cWidth
)

115 
def
 
	`isShrök
(
x
: 
UI¡
Ëx <
BtoN


118 
def
 
TtoT
 = 
	`UI¡
(3, 
cWidth
)

119 
def
 
BtoB
 = 
	`UI¡
(4, 
cWidth
)

120 
def
 
NtoN
 = 
	`UI¡
(5, 
cWidth
)

121 
def
 
	`isRï‹t
(
x
: 
UI¡
Ëx <
NtoN


123 
def
 
PîmMsgGrow
:
Seq
[
Såög
] = 
	`Seq
("Grow NtoB", "Grow NtoT", "Grow BtoT")

124 
def
 
PîmMsgC≠
:
Seq
[
Såög
] = 
	`Seq
("CapÅoT", "CapÅoB", "CapÅoN")

125 
def
 
PîmMsgRï‹t
:
Seq
[
Såög
] = 
	`Seq
("Shrink TtoB", "Shrink TtoN", "Shrink BtoN", "Report TotT", "Report BtoB", "Report NtoN")

126 
def
 
PîmMsgRe£rved
:
Seq
[
Såög
] = 
	`Seq
("Reserved")

127 
	}
}

129 
obje˘
 
TLAtomics


131 
vÆ
 
width
 = 3

134 
def
 
MIN
 = 
UI¡
(0, 
width
)

135 
def
 
	gMAX
 = 
UI¡
(1, 
width
)

136 
def
 
	gMINU
 = 
UI¡
(2, 
width
)

137 
def
 
	gMAXU
 = 
UI¡
(3, 
width
)

138 
def
 
	gADD
 = 
UI¡
(4, 
width
)

139 
def
 
isArôhmëic
(
x
: 
UI¡
Ëx <
ADD


142 
def
 
XOR
 = 
UI¡
(0, 
width
)

143 
def
 
	gOR
 = 
UI¡
(1, 
width
)

144 
def
 
	gAND
 = 
UI¡
(2, 
width
)

145 
def
 
	gSWAP
 = 
UI¡
(3, 
width
)

146 
def
 
isLogiˇl
(
x
: 
UI¡
Ëx <
SWAP


148 
def
 
ArôhMsg
:
Seq
[
Såög
] = Seq("MIN", "MAX", "MIN", "MAXU", "ADD")

149 
def
 
	gLogicMsg
:
Seq
[
Såög
] = Seq("XOR", "OR", "AND", "SWAP")

153 
obje˘
 
	gTLHöts


155 
vÆ
 
	gwidth
 = 1

157 
def
 
PREFETCH_READ
 = 
UI¡
(0, 
width
)

158 
def
 
	gPREFETCH_WRITE
 = 
UI¡
(1, 
width
)

160 
def
 
	gHötsMsg
:
Seq
[
Såög
] = Seq("PrefetchRead", "PrefetchWrite")

163 
£Æed
 
åaô
 
TLCh™√l
 
exãnds
 
	gTLBundÀBa£
 {

164 
vÆ
 
	gch™√lName
: 
Såög


167 
£Æed
 
åaô
 
TLD©aCh™√l
 
exãnds
 
TLCh™√l


168 
£Æed
 
åaô
 
TLAddrCh™√l
 
exãnds
 
TLD©aCh™√l


170 
föÆ
 cœs†
	cTLBundÀA
(
∑øms
: 
TLBundÀP¨amëîs
)

171 
exãnds
 
	$TLBundÀBa£
(
∑øms
Ë
wôh
 
TLAddrCh™√l


173 
vÆ
 
ch™√lName
 = "'A' channel"

175 
vÆ
 
›code
 = 
	$UI¡
(
width
 = 3)

176 
vÆ
 
∑øm
 = 
	`UI¡
(
width
 = 
	`Li°
(
TLAtomics
.width, 
TLPîmissi⁄s
.
aWidth
, 
TLHöts
.width).
max
)

177 
vÆ
 
size
 = 
	$UI¡
(
width
 = 
∑øms
.
sizeBôs
)

178 
vÆ
 
sour˚
 = 
	$UI¡
(
width
 = 
∑øms
.
sour˚Bôs
)

179 
vÆ
 
addªss
 = 
	$UI¡
(
width
 = 
∑øms
.
addªssBôs
)

181 
vÆ
 
mask
 = 
	`UI¡
(
width
 = 
∑øms
.
d©aBôs
/8)

182 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
d©aBôs
)

183 
vÆ
 
c‹ru±
 = 
	`Boﬁ
()

185 
föÆ
 cœs†
	cTLBundÀB
(
∑øms
: 
TLBundÀP¨amëîs
)

186 
exãnds
 
	$TLBundÀBa£
(
∑øms
Ë
wôh
 
TLAddrCh™√l


188 
vÆ
 
ch™√lName
 = "'B' channel"

190 
vÆ
 
›code
 = 
	$UI¡
(
width
 = 3)

191 
vÆ
 
∑øm
 = 
	$UI¡
(
width
 = 
TLPîmissi⁄s
.
bdWidth
)

192 
vÆ
 
size
 = 
	$UI¡
(
width
 = 
∑øms
.
sizeBôs
)

193 
vÆ
 
sour˚
 = 
	$UI¡
(
width
 = 
∑øms
.
sour˚Bôs
)

194 
vÆ
 
addªss
 = 
	$UI¡
(
width
 = 
∑øms
.
addªssBôs
)

196 
vÆ
 
mask
 = 
	`UI¡
(
width
 = 
∑øms
.
d©aBôs
/8)

197 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
d©aBôs
)

198 
vÆ
 
c‹ru±
 = 
	`Boﬁ
()

201 
föÆ
 cœs†
	cTLBundÀC
(
∑øms
: 
TLBundÀP¨amëîs
)

202 
exãnds
 
	$TLBundÀBa£
(
∑øms
Ë
wôh
 
TLAddrCh™√l


204 
vÆ
 
ch™√lName
 = "'C' channel"

206 
vÆ
 
›code
 = 
	$UI¡
(
width
 = 3)

207 
vÆ
 
∑øm
 = 
	$UI¡
(
width
 = 
TLPîmissi⁄s
.
cWidth
)

208 
vÆ
 
size
 = 
	$UI¡
(
width
 = 
∑øms
.
sizeBôs
)

209 
vÆ
 
sour˚
 = 
	$UI¡
(
width
 = 
∑øms
.
sour˚Bôs
)

210 
vÆ
 
addªss
 = 
	$UI¡
(
width
 = 
∑øms
.
addªssBôs
)

212 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
d©aBôs
)

213 
vÆ
 
c‹ru±
 = 
	`Boﬁ
()

216 
föÆ
 cœs†
	cTLBundÀD
(
∑øms
: 
TLBundÀP¨amëîs
)

217 
exãnds
 
	$TLBundÀBa£
(
∑øms
Ë
wôh
 
TLD©aCh™√l


219 
vÆ
 
ch™√lName
 = "'D' channel"

221 
vÆ
 
›code
 = 
	$UI¡
(
width
 = 3)

222 
vÆ
 
∑øm
 = 
	$UI¡
(
width
 = 
TLPîmissi⁄s
.
bdWidth
)

223 
vÆ
 
size
 = 
	$UI¡
(
width
 = 
∑øms
.
sizeBôs
)

224 
vÆ
 
sour˚
 = 
	$UI¡
(
width
 = 
∑øms
.
sour˚Bôs
)

225 
vÆ
 
sök
 = 
	$UI¡
(
width
 = 
∑øms
.
sökBôs
)

226 
vÆ
 
díõd
 = 
	$Boﬁ
()

228 
vÆ
 
d©a
 = 
	$UI¡
(
width
 = 
∑øms
.
d©aBôs
)

229 
vÆ
 
c‹ru±
 = 
	`Boﬁ
()

232 
föÆ
 cœs†
	cTLBundÀE
(
∑øms
: 
TLBundÀP¨amëîs
)

233 
exãnds
 
	$TLBundÀBa£
(
∑øms
Ë
wôh
 
TLCh™√l


235 
vÆ
 
ch™√lName
 = "'E' channel"

236 
vÆ
 
sök
 = 
	`UI¡
(
width
 = 
∑øms
.
sökBôs
)

239 ˛as†
	cTLBundÀ
(
∑øms
: 
TLBundÀP¨amëîs
Ë
exãnds
 
	$TLBundÀBa£
(
∑øms
)

241 
vÆ
 
a
 = 
	`Decou∂ed
(
√w
 
	$TLBundÀA
(
∑øms
))

242 
vÆ
 
b
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀB
(
∑øms
)).
Êù


243 
vÆ
 
c
 = 
	`Decou∂ed
(
√w
 
	$TLBundÀC
(
∑øms
))

244 
vÆ
 
d
 = 
	`Decou∂ed
(
√w
 
	`TLBundÀD
(
∑øms
)).
Êù


245 
vÆ
 
e
 = 
	`Decou∂ed
(
√w
 
	$TLBundÀE
(
∑øms
))

247 
def
 
	$tõoff
() {

248 
a
.
ªady
.
dú
 
m©ch
 {

249 
INPUT
 =>

250 
a
.
ªady
 :
	`Boﬁ
(
Ál£
)

251 
c
.
ªady
 :
	`Boﬁ
(
Ál£
)

252 
e
.
ªady
 :
	`Boﬁ
(
Ál£
)

253 
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

254 
d
.
vÆid
 :
	`Boﬁ
(
Ál£
)

255 
OUTPUT
 =>

256 
a
.
vÆid
 :
	`Boﬁ
(
Ál£
)

257 
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

258 
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

259 
b
.
ªady
 :
	`Boﬁ
(
Ál£
)

260 
d
.
ªady
 :
	`Boﬁ
(
Ál£
)

261 
_
 =>

264 
	}
}

266 
obje˘
 
TLBundÀ


268 
def
 
≠∂y
(
∑øms
: 
TLBundÀP¨amëîs
Ë
√w
 
TLBundÀ
(params)

271 
föÆ
 
˛ass
 
Decou∂edSno›
[+
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ


273 
vÆ
 
ªady
 = 
Boﬁ
()

274 
vÆ
 
vÆid
 = 
Boﬁ
()

275 
vÆ
 
bôs
 = 
gí
.
asOuçut


277 
def
 
fúe
(Ë
ªady
 && 
vÆid


278 
ovîride
 
def
 
˛⁄eTy≥
: 
this
.
ty≥
 = 
√w
 
Decou∂edSno›
(
gí
).
asIn°™˚Of
[this.type]

281 
obje˘
 
Decou∂edSno›


283 
def
 
≠∂y
[
T
 <: 
D©a
](
sour˚
: 
Decou∂edIO
[T], 
	gsök
: DecoupledIO[T]) = {

284 
vÆ
 
out
 = 
Wúe
(
√w
 
Decou∂edSno›
(
sök
.
bôs
))

285 
out
.
ªady
 :
sök
.ready

286 
out
.
vÆid
 :
sour˚
.valid

287 
out
.
bôs
 :
sour˚
.bits

288 
out


292 ˛as†
	cTLBundÀSno›
(
∑øms
: 
TLBundÀP¨amëîs
Ë
exãnds
 
	$TLBundÀBa£
(
∑øms
)

294 
vÆ
 
a
 = 
√w
 
	`Decou∂edSno›
“ew 
	$TLBundÀA
(
∑øms
))

295 
vÆ
 
b
 = 
√w
 
	`Decou∂edSno›
“ew 
	$TLBundÀB
(
∑øms
))

296 
vÆ
 
c
 = 
√w
 
	`Decou∂edSno›
“ew 
	$TLBundÀC
(
∑øms
))

297 
vÆ
 
d
 = 
√w
 
	`Decou∂edSno›
“ew 
	$TLBundÀD
(
∑øms
))

298 
vÆ
 
e
 = 
√w
 
	`Decou∂edSno›
“ew 
	`TLBundÀE
(
∑øms
))

301 
obje˘
 
TLBundÀSno›


303 
def
 
	`≠∂y
(
sour˚
: 
TLBundÀ
, 
sök
: TLBundle) = {

304 
vÆ
 
out
 = 
	`Wúe
(
√w
 
	`TLBundÀSno›
(
sök
.
∑øms
))

305 
out
.
a
 :
	`Decou∂edSno›
(
sour˚
.a, 
sök
.a)

306 
out
.
b
 :
	`Decou∂edSno›
(
sök
.b, 
sour˚
.b)

307 
out
.
c
 :
	`Decou∂edSno›
(
sour˚
.c, 
sök
.c)

308 
out
.
d
 :
	`Decou∂edSno›
(
sök
.d, 
sour˚
.d)

309 
out
.
e
 :
	`Decou∂edSno›
(
sour˚
.e, 
sök
.e)

310 
out


312 
	}
}

314 ˛as†
	cTLAsyncBundÀBa£
(
∑øms
: 
TLAsyncBundÀP¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

316 ˛as†
	cTLAsyncBundÀ
(
∑øms
: 
TLAsyncBundÀP¨amëîs
Ë
exãnds
 
	$TLAsyncBundÀBa£
(
∑øms
)

318 
vÆ
 
a
 = 
√w
 
	`AsyncBundÀ
“ew 
	`TLBundÀA
(
∑øms
.
ba£
),Ö¨ams.
async
)

319 
vÆ
 
b
 = 
√w
 
	`AsyncBundÀ
“ew 
	`TLBundÀB
(
∑øms
.
ba£
),Ö¨ams.
async
).
Êù


320 
vÆ
 
c
 = 
√w
 
	`AsyncBundÀ
“ew 
	`TLBundÀC
(
∑øms
.
ba£
),Ö¨ams.
async
)

321 
vÆ
 
d
 = 
√w
 
	`AsyncBundÀ
“ew 
	`TLBundÀD
(
∑øms
.
ba£
),Ö¨ams.
async
).
Êù


322 
vÆ
 
e
 = 
√w
 
	`AsyncBundÀ
“ew 
	`TLBundÀE
(
∑øms
.
ba£
),Ö¨ams.
async
)

325 ˛as†
	cTLR©i⁄ÆBundÀ
(
∑øms
: 
TLBundÀP¨amëîs
Ë
exãnds
 
	$TLBundÀBa£
(
∑øms
)

327 
vÆ
 
a
 = 
	`R©i⁄ÆIO
(
√w
 
	$TLBundÀA
(
∑øms
))

328 
vÆ
 
b
 = 
	`R©i⁄ÆIO
(
√w
 
	`TLBundÀB
(
∑øms
)).
Êù


329 
vÆ
 
c
 = 
	`R©i⁄ÆIO
(
√w
 
	$TLBundÀC
(
∑øms
))

330 
vÆ
 
d
 = 
	`R©i⁄ÆIO
(
√w
 
	`TLBundÀD
(
∑øms
)).
Êù


331 
vÆ
 
e
 = 
	`R©i⁄ÆIO
(
√w
 
	`TLBundÀE
(
∑øms
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BusWrapper.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
åaô
 
	gHasTLBusP¨ams
 {

12 
def
 
	gbótByãs
: 
I¡


13 
def
 
blockByãs
: 
I¡


15 
def
 
bótBôs
: 
I¡
 = 
bótByãs
 * 8

16 
def
 
blockBôs
: 
I¡
 = 
blockByãs
 * 8

17 
def
 
blockBóts
: 
I¡
 = 
blockByãs
 / 
bótByãs


18 
def
 
blockOff£t
: 
I¡
 = 
log2Up
(
blockByãs
)

21 
ab°ø˘
 
˛ass
 
	$TLBusWøµî
(
∑øms
: 
HasTLBusP¨ams
, 
vÆ
 
busName
: 
Såög
)(
im∂icô
 
p
: 
P¨amëîs
)

22 
exãnds
 
Sim∂eLazyModuÀ


23 
wôh
 
LazySc›e


24 
wôh
 
HasTLBusP¨ams
 {

26 
def
 
bótByãs
 = 
∑øms
.beatBytes

27 
def
 
blockByãs
 = 
∑øms
.blockBytes

28 
	`ªquúe
(
blockByãs
 % 
bótByãs
 == 0)

30 
def
 
öw¨dNode
: 
TLInw¨dNode


31 
def
 
outw¨dNode
: 
TLOutw¨dNode


33 
def
 
to
[
T
](
«me
: 
Såög
)(
body
: => T): T = {

34 
this
 { 
	`LazySc›e
(
s
"cou∂î_to_${«me}"Ë{ 
body
 } }

37 
def
 
‰om
[
T
](
«me
: 
Såög
)(
body
: => T): T = {

38 
this
 { 
	`LazySc›e
(
s
"cou∂î_‰om_${«me}"Ë{ 
body
 } }

41 
def
 
cou∂eTo
[
T
](
«me
: 
Såög
)(
gí
: 
TLOutw¨dNode
 => T): T =

42 
	`to
(
«me
Ë{ 
	`gí
(
outw¨dNode
) }

44 
def
 
cou∂eFrom
[
T
](
«me
: 
Såög
)(
gí
: 
TLInw¨dNode
 => T): T =

45 
	`‰om
(
«me
Ë{ 
	`gí
(
öw¨dNode
) }

46 
	}
}

48 
åaô
 
C™AâachTLSœves
 
exãnds
 
HasTLBusP¨ams
 { 
this
: 
TLBusWøµî
 =>

49 
def
 
toSœve
[
D
,
U
,
E
,
B
 <: 
D©a
]

50 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

51 (
gí
: => 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
,
D
,
U
,
E
,
B
] =

52 
TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

53 
to
("¶ave" 
«med
 
«me
Ë{ 
gí
 :*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode
 }

56 
def
 
toV¨übÀWidthSœveNode
(
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
buf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)(
node
: 
TLInw¨dNode
) {

57 
toV¨übÀWidthSœveNodeO±i⁄
(
«me
, 
buf„r
)(
Some
(
node
))

60 
def
 
toV¨übÀWidthSœveNodeO±i⁄
(
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
buf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)(
node
: O±i⁄[
TLInw¨dNode
]) {

61 
node
 
f‹óch
 { 
n
 => 
to
("¶ave" 
«med
 
«me
) {

62 
n
 :*
TLFøgmíãr
(
bótByãs
, 
blockByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode


66 
def
 
toV¨übÀWidthSœve
[
D
,
U
,
E
,
B
 <: 
D©a
]

67 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

68 (
gí
: => 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
,
D
,
U
,
E
,
B
] =

69 
TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

70 
to
("¶ave" 
«med
 
«me
) {

71 
gí
 :*
TLFøgmíãr
(
bótByãs
, 
blockByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode


75 
def
 
toFixedWidthSœveNode
(
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
buf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)(
gí
: 
TLInw¨dNode
) {

76 
to
("¶ave" 
«med
 
«me
Ë{ 
gí
 :*
TLWidthWidgë
(
bótByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode
 }

79 
def
 
toFixedWidthSœve
[
D
,
U
,
E
,
B
 <: 
D©a
]

80 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

81 (
gí
: => 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
,
D
,
U
,
E
,
B
] =

82 
TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

83 
to
("¶ave" 
«med
 
«me
Ë{ 
gí
 :*
TLWidthWidgë
(
bótByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode
 }

86 
def
 
toFixedWidthSögÀBótSœveNode


87 (
widthByãs
: 
I¡
, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

88 (
gí
: 
TLInw¨dNode
) {

89 
to
("¶ave" 
«med
 
«me
) {

90 
gí
 :*
TLFøgmíãr
(
widthByãs
, 
blockByãs
Ë:*
TLWidthWidgë
(
bótByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode


94 
def
 
toFixedWidthSögÀBótSœve
[
D
,
U
,
E
,
B
 <: 
D©a
]

95 (
widthByãs
: 
I¡
, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

96 (
gí
: => 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
,
D
,
U
,
E
,
B
] =

97 
TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

98 
to
("¶ave" 
«med
 
«me
) {

99 
gí
 :*
TLFøgmíãr
(
widthByãs
, 
blockByãs
Ë:*
TLWidthWidgë
(
bótByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode


103 
def
 
toL¨geBur°Sœve
[
D
,
U
,
E
,
B
 <: 
D©a
]

104 (
maxX„rByãs
: 
I¡
, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

105 (
gí
: => 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
,
D
,
U
,
E
,
B
] =

106 
TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

107 
to
("¶ave" 
«med
 
«me
) {

108 
gí
 :*
TLFøgmíãr
(
bótByãs
, 
maxX„rByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode


112 
def
 
toFixedWidthP‹t
[
D
,
U
,
E
,
B
 <: 
D©a
]

113 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

114 (
gí
: => 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeIn
,
TLBundÀ
,
D
,
U
,
E
,
B
] =

115 
TLNameNode
(
«me
)): 
Outw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

116 
to
("p‹t" 
«med
 
«me
) {

117 
gí
 :
TLWidthWidgë
(
bótByãs
Ë:*
TLBuf„r
(
buf„r
Ë:*
outw¨dNode


122 
åaô
 
C™AâachTLMa°îs
 
exãnds
 
HasTLBusP¨ams
 { 
this
: 
TLBusWøµî
 =>

123 
def
 
‰omMa°îNode


124 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

125 (
gí
: 
TLOutw¨dNode
) {

126 
‰om
("ma°î" 
«med
 
«me
) {

127 
öw¨dNode
 :=* 
TLBuf„r
(
buf„r
Ë:=* 
TLFIFOFixî
(TLFIFOFixî.
Æl
Ë:=* 
gí


131 
def
 
‰omMa°î
[
D
,
U
,
E
,
B
 <: 
D©a
]

132 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

133 (
gí
: => 
NodeH™dÀ
[
D
,
U
,
E
,
B
,
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeOut
,
TLBundÀ
] =

134 
TLNameNode
(
«me
)): 
Inw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

135 
‰om
("ma°î" 
«med
 
«me
) {

136 
öw¨dNode
 :=* 
TLBuf„r
(
buf„r
Ë:=* 
TLFIFOFixî
(TLFIFOFixî.
Æl
Ë:=* 
gí


140 
def
 
‰omP‹t
[
D
,
U
,
E
,
B
 <: 
D©a
]

141 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

142 (
gí
: => 
NodeH™dÀ
[
D
,
U
,
E
,
B
,
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeOut
,
TLBundÀ
] =

143 
TLNameNode
(
«me
)): 
Inw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

144 
‰om
("p‹t" 
«med
 
«me
) {

145 
öw¨dNode
 :=* 
TLBuf„r
(
buf„r
Ë:=* 
TLFIFOFixî
(TLFIFOFixî.
Æl
Ë:=* 
gí


149 
def
 
‰omCohîítMa°î
[
D
,
U
,
E
,
B
 <: 
D©a
]

150 (
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
	gbuf„r
: 
Buf„rP¨ams
 = Buf„rP¨ams.
n⁄e
)

151 (
gí
: => 
NodeH™dÀ
[
D
,
U
,
E
,
B
,
TLClõ¡P‹tP¨amëîs
,
TLM™agîP‹tP¨amëîs
,
TLEdgeOut
,
TLBundÀ
] =

152 
TLNameNode
(
«me
)): 
Inw¨dNodeH™dÀ
[
D
,
U
,
E
,
B
] = {

153 
‰om
("cohîít_ma°î" 
«med
 
«me
) {

154 
öw¨dNode
 :=* 
TLBuf„r
(
buf„r
Ë:=* 
TLFIFOFixî
(TLFIFOFixî.
Æl
Ë:=* 
gí


159 
åaô
 
HasTLXb¨Phy
 { 
this
: 
TLBusWøµî
 =>

160 
¥iv©e
 
vÆ
 
xb¨
 = 
LazyModuÀ
(
√w
 
TLXb¨
).
sugge°Name
(
busName
 + "_xbar")

162 
def
 
öw¨dNode
: 
TLInw¨dNode
 = 
xb¨
.
node


163 
def
 
outw¨dNode
: 
TLOutw¨dNode
 = 
xb¨
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CacheCork.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

10 
imp‹t
 
	gTLMesßges
.
_


12 
˛ass
 
	$TLCacheC‹k
(
unß„
: 
Boﬁón
 = 
Ál£
, 
sökIds
: 
I¡
 = 8)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

15 
˛õ¡Fn
 = { 
˝
 =>

16 
˝
.
	`c›y
(
˛õ¡s
 = cp.˛õ¡s.
m≠
 { 
c
 => c.copy(

17 
suµ‹tsProbe
 = 
Tøns„rSizes
.
n⁄e
,

18 
sour˚Id
 = 
	`IdR™ge
(
c
.sour˚Id.
°¨t
*2, c.sour˚Id.
íd
*2))})},

19 
m™agîFn
 = { 
mp
 =>

20 
mp
.
	`c›y
(

21 
ídSökId
 = i‡(
mp
.
m™agîs
.
	`exi°s
(
_
.
ªgi⁄Ty≥
 =
Regi⁄Ty≥
.
UNCACHED
)Ë
sökIds
 0,

22 
m™agîs
 = 
mp
.m™agîs.
m≠
 { 
m
 => m.
	`c›y
(

23 
suµ‹tsAcquúeB
 = i‡(
m
.
ªgi⁄Ty≥
 =
Regi⁄Ty≥
.
UNCACHED
Ëm.
suµ‹tsGë
 m.supportsAcquireB,

24 
suµ‹tsAcquúeT
 = i‡(
m
.
ªgi⁄Ty≥
 =
Regi⁄Ty≥
.
UNCACHED
Ëm.
suµ‹tsPutFuŒ
 m.supportsAcquireT,

25 
ÆwaysGø¡sT
 = i‡(
m
.
ªgi⁄Ty≥
 =
Regi⁄Ty≥
.
UNCACHED
Ëm.
suµ‹tsPutFuŒ
 m.alwaysGrantsT)})})

27 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

28 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

30 i‡(!
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
) {

31 
out
 <> 
ö


33 
vÆ
 
˛õ¡s
 = 
edgeIn
.
˛õ¡
.clients

34 
vÆ
 
ˇches
 = 
˛õ¡s
.
	`fûãr
(
_
.
suµ‹tsProbe
)

35 
	`ªquúe
 (
˛õ¡s
.
size
 =1 || 
ˇches
.sizê=0 || 
unß„
, 
s
"Only one client can safely useá TLCacheCork; ${clients.map(_.name)}")

36 
	`ªquúe
 (
ˇches
.
size
 <1 || 
unß„
, 
s
"Only one caching clientállowed; ${clients.map(_.name)}")

37 
edgeOut
.
m™agî
.
m™agîs
.
f‹óch
 { 
m
 =>

38 
	`ªquúe
 (!
m
.
suµ‹tsAcquúeB
 || 
unß„
, 
s
"Cannot support caches beyondÅhe Cork; ${m.name}")

39 
	`ªquúe
 (
m
.
ªgi⁄Ty≥
 <
Regi⁄Ty≥
.
UNCACHED
)

59 
vÆ
 
a_a
 = 
	`Wúe
(
out
.
a
)

60 
vÆ
 
a_d
 = 
	`Wúe
(
ö
.
d
)

61 
vÆ
 
isPut
 = 
ö
.
a
.
bôs
.
›code
 ==
PutFuŒD©a
 || in.a.bôs.›codê==
PutP¨tülD©a


62 
vÆ
 
toD
 = (
ö
.
a
.
bôs
.
›code
 ==
AcquúeBlock
 && in.a.bôs.
∑øm
 ==
TLPîmissi⁄s
.
BtoT
) ||

63 (
ö
.
a
.
bôs
.
›code
 ==
AcquúePîm
)

64 
ö
.
a
.
ªady
 :
	`Mux
(
toD
, 
a_d
.ªady, 
a_a
.ready)

66 
a_a
.
vÆid
 :
ö
.
a
.vÆid && !
toD


67 
a_a
.
bôs
 :
ö
.
a
.bits

68 
a_a
.
bôs
.
sour˚
 :
ö
.
a
.bôs.sour˚ << 1 | 
	`Mux
(
isPut
, 
	`UI¡
(1), UInt(0))

71 
	`whí
 (
ö
.
a
.
bôs
.
›code
 ==
AcquúeBlock
 || in.a.bôs.›codê==
AcquúePîm
) {

72 
a_a
.
bôs
.
›code
 :
Gë


73 
a_a
.
bôs
.
∑øm
 :
	`UI¡
(0)

74 
a_a
.
bôs
.
sour˚
 :
ö
.
a
.bôs.sour˚ << 1 | 
	`UI¡
(1)

78 
a_d
.
vÆid
 :
ö
.
a
.vÆid && 
toD


79 
a_d
.
bôs
 :
edgeIn
.
	`Gø¡
(

80 
‰omSök
 = 
	`UI¡
(0),

81 
toSour˚
 = 
ö
.
a
.
bôs
.
sour˚
,

82 
lgSize
 = 
ö
.
a
.
bôs
.
size
,

83 
ˇpPîmissi⁄s
 = 
TLPîmissi⁄s
.
toT
)

86 
vÆ
 
c_a
 = 
	`Wúe
(
out
.
a
)

87 
c_a
.
vÆid
 :
ö
.
c
.vÆid && in.c.
bôs
.
›code
 ==
Rñó£D©a


88 
c_a
.
bôs
 :
edgeOut
.
	`Put
(

89 
‰omSour˚
 = 
ö
.
c
.
bôs
.
sour˚
 << 1,

90 
toAddªss
 = 
ö
.
c
.
bôs
.
addªss
,

91 
lgSize
 = 
ö
.
c
.
bôs
.
size
,

92 
d©a
 = 
ö
.
c
.
bôs
.data,

93 
c‹ru±
 = 
ö
.
c
.
bôs
.c‹ru±).
_2


96 
vÆ
 
c_d
 = 
	`Wúe
(
ö
.
d
)

97 
c_d
.
vÆid
 :
ö
.
c
.vÆid && in.c.
bôs
.
›code
 ==
Rñó£


98 
c_d
.
bôs
 :
edgeIn
.
	`Rñó£Ack
(
ö
.
c
.bits)

100 
	`as£π
 (!
ö
.
c
.
vÆid
 || in.c.
bôs
.
›code
 ==
Rñó£
 || in.c.bôs.›codê==
Rñó£D©a
)

101 
ö
.
c
.
ªady
 :
	`Mux
(ö.c.
bôs
.
›code
 ==
Rñó£
, 
c_d
.ªady, 
c_a
.ready)

104 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

107 
out
.
b
.
ªady
 :
	`Boﬁ
(
Ál£
)

108 
	`as£π
 (!
out
.
b
.
vÆid
)

111 
vÆ
 
poﬁ
 = 
	`ModuÀ
(
√w
 
	`IDPoﬁ
(
sökIds
))

112 
poﬁ
.
io
.
‰ì
.
vÆid
 :
ö
.
e
.
	`fúe
()

113 
poﬁ
.
io
.
‰ì
.
bôs
 :
ö
.
e
.bôs.
sök


115 
vÆ
 
ö_d
 = 
	`Wúe
(
ö
.
d
)

116 
vÆ
 
d_fú°
 = 
edgeOut
.
	`fú°
(
ö_d
)

117 
vÆ
 
d_gø¡
 = 
ö_d
.
bôs
.
›code
 ==
Gø¡D©a
 || in_d.bôs.›codê==
Gø¡


118 
poﬁ
.
io
.
Æloc
.
ªady
 :
ö
.
d
.
	`fúe
(Ë&& 
d_fú°
 && 
d_gø¡


119 
ö
.
d
.
vÆid
 :
ö_d
.vÆid && (
poﬁ
.
io
.
Æloc
.vÆid || !
d_fú°
 || !
d_gø¡
)

120 
ö_d
.
ªady
 :
ö
.
d
.ªady && (
poﬁ
.
io
.
Æloc
.
vÆid
 || !
d_fú°
 || !
d_gø¡
)

121 
ö
.
d
.
bôs
 :
ö_d
.bits

122 
ö
.
d
.
bôs
.
sök
 :
poﬁ
.
io
.
Æloc
.bô†
hﬁdU∆ess
 
d_fú°


125 
vÆ
 
d_d
 = 
	`Wúe
(
ö
.
d
)

126 
d_d
 <> 
out
.
d


127 
d_d
.
bôs
.
sour˚
 :
out
.
d
.bits.source >> 1

131 
vÆ
 
wSour˚Vec
 = 
	`Reg
(
	`Vec
(
edgeIn
.
˛õ¡
.
ídSour˚Id
, 
	`Boﬁ
()))

132 
vÆ
 
aWOk
 = 
edgeIn
.
m™agî
.
	`Á°Pr›îty
(
ö
.
a
.
bôs
.
addªss
, !
_
.
suµ‹tsPutFuŒ
.
n⁄e
, (
b
:
Boﬁón
Ë=> 
	`Boﬁ
(b))

133 
vÆ
 
dWOk
 = 
	`wSour˚Vec
(
d_d
.
bôs
.
sour˚
)

134 
vÆ
 
by∑ss
 = 
	`Boﬁ
(
edgeIn
.
m™agî
.
möL©ícy
 =0Ë&& 
ö
.
a
.
vÆid
 && in.a.
bôs
.
sour˚
 ==
d_d
.bits.source

135 
vÆ
 
dWHñd
 = 
	`Mux
(
by∑ss
, 
aWOk
, 
dWOk
Ë
hﬁdU∆ess
 
d_fú°


137 
	`whí
 (
ö
.
a
.
	`fúe
()) {

138 
	`wSour˚Vec
(
ö
.
a
.
bôs
.
sour˚
Ë:
aWOk


142 
edgeIn
.
˛õ¡
.
unu£dSour˚s
.
f‹óch
 { 
id
 =>

143 
	`wSour˚Vec
(
id
Ë:
	`Boﬁ
(
edgeIn
.
m™agî
.
™ySuµ‹tPutFuŒ
)

146 
	`whí
 (
out
.
d
.
bôs
.
›code
 ==
Ac˚ssAckD©a
 && out.d.bôs.
	`sour˚
(0)) {

147 
d_d
.
bôs
.
›code
 :
Gø¡D©a


148 
d_d
.
bôs
.
∑øm
 :
	`Mux
(
dWHñd
, 
TLPîmissi⁄s
.
toT
, TLPîmissi⁄s.
toB
)

150 
	`whí
 (
out
.
d
.
bôs
.
›code
 ==
Ac˚ssAck
 && !out.d.bôs.
	`sour˚
(0)) {

151 
d_d
.
bôs
.
›code
 :
Rñó£Ack


155 
	`TLArbôî
(
TLArbôî
.
lowe°IndexFú°
)(
out
.
a
, (
edgeOut
.
	`numBóts1
(
c_a
.
bôs
), c_a), (edgeOut.numBóts1(
a_a
.bits),á_a))

156 
	`TLArbôî
(
TLArbôî
.
lowe°IndexFú°
)(
ö_d
, (
edgeIn
 .
	`numBóts1
(
d_d
.
bôs
), d_d), (
	`UI¡
(0), 
	`Queue
(
c_d
, 2)), (UI¡(0), Queue(
a_d
, 2)))

159 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

160 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

161 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

165 
	}
}

167 
obje˘
 
TLCacheC‹k


169 
def
 
≠∂y
(
unß„
: 
Boﬁón
 = 
Ál£
, 
sökIds
: 
I¡
 = 8)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

171 
vÆ
 
c‹k
 = 
LazyModuÀ
(
√w
 
TLCacheC‹k
(
unß„
, 
sökIds
))

172 
	gc‹k
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CrossingHelper.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
R©i⁄ÆDúe˘i⁄


9 
˛ass
 
	$TLInw¨dCrossögHñ≥r
(
«me
: 
Såög
, 
sc›e
: 
LazySc›e
, 
node
: 
TLInw¨dNode
) {

10 
def
 
	`≠∂y
(
xög
: 
ClockCrossögTy≥
 = 
NoCrossög
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLInw¨dNode
 = {

11 
xög
 
m©ch
 {

12 
x
: 
Asynchr⁄ousCrossög
 =>

13 
node
 :*=* 
sc›e
 { 
	`TLAsyncCrossögSök
(
x
.
asSökP¨ams
Ë:*=* 
	`TLAsyncNameNode
(
«me
Ë} :*=* TLAsyncNameNode“ameË:*=* 
	`TLAsyncCrossögSour˚
(x.
sour˚Sync
)

14 
	`R©i⁄ÆCrossög
(
dúe˘i⁄
) =>

15 
node
 :*=* 
sc›e
 { 
	`TLR©i⁄ÆCrossögSök
(
dúe˘i⁄
.
Êù
Ë:*=* 
	`TLR©i⁄ÆNameNode
(
«me
Ë} :*=* TLR©i⁄ÆNameNode“ameË:*=* 
	`TLR©i⁄ÆCrossögSour˚
()

16 
	`Synchr⁄ousCrossög
(
buf„r
) =>

17 
node
 :*=* 
sc›e
 { 
	`TLBuf„r
(
buf„r
Ë:*=* 
	`TLNameNode
(
«me
) } :*=* TLNameNode(name)

20 
	}
}

22 
˛ass
 
	$TLOutw¨dCrossögHñ≥r
(
«me
: 
Såög
, 
sc›e
: 
LazySc›e
, 
node
: 
TLOutw¨dNode
) {

23 
def
 
	`≠∂y
(
xög
: 
ClockCrossögTy≥
 = 
NoCrossög
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLOutw¨dNode
 = {

24 
xög
 
m©ch
 {

25 
x
: 
Asynchr⁄ousCrossög
 =>

26 
	`TLAsyncCrossögSök
(
x
.
asSökP¨ams
Ë:*=* 
	`TLAsyncNameNode
(
«me
Ë:*=* 
sc›e
 { TLAsyncNameNode“ameË:*=* 
	`TLAsyncCrossögSour˚
(x.
sour˚Sync
Ë} :*=* 
node


27 
	`R©i⁄ÆCrossög
(
dúe˘i⁄
) =>

28 
	`TLR©i⁄ÆCrossögSök
(
dúe˘i⁄
Ë:*=* 
	`TLR©i⁄ÆNameNode
(
«me
Ë:*=* 
sc›e
 { TLR©i⁄ÆNameNode“ameË:*=* 
	`TLR©i⁄ÆCrossögSour˚
(Ë} :*=* 
node


29 
	`Synchr⁄ousCrossög
(
buf„r
) =>

30 
	`TLNameNode
(
«me
Ë:*=* 
sc›e
 { TLNameNode“ameË:*=* 
	`TLBuf„r
(
buf„r
Ë} :*=* 
node


33 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Delayer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 ˛as†
	cTLDñayî
(
q
: 
DoubÀ
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


12 
vÆ
 
node
 = 
	$TLAd≠ãrNode
()

13 
	`ªquúe
 (0.0 <
q
 && q < 1)

15 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

16 
def
 
„ed
[
T
 <: 
D©a
](
sök
: 
Decou∂edIO
[T], 
sour˚
: Decou∂edIO[T], 
noi£
: T) {

17 
vÆ
 
Ælow
 = 
	`UI¡
((
q
 * 65535.0).
toI¡
Ë<
	`LFSRNoi£Makî
(16, 
sour˚
.
vÆid
)

18 
sök
.
vÆid
 :
sour˚
.vÆid && 
Ælow


19 
sour˚
.
ªady
 :
sök
.ªady && 
Ælow


20 
sök
.
bôs
 :
sour˚
.bits

21 
	`whí
 (!
sök
.
vÆid
Ë{ sök.
bôs
 :
noi£
 }

24 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
_
), (out, _)) =>

25 
vÆ
 
™oi£
 = 
	`Wúe
(
ö
.
a
.
bôs
)

26 
™oi£
.
›code
 :
	`LFSRNoi£Makî
(3)

27 
™oi£
.
∑øm
 :
	`LFSRNoi£Makî
(3)

28 
™oi£
.
size
 :
	`LFSRNoi£Makî
◊noi£.
∑øms
.
sizeBôs
)

29 
™oi£
.
sour˚
 :
	`LFSRNoi£Makî
◊noi£.
∑øms
.
sour˚Bôs
)

30 
™oi£
.
addªss
 :
	`LFSRNoi£Makî
◊noi£.
∑øms
.
addªssBôs
)

31 
™oi£
.
mask
 :
	`LFSRNoi£Makî
◊noi£.
∑øms
.
d©aBôs
/8)

32 
™oi£
.
d©a
 :
	`LFSRNoi£Makî
◊noi£.
∑øms
.
d©aBôs
)

34 
vÆ
 
bnoi£
 = 
	`Wúe
(
out
.
b
.
bôs
)

35 
bnoi£
.
›code
 :
	`LFSRNoi£Makî
(3)

36 
bnoi£
.
∑øm
 :
	`LFSRNoi£Makî
(3)

37 
bnoi£
.
size
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
sizeBôs
)

38 
bnoi£
.
sour˚
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
sour˚Bôs
)

39 
bnoi£
.
addªss
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
addªssBôs
)

40 
bnoi£
.
mask
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
d©aBôs
/8)

41 
bnoi£
.
d©a
 :
	`LFSRNoi£Makî
(bnoi£.
∑øms
.
d©aBôs
)

43 
vÆ
 
˙oi£
 = 
	`Wúe
(
ö
.
c
.
bôs
)

44 
˙oi£
.
›code
 :
	`LFSRNoi£Makî
(3)

45 
˙oi£
.
∑øm
 :
	`LFSRNoi£Makî
(3)

46 
˙oi£
.
size
 :
	`LFSRNoi£Makî
(˙oi£.
∑øms
.
sizeBôs
)

47 
˙oi£
.
sour˚
 :
	`LFSRNoi£Makî
(˙oi£.
∑øms
.
sour˚Bôs
)

48 
˙oi£
.
addªss
 :
	`LFSRNoi£Makî
(˙oi£.
∑øms
.
addªssBôs
)

49 
˙oi£
.
d©a
 :
	`LFSRNoi£Makî
(˙oi£.
∑øms
.
d©aBôs
)

50 
˙oi£
.
c‹ru±
 :
	`LFSRNoi£Makî
(1)(0)

52 
vÆ
 
dnoi£
 = 
	`Wúe
(
out
.
d
.
bôs
)

53 
dnoi£
.
›code
 :
	`LFSRNoi£Makî
(3)

54 
dnoi£
.
∑øm
 :
	`LFSRNoi£Makî
(3)

55 
dnoi£
.
size
 :
	`LFSRNoi£Makî
(dnoi£.
∑øms
.
sizeBôs
)

56 
dnoi£
.
sour˚
 :
	`LFSRNoi£Makî
(dnoi£.
∑øms
.
sour˚Bôs
)

57 
dnoi£
.
sök
 :
	`LFSRNoi£Makî
(dnoi£.
∑øms
.
sökBôs
)

58 
dnoi£
.
díõd
 :
	`LFSRNoi£Makî
(1)(0)

59 
dnoi£
.
d©a
 :
	`LFSRNoi£Makî
(dnoi£.
∑øms
.
d©aBôs
)

60 
dnoi£
.
c‹ru±
 :
	`LFSRNoi£Makî
(1)(0)

62 
vÆ
 
íoi£
 = 
	`Wúe
(
ö
.
e
.
bôs
)

63 
íoi£
.
sök
 :
	`LFSRNoi£Makî
”noi£.
∑øms
.
sökBôs
)

65 
	`„ed
(
out
.
a
, 
ö
.a, 
™oi£
)

66 
	`„ed
(
out
.
c
, 
ö
.c, 
˙oi£
)

67 
	`„ed
(
out
.
e
, 
ö
.e, 
íoi£
)

68 
	`„ed
(
ö
.
b
, 
out
.b, 
bnoi£
)

69 
	`„ed
(
ö
.
d
, 
out
.d, 
dnoi£
)

72 
	}
}

74 
obje˘
 
	gTLDñayî


76 
def
 
≠∂y
(
q
: 
DoubÀ
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

78 
vÆ
 
dñayî
 = 
LazyModuÀ
(
√w
 
TLDñayî
(
q
))

79 
dñayî
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Edges.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
˛ass
 
	$TLEdge
(

12 
˛õ¡
: 
TLClõ¡P‹tP¨amëîs
,

13 
m™agî
: 
TLM™agîP‹tP¨amëîs
,

14 
∑øms
: 
P¨amëîs
,

15 
sour˚Info
: 
Sour˚Info
)

16 
exãnds
 
	$TLEdgeP¨amëîs
(
˛õ¡
, 
m™agî
, 
∑øms
, 
sour˚Info
)

18 
def
 
	`isAlig√d
(
addªss
: 
UI¡
, 
lgSize
: UI¡): 
Boﬁ
 = {

19 i‡(
maxLgSize
 =0Ë
	`Boﬁ
(
åue
) {

20 
vÆ
 
mask
 = 
	`UI¡ToOH1
(
lgSize
, 
maxLgSize
)

21 (
addªss
 & 
mask
Ë==
	`UI¡
(0)

25 
def
 
	`mask
(
addªss
: 
UI¡
, 
lgSize
: UInt): UInt =

26 
	`MaskGí
(
addªss
, 
lgSize
, 
m™agî
.
bótByãs
)

28 
def
 
	`°©icHasD©a
(
bundÀ
: 
TLCh™√l
): 
O±i⁄
[
Boﬁón
] = {

29 
bundÀ
 
m©ch
 {

30 
_
:
TLBundÀA
 => {

32 
vÆ
 
aD©aYes
 = 
m™agî
.
™ySuµ‹tArôhmëic
 || m™agî.
™ySuµ‹tLogiˇl
 || m™agî.
™ySuµ‹tPutFuŒ
 || m™agî.
™ySuµ‹tPutP¨tül


34 
vÆ
 
aD©aNo
 = 
m™agî
.
™ySuµ‹tAcquúeB
 || m™agî.
™ySuµ‹tGë
 || m™agî.
™ySuµ‹tHöt


36 i‡(!
aD©aYes
Ë
	`Some
(
Ál£
Ëi‡(!
aD©aNo
ËSome(
åue
Ë
N⁄e


38 
_
:
TLBundÀB
 => {

40 
vÆ
 
bD©aYes
 = 
˛õ¡
.
™ySuµ‹tArôhmëic
 || clõ¡.
™ySuµ‹tLogiˇl
 || clõ¡.
™ySuµ‹tPutFuŒ
 || clõ¡.
™ySuµ‹tPutP¨tül


42 
vÆ
 
bD©aNo
 = 
˛õ¡
.
™ySuµ‹tProbe
 || clõ¡.
™ySuµ‹tGë
 || clõ¡.
™ySuµ‹tHöt


44 i‡(!
bD©aYes
Ë
	`Some
(
Ál£
Ëi‡(!
bD©aNo
ËSome(
åue
Ë
N⁄e


46 
_
:
TLBundÀC
 => {

48 
vÆ
 
cD©aYes
 = 
˛õ¡
.
™ySuµ‹tGë
 || clõ¡.
™ySuµ‹tArôhmëic
 || clõ¡.
™ySuµ‹tLogiˇl
 || clõ¡.
™ySuµ‹tProbe


50 
vÆ
 
cD©aNo
 = 
˛õ¡
.
™ySuµ‹tPutFuŒ
 || clõ¡.
™ySuµ‹tPutP¨tül
 || clõ¡.
™ySuµ‹tHöt
 || clõ¡.
™ySuµ‹tProbe


51 i‡(!
cD©aYes
Ë
	`Some
(
Ál£
Ëi‡(!
cD©aNo
ËSome(
åue
Ë
N⁄e


53 
_
:
TLBundÀD
 => {

55 
vÆ
 
dD©aYes
 = 
m™agî
.
™ySuµ‹tGë
 || m™agî.
™ySuµ‹tArôhmëic
 || m™agî.
™ySuµ‹tLogiˇl
 || m™agî.
™ySuµ‹tAcquúeB


57 
vÆ
 
dD©aNo
 = 
m™agî
.
™ySuµ‹tPutFuŒ
 || m™agî.
™ySuµ‹tPutP¨tül
 || m™agî.
™ySuµ‹tHöt
 || m™agî.
™ySuµ‹tAcquúeT


58 i‡(!
dD©aYes
Ë
	`Some
(
Ál£
Ëi‡(!
dD©aNo
ËSome(
åue
Ë
N⁄e


60 
_
:
TLBundÀE
 => 
	`Some
(
Ál£
)

64 
def
 
	`isReque°
(
x
: 
TLCh™√l
): 
Boﬁ
 = {

65 
x
 
m©ch
 {

66 
a
: 
TLBundÀA
 => 
	`Boﬁ
(
åue
)

67 
b
: 
TLBundÀB
 => 
	`Boﬁ
(
åue
)

68 
c
: 
TLBundÀC
 => c.
	`›code
(2) && c.opcode(1)

71 
d
: 
TLBundÀD
 => d.
	`›code
(2) && !d.opcode(1)

74 
e
: 
TLBundÀE
 => 
	`Boﬁ
(
Ál£
)

78 
def
 
	`isRe•⁄£
(
x
: 
TLCh™√l
): 
Boﬁ
 = {

79 
x
 
m©ch
 {

80 
a
: 
TLBundÀA
 => 
	`Boﬁ
(
Ál£
)

81 
b
: 
TLBundÀB
 => 
	`Boﬁ
(
Ál£
)

82 
c
: 
TLBundÀC
 => !c.
	`›code
(2) || !c.opcode(1)

85 
d
: 
TLBundÀD
 => 
	`Boﬁ
(
åue
)

86 
e
: 
TLBundÀE
 => 
	`Boﬁ
(
åue
)

90 
def
 
	`hasD©a
(
x
: 
TLCh™√l
): 
Boﬁ
 = {

91 
vÆ
 
›d©a
 = 
x
 
m©ch
 {

92 
a
: 
TLBundÀA
 => !a.
	`›code
(2)

97 
b
: 
TLBundÀB
 => !b.
	`›code
(2)

102 
c
: 
TLBundÀC
 => c.
	`›code
(0)

106 
d
: 
TLBundÀD
 => d.
	`›code
(0)

109 
e
: 
TLBundÀE
 => 
	`Boﬁ
(
Ál£
)

111 
	`°©icHasD©a
(
x
).
	`m≠
(
	`Boﬁ
(
_
)).
	`gëOrEl£
(
›d©a
)

114 
def
 
	`›code
(
x
: 
TLD©aCh™√l
): 
UI¡
 = {

115 
x
 
m©ch
 {

116 
a
: 
TLBundÀA
 =>á.
›code


117 
b
: 
TLBundÀB
 => b.
›code


118 
c
: 
TLBundÀC
 => c.
›code


119 
d
: 
TLBundÀD
 => d.
›code


123 
def
 
	`∑øm
(
x
: 
TLD©aCh™√l
): 
UI¡
 = {

124 
x
 
m©ch
 {

125 
a
: 
TLBundÀA
 =>á.
∑øm


126 
b
: 
TLBundÀB
 => b.
∑øm


127 
c
: 
TLBundÀC
 => c.
∑øm


128 
d
: 
TLBundÀD
 => d.
∑øm


132 
def
 
	`size
(
x
: 
TLD©aCh™√l
): 
UI¡
 = {

133 
x
 
m©ch
 {

134 
a
: 
TLBundÀA
 =>á.
size


135 
b
: 
TLBundÀB
 => b.
size


136 
c
: 
TLBundÀC
 => c.
size


137 
d
: 
TLBundÀD
 => d.
size


141 
def
 
	`d©a
(
x
: 
TLD©aCh™√l
): 
UI¡
 = {

142 
x
 
m©ch
 {

143 
a
: 
TLBundÀA
 =>á.
d©a


144 
b
: 
TLBundÀB
 => b.
d©a


145 
c
: 
TLBundÀC
 => c.
d©a


146 
d
: 
TLBundÀD
 => d.
d©a


150 
def
 
	`c‹ru±
(
x
: 
TLD©aCh™√l
): 
Boﬁ
 = {

151 
x
 
m©ch
 {

152 
a
: 
TLBundÀA
 =>á.
c‹ru±


153 
b
: 
TLBundÀB
 => b.
c‹ru±


154 
c
: 
TLBundÀC
 => c.
c‹ru±


155 
d
: 
TLBundÀD
 => d.
c‹ru±


159 
def
 
	`mask
(
x
: 
TLAddrCh™√l
): 
UI¡
 = {

160 
x
 
m©ch
 {

161 
a
: 
TLBundÀA
 =>á.
mask


162 
b
: 
TLBundÀB
 => b.
mask


163 
c
: 
TLBundÀC
 => 
	`mask
(c.
addªss
, c.
size
)

167 
def
 
	`fuŒ_mask
(
x
: 
TLAddrCh™√l
): 
UI¡
 = {

168 
x
 
m©ch
 {

169 
a
: 
TLBundÀA
 => 
	`mask
◊.
addªss
,á.
size
)

170 
b
: 
TLBundÀB
 => 
	`mask
(b.
addªss
, b.
size
)

171 
c
: 
TLBundÀC
 => 
	`mask
(c.
addªss
, c.
size
)

175 
def
 
	`addªss
(
x
: 
TLAddrCh™√l
): 
UI¡
 = {

176 
x
 
m©ch
 {

177 
a
: 
TLBundÀA
 =>á.
addªss


178 
b
: 
TLBundÀB
 => b.
addªss


179 
c
: 
TLBundÀC
 => c.
addªss


183 
def
 
	`sour˚
(
x
: 
TLD©aCh™√l
): 
UI¡
 = {

184 
x
 
m©ch
 {

185 
a
: 
TLBundÀA
 =>á.
sour˚


186 
b
: 
TLBundÀB
 => b.
sour˚


187 
c
: 
TLBundÀC
 => c.
sour˚


188 
d
: 
TLBundÀD
 => d.
sour˚


192 
def
 
	`addr_hi
(
x
: 
UI¡
): UI¡ = x >> 
	`log2Ceû
(
m™agî
.
bótByãs
)

193 
def
 
	`addr_lo
(
x
: 
UI¡
): UInt =

194 i‡(
m™agî
.
bótByãs
 =1Ë
	`UI¡
(0Ë
	`x
(
	`log2Ceû
(manager.beatBytes)-1, 0)

196 
def
 
	`addr_hi
(
x
: 
TLAddrCh™√l
): 
UI¡
 =áddr_hi(
	`addªss
(x))

197 
def
 
	`addr_lo
(
x
: 
TLAddrCh™√l
): 
UI¡
 =áddr_lo(
	`addªss
(x))

199 
def
 
	`numBóts
(
x
: 
TLCh™√l
): 
UI¡
 = {

200 
x
 
m©ch
 {

201 
_
: 
TLBundÀE
 => 
	`UI¡
(1)

202 
bundÀ
: 
TLD©aCh™√l
 => {

203 
vÆ
 
hasD©a
 = 
this
.
	`hasD©a
(
bundÀ
)

204 
vÆ
 
size
 = 
this
.
	`size
(
bundÀ
)

205 
vÆ
 
cutoff
 = 
	`log2Ceû
(
m™agî
.
bótByãs
)

206 
vÆ
 
smÆl
 = i‡(
m™agî
.
maxTøns„r
 <m™agî.
bótByãs
Ë
	`Boﬁ
(
åue
Ë
size
 <
	`UI¡
(
cutoff
)

207 
vÆ
 
decode
 = 
	`UI¡ToOH
(
size
, 
maxLgSize
+1Ë>> 
cutoff


208 
	`Mux
(
hasD©a
, 
decode
 | 
smÆl
.
asUI¡
, 
	`UI¡
(1))

213 
def
 
	`numBóts1
(
x
: 
TLCh™√l
): 
UI¡
 = {

214 
x
 
m©ch
 {

215 
_
: 
TLBundÀE
 => 
	`UI¡
(0)

216 
bundÀ
: 
TLD©aCh™√l
 => {

217 i‡(
maxLgSize
 == 0) {

218 
	`UI¡
(0)

220 
vÆ
 
decode
 = 
	`UI¡ToOH1
(
	`size
(
bundÀ
), 
maxLgSize
Ë>> 
	`log2Ceû
(
m™agî
.
bótByãs
)

221 
	`Mux
(
	`hasD©a
(
bundÀ
), 
decode
, 
	`UI¡
(0))

227 
def
 
	`fú°œ°Hñ≥r
(
bôs
: 
TLCh™√l
, 
fúe
: 
Boﬁ
): (Boﬁ, Boﬁ, Boﬁ, 
UI¡
) = {

228 
vÆ
 
bóts1
 = 
	`numBóts1
(
bôs
)

229 
vÆ
 
cou¡î
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
	`log2Up
(
maxTøns„r
 / 
m™agî
.
bótByãs
)))

230 
vÆ
 
cou¡î1
 = 
cou¡î
 - 
	`UI¡
(1)

231 
vÆ
 
fú°
 = 
cou¡î
 ==
	`UI¡
(0)

232 
vÆ
 
œ°
 = 
cou¡î
 ==
	`UI¡
(1Ë|| 
bóts1
 === UInt(0)

233 
vÆ
 
d⁄e
 = 
œ°
 && 
fúe


234 
vÆ
 
cou¡
 = (
bóts1
 & ~
cou¡î1
)

235 
	`whí
 (
fúe
) {

236 
cou¡î
 :
	`Mux
(
fú°
, 
bóts1
, 
cou¡î1
)

238 (
fú°
, 
œ°
, 
d⁄e
, 
cou¡
)

241 
def
 
	`fú°
(
bôs
: 
TLCh™√l
, 
fúe
: 
Boﬁ
): Boﬁ = 
	`fú°œ°Hñ≥r
(bôs, fúe).
_1


242 
def
 
	`fú°
(
x
: 
Decou∂edIO
[
TLCh™√l
]): 
Boﬁ
 = fú°(x.
bôs
, x.
	`fúe
())

243 
def
 
	`fú°
(
x
: 
VÆidIO
[
TLCh™√l
]): 
Boﬁ
 = fú°(x.
bôs
, x.
vÆid
)

245 
def
 
	`œ°
(
bôs
: 
TLCh™√l
, 
fúe
: 
Boﬁ
): Boﬁ = 
	`fú°œ°Hñ≥r
(bôs, fúe).
_2


246 
def
 
	`œ°
(
x
: 
Decou∂edIO
[
TLCh™√l
]): 
Boﬁ
 =Üa°(x.
bôs
, x.
	`fúe
())

247 
def
 
	`œ°
(
x
: 
VÆidIO
[
TLCh™√l
]): 
Boﬁ
 =Üa°(x.
bôs
, x.
vÆid
)

249 
def
 
	`d⁄e
(
bôs
: 
TLCh™√l
, 
fúe
: 
Boﬁ
): Boﬁ = 
	`fú°œ°Hñ≥r
(bôs, fúe).
_3


250 
def
 
	`d⁄e
(
x
: 
Decou∂edIO
[
TLCh™√l
]): 
Boﬁ
 = d⁄e(x.
bôs
, x.
	`fúe
())

251 
def
 
	`d⁄e
(
x
: 
VÆidIO
[
TLCh™√l
]): 
Boﬁ
 = d⁄e(x.
bôs
, x.
vÆid
)

253 
def
 
	`fú°œ°
(
bôs
: 
TLCh™√l
, 
fúe
: 
Boﬁ
): (Bool, Bool, Bool) = {

254 
vÆ
 
r
 = 
	`fú°œ°Hñ≥r
(
bôs
, 
fúe
)

255 (
r
.
_1
,Ñ.
_2
,Ñ.
_3
)

257 
def
 
	`fú°œ°
(
x
: 
Decou∂edIO
[
TLCh™√l
]): (
Boﬁ
, Boﬁ, BoﬁËfú°œ°(x.
bôs
, x.
	`fúe
())

258 
def
 
	`fú°œ°
(
x
: 
VÆidIO
[
TLCh™√l
]): (
Boﬁ
, Boﬁ, BoﬁËfú°œ°(x.
bôs
, x.
vÆid
)

260 
def
 
	`cou¡
(
bôs
: 
TLCh™√l
, 
fúe
: 
Boﬁ
): (Boﬁ, Boﬁ, Boﬁ, 
UI¡
) = {

261 
vÆ
 
r
 = 
	`fú°œ°Hñ≥r
(
bôs
, 
fúe
)

262 (
r
.
_1
,Ñ.
_2
,Ñ.
_3
,Ñ.
_4
)

264 
def
 
	`cou¡
(
x
: 
Decou∂edIO
[
TLCh™√l
]): (
Boﬁ
, Boﬁ, Boﬁ, 
UI¡
Ëcou¡(x.
bôs
, x.
	`fúe
())

265 
def
 
	`cou¡
(
x
: 
VÆidIO
[
TLCh™√l
]): (
Boﬁ
, Boﬁ, Boﬁ, 
UI¡
Ëcou¡(x.
bôs
, x.
vÆid
)

267 
def
 
	`addr_öc
(
bôs
: 
TLCh™√l
, 
fúe
: 
Boﬁ
): (Boﬁ, Boﬁ, Boﬁ, 
UI¡
) = {

268 
vÆ
 
r
 = 
	`fú°œ°Hñ≥r
(
bôs
, 
fúe
)

269 (
r
.
_1
,Ñ.
_2
,Ñ.
_3
,Ñ.
_4
 << 
	`log2Ceû
(
m™agî
.
bótByãs
))

271 
def
 
	`addr_öc
(
x
: 
Decou∂edIO
[
TLCh™√l
]): (
Boﬁ
, Boﬁ, Boﬁ, 
UI¡
Ëaddr_öc(x.
bôs
, x.
	`fúe
())

272 
def
 
	`addr_öc
(
x
: 
VÆidIO
[
TLCh™√l
]): (
Boﬁ
, Boﬁ, Boﬁ, 
UI¡
Ëaddr_öc(x.
bôs
, x.
vÆid
)

275 
def
 
	`öFlight
(
x
: 
TLBundÀ
): (
UI¡
, UInt) = {

276 
vÆ
 
Êight
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
	`log2Ceû
(3*
˛õ¡
.
ídSour˚Id
+1)))

277 
vÆ
 
b˚
 = 
m™agî
.
™ySuµ‹tAcquúeB
 && 
˛õ¡
.
™ySuµ‹tProbe


279 
	`vÆ
 (
a_fú°
, 
a_œ°
, 
_
Ë
	`fú°œ°
(
x
.
a
)

280 
	`vÆ
 (
b_fú°
, 
b_œ°
, 
_
Ë
	`fú°œ°
(
x
.
b
)

281 
	`vÆ
 (
c_fú°
, 
c_œ°
, 
_
Ë
	`fú°œ°
(
x
.
c
)

282 
	`vÆ
 (
d_fú°
, 
d_œ°
, 
_
Ë
	`fú°œ°
(
x
.
d
)

283 
	`vÆ
 (
e_fú°
, 
e_œ°
, 
_
Ë
	`fú°œ°
(
x
.
e
)

285 
	`vÆ
 (
a_ªque°
, 
a_ª•⁄£
Ë(
	`isReque°
(
x
.
a
.
bôs
), 
	`isRe•⁄£
(x.a.bits))

286 
	`vÆ
 (
b_ªque°
, 
b_ª•⁄£
Ë(
	`isReque°
(
x
.
b
.
bôs
), 
	`isRe•⁄£
(x.b.bits))

287 
	`vÆ
 (
c_ªque°
, 
c_ª•⁄£
Ë(
	`isReque°
(
x
.
c
.
bôs
), 
	`isRe•⁄£
(x.c.bits))

288 
	`vÆ
 (
d_ªque°
, 
d_ª•⁄£
Ë(
	`isReque°
(
x
.
d
.
bôs
), 
	`isRe•⁄£
(x.d.bits))

289 
	`vÆ
 (
e_ªque°
, 
e_ª•⁄£
Ë(
	`isReque°
(
x
.
e
.
bôs
), 
	`isRe•⁄£
(x.e.bits))

291 
vÆ
 
a_öc
 = 
x
.
a
.
	`fúe
(Ë&& 
a_fú°
 && 
a_ªque°


292 
vÆ
 
b_öc
 = 
x
.
b
.
	`fúe
(Ë&& 
b_fú°
 && 
b_ªque°


293 
vÆ
 
c_öc
 = 
x
.
c
.
	`fúe
(Ë&& 
c_fú°
 && 
c_ªque°


294 
vÆ
 
d_öc
 = 
x
.
d
.
	`fúe
(Ë&& 
d_fú°
 && 
d_ªque°


295 
vÆ
 
e_öc
 = 
x
.
e
.
	`fúe
(Ë&& 
e_fú°
 && 
e_ªque°


296 
vÆ
 
öc
 = 
	`C©
(
	`Seq
(
a_öc
, 
d_öc
Ë++ (i‡(
b˚
ËSeq(
b_öc
, 
c_öc
, 
e_öc
Ë
Nû
))

298 
vÆ
 
a_dec
 = 
x
.
a
.
	`fúe
(Ë&& 
a_œ°
 && 
a_ª•⁄£


299 
vÆ
 
b_dec
 = 
x
.
b
.
	`fúe
(Ë&& 
b_œ°
 && 
b_ª•⁄£


300 
vÆ
 
c_dec
 = 
x
.
c
.
	`fúe
(Ë&& 
c_œ°
 && 
c_ª•⁄£


301 
vÆ
 
d_dec
 = 
x
.
d
.
	`fúe
(Ë&& 
d_œ°
 && 
d_ª•⁄£


302 
vÆ
 
e_dec
 = 
x
.
e
.
	`fúe
(Ë&& 
e_œ°
 && 
e_ª•⁄£


303 
vÆ
 
dec
 = 
	`C©
(
	`Seq
(
a_dec
, 
d_dec
Ë++ (i‡(
b˚
ËSeq(
b_dec
, 
c_dec
, 
e_dec
Ë
Nû
))

305 
vÆ
 
√xt_Êight
 = 
Êight
 + 
	`P›Cou¡
(
öc
Ë- P›Cou¡(
dec
)

306 
Êight
 :
√xt_Êight


308 (
Êight
, 
√xt_Êight
)

310 
	}
}

312 
˛ass
 
	$TLEdgeOut
(

313 
˛õ¡
: 
TLClõ¡P‹tP¨amëîs
,

314 
m™agî
: 
TLM™agîP‹tP¨amëîs
,

315 
∑øms
: 
P¨amëîs
,

316 
sour˚Info
: 
Sour˚Info
)

317 
exãnds
 
	$TLEdge
(
˛õ¡
, 
m™agî
, 
∑øms
, 
sour˚Info
)

320 
def
 
	`AcquúeBlock
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
growPîmissi⁄s
: UInt) = {

321 
	`ªquúe
 (
m™agî
.
™ySuµ‹tAcquúeB
)

322 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsAcquúeBFa°
(
toAddªss
, 
lgSize
)

323 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

324 
a
.
›code
 :
TLMesßges
.
AcquúeBlock


325 
a
.
∑øm
 :
growPîmissi⁄s


326 
a
.
size
 :
lgSize


327 
a
.
sour˚
 :
‰omSour˚


328 
a
.
addªss
 :
toAddªss


329 
a
.
mask
 :
	`mask
(
toAddªss
, 
lgSize
)

330 
a
.
d©a
 :
	`UI¡
(0)

331 
a
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

332 (
ÀgÆ
, 
a
)

335 
def
 
	`AcquúePîm
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
growPîmissi⁄s
: UInt) = {

336 
	`ªquúe
 (
m™agî
.
™ySuµ‹tAcquúeB
)

337 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsAcquúeBFa°
(
toAddªss
, 
lgSize
)

338 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

339 
a
.
›code
 :
TLMesßges
.
AcquúePîm


340 
a
.
∑øm
 :
growPîmissi⁄s


341 
a
.
size
 :
lgSize


342 
a
.
sour˚
 :
‰omSour˚


343 
a
.
addªss
 :
toAddªss


344 
a
.
mask
 :
	`mask
(
toAddªss
, 
lgSize
)

345 
a
.
d©a
 :
	`UI¡
(0)

346 
a
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

347 (
ÀgÆ
, 
a
)

350 
def
 
	`Rñó£
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
shrökPîmissi⁄s
: UI¡): (
Boﬁ
, 
TLBundÀC
) = {

351 
	`ªquúe
 (
m™agî
.
™ySuµ‹tAcquúeB
)

352 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsAcquúeBFa°
(
toAddªss
, 
lgSize
)

353 
vÆ
 
c
 = 
	`Wúe
(
√w
 
	`TLBundÀC
(
bundÀ
))

354 
c
.
›code
 :
TLMesßges
.
Rñó£


355 
c
.
∑øm
 :
shrökPîmissi⁄s


356 
c
.
size
 :
lgSize


357 
c
.
sour˚
 :
‰omSour˚


358 
c
.
addªss
 :
toAddªss


359 
c
.
d©a
 :
	`UI¡
(0)

360 
c
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

361 (
ÀgÆ
, 
c
)

364 
def
 
	`Rñó£
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
shrökPîmissi⁄s
: UI¡, 
d©a
: UI¡, 
c‹ru±
: 
Boﬁ
): (Boﬁ, 
TLBundÀC
) = {

365 
	`ªquúe
 (
m™agî
.
™ySuµ‹tAcquúeB
)

366 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsAcquúeBFa°
(
toAddªss
, 
lgSize
)

367 
vÆ
 
c
 = 
	`Wúe
(
√w
 
	`TLBundÀC
(
bundÀ
))

368 
c
.
›code
 :
TLMesßges
.
Rñó£D©a


369 
c
.
∑øm
 :
shrökPîmissi⁄s


370 
c
.
size
 :
lgSize


371 
c
.
sour˚
 :
‰omSour˚


372 
c
.
addªss
 :
toAddªss


373 
c
.
d©a
 := data

374 
c
.
c‹ru±
 := corrupt

375 (
ÀgÆ
, 
c
)

378 
def
 
	`Rñó£
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
shrökPîmissi⁄s
: UI¡, 
d©a
: UI¡): (
Boﬁ
, 
TLBundÀC
) =

379 
	`Rñó£
(
‰omSour˚
, 
toAddªss
, 
lgSize
, 
shrökPîmissi⁄s
, 
d©a
, 
	`Boﬁ
(
Ál£
))

381 
def
 
	`ProbeAck
(
b
: 
TLBundÀB
, 
ªp‹tPîmissi⁄s
: 
UI¡
): 
TLBundÀC
 =

382 
	`ProbeAck
(
b
.
sour˚
, b.
addªss
, b.
size
, 
ªp‹tPîmissi⁄s
)

384 
def
 
	`ProbeAck
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
ªp‹tPîmissi⁄s
: UI¡): 
TLBundÀC
 = {

385 
vÆ
 
c
 = 
	`Wúe
(
√w
 
	`TLBundÀC
(
bundÀ
))

386 
c
.
›code
 :
TLMesßges
.
ProbeAck


387 
c
.
∑øm
 :
ªp‹tPîmissi⁄s


388 
c
.
size
 :
lgSize


389 
c
.
sour˚
 :
‰omSour˚


390 
c
.
addªss
 :
toAddªss


391 
c
.
d©a
 :
	`UI¡
(0)

392 
c
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

393 
c


396 
def
 
	`ProbeAck
(
b
: 
TLBundÀB
, 
ªp‹tPîmissi⁄s
: 
UI¡
, 
d©a
: UI¡): 
TLBundÀC
 =

397 
	`ProbeAck
(
b
.
sour˚
, b.
addªss
, b.
size
, 
ªp‹tPîmissi⁄s
, 
d©a
)

399 
def
 
	`ProbeAck
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
ªp‹tPîmissi⁄s
: UI¡, 
d©a
: UI¡, 
c‹ru±
: 
Boﬁ
): 
TLBundÀC
 = {

400 
vÆ
 
c
 = 
	`Wúe
(
√w
 
	`TLBundÀC
(
bundÀ
))

401 
c
.
›code
 :
TLMesßges
.
ProbeAckD©a


402 
c
.
∑øm
 :
ªp‹tPîmissi⁄s


403 
c
.
size
 :
lgSize


404 
c
.
sour˚
 :
‰omSour˚


405 
c
.
addªss
 :
toAddªss


406 
c
.
d©a
 := data

407 
c
.
c‹ru±
 := corrupt

408 
c


411 
def
 
	`ProbeAck
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
ªp‹tPîmissi⁄s
: UI¡, 
d©a
: UI¡): 
TLBundÀC
 =

412 
	`ProbeAck
(
‰omSour˚
, 
toAddªss
, 
lgSize
, 
ªp‹tPîmissi⁄s
, 
d©a
, 
	`Boﬁ
(
Ál£
))

414 
def
 
	`Gø¡Ack
(
d
: 
TLBundÀD
): 
TLBundÀE
 = Gø¡Ack(d.
sök
)

415 
def
 
	`Gø¡Ack
(
toSök
: 
UI¡
): 
TLBundÀE
 = {

416 
vÆ
 
e
 = 
	`Wúe
(
√w
 
	`TLBundÀE
(
bundÀ
))

417 
e
.
sök
 :
toSök


418 
e


422 
def
 
	`Gë
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UInt) = {

423 
	`ªquúe
 (
m™agî
.
™ySuµ‹tGë
)

424 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsGëFa°
(
toAddªss
, 
lgSize
)

425 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

426 
a
.
›code
 :
TLMesßges
.
Gë


427 
a
.
∑øm
 :
	`UI¡
(0)

428 
a
.
size
 :
lgSize


429 
a
.
sour˚
 :
‰omSour˚


430 
a
.
addªss
 :
toAddªss


431 
a
.
mask
 :
	`mask
(
toAddªss
, 
lgSize
)

432 
a
.
d©a
 :
	`UI¡
(0)

433 
a
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

434 (
ÀgÆ
, 
a
)

437 
def
 
	`Put
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡): (
Boﬁ
, 
TLBundÀA
) =

438 
	`Put
(
‰omSour˚
, 
toAddªss
, 
lgSize
, 
d©a
, 
	`Boﬁ
(
Ál£
))

440 
def
 
	`Put
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
c‹ru±
: 
Boﬁ
): (Boﬁ, 
TLBundÀA
) = {

441 
	`ªquúe
 (
m™agî
.
™ySuµ‹tPutFuŒ
)

442 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsPutFuŒFa°
(
toAddªss
, 
lgSize
)

443 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

444 
a
.
›code
 :
TLMesßges
.
PutFuŒD©a


445 
a
.
∑øm
 :
	`UI¡
(0)

446 
a
.
size
 :
lgSize


447 
a
.
sour˚
 :
‰omSour˚


448 
a
.
addªss
 :
toAddªss


449 
a
.
mask
 :
	`mask
(
toAddªss
, 
lgSize
)

450 
a
.
d©a
 := data

451 
a
.
c‹ru±
 := corrupt

452 (
ÀgÆ
, 
a
)

455 
def
 
	`Put
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
mask
: UI¡): (
Boﬁ
, 
TLBundÀA
) =

456 
	`Put
(
‰omSour˚
, 
toAddªss
, 
lgSize
, 
d©a
, 
mask
, 
	`Boﬁ
(
Ál£
))

458 
def
 
	`Put
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
mask
: UI¡, 
c‹ru±
: 
Boﬁ
): (Boﬁ, 
TLBundÀA
) = {

459 
	`ªquúe
 (
m™agî
.
™ySuµ‹tPutP¨tül
)

460 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsPutP¨tülFa°
(
toAddªss
, 
lgSize
)

461 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

462 
a
.
›code
 :
TLMesßges
.
PutP¨tülD©a


463 
a
.
∑øm
 :
	`UI¡
(0)

464 
a
.
size
 :
lgSize


465 
a
.
sour˚
 :
‰omSour˚


466 
a
.
addªss
 :
toAddªss


467 
a
.
mask
 := mask

468 
a
.
d©a
 := data

469 
a
.
c‹ru±
 := corrupt

470 (
ÀgÆ
, 
a
)

473 
def
 
	`Arôhmëic
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
©omic
: UI¡, 
c‹ru±
: 
Boﬁ
 = 
	`Boﬁ
(
Ál£
)): (Boﬁ, 
TLBundÀA
) = {

474 
	`ªquúe
 (
m™agî
.
™ySuµ‹tArôhmëic
)

475 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsArôhmëicFa°
(
toAddªss
, 
lgSize
)

476 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

477 
a
.
›code
 :
TLMesßges
.
ArôhmëicD©a


478 
a
.
∑øm
 :
©omic


479 
a
.
size
 :
lgSize


480 
a
.
sour˚
 :
‰omSour˚


481 
a
.
addªss
 :
toAddªss


482 
a
.
mask
 :
	`mask
(
toAddªss
, 
lgSize
)

483 
a
.
d©a
 := data

484 
a
.
c‹ru±
 := corrupt

485 (
ÀgÆ
, 
a
)

488 
def
 
	`Logiˇl
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
©omic
: UI¡, 
c‹ru±
: 
Boﬁ
 = 
	`Boﬁ
(
Ál£
)) = {

489 
	`ªquúe
 (
m™agî
.
™ySuµ‹tLogiˇl
)

490 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsLogiˇlFa°
(
toAddªss
, 
lgSize
)

491 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

492 
a
.
›code
 :
TLMesßges
.
LogiˇlD©a


493 
a
.
∑øm
 :
©omic


494 
a
.
size
 :
lgSize


495 
a
.
sour˚
 :
‰omSour˚


496 
a
.
addªss
 :
toAddªss


497 
a
.
mask
 :
	`mask
(
toAddªss
, 
lgSize
)

498 
a
.
d©a
 := data

499 
a
.
c‹ru±
 := corrupt

500 (
ÀgÆ
, 
a
)

503 
def
 
	`Höt
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
∑øm
: UInt) = {

504 
	`ªquúe
 (
m™agî
.
™ySuµ‹tHöt
)

505 
vÆ
 
ÀgÆ
 = 
m™agî
.
	`suµ‹tsHötFa°
(
toAddªss
, 
lgSize
)

506 
vÆ
 
a
 = 
	`Wúe
(
√w
 
	`TLBundÀA
(
bundÀ
))

507 
a
.
›code
 :
TLMesßges
.
Höt


508 
a
.
∑øm
 :=Öaram

509 
a
.
size
 :
lgSize


510 
a
.
sour˚
 :
‰omSour˚


511 
a
.
addªss
 :
toAddªss


512 
a
.
mask
 :
	`mask
(
toAddªss
, 
lgSize
)

513 
a
.
d©a
 :
	`UI¡
(0)

514 
a
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

515 (
ÀgÆ
, 
a
)

518 
def
 
	`Ac˚ssAck
(
b
: 
TLBundÀB
): 
TLBundÀC
 = Ac˚ssAck(b.
sour˚
, 
	`addªss
(b), b.
size
)

519 
def
 
	`Ac˚ssAck
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UInt) = {

520 
vÆ
 
c
 = 
	`Wúe
(
√w
 
	`TLBundÀC
(
bundÀ
))

521 
c
.
›code
 :
TLMesßges
.
Ac˚ssAck


522 
c
.
∑øm
 :
	`UI¡
(0)

523 
c
.
size
 :
lgSize


524 
c
.
sour˚
 :
‰omSour˚


525 
c
.
addªss
 :
toAddªss


526 
c
.
d©a
 :
	`UI¡
(0)

527 
c
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

528 
c


531 
def
 
	`Ac˚ssAck
(
b
: 
TLBundÀB
, 
d©a
: 
UI¡
): 
TLBundÀC
 = Ac˚ssAck(b.
sour˚
, 
	`addªss
(b), b.
size
, data)

532 
def
 
	`Ac˚ssAck
(
b
: 
TLBundÀB
, 
d©a
: 
UI¡
, 
c‹ru±
: 
Boﬁ
): 
TLBundÀC
 = Ac˚ssAck(b.
sour˚
, 
	`addªss
(b), b.
size
, data, corrupt)

533 
def
 
	`Ac˚ssAck
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡): 
TLBundÀC
 = Ac˚ssAck(‰omSour˚,ÅoAddªss,ÜgSize, d©a, 
	`Boﬁ
(
Ál£
))

534 
def
 
	`Ac˚ssAck
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
c‹ru±
: 
Boﬁ
) = {

535 
vÆ
 
c
 = 
	`Wúe
(
√w
 
	`TLBundÀC
(
bundÀ
))

536 
c
.
›code
 :
TLMesßges
.
Ac˚ssAckD©a


537 
c
.
∑øm
 :
	`UI¡
(0)

538 
c
.
size
 :
lgSize


539 
c
.
sour˚
 :
‰omSour˚


540 
c
.
addªss
 :
toAddªss


541 
c
.
d©a
 := data

542 
c
.
c‹ru±
 := corrupt

543 
c


546 
def
 
	`HötAck
(
b
: 
TLBundÀB
): 
TLBundÀC
 = HötAck(b.
sour˚
, 
	`addªss
(b), b.
size
)

547 
def
 
	`HötAck
(
‰omSour˚
: 
UI¡
, 
toAddªss
: UI¡, 
lgSize
: UInt) = {

548 
vÆ
 
c
 = 
	`Wúe
(
√w
 
	`TLBundÀC
(
bundÀ
))

549 
c
.
›code
 :
TLMesßges
.
HötAck


550 
c
.
∑øm
 :
	`UI¡
(0)

551 
c
.
size
 :
lgSize


552 
c
.
sour˚
 :
‰omSour˚


553 
c
.
addªss
 :
toAddªss


554 
c
.
d©a
 :
	`UI¡
(0)

555 
c
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

556 
c


558 
	}
}

560 
˛ass
 
	$TLEdgeIn
(

561 
˛õ¡
: 
TLClõ¡P‹tP¨amëîs
,

562 
m™agî
: 
TLM™agîP‹tP¨amëîs
,

563 
∑øms
: 
P¨amëîs
,

564 
sour˚Info
: 
Sour˚Info
)

565 
exãnds
 
	$TLEdge
(
˛õ¡
, 
m™agî
, 
∑øms
, 
sour˚Info
)

568 
def
 
	`Probe
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
ˇpPîmissi⁄s
: UInt) = {

569 
	`ªquúe
 (
˛õ¡
.
™ySuµ‹tProbe
)

570 
vÆ
 
ÀgÆ
 = 
˛õ¡
.
	`suµ‹tsProbe
(
toSour˚
, 
lgSize
)

571 
vÆ
 
b
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
bundÀ
))

572 
b
.
›code
 :
TLMesßges
.
Probe


573 
b
.
∑øm
 :
ˇpPîmissi⁄s


574 
b
.
size
 :
lgSize


575 
b
.
sour˚
 :
toSour˚


576 
b
.
addªss
 :
‰omAddªss


577 
b
.
mask
 :
	`mask
(
‰omAddªss
, 
lgSize
)

578 
b
.
d©a
 :
	`UI¡
(0)

579 
b
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

580 (
ÀgÆ
, 
b
)

583 
def
 
	`Gø¡
(
‰omSök
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
ˇpPîmissi⁄s
: UI¡): 
TLBundÀD
 = Gø¡(‰omSök,ÅoSour˚,ÜgSize, c≠Pîmissi⁄s, 
	`Boﬁ
(
Ál£
))

584 
def
 
	`Gø¡
(
‰omSök
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
ˇpPîmissi⁄s
: UI¡, 
díõd
: 
Boﬁ
) = {

585 
vÆ
 
d
 = 
	`Wúe
(
√w
 
	`TLBundÀD
(
bundÀ
))

586 
d
.
›code
 :
TLMesßges
.
Gø¡


587 
d
.
∑øm
 :
ˇpPîmissi⁄s


588 
d
.
size
 :
lgSize


589 
d
.
sour˚
 :
toSour˚


590 
d
.
sök
 :
‰omSök


591 
d
.
díõd
 := denied

592 
d
.
d©a
 :
	`UI¡
(0)

593 
d
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

594 
d


597 
def
 
	`Gø¡
(
‰omSök
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
ˇpPîmissi⁄s
: UI¡, 
d©a
: UI¡): 
TLBundÀD
 = Gø¡(‰omSök,ÅoSour˚,ÜgSize, c≠Pîmissi⁄s, d©a, 
	`Boﬁ
(
Ál£
), Bool(false))

598 
def
 
	`Gø¡
(
‰omSök
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
ˇpPîmissi⁄s
: UI¡, 
d©a
: UI¡, 
díõd
: 
Boﬁ
, 
c‹ru±
: Bool) = {

599 
vÆ
 
d
 = 
	`Wúe
(
√w
 
	`TLBundÀD
(
bundÀ
))

600 
d
.
›code
 :
TLMesßges
.
Gø¡D©a


601 
d
.
∑øm
 :
ˇpPîmissi⁄s


602 
d
.
size
 :
lgSize


603 
d
.
sour˚
 :
toSour˚


604 
d
.
sök
 :
‰omSök


605 
d
.
díõd
 := denied

606 
d
.
d©a
 := data

607 
d
.
c‹ru±
 := corrupt

608 
d


611 
def
 
	`Rñó£Ack
(
c
: 
TLBundÀC
): 
TLBundÀD
 = Rñó£Ack(c.
sour˚
, c.
size
, 
	`Boﬁ
(
Ál£
))

612 
def
 
	`Rñó£Ack
(
toSour˚
: 
UI¡
, 
lgSize
: UI¡, 
díõd
: 
Boﬁ
): 
TLBundÀD
 = {

613 
vÆ
 
d
 = 
	`Wúe
(
√w
 
	`TLBundÀD
(
bundÀ
))

614 
d
.
›code
 :
TLMesßges
.
Rñó£Ack


615 
d
.
∑øm
 :
	`UI¡
(0)

616 
d
.
size
 :
lgSize


617 
d
.
sour˚
 :
toSour˚


618 
d
.
sök
 :
	`UI¡
(0)

619 
d
.
díõd
 := denied

620 
d
.
d©a
 :
	`UI¡
(0)

621 
d
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

622 
d


626 
def
 
	`Gë
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UInt) = {

627 
	`ªquúe
 (
˛õ¡
.
™ySuµ‹tGë
)

628 
vÆ
 
ÀgÆ
 = 
˛õ¡
.
	`suµ‹tsGë
(
toSour˚
, 
lgSize
)

629 
vÆ
 
b
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
bundÀ
))

630 
b
.
›code
 :
TLMesßges
.
Gë


631 
b
.
∑øm
 :
	`UI¡
(0)

632 
b
.
size
 :
lgSize


633 
b
.
sour˚
 :
toSour˚


634 
b
.
addªss
 :
‰omAddªss


635 
b
.
mask
 :
	`mask
(
‰omAddªss
, 
lgSize
)

636 
b
.
d©a
 :
	`UI¡
(0)

637 
b
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

638 (
ÀgÆ
, 
b
)

641 
def
 
	`Put
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡): (
Boﬁ
, 
TLBundÀB
) =

642 
	`Put
(
‰omAddªss
, 
toSour˚
, 
lgSize
, 
d©a
, 
	`Boﬁ
(
Ál£
))

644 
def
 
	`Put
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
c‹ru±
: 
Boﬁ
): (Boﬁ, 
TLBundÀB
) = {

645 
	`ªquúe
 (
˛õ¡
.
™ySuµ‹tPutFuŒ
)

646 
vÆ
 
ÀgÆ
 = 
˛õ¡
.
	`suµ‹tsPutFuŒ
(
toSour˚
, 
lgSize
)

647 
vÆ
 
b
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
bundÀ
))

648 
b
.
›code
 :
TLMesßges
.
PutFuŒD©a


649 
b
.
∑øm
 :
	`UI¡
(0)

650 
b
.
size
 :
lgSize


651 
b
.
sour˚
 :
toSour˚


652 
b
.
addªss
 :
‰omAddªss


653 
b
.
mask
 :
	`mask
(
‰omAddªss
, 
lgSize
)

654 
b
.
d©a
 := data

655 
b
.
c‹ru±
 := corrupt

656 (
ÀgÆ
, 
b
)

659 
def
 
	`Put
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
mask
: UI¡): (
Boﬁ
, 
TLBundÀB
) =

660 
	`Put
(
‰omAddªss
, 
toSour˚
, 
lgSize
, 
d©a
, 
mask
, 
	`Boﬁ
(
Ál£
))

662 
def
 
	`Put
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
mask
: UI¡, 
c‹ru±
: 
Boﬁ
): (Boﬁ, 
TLBundÀB
) = {

663 
	`ªquúe
 (
˛õ¡
.
™ySuµ‹tPutP¨tül
)

664 
vÆ
 
ÀgÆ
 = 
˛õ¡
.
	`suµ‹tsPutP¨tül
(
toSour˚
, 
lgSize
)

665 
vÆ
 
b
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
bundÀ
))

666 
b
.
›code
 :
TLMesßges
.
PutP¨tülD©a


667 
b
.
∑øm
 :
	`UI¡
(0)

668 
b
.
size
 :
lgSize


669 
b
.
sour˚
 :
toSour˚


670 
b
.
addªss
 :
‰omAddªss


671 
b
.
mask
 := mask

672 
b
.
d©a
 := data

673 
b
.
c‹ru±
 := corrupt

674 (
ÀgÆ
, 
b
)

677 
def
 
	`Arôhmëic
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
©omic
: UI¡, 
c‹ru±
: 
Boﬁ
 = 
	`Boﬁ
(
Ál£
)) = {

678 
	`ªquúe
 (
˛õ¡
.
™ySuµ‹tArôhmëic
)

679 
vÆ
 
ÀgÆ
 = 
˛õ¡
.
	`suµ‹tsArôhmëic
(
toSour˚
, 
lgSize
)

680 
vÆ
 
b
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
bundÀ
))

681 
b
.
›code
 :
TLMesßges
.
ArôhmëicD©a


682 
b
.
∑øm
 :
©omic


683 
b
.
size
 :
lgSize


684 
b
.
sour˚
 :
toSour˚


685 
b
.
addªss
 :
‰omAddªss


686 
b
.
mask
 :
	`mask
(
‰omAddªss
, 
lgSize
)

687 
b
.
d©a
 := data

688 
b
.
c‹ru±
 := corrupt

689 (
ÀgÆ
, 
b
)

692 
def
 
	`Logiˇl
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
d©a
: UI¡, 
©omic
: UI¡, 
c‹ru±
: 
Boﬁ
 = 
	`Boﬁ
(
Ál£
)) = {

693 
	`ªquúe
 (
˛õ¡
.
™ySuµ‹tLogiˇl
)

694 
vÆ
 
ÀgÆ
 = 
˛õ¡
.
	`suµ‹tsLogiˇl
(
toSour˚
, 
lgSize
)

695 
vÆ
 
b
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
bundÀ
))

696 
b
.
›code
 :
TLMesßges
.
LogiˇlD©a


697 
b
.
∑øm
 :
©omic


698 
b
.
size
 :
lgSize


699 
b
.
sour˚
 :
toSour˚


700 
b
.
addªss
 :
‰omAddªss


701 
b
.
mask
 :
	`mask
(
‰omAddªss
, 
lgSize
)

702 
b
.
d©a
 := data

703 
b
.
c‹ru±
 := corrupt

704 (
ÀgÆ
, 
b
)

707 
def
 
	`Höt
(
‰omAddªss
: 
UI¡
, 
toSour˚
: UI¡, 
lgSize
: UI¡, 
∑øm
: UInt) = {

708 
	`ªquúe
 (
˛õ¡
.
™ySuµ‹tHöt
)

709 
vÆ
 
ÀgÆ
 = 
˛õ¡
.
	`suµ‹tsHöt
(
toSour˚
, 
lgSize
)

710 
vÆ
 
b
 = 
	`Wúe
(
√w
 
	`TLBundÀB
(
bundÀ
))

711 
b
.
›code
 :
TLMesßges
.
Höt


712 
b
.
∑øm
 :=Öaram

713 
b
.
size
 :
lgSize


714 
b
.
sour˚
 :
toSour˚


715 
b
.
addªss
 :
‰omAddªss


716 
b
.
mask
 :
	`mask
(
‰omAddªss
, 
lgSize
)

717 
b
.
d©a
 :
	`UI¡
(0)

718 
b
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

719 (
ÀgÆ
, 
b
)

722 
def
 
	`Ac˚ssAck
(
a
: 
TLBundÀA
): 
TLBundÀD
 = Ac˚ssAck◊.
sour˚
,á.
size
)

723 
def
 
	`Ac˚ssAck
(
a
: 
TLBundÀA
, 
díõd
: 
Boﬁ
): 
TLBundÀD
 = Ac˚ssAck◊.
sour˚
,á.
size
, denied)

724 
def
 
	`Ac˚ssAck
(
toSour˚
: 
UI¡
, 
lgSize
: UI¡): 
TLBundÀD
 = Ac˚ssAck—oSour˚,ÜgSize, 
	`Boﬁ
(
Ál£
))

725 
def
 
	`Ac˚ssAck
(
toSour˚
: 
UI¡
, 
lgSize
: UI¡, 
díõd
: 
Boﬁ
) = {

726 
vÆ
 
d
 = 
	`Wúe
(
√w
 
	`TLBundÀD
(
bundÀ
))

727 
d
.
›code
 :
TLMesßges
.
Ac˚ssAck


728 
d
.
∑øm
 :
	`UI¡
(0)

729 
d
.
size
 :
lgSize


730 
d
.
sour˚
 :
toSour˚


731 
d
.
sök
 :
	`UI¡
(0)

732 
d
.
díõd
 := denied

733 
d
.
d©a
 :
	`UI¡
(0)

734 
d
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

735 
d


738 
def
 
	`Ac˚ssAck
(
a
: 
TLBundÀA
, 
d©a
: 
UI¡
): 
TLBundÀD
 = Ac˚ssAck◊.
sour˚
,á.
size
, data)

739 
def
 
	`Ac˚ssAck
(
a
: 
TLBundÀA
, 
d©a
: 
UI¡
, 
díõd
: 
Boﬁ
, 
c‹ru±
: Boﬁ): 
TLBundÀD
 = Ac˚ssAck◊.
sour˚
,á.
size
, data, denied, corrupt)

740 
def
 
	`Ac˚ssAck
(
toSour˚
: 
UI¡
, 
lgSize
: UI¡, 
d©a
: UI¡): 
TLBundÀD
 = Ac˚ssAck—oSour˚,ÜgSize, d©a, 
	`Boﬁ
(
Ál£
), Bool(false))

741 
def
 
	`Ac˚ssAck
(
toSour˚
: 
UI¡
, 
lgSize
: UI¡, 
d©a
: UI¡, 
díõd
: 
Boﬁ
, 
c‹ru±
: Bool) = {

742 
vÆ
 
d
 = 
	`Wúe
(
√w
 
	`TLBundÀD
(
bundÀ
))

743 
d
.
›code
 :
TLMesßges
.
Ac˚ssAckD©a


744 
d
.
∑øm
 :
	`UI¡
(0)

745 
d
.
size
 :
lgSize


746 
d
.
sour˚
 :
toSour˚


747 
d
.
sök
 :
	`UI¡
(0)

748 
d
.
díõd
 := denied

749 
d
.
d©a
 := data

750 
d
.
c‹ru±
 := corrupt

751 
d


754 
def
 
	`HötAck
(
a
: 
TLBundÀA
): 
TLBundÀD
 = HötAck◊, 
	`Boﬁ
(
Ál£
))

755 
def
 
	`HötAck
(
a
: 
TLBundÀA
, 
díõd
: 
Boﬁ
): 
TLBundÀD
 = HötAck◊.
sour˚
,á.
size
, denied)

756 
def
 
	`HötAck
(
toSour˚
: 
UI¡
, 
lgSize
: UI¡): 
TLBundÀD
 = HötAck—oSour˚,ÜgSize, 
	`Boﬁ
(
Ál£
))

757 
def
 
	`HötAck
(
toSour˚
: 
UI¡
, 
lgSize
: UI¡, 
díõd
: 
Boﬁ
) = {

758 
vÆ
 
d
 = 
	`Wúe
(
√w
 
	`TLBundÀD
(
bundÀ
))

759 
d
.
›code
 :
TLMesßges
.
HötAck


760 
d
.
∑øm
 :
	`UI¡
(0)

761 
d
.
size
 :
lgSize


762 
d
.
sour˚
 :
toSour˚


763 
d
.
sök
 :
	`UI¡
(0)

764 
d
.
díõd
 := denied

765 
d
.
d©a
 :
	`UI¡
(0)

766 
d
.
c‹ru±
 :
	`Boﬁ
(
Ál£
)

767 
d


769 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ErrorEvaluator.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
˛ass
 
Reque°P©ã∫
(
ã°
: 
TLBundÀA
 => 
Boﬁ
)

13 
def
 
≠∂y
(
a
: 
TLBundÀA
Ë
ã°
(a)

16 
obje˘
 
Reque°P©ã∫


19 
def
 
ovîœps
(
∑âîn
: 
Seq
[
AddªssSë
])(
a
: 
TLBundÀA
) = {

20 
vÆ
 
amask
 = 
UI¡ToOH1
(
a
.
size
,á.
∑øms
.
addªssBôs
)

21 
vÆ
 
	gaba£
 = 
a
.
addªss


22 
∑âîn
.
m≠
 { 
p
 =>

23 
vÆ
 
pba£
 = 
UI¡
(
p
.
ba£
)

24 
vÆ
 
pmask
 = 
UI¡
(
p
.
mask
 & ((
BigI¡
(1Ë<< 
a
.
∑øms
.
addªssBôs
) - 1))

25 (
amask
 | 
pmask
 | ~(
aba£
 ^ 
pba£
)).
™dR


26 }.
ªdu˚
(
_
 || _)

29 
im∂icô
 
def
 
≠∂y
(
∑âîn
: 
Seq
[
AddªssSë
]): 
Reque°P©ã∫
 = 
√w
 Reque°P©ã∫(
ovîœps
’©ã∫Ë
_
)

37 
˛ass
 
	$TLEº‹EvÆu©‹
(
ã°
: 
Reque°P©ã∫
, 
ã°On
: 
Boﬁón
, 
ã°Off
: Boﬁón, 
díy
: Boﬁó¿
Ál£
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


39 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(
m™agîFn
 = { 
mp
 => mp.
	`c›y
(
m™agîs
 =

40 
mp
.
m™agîs
.
m≠
 { 
m
 => m.
	`c›y
(
mayDíyPut
 = 
åue
, 
mayDíyGë
 = 
díy
 || m.mayDenyGet) }) })

42 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

43 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

44 
out
 <> 
ö


47 
vÆ
 
öje˘_m≠
 = 
	`Mem
(
edgeIn
.
˛õ¡
.
ídSour˚Id
, 
	`Boﬁ
())

48 
vÆ
 
öje˘_now
 = 
	`ã°
(
ö
.
a
.
bôs
)

50 
	`vÆ
 (
d_fú°
, 
d_œ°
, 
_
Ë
edgeOut
.
	`fú°œ°
(
out
.
d
)

51 
vÆ
 
d_hasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
bôs
)

53 
	`whí
 (
ö
.
a
.
	`fúe
()Ë{ 
öje˘_m≠
.
	`wrôe
(ö.a.
bôs
.
sour˚
, 
öje˘_now
) }

55 
vÆ
 
by∑ss
 = 
	`Boﬁ
(
edgeOut
.
m™agî
.
möL©ícy
 =0Ë&& 
ö
.
a
.
	`fúe
(Ë&& in.a.
bôs
.
sour˚
 ==ö.
d
.bits.source

56 
vÆ
 
d_öje˘
 = 
	`Mux
(
by∑ss
, 
öje˘_now
, 
öje˘_m≠
.
	`ªad
(
ö
.
d
.
bôs
.
sour˚
)Ë
hﬁdU∆ess
 
d_fú°


57 
ö
.
d
.
bôs
.
c‹ru±
 :
out
.d.bôs.c‹ru± || (
d_öje˘
 && 
d_hasD©a
)

58 
ö
.
d
.
bôs
.
díõd
 :
out
.d.bôs.díõd || (
d_öje˘
 && (!
d_hasD©a
 || 
	`Boﬁ
(
díy
)))

60 
vÆ
 
r_dëe˘
 = 
	`Reg
(
	`Boﬁ
())

61 
vÆ
 
d_dëe˘
 = (!
d_fú°
 && 
r_dëe˘
Ë|| (
	`Boﬁ
(!
díy
Ë&& 
out
.
d
.
bôs
.
c‹ru±
Ë|| out.d.bôs.
díõd


62 
	`whí
 (
out
.
d
.
	`fúe
()Ë{ 
r_dëe˘
 :
d_dëe˘
 }

64 
vÆ
 
d_höt
 = 
out
.
d
.
bôs
.
›code
 ==
TLMesßges
.
HötAck


65 
	`as£π
 (
	`Boﬁ
(!
ã°On
Ë|| !
out
.
d
.
	`fúe
(Ë|| !
d_œ°
 || !
d_öje˘
 || 
d_dëe˘
 || 
d_höt
, "Denied/Corrupt flag wasÇot set!")

66 
	`as£π
 (
	`Boﬁ
(!
ã°Off
Ë|| !
out
.
d
.
	`fúe
(Ë|| !
d_œ°
 || 
d_öje˘
 || !
d_dëe˘
, "Denied/Corrupt flag was set!")

69 
	}
}

71 
obje˘
 
	gTLEº‹EvÆu©‹


73 
def
 
≠∂y
(
ã°
: 
Reque°P©ã∫
, 
ã°On
: 
Boﬁón
 = 
Ál£
, 
ã°Off
: Boﬁó¿Ál£, 
díy
: Boﬁó¿Ál£)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

75 
vÆ
 
îr‹s
 = 
LazyModuÀ
(
√w
 
TLEº‹EvÆu©‹
(
ã°
, 
ã°On
, 
ã°Off
, 
díy
))

76 
	gîr‹s
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Example.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


9 
˛ass
 
	$Exam∂eP¨ams
(
num
: 
I¡
, 
addªss
: 
BigI¡
)

11 
åaô
 
Exam∂eBundÀ


13 
vÆ
 
∑øms
: 
Exam∂eP¨ams


14 
vÆ
 
gpio
 = 
	`UI¡
(
width
 = 
∑øms
.
num
)

15 
	}
}

17 
åaô
 
Exam∂eModuÀ
 
exãnds
 
HasRegM≠


19 
vÆ
 
∑øms
: 
Exam∂eP¨ams


20 
vÆ
 
io
: 
Exam∂eBundÀ


21 
vÆ
 
öãºu±s
: 
Vec
[
Boﬁ
]

23 
vÆ
 
°©e
 = 
RegInô
(
UI¡
(0, 
width
 = 
∑øms
.
num
))

24 
vÆ
 
≥ndög
 = 
RegInô
(
UI¡
(0xf, 
width
 = 4))

26 
io
.
gpio
 :
°©e


27 
öãºu±s
 :
≥ndög
.
toBoﬁs


29 
ªgm≠
(

30 0 -> 
Seq
(

31 
RegFõld
(
∑øms
.
num
, 
°©e
,

32 
RegFõldDesc
("°©e", "Sèã: Exam∂êo‡®R/W Regi°î wôh des¸ùti⁄.", 
ª£t
 = 
Some
(0)))),

33 4 -> 
Seq
(

34 
RegFõld
.
w1ToCÀ¨
(4, 
≥ndög
, 
°©e
,

35 
Some
(
RegFõldDesc
("pending", "Pending: Example ofá special (W1ToC) Register. " +

38 
ª£t
=
Some
(0xF), vﬁ©ûe=
åue
))))

43 
˛ass
 
	$TLExam∂e
(
∑øms
: 
Exam∂eP¨ams
)(
im∂icô
 
p
: 
P¨amëîs
)

44 
exãnds
 
	`TLRegi°îRouãr
(
∑øms
.
addªss
, "somedev", 
	`Seq
("ucbbar,random-interface"), 4)(

45 
√w
 
	$TLRegBundÀ
(
∑øms
, 
_
Ë
wôh
 
Exam∂eBundÀ
)(

46 
√w
 
	$TLRegModuÀ
(
∑øms
, 
_
, _Ë
wôh
 
Exam∂eModuÀ
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/FIFOFixer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	g¥›îty
.
_


10 
imp‹t
 
	gsˇœ
.
	gm©h
.
max


12 
˛ass
 
	$TLFIFOFixî
(
pﬁicy
: 
TLFIFOFixî
.
Pﬁicy
 = TLFIFOFixî.
Æl
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
¥iv©e
 
def
 
	`fifoM≠
(
£q
: 
Seq
[
TLM™agîP¨amëîs
]) = {

15 
	`vÆ
 (
Ê©M™agîs
, 
kìpM™agîs
Ë
£q
.
	`∑πôi⁄
(
pﬁicy
)

18 
vÆ
 
Ê©Domaös
 = 
	`Së
(
Ê©M™agîs
.
	`Ê©M≠
(
_
.
fifoId
):_*)

19 
vÆ
 
kìpDomaös
 = 
	`Së
(
kìpM™agîs
.
	`Ê©M≠
(
_
.
fifoId
):_*Ë-- 
Ê©Domaös


21 
vÆ
 
Ê©M≠
 = 
Ê©Domaös
.
m≠
 { 
x
 => (x, 0Ë}.
toM≠


22 
vÆ
 
kìpM≠
 = 
kìpDomaös
.
	`sˇnLe·
((-1,0)Ë{ ((
_
,
s
),
x
Ë=> (x, s+1Ë}.
toM≠


23 
vÆ
 
m≠
 = 
Ê©M≠
 ++ 
kìpM≠


24 
vÆ
 
fixM≠
 = 
£q
.
m≠
 { 
m
 => m.
fifoId
 
m©ch
 {

25 
N⁄e
 => i‡(
	`pﬁicy
(
m
)Ë
	`Some
(0) None

26 
	`Some
(
id
Ë=> Some(
	`m≠
(id))

29 
vÆ
 
ªM≠
 = 
Ê©Domaös
.
	`sˇnLe·
((-1,-1)Ë{ ((
_
,
s
),
x
Ë=> (x, s+1Ë}.
toM≠


30 
vÆ
 
•œtM≠
 = 
£q
.
m≠
 { 
m
 => m.
fifoId
 
m©ch
 {

31 
N⁄e
 => None

32 
	`Some
(
id
Ë=> 
ªM≠
.
	`li·
(id)

34 (
fixM≠
, 
•œtM≠
)

37 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

38 
˛õ¡Fn
 = { 
˝
 => cp },

39 
m™agîFn
 = { 
mp
 =>

40 
	`vÆ
 (
fixM≠
, 
_
Ë
	`fifoM≠
(
mp
.
m™agîs
)

41 
mp
.
	`c›y
(
m™agîs
 = (
fixM≠
 
zù
 mp.m™agîsË
m≠
 { (
id
, 
m
Ë=> m.c›y(
fifoId
 = id) })

44 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

45 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

46 
	`vÆ
 (
fixM≠
, 
•œtM≠
Ë
	`fifoM≠
(
edgeOut
.
m™agî
.
m™agîs
)

49 
vÆ
 
a_nŸFIFO
 = 
edgeIn
.
m™agî
.
	`Á°Pr›îty
(
ö
.
a
.
bôs
.
addªss
, 
_
.
fifoId
 !
	`Some
(0), (
b
:
Boﬁón
Ë=> 
	`Boﬁ
(b))

51 
vÆ
 
com∑˘ed
 = ((
fixM≠
 
zù
 
•œtM≠
Ëzù 
edgeOut
.
m™agî
.
m™agîs
Ë
Ê©M≠
 {

52 ((
f
, 
s
), 
m
Ë=> i‡(‡=
	`Some
(0)ËSome(m.
	`c›y
(
fifoId
 = s)Ë
N⁄e


54 
vÆ
 
söks
 = i‡(
com∑˘ed
.
	`exi°s
(
_
.
suµ‹tsAcquúeB
)Ë
edgeOut
.
m™agî
.
ídSökId
 0

55 
vÆ
 
a_id
 = i‡(
com∑˘ed
.
isEm±y
Ë
	`UI¡
(0) 

56 
edgeOut
.
m™agî
.
	`c›y
(
m™agîs
 = 
com∑˘ed
, 
ídSökId
 = 
söks
).
	`födFifoIdFa°
(
ö
.
a
.
bôs
.
addªss
)

57 
vÆ
 
a_noDomaö
 = 
a_id
 ==
	`UI¡
(0)

59 i‡(
Ál£
) {

60 
	`¥öén
(
s
"FIFOFixer for: ${edgeIn.client.clients.map(_.name).mkString(", ")}")

61 
	`¥öén
(
s
"make FIFO: ${edgeIn.manager.managers.filter(_.fifoId==Some(0)).map(_.name).mkString(", ")}")

62 
	`¥öén
(
s
"not FIFO: ${edgeIn.manager.managers.filter(_.fifoId!=Some(0)).map(_.name).mkString(", ")}")

63 
	`¥öén
(
s
"domains: ${compacted.groupBy(_.name).mapValues(_.map(_.fifoId))}")

64 
	`¥öén
("")

68 
vÆ
 
a_fú°
 = 
edgeIn
.
	`fú°
(
ö
.
a
)

69 
vÆ
 
d_fú°
 = 
edgeOut
.
	`fú°
(
out
.
d
Ë&& out.d.
bôs
.
›code
 =/
TLMesßges
.
Rñó£Ack


73 
vÆ
 
Êight
 = 
	`RegInô
(
Vec
.
	`fûl
(
edgeIn
.
˛õ¡
.
ídSour˚Id
Ë{ 
	`Boﬁ
(
Ál£
) })

74 
	`whí
 (
a_fú°
 && 
ö
.
a
.
	`fúe
()Ë{ 
	`Êight
(ö.a.
bôs
.
sour˚
Ë:!
a_nŸFIFO
 }

75 
	`whí
 (
d_fú°
 && 
ö
.
d
.
	`fúe
()Ë{ 
	`Êight
(ö.d.
bôs
.
sour˚
Ë:
	`Boﬁ
(
Ál£
) }

77 
vÆ
 
°Æls
 = 
edgeIn
.
˛õ¡
.
˛õ¡s
.
	`fûãr
(
c
 => c.
ªque°Fifo
 && c.
sour˚Id
.
size
 > 1).
m≠
 { c =>

78 
vÆ
 
a_£l
 = 
c
.
sour˚Id
.
	`c⁄èös
(
ö
.
a
.
bôs
.
sour˚
)

79 
vÆ
 
id
 = 
	`RegE«bÀ
(
a_id
, 
ö
.
a
.
	`fúe
(Ë&& 
a_£l
 && !
a_nŸFIFO
)

80 
vÆ
 
åack
 = 
Êight
.
	`¶i˚
(
c
.
sour˚Id
.
°¨t
, c.sour˚Id.
íd
)

82 
a_£l
 && 
a_fú°
 && 
åack
.
	`ªdu˚
(
_
 || _Ë&& (
a_noDomaö
 || 
id
 =/
a_id
)

85 
vÆ
 
°Æl
 = 
°Æls
.
	`fﬁdLe·
(
	`Boﬁ
(
Ál£
))(
_
||_)

87 
out
.
a
 <> 
ö
.a

88 
ö
.
d
 <> 
out
.d

89 
out
.
a
.
vÆid
 :
ö
.a.vÆid && (
a_nŸFIFO
 || !
°Æl
)

90 
ö
.
a
.
ªady
 :
out
.a.ªady && (
a_nŸFIFO
 || !
°Æl
)

92 i‡(
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeOut.
˛õ¡
.
™ySuµ‹tProbe
) {

93 
ö
 .
b
 <> 
out
.b

94 
out
.
c
 <> 
ö
 .c

95 
out
.
e
 <> 
ö
 .e

97 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

98 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

99 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

100 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

101 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

102 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

107 
	`covî
(
ö
.
a
.
vÆid
 && 
°Æl
, "COVER FIFOFIXER STALL", "Cover: Stall occured forá validÅransaction")

109 
vÆ
 
Sour˚IdFIFOed
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
edgeIn
.
˛õ¡
.
ídSour˚Id
))

110 
vÆ
 
Sour˚IdSë
 = 
	`Wúe
(
öô
 = 
	`UI¡
(0, 
width
 = 
edgeIn
.
˛õ¡
.
ídSour˚Id
))

111 
vÆ
 
Sour˚IdCÀ¨
 = 
	`Wúe
(
öô
 = 
	`UI¡
(0, 
width
 = 
edgeIn
.
˛õ¡
.
ídSour˚Id
))

113 
	`whí
 (
a_fú°
 && 
ö
.
a
.
	`fúe
(Ë&& !
a_nŸFIFO
) {

114 
Sour˚IdSë
 :
	`UI¡ToOH
(
ö
.
a
.
bôs
.
sour˚
)

116 
	`whí
 (
d_fú°
 && 
ö
.
d
.
	`fúe
()) {

117 
Sour˚IdCÀ¨
 :
	`UI¡ToOH
(
ö
.
d
.
bôs
.
sour˚
)

120 
Sour˚IdFIFOed
 :Sour˚IdFIFOed | 
Sour˚IdSë


121 
vÆ
 
ÆlIDs_FIFOed
 = 
Sour˚IdFIFOed
===
	`Fûl
(Sour˚IdFIFOed.
gëWidth
, 1.U)

123 
	`covî
(
ÆlIDs_FIFOed
, "COVERáll sources", "Cover: FIFOFIXER coversáll Source IDs")

125 
	`covî
(!(
Êight
.
	`ªdu˚
(
_
 || _)), "COVERÉmpty", "Cover: FIFO isÉmpty")

126 
	`covî
(
Sour˚IdSë
 > 0.U, "COVERátÜeast oneÖush", "Cover: AtÜeast one Source ID isÖushed")

127 
	`covî
(
Sour˚IdCÀ¨
 > 0.U, "COVERátÜeast oneÖop", "Cover: AtÜeast one Source ID isÖopped")

131 
	}
}

133 
obje˘
 
	gTLFIFOFixî


137 
ty≥
 
	gPﬁicy
 = 
TLM™agîP¨amëîs
 => 
Boﬁón


138 
imp‹t
 
Regi⁄Ty≥
.
_


140 
vÆ
 
Æl
: 
Pﬁicy
 = 
m
 => 
åue


141 
vÆ
 
ÆlFIFO
: 
Pﬁicy
 = 
m
 => m.
fifoId
.
isDeföed


142 
vÆ
 
ÆlUnˇchóbÀ
: 
Pﬁicy
 = 
m
 => m.
ªgi⁄Ty≥
 <
UNCACHEABLE


144 
def
 
≠∂y
(
pﬁicy
: 
Pﬁicy
 = 
Æl
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

146 
vÆ
 
fixî
 = 
LazyModuÀ
(
√w
 
TLFIFOFixî
(
pﬁicy
))

147 
fixî
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Filter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

10 
˛ass
 
	$TLFûãr
(

11 
mfûãr
: 
TLFûãr
.
M™agîFûãr
 = TLFûãr.
mIdítôy
,

12 
cfûãr
: 
TLFûãr
.
Clõ¡Fûãr
 = TLFûãr.
cIdítôy


13 )(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


15 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

16 
˛õ¡Fn
 = { 
˝
 => cp.
	`c›y
(
˛õ¡s
 = cp.˛õ¡s.
Ê©M≠
 { 
c
 =>

17 
vÆ
 
out
 = 
	`cfûãr
(
c
)

18 
out
.
m≠
 { 
o
 =>

19 
	`ªquúe
 (
c
.
sour˚Id
.
	`c⁄èös
(
o
.sourceId))

20 
	`ªquúe
 (
c
.
suµ‹tsProbe
.
	`c⁄èös
(
o
.supportsProbe))

21 
	`ªquúe
 (
c
.
suµ‹tsArôhmëic
.
	`c⁄èös
(
o
.supportsArithmetic))

22 
	`ªquúe
 (
c
.
suµ‹tsLogiˇl
.
	`c⁄èös
(
o
.supportsLogical))

23 
	`ªquúe
 (
c
.
suµ‹tsGë
.
	`c⁄èös
(
o
.supportsGet))

24 
	`ªquúe
 (
c
.
suµ‹tsPutFuŒ
.
	`c⁄èös
(
o
.supportsPutFull))

25 
	`ªquúe
 (
c
.
suµ‹tsPutP¨tül
.
	`c⁄èös
(
o
.supportsPutPartial))

26 
	`ªquúe
 (
c
.
suµ‹tsHöt
.
	`c⁄èös
(
o
.supportsHint))

27 
	`ªquúe
 (!
c
.
ªque°Fifo
 || 
o
.requestFifo)

29 
out


31 
m™agîFn
 = { 
mp
 =>

32 
vÆ
 
m™agîs
 = 
mp
.m™agîs.
Ê©M≠
 { 
m
 =>

33 
vÆ
 
out
 = 
	`mfûãr
(
m
)

34 
out
.
m≠
 { 
o
 =>

35 
o
.
addªss
.
f‹óch
 { 
a
 => 
	`ªquúe
 (
m
.addªss.
	`m≠
(
_
.
	`c⁄èös
◊)).
	`ªdu˚
(_||_)) }

36 
	`ªquúe
 (
o
.
ªgi⁄Ty≥
 <
m
.regionType)

38 
	`ªquúe
 (
m
.
suµ‹tsAcquúeT
.
	`c⁄èös
(
o
.supportsAcquireT))

39 
	`ªquúe
 (
m
.
suµ‹tsAcquúeB
.
	`c⁄èös
(
o
.supportsAcquireB))

40 
	`ªquúe
 (
m
.
suµ‹tsArôhmëic
.
	`c⁄èös
(
o
.supportsArithmetic))

41 
	`ªquúe
 (
m
.
suµ‹tsLogiˇl
.
	`c⁄èös
(
o
.supportsLogical))

42 
	`ªquúe
 (
m
.
suµ‹tsGë
.
	`c⁄èös
(
o
.supportsGet))

43 
	`ªquúe
 (
m
.
suµ‹tsPutFuŒ
.
	`c⁄èös
(
o
.supportsPutFull))

44 
	`ªquúe
 (
m
.
suµ‹tsPutP¨tül
.
	`c⁄èös
(
o
.supportsPutPartial))

45 
	`ªquúe
 (
m
.
suµ‹tsHöt
.
	`c⁄èös
(
o
.supportsHint))

46 
	`ªquúe
 (!
o
.
fifoId
.
isDeföed
 || 
m
.fifoId == o.fifoId)

48 
out


50 
mp
.
	`c›y
(
m™agîs
 = managers,

51 
ídSökId
 = i‡(
m™agîs
.
	`exi°s
(
_
.
suµ‹tsAcquúeB
)Ë
mp
.endSinkId 0)

54 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

55 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

56 
out
 <> 
ö


59 i‡(!
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
) {

60 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

61 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

62 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

63 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

64 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

65 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

69 
	}
}

71 
obje˘
 
TLFûãr


73 
ty≥
 
M™agîFûãr
 = 
TLM™agîP¨amëîs
 => 
O±i⁄
[TLManagerParameters]

74 
ty≥
 
Clõ¡Fûãr
 = 
TLClõ¡P¨amëîs
 => 
O±i⁄
[TLClientParameters]

77 
def
 
mIdítôy
: 
M™agîFûãr
 = { 
m
 => 
Some
(m) }

79 
def
 
cIdítôy
: 
Clõ¡Fûãr
 = { 
c
 => 
Some
(c) }

81 
def
 
mSñe˘I¡î£˘
(
£À˘
: 
AddªssSë
): 
M™agîFûãr
 = { 
m
 =>

82 
vÆ
 
fûãªd
 = 
m
.
addªss
.
m≠
(
_
.
öãr£˘
(
£À˘
)).
Ê©ãn


83 
vÆ
 
Æignmít
 = 
£À˘
.alignment

84 
vÆ
 
maxTøns„r
 = 1 << 30

85 
vÆ
 
ˇpTøns„r
 = i‡(
Æignmít
 =0 ||álignmíà> 
maxTøns„r
ËmaxTøns„∏Æignmít.
toI¡


86 
vÆ
 
ˇp
 = 
Tøns„rSizes
(1, 
ˇpTøns„r
)

87 i‡(
	gfûãªd
.
	gisEm±y
Ë{ 
	gN⁄e
 } {

88 
Some
(
m
.
c›y
(

89 
addªss
 = 
fûãªd
,

90 
suµ‹tsAcquúeT
 = 
m
.suµ‹tsAcquúeT .
öãr£˘
(
ˇp
),

91 
suµ‹tsAcquúeB
 = 
m
.suµ‹tsAcquúeB .
öãr£˘
(
ˇp
),

92 
suµ‹tsArôhmëic
 = 
m
.suµ‹tsArôhmëic.
öãr£˘
(
ˇp
),

93 
suµ‹tsLogiˇl
 = 
m
.suµ‹tsLogiˇ».
öãr£˘
(
ˇp
),

94 
suµ‹tsGë
 = 
m
.suµ‹tsGë .
öãr£˘
(
ˇp
),

95 
suµ‹tsPutFuŒ
 = 
m
.suµ‹tsPutFuŒ .
öãr£˘
(
ˇp
),

96 
suµ‹tsPutP¨tül
 = 
m
.suµ‹tsPutP¨tül.
öãr£˘
(
ˇp
),

97 
suµ‹tsHöt
 = 
m
.suµ‹tsHöà.
öãr£˘
(
ˇp
)))

101 
def
 
mHideC⁄èöed
(
c⁄èöedBy
: 
AddªssSë
): 
M™agîFûãr
 = { 
m
 =>

102 
vÆ
 
fûãªd
 = 
m
.
addªss
.
fûãrNŸ
(
c⁄èöedBy
.
c⁄èös
(
_
))

103 i‡(
fûãªd
.
isEm±y
Ë
N⁄e
 
Some
(
m
.
c›y
(
addªss
 = filtered))

106 
def
 
mHideCachóbÀ
: 
M™agîFûãr
 = { 
m
 =>

107 i‡(
m
.
suµ‹tsAcquúeB
Ë
N⁄e
 
Some
(m)

110 
def
 
mSñe˘CachóbÀ
: 
M™agîFûãr
 = { 
m
 =>

111 i‡(
m
.
suµ‹tsAcquúeB
Ë
Some
(mË
N⁄e


114 
def
 
mMaskCachóbÀ
: 
M™agîFûãr
 = { 
m
 =>

115 i‡(
m
.
suµ‹tsAcquúeB
) {

116 
Some
(
m
.
c›y
(

117 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

118 
suµ‹tsAcquúeB
 = 
Tøns„rSizes
.
n⁄e
,

119 
suµ‹tsAcquúeT
 = 
Tøns„rSizes
.
n⁄e
,

120 
ÆwaysGø¡sT
 = 
Ál£
))

121 } { 
Some
(
m
) }

124 
def
 
	gmSñe˘AndMaskCachóbÀ
: 
M™agîFûãr
 = { 
m
 =>

125 i‡(
m
.
suµ‹tsAcquúeB
) {

126 
Some
(
m
.
c›y
(

127 
ªgi⁄Ty≥
 = 
Regi⁄Ty≥
.
UNCACHED
,

128 
suµ‹tsAcquúeB
 = 
Tøns„rSizes
.
n⁄e
,

129 
suµ‹tsAcquúeT
 = 
Tøns„rSizes
.
n⁄e
,

130 
ÆwaysGø¡sT
 = 
Ál£
))

131 } { 
	gN⁄e
 }

134 
def
 
	gcHideCachög
: 
Clõ¡Fûãr
 = { 
c
 =>

135 i‡(
c
.
suµ‹tsProbe
Ë
N⁄e
 
Some
(c)

138 
def
 
cSñe˘Cachög
: 
Clõ¡Fûãr
 = { 
c
 =>

139 i‡(
c
.
suµ‹tsProbe
Ë
Some
(cË
N⁄e


143 
def
 
≠∂y
(

144 
mfûãr
: 
M™agîFûãr
 = 
TLFûãr
.
mIdítôy
,

145 
cfûãr
: 
Clõ¡Fûãr
 = 
TLFûãr
.
cIdítôy


146 )(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

148 
vÆ
 
fûãr
 = 
LazyModuÀ
(
√w
 
TLFûãr
(
mfûãr
, 
cfûãr
))

149 
	gfûãr
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fragmenter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

11 
obje˘
 
	gE¨lyAck
 {

12 
£Æed
 
åaô
 
T


13 
obje˘
 
AŒPuts
 
exãnds
 
T


14 
obje˘
 
PutFuŒs
 
exãnds
 
T


15 
obje˘
 
N⁄e
 
exãnds
 
	gT


26 
˛ass
 
	$TLFøgmíãr
(
vÆ
 
möSize
: 
I¡
, vÆ 
maxSize
: I¡, vÆ 
ÆwaysMö
: 
Boﬁón
 = 
Ál£
, vÆ 
óæyAck
: 
E¨lyAck
.
T
 = E¨lyAck.
N⁄e
, vÆ 
hﬁdFú°Díy
: Boﬁó¿Ál£)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


28 
	`ªquúe
(
	`isPow2
 (
maxSize
), 
s
"TLFragmenterÉxpectsÖow2(maxSize), but got $maxSize")

29 
	`ªquúe
(
	`isPow2
 (
möSize
), 
s
"TLFragmenterÉxpectsÖow2(minSize), but got $minSize")

30 
	`ªquúe
(
möSize
 < 
maxSize
, 
s
"TLFragmenterÉxpects min < max, but got $minSize >= $maxSize")

32 
vÆ
 
‰agmítBôs
 = 
	`log2Ceû
(
maxSize
 / 
möSize
)

33 
vÆ
 
fuŒBôs
 = i‡(
óæyAck
 =
E¨lyAck
.
PutFuŒs
) 1 0

34 
vÆ
 
toggÀBôs
 = 1

35 
vÆ
 
addedBôs
 = 
‰agmítBôs
 + 
toggÀBôs
 + 
fuŒBôs


37 
def
 
	`ex∑ndTøns„r
(
x
: 
Tøns„rSizes
, 
›
: 
Såög
) = if (!x) x {

39 
	`ªquúe
 (
x
.
max
 >
möSize
, 
s
"TLFragmenter (withÖarent $parent) maxÅransfer size $op(${x.max}) must be >= minÅransfer size (${minSize})")

40 
	`Tøns„rSizes
(
x
.
mö
, 
maxSize
)

42 
def
 
	`shrökTøns„r
(
x
: 
Tøns„rSizes
) =

43 i‡(!
ÆwaysMö
Ë
x
 

44 i‡(
x
.
mö
 <
möSize
Ë
	`Tøns„rSizes
(x.mö, 
	`mö
(möSize, x.
max
)) 

45 
Tøns„rSizes
.
n⁄e


46 
def
 
	`m≠M™agî
(
m
: 
TLM™agîP¨amëîs
Ëm.
	`c›y
(

47 
suµ‹tsArôhmëic
 = 
	`shrökTøns„r
(
m
.supportsArithmetic),

48 
suµ‹tsLogiˇl
 = 
	`shrökTøns„r
(
m
.supportsLogical),

49 
suµ‹tsGë
 = 
	`ex∑ndTøns„r
(
m
.supportsGet, "Get"),

50 
suµ‹tsPutFuŒ
 = 
	`ex∑ndTøns„r
(
m
.supportsPutFull, "PutFull"),

51 
suµ‹tsPutP¨tül
 = 
	`ex∑ndTøns„r
(
m
.supportsPutPartial, "PutParital"),

52 
suµ‹tsHöt
 = 
	`ex∑ndTøns„r
(
m
.supportsHint, "Hint"))

54 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

57 
˛õ¡Fn
 = { 
c
 => c.
	`c›y
(
˛õ¡s
 = 
	`Seq
(
	`TLClõ¡P¨amëîs
(

58 
«me
 = "TLFragmenter",

59 
sour˚Id
 = 
	`IdR™ge
(0, 
c
.
ídSour˚Id
 << 
addedBôs
),

60 
ªque°Fifo
 = 
åue
))) },

61 
m™agîFn
 = { 
m
 => m.
	`c›y
(
m™agîs
 = m.m™agîs.
	`m≠
(
m≠M™agî
)) })

63 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

64 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

66 
vÆ
 
m™agî
 = 
edgeOut
.manager

67 
vÆ
 
m™agîs
 = 
m™agî
.managers

68 
vÆ
 
bótByãs
 = 
m™agî
.beatBytes

69 
vÆ
 
fifoId
 = 
	`m™agîs
(0).fifoId

70 
	`ªquúe
 (
fifoId
.
isDeföed
 && 
m™agîs
.
	`m≠
(
_
.fifoId =fifoId).
	`ªdu˚
(_ && _))

71 
	`ªquúe
 (!
m™agî
.
™ySuµ‹tAcquúeB
)

73 
	`ªquúe
 (
möSize
 >
bótByãs
, 
s
"TLFragmenter (withÖarent $parent) can't support fragmenting ($minSize)Åo sub-beat ($beatBytes)áccesses")

75 
	`ªquúe
 (!
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 || !
edgeIn
.
˛õ¡
.
™ySuµ‹tProbe
)

77 
	`ªquúe
 (!
edgeOut
.
m™agî
.
mayDíyGë
 || 
hﬁdFú°Díy
, 
s
"TLFragmenter (withÖarent $parent) can't support denials without holdFirstDeny=true")

78 
	`ªquúe
 (!
edgeOut
.
m™agî
.
mayDíyPut
 || 
óæyAck
 =
E¨lyAck
.
N⁄e
)

145 
vÆ
 
cou¡îBôs
 = 
	`log2Up
(
maxSize
/
bótByãs
)

146 
vÆ
 
maxDownSize
 = i‡(
ÆwaysMö
Ë
möSize
 
	`mö
(
m™agî
.
maxTøns„r
, 
maxSize
)

167 
vÆ
 
acknum
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
cou¡îBôs
))

168 
vÆ
 
dOrig
 = 
	`Reg
(
	`UI¡
())

169 
vÆ
 
dToggÀ
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

170 
vÆ
 
dFøgnum
 = 
out
.
d
.
bôs
.
	`sour˚
(
‰agmítBôs
-1, 0)

171 
vÆ
 
dFú°
 = 
acknum
 ==
	`UI¡
(0)

172 
vÆ
 
dLa°
 = 
dFøgnum
 ==
	`UI¡
(0)

173 
vÆ
 
dsizeOH
 = 
	`UI¡ToOH
 (
out
.
d
.
bôs
.
size
, 
	`log2Ceû
(
maxDownSize
)+1)

174 
vÆ
 
dsizeOH1
 = 
	`UI¡ToOH1
(
out
.
d
.
bôs
.
size
, 
	`log2Up
(
maxDownSize
))

175 
vÆ
 
dHasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
bôs
)

178 
vÆ
 
acknum_‰agmít
 = 
dFøgnum
 << 
	`log2Ceû
(
möSize
/
bótByãs
)

179 
vÆ
 
acknum_size
 = 
dsizeOH1
 >> 
	`log2Ceû
(
bótByãs
)

180 
	`as£π
 (!
out
.
d
.
vÆid
 || (
acknum_‰agmít
 & 
acknum_size
Ë==
	`UI¡
(0))

181 
vÆ
 
dFú°_acknum
 = 
acknum_‰agmít
 | 
	`Mux
(
dHasD©a
, 
acknum_size
, 
	`UI¡
(0))

182 
vÆ
 
ack_de¸emít
 = 
	`Mux
(
dHasD©a
, 
	`UI¡
(1), 
dsizeOH
 >> 
	`log2Ceû
(
bótByãs
))

184 
vÆ
 
dFú°_size
 = 
	`OH1ToUI¡
((
dFøgnum
 << 
	`log2Ceû
(
möSize
)Ë| 
dsizeOH1
)

186 
	`whí
 (
out
.
d
.
	`fúe
()) {

187 
acknum
 :
	`Mux
(
dFú°
, 
dFú°_acknum
,ácknum - 
ack_de¸emít
)

188 
	`whí
 (
dFú°
) {

189 
dOrig
 :
dFú°_size


190 
dToggÀ
 :
out
.
d
.
bôs
.
	`sour˚
(
‰agmítBôs
)

195 
vÆ
 
doE¨lyAck
 = 
óæyAck
 
m©ch
 {

196 
E¨lyAck
.
AŒPuts
 => 
	`Boﬁ
(
åue
)

197 
E¨lyAck
.
PutFuŒs
 => 
out
.
d
.
bôs
.
	`sour˚
(
‰agmítBôs
+1)

198 
E¨lyAck
.
N⁄e
 => 
	`Boﬁ
(
Ál£
)

200 
vÆ
 
dr›
 = !
dHasD©a
 && !
	`Mux
(
doE¨lyAck
, 
dFú°
, 
dLa°
)

201 
out
.
d
.
ªady
 :
ö
.d.ªady || 
dr›


202 
ö
.
d
.
vÆid
 :
out
.d.vÆid && !
dr›


203 
ö
.
d
.
bôs
 :
out
.d.bits

204 
ö
.
d
.
bôs
.
sour˚
 :
out
.d.bôs.sour˚ >> 
addedBôs


205 
ö
.
d
.
bôs
.
size
 :
	`Mux
(
dFú°
, 
dFú°_size
, 
dOrig
)

207 i‡(
edgeOut
.
m™agî
.
mayDíyPut
) {

208 
vÆ
 
r_díõd
 = 
	`Reg
(
	`Boﬁ
())

209 
vÆ
 
d_díõd
 = (!
dFú°
 && 
r_díõd
Ë|| 
out
.
d
.
bôs
.
díõd


210 
	`whí
 (
out
.
d
.
	`fúe
()Ë{ 
r_díõd
 :
d_díõd
 }

211 
ö
.
d
.
bôs
.
díõd
 :
d_díõd


213 i‡(
edgeOut
.
m™agî
.
mayDíyGë
) {

215 
vÆ
 
d_díõd
 = 
out
.
d
.
bôs
.
díõd
 
hﬁdU∆ess
 
dFú°


216 
	`whí
 (
dHasD©a
) {

217 
ö
.
d
.
bôs
.
díõd
 :
d_díõd


222 
vÆ
 
maxArôhmëics
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsArôhmëic
.
max
)

223 
vÆ
 
maxLogiˇls
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsLogiˇl
.
max
)

224 
vÆ
 
maxGës
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsGë
.
max
)

225 
vÆ
 
maxPutFuŒs
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsPutFuŒ
.
max
)

226 
vÆ
 
maxPutP¨tüls
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsPutP¨tül
.
max
)

227 
vÆ
 
maxHöts
 = 
m™agîs
.
	`m≠
(
m
 => i‡(m.
suµ‹tsHöt
Ë
maxDownSize
 0)

230 
vÆ
 
lgMöSize
 = 
	`UI¡
(
	`log2Ceû
(
möSize
))

231 
vÆ
 
maxLgArôhmëics
 = 
maxArôhmëics
.
	`m≠
(
m
 => i‡(m =0Ë
lgMöSize
 
	`UI¡
(
	`log2Ceû
(m)))

232 
vÆ
 
maxLgLogiˇls
 = 
maxLogiˇls
 .
	`m≠
(
m
 => i‡(m =0Ë
lgMöSize
 
	`UI¡
(
	`log2Ceû
(m)))

233 
vÆ
 
maxLgGës
 = 
maxGës
 .
	`m≠
(
m
 => i‡(m =0Ë
lgMöSize
 
	`UI¡
(
	`log2Ceû
(m)))

234 
vÆ
 
maxLgPutFuŒs
 = 
maxPutFuŒs
 .
	`m≠
(
m
 => i‡(m =0Ë
lgMöSize
 
	`UI¡
(
	`log2Ceû
(m)))

235 
vÆ
 
maxLgPutP¨tüls
 = 
maxPutP¨tüls
.
	`m≠
(
m
 => i‡(m =0Ë
lgMöSize
 
	`UI¡
(
	`log2Ceû
(m)))

236 
vÆ
 
maxLgHöts
 = 
maxHöts
 .
	`m≠
(
m
 => i‡(m =0Ë
lgMöSize
 
	`UI¡
(
	`log2Ceû
(m)))

239 
vÆ
 
ª≥©î
 = 
	`ModuÀ
(
√w
 
	`Rïóãr
(
ö
.
a
.
bôs
))

240 
ª≥©î
.
io
.
íq
 <> 
ö
.
a


241 
vÆ
 
ö_a
 = 
ª≥©î
.
io
.
deq


244 
vÆ
 
föd
 = 
m™agî
.
	`födFa°
(
edgeIn
.
	`addªss
(
ö_a
.
bôs
))

245 
vÆ
 
maxLgArôhmëic
 = 
	`Mux1H
(
föd
, 
maxLgArôhmëics
)

246 
vÆ
 
maxLgLogiˇl
 = 
	`Mux1H
(
föd
, 
maxLgLogiˇls
)

247 
vÆ
 
maxLgGë
 = 
	`Mux1H
(
föd
, 
maxLgGës
)

248 
vÆ
 
maxLgPutFuŒ
 = 
	`Mux1H
(
föd
, 
maxLgPutFuŒs
)

249 
vÆ
 
maxLgPutP¨tül
 = 
	`Mux1H
(
föd
, 
maxLgPutP¨tüls
)

250 
vÆ
 
maxLgHöt
 = 
	`Mux1H
(
föd
, 
maxLgHöts
)

252 
vÆ
 
limô
 = i‡(
ÆwaysMö
Ë
lgMöSize
 

253 
	`MuxLookup
(
ö_a
.
bôs
.
›code
, 
lgMöSize
, 
	`Aºay
(

254 
TLMesßges
.
PutFuŒD©a
 -> 
maxLgPutFuŒ
,

255 
TLMesßges
.
PutP¨tülD©a
 -> 
maxLgPutP¨tül
,

256 
TLMesßges
.
ArôhmëicD©a
 -> 
maxLgArôhmëic
,

257 
TLMesßges
.
LogiˇlD©a
 -> 
maxLgLogiˇl
,

258 
TLMesßges
.
Gë
 -> 
maxLgGë
,

259 
TLMesßges
.
Höt
 -> 
maxLgHöt
))

261 
vÆ
 
aOrig
 = 
ö_a
.
bôs
.
size


262 
vÆ
 
aFøg
 = 
	`Mux
(
aOrig
 > 
limô
,Üimit,áOrig)

263 
vÆ
 
aOrigOH1
 = 
	`UI¡ToOH1
(
aOrig
, 
	`log2Ceû
(
maxSize
))

264 
vÆ
 
aFøgOH1
 = 
	`UI¡ToOH1
(
aFøg
, 
	`log2Up
(
maxDownSize
))

265 
vÆ
 
aHasD©a
 = 
edgeIn
.
	`hasD©a
(
ö_a
.
bôs
)

266 
vÆ
 
aMask
 = 
	`Mux
(
aHasD©a
, 
	`UI¡
(0), 
aFøgOH1
)

268 
vÆ
 
gínum
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
cou¡îBôs
))

269 
vÆ
 
aFú°
 = 
gínum
 ==
	`UI¡
(0)

270 
vÆ
 
ﬁd_gínum1
 = 
	`Mux
(
aFú°
, 
aOrigOH1
 >> 
	`log2Ceû
(
bótByãs
), 
gínum
 - 
	`UI¡
(1))

271 
vÆ
 
√w_gínum
 = ~(~
ﬁd_gínum1
 | (
aMask
 >> 
	`log2Ceû
(
bótByãs
)))

272 
vÆ
 
aFøgnum
 = ~(~(
ﬁd_gínum1
 >> 
	`log2Ceû
(
möSize
/
bótByãs
)Ë| (
aFøgOH1
 >>Üog2Ceil(minSize)))

273 
vÆ
 
aLa°
 = 
aFøgnum
 ==
	`UI¡
(0)

274 
vÆ
 
aToggÀ
 = !
	`Mux
(
aFú°
, 
dToggÀ
, 
	`RegE«bÀ
(dToggle,áFirst))

275 
vÆ
 
aFuŒ
 = i‡(
óæyAck
 =
E¨lyAck
.
PutFuŒs
Ë
	`Some
(
ö_a
.
bôs
.
›code
 ==
TLMesßges
.
PutFuŒD©a
Ë
N⁄e


277 
	`whí
 (
out
.
a
.
	`fúe
()Ë{ 
gínum
 :
√w_gínum
 }

279 
ª≥©î
.
io
.
ª≥©
 :!
aHasD©a
 && 
aFøgnum
 =/
	`UI¡
(0)

280 
out
.
a
 <> 
ö_a


281 
out
.
a
.
bôs
.
addªss
 :
ö_a
.bôs.addªs†| ~(
ﬁd_gínum1
 << 
	`log2Ceû
(
bótByãs
Ë| ~
aOrigOH1
 | 
aFøgOH1
 | 
	`UI¡
(
möSize
-1))

282 
out
.
a
.
bôs
.
sour˚
 :
	`C©
(
	`Seq
(
ö_a
.bôs.sour˚Ë++ 
aFuŒ
 ++ Seq(
aToggÀ
.
asUI¡
, 
aFøgnum
))

283 
out
.
a
.
bôs
.
size
 :
aFøg


286 
	`as£π
 (!
ª≥©î
.
io
.
fuŒ
 || !
aHasD©a
)

287 
out
.
a
.
bôs
.
d©a
 :
ö
.a.bits.data

288 
vÆ
 
fuŒMask
 = 
	`UI¡
((
	`BigI¡
(1Ë<< 
bótByãs
) - 1)

289 
	`as£π
 (!
ª≥©î
.
io
.
fuŒ
 || 
ö_a
.
bôs
.
mask
 ==
fuŒMask
)

290 
out
.
a
.
bôs
.
mask
 :
	`Mux
(
ª≥©î
.
io
.
fuŒ
, 
fuŒMask
, 
ö
.a.bits.mask)

293 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

294 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

295 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

296 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

297 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

298 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

301 
	}
}

303 
obje˘
 
TLFøgmíãr


305 
def
 
≠∂y
(
möSize
: 
I¡
, 
maxSize
: I¡, 
ÆwaysMö
: 
Boﬁón
 = 
Ál£
, 
óæyAck
: 
E¨lyAck
.
T
 = E¨lyAck.
N⁄e
, 
hﬁdFú°Díy
: Boﬁó¿Ál£)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

307 
vÆ
 
‰agmíãr
 = 
LazyModuÀ
(
√w
 
TLFøgmíãr
(
möSize
, 
maxSize
, 
ÆwaysMö
, 
óæyAck
, 
hﬁdFú°Díy
))

308 
	g‰agmíãr
.
	gnode


313 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


315 
˛ass
 
	$TLRAMFøgmíãr
(
ømBótByãs
: 
I¡
, 
maxSize
: I¡, 
txns
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

316 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

317 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("Fragmenter"))

318 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0x0, 0x3ff), 
bótByãs
 = 
ømBótByãs
))

320 (
øm
.
node


321 :
	`TLDñayî
(0.1)

322 :
	`TLBuf„r
(
Buf„rP¨ams
.
Êow
)

323 :
	`TLDñayî
(0.1)

324 :
	`TLFøgmíãr
(
ømBótByãs
, 
maxSize
, 
óæyAck
 = 
E¨lyAck
.
AŒPuts
)

325 :
	`TLDñayî
(0.1)

326 :
	`TLBuf„r
(
Buf„rP¨ams
.
Êow
)

327 :
	`TLFøgmíãr
(
ømBótByãs
, 
maxSize
/2)

328 :
	`TLDñayî
(0.1)

329 :
	`TLBuf„r
(
Buf„rP¨ams
.
Êow
)

330 :
modñ
.
node


331 :
fuzz
.
node
)

333 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

334 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

336 
	}
}

338 
˛ass
 
	$TLRAMFøgmíãrTe°
(
ømBótByãs
: 
I¡
, 
maxSize
: I¡, 
txns
: I¡ = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

339 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMFøgmíãr
(
ømBótByãs
,
maxSize
,
txns
)).
moduÀ
)

340 
io
.
föished
 :
dut
.io.finished

341 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fuzzer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 ˛as†
	cIDM≠Gíî©‹
(
numIds
: 
I¡
Ë
exãnds
 
ModuÀ
 {

11 
	`ªquúe
 (
numIds
 > 0)

13 
vÆ
 
w
 = 
	$log2Up
(
numIds
)

14 
vÆ
 
io
 = 
√w
 
BundÀ
 {

15 
vÆ
 
‰ì
 = 
	`Decou∂ed
(
	`UI¡
(
width
 = 
w
)).
Êù


16 
vÆ
 
Æloc
 = 
	`Decou∂ed
(
	`UI¡
(
width
 = 
w
))

19 
io
.
‰ì
.
ªady
 :
	$Boﬁ
(
åue
)

22 
vÆ
 
bôm≠
 = 
	`RegInô
(
	`UI¡
((
	`BigI¡
(1Ë<< 
numIds
Ë- 1, 
width
 =ÇumIds))

24 
vÆ
 
£À˘
 = ~(
	`À·OR
(
bôm≠
) << 1) & bitmap

25 
io
.
Æloc
.
bôs
 :
	$OHToUI¡
(
£À˘
)

26 
io
.
Æloc
.
vÆid
 :
bôm≠
.
	$‹R
()

28 
vÆ
 
˛r
 = 
	`Wúe
(
öô
 = 
	$UI¡
(0, 
width
 = 
numIds
))

29 
	`whí
 (
io
.
Æloc
.
	$fúe
()Ë{ 
˛r
 :
	`UI¡ToOH
(
io
.
Æloc
.
bôs
Ë
	}
}

31 
vÆ
 
£t
 = 
Wúe
(
öô
 = 
	$UI¡
(0, 
width
 = 
numIds
))

32 
	`whí
 (
io
.
‰ì
.
	$fúe
()Ë{ 
£t
 :
	`UI¡ToOH
(
io
.
‰ì
.
bôs
Ë
	}
}

34 
bôm≠
 :(bôm≠ & ~
˛r
Ë| 
£t


35 
as£π
 (!
io
.
‰ì
.
vÆid
 || !(
bôm≠
 & ~
˛r
)(io.‰ì.
bôs
))

38 
obje˘
 
LFSR64


40 
def
 
≠∂y
(
ö¸emít
: 
Boﬁ
 = Boﬁ(
åue
)): 
UI¡
 =

42 
vÆ
 
wide
 = 64

43 
vÆ
 
lf§
 = 
Reg
(
UI¡
(
width
 = 
wide
))

44 
vÆ
 
x‹
 = 
lf§
(0) ^Üfsr(1) ^Üfsr(3) ^Üfsr(4)

45 
whí
 (
ö¸emít
) {

46 
lf§
 :
Mux
÷f§ ==
UI¡
(0), UI¡(1), 
C©
(
x‹
,Üf§(
wide
-1,1)))

48 
	glf§


52 
åaô
 
	gHasNoi£MakîIO


54 
vÆ
 
	gio
 = 
√w
 
BundÀ
 {

55 
vÆ
 
öc
 = 
Boﬁ
(
INPUT
)

56 
vÆ
 
øndom
 = 
UI¡
(
OUTPUT
)

60 ˛as†
	cLFSRNoi£Makî
(
wide
: 
I¡
Ë
exãnds
 
ModuÀ
 
wôh
 
HasNoi£MakîIO


62 
vÆ
 
lf§s
 = 
Seq
.
	`fûl
((
wide
+63)/64Ë{ 
	`LFSR64
(
io
.
öc
) }

63 
io
.
øndom
 :
	$C©
(
lf§s
)(
wide
-1,0)

64 
	}
}

66 
obje˘
 
	gLFSRNoi£Makî
 {

67 
def
 
≠∂y
(
wide
: 
I¡
, 
ö¸emít
: 
Boﬁ
 = Boﬁ(
åue
)): 
UI¡
 = {

68 
vÆ
 
nm
 = 
ModuÀ
(
√w
 
LFSRNoi£Makî
(
wide
))

69 
nm
.
io
.
öc
 :
ö¸emít


70 
nm
.
io
.
øndom


81 
˛ass
 
TLFuzzî
(

82 
nO≥øti⁄s
: 
I¡
,

83 
öFlight
: 
I¡
 = 32,

84 
noi£Makî
: (
I¡
, 
Boﬁ
, I¡Ë=> 
UI¡
 = {

85 (
wide
: 
I¡
, 
ö¸emít
: 
Boﬁ
, 
abs_vÆues
: Int) =>

86 
LFSRNoi£Makî
(
wide
=wide, 
ö¸emít
=increment)

88 
noModify
: 
Boﬁón
 = 
Ál£
,

89 
ovîrideAddªss
: 
O±i⁄
[
AddªssSë
] = 
N⁄e
,

90 
nOrdîed
: 
O±i⁄
[
I¡
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


93 
vÆ
 
˛õ¡P¨ams
 = i‡(
nOrdîed
.
isDeföed
) {

94 
vÆ
 
n
 = 
nOrdîed
.
gë


95 
ªquúe
(
n
 > 0, 
s
"nOrdered must be > 0,Çot $n")

96 
ªquúe
((
öFlight
 % 
n
Ë=0, 
s
"inFlight (${inFlight}) must beÉvenly divisible byÇOrdered (${nOrdered}).")

97 
	gSeq
.
èbuœã
(
n
Ë{
	gi
 =>

98 
TLClõ¡P¨amëîs
(
«me
 =
s
"OrderedFuzzer$i",

99 
sour˚Id
 = 
IdR™ge
(
i
 * (
öFlight
/
n
), (i + 1)*(inFlight/n)),

100 
ªque°Fifo
 = 
åue
)

103 
Seq
(
TLClõ¡P¨amëîs
(

104 
«me
 = "Fuzzer",

105 
sour˚Id
 = 
IdR™ge
(0,
öFlight
)

109 
vÆ
 
	gnode
 = 
TLClõ¡Node
(
Seq
(
TLClõ¡P‹tP¨amëîs
(
˛õ¡P¨ams
)))

111 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

112 
vÆ
 
io
 = 
IO
(
√w
 
BundÀ
 {

113 
vÆ
 
föished
 = 
Boﬁ
(
OUTPUT
)

116 
vÆ
 (
out
, 
edge
Ë
node
.out(0)

119 
vÆ
 
maxTøns„r
 = 
edge
.
m™agî
.maxTransfer

120 
vÆ
 
bótByãs
 = 
edge
.
m™agî
.beatBytes

121 
vÆ
 
maxLgBóts
 = 
log2Up
(
maxTøns„r
/
bótByãs
)

122 
vÆ
 
addªssBôs
 = 
log2Up
(
ovîrideAddªss
.
m≠
(
_
.
max
).
gëOrEl£
(
edge
.
m™agî
.
maxAddªss
))

123 
vÆ
 
sizeBôs
 = 
edge
.
bundÀ
.sizeBits

124 
vÆ
 
d©aBôs
 = 
edge
.
bundÀ
.dataBits

127 
vÆ
 
num_ªqs
 = 
Reg
(
öô
 = 
UI¡
(
nO≥øti⁄s
, 
log2Up
(nOperations+1)))

128 
vÆ
 
	gnum_ª•s
 = 
Reg
(
öô
 = 
UI¡
(
nO≥øti⁄s
, 
log2Up
(nOperations+1)))

129 i‡(
	gnO≥øti⁄s
>0) {

130 
	gio
.
	gföished
 :
num_ª•s
 ==
UI¡
(0)

132 
io
.
föished
 :
Boﬁ
(
Ál£
)

136 
vÆ
 
a
 = 
out
.a.
bôs


137 
vÆ
 (
a_fú°
, 
a_œ°
, 
ªq_d⁄e
Ë
edge
.
fú°œ°
(
out
.
a
)

139 
vÆ
 
d
 = 
out
.d.
bôs


140 
vÆ
 (
d_fú°
, 
d_œ°
, 
ª•_d⁄e
Ë
edge
.
fú°œ°
(
out
.
d
)

143 
vÆ
 
idM≠
 = 
ModuÀ
(
√w
 
IDM≠Gíî©‹
(
öFlight
))

144 
vÆ
 
§c
 = 
idM≠
.
io
.
Æloc
.
bôs
 
hﬁdU∆ess
 
a_fú°


146 
vÆ
 
öc
 = 
Wúe
(
Boﬁ
())

147 
vÆ
 
öc_bót
 = 
Wúe
(
Boﬁ
())

148 
vÆ
 
¨th_›_3
 = 
noi£Makî
(3, 
öc
, 0)

149 
vÆ
 
	g¨th_›
 = 
Mux
(
¨th_›_3
 > 
UI¡
(4), UInt(4),árth_op_3)

150 
vÆ
 
	glog_›
 = 
noi£Makî
(2, 
öc
, 0)

151 
vÆ
 
	gamo_size
 = 
UI¡
(2Ë+ 
noi£Makî
(1, 
öc
, 0)

152 
vÆ
 
	gsize
 = 
noi£Makî
(
sizeBôs
, 
öc
, 0)

153 
vÆ
 
	gøwAddr
 = 
noi£Makî
(
addªssBôs
, 
öc
, 2)

154 
vÆ
 
	gaddr
 = 
ovîrideAddªss
.
m≠
(
_
.
ÀgÆize
(
øwAddr
)).
gëOrEl£
‘awAddrË& ~
UI¡ToOH1
(
size
, 
addªssBôs
)

155 
vÆ
 
	gmask
 = 
noi£Makî
(
bótByãs
, 
öc_bót
, 2Ë& 
	gedge
.
mask
(
addr
, 
size
)

156 
vÆ
 
	gd©a
 = 
noi£Makî
(
d©aBôs
, 
öc_bót
, 2)

159 
vÆ
 (
gÀgÆ
, 
gbôs
Ë
edge
.
Gë
(
§c
, 
addr
, 
size
)

160 
vÆ
 (
pÊegÆ
, 
pfbôs
Ëif(
edge
.
m™agî
.
™ySuµ‹tPutFuŒ
) {

161 
edge
.
Put
(
§c
, 
addr
, 
size
, 
d©a
)

162 } { (
gÀgÆ
, 
gbôs
) }

163 
vÆ
 (
µÀgÆ
, 
µbôs
Ëif(
edge
.
m™agî
.
™ySuµ‹tPutP¨tül
) {

164 
edge
.
Put
(
§c
, 
addr
, 
size
, 
d©a
, 
mask
)

165 } { (
gÀgÆ
, 
gbôs
) }

166 
vÆ
 (
ÆegÆ
, 
abôs
Ëif(
edge
.
m™agî
.
™ySuµ‹tArôhmëic
) {

167 
edge
.
Arôhmëic
(
§c
, 
addr
, 
size
, 
d©a
, 
¨th_›
)

168 } { (
gÀgÆ
, 
gbôs
) }

169 
vÆ
 (
ŒegÆ
, 
lbôs
Ëif(
edge
.
m™agî
.
™ySuµ‹tLogiˇl
) {

170 
edge
.
Logiˇl
(
§c
, 
addr
, 
size
, 
d©a
, 
log_›
)

171 } { (
gÀgÆ
, 
gbôs
) }

172 
vÆ
 (
hÀgÆ
, 
hbôs
Ëif(
edge
.
m™agî
.
™ySuµ‹tHöt
) {

173 
edge
.
Höt
(
§c
, 
addr
, 
size
, 
UI¡
(0))

174 } { (
gÀgÆ
, 
gbôs
) }

176 
vÆ
 
ÀgÆ_de°
 = 
edge
.
m™agî
.
c⁄èösSa„
(
addr
)

179 
vÆ
 
a_ty≥_£l
 = 
noi£Makî
(3, 
öc
, 0)

181 
vÆ
 
	gÀgÆ
 = 
ÀgÆ_de°
 && 
MuxLookup
(
a_ty≥_£l
, 
gÀgÆ
, 
Seq
(

182 
UI¡
("b000"Ë-> 
gÀgÆ
,

183 
UI¡
("b001"Ë-> (
pÊegÆ
 && !
Boﬁ
(
noModify
)),

184 
UI¡
("b010"Ë-> (
µÀgÆ
 && !
Boﬁ
(
noModify
)),

185 
UI¡
("b011"Ë-> (
ÆegÆ
 && !
Boﬁ
(
noModify
)),

186 
UI¡
("b100"Ë-> (
ŒegÆ
 && !
Boﬁ
(
noModify
)),

187 
UI¡
("b101"Ë-> 
hÀgÆ
))

189 
vÆ
 
	gbôs
 = 
MuxLookup
(
a_ty≥_£l
, 
gbôs
, 
Seq
(

190 
UI¡
("b000"Ë-> 
gbôs
,

191 
UI¡
("b001"Ë-> 
pfbôs
,

192 
UI¡
("b010"Ë-> 
µbôs
,

193 
UI¡
("b011"Ë-> 
abôs
,

194 
UI¡
("b100"Ë-> 
lbôs
,

195 
UI¡
("b101"Ë-> 
hbôs
))

198 
vÆ
 
	ga_gí
 = i‡(
nO≥øti⁄s
>0Ë
num_ªqs
 =/
UI¡
(0Ë
Boﬁ
(
åue
)

199 
out
.
a
.
vÆid
 :
a_gí
 && 
ÀgÆ
 && (!
a_fú°
 || 
idM≠
.
io
.
Æloc
.valid)

200 
idM≠
.
io
.
Æloc
.
ªady
 :
a_gí
 && 
ÀgÆ
 && 
a_fú°
 && 
out
.
a
.ready

201 
idM≠
.
io
.
‰ì
.
vÆid
 :
d_fú°
 && 
out
.
d
.
fúe
()

202 
idM≠
.
io
.
‰ì
.
bôs
 :
out
.
d
.bôs.
sour˚


204 
out
.
a
.
bôs
 := bits

205 
out
.
b
.
ªady
 :
Boﬁ
(
åue
)

206 
out
.
c
.
vÆid
 :
Boﬁ
(
Ál£
)

207 
out
.
d
.
ªady
 :
Boﬁ
(
åue
)

208 
out
.
e
.
vÆid
 :
Boﬁ
(
Ál£
)

211 
öc
 :!
ÀgÆ
 || 
ªq_d⁄e


212 
öc_bót
 :!
ÀgÆ
 || 
out
.
a
.
fúe
()

214 i‡(
nO≥øti⁄s
>0) {

215 
whí
 (
out
.
a
.
fúe
(Ë&& 
a_œ°
) {

216 
num_ªqs
 :num_ªq†- 
UI¡
(1)

219 
whí
 (
out
.
d
.
fúe
(Ë&& 
d_œ°
) {

220 
num_ª•s
 :num_ª•†- 
UI¡
(1)

226 
obje˘
 
TLFuzzî


228 
def
 
≠∂y
(

229 
nO≥øti⁄s
: 
I¡
,

230 
öFlight
: 
I¡
 = 32,

231 
noi£Makî
: (
I¡
, 
Boﬁ
, I¡Ë=> 
UI¡
 = {

232 (
wide
: 
I¡
, 
ö¸emít
: 
Boﬁ
, 
abs_vÆues
: Int) =>

233 
LFSRNoi£Makî
(
wide
=wide, 
ö¸emít
=increment)

235 
noModify
: 
Boﬁón
 = 
Ál£
,

236 
ovîrideAddªss
: 
O±i⁄
[
AddªssSë
] = 
N⁄e
,

237 
nOrdîed
: 
O±i⁄
[
I¡
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLOutw¨dNode
 =

239 
vÆ
 
fuzzî
 = 
LazyModuÀ
(
√w
 
TLFuzzî
(
nO≥øti⁄s
, 
öFlight
, 
noi£Makî
, 
noModify
, 
ovîrideAddªss
, 
nOrdîed
))

240 
	gfuzzî
.
	gnode


245 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


247 ˛as†
	cTLFuzzRAM
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


249 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("TLFuzzRAM"))

250 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	$AddªssSë
(0x800, 0x7ff)))

251 
vÆ
 
øm2
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0, 0x3ff), 
bótByãs
 = 16))

252 
vÆ
 
gpio
 = 
	`LazyModuÀ
(
√w
 
	$RRTe°1
(0x400))

253 
vÆ
 
xb¨
 = 
	$LazyModuÀ
(
√w
 
TLXb¨
)

254 
vÆ
 
xb¨2

	$LazyModuÀ
(
√w
 
TLXb¨
)

255 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

257 
xb¨2
.
node
 :
	$TLAtomicAutom©a
(Ë:
modñ
.
node
 :
fuzz
.node

258 
øm2
.
node
 :
	$TLFøgmíãr
(16, 256Ë:
xb¨2
.
node


259 
xb¨
.
node
 :
	$TLWidthWidgë
(16Ë:
	$TLHötH™dÀr
(Ë:
xb¨2
.
node


260 
øm
.
node
 :
	$TLFøgmíãr
(4, 256Ë:
	$TLBuf„r
(Ë:
xb¨
.
node


261 
gpio
.
node
 :
	$TLFøgmíãr
(4, 32Ë:
	$TLBuf„r
(Ë:
xb¨
.
node


263 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

264 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

266 
	}
}

268 
˛ass
 
	$TLFuzzRAMTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

269 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLFuzzRAM
(
txns
)).
moduÀ
)

270 
io
.
föished
 :
dut
.io.finished

271 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/HintHandler.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
Rïóãr


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
TLROM


11 
imp‹t
 
	gsˇœ
.
	gm©h
.
mö


14 
˛ass
 
	$TLHötH™dÀr
(
∑s°hrough
: 
Boﬁón
 = 
åue
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


16 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

17 
˛õ¡Fn
 = { 
˝
 =>

18 
˝
.
	`c›y
(
˛õ¡s
 = cp.˛õ¡s.
m≠
 { 
c
 => c.copy(

19 
sour˚Id
 = 
	`IdR™ge
(
c
.sour˚Id.
°¨t
*2, c.sour˚Id.
íd
*2))})},

20 
m™agîFn
 = { 
mp
 =>

21 
mp
.
	`c›y
(
m™agîs
 = mp.m™agîs.
m≠
 { 
m
 => m.copy(

22 
suµ‹tsHöt
 =

23 i‡(
m
.
suµ‹tsHöt
 && 
∑s°hrough
) m.supportsHint

24 i‡(
m
.
suµ‹tsPutP¨tül
) m.supportsPutPartial

25 i‡(
m
.
ªgi⁄Ty≥
 !
Regi⁄Ty≥
.
GET_EFFECTS
Ëm.
suµ‹tsGë


26 
Tøns„rSizes
.
n⁄e
)})})

28 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

29 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

30 
out
 <> 
ö


33 
edgeIn
.
m™agî
.
m™agîs
.
f‹óch
 { 
m
 =>

34 
	`ªquúe
 (
m
.
suµ‹tsHöt
, 
s
"NoÜegal wayÅo implement Hints for ${m.name}")

37 
vÆ
 
isHöt
 = 
ö
.
a
.
bôs
.
›code
 ==
TLMesßges
.
Höt


38 
def
 
	`u£PP
 (
m
: 
TLM™agîP¨amëîs
Ë!(
∑s°hrough
 && m.
suµ‹tsHöt
Ë&& m.
suµ‹tsPutP¨tül


39 
def
 
	`u£Gë
(
m
: 
TLM™agîP¨amëîs
Ë!(
∑s°hrough
 && m.
suµ‹tsHöt
Ë&& !m.
suµ‹tsPutP¨tül


42 
vÆ
 
hñpPP
 = 
isHöt
 && 
edgeOut
.
m™agî
.
	`Á°Pr›îty
(
ö
.
a
.
bôs
.
addªss
, 
u£PP
, (
b
:
Boﬁón
Ë=> b.
B
)

43 
vÆ
 
m≠PP
 = 
	`WúeInô
(
hñpPP
)

46 
vÆ
 
m≠Gë
 = 
isHöt
 && 
edgeOut
.
m™agî
.
	`Á°Pr›îty
(
ö
.
a
.
bôs
.
addªss
, 
u£Gë
, (
b
:
Boﬁón
Ë=> b.
B
)

50 
vÆ
 
√edRïóãr
 = 
edgeOut
.
m™agî
.
m™agîs
.
exi°s
 { 
m
 =>

51 !(
∑s°hrough
 && 
m
.
suµ‹tsHöt
Ë&& m.
suµ‹tsPutP¨tül
.
max
 > 
edgeOut
.
m™agî
.
bótByãs


54 
vÆ
 
a
 = i‡(!
√edRïóãr
Ë
ö
.a {

55 
vÆ
 
ª≥©î
 = 
	`ModuÀ
(
√w
 
	`Rïóãr
(
ö
.
a
.
bôs
))

56 
vÆ
 
mux
 = 
	`Wúe
(
	`chi£lTy≥Of
(
ö
.
a
))

58 
ª≥©î
.
io
.
ª≥©
 :
m≠PP
 && !
edgeIn
.
	`œ°
(
out
.
a
)

59 
ª≥©î
.
io
.
íq
 <> 
ö
.
a


61 
out
.
a
.
bôs
 :
mux
.bits

62 
out
.
a
.
vÆid
 :
mux
.valid

63 
mux
.
ªady
 :
out
.
a
.ready

66 
mux
.
bôs
.
›code
 :
ö
.
a
.bits.opcode

67 
mux
.
bôs
.
∑øm
 :
ö
.
a
.bits.param

68 
mux
.
bôs
.
size
 :
ª≥©î
.
io
.
deq
.bits.size

69 
mux
.
bôs
.
sour˚
 :
ª≥©î
.
io
.
deq
.bits.source

70 
mux
.
bôs
.
addªss
 :
ª≥©î
.
io
.
deq
.bits.address

71 
mux
.
bôs
.
d©a
 :
ö
.
a
.bits.data

72 
mux
.
bôs
.
mask
 :
ö
.
a
.bits.mask

73 
mux
.
bôs
.
c‹ru±
 :
ö
.
a
.bits.corrupt

75 
mux
.
vÆid
 :
ª≥©î
.
io
.
deq
.valid

76 
ª≥©î
.
io
.
deq
.
ªady
 :
mux
.ready

78 
m≠PP
 :
ª≥©î
.
io
.
fuŒ
 || 
hñpPP


79 
mux


83 
out
.
a
.
bôs
.
›code
 :
	`Mux
(
m≠PP
, 
TLMesßges
.
PutP¨tülD©a
, Mux(
m≠Gë
, TLMesßges.
Gë
,á.bits.opcode))

84 
out
.
a
.
bôs
.
∑øm
 :
	`Mux
(
m≠PP
 | 
m≠Gë
, 0.U,á.bits.param)

85 
out
.
a
.
bôs
.
mask
 :
	`Mux
(
m≠PP
, 0.U,á.bits.mask)

86 
out
.
a
.
bôs
.
sour˚
 :a.bôs.sour˚ << 1 | (
m≠PP
|
m≠Gë
)

89 
vÆ
 
√edsDr›
 = 
edgeOut
.
m™agî
.
m™agîs
.
exi°s
 { 
m
 =>

90 !(
∑s°hrough
 && 
m
.
suµ‹tsHöt
Ë&& !m.
suµ‹tsPutP¨tül
 &&

91 
m
.
suµ‹tsGë
.
max
 > 
edgeOut
.
m™agî
.
bótByãs


94 
vÆ
 
å™sf‹m
 = 
out
.
d
.
bôs
.
	`sour˚
(0)

95 
vÆ
 
dr›
 = i‡(!
√edsDr›
Ë
Ál£
.
B
 {

97 
vÆ
 
œ°
 = 
edgeOut
.
	`œ°
(
out
.
d
)

98 !
œ°
 && 
å™sf‹m


102 
ö
.
d
.
bôs
.
sour˚
 :
out
.d.bits.source >> 1

103 
ö
.
d
.
bôs
.
›code
 :
	`Mux
(
å™sf‹m
, 
TLMesßges
.
HötAck
, 
out
.d.bits.opcode)

104 
ö
.
d
.
vÆid
 :
out
.d.vÆid && !
dr›


105 
out
.
d
.
ªady
 :
ö
.d.ªady || 
dr›


107 i‡(
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 && 
edgeIn
.
˛õ¡
.
™ySuµ‹tProbe
) {

108 
ö
.
b
.
bôs
.
sour˚
 :
out
.b.bits.source >> 1

109 
out
.
c
.
bôs
.
sour˚
 :
ö
.c.bits.source << 1

113 
	}
}

115 
obje˘
 
TLHötH™dÀr


117 
def
 
≠∂y
(
∑s°hrough
: 
Boﬁón
 = 
åue
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

119 
vÆ
 
höts
 = 
LazyModuÀ
(
√w
 
TLHötH™dÀr
(
∑s°hrough
))

120 
höts
.
node


125 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


129 ˛as†
	cTLRAMHötH™dÀr
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

130 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

131 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("HintHandler"))

132 
vÆ
 
øm1
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	$AddªssSë
(0x0, 0x3ff)))

133 
vÆ
 
øm2
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	$AddªssSë
(0x400, 0x3ff)))

134 
vÆ
 
rom
 = 
	`LazyModuÀ
(
√w
 
	`TLROM
(0x800, 0x400, 
Seq
.
	$fûl
(128) { 0 }))

135 
vÆ
 
xb¨
 = 
	$LazyModuÀ
(
√w
 
TLXb¨
)

137 (
øm1
.
node


138 :
	$TLDñayî
(0.1)

139 :
	$TLHötH™dÀr
()

140 :
	$TLDñayî
(0.1)

141 :
	$TLHötH™dÀr
()

142 :
	$TLDñayî
(0.1)

143 :
	$TLFøgmíãr
(4, 64)

144 :
xb¨
.
node
)

145 (
øm2
.
node


146 :
	$TLFøgmíãr
(4, 64)

147 :
	$TLDñayî
(0.1)

148 :
xb¨
.
node
)

149 (
rom
.
node


150 :
	$TLFøgmíãr
(4, 64)

151 :
xb¨
.
node
)

152 (
xb¨
.
node


153 :
	$TLDñayî
(0.1)

154 :
	$TLHötH™dÀr
()

155 :
	$TLDñayî
(0.1)

156 :
modñ
.
node


157 :
fuzz
.
node
)

159 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

160 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

161 
	}
}

164 
˛ass
 
	$TLRAMHötH™dÀrTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

165 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMHötH™dÀr
(
txns
)).
moduÀ
)

166 
io
 <> 
dut
.io

167 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Isolation.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
AsyncBundÀ


11 
˛ass
 
TLIsﬁ©i⁄
(
fOut
: (
Boﬁ
, 
UI¡
Ë=> UI¡, 
fIn
: (Boﬁ, UI¡Ë=> UI¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


13 
vÆ
 
node
 = 
TLAsyncAd≠ãrNode
()

15 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

16 
vÆ
 
io
 = 
IO
(
√w
 
BundÀ
 {

17 
vÆ
 
iso_out
 = 
Boﬁ
(
INPUT
)

18 
vÆ
 
iso_ö
 = 
Boﬁ
(
INPUT
)

21 
def
 
ISOo
[
T
 <: 
D©a
](
x
: T): T = x.
‰omBôs
(
fOut
(
io
.
iso_out
, x.
asUI¡
))

22 
def
 
	gISOi
[
T
 <: 
D©a
](
x
: T): T = x.
‰omBôs
(
fIn
 (
io
.
iso_ö
, x.
asUI¡
))

24 
def
 
	gABo
[
T
 <: 
D©a
](
x
: 
AsyncBundÀ
[T], 
	gy
: AsyncBundle[T]) {

25 
x
.
mem
 :
ISOo
(
y
.mem)

26 
x
.
widx
 :
ISOo
(
y
.widx)

27 
y
.
ridx
 :
ISOi
(
x
.ridx)

28 (
x
.
ödex
 
zù
 
y
.ödexË
f‹óch
 { (x, yË=> y :
ISOi
(x) }

29 (
x
.
ß„
 
zù
 
y
.ß„Ë
f‹óch
 { (x, 
	gy
) =>

30 
x
.
widx_vÆid
 :
ISOo
(
y
.widx_valid)

31 
x
.
sour˚_ª£t_n
 :
ISOo
(
y
.source_reset_n)

32 
y
.
ridx_vÆid
 :
ISOi
(
x
.ridx_valid)

33 
y
.
sök_ª£t_n
 :
ISOi
(
x
.sink_reset_n)

37 
def
 
ABi
[
T
 <: 
D©a
](
x
: 
AsyncBundÀ
[T], 
	gy
: AsyncBundle[T]) {

38 
x
.
mem
 :
ISOi
(
y
.mem)

39 
x
.
widx
 :
ISOi
(
y
.widx)

40 
y
.
ridx
 :
ISOo
(
x
.ridx)

41 (
x
.
ödex
 
zù
 
y
.ödexË
f‹óch
 { (x, yË=> y :
ISOo
(x) }

42 (
x
.
ß„
 
zù
 
y
.ß„Ë
f‹óch
 { (x, 
	gy
) =>

43 
x
.
widx_vÆid
 :
ISOi
(
y
.widx_valid)

44 
x
.
sour˚_ª£t_n
 :
ISOi
(
y
.source_reset_n)

45 
y
.
ridx_vÆid
 :
ISOo
(
x
.ridx_valid)

46 
y
.
sök_ª£t_n
 :
ISOo
(
x
.sink_reset_n)

50 
def
 
ABz
[
T
 <: 
D©a
](
x
: 
AsyncBundÀ
[T], 
	gy
: AsyncBundle[T]) {

51 
x
.
widx
 :
UI¡
(0)

52 
y
.
ridx
 :
UI¡
(0)

53 (
x
.
ödex
 
zù
 
y
.ödexË
f‹óch
 { (
_
, yË=> y :
UI¡
(0) }

54 (
x
.
ß„
 
zù
 
y
.ß„Ë
f‹óch
 { (x, 
	gy
) =>

55 
x
.
widx_vÆid
 :
Boﬁ
(
Ál£
)

56 
x
.
sour˚_ª£t_n
 :
Boﬁ
(
Ál£
)

57 
y
.
ridx_vÆid
 :
Boﬁ
(
Ál£
)

58 
y
.
sök_ª£t_n
 :
Boﬁ
(
Ál£
)

62 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
	gedgeIn
), (
	gout
, 
	gedgeOut
)) =>

63 
ABo
(
out
.
a
, 
ö
 .a)

64 
ABi
(
ö
 .
d
, 
out
.d)

66 i‡(
	gedgeOut
.
	gm™agî
.
	gba£
.
	g™ySuµ‹tAcquúeB
 &&ÉdgeOut.
	g˛õ¡
.ba£.
	g™ySuµ‹tProbe
) {

67 
ABi
(
ö
 .
b
, 
out
.b)

68 
ABo
(
out
.
c
, 
ö
 .c)

69 
ABo
(
out
.
e
, 
ö
 .e)

71 
ABz
(
ö
 .
b
, 
out
.b)

72 
ABz
(
out
.
c
, 
ö
 .c)

73 
ABz
(
out
.
e
, 
ö
 .e)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Map.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

12 
˛ass
 
TLM≠
(
‚
: 
AddªssSë
 => 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
node
 = 
TLAd≠ãrNode
(

15 
˛õ¡Fn
 = { 
˝
 => cp },

16 
m™agîFn
 = { 
mp
 =>

17 
mp
.
c›y
(
m™agîs
 = mp.m™agîs.
m≠
(
m
 =>

18 
m
.
c›y
(
addªss
 = m.addªss.
m≠
(
a
 =>

19 
AddªssSë
(
‚
(
a
),á.
mask
)))))})

21 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

22 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

23 
out
 <> 
ö


24 
vÆ
 
c⁄vît
 = 
edgeIn
.
m™agî
.
m™agîs
.
Ê©M≠
(
_
.
addªss
Ë
zù
 
edgeOut
.manager.managers.flatMap(_.address)

25 
def
 
f‹w¨d
(
x
: 
UI¡
) =

26 
c⁄vît
.
m≠
 { (
i
, 
o
Ë=> 
Mux
(i.
c⁄èös
(
x
), 
UI¡
(o.
ba£
Ë| (x & UI¡(o.
mask
)), UI¡(0)Ë}.
ªdu˚
(
_
 | _)

27 
def
 
backw¨d
(
x
: 
UI¡
) =

28 
c⁄vît
.
m≠
 { (
i
, 
o
Ë=> 
Mux
(o.
c⁄èös
(
x
), 
UI¡
(i.
ba£
Ë| (x & UI¡(i.
mask
)), UI¡(0)Ë}.
ªdu˚
(
_
 | _)

30 
	gout
.
	ga
.
	gbôs
.
	gaddªss
 :
f‹w¨d
(
ö
.
a
.
bôs
.
addªss
)

31 i‡(
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeOut.
˛õ¡
.
™ySuµ‹tProbe
) {

32 
out
.
c
.
bôs
.
addªss
 :
f‹w¨d
(
ö
.c.bits.address)

33 
ö
.
b
.
bôs
.
addªss
 :
backw¨d
(
out
.b.bits.address)

39 
obje˘
 
TLM≠


41 
def
 
≠∂y
(
‚
: 
AddªssSë
 => 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

43 
vÆ
 
m≠
 = 
LazyModuÀ
(
√w
 
TLM≠
(
‚
))

44 
m≠
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Metadata.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	grockë
.
	gc⁄°™ts
.
Mem‹yOpC⁄°™ts


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
obje˘
 
	gClõ¡Sèãs
 {

12 
vÆ
 
	gwidth
 = 2

14 
def
 
NŸhög
 = 
UI¡
(0, 
width
)

15 
def
 
	gBønch
 = 
UI¡
(1, 
width
)

16 
def
 
	gTrunk
 = 
UI¡
(2, 
width
)

17 
def
 
	gDúty
 = 
UI¡
(3, 
width
)

19 
def
 
hasRódPîmissi⁄
(
°©e
: 
UI¡
): 
Boﬁ
 = sèã > 
NŸhög


20 
def
 
hasWrôePîmissi⁄
(
°©e
: 
UI¡
): 
Boﬁ
 = sèã > 
Bønch


23 
obje˘
 
Mem‹yOpC©eg‹õs
 
exãnds
 
Mem‹yOpC⁄°™ts
 {

24 
def
 
wr
 = 
C©
(
Boﬁ
(
åue
), Bool(true))

25 
def
 
	gwi
 = 
C©
(
Boﬁ
(
Ál£
), Boﬁ(
åue
))

26 
def
 
	grd
 = 
C©
(
Boﬁ
(
Ál£
), Bool(false))

28 
def
 
ˇãg‹ize
(
cmd
: 
UI¡
): UInt = {

29 
vÆ
 
ˇt
 = 
C©
(
isWrôe
(
cmd
), 
isWrôeI¡ít
(cmd))

31 
	gˇt


40 ˛as†
	cClõ¡Mëad©a
 
exãnds
 
	mBundÀ
 {

42 
vÆ
 
	m°©e
 = 
	$UI¡
(
width
 = 
Clõ¡Sèãs
.width)

45 
def
 ===(
rhs
: 
UI¡
): 
Boﬁ
 = 
°©e
 ===Ñhs

46 
def
 ===(
rhs
: 
Clõ¡Mëad©a
): 
Boﬁ
 = 
°©e
 ===Ñhs.state

47 
def
 =/=(
rhs
: 
Clõ¡Mëad©a
): 
Boﬁ
 = !
this
.===(rhs)

50 
def
 
	$isVÆid
(
dummy
: 
I¡
 = 0): 
Boﬁ
 = 
°©e
 > 
Clõ¡Sèãs
.
NŸhög


53 
¥iv©e
 
def
 
	$growSèπî
(
cmd
: 
UI¡
): (
Boﬁ
, UInt) = {

54 
imp‹t
 
Mem‹yOpC©eg‹õs
.
_


55 
imp‹t
 
TLPîmissi⁄s
.
_


56 
imp‹t
 
Clõ¡Sèãs
.
_


57 
vÆ
 
c
 = 
	`ˇãg‹ize
(
cmd
)

58 
	`MuxTLookup
(
	`C©
(
c
, 
°©e
), (
	`Boﬁ
(
Ál£
), 
	`UI¡
(0)), 
	`Seq
(

60 
	`C©
(
rd
, 
Dúty
Ë-> (
	`Boﬁ
(
åue
), Dirty),

61 
	`C©
(
rd
, 
Trunk
Ë-> (
	`Boﬁ
(
åue
), Trunk),

62 
	`C©
(
rd
, 
Bønch
Ë-> (
	`Boﬁ
(
åue
), Branch),

63 
	`C©
(
wi
, 
Dúty
Ë-> (
	`Boﬁ
(
åue
), Dirty),

64 
	`C©
(
wi
, 
Trunk
Ë-> (
	`Boﬁ
(
åue
), Trunk),

65 
	`C©
(
wr
, 
Dúty
Ë-> (
	`Boﬁ
(
åue
), Dirty),

66 
	`C©
(
wr
, 
Trunk
Ë-> (
	`Boﬁ
(
åue
), 
Dúty
),

68 
	`C©
(
rd
, 
NŸhög
Ë-> (
	`Boﬁ
(
Ál£
), 
NtoB
),

69 
	`C©
(
wi
, 
Bønch
Ë-> (
	`Boﬁ
(
Ál£
), 
BtoT
),

70 
	`C©
(
wi
, 
NŸhög
Ë-> (
	`Boﬁ
(
Ál£
), 
NtoT
),

71 
	`C©
(
wr
, 
Bønch
Ë-> (
	`Boﬁ
(
Ál£
), 
BtoT
),

72 
	`C©
(
wr
, 
NŸhög
Ë-> (
	`Boﬁ
(
Ál£
), 
NtoT
)))

78 
¥iv©e
 
def
 
	$growFöishî
(
cmd
: 
UI¡
, 
∑øm
: UInt): UInt = {

79 
imp‹t
 
Mem‹yOpC©eg‹õs
.
_


80 
imp‹t
 
TLPîmissi⁄s
.
_


81 
imp‹t
 
Clõ¡Sèãs
.
_


82 
vÆ
 
c
 = 
	`ˇãg‹ize
(
cmd
)

84 
	`MuxLookup
(
	`C©
(
c
, 
∑øm
), 
NŸhög
, 
	`Seq
(

86 
	`C©
(
rd
, 
toB
Ë-> 
Bønch
,

87 
	`C©
(
rd
, 
toT
Ë-> 
Trunk
,

88 
	`C©
(
wi
, 
toT
Ë-> 
Trunk
,

89 
	`C©
(
wr
, 
toT
Ë-> 
Dúty
))

90 
	}
}

94 
def
 
	$⁄Ac˚ss
(
cmd
: 
UI¡
): (
Boﬁ
, UI¡, 
Clõ¡Mëad©a
) = {

95 
vÆ
 
r
 = 
	`growSèπî
(
cmd
)

96 (
r
.
_1
,Ñ.
_2
, 
	`Clõ¡Mëad©a
(r._2))

97 
	}
}

100 
def
 
	$⁄Sec⁄d¨yAc˚ss
(
fú°_cmd
: 
UI¡
, 
£c⁄d_cmd
: UI¡): (
Boﬁ
, Boﬁ, UI¡, 
Clõ¡Mëad©a
, UInt) = {

101 
imp‹t
 
Mem‹yOpC©eg‹õs
.
_


102 
vÆ
 
r1
 = 
	`growSèπî
(
fú°_cmd
)

103 
vÆ
 
r2
 = 
	`growSèπî
(
£c⁄d_cmd
)

104 
vÆ
 
√eds_£c⁄d_acq
 = 
	`isWrôeI¡ít
(
£c⁄d_cmd
Ë&& !isWrôeI¡ít(
fú°_cmd
)

105 
vÆ
 
hô_agaö
 = 
r1
.
_1
 && 
r2
._1

106 
vÆ
 
dútõs
 = 
	`ˇãg‹ize
(
£c⁄d_cmd
Ë==
wr


107 
vÆ
 
bigge°_grow_∑øm
 = 
	`Mux
(
dútõs
, 
r2
.
_2
, 
r1
._2)

108 
vÆ
 
dútõ°_°©e
 = 
	`Clõ¡Mëad©a
(
bigge°_grow_∑øm
)

109 
vÆ
 
dútõ°_cmd
 = 
	`Mux
(
dútõs
, 
£c⁄d_cmd
, 
fú°_cmd
)

110 (
√eds_£c⁄d_acq
, 
hô_agaö
, 
bigge°_grow_∑øm
, 
dútõ°_°©e
, 
dútõ°_cmd
)

111 
	}
}

114 
def
 
	$⁄Gø¡
(
cmd
: 
UI¡
, 
∑øm
: UI¡): 
Clõ¡Mëad©a
 = 
	`Clõ¡Mëad©a
(
	$growFöishî
(
cmd
, 
∑øm
))

117 
¥iv©e
 
def
 
	$shrökHñ≥r
(
∑øm
: 
UI¡
): (
Boﬁ
, UInt, UInt) = {

118 
imp‹t
 
Clõ¡Sèãs
.
_


119 
imp‹t
 
TLPîmissi⁄s
.
_


120 
	`MuxTLookup
(
	`C©
(
∑øm
, 
°©e
), (
	`Boﬁ
(
Ál£
), 
	`UI¡
(0), UI¡(0)), 
	`Seq
(

122 
	`C©
(
toT
, 
Dúty
Ë-> (
	`Boﬁ
(
åue
), 
TtoT
, 
Trunk
),

123 
	`C©
(
toT
, 
Trunk
Ë-> (
	`Boﬁ
(
Ál£
), 
TtoT
, Trunk),

124 
	`C©
(
toT
, 
Bønch
Ë-> (
	`Boﬁ
(
Ál£
), 
BtoB
, Branch),

125 
	`C©
(
toT
, 
NŸhög
Ë-> (
	`Boﬁ
(
Ál£
), 
NtoN
, Nothing),

126 
	`C©
(
toB
, 
Dúty
Ë-> (
	`Boﬁ
(
åue
), 
TtoB
, 
Bønch
),

127 
	`C©
(
toB
, 
Trunk
Ë-> (
	`Boﬁ
(
Ál£
), 
TtoB
, 
Bønch
),

128 
	`C©
(
toB
, 
Bønch
Ë-> (
	`Boﬁ
(
Ál£
), 
BtoB
, Branch),

129 
	`C©
(
toB
, 
NŸhög
Ë-> (
	`Boﬁ
(
Ál£
), 
BtoN
, Nothing),

130 
	`C©
(
toN
, 
Dúty
Ë-> (
	`Boﬁ
(
åue
), 
TtoN
, 
NŸhög
),

131 
	`C©
(
toN
, 
Trunk
Ë-> (
	`Boﬁ
(
Ál£
), 
TtoN
, 
NŸhög
),

132 
	`C©
(
toN
, 
Bønch
Ë-> (
	`Boﬁ
(
Ál£
), 
BtoN
, 
NŸhög
),

133 
	`C©
(
toN
, 
NŸhög
Ë-> (
	`Boﬁ
(
Ál£
), 
NtoN
, Nothing)))

134 
	}
}

137 
¥iv©e
 
def
 
	$cmdToPîmC≠
(
cmd
: 
UI¡
): UInt = {

138 
imp‹t
 
Mem‹yOpC©eg‹õs
.
_


139 
imp‹t
 
TLPîmissi⁄s
.
_


140 
	`MuxLookup
(
cmd
, 
toN
, 
	`Seq
(

141 
M_FLUSH
 -> 
toN
,

142 
M_PRODUCE
 -> 
toB
,

143 
M_CLEAN
 -> 
toT
))

144 
	}
}

146 
def
 
	$⁄CacheC⁄åﬁ
(
cmd
: 
UI¡
): (
Boﬁ
, UI¡, 
Clõ¡Mëad©a
) = {

147 
vÆ
 
r
 = 
	`shrökHñ≥r
(
	`cmdToPîmC≠
(
cmd
))

148 (
r
.
_1
,Ñ.
_2
, 
	`Clõ¡Mëad©a
‘.
_3
))

149 
	}
}

151 
def
 
	$⁄Probe
(
∑øm
: 
UI¡
): (
Boﬁ
, UI¡, 
Clõ¡Mëad©a
) = {

152 
vÆ
 
r
 = 
	`shrökHñ≥r
(
∑øm
)

153 (
r
.
_1
,Ñ.
_2
, 
	`Clõ¡Mëad©a
‘.
_3
))

154 
	}
}

158 
obje˘
 
	gClõ¡Mëad©a
 {

159 
def
 
≠∂y
(
≥rm
: 
UI¡
) = {

160 
vÆ
 
mëa
 = 
Wúe
(
√w
 
Clõ¡Mëad©a
)

161 
mëa
.
°©e
 :
≥rm


162 
mëa


164 
def
 
⁄Re£t
 = 
Clõ¡Mëad©a
(
Clõ¡Sèãs
.
NŸhög
)

165 
def
 
maximum
 = 
Clõ¡Mëad©a
(
Clõ¡Sèãs
.
Dúty
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Monitor.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.{
	gSour˚Info
, 
	gSour˚Löe
}

7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gHëîogíeousBag
, 
	gPlusArg
}

11 ˛as†
	cTLM⁄ô‹Args
(
edge
: 
TLEdge
)

13 
ab°ø˘
 cœs†
	cTLM⁄ô‹Ba£
(
¨gs
: 
TLM⁄ô‹Args
Ë
exãnds
 
ModuÀ


15 
vÆ
 
io
 = 
√w
 
BundÀ
 {

16 
vÆ
 
ö
 = 
√w
 
	`TLBundÀSno›
(
¨gs
.
edge
.
bundÀ
).
Êù


19 
def
 
	$ÀgÆize
(
bundÀ
: 
TLBundÀSno›
, 
edge
: 
TLEdge
, 
ª£t
: 
Boﬁ
): 
Unô


20 
	`ÀgÆize
(
io
.
ö
, 
¨gs
.
edge
, 
ª£t
)

21 
	}
}

23 ˛as†
	cTLM⁄ô‹
(
¨gs
: 
TLM⁄ô‹Args
Ë
exãnds
 
	$TLM⁄ô‹Ba£
(
¨gs
)

25 
def
 
exåa
 = {

26 
¨gs
.
edge
.
sour˚Info
 
m©ch
 {

27 
	`Sour˚Löe
(
fûíame
, 
löe
, 
cﬁ
Ë=> 
s
" (connectedát $filename:$line:$col)"

28 
_
 => ""

32 
def
 
	`visibÀ
(
addªss
: 
UI¡
, 
sour˚
: UI¡, 
edge
: 
TLEdge
) =

33 
edge
.
˛õ¡
.
˛õ¡s
.
m≠
 { 
c
 =>

34 !
c
.
sour˚Id
.
	`c⁄èös
(
sour˚
) ||

35 
c
.
visibûôy
.
	`m≠
(
_
.
	`c⁄èös
(
addªss
)).
	`ªdu˚
(_ || _)

36 
	}
}.
	$ªdu˚
(
_
 && _)

38 
def
 
	$ÀgÆizeF‹m©A
(
bundÀ
: 
TLBundÀA
, 
edge
: 
TLEdge
) {

39 
	`as£π
 (
TLMesßges
.
	`isA
(
bundÀ
.
›code
), "'A' ch™√»ha†övÆid opcode" + 
exåa
)

42 
vÆ
 
sour˚_ok
 = 
edge
.
˛õ¡
.
	`c⁄èös
(
bundÀ
.
sour˚
)

43 
vÆ
 
is_Æig√d
 = 
edge
.
	`isAlig√d
(
bundÀ
.
addªss
, bundÀ.
size
)

44 
vÆ
 
mask
 = 
edge
.
	`fuŒ_mask
(
bundÀ
)

46 
	`as£π
 (
	`visibÀ
(
edge
.
	`addªss
(
bundÀ
), bundÀ.
sour˚
,Édge), "'A' channel carriesánáddress illegal forÅhe specified bank visibility")

48 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
AcquúeBlock
) {

49 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsAcquúeBSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†AcquúeBlockÅy≥ unsuµ‹ãd by m™agî" + 
exåa
)

50 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsProbe
”dge.
	`sour˚
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†AcquúeBlock fromá clõ¡ which d€†nŸ suµ‹àProbe" + 
exåa
)

51 
	`as£π
 (
sour˚_ok
, "'A' ch™√»AcquúeBlock c¨rõ†övÆid sour˚ ID" + 
exåa
)

52 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'A' ch™√»AcquúeBlock smÆÀ∏th™á bót" + 
exåa
)

53 
	`as£π
 (
is_Æig√d
, "'A' ch™√»AcquúeBlockáddªs†nŸálig√dÅÿsize" + 
exåa
)

54 
	`as£π
 (
TLPîmissi⁄s
.
	`isGrow
(
bundÀ
.
∑øm
), "'A' ch™√»AcquúeBlock c¨rõ†övÆid growÖ¨am" + 
exåa
)

55 
	`as£π
 (~
bundÀ
.
mask
 ==
	`UI¡
(0), "'A' ch™√»AcquúeBlock c⁄èö†övÆid mask" + 
exåa
)

56 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'A' ch™√»AcquúeBlock i†c‹ru±" + 
exåa
)

59 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
AcquúePîm
) {

60 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsAcquúeBSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†AcquúePîmÅy≥ unsuµ‹ãd by m™agî" + 
exåa
)

61 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsProbe
”dge.
	`sour˚
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†AcquúePîm fromá clõ¡ which d€†nŸ suµ‹àProbe" + 
exåa
)

62 
	`as£π
 (
sour˚_ok
, "'A' ch™√»AcquúePîm c¨rõ†övÆid sour˚ ID" + 
exåa
)

63 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'A' ch™√»AcquúePîm smÆÀ∏th™á bót" + 
exåa
)

64 
	`as£π
 (
is_Æig√d
, "'A' ch™√»AcquúePîmáddªs†nŸálig√dÅÿsize" + 
exåa
)

65 
	`as£π
 (
TLPîmissi⁄s
.
	`isGrow
(
bundÀ
.
∑øm
), "'A' ch™√»AcquúePîm c¨rõ†övÆid growÖ¨am" + 
exåa
)

66 
	`as£π
 (
bundÀ
.
∑øm
 =/
TLPîmissi⁄s
.
NtoB
, "'A' ch™√»AcquúePîmÑeque°†NtoB" + 
exåa
)

67 
	`as£π
 (~
bundÀ
.
mask
 ==
	`UI¡
(0), "'A' ch™√»AcquúePîm c⁄èö†övÆid mask" + 
exåa
)

68 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'A' ch™√»AcquúePîm i†c‹ru±" + 
exåa
)

71 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Gë
) {

72 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsGëSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†GëÅy≥ unsuµ‹ãd by m™agî" + 
exåa
)

73 
	`as£π
 (
sour˚_ok
, "'A' ch™√»Gë c¨rõ†övÆid sour˚ ID" + 
exåa
)

74 
	`as£π
 (
is_Æig√d
, "'A' ch™√»Gëáddªs†nŸálig√dÅÿsize" + 
exåa
)

75 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'A' ch™√»Gë c¨rõ†övÆidÖ¨am" + 
exåa
)

76 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'A' ch™√»Gë c⁄èö†övÆid mask" + 
exåa
)

77 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'A' ch™√»Gë i†c‹ru±" + 
exåa
)

80 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
PutFuŒD©a
) {

81 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsPutFuŒSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†PutFuŒÅy≥ unsuµ‹ãd by m™agî" + 
exåa
)

82 
	`as£π
 (
sour˚_ok
, "'A' ch™√»PutFuŒ c¨rõ†övÆid sour˚ ID" + 
exåa
)

83 
	`as£π
 (
is_Æig√d
, "'A' ch™√»PutFuŒáddªs†nŸálig√dÅÿsize" + 
exåa
)

84 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'A' ch™√»PutFuŒ c¨rõ†övÆidÖ¨am" + 
exåa
)

85 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'A' ch™√»PutFuŒ c⁄èö†övÆid mask" + 
exåa
)

88 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
PutP¨tülD©a
) {

89 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsPutP¨tülSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†PutP¨tü»ty≥ unsuµ‹ãd by m™agî" + 
exåa
)

90 
	`as£π
 (
sour˚_ok
, "'A' ch™√»PutP¨tü»ˇºõ†övÆid sour˚ ID" + 
exåa
)

91 
	`as£π
 (
is_Æig√d
, "'A' ch™√»PutP¨tü»addªs†nŸálig√dÅÿsize" + 
exåa
)

92 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'A' ch™√»PutP¨tü»ˇºõ†övÆidÖ¨am" + 
exåa
)

93 
	`as£π
 ((
bundÀ
.
mask
 & ~maskË==
	`UI¡
(0), "'A' ch™√»PutP¨tü»c⁄èö†övÆid mask" + 
exåa
)

96 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
ArôhmëicD©a
) {

97 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsArôhmëicSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†Arôhmëi¯ty≥ unsuµ‹ãd by m™agî" + 
exåa
)

98 
	`as£π
 (
sour˚_ok
, "'A' ch™√»Arôhmëi¯ˇºõ†övÆid sour˚ ID" + 
exåa
)

99 
	`as£π
 (
is_Æig√d
, "'A' ch™√»Arôhmëi¯addªs†nŸálig√dÅÿsize" + 
exåa
)

100 
	`as£π
 (
TLAtomics
.
	`isArôhmëic
(
bundÀ
.
∑øm
), "'A' ch™√»Arôhmëi¯ˇºõ†övÆid opcodê∑øm" + 
exåa
)

101 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'A' ch™√»Arôhmëi¯c⁄èö†övÆid mask" + 
exåa
)

104 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
LogiˇlD©a
) {

105 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsLogiˇlSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†Logiˇ»ty≥ unsuµ‹ãd by m™agî" + 
exåa
)

106 
	`as£π
 (
sour˚_ok
, "'A' ch™√»Logiˇ»ˇºõ†övÆid sour˚ ID" + 
exåa
)

107 
	`as£π
 (
is_Æig√d
, "'A' ch™√»Logiˇ»addªs†nŸálig√dÅÿsize" + 
exåa
)

108 
	`as£π
 (
TLAtomics
.
	`isLogiˇl
(
bundÀ
.
∑øm
), "'A' ch™√»Logiˇ»ˇºõ†övÆid opcodê∑øm" + 
exåa
)

109 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'A' ch™√»Logiˇ»c⁄èö†övÆid mask" + 
exåa
)

112 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Höt
) {

113 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsHötSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'A' ch™√»ˇºõ†Höàty≥ unsuµ‹ãd by m™agî" + 
exåa
)

114 
	`as£π
 (
sour˚_ok
, "'A' ch™√»Höàˇºõ†övÆid sour˚ ID" + 
exåa
)

115 
	`as£π
 (
is_Æig√d
, "'A' ch™√»Höàaddªs†nŸálig√dÅÿsize" + 
exåa
)

116 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'A' ch™√»Höàc⁄èö†övÆid mask" + 
exåa
)

117 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'A' ch™√»Höài†c‹ru±" + 
exåa
)

119 
	}
}

121 
def
 
	$ÀgÆizeF‹m©B
(
bundÀ
: 
TLBundÀB
, 
edge
: 
TLEdge
) {

122 
	`as£π
 (
TLMesßges
.
	`isB
(
bundÀ
.
›code
), "'B' ch™√»ha†övÆid opcode" + 
exåa
)

124 
	`as£π
 (
	`visibÀ
(
edge
.
	`addªss
(
bundÀ
), bundÀ.
sour˚
,Édge), "'B' channel carriesánáddress illegal forÅhe specified bank visibility")

127 
vÆ
 
addªss_ok
 = 
edge
.
m™agî
.
	`c⁄èösSa„
”dge.
	`addªss
(
bundÀ
))

128 
vÆ
 
is_Æig√d
 = 
edge
.
	`isAlig√d
(
bundÀ
.
addªss
, bundÀ.
size
)

129 
vÆ
 
mask
 = 
edge
.
	`fuŒ_mask
(
bundÀ
)

130 
vÆ
 
ÀgÆ_sour˚
 = 
	`Mux1H
(
edge
.
˛õ¡
.
	`föd
(
bundÀ
.
sour˚
),Édge.˛õ¡.
˛õ¡s
.
	`m≠
(
c
 => 
	`UI¡
(c.
sour˚Id
.
°¨t
))) === bundle.source

132 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Probe
) {

133 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsProbe
(
bundÀ
.
sour˚
, bundÀ.
size
), "'B' ch™√»ˇºõ†Probêty≥ unsuµ‹ãd by clõ¡" + 
exåa
)

134 
	`as£π
 (
addªss_ok
, "'B' ch™√»Probêˇºõ†unm™agedáddªss" + 
exåa
)

135 
	`as£π
 (
ÀgÆ_sour˚
, "'B' ch™√»Probêˇºõ†sour˚Åh© i†nŸ fú° sour˚" + 
exåa
)

136 
	`as£π
 (
is_Æig√d
, "'B' ch™√»Probêaddªs†nŸálig√dÅÿsize" + 
exåa
)

137 
	`as£π
 (
TLPîmissi⁄s
.
	`isC≠
(
bundÀ
.
∑øm
), "'B' ch™√»Probêˇºõ†övÆid c≠Ö¨am" + 
exåa
)

138 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'B' ch™√»Probêc⁄èö†övÆid mask" + 
exåa
)

139 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'B' ch™√»Probêi†c‹ru±" + 
exåa
)

142 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Gë
) {

143 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsGë
(
bundÀ
.
sour˚
, bundÀ.
size
), "'B' ch™√»ˇºõ†GëÅy≥ unsuµ‹ãd by clõ¡" + 
exåa
)

144 
	`as£π
 (
addªss_ok
, "'B' ch™√»Gë c¨rõ†unm™agedáddªss" + 
exåa
)

145 
	`as£π
 (
ÀgÆ_sour˚
, "'B' ch™√»Gë c¨rõ†sour˚Åh© i†nŸ fú° sour˚" + 
exåa
)

146 
	`as£π
 (
is_Æig√d
, "'B' ch™√»Gëáddªs†nŸálig√dÅÿsize" + 
exåa
)

147 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'B' ch™√»Gë c¨rõ†övÆidÖ¨am" + 
exåa
)

148 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'B' ch™√»Gë c⁄èö†övÆid mask" + 
exåa
)

149 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'B' ch™√»Gë i†c‹ru±" + 
exåa
)

152 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
PutFuŒD©a
) {

153 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsPutFuŒ
(
bundÀ
.
sour˚
, bundÀ.
size
), "'B' ch™√»ˇºõ†PutFuŒÅy≥ unsuµ‹ãd by clõ¡" + 
exåa
)

154 
	`as£π
 (
addªss_ok
, "'B' ch™√»PutFuŒ c¨rõ†unm™agedáddªss" + 
exåa
)

155 
	`as£π
 (
ÀgÆ_sour˚
, "'B' ch™√»PutFuŒ c¨rõ†sour˚Åh© i†nŸ fú° sour˚" + 
exåa
)

156 
	`as£π
 (
is_Æig√d
, "'B' ch™√»PutFuŒáddªs†nŸálig√dÅÿsize" + 
exåa
)

157 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'B' ch™√»PutFuŒ c¨rõ†övÆidÖ¨am" + 
exåa
)

158 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'B' ch™√»PutFuŒ c⁄èö†övÆid mask" + 
exåa
)

161 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
PutP¨tülD©a
) {

162 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsPutP¨tül
(
bundÀ
.
sour˚
, bundÀ.
size
), "'B' ch™√»ˇºõ†PutP¨tü»ty≥ unsuµ‹ãd by clõ¡" + 
exåa
)

163 
	`as£π
 (
addªss_ok
, "'B' ch™√»PutP¨tü»ˇºõ†unm™agedáddªss" + 
exåa
)

164 
	`as£π
 (
ÀgÆ_sour˚
, "'B' ch™√»PutP¨tü»ˇºõ†sour˚Åh© i†nŸ fú° sour˚" + 
exåa
)

165 
	`as£π
 (
is_Æig√d
, "'B' ch™√»PutP¨tü»addªs†nŸálig√dÅÿsize" + 
exåa
)

166 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'B' ch™√»PutP¨tü»ˇºõ†övÆidÖ¨am" + 
exåa
)

167 
	`as£π
 ((
bundÀ
.
mask
 & ~maskË==
	`UI¡
(0), "'B' ch™√»PutP¨tü»c⁄èö†övÆid mask" + 
exåa
)

170 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
ArôhmëicD©a
) {

171 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsArôhmëic
(
bundÀ
.
sour˚
, bundÀ.
size
), "'B' ch™√»ˇºõ†Arôhmëi¯ty≥ unsuµ‹ãd by clõ¡" + 
exåa
)

172 
	`as£π
 (
addªss_ok
, "'B' ch™√»Arôhmëi¯ˇºõ†unm™agedáddªss" + 
exåa
)

173 
	`as£π
 (
ÀgÆ_sour˚
, "'B' ch™√»Arôhmëi¯ˇºõ†sour˚Åh© i†nŸ fú° sour˚" + 
exåa
)

174 
	`as£π
 (
is_Æig√d
, "'B' ch™√»Arôhmëi¯addªs†nŸálig√dÅÿsize" + 
exåa
)

175 
	`as£π
 (
TLAtomics
.
	`isArôhmëic
(
bundÀ
.
∑øm
), "'B' ch™√»Arôhmëi¯ˇºõ†övÆid opcodê∑øm" + 
exåa
)

176 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'B' ch™√»Arôhmëi¯c⁄èö†övÆid mask" + 
exåa
)

179 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
LogiˇlD©a
) {

180 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsLogiˇl
(
bundÀ
.
sour˚
, bundÀ.
size
), "'B' ch™√»ˇºõ†Logiˇ»ty≥ unsuµ‹ãd by clõ¡" + 
exåa
)

181 
	`as£π
 (
addªss_ok
, "'B' ch™√»Logiˇ»ˇºõ†unm™agedáddªss" + 
exåa
)

182 
	`as£π
 (
ÀgÆ_sour˚
, "'B' ch™√»Logiˇ»ˇºõ†sour˚Åh© i†nŸ fú° sour˚" + 
exåa
)

183 
	`as£π
 (
is_Æig√d
, "'B' ch™√»Logiˇ»addªs†nŸálig√dÅÿsize" + 
exåa
)

184 
	`as£π
 (
TLAtomics
.
	`isLogiˇl
(
bundÀ
.
∑øm
), "'B' ch™√»Logiˇ»ˇºõ†övÆid opcodê∑øm" + 
exåa
)

185 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'B' ch™√»Logiˇ»c⁄èö†övÆid mask" + 
exåa
)

188 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Höt
) {

189 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsHöt
(
bundÀ
.
sour˚
, bundÀ.
size
), "'B' ch™√»ˇºõ†Höàty≥ unsuµ‹ãd by clõ¡" + 
exåa
)

190 
	`as£π
 (
addªss_ok
, "'B' ch™√»Höàˇºõ†unm™agedáddªss" + 
exåa
)

191 
	`as£π
 (
ÀgÆ_sour˚
, "'B' ch™√»Höàˇºõ†sour˚Åh© i†nŸ fú° sour˚" + 
exåa
)

192 
	`as£π
 (
is_Æig√d
, "'B' ch™√»Höàaddªs†nŸálig√dÅÿsize" + 
exåa
)

193 
	`as£π
 (
bundÀ
.
mask
 ==mask, "'B' ch™√»Höàc⁄èö†övÆid mask" + 
exåa
)

194 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'B' ch™√»Höài†c‹ru±" + 
exåa
)

196 
	}
}

198 
def
 
	$ÀgÆizeF‹m©C
(
bundÀ
: 
TLBundÀC
, 
edge
: 
TLEdge
) {

199 
	`as£π
 (
TLMesßges
.
	`isC
(
bundÀ
.
›code
), "'C' ch™√»ha†övÆid opcode" + 
exåa
)

201 
vÆ
 
sour˚_ok
 = 
edge
.
˛õ¡
.
	`c⁄èös
(
bundÀ
.
sour˚
)

202 
vÆ
 
is_Æig√d
 = 
edge
.
	`isAlig√d
(
bundÀ
.
addªss
, bundÀ.
size
)

203 
vÆ
 
addªss_ok
 = 
edge
.
m™agî
.
	`c⁄èösSa„
”dge.
	`addªss
(
bundÀ
))

205 
	`as£π
 (
	`visibÀ
(
edge
.
	`addªss
(
bundÀ
), bundÀ.
sour˚
,Édge), "'C' channel carriesánáddress illegal forÅhe specified bank visibility")

207 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
ProbeAck
) {

208 
	`as£π
 (
addªss_ok
, "'C' ch™√»ProbeAck c¨rõ†unm™agedáddªss" + 
exåa
)

209 
	`as£π
 (
sour˚_ok
, "'C' ch™√»ProbeAck c¨rõ†övÆid sour˚ ID" + 
exåa
)

210 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'C' ch™√»ProbeAck smÆÀ∏th™á bót" + 
exåa
)

211 
	`as£π
 (
is_Æig√d
, "'C' ch™√»ProbeAckáddªs†nŸálig√dÅÿsize" + 
exåa
)

212 
	`as£π
 (
TLPîmissi⁄s
.
	`isRï‹t
(
bundÀ
.
∑øm
), "'C' ch™√»ProbeAck c¨rõ†övÆidÑï‹à∑øm" + 
exåa
)

213 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'C' ch™√»ProbeAck i†c‹ru±" + 
exåa
)

216 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
ProbeAckD©a
) {

217 
	`as£π
 (
addªss_ok
, "'C' ch™√»ProbeAckD©®ˇºõ†unm™agedáddªss" + 
exåa
)

218 
	`as£π
 (
sour˚_ok
, "'C' ch™√»ProbeAckD©®ˇºõ†övÆid sour˚ ID" + 
exåa
)

219 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'C' ch™√»ProbeAckD©®smÆÀ∏th™á bót" + 
exåa
)

220 
	`as£π
 (
is_Æig√d
, "'C' ch™√»ProbeAckD©®addªs†nŸálig√dÅÿsize" + 
exåa
)

221 
	`as£π
 (
TLPîmissi⁄s
.
	`isRï‹t
(
bundÀ
.
∑øm
), "'C' ch™√»ProbeAckD©®ˇºõ†övÆidÑï‹à∑øm" + 
exåa
)

224 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Rñó£
) {

225 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsAcquúeBSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'C' ch™√»ˇºõ†Rñó£Åy≥ unsuµ‹ãd by m™agî" + 
exåa
)

226 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsProbe
”dge.
	`sour˚
(
bundÀ
), bundÀ.
size
), "'C' ch™√»ˇºõ†Rñó£ fromá clõ¡ which d€†nŸ suµ‹àProbe" + 
exåa
)

227 
	`as£π
 (
sour˚_ok
, "'C' ch™√»Rñó£ c¨rõ†övÆid sour˚ ID" + 
exåa
)

228 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'C' ch™√»Rñó£ smÆÀ∏th™á bót" + 
exåa
)

229 
	`as£π
 (
is_Æig√d
, "'C' ch™√»Rñó£áddªs†nŸálig√dÅÿsize" + 
exåa
)

230 
	`as£π
 (
TLPîmissi⁄s
.
	`isShrök
(
bundÀ
.
∑øm
), "'C' ch™√»Rñó£ c¨rõ†övÆid shrökÖ¨am" + 
exåa
)

231 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'C' ch™√»Rñó£ i†c‹ru±" + 
exåa
)

234 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Rñó£D©a
) {

235 
	`as£π
 (
edge
.
m™agî
.
	`suµ‹tsAcquúeBSa„
”dge.
	`addªss
(
bundÀ
), bundÀ.
size
), "'C' ch™√»ˇºõ†Rñó£D©®ty≥ unsuµ‹ãd by m™agî" + 
exåa
)

236 
	`as£π
 (
edge
.
˛õ¡
.
	`suµ‹tsProbe
”dge.
	`sour˚
(
bundÀ
), bundÀ.
size
), "'C' ch™√»ˇºõ†Rñó£ fromá clõ¡ which d€†nŸ suµ‹àProbe" + 
exåa
)

237 
	`as£π
 (
sour˚_ok
, "'C' ch™√»Rñó£D©®ˇºõ†övÆid sour˚ ID" + 
exåa
)

238 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'C' ch™√»Rñó£D©®smÆÀ∏th™á bót" + 
exåa
)

239 
	`as£π
 (
is_Æig√d
, "'C' ch™√»Rñó£D©®addªs†nŸálig√dÅÿsize" + 
exåa
)

240 
	`as£π
 (
TLPîmissi⁄s
.
	`isShrök
(
bundÀ
.
∑øm
), "'C' ch™√»Rñó£D©®ˇºõ†övÆid shrökÖ¨am" + 
exåa
)

243 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Ac˚ssAck
) {

244 
	`as£π
 (
addªss_ok
, "'C' ch™√»Ac˚ssAck c¨rõ†unm™agedáddªss" + 
exåa
)

245 
	`as£π
 (
sour˚_ok
, "'C' ch™√»Ac˚ssAck c¨rõ†övÆid sour˚ ID" + 
exåa
)

246 
	`as£π
 (
is_Æig√d
, "'C' ch™√»Ac˚ssAckáddªs†nŸálig√dÅÿsize" + 
exåa
)

247 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'C' ch™√»Ac˚ssAck c¨rõ†övÆidÖ¨am" + 
exåa
)

248 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'C' ch™√»Ac˚ssAck i†c‹ru±" + 
exåa
)

251 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Ac˚ssAckD©a
) {

252 
	`as£π
 (
addªss_ok
, "'C' ch™√»Ac˚ssAckD©®ˇºõ†unm™agedáddªss" + 
exåa
)

253 
	`as£π
 (
sour˚_ok
, "'C' ch™√»Ac˚ssAckD©®ˇºõ†övÆid sour˚ ID" + 
exåa
)

254 
	`as£π
 (
is_Æig√d
, "'C' ch™√»Ac˚ssAckD©®addªs†nŸálig√dÅÿsize" + 
exåa
)

255 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'C' ch™√»Ac˚ssAckD©®ˇºõ†övÆidÖ¨am" + 
exåa
)

258 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
HötAck
) {

259 
	`as£π
 (
addªss_ok
, "'C' ch™√»HötAck c¨rõ†unm™agedáddªss" + 
exåa
)

260 
	`as£π
 (
sour˚_ok
, "'C' ch™√»HötAck c¨rõ†övÆid sour˚ ID" + 
exåa
)

261 
	`as£π
 (
is_Æig√d
, "'C' ch™√»HötAckáddªs†nŸálig√dÅÿsize" + 
exåa
)

262 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'C' ch™√»HötAck c¨rõ†övÆidÖ¨am" + 
exåa
)

263 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'C' ch™√»HötAck i†c‹ru±" + 
exåa
)

265 
	}
}

267 
def
 
	$ÀgÆizeF‹m©D
(
bundÀ
: 
TLBundÀD
, 
edge
: 
TLEdge
) {

268 
	`as£π
 (
TLMesßges
.
	`isD
(
bundÀ
.
›code
), "'D' ch™√»ha†övÆid opcode" + 
exåa
)

270 
vÆ
 
sour˚_ok
 = 
edge
.
˛õ¡
.
	`c⁄èös
(
bundÀ
.
sour˚
)

271 
vÆ
 
sök_ok
 = 
bundÀ
.
sök
 < 
	`UI¡
(
edge
.
m™agî
.
ídSökId
)

272 
vÆ
 
díy_put_ok
 = 
	`Boﬁ
(
edge
.
m™agî
.
mayDíyPut
)

273 
vÆ
 
díy_gë_ok
 = 
	`Boﬁ
(
edge
.
m™agî
.
mayDíyGë
)

275 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Rñó£Ack
) {

276 
	`as£π
 (
sour˚_ok
, "'D' ch™√»Rñó£Ack c¨rõ†övÆid sour˚ ID" + 
exåa
)

277 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'D' ch™√»Rñó£Ack smÆÀ∏th™á bót" + 
exåa
)

278 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'D' ch™√»Rñó£eAck c¨rõ†övÆidÖ¨am" + 
exåa
)

279 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'D' ch™√»Rñó£Ack i†c‹ru±" + 
exåa
)

280 
	`as£π
 (!
bundÀ
.
díõd
, "'D' ch™√»Rñó£Ack i†díõd" + 
exåa
)

283 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Gø¡
) {

284 
	`as£π
 (
sour˚_ok
, "'D' ch™√»Gø¡ c¨rõ†övÆid sour˚ ID" + 
exåa
)

285 
	`as£π
 (
sök_ok
, "'D' ch™√»Gø¡ c¨rõ†övÆid sök ID" + 
exåa
)

286 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'D' ch™√»Gø¡ smÆÀ∏th™á bót" + 
exåa
)

287 
	`as£π
 (
TLPîmissi⁄s
.
	`isC≠
(
bundÀ
.
∑øm
), "'D' ch™√»Gø¡ c¨rõ†övÆid c≠Ö¨am" + 
exåa
)

288 
	`as£π
 (
bundÀ
.
∑øm
 =/
TLPîmissi⁄s
.
toN
, "'D' ch™√»Gø¡ c¨rõ†toNÖ¨am" + 
exåa
)

289 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'D' ch™√»Gø¡ i†c‹ru±" + 
exåa
)

290 
	`as£π
 (
díy_put_ok
 || !
bundÀ
.
díõd
, "'D' ch™√»Gø¡ i†díõd" + 
exåa
)

293 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Gø¡D©a
) {

294 
	`as£π
 (
sour˚_ok
, "'D' ch™√»Gø¡D©®ˇºõ†övÆid sour˚ ID" + 
exåa
)

295 
	`as£π
 (
sök_ok
, "'D' ch™√»Gø¡D©®ˇºõ†övÆid sök ID" + 
exåa
)

296 
	`as£π
 (
bundÀ
.
size
 >
	`UI¡
(
	`log2Ceû
(
edge
.
m™agî
.
bótByãs
)), "'D' ch™√»Gø¡D©®smÆÀ∏th™á bót" + 
exåa
)

297 
	`as£π
 (
TLPîmissi⁄s
.
	`isC≠
(
bundÀ
.
∑øm
), "'D' ch™√»Gø¡D©®ˇºõ†övÆid c≠Ö¨am" + 
exåa
)

298 
	`as£π
 (
bundÀ
.
∑øm
 =/
TLPîmissi⁄s
.
toN
, "'D' ch™√»Gø¡D©®ˇºõ†toNÖ¨am" + 
exåa
)

299 
	`as£π
 (!
bundÀ
.
díõd
 || bundÀ.
c‹ru±
, "'D' ch™√»Gø¡D©®i†díõd buànŸ c‹ru±" + 
exåa
)

300 
	`as£π
 (
díy_gë_ok
 || !
bundÀ
.
díõd
, "'D' ch™√»Gø¡D©®i†díõd" + 
exåa
)

303 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Ac˚ssAck
) {

304 
	`as£π
 (
sour˚_ok
, "'D' ch™√»Ac˚ssAck c¨rõ†övÆid sour˚ ID" + 
exåa
)

306 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'D' ch™√»Ac˚ssAck c¨rõ†övÆidÖ¨am" + 
exåa
)

307 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'D' ch™√»Ac˚ssAck i†c‹ru±" + 
exåa
)

308 
	`as£π
 (
díy_put_ok
 || !
bundÀ
.
díõd
, "'D' ch™√»Ac˚ssAck i†díõd" + 
exåa
)

311 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
Ac˚ssAckD©a
) {

312 
	`as£π
 (
sour˚_ok
, "'D' ch™√»Ac˚ssAckD©®ˇºõ†övÆid sour˚ ID" + 
exåa
)

314 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'D' ch™√»Ac˚ssAckD©®ˇºõ†övÆidÖ¨am" + 
exåa
)

315 
	`as£π
 (!
bundÀ
.
díõd
 || bundÀ.
c‹ru±
, "'D' ch™√»Ac˚ssAckD©®i†díõd buànŸ c‹ru±" + 
exåa
)

316 
	`as£π
 (
díy_gë_ok
 || !
bundÀ
.
díõd
, "'D' ch™√»Ac˚ssAckD©®i†díõd" + 
exåa
)

319 
	`whí
 (
bundÀ
.
›code
 ==
TLMesßges
.
HötAck
) {

320 
	`as£π
 (
sour˚_ok
, "'D' ch™√»HötAck c¨rõ†övÆid sour˚ ID" + 
exåa
)

322 
	`as£π
 (
bundÀ
.
∑øm
 ==
	`UI¡
(0), "'D' ch™√»HötAck c¨rõ†övÆidÖ¨am" + 
exåa
)

323 
	`as£π
 (!
bundÀ
.
c‹ru±
, "'D' ch™√»HötAck i†c‹ru±" + 
exåa
)

324 
	`as£π
 (
díy_put_ok
 || !
bundÀ
.
díõd
, "'D' ch™√»HötAck i†díõd" + 
exåa
)

326 
	}
}

328 
def
 
	$ÀgÆizeF‹m©E
(
bundÀ
: 
TLBundÀE
, 
edge
: 
TLEdge
) {

329 
vÆ
 
sök_ok
 = 
bundÀ
.
sök
 < 
	`UI¡
(
edge
.
m™agî
.
ídSökId
)

330 
	`as£π
 (
sök_ok
, "'E' ch™√l†ˇºõ†övÆid sök ID" + 
exåa
)

331 
	}
}

333 
def
 
ÀgÆizeF‹m©
(
bundÀ
: 
TLBundÀSno›
, 
edge
: 
TLEdge
) = {

334 
whí
 (
bundÀ
.
a
.
vÆid
Ë{ 
ÀgÆizeF‹m©A
(bundÀ.a.
bôs
, 
edge
) }

335 
whí
 (
bundÀ
.
d
.
vÆid
Ë{ 
ÀgÆizeF‹m©D
(bundÀ.d.
bôs
, 
edge
) }

336 i‡(
edge
.
˛õ¡
.
™ySuµ‹tProbe
 &&Édge.
m™agî
.
™ySuµ‹tAcquúeB
) {

337 
whí
 (
bundÀ
.
b
.
vÆid
Ë{ 
ÀgÆizeF‹m©B
(bundÀ.b.
bôs
, 
edge
) }

338 
whí
 (
bundÀ
.
c
.
vÆid
Ë{ 
ÀgÆizeF‹m©C
(bundÀ.c.
bôs
, 
edge
) }

339 
whí
 (
bundÀ
.
e
.
vÆid
Ë{ 
ÀgÆizeF‹m©E
(bundÀ.e.
bôs
, 
edge
) }

341 
as£π
 (!
bundÀ
.
b
.
vÆid
, "'B' ch™√»vÆidándÇŸ TL-C" + 
exåa
)

342 
as£π
 (!
bundÀ
.
c
.
vÆid
, "'C' ch™√»vÆidándÇŸ TL-C" + 
exåa
)

343 
as£π
 (!
bundÀ
.
e
.
vÆid
, "'E' ch™√»vÆidándÇŸ TL-C" + 
exåa
)

347 
def
 
	$ÀgÆizeMu…ibótA
(
a
: 
Decou∂edSno›
[
TLBundÀA
], 
edge
: 
TLEdge
) {

348 
vÆ
 
a_fú°
 = 
edge
.
	`fú°
(
a
.
bôs
,á.
	`fúe
())

349 
vÆ
 
›code
 = 
	`Reg
(
	`UI¡
())

350 
vÆ
 
∑øm
 = 
	`Reg
(
	`UI¡
())

351 
vÆ
 
size
 = 
	`Reg
(
	`UI¡
())

352 
vÆ
 
sour˚
 = 
	`Reg
(
	`UI¡
())

353 
vÆ
 
addªss
 = 
	`Reg
(
	`UI¡
())

354 
	`whí
 (
a
.
vÆid
 && !
a_fú°
) {

355 
	`as£π
 (
a
.
bôs
.
›code
 ==›code, "'A' ch™√»›codêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

356 
	`as£π
 (
a
.
bôs
.
∑øm
 ==∑øm, "'A' ch™√»∑øm ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

357 
	`as£π
 (
a
.
bôs
.
size
 ==size, "'A' ch™√»sizêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

358 
	`as£π
 (
a
.
bôs
.
sour˚
 ==sour˚, "'A' ch™√»sour˚ ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

359 
	`as£π
 (
a
.
bôs
.
addªss
==addªss,"'A' ch™√»addªs†ch™ged wôh mu…ibóà›î©i⁄" + 
exåa
)

361 
	`whí
 (
a
.
	`fúe
(Ë&& 
a_fú°
) {

362 
›code
 :
a
.
bôs
.opcode

363 
∑øm
 :
a
.
bôs
.param

364 
size
 :
a
.
bôs
.size

365 
sour˚
 :
a
.
bôs
.source

366 
addªss
 :
a
.
bôs
.address

368 
	}
}

370 
def
 
	$ÀgÆizeMu…ibótB
(
b
: 
Decou∂edSno›
[
TLBundÀB
], 
edge
: 
TLEdge
) {

371 
vÆ
 
b_fú°
 = 
edge
.
	`fú°
(
b
.
bôs
, b.
	`fúe
())

372 
vÆ
 
›code
 = 
	`Reg
(
	`UI¡
())

373 
vÆ
 
∑øm
 = 
	`Reg
(
	`UI¡
())

374 
vÆ
 
size
 = 
	`Reg
(
	`UI¡
())

375 
vÆ
 
sour˚
 = 
	`Reg
(
	`UI¡
())

376 
vÆ
 
addªss
 = 
	`Reg
(
	`UI¡
())

377 
	`whí
 (
b
.
vÆid
 && !
b_fú°
) {

378 
	`as£π
 (
b
.
bôs
.
›code
 ==›code, "'B' ch™√»›codêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

379 
	`as£π
 (
b
.
bôs
.
∑øm
 ==∑øm, "'B' ch™√»∑øm ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

380 
	`as£π
 (
b
.
bôs
.
size
 ==size, "'B' ch™√»sizêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

381 
	`as£π
 (
b
.
bôs
.
sour˚
 ==sour˚, "'B' ch™√»sour˚ ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

382 
	`as£π
 (
b
.
bôs
.
addªss
==addªss,"'B' ch™√»addªss†ch™ged wôh mu…ibóà›î©i⁄" + 
exåa
)

384 
	`whí
 (
b
.
	`fúe
(Ë&& 
b_fú°
) {

385 
›code
 :
b
.
bôs
.opcode

386 
∑øm
 :
b
.
bôs
.param

387 
size
 :
b
.
bôs
.size

388 
sour˚
 :
b
.
bôs
.source

389 
addªss
 :
b
.
bôs
.address

391 
	}
}

393 
def
 
	$ÀgÆizeMu…ibótC
(
c
: 
Decou∂edSno›
[
TLBundÀC
], 
edge
: 
TLEdge
) {

394 
vÆ
 
c_fú°
 = 
edge
.
	`fú°
(
c
.
bôs
, c.
	`fúe
())

395 
vÆ
 
›code
 = 
	`Reg
(
	`UI¡
())

396 
vÆ
 
∑øm
 = 
	`Reg
(
	`UI¡
())

397 
vÆ
 
size
 = 
	`Reg
(
	`UI¡
())

398 
vÆ
 
sour˚
 = 
	`Reg
(
	`UI¡
())

399 
vÆ
 
addªss
 = 
	`Reg
(
	`UI¡
())

400 
	`whí
 (
c
.
vÆid
 && !
c_fú°
) {

401 
	`as£π
 (
c
.
bôs
.
›code
 ==›code, "'C' ch™√»›codêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

402 
	`as£π
 (
c
.
bôs
.
∑øm
 ==∑øm, "'C' ch™√»∑øm ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

403 
	`as£π
 (
c
.
bôs
.
size
 ==size, "'C' ch™√»sizêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

404 
	`as£π
 (
c
.
bôs
.
sour˚
 ==sour˚, "'C' ch™√»sour˚ ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

405 
	`as£π
 (
c
.
bôs
.
addªss
==addªss,"'C' ch™√»addªs†ch™ged wôh mu…ibóà›î©i⁄" + 
exåa
)

407 
	`whí
 (
c
.
	`fúe
(Ë&& 
c_fú°
) {

408 
›code
 :
c
.
bôs
.opcode

409 
∑øm
 :
c
.
bôs
.param

410 
size
 :
c
.
bôs
.size

411 
sour˚
 :
c
.
bôs
.source

412 
addªss
 :
c
.
bôs
.address

414 
	}
}

416 
def
 
	$ÀgÆizeMu…ibótD
(
d
: 
Decou∂edSno›
[
TLBundÀD
], 
edge
: 
TLEdge
) {

417 
vÆ
 
d_fú°
 = 
edge
.
	`fú°
(
d
.
bôs
, d.
	`fúe
())

418 
vÆ
 
›code
 = 
	`Reg
(
	`UI¡
())

419 
vÆ
 
∑øm
 = 
	`Reg
(
	`UI¡
())

420 
vÆ
 
size
 = 
	`Reg
(
	`UI¡
())

421 
vÆ
 
sour˚
 = 
	`Reg
(
	`UI¡
())

422 
vÆ
 
sök
 = 
	`Reg
(
	`UI¡
())

423 
vÆ
 
díõd
 = 
	`Reg
(
	`Boﬁ
())

424 
	`whí
 (
d
.
vÆid
 && !
d_fú°
) {

425 
	`as£π
 (
d
.
bôs
.
›code
 ==›code, "'D' ch™√»›codêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

426 
	`as£π
 (
d
.
bôs
.
∑øm
 ==∑øm, "'D' ch™√»∑øm ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

427 
	`as£π
 (
d
.
bôs
.
size
 ==size, "'D' ch™√»sizêch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

428 
	`as£π
 (
d
.
bôs
.
sour˚
 ==sour˚, "'D' ch™√»sour˚ ch™ged wôhö mu…ibóà›î©i⁄" + 
exåa
)

429 
	`as£π
 (
d
.
bôs
.
sök
 ==sök, "'D' ch™√»sök ch™ged wôh mu…ibóà›î©i⁄" + 
exåa
)

430 
	`as£π
 (
d
.
bôs
.
díõd
 ==díõd, "'D' ch™√»díõd ch™ged wôh mu…ibóà›î©i⁄" + 
exåa
)

432 
	`whí
 (
d
.
	`fúe
(Ë&& 
d_fú°
) {

433 
›code
 :
d
.
bôs
.opcode

434 
∑øm
 :
d
.
bôs
.param

435 
size
 :
d
.
bôs
.size

436 
sour˚
 :
d
.
bôs
.source

437 
sök
 :
d
.
bôs
.sink

438 
díõd
 :
d
.
bôs
.denied

440 
	}
}

442 
def
 
	$ÀgÆizeMu…ibót
(
bundÀ
: 
TLBundÀSno›
, 
edge
: 
TLEdge
) {

443 
	`ÀgÆizeMu…ibótA
(
bundÀ
.
a
, 
edge
)

444 
	`ÀgÆizeMu…ibótD
(
bundÀ
.
d
, 
edge
)

445 i‡(
edge
.
˛õ¡
.
™ySuµ‹tProbe
 &&Édge.
m™agî
.
™ySuµ‹tAcquúeB
) {

446 
	`ÀgÆizeMu…ibótB
(
bundÀ
.
b
, 
edge
)

447 
	`ÀgÆizeMu…ibótC
(
bundÀ
.
c
, 
edge
)

449 
	}
}

451 
def
 
	$ÀgÆizeADSour˚
(
bundÀ
: 
TLBundÀSno›
, 
edge
: 
TLEdge
) {

452 
vÆ
 
öÊight
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
edge
.
˛õ¡
.
ídSour˚Id
))

454 
vÆ
 
a_fú°
 = 
edge
.
	`fú°
(
bundÀ
.
a
.
bôs
, bundÀ.a.
	`fúe
())

455 
vÆ
 
d_fú°
 = 
edge
.
	`fú°
(
bundÀ
.
d
.
bôs
, bundÀ.d.
	`fúe
())

457 
vÆ
 
a_£t
 = 
	`Wúe
(
öô
 = 
	`UI¡
(0, 
width
 = 
edge
.
˛õ¡
.
ídSour˚Id
))

458 
	`whí
 (
bundÀ
.
a
.
	`fúe
(Ë&& 
a_fú°
 && 
edge
.
	`isReque°
(bundÀ.a.
bôs
)) {

459 
a_£t
 :
	`UI¡ToOH
(
bundÀ
.
a
.
bôs
.
sour˚
)

460 
	`as£π
(!
	`öÊight
(
bundÀ
.
a
.
bôs
.
sour˚
), "'A' ch™√»ª-u£dá sour˚ ID" + 
exåa
)

463 
vÆ
 
d_˛r
 = 
	`Wúe
(
öô
 = 
	`UI¡
(0, 
width
 = 
edge
.
˛õ¡
.
ídSour˚Id
))

464 
vÆ
 
d_ªÀa£_ack
 = 
bundÀ
.
d
.
bôs
.
›code
 ==
TLMesßges
.
Rñó£Ack


465 
	`whí
 (
bundÀ
.
d
.
	`fúe
(Ë&& 
d_fú°
 && 
edge
.
	`isRe•⁄£
(bundÀ.d.
bôs
Ë&& !
d_ªÀa£_ack
) {

466 
d_˛r
 :
	`UI¡ToOH
(
bundÀ
.
d
.
bôs
.
sour˚
)

467 
	`as£π
((
a_£t
 | 
öÊight
)(
bundÀ
.
d
.
bôs
.
sour˚
), "'D' ch™√»acknowÀdged f‹ÇŸhög inÊight" + 
exåa
)

470 i‡(
edge
.
m™agî
.
möL©ícy
 > 0) {

471 
	`as£π
(
a_£t
 =/
d_˛r
 || !a_£t.
‹R
, 
s
"'A'ánd 'D' c⁄cuºít, de•ôêmöœãncy ${edge.m™agî.möL©ícy}" + 
exåa
)

474 
öÊight
 :(öÊighà| 
a_£t
Ë& ~
d_˛r


476 
vÆ
 
w©chdog
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 32))

477 
vÆ
 
limô
 = 
	`PlusArg
("tilelink_timeout",

478 
doc°rög
="KillÉmulationáfter INT waiting TileLink cycles. Off if 0.")

479 
	`as£π
 (!
öÊight
.
‹R
 || 
limô
 ==
	`UI¡
(0Ë|| 
w©chdog
 <Üimô, "TûeLökÅimeouàexpúed" + 
exåa
)

481 
w©chdog
 :w©chdog + 
	`UI¡
(1)

482 
	`whí
 (
bundÀ
.
a
.
	`fúe
(Ë|| bundÀ.
d
.fúe()Ë{ 
w©chdog
 :
	`UI¡
(0) }

483 
	}
}

485 
def
 
	$ÀgÆizeDESök
(
bundÀ
: 
TLBundÀSno›
, 
edge
: 
TLEdge
) {

486 
vÆ
 
öÊight
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
edge
.
m™agî
.
ídSökId
))

488 
vÆ
 
d_fú°
 = 
edge
.
	`fú°
(
bundÀ
.
d
.
bôs
, bundÀ.d.
	`fúe
())

489 
vÆ
 
e_fú°
 = 
	`Boﬁ
(
åue
)

491 
vÆ
 
d_£t
 = 
	`Wúe
(
öô
 = 
	`UI¡
(0, 
width
 = 
edge
.
m™agî
.
ídSökId
))

492 
	`whí
 (
bundÀ
.
d
.
	`fúe
(Ë&& 
d_fú°
 && 
edge
.
	`isReque°
(bundÀ.d.
bôs
)) {

493 
d_£t
 :
	`UI¡ToOH
(
bundÀ
.
d
.
bôs
.
sök
)

494 
	`as£π
(!
	`öÊight
(
bundÀ
.
d
.
bôs
.
sök
), "'D' ch™√»ª-u£dá sök ID" + 
exåa
)

497 
vÆ
 
e_˛r
 = 
	`Wúe
(
öô
 = 
	`UI¡
(0, 
width
 = 
edge
.
m™agî
.
ídSökId
))

498 
	`whí
 (
bundÀ
.
e
.
	`fúe
(Ë&& 
e_fú°
 && 
edge
.
	`isRe•⁄£
(bundÀ.e.
bôs
)) {

499 
e_˛r
 :
	`UI¡ToOH
(
bundÀ
.
e
.
bôs
.
sök
)

500 
	`as£π
((
d_£t
 | 
öÊight
)(
bundÀ
.
e
.
bôs
.
sök
), "'E' ch™√»acknowÀdged f‹ÇŸhög inÊight" + 
exåa
)

505 
öÊight
 :(öÊighà| 
d_£t
Ë& ~
e_˛r


506 
	}
}

508 
def
 
	$ÀgÆizeUnique
(
bundÀ
: 
TLBundÀSno›
, 
edge
: 
TLEdge
) {

509 
vÆ
 
sour˚Bôs
 = 
	`log2Ceû
(
edge
.
˛õ¡
.
ídSour˚Id
)

510 
vÆ
 
tooBig
 = 14

511 i‡(
sour˚Bôs
 > 
tooBig
) {

512 
	`¥öén
(
s
"WARNING: TLMonitor instantiated oná bus with source bits (${sourceBits}) > ${tooBig}; A=>DÅransaction flight willÇot be checked")

514 
	`ÀgÆizeADSour˚
(
bundÀ
, 
edge
)

516 i‡(
edge
.
˛õ¡
.
™ySuµ‹tProbe
 &&Édge.
m™agî
.
™ySuµ‹tAcquúeB
) {

518 
vÆ
 
sökBôs
 = 
	`log2Ceû
(
edge
.
m™agî
.
ídSökId
)

519 i‡(
sökBôs
 > 
tooBig
) {

520 
	`¥öén
(
s
"WARNING: TLMonitor instantiated oná bus with sink bits (${sinkBits}) > ${tooBig}; D=>EÅransaction flight willÇot be checked")

522 
	`ÀgÆizeDESök
(
bundÀ
, 
edge
)

525 
	}
}

527 
def
 
	$ÀgÆize
(
bundÀ
: 
TLBundÀSno›
, 
edge
: 
TLEdge
, 
ª£t
: 
Boﬁ
) {

528 
	`ÀgÆizeF‹m©
 (
bundÀ
, 
edge
)

529 
	`ÀgÆizeMu…ibót
(
bundÀ
, 
edge
)

530 
	`ÀgÆizeUnique
 (
bundÀ
, 
edge
)

531 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/NodeNumberer.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
˛ass
 
	$TLNodeNumbîîNode
(
nodeAddªssOff£t
: 
O±i⁄
[
I¡
] = 
N⁄e
)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
TLCu°omNode


11 
def
 
	`ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

12 
	`ªquúe
 (
oSèrs
 + 
iSèrs
 <1, 
s
"${name} (a customádapter)áppearsÜeft ofá :*= ${iStars}ÅimesándÑight ofá :=* ${oStars}Åimes;át most once isállowed${lazyModule.line}")

13 i‡(
oSèrs
 > 0) {

14 
	`ªquúe
 (
iKnown
 >
oKnown
, 
s
"${name} (a customádapter) has ${oKnown} outputsánd ${iKnown} inputs; cannotássign ${iKnown-oKnown}ÉdgesÅoÑesolve :=*${lazyModule.line}")

15 (0, 
iKnown
 - 
oKnown
)

17 
	`ªquúe
 (
oKnown
 >
iKnown
, 
s
"${name} (a customádapter) has ${oKnown} outputsánd ${iKnown} inputs; cannotássign ${oKnown-iKnown}ÉdgesÅoÑesolve :*=${lazyModule.line}")

18 (
oKnown
 - 
iKnown
, 0)

22 
def
 
	`m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
TLClõ¡P‹tP¨amëîs
]): Seq[TLClientPortParameters] = {

23 
	`ªquúe
(
n
 =
p
.
size
, 
s
"${name} has ${p.size} inputsánd ${n} outputs;Åhey must match${lazyModule.line}")

24 
p


27 
def
 
	`m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
TLM™agîP‹tP¨amëîs
]): Seq[TLManagerPortParameters] = {

28 
	`ªquúe
(
n
 =
p
.
size
, 
s
"${name} has ${n} inputsánd ${p.size} outputs;Åhey must match${lazyModule.line}")

29 
vÆ
 
möNodeOff£t
 = 
	`log2Ceû
(
p
.
	`m≠
(
_
.
maxAddªss
).
max
)

30 
vÆ
 
nodeOff£t
 = 
nodeAddªssOff£t
.
	`gëOrEl£
(
möNodeOff£t
)

31 
	`ªquúe
 (
nodeOff£t
 >
möNodeOff£t
)

33 
p
.
zùWôhIndex
.
m≠
 { (
mp
, 
i
) =>

34 
vÆ
 
nodeIndex
 = 
	`BigI¡
(
i
+1Ë<< 
nodeOff£t


35 
mp
.
	`c›y
(
m™agîs
 = mp.m™agîs.
	`m≠
(
m
 => m.c›y(
addªss
 = m.addªss.m≠(
a
 =>á.c›y(
ba£
 =á.ba£ | 
nodeIndex
)))))

38 
	}
}

40 
˛ass
 
	$TLNodeNumbîî
(
nodeAddªssOff£t
: 
O±i⁄
[
I¡
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


42 
vÆ
 
node
 = 
	`TLNodeNumbîîNode
(
nodeAddªssOff£t
)

44 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

45 
vÆ
 
möNodeOff£t
 = 
	`log2Ceû
(
node
.
edges
.
out
.
	`m≠
(
_
.
m™agî
.
maxAddªss
).
max
)

46 
vÆ
 
nodeOff£t
 = 
nodeAddªssOff£t
.
	`gëOrEl£
(
möNodeOff£t
)

48 (
node
.
ö
 
zù
Çode.
out
).
zùWôhIndex
 
f‹óch
 { (((ö, 
_
), (out, _)), 
i
) =>

49 
out
 <> 
ö


51 
ö
.
b
.
bôs
.
addªss
 :(
	`UI¡
(
i
+1Ë<< 
nodeOff£t
Ë| 
out
.b.bits.address

54 
	}
}

56 
obje˘
 
TLNodeNumbîî


58 
def
 
≠∂y
(
nodeAddªssOff£t
: 
O±i⁄
[
I¡
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

60 
vÆ
 
numbîî
 = 
LazyModuÀ
(
√w
 
TLNodeNumbîî
(
nodeAddªssOff£t
))

61 
numbîî
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Nodes.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gAsyncQueueP¨ams
,
	gR©i⁄ÆDúe˘i⁄
}

10 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.
Li°Buf„r


12 
obje˘
 
TLM⁄ô‹Buûdî
 
exãnds
 
	gFõld
[
TLM⁄ô‹Args
 => 
TLM⁄ô‹Ba£
](
¨gs
 => 
√w
 
	$TLM⁄ô‹
(
¨gs
))

14 
obje˘
 
TLImp
 
exãnds
 
NodeImp
[
TLClõ¡P‹tP¨amëîs
, 
TLM™agîP‹tP¨amëîs
, 
TLEdgeOut
, 
TLEdgeIn
, 
TLBundÀ
]

16 
def
 
	`edgeO
(
pd
: 
TLClõ¡P‹tP¨amëîs
, 
pu
: 
TLM™agîP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
√w
 
	`TLEdgeOut
(pd,Öu,Ö, sourceInfo)

17 
def
 
	`edgeI
(
pd
: 
TLClõ¡P‹tP¨amëîs
, 
pu
: 
TLM™agîP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
√w
 
	`TLEdgeIn
 (pd,Öu,Ö, sourceInfo)

19 
def
 
	`bundÀO
(
eo
: 
TLEdgeOut
Ë
	`TLBundÀ
”o.
bundÀ
)

20 
def
 
	`bundÀI
(
ei
: 
TLEdgeIn
Ë
	`TLBundÀ
”i.
bundÀ
)

22 
def
 
	`ªndî
(
ei
: 
TLEdgeIn
Ë
	`RídîedEdge
(
cﬁour
 = "#000000" , 
œbñ
 = (ei.
m™agî
.
bótByãs
 * 8).
toSåög
)

24 
ovîride
 
def
 
	`m⁄ô‹
(
bundÀ
: 
TLBundÀ
, 
edge
: 
TLEdgeIn
) {

25 
vÆ
 
m⁄ô‹
 = 
	`ModuÀ
(
edge
.
	`∑øms
(
TLM⁄ô‹Buûdî
)(
	`TLM⁄ô‹Args
(edge)))

26 
m⁄ô‹
.
io
.
ö
 :
	`TLBundÀSno›
(
bundÀ
, bundle)

29 
ovîride
 
def
 
	`mixO
(
pd
: 
TLClõ¡P‹tP¨amëîs
, 
node
: 
Outw¨dNode
[TLClõ¡P‹tP¨amëîs, 
TLM™agîP‹tP¨amëîs
, 
TLBundÀ
]): TLClientPortParameters =

30 
pd
.
	`c›y
(
˛õ¡s
 =Öd.˛õ¡s.
m≠
 { 
c
 => c.c›y (
nodeP©h
 = 
node
 +: c.nodePath) })

31 
ovîride
 
def
 
	`mixI
(
pu
: 
TLM™agîP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
TLClõ¡P‹tP¨amëîs
, TLM™agîP‹tP¨amëîs, 
TLBundÀ
]): TLManagerPortParameters =

32 
pu
.
	`c›y
(
m™agîs
 =Öu.m™agîs.
m≠
 { 
m
 => m.c›y (
nodeP©h
 = 
node
 +: m.nodePath) })

33 
	}
}

35 
˛ass
 
	$TLClõ¡Node
(
p‹tP¨ams
: 
Seq
[
TLClõ¡P‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$Sour˚Node
(
TLImp
)(
p‹tP¨ams
)

36 
˛ass
 
	$TLM™agîNode
(
p‹tP¨ams
: 
Seq
[
TLM™agîP‹tP¨amëîs
])(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$SökNode
(
TLImp
)(
p‹tP¨ams
)

38 
˛ass
 
	`TLAd≠ãrNode
(

39 
˛õ¡Fn
: 
TLClõ¡P‹tP¨amëîs
 => TLClõ¡P‹tP¨amëî†{ 
s
 => s 
	}
},

40 
	gm™agîFn
: 
TLM™agîP‹tP¨amëîs
 => TLM™agîP‹tP¨amëî†{ 
s
 => s })(

41 
im∂icô
 
vÆName
: 
VÆName
)

42 
exãnds
 
	$Ad≠ãrNode
(
TLImp
)(
˛õ¡Fn
, 
m™agîFn
)

44 ˛as†
	cTLIdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$IdítôyNode
(
TLImp
)()

46 
obje˘
 
TLNameNode
 {

47 
def
 
	`≠∂y
(
«me
: 
VÆName
Ë
	$TLIdítôyNode
()(
«me
)

48 
def
 
	$≠∂y
(
«me
: 
O±i⁄
[
Såög
]): 
TLIdítôyNode
 = 
	`≠∂y
(
	`VÆName
“ame.
	`gëOrEl£
("with_no_name")))

49 
def
 
	$≠∂y
(
«me
: 
Såög
): 
TLIdítôyNode
 = 
	`≠∂y
(
	`Some
(name))

52 
˛ass
 
	`TLNexusNode
(

53 
˛õ¡Fn
: 
Seq
[
TLClõ¡P‹tP¨amëîs
] => TLClientPortParameters,

54 
m™agîFn
: 
Seq
[
TLM™agîP‹tP¨amëîs
] => TLManagerPortParameters)(

55 
im∂icô
 
vÆName
: 
VÆName
)

56 
exãnds
 
	$NexusNode
(
TLImp
)(
˛õ¡Fn
, 
m™agîFn
)

58 
ab°ø˘
 
˛ass
 
	$TLCu°omNode
(
im∂icô
 
vÆName
: 
VÆName
)

59 
exãnds
 
	$Cu°omNode
(
TLImp
)

63 
obje˘
 
TLAsyncImp
 
exãnds
 
Sim∂eNodeImp
[
TLAsyncClõ¡P‹tP¨amëîs
, 
TLAsyncM™agîP‹tP¨amëîs
, 
TLAsyncEdgeP¨amëîs
, 
TLAsyncBundÀ
]

65 
def
 
	`edge
(
pd
: 
TLAsyncClõ¡P‹tP¨amëîs
, 
pu
: 
TLAsyncM™agîP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
	`TLAsyncEdgeP¨amëîs
(pd,Öu,Ö, sourceInfo)

66 
def
 
	`bundÀ
(
e
: 
TLAsyncEdgeP¨amëîs
Ë
√w
 
	`TLAsyncBundÀ
”.
bundÀ
)

67 
def
 
	`ªndî
(
e
: 
TLAsyncEdgeP¨amëîs
Ë
	`RídîedEdge
(
cﬁour
 = "#ff0000" , 
œbñ
 =É.
m™agî
.
async
.
dïth
.
toSåög
)

69 
ovîride
 
def
 
	`mixO
(
pd
: 
TLAsyncClõ¡P‹tP¨amëîs
, 
node
: 
Outw¨dNode
[TLAsyncClõ¡P‹tP¨amëîs, 
TLAsyncM™agîP‹tP¨amëîs
, 
TLAsyncBundÀ
]): TLAsyncClientPortParameters =

70 
pd
.
	`c›y
(
ba£
 =Öd.ba£.c›y(
˛õ¡s
 =Öd.ba£.˛õ¡s.
m≠
 { 
c
 => c.c›y (
nodeP©h
 = 
node
 +: c.nodePath) }))

71 
ovîride
 
def
 
	`mixI
(
pu
: 
TLAsyncM™agîP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
TLAsyncClõ¡P‹tP¨amëîs
, TLAsyncM™agîP‹tP¨amëîs, 
TLAsyncBundÀ
]): TLAsyncManagerPortParameters =

72 
pu
.
	`c›y
(
ba£
 =Öu.ba£.c›y(
m™agîs
 =Öu.ba£.m™agîs.
m≠
 { 
m
 => m.c›y (
nodeP©h
 = 
node
 +: m.nodePath) }))

73 
	}
}

75 
˛ass
 
TLAsyncAd≠ãrNode
(

76 
˛õ¡Fn
: 
TLAsyncClõ¡P‹tP¨amëîs
 => TLAsyncClõ¡P‹tP¨amëî†{ 
s
 => s },

77 
m™agîFn
: 
TLAsyncM™agîP‹tP¨amëîs
 => TLAsyncM™agîP‹tP¨amëî†{ 
s
 => s })(

78 
im∂icô
 
vÆName
: 
VÆName
)

79 
exãnds
 
	$Ad≠ãrNode
(
TLAsyncImp
)(
˛õ¡Fn
, 
m™agîFn
)

81 ˛as†
	cTLAsyncIdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$IdítôyNode
(
TLAsyncImp
)()

83 
obje˘
 
TLAsyncNameNode
 {

84 
def
 
	`≠∂y
(
«me
: 
VÆName
Ë
	$TLAsyncIdítôyNode
()(
«me
)

85 
def
 
	$≠∂y
(
«me
: 
O±i⁄
[
Såög
]): 
TLAsyncIdítôyNode
 = 
	`≠∂y
(
	`VÆName
“ame.
	`gëOrEl£
("with_no_name")))

86 
def
 
	$≠∂y
(
«me
: 
Såög
): 
TLAsyncIdítôyNode
 = 
	`≠∂y
(
	`Some
(name))

89 
˛ass
 
	$TLAsyncSour˚Node
(
sync
: 
O±i⁄
[
I¡
])(
im∂icô
 
vÆName
: 
VÆName
)

90 
exãnds
 
	$MixedAd≠ãrNode
(
TLImp
, 
TLAsyncImp
)(

91 
dFn
 = { 
p
 => 
	`TLAsyncClõ¡P‹tP¨amëîs
’Ë
	}
},

92 
	guFn
 = { 
p
 =>Ö.
ba£
.
c›y
(
möL©ícy
 =Ö.ba£.möL©ícy + 
sync
.
gëOrEl£
’.
async
.sync)) })

94 
˛ass
 
	$TLAsyncSökNode
(
async
: 
AsyncQueueP¨ams
)(
im∂icô
 
vÆName
: 
VÆName
)

95 
exãnds
 
	$MixedAd≠ãrNode
(
TLAsyncImp
, 
TLImp
)(

96 
dFn
 = { 
p
 =>Ö.
ba£
.
	`c›y
(
möL©ícy
 =Ö.ba£.möL©ícy + 
async
.
sync
Ë
	}
},

97 
	guFn
 = { 
p
 => 
TLAsyncM™agîP‹tP¨amëîs
(
async
,Ö) })

101 
obje˘
 
TLR©i⁄ÆImp
 
exãnds
 
	gSim∂eNodeImp
[
TLR©i⁄ÆClõ¡P‹tP¨amëîs
, 
TLR©i⁄ÆM™agîP‹tP¨amëîs
, 
TLR©i⁄ÆEdgeP¨amëîs
, 
TLR©i⁄ÆBundÀ
]

103 
def
 
edge
(
pd
: 
TLR©i⁄ÆClõ¡P‹tP¨amëîs
, 
pu
: 
TLR©i⁄ÆM™agîP‹tP¨amëîs
, 
p
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
Ë
TLR©i⁄ÆEdgeP¨amëîs
(pd,Öu,Ö, sourceInfo)

104 
def
 
bundÀ
(
e
: 
TLR©i⁄ÆEdgeP¨amëîs
Ë
√w
 
TLR©i⁄ÆBundÀ
(e.bundle)

105 
def
 
ªndî
(
e
: 
TLR©i⁄ÆEdgeP¨amëîs
Ë
RídîedEdge
(
cﬁour
 = "#00ff00" )

107 
ovîride
 
def
 
mixO
(
pd
: 
TLR©i⁄ÆClõ¡P‹tP¨amëîs
, 
node
: 
Outw¨dNode
[TLR©i⁄ÆClõ¡P‹tP¨amëîs, 
TLR©i⁄ÆM™agîP‹tP¨amëîs
, 
TLR©i⁄ÆBundÀ
]): TLRationalClientPortParameters =

108 
pd
.
c›y
(
ba£
 =Öd.ba£.c›y(
˛õ¡s
 =Öd.ba£.˛õ¡s.
m≠
 { 
c
 => c.c›y (
nodeP©h
 = 
node
 +: c.nodePath) }))

109 
ovîride
 
def
 
mixI
(
pu
: 
TLR©i⁄ÆM™agîP‹tP¨amëîs
, 
node
: 
Inw¨dNode
[
TLR©i⁄ÆClõ¡P‹tP¨amëîs
, TLR©i⁄ÆM™agîP‹tP¨amëîs, 
TLR©i⁄ÆBundÀ
]): TLRationalManagerPortParameters =

110 
pu
.
c›y
(
ba£
 =Öu.ba£.c›y(
m™agîs
 =Öu.ba£.m™agîs.
m≠
 { 
m
 => m.c›y (
nodeP©h
 = 
node
 +: m.nodePath) }))

113 
˛ass
 
TLR©i⁄ÆAd≠ãrNode
(

114 
˛õ¡Fn
: 
TLR©i⁄ÆClõ¡P‹tP¨amëîs
 => TLR©i⁄ÆClõ¡P‹tP¨amëî†{ 
s
 => s },

115 
m™agîFn
: 
TLR©i⁄ÆM™agîP‹tP¨amëîs
 => TLR©i⁄ÆM™agîP‹tP¨amëî†{ 
s
 => s })(

116 
im∂icô
 
vÆName
: 
VÆName
)

117 
exãnds
 
	$Ad≠ãrNode
(
TLR©i⁄ÆImp
)(
˛õ¡Fn
, 
m™agîFn
)

119 ˛as†
	cTLR©i⁄ÆIdítôyNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$IdítôyNode
(
TLR©i⁄ÆImp
)()

121 
obje˘
 
TLR©i⁄ÆNameNode
 {

122 
def
 
	`≠∂y
(
«me
: 
VÆName
Ë
	$TLR©i⁄ÆIdítôyNode
()(
«me
)

123 
def
 
	$≠∂y
(
«me
: 
O±i⁄
[
Såög
]): 
TLR©i⁄ÆIdítôyNode
 = 
	`≠∂y
(
	`VÆName
“ame.
	`gëOrEl£
("with_no_name")))

124 
def
 
	$≠∂y
(
«me
: 
Såög
): 
TLR©i⁄ÆIdítôyNode
 = 
	`≠∂y
(
	`Some
(name))

127 
˛ass
 
	$TLR©i⁄ÆSour˚Node
()(
im∂icô
 
vÆName
: 
VÆName
)

128 
exãnds
 
	$MixedAd≠ãrNode
(
TLImp
, 
TLR©i⁄ÆImp
)(

129 
dFn
 = { 
p
 => 
	`TLR©i⁄ÆClõ¡P‹tP¨amëîs
’Ë
	}
},

130 
	guFn
 = { 
p
 =>Ö.
ba£
.
c›y
(
möL©ícy
 = 1) })

132 
˛ass
 
	$TLR©i⁄ÆSökNode
(
dúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
)(
im∂icô
 
vÆName
: 
VÆName
)

133 
exãnds
 
	$MixedAd≠ãrNode
(
TLR©i⁄ÆImp
, 
TLImp
)(

134 
dFn
 = { 
p
 =>Ö.
ba£
.
	`c›y
(
möL©ícy
 = 1Ë
	}
},

135 
	guFn
 = { 
p
 => 
TLR©i⁄ÆM™agîP‹tP¨amëîs
(
dúe˘i⁄
,Ö) })

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Parameters.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gR©i⁄ÆDúe˘i⁄
,
	gAsyncQueueP¨ams
}

10 
imp‹t
 
	gsˇœ
.
	gm©h
.
max


12 
˛ass
 
TLM™agîP¨amëîs
(

13 
addªss
: 
Seq
[
AddªssSë
],

14 
ªsour˚s
: 
Seq
[
Resour˚
] = Seq(),

15 
ªgi⁄Ty≥
: 
Regi⁄Ty≥
.
T
 = Regi⁄Ty≥.
GET_EFFECTS
,

16 
execuèbÀ
: 
Boﬁón
 = 
Ál£
,

17 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

19 
suµ‹tsAcquúeT
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

20 
suµ‹tsAcquúeB
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

21 
suµ‹tsArôhmëic
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

22 
suµ‹tsLogiˇl
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

23 
suµ‹tsGë
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

24 
suµ‹tsPutFuŒ
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

25 
suµ‹tsPutP¨tül
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

26 
suµ‹tsHöt
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

28 
mayDíyGë
: 
Boﬁón
 = 
Ál£
,

29 
mayDíyPut
: 
Boﬁón
 = 
Ál£
,

31 
ÆwaysGø¡sT
: 
Boﬁón
 = 
Ál£
,

34 
fifoId
: 
O±i⁄
[
I¡
] = 
N⁄e
)

36 
ªquúe
 (!
addªss
.
isEm±y
, "Address cannot beÉmpty")

37 
addªss
.
f‹óch
 { 
a
 => 
ªquúe
 (a.
föôe
, "Address must be finite") }

39 
	gaddªss
.
combö©i⁄s
(2).
	gf‹óch
 { 
Seq
(
x
,
y
Ë=> 
ªquúe
 (!x.
ovîœps
(y), 
s
"$xánd $y overlap.") }

40 
ªquúe
 (
suµ‹tsPutFuŒ
.
c⁄èös
(
suµ‹tsPutP¨tül
), 
s
"PutFull($supportsPutFull) < PutPartial($supportsPutPartial)")

41 
ªquúe
 (
suµ‹tsPutFuŒ
.
c⁄èös
(
suµ‹tsArôhmëic
), 
s
"PutFull($supportsPutFull) < Arithmetic($supportsArithmetic)")

42 
ªquúe
 (
suµ‹tsPutFuŒ
.
c⁄èös
(
suµ‹tsLogiˇl
), 
s
"PutFull($supportsPutFull) < Logical($supportsLogical)")

43 
ªquúe
 (
suµ‹tsGë
.
c⁄èös
(
suµ‹tsArôhmëic
), 
s
"Get($supportsGet) < Arithmetic($supportsArithmetic)")

44 
ªquúe
 (
suµ‹tsGë
.
c⁄èös
(
suµ‹tsLogiˇl
), 
s
"Get($supportsGet) < Logical($supportsLogical)")

45 
ªquúe
 (
suµ‹tsAcquúeB
.
c⁄èös
(
suµ‹tsAcquúeT
), 
s
"AcquireB($supportsAcquireB) < AcquireT($supportsAcquireT)")

46 
ªquúe
 (!
ÆwaysGø¡sT
 || 
suµ‹tsAcquúeT
, 
s
"Must supportAcquireT ifÖromisingÅoálways grantT")

49 
ªquúe
 (!
suµ‹tsAcquúeB
 || 
ªgi⁄Ty≥
 >
Regi⁄Ty≥
.
UNCACHED
)

50 
ªquúe
 (
ªgi⁄Ty≥
 <
Regi⁄Ty≥
.
UNCACHED
 || 
suµ‹tsAcquúeB
)

51 
ªquúe
 (
ªgi⁄Ty≥
 !
Regi⁄Ty≥
.
UNCACHED
 || 
suµ‹tsGë
)

53 
vÆ
 
«me
 = 
nodeP©h
.
œ°O±i⁄
.
m≠
(
_
.
œzyModuÀ
.«me).
gëOrEl£
("disconnected")

54 
vÆ
 
maxTøns„r
 = 
Li°
(

55 
suµ‹tsAcquúeT
.
max
,

56 
suµ‹tsAcquúeB
.
max
,

57 
suµ‹tsArôhmëic
.
max
,

58 
suµ‹tsLogiˇl
.
max
,

59 
suµ‹tsGë
.
max
,

60 
suµ‹tsPutFuŒ
.
max
,

61 
suµ‹tsPutP¨tül
.
max
).max

62 
vÆ
 
	gmaxAddªss
 = 
addªss
.
m≠
(
_
.
max
).max

63 
vÆ
 
möAlignmít
 = 
addªss
.
m≠
(
_
.
Æignmít
).
mö


66 
ªquúe
 (
möAlignmít
 >
maxTøns„r
, 
s
"Bad $address: minAlignment ($minAlignment) must be >= maxTransfer ($maxTransfer)")

68 
def
 
	gtoResour˚
: 
Resour˚Addªss
 = {

69 
Resour˚Addªss
(
addªss
, 
Resour˚Pîmissi⁄s
(

70 
r
 = 
suµ‹tsAcquúeB
 || 
suµ‹tsGë
,

71 
w
 = 
suµ‹tsAcquúeT
 || 
suµ‹tsPutFuŒ
,

72 
x
 = 
execuèbÀ
,

73 
c
 = 
suµ‹tsAcquúeB
,

74 
a
 = 
suµ‹tsArôhmëic
 && 
suµ‹tsLogiˇl
))

77 
def
 
födTªeViﬁ©i⁄
(Ë
nodeP©h
.
föd
 {

78 
_
: 
MixedAd≠ãrNode
[_, _, _, _, _, _, _, _] => 
Ál£


79 
_
: 
SökNode
[_, _, _, _, _] => 
Ál£


80 
node
 =>Çode.
öputs
.
size
 != 1

82 
def
 
	gisTªe
 = 
födTªeViﬁ©i⁄
(Ë=
N⁄e


85 
˛ass
 
	$TLM™agîP‹tP¨amëîs
(

86 
m™agîs
: 
Seq
[
TLM™agîP¨amëîs
],

87 
bótByãs
: 
I¡
,

88 
ídSökId
: 
I¡
 = 0,

89 
möL©ícy
: 
I¡
 = 0)

91 
	`ªquúe
 (!
m™agîs
.
isEm±y
, "ManagerÖorts must have managers")

92 
	`ªquúe
 (
	`isPow2
(
bótByãs
), "Data channel width must beáÖower of 2")

93 
	`ªquúe
 (
ídSökId
 >= 0, "Sink ids cannot beÇegative")

94 
	`ªquúe
 (
möL©ícy
 >= 0, "MinimumÑequiredÜatency cannot beÇegative")

96 
def
 
	`ªquúeFifo
(Ë
m™agîs
.
f‹óch
 { 
m
 =>

97 
	`ªquúe
(
m
.
fifoId
.
isDeföed
 && m.fifoId =
m™agîs
.
hód
.fifoId, 
s
"${m.name} had fifoId ${m.fifoId}, which wasÇot homogeneous (${managers.map(s => (s.name, s.fifoId))}) ")

101 
def
 
maxAddªss
 = 
m™agîs
.
	`m≠
(
_
.maxAddªss).
max


102 
def
 
maxTøns„r
 = 
m™agîs
.
	`m≠
(
_
.maxTøns„r).
max


103 
def
 
mayDíyGë
 = 
m™agîs
.
	`exi°s
(
_
.mayDenyGet)

104 
def
 
mayDíyPut
 = 
m™agîs
.
	`exi°s
(
_
.mayDenyPut)

107 
vÆ
 
ÆlSuµ‹tAcquúeT
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsAcquúeT
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

108 
vÆ
 
ÆlSuµ‹tAcquúeB
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsAcquúeB
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

109 
vÆ
 
ÆlSuµ‹tArôhmëic
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsArôhmëic
).
	`ªdu˚
(_ 
öãr£˘
 _)

110 
vÆ
 
ÆlSuµ‹tLogiˇl
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsLogiˇl
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

111 
vÆ
 
ÆlSuµ‹tGë
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsGë
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

112 
vÆ
 
ÆlSuµ‹tPutFuŒ
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsPutFuŒ
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

113 
vÆ
 
ÆlSuµ‹tPutP¨tül
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsPutP¨tül
).
	`ªdu˚
(_ 
öãr£˘
 _)

114 
vÆ
 
ÆlSuµ‹tHöt
 = 
m™agîs
.
	`m≠
(
_
.
suµ‹tsHöt
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

117 
vÆ
 
™ySuµ‹tAcquúeT
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsAcquúeT
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

118 
vÆ
 
™ySuµ‹tAcquúeB
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsAcquúeB
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

119 
vÆ
 
™ySuµ‹tArôhmëic
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsArôhmëic
.
n⁄e
).
	`ªdu˚
(_ || _)

120 
vÆ
 
™ySuµ‹tLogiˇl
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsLogiˇl
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

121 
vÆ
 
™ySuµ‹tGë
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsGë
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

122 
vÆ
 
™ySuµ‹tPutFuŒ
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsPutFuŒ
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

123 
vÆ
 
™ySuµ‹tPutP¨tül
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsPutP¨tül
.
n⁄e
).
	`ªdu˚
(_ || _)

124 
vÆ
 
™ySuµ‹tHöt
 = 
m™agîs
.
	`m≠
(!
_
.
suµ‹tsHöt
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

127 
	`ªquúe
 ((
ídSökId
 =0Ë=!
™ySuµ‹tAcquúeB
)

130 
def
 
	`föd
(
addªss
: 
BigI¡
Ë
m™agîs
.föd(
_
.addªss.
	`exi°s
(_.
	`c⁄èös
(address)))

133 
def
 
	`födSa„
(
addªss
: 
UI¡
Ë
	`Vec
(
m™agîs
.
	`m≠
(
_
.addªss.m≠(_.
	`c⁄èös
◊ddªss)).
	`ªdu˚
(_ || _)))

135 
def
 
	`födFa°
(
addªss
: 
UI¡
) = {

136 
vÆ
 
routögMask
 = 
	`AddªssDecodî
(
m™agîs
.
	`m≠
(
_
.
addªss
))

137 
	`Vec
(
m™agîs
.
	`m≠
(
_
.
addªss
.m≠(_.
	`widí
(~
routögMask
)).
di°ö˘
.m≠(_.
	`c⁄èös
◊ddªss)).
	`ªdu˚
(_ || _)))

141 
def
 
Á°Pr›îtyGroup
[
K
](
p
: 
TLM™agîP¨amëîs
 => K): 
M≠
[K, 
Seq
[
AddªssSë
]] = {

142 
vÆ
 
groups
 = 
m™agîs
.
	`m≠
(
m
 => (
	`p
(m), m.
addªss
)).
	`groupBy
(
_
.
_1
).
	`m≠VÆues
(_.
	`Ê©M≠
(_.
_2
))

143 
vÆ
 
ªdu˘i⁄Mask
 = 
	`AddªssDecodî
(
groups
.
vÆues
.
toLi°
)

144 
groups
.
	`m≠VÆues
(
£q
 => 
AddªssSë
.
	`unify
(£q.
	`m≠
(
_
.
	`widí
(~
ªdu˘i⁄Mask
)).
di°ö˘
))

147 
def
 
Á°Pr›îty
[
K
, 
D
 <: 
D©a
](
addªss
: 
UI¡
, 
p
: 
TLM™agîP¨amëîs
 => K, 
d
: K => D): D =

148 
	`Mux1H
(
	`Á°Pr›îtyGroup
(
p
).
m≠
 { (
v
, 
a
Ë=> (a.
	`m≠
(
_
.
	`c⁄èös
(
addªss
)).
	`ªdu˚
(_||_), 
	`d
(v)) })

151 
def
 
	`födFifoIdFa°
(
addªss
: 
UI¡
Ë
	`Á°Pr›îty
◊ddªss, 
_
.
fifoId
.
	`m≠
(_+1).
	`gëOrEl£
(0), (
i
:
I¡
Ë=> 
	`UI¡
(i))

152 
def
 
	`hasFifoIdFa°
(
addªss
: 
UI¡
Ë
	`Á°Pr›îty
◊ddªss, 
_
.
fifoId
.
isDeföed
, (
b
:
Boﬁón
Ë=> 
	`Boﬁ
(b))

155 
def
 
	`c⁄èösSa„
(
addªss
: 
UI¡
Ë
	`födSa„
◊ddªss).
	`ªdu˚
(
_
 || _)

157 
¥iv©e
 
def
 
	`suµ‹tHñ≥r
(

158 
ß„
: 
Boﬁón
,

159 
membî
: 
TLM™agîP¨amëîs
 => 
Tøns„rSizes
,

160 
addªss
: 
UI¡
,

161 
lgSize
: 
UI¡
,

162 
ønge
: 
O±i⁄
[
Tøns„rSizes
]): 
Boﬁ
 = {

163 
def
 
	`åim
(
x
: 
Tøns„rSizes
Ë
ønge
.
	`m≠
(
_
.
	`öãr£˘
(x)).
	`gëOrEl£
(x)

164 
vÆ
 
suµ‹tCa£s
 = 
m™agîs
.
	`groupBy
(
m
 => 
	`åim
(
	`membî
(m))).
	`m≠VÆues
(
_
.
	`Ê©M≠
(_.
addªss
))

165 
vÆ
 
mask
 = i‡(
ß„
Ë~
	`BigI¡
(0Ë
	`AddªssDecodî
(
suµ‹tCa£s
.
vÆues
.
toLi°
)

166 
vÆ
 
sim∂ifõd
 = 
suµ‹tCa£s
.
	`m≠VÆues
(
£q
 => 
AddªssSë
.
	`unify
(£q.
	`m≠
(
_
.
	`widí
(~
mask
)).
di°ö˘
))

167 
sim∂ifõd
.
m≠
 { (
s
, 
a
) =>

168 (
	`Boﬁ
(
	`Some
(
s
Ë=
ønge
Ë|| s.
	`c⁄èösLg
(
lgSize
)) &&

169 
a
.
	`m≠
(
_
.
	`c⁄èös
(
addªss
)).
	`ªdu˚
(_||_)

170 }.
	`fﬁdLe·
(
	`Boﬁ
(
Ál£
))(
_
||_)

174 
def
 
	`suµ‹tsAcquúeTSa„
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsAcquúeT
,áddress,ÜgSize,Ñange)

175 
def
 
	`suµ‹tsAcquúeBSa„
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsAcquúeB
,áddress,ÜgSize,Ñange)

176 
def
 
	`suµ‹tsArôhmëicSa„
(
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsArôhmëic
,áddress,ÜgSize,Ñange)

177 
def
 
	`suµ‹tsLogiˇlSa„
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsLogiˇl
,áddress,ÜgSize,Ñange)

178 
def
 
	`suµ‹tsGëSa„
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsGë
,áddress,ÜgSize,Ñange)

179 
def
 
	`suµ‹tsPutFuŒSa„
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsPutFuŒ
,áddress,ÜgSize,Ñange)

180 
def
 
	`suµ‹tsPutP¨tülSa„
(
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsPutP¨tül
,áddress,ÜgSize,Ñange)

181 
def
 
	`suµ‹tsHötSa„
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
åue
, 
_
.
suµ‹tsHöt
,áddress,ÜgSize,Ñange)

183 
def
 
	`suµ‹tsAcquúeTFa°
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsAcquúeT
,áddress,ÜgSize,Ñange)

184 
def
 
	`suµ‹tsAcquúeBFa°
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsAcquúeB
,áddress,ÜgSize,Ñange)

185 
def
 
	`suµ‹tsArôhmëicFa°
(
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsArôhmëic
,áddress,ÜgSize,Ñange)

186 
def
 
	`suµ‹tsLogiˇlFa°
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsLogiˇl
,áddress,ÜgSize,Ñange)

187 
def
 
	`suµ‹tsGëFa°
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsGë
,áddress,ÜgSize,Ñange)

188 
def
 
	`suµ‹tsPutFuŒFa°
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsPutFuŒ
,áddress,ÜgSize,Ñange)

189 
def
 
	`suµ‹tsPutP¨tülFa°
(
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsPutP¨tül
,áddress,ÜgSize,Ñange)

190 
def
 
	`suµ‹tsHötFa°
 (
addªss
: 
UI¡
, 
lgSize
: UI¡, 
ønge
: 
O±i⁄
[
Tøns„rSizes
] = 
N⁄e
Ë
	`suµ‹tHñ≥r
(
Ál£
, 
_
.
suµ‹tsHöt
,áddress,ÜgSize,Ñange)

192 
def
 
	`födTªeViﬁ©i⁄
(Ë
m™agîs
.
	`Ê©M≠
(
_
.födTªeViﬁ©i⁄()).
hódO±i⁄


193 
def
 
isTªe
 = !
m™agîs
.
	`exi°s
(!
_
.isTree)

194 
	}
}

196 
˛ass
 
TLClõ¡P¨amëîs
(

197 
«me
: 
Såög
,

198 
sour˚Id
: 
IdR™ge
 = IdRange(0,1),

199 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

200 
ªque°Fifo
: 
Boﬁón
 = 
Ál£
,

201 
visibûôy
: 
Seq
[
AddªssSë
] = Seq(AddressSet(0, ~0)),

203 
suµ‹tsProbe
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

204 
suµ‹tsArôhmëic
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

205 
suµ‹tsLogiˇl
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

206 
suµ‹tsGë
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

207 
suµ‹tsPutFuŒ
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

208 
suµ‹tsPutP¨tül
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
,

209 
suµ‹tsHöt
: 
Tøns„rSizes
 = Tøns„rSizes.
n⁄e
)

211 
ªquúe
 (!
sour˚Id
.
isEm±y
)

212 
ªquúe
 (!
visibûôy
.
isEm±y
)

213 
ªquúe
 (
suµ‹tsPutFuŒ
.
c⁄èös
(
suµ‹tsPutP¨tül
))

215 
ªquúe
 (
suµ‹tsProbe
.
c⁄èös
(
suµ‹tsArôhmëic
))

216 
ªquúe
 (
suµ‹tsProbe
.
c⁄èös
(
suµ‹tsLogiˇl
))

217 
ªquúe
 (
suµ‹tsProbe
.
c⁄èös
(
suµ‹tsGë
))

218 
ªquúe
 (
suµ‹tsProbe
.
c⁄èös
(
suµ‹tsPutFuŒ
))

219 
ªquúe
 (
suµ‹tsProbe
.
c⁄èös
(
suµ‹tsPutP¨tül
))

220 
ªquúe
 (
suµ‹tsProbe
.
c⁄èös
(
suµ‹tsHöt
))

222 
visibûôy
.
combö©i⁄s
(2).
f‹óch
 { 
Seq
(
x
,
y
Ë=> 
ªquúe
 (!x.
ovîœps
(y), 
s
"$xánd $y overlap.") }

224 
vÆ
 
	gmaxTøns„r
 = 
Li°
(

225 
suµ‹tsProbe
.
max
,

226 
suµ‹tsArôhmëic
.
max
,

227 
suµ‹tsLogiˇl
.
max
,

228 
suµ‹tsGë
.
max
,

229 
suµ‹tsPutFuŒ
.
max
,

230 
suµ‹tsPutP¨tül
.
max
).
	gmax


233 
˛ass
 
	$TLClõ¡P‹tP¨amëîs
(

234 
˛õ¡s
: 
Seq
[
TLClõ¡P¨amëîs
],

235 
möL©ícy
: 
I¡
 = 0)

237 
	`ªquúe
 (!
˛õ¡s
.
isEm±y
)

238 
	`ªquúe
 (
möL©ícy
 >= 0)

241 
IdR™ge
.
	`ovîœps
(
˛õ¡s
.
	`m≠
(
_
.
sour˚Id
)).
f‹óch
 { (
x
, 
y
) =>

242 
	`ªquúe
 (!
x
.
	`ovîœps
(
y
), 
s
"TLClientParameters.sourceId ${x} overlaps ${y}")

246 
def
 
ídSour˚Id
 = 
˛õ¡s
.
	`m≠
(
_
.
sour˚Id
.
íd
).
max


247 
def
 
maxTøns„r
 = 
˛õ¡s
.
	`m≠
(
_
.maxTøns„r).
max


250 
def
 
unu£dSour˚s
: 
Seq
[
I¡
] = {

251 
vÆ
 
u£dSour˚s
 = 
˛õ¡s
.
	`m≠
(
_
.
sour˚Id
).
	`s‹tBy
(_.
°¨t
)

252 ((
	`Seq
(0Ë++ 
u£dSour˚s
.
	`m≠
(
_
.
íd
)Ë
zù
 u£dSour˚s.m≠(_.
°¨t
)Ë
Ê©M≠
 { (end, start) =>

253 
íd
 
u¡û
 
°¨t


258 
vÆ
 
ÆlSuµ‹tProbe
 = 
˛õ¡s
.
	`m≠
(
_
.
suµ‹tsProbe
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

259 
vÆ
 
ÆlSuµ‹tArôhmëic
 = 
˛õ¡s
.
	`m≠
(
_
.
suµ‹tsArôhmëic
).
	`ªdu˚
(_ 
öãr£˘
 _)

260 
vÆ
 
ÆlSuµ‹tLogiˇl
 = 
˛õ¡s
.
	`m≠
(
_
.
suµ‹tsLogiˇl
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

261 
vÆ
 
ÆlSuµ‹tGë
 = 
˛õ¡s
.
	`m≠
(
_
.
suµ‹tsGë
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

262 
vÆ
 
ÆlSuµ‹tPutFuŒ
 = 
˛õ¡s
.
	`m≠
(
_
.
suµ‹tsPutFuŒ
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

263 
vÆ
 
ÆlSuµ‹tPutP¨tül
 = 
˛õ¡s
.
	`m≠
(
_
.
suµ‹tsPutP¨tül
).
	`ªdu˚
(_ 
öãr£˘
 _)

264 
vÆ
 
ÆlSuµ‹tHöt
 = 
˛õ¡s
.
	`m≠
(
_
.
suµ‹tsHöt
Ë.
	`ªdu˚
(_ 
öãr£˘
 _)

267 
vÆ
 
™ySuµ‹tProbe
 = 
˛õ¡s
.
	`m≠
(!
_
.
suµ‹tsProbe
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

268 
vÆ
 
™ySuµ‹tArôhmëic
 = 
˛õ¡s
.
	`m≠
(!
_
.
suµ‹tsArôhmëic
.
n⁄e
).
	`ªdu˚
(_ || _)

269 
vÆ
 
™ySuµ‹tLogiˇl
 = 
˛õ¡s
.
	`m≠
(!
_
.
suµ‹tsLogiˇl
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

270 
vÆ
 
™ySuµ‹tGë
 = 
˛õ¡s
.
	`m≠
(!
_
.
suµ‹tsGë
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

271 
vÆ
 
™ySuµ‹tPutFuŒ
 = 
˛õ¡s
.
	`m≠
(!
_
.
suµ‹tsPutFuŒ
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

272 
vÆ
 
™ySuµ‹tPutP¨tül
 = 
˛õ¡s
.
	`m≠
(!
_
.
suµ‹tsPutP¨tül
.
n⁄e
).
	`ªdu˚
(_ || _)

273 
vÆ
 
™ySuµ‹tHöt
 = 
˛õ¡s
.
	`m≠
(!
_
.
suµ‹tsHöt
.
n⁄e
Ë.
	`ªdu˚
(_ || _)

276 
def
 
	`föd
(
id
: 
I¡
Ë
˛õ¡s
.föd(
_
.
sour˚Id
.
	`c⁄èös
(id))

279 
def
 
	`föd
(
id
: 
UI¡
Ë
	`Vec
(
˛õ¡s
.
	`m≠
(
_
.
sour˚Id
.
	`c⁄èös
(id)))

280 
def
 
	`c⁄èös
(
id
: 
UI¡
Ë
	`föd
(id).
	`ªdu˚
(
_
 || _)

282 
def
 
	`ªque°Fifo
(
id
: 
UI¡
Ë
	`Mux1H
(
	`föd
(id), 
˛õ¡s
.
	`m≠
(
c
 => 
	`Boﬁ
(c.
ªque°Fifo
)))

284 
¥iv©e
 
def
 
	`ß„ty_hñ≥r
(
membî
: 
TLClõ¡P¨amëîs
 => 
Tøns„rSizes
)(
id
: 
UI¡
, 
lgSize
: UInt) = {

285 
vÆ
 
ÆlSame
 = 
˛õ¡s
.
	`m≠
(
	`membî
(
_
Ë=membî(
	`˛õ¡s
(0))).
	`ªdu˚
(_ && _)

286 i‡(
ÆlSame
Ë
	`membî
(
	`˛õ¡s
(0)).
	`c⁄èösLg
(
lgSize
) {

287 
	`Mux1H
(
	`föd
(
id
), 
˛õ¡s
.
	`m≠
(
	`membî
(
_
).
	`c⁄èösLg
(
lgSize
)))

292 
vÆ
 
suµ‹tsProbe
 = 
	`ß„ty_hñ≥r
(
_
.supportsProbe) _

293 
vÆ
 
suµ‹tsArôhmëic
 = 
	`ß„ty_hñ≥r
(
_
.supportsArithmetic) _

294 
vÆ
 
suµ‹tsLogiˇl
 = 
	`ß„ty_hñ≥r
(
_
.supportsLogical) _

295 
vÆ
 
suµ‹tsGë
 = 
	`ß„ty_hñ≥r
(
_
.supportsGet) _

296 
vÆ
 
suµ‹tsPutFuŒ
 = 
	`ß„ty_hñ≥r
(
_
.supportsPutFull) _

297 
vÆ
 
suµ‹tsPutP¨tül
 = 
	`ß„ty_hñ≥r
(
_
.supportsPutPartial) _

298 
vÆ
 
suµ‹tsHöt
 = 
	`ß„ty_hñ≥r
(
_
.supportsHint) _

299 
	}
}

301 
˛ass
 
	$TLBundÀP¨amëîs
(

302 
addªssBôs
: 
I¡
,

303 
d©aBôs
: 
I¡
,

304 
sour˚Bôs
: 
I¡
,

305 
sökBôs
: 
I¡
,

306 
sizeBôs
: 
I¡
)

309 
	`ªquúe
 (
addªssBôs
 >= 1)

310 
	`ªquúe
 (
d©aBôs
 >= 8)

311 
	`ªquúe
 (
sour˚Bôs
 >= 1)

312 
	`ªquúe
 (
sökBôs
 >= 1)

313 
	`ªquúe
 (
sizeBôs
 >= 1)

314 
	`ªquúe
 (
	`isPow2
(
d©aBôs
))

316 
vÆ
 
addrLoBôs
 = 
	`log2Up
(
d©aBôs
/8)

318 
def
 (
x
: 
TLBundÀP¨amëîs
) =

319 
	`TLBundÀP¨amëîs
(

320 
	`max
(
addªssBôs
, 
x
.addressBits),

321 
	`max
(
d©aBôs
, 
x
.dataBits),

322 
	`max
(
sour˚Bôs
, 
x
.sourceBits),

323 
	`max
(
sökBôs
, 
x
.sinkBits),

324 
	`max
(
sizeBôs
, 
x
.sizeBits))

325 
	}
}

327 
obje˘
 
	gTLBundÀP¨amëîs


329 
vÆ
 
	gem±yBundÀP¨ams
 = 
TLBundÀP¨amëîs
(

330 
addªssBôs
 = 1,

331 
d©aBôs
 = 8,

332 
sour˚Bôs
 = 1,

333 
sökBôs
 = 1,

334 
sizeBôs
 = 1)

336 
def
 (
x
: 
Seq
[
TLBundÀP¨amëîs
]Ëx.
fﬁdLe·
(
em±yBundÀP¨ams
)((x,
	gy
Ë=> x.(
y
))

338 
def
 
≠∂y
(
˛õ¡
: 
TLClõ¡P‹tP¨amëîs
, 
m™agî
: 
TLM™agîP‹tP¨amëîs
) =

339 
√w
 
TLBundÀP¨amëîs
(

340 
addªssBôs
 = 
log2Up
(
m™agî
.
maxAddªss
 + 1),

341 
d©aBôs
 = 
m™agî
.
bótByãs
 * 8,

342 
sour˚Bôs
 = 
log2Up
(
˛õ¡
.
ídSour˚Id
),

343 
sökBôs
 = 
log2Up
(
m™agî
.
ídSökId
),

344 
sizeBôs
 = 
log2Up
(
log2Ceû
(
max
(
˛õ¡
.
maxTøns„r
, 
m™agî
.maxTransfer))+1))

347 
˛ass
 
	$TLEdgeP¨amëîs
(

348 
˛õ¡
: 
TLClõ¡P‹tP¨amëîs
,

349 
m™agî
: 
TLM™agîP‹tP¨amëîs
,

350 
∑øms
: 
P¨amëîs
,

351 
sour˚Info
: 
Sour˚Info
)

353 
vÆ
 
maxTøns„r
 = 
	`max
(
˛õ¡
.maxTøns„r, 
m™agî
.maxTransfer)

354 
vÆ
 
maxLgSize
 = 
	`log2Ceû
(
maxTøns„r
)

357 
	`ªquúe
 (
maxTøns„r
 >
m™agî
.
bótByãs
, 
s
"Link's maxÅransfer (${maxTransfer}) < ${manager.managers.map(_.name)}'s beatBytes (${manager.beatBytes})")

359 
vÆ
 
bundÀ
 = 
	`TLBundÀP¨amëîs
(
˛õ¡
, 
m™agî
)

360 
	}
}

362 
˛ass
 
	$TLAsyncM™agîP‹tP¨amëîs
(
async
: 
AsyncQueueP¨ams
, 
ba£
: 
TLM™agîP‹tP¨amëîs
)

363 
˛ass
 
	$TLAsyncClõ¡P‹tP¨amëîs
(
ba£
: 
TLClõ¡P‹tP¨amëîs
)

364 
˛ass
 
	$TLAsyncBundÀP¨amëîs
(
async
: 
AsyncQueueP¨ams
, 
ba£
: 
TLBundÀP¨amëîs
)

365 
˛ass
 
	$TLAsyncEdgeP¨amëîs
(
˛õ¡
: 
TLAsyncClõ¡P‹tP¨amëîs
, 
m™agî
: 
TLAsyncM™agîP‹tP¨amëîs
, 
∑øms
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
)

367 
vÆ
 
bundÀ
 = 
	`TLAsyncBundÀP¨amëîs
(
m™agî
.
async
, 
	`TLBundÀP¨amëîs
(
˛õ¡
.
ba£
, manager.base))

368 
	}
}

370 
˛ass
 
	$TLR©i⁄ÆM™agîP‹tP¨amëîs
(
dúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
, 
ba£
: 
TLM™agîP‹tP¨amëîs
)

371 
˛ass
 
	$TLR©i⁄ÆClõ¡P‹tP¨amëîs
(
ba£
: 
TLClõ¡P‹tP¨amëîs
)

373 
˛ass
 
	$TLR©i⁄ÆEdgeP¨amëîs
(
˛õ¡
: 
TLR©i⁄ÆClõ¡P‹tP¨amëîs
, 
m™agî
: 
TLR©i⁄ÆM™agîP‹tP¨amëîs
, 
∑øms
: 
P¨amëîs
, 
sour˚Info
: 
Sour˚Info
)

375 
vÆ
 
bundÀ
 = 
	`TLBundÀP¨amëîs
(
˛õ¡
.
ba£
, 
m™agî
.base)

376 
	}
}

378 
obje˘
 
	gM™agîUnifiˇti⁄


380 
def
 
≠∂y
(
m™agîs
: 
Seq
[
TLM™agîP¨amëîs
]) = {

382 
˛ass
 
TLM™agîKey
(

383 
ªsour˚s
: 
Seq
[
Resour˚
],

384 
ªgi⁄Ty≥
: 
Regi⁄Ty≥
.
T
,

385 
execuèbÀ
: 
Boﬁón
,

386 
suµ‹tsAcquúeT
: 
Tøns„rSizes
,

387 
suµ‹tsAcquúeB
: 
Tøns„rSizes
,

388 
suµ‹tsArôhmëic
: 
Tøns„rSizes
,

389 
suµ‹tsLogiˇl
: 
Tøns„rSizes
,

390 
suµ‹tsGë
: 
Tøns„rSizes
,

391 
suµ‹tsPutFuŒ
: 
Tøns„rSizes
,

392 
suµ‹tsPutP¨tül
: 
Tøns„rSizes
,

393 
suµ‹tsHöt
: 
Tøns„rSizes
)

394 
def
 
key
(
x
: 
TLM™agîP¨amëîs
Ë
TLM™agîKey
(

395 
ªsour˚s
 = 
x
.resources,

396 
ªgi⁄Ty≥
 = 
x
.regionType,

397 
execuèbÀ
 = 
x
.executable,

398 
suµ‹tsAcquúeT
 = 
x
.supportsAcquireT,

399 
suµ‹tsAcquúeB
 = 
x
.supportsAcquireB,

400 
suµ‹tsArôhmëic
 = 
x
.supportsArithmetic,

401 
suµ‹tsLogiˇl
 = 
x
.supportsLogical,

402 
suµ‹tsGë
 = 
x
.supportsGet,

403 
suµ‹tsPutFuŒ
 = 
x
.supportsPutFull,

404 
suµ‹tsPutP¨tül
 = 
x
.supportsPutPartial,

405 
suµ‹tsHöt
 = 
x
.supportsHint)

406 
vÆ
 
m≠
 = 
sˇœ
.
cﬁÀ˘i⁄
.
muèbÀ
.
HashM≠
[
TLM™agîKey
, 
TLM™agîP¨amëîs
]()

407 
	gm™agîs
.
	gf‹óch
 { 
	gm
 =>

408 
vÆ
 
k
 = 
key
(
m
)

409 
m≠
.
gë
(
k
Ë
m©ch
 {

410 
N⁄e
 => 
m≠
.
upd©e
(
k
, 
m
)

411 
Some
(
n
) => {

412 
m≠
.
upd©e
(
k
, 
m
.
c›y
(

413 
addªss
 = 
m
.addªs†++ 
n
.address,

414 
fifoId
 = 
N⁄e
))

418 
	gm≠
.
	gvÆues
.
m≠
(
m
 => m.
c›y
(
addªss
 = 
AddªssSë
.
unify
(m.addªss))).
toLi°


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/PatternPusher.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.
Sour˚Info


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
åaô
 
	gP©ã∫
 {

12 
def
 
	gaddªss
: 
BigI¡


13 
def
 
size
: 
I¡


14 
def
 
bôs
(
edge
: 
TLEdgeOut
): (
Boﬁ
, 
	gTLBundÀA
)

15 
def
 
	gd©aIn
: 
O±i⁄
[
BigI¡
] = 
N⁄e


16 
ªquúe
 ((
addªss
 & ((
BigI¡
(1Ë<< 
size
) - 1)) == 0)

19 
˛ass
 
	$WrôeP©ã∫
(
addªss
: 
BigI¡
, 
size
: 
I¡
, 
d©a
: BigI¡Ë
exãnds
 
P©ã∫


21 
	`ªquúe
 (0 <
d©a
 && d©®< (
	`BigI¡
(1Ë<< (8 << 
size
)))

22 
def
 
	`bôs
(
edge
: 
TLEdgeOut
Ëedge.
	`Put
(
	`UI¡
(0), UI¡(
addªss
), UI¡(
size
), UI¡(
d©a
 << (8*◊ddªs†%Édge.
m™agî
.
bótByãs
).
toI¡
)))

23 
	}
}

25 
˛ass
 
	$RódP©ã∫
(
addªss
: 
BigI¡
, 
size
: 
I¡
Ë
exãnds
 
P©ã∫


27 
def
 
	`bôs
(
edge
: 
TLEdgeOut
Ëedge.
	`Gë
(
	`UI¡
(0), UI¡(
addªss
), UI¡(
size
))

28 
	}
}

30 
˛ass
 
	$RódEx≥˘P©ã∫
(
addªss
: 
BigI¡
, 
size
: 
I¡
, 
d©a
: BigI¡Ë
exãnds
 
P©ã∫


32 
def
 
	`bôs
(
edge
: 
TLEdgeOut
Ëedge.
	`Gë
(
	`UI¡
(0), UI¡(
addªss
), UI¡(
size
))

33 
ovîride
 
def
 
d©aIn
 = 
	`Some
(
d©a
)

34 
	}
}

36 
˛ass
 
	$TLP©ã∫Pushî
(
«me
: 
Såög
, 
∑âîn
: 
Seq
[
P©ã∫
])(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


38 
vÆ
 
node
 = 
	`TLClõ¡Node
(
	`Seq
(
	`TLClõ¡P‹tP¨amëîs
(Seq(
	`TLClõ¡P¨amëîs
(
«me
 =Çame)))))

40 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

41 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

42 
vÆ
 
run
 = 
	`Boﬁ
(
INPUT
)

43 
vÆ
 
d⁄e
 = 
	`Boﬁ
(
OUTPUT
)

46 
	`vÆ
 (
é_out
, 
edgeOut
Ë
node
.
	`out
(0)

47 
∑âîn
.
f‹óch
 { 
p
 =>

48 
	`ªquúe
 (
p
.
size
 <
	`log2Ceû
(
edgeOut
.
m™agî
.
bótByãs
), "Patterns must fit iná single beat")

51 
vÆ
 
°ï
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
	`log2Ceû
(
∑âîn
.
size
+1)))

52 
vÆ
 
Êight
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

53 
vÆ
 
ªady
 = 
	`RegNext
(
	`Boﬁ
(
åue
), Boﬁ(
Ál£
))

55 
vÆ
 
íd
 = 
°ï
 ==
	`UI¡
(
∑âîn
.
size
)

56 
io
.
d⁄e
 :
íd
 && !
Êight


58 
vÆ
 
a
 = 
é_out
.a

59 
vÆ
 
d
 = 
é_out
.d

62 
vÆ
 
check
 = 
	`Vec
(
∑âîn
.
	`m≠
(
p
 => 
	`Boﬁ
’.
d©aIn
.
isDeföed
)))(
°ï
Ë
hﬁdU∆ess
 
a
.
	`fúe
()

63 
vÆ
 
ex≥˘
 = 
	`Vec
(
∑âîn
.
	`m≠
(
p
 => 
	`UI¡
’.
d©aIn
.
	`gëOrEl£
(
	`BigI¡
(0)))))(
°ï
Ë
hﬁdU∆ess
 
a
.
	`fúe
()

64 
	`as£π
 (!
check
 || !
d
.
	`fúe
(Ë|| 
ex≥˘
 ==d.
bôs
.
d©a
)

66 
	`whí
 (
a
.
	`fúe
()) {

67 
Êight
 :
	`Boﬁ
(
åue
)

68 
°ï
 :°ï + 
	`UI¡
(1)

70 
	`whí
 (
d
.
	`fúe
()) {

71 
Êight
 :
	`Boﬁ
(
Ál£
)

74 
	`vÆ
 (
∂egÆ
, 
pbôs
Ë
∑âîn
.
	`m≠
(
_
.
	`bôs
(
edgeOut
)).
unzù


75 
	`as£π
 (
íd
 || 
	`Vec
(
∂egÆ
)(
°ï
), 
s
"PatternÖusher ${name}ÅriedÅoÖushán illegalÑequest")

77 
a
.
vÆid
 :
io
.
run
 && 
ªady
 && !
íd
 && !
Êight


78 
a
.
bôs
 :
	`Vec
(
pbôs
)(
°ï
)

79 
d
.
ªady
 :
	`Boﬁ
(
åue
)

82 
é_out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

83 
é_out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

84 
é_out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

86 
	}
}

88 
obje˘
 
TLP©ã∫Pushî


90 
def
 
≠∂y
(
«me
: 
Såög
, 
∑âîn
: 
Seq
[
P©ã∫
])(
im∂icô
 
p
: 
P¨amëîs
): 
TLOutw¨dNode
 =

92 
vÆ
 
pushî
 = 
LazyModuÀ
(
√w
 
TLP©ã∫Pushî
(
«me
, 
∑âîn
))

93 
	gpushî
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ProbePicker.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 ˛as†
	cProbePickî
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


13 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

14 
˛õ¡Fn
 = { 
p
 =>

17 
def
 
	`comböe
(
√xt
: 
TLClõ¡P¨amëîs
, 
∑ú
: (TLClõ¡P¨amëîs, 
Seq
[TLClientParameters])) = {

18 
	`vÆ
 (
hód
, 
ouçut
Ë
∑ú


19 i‡(
hód
.
visibûôy
.
	`exi°s
(
x
 => 
√xt
.visibûôy.exi°s(
_
.
	`ovîœps
(x)))) {

20 (
√xt
, 
hód
 +: 
ouçut
)

22 
def
 
	`ªda˘
(
x
: 
TLClõ¡P¨amëîs
Ëx.
	`c›y
(
sour˚Id
 = 
	`IdR™ge
(0,1), 
nodeP©h
 = 
Nû
, 
visibûôy
 = 
	`Seq
(
	`AddªssSë
(0, ~0)))

23 
	`ªquúe
 (
	`ªda˘
(
√xt
Ë=ªda˘(
hód
))

24 
vÆ
 
mîge
 = 
hód
.
	`c›y
(

25 
sour˚Id
 = 
	`IdR™ge
(

26 
hód
.
sour˚Id
.
°¨t
 
mö
 
√xt
.sourceId.start,

27 
hód
.
sour˚Id
.
íd
 
max
 
√xt
.sourceId.end),

28 
visibûôy
 = 
AddªssSë
.
	`unify
(
hód
.visibûôy ++ 
√xt
.visibility))

29 (
mîge
, 
ouçut
)

32 
vÆ
 
myNû
: 
Seq
[
TLClõ¡P¨amëîs
] = 
Nû


33 
	`vÆ
 (
hód
, 
ouçut
Ë
p
.
˛õ¡s
.
öô
.
	`fﬁdRight
(’.˛õ¡s.
œ°
, 
myNû
))(
comböe
)

34 
p
.
	`c›y
(
˛õ¡s
 = 
hód
 +: 
ouçut
)

36 
m™agîFn
 = { 
p
 =>Ö 
	}
})

38 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

39 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

40 
out
 <> 
ö


43 i‡(
edgeIn
.
˛õ¡
.
˛õ¡s
.
size
 !
edgeOut
.client.clients.size) {

44 
ö
.
b
.
bôs
.
sour˚
 :
	`Mux1H
(

45 
edgeOut
.
˛õ¡
.
˛õ¡s
.
	`m≠
(
_
.
sour˚Id
 
c⁄èös
 
out
.
b
.
bôs
.
sour˚
),

46 
edgeOut
.
˛õ¡
.
˛õ¡s
.
m≠
 { 
c
 =>

47 
vÆ
 
b™ks
 = 
edgeIn
.
˛õ¡
.
˛õ¡s
.
	`fûãr
(
c
.
sour˚Id
 
c⁄èös
 
_
.sourceId)

48 i‡(
b™ks
.
size
 == 1) {

49 
out
.
b
.
bôs
.
sour˚


51 
	`Mux1H
(

52 
b™ks
.
	`m≠
(
_
.
visibûôy
.m≠(_ 
c⁄èös
 
out
.
b
.
bôs
.
addªss
).
	`ªdu˚
(_ || _)),

53 
b™ks
.
	`m≠
(
_
.
sour˚Id
.
°¨t
.
U
))

59 
	}
}

62 
obje˘
 
	gProbePickî


64 
def
 
≠∂y
()(
im∂icô
 
	gp
: 
P¨amëîs
): 
TLNode
 = {

65 
vÆ
 
pickî
 = 
LazyModuÀ
(
√w
 
ProbePickî
)

66 
pickî
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RAMModel.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


25 
˛ass
 
TLRAMModñ
(
log
: 
Såög
 = "", 
ign‹eC‹ru±D©a
: 
Boﬁón
 = 
Ál£
, 
ign‹eDíõdD©a
: Boﬁó¿
åue
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


27 
vÆ
 
node
 = 
TLAd≠ãrNode
()

29 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
LazyModuÀImp
(
this
) {

30 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

31 
vÆ
 
edge
 = 
edgeIn


32 
vÆ
 
ídAddªss
 = 
edge
.
m™agî
.
maxAddªss
 + 1

33 
vÆ
 
ídSour˚Id
 = 
edge
.
˛õ¡
.endSourceId

34 
vÆ
 
maxTøns„r
 = 
edge
.
m™agî
.maxTransfer

35 
vÆ
 
bótByãs
 = 
edge
.
m™agî
.beatBytes

36 
vÆ
 
ídAddªssHi
 = (
ídAddªss
 / 
bótByãs
).
ötVÆue


37 
vÆ
 
maxLgBóts
 = 
log2Up
(
maxTøns„r
/
bótByãs
)

38 
vÆ
 
shi·
 = 
log2Ceû
(
bótByãs
)

39 
vÆ
 
decTªes
 = 
log2Up
(
maxTøns„r
/
bótByãs
)

40 
vÆ
 
addªssBôs
 = 
log2Up
(
ídAddªss
)

41 
vÆ
 
cou¡Bôs
 = 
log2Up
(
ídSour˚Id
)

42 
vÆ
 
sizeBôs
 = 
edge
.
bundÀ
.sizeBits

43 
vÆ
 
divis‹
 = 
CRC
.
CRC_16F_4_2


46 
vÆ
 
wùeIndex
 = 
RegInô
(
UI¡
(0, 
width
 = 
log2Ceû
(
ídAddªssHi
) + 1))

47 
vÆ
 
wùe
 = !
wùeIndex
(
log2Ceû
(
ídAddªssHi
))

48 
wùeIndex
 :wùeIndex + 
wùe
.
asUI¡


51 
ö
.
a
.
ªady
 :
out
.a.ªady && !
wùe


52 
out
.
a
.
vÆid
 :
ö
.a.vÆid && !
wùe


53 
out
.
a
.
bôs
 :
ö
.a.bits

54 
out
.
d
.
ªady
 :
ö
.d.ªady && !
wùe


55 
ö
.
d
.
vÆid
 :
out
.d.vÆid && !
wùe


56 
ö
.
d
.
bôs
 :
out
.d.bits

59 
ö
.
b
.
vÆid
 :
Boﬁ
(
Ál£
)

60 
out
.
c
.
vÆid
 :
Boﬁ
(
Ál£
)

61 
out
.
e
.
vÆid
 :
Boﬁ
(
Ál£
)

62 
out
.
b
.
ªady
 :
Boﬁ
(
åue
)

63 
ö
.
c
.
ªady
 :
Boﬁ
(
åue
)

64 
ö
.
e
.
ªady
 :
Boﬁ
(
åue
)

66 
vÆ
 
∑øms
 = 
TLRAMModñ
.
M⁄ô‹P¨amëîs
(
addªssBôs
, 
sizeBôs
)

69 
vÆ
 
	gshadow
 = 
Seq
.
fûl
(
bótByãs
Ë{ 
Mem
(
ídAddªssHi
, 
√w
 
TLRAMModñ
.
ByãM⁄ô‹
(
∑øms
)) }

70 
vÆ
 
öc_byãs
 = 
Seq
.
fûl
(
bótByãs
Ë{ 
Mem
(
ídAddªssHi
, 
UI¡
(
width
 = 
cou¡Bôs
)) }

71 
vÆ
 
	gdec_byãs
 = 
Seq
.
fûl
(
bótByãs
Ë{ 
Mem
(
ídAddªssHi
, 
UI¡
(
width
 = 
cou¡Bôs
)) }

72 
vÆ
 
	göc_åìs
 = 
Seq
.
èbuœã
(
decTªes
Ë{ 
i
 => 
Mem
(
ídAddªssHi
 >> (i+1), 
UI¡
(
width
 = 
cou¡Bôs
)) }

73 
vÆ
 
	gdec_åìs
 = 
Seq
.
èbuœã
(
decTªes
Ë{ 
i
 => 
Mem
(
ídAddªssHi
 >> (i+1), 
UI¡
(
width
 = 
cou¡Bôs
)) }

75 
vÆ
 
	gshadow_wí
 = 
Wúe
(
öô
 = 
Fûl
(
bótByãs
, 
wùe
))

76 
vÆ
 
	göc_byãs_wí
 = 
Wúe
(
öô
 = 
Fûl
(
bótByãs
, 
wùe
))

77 
vÆ
 
	gdec_byãs_wí
 = 
Wúe
(
öô
 = 
Fûl
(
bótByãs
, 
wùe
))

78 
vÆ
 
	göc_åìs_wí
 = 
Wúe
(
öô
 = 
Fûl
(
decTªes
, 
wùe
))

79 
vÆ
 
	gdec_åìs_wí
 = 
Wúe
(
öô
 = 
Fûl
(
decTªes
, 
wùe
))

82 
vÆ
 
	gÊight
 = 
Reg
(
Vec
(
ídSour˚Id
, 
√w
 
TLRAMModñ
.
FlightM⁄ô‹
(
∑øms
)))

83 
vÆ
 
	gvÆid
 = 
Reg
(
Vec
(
ídSour˚Id
, 
Boﬁ
()))

86 
vÆ
 
	ga_Êight
 = 
Wúe
(
√w
 
TLRAMModñ
.
FlightM⁄ô‹
(
∑øms
))

87 
a_Êight
.
ba£
 :
edge
.
addªss
(
ö
.
a
.
bôs
)

88 
a_Êight
.
size
 :
edge
.size(
ö
.
a
.
bôs
)

89 
a_Êight
.
›code
 :
ö
.
a
.
bôs
.opcode

91 
whí
 (
ö
.
a
.
fúe
()Ë{ 
Êight
(ö.a.
bôs
.
sour˚
Ë:
a_Êight
 }

92 
vÆ
 
by∑ss
 = i‡(
edge
.
m™agî
.
möL©ícy
 > 0Ë
Boﬁ
(
Ál£
Ë
ö
.
a
.
vÆid
 && in.a.
bôs
.
sour˚
 ==
out
.
d
.bits.source

93 
vÆ
 
d_Êight
 = 
RegE«bÀ
(
Mux
(
by∑ss
, 
a_Êight
, 
Êight
(
out
.
d
.
bôs
.
sour˚
)), 
edge
.
fú°
(out.d))

96 
vÆ
 
	ga
 = 
Reg
(
√xt
 = 
ö
.
a
.
bôs
)

97 
vÆ
 
a_fúe
 = 
Reg
(
√xt
 = 
ö
.
a
.
fúe
(), 
öô
 = 
Boﬁ
(
Ál£
))

98 
vÆ
 (
a_fú°
, 
a_œ°
, 
_
, 
a_addªss_öc
Ë
edge
.
addr_öc
(
a
, 
a_fúe
)

99 
vÆ
 
	ga_size
 = 
edge
.
size
(
a
)

100 
vÆ
 
a_sizeOH
 = 
UI¡ToOH
(
a_size
)

101 
vÆ
 
a_addªss
 = 
a
.
addªss
 | 
a_addªss_öc


102 
vÆ
 
a_addr_hi
 = 
edge
.
addr_hi
(
a_addªss
)

103 
vÆ
 
a_ba£
 = 
edge
.
addªss
(
a
)

104 
vÆ
 
a_mask
 = 
edge
.
mask
(
a_ba£
, 
a_size
)

105 
vÆ
 
	ga_fifo
 = 
edge
.
m™agî
.
hasFifoIdFa°
(
a_ba£
Ë&&Édge.
˛õ¡
.
ªque°Fifo
(
a
.
sour˚
)

108 
vÆ
 
a_öc_byãs
 = 
öc_byãs
.
m≠
(
_
.
ªad
(
a_addr_hi
))

109 
vÆ
 
a_dec_byãs
 = 
dec_byãs
.
m≠
(
_
.
ªad
(
a_addr_hi
))

110 
vÆ
 
a_öc_åìs
 = 
öc_åìs
.
zùWôhIndex
.
m≠
{ (
m
, 
i
Ë=> m.
ªad
(
a_addr_hi
 >> (i+1)) }

111 
vÆ
 
	ga_dec_åìs
 = 
dec_åìs
.
zùWôhIndex
.
m≠
{ (
m
, 
i
Ë=> m.
ªad
(
a_addr_hi
 >> (i+1)) }

112 
vÆ
 
	ga_öc_åì
 = 
a_öc_åìs
.
fﬁd
(
UI¡
(0))(
_
 + _)

113 
vÆ
 
a_dec_åì
 = 
a_dec_åìs
.
fﬁd
(
UI¡
(0))(
_
 + _)

114 
vÆ
 
a_öc
 = 
a_öc_byãs
.
m≠
(
_
 + 
a_öc_åì
)

115 
vÆ
 
a_dec
 = 
a_dec_byãs
.
m≠
(
_
 + 
a_dec_åì
)

117 
whí
 (
a_fúe
) {

119 
as£π
 (
a
.
›code
 =/
TLMesßges
.
AcquúeBlock
 &&á.›codê=/TLMesßges.
AcquúePîm
)

122 
vÆid
(
a
.
sour˚
Ë:
Boﬁ
(
åue
)

125 
whí
 (
a_fú°
 && 
a
.
›code
 =/
TLMesßges
.
Höt
 &&á.›codê=/TLMesßges.
Gë
) {

126 
whí
 (
a_size
 <
UI¡
(
shi·
)) {

127 
öc_byãs_wí
 :
a_mask


129 
öc_åìs_wí
 :
a_sizeOH
 >> (
shi·
+1)

132 
whí
 (
a
.
›code
 ==
TLMesßges
.
PutFuŒD©a
 ||á.›codê==TLMesßges.
PutP¨tülD©a
 ||

133 
a
.
›code
 ==
TLMesßges
.
ArôhmëicD©a
 ||á.›codê==TLMesßges.
LogiˇlD©a
) {

134 
shadow_wí
 :
a
.
mask


135 
i
 <- 0 
u¡û
 
bótByãs
) {

136 
vÆ
 
busy
 = 
a_öc
(
i
Ë- 
a_dec
(iË- (!
a_fú°
).
asUI¡


137 
vÆ
 
byã
 = 
a
.
d©a
(8*(
i
+1)-1, 8*i)

138 
whí
 (
a
.
mask
(
i
)) {

139 
¥ötf
(
log
 + " ")

140 
whí
 (
a
.
›code
 ==
TLMesßges
.
PutFuŒD©a
Ë{ 
¥ötf
("PF") }

141 
whí
 (
a
.
›code
 ==
TLMesßges
.
PutP¨tülD©a
Ë{ 
¥ötf
("PP") }

142 
whí
 (
a
.
›code
 ==
TLMesßges
.
ArôhmëicD©a
Ë{ 
¥ötf
("A ") }

143 
whí
 (
a
.
›code
 ==
TLMesßges
.
LogiˇlD©a
Ë{ 
¥ötf
("L ") }

144 
¥ötf
(" 0x%x :0x%x #%d %x\n", 
a_addr_hi
 << 
shi·
 | 
UI¡
(
i
), 
byã
, 
busy
, 
a
.
∑øm
)

149 
whí
 (
a
.
›code
 ==
TLMesßges
.
Gë
) {

150 
¥ötf
(
log
 + " G 0x%x - 0x%x\n", 
a_ba£
,á_ba£ | 
UI¡ToOH1
(
a_size
, 
addªssBôs
))

154 
vÆ
 
	ga_waddr
 = 
Mux
(
wùe
, 
wùeIndex
, 
a_addr_hi
)

155 
vÆ
 
	ga_shadow
 = 
shadow
.
m≠
(
_
.
ªad
(
a_waddr
))

156 
vÆ
 
a_known_ﬁd
 = !(
C©
(
a_shadow
.
m≠
(!
_
.
vÆid
).
ªvî£
Ë& 
a_mask
).
‹R


157 
vÆ
 
Æu
 = 
ModuÀ
(
√w
 
Atomics
(
a
.
∑øms
))

158 
Æu
.
io
.
wrôe
 :
Boﬁ
(
Ál£
)

159 
Æu
.
io
.
a
 :=á

160 
Æu
.
io
.
d©a_ö
 :
C©
(
a_shadow
.
m≠
(
_
.
vÆue
).
ªvî£
)

162 
vÆ
 
¸c
 = 
Mem
(
ídSour˚Id
, 
UI¡
(
width
 = 16))

163 
vÆ
 
¸c_vÆid
 = 
Mem
(
ídSour˚Id
, 
Boﬁ
())

164 
vÆ
 
	ga_¸c_acc
 = 
Mux
(
a_fú°
, 
UI¡
(0), 
¸c
(
a
.
sour˚
))

165 
vÆ
 
	ga_¸c_√w
 = 
C©
(
a_shadow
.
zùWôhIndex
.
m≠
 { (
z
, 
i
Ë=> 
Mux
(
a_mask
(i), z.
vÆue
, 
UI¡
(0)Ë}.
ªvî£
)

166 
vÆ
 
	ga_¸c
 = 
CRC
(
divis‹
, 
C©
(
a_¸c_acc
, 
a_¸c_√w
), 16 + 
bótByãs
*8)

167 
vÆ
 
	ga_¸c_vÆid
 = 
a_known_ﬁd
 && 
Mux
(
a_fú°
, 
Boﬁ
(
åue
), 
¸c_vÆid
(
a
.
sour˚
))

168 
whí
 (
a_fúe
) {

169 
	g¸c
.
wrôe
(
a
.
sour˚
, 
a_¸c
)

170 
	g¸c_vÆid
.
wrôe
(
a
.
sour˚
, 
a_¸c_vÆid
)

173 
	gi
 <- 0 
u¡û
 
	gbótByãs
) {

174 
vÆ
 
	gd©a
 = 
Wúe
(
√w
 
TLRAMModñ
.
ByãM⁄ô‹
(
∑øms
))

175 
vÆ
 
busy
 = 
a_öc
(
i
Ë=/
a_dec
(iË+ (!
a_fú°
).
asUI¡


176 
vÆ
 
amo
 = 
a
.
›code
 ==
TLMesßges
.
ArôhmëicD©a
 ||á.›codê==TLMesßges.
LogiˇlD©a


177 
vÆ
 
bót_amo
 = 
a
.
size
 <
UI¡
(
log2Ceû
(
bótByãs
))

178 
d©a
.
vÆid
 :
Mux
(
wùe
, 
Boﬁ
(
Ál£
), (!
busy
 || 
a_fifo
Ë&& (!
amo
 || (
a_known_ﬁd
 && 
bót_amo
)))

179 
	gd©a
.
	gvÆue
 :
Æu
.
io
.
d©a_out
(8*(
i
+1)-1, 8*i)

180 
whí
 (
shadow_wí
(
i
)) {

181 
shadow
(
i
).
wrôe
(
a_waddr
, 
d©a
)

185 
	gi
 <- 0 
u¡û
 
	gbótByãs
) {

186 
vÆ
 
	gd©a
 = 
Mux
(
wùe
, 
UI¡
(0), 
a_öc_byãs
(
i
) + UInt(1))

187 
whí
 (
öc_byãs_wí
(
i
)) {

188 
öc_byãs
(
i
).
wrôe
(
a_waddr
, 
d©a
)

192 
	gi
 <- 0 
u¡û
 
	göc_åìs
.
	gsize
) {

193 
vÆ
 
	gd©a
 = 
Mux
(
wùe
, 
UI¡
(0), 
a_öc_åìs
(
i
) + UInt(1))

194 
whí
 (
öc_åìs_wí
(
i
)) {

195 
öc_åìs
(
i
).
wrôe
(
a_waddr
 >> (i+1), 
d©a
)

200 
vÆ
 
	gd
 = 
RegNext
(
out
.
d
.
bôs
)

201 
vÆ
 
d_fúe
 = 
Reg
(
√xt
 = 
out
.
d
.
fúe
(), 
öô
 = 
Boﬁ
(
Ál£
))

202 
vÆ
 (
d_fú°
, 
d_œ°
, 
_
, 
d_addªss_öc
Ë
edge
.
addr_öc
(
d
, 
d_fúe
)

203 
vÆ
 
	gd_size
 = 
edge
.
size
(
d
)

204 
vÆ
 
d_sizeOH
 = 
UI¡ToOH
(
d_size
)

205 
vÆ
 
d_ba£
 = 
d_Êight
.
ba£


206 
vÆ
 
d_addªss
 = 
d_ba£
 | 
d_addªss_öc


207 
vÆ
 
d_addr_hi
 = 
edge
.
addr_hi
(
d_addªss
)

208 
vÆ
 
d_mask
 = 
edge
.
mask
(
d_ba£
, 
d_size
)

209 
vÆ
 
	gd_fifo
 = 
edge
.
m™agî
.
hasFifoIdFa°
(
d_Êight
.
ba£
Ë&&Édge.
˛õ¡
.
ªque°Fifo
(
d
.
sour˚
)

212 
vÆ
 
d_öc_byãs
 = 
öc_byãs
.
m≠
(
_
.
ªad
(
d_addr_hi
))

213 
vÆ
 
d_dec_byãs
 = 
dec_byãs
.
m≠
(
_
.
ªad
(
d_addr_hi
))

214 
vÆ
 
d_öc_åìs
 = 
öc_åìs
.
zùWôhIndex
.
m≠
{ (
m
, 
i
Ë=> m.
ªad
(
d_addr_hi
 >> (i+1)) }

215 
vÆ
 
	gd_dec_åìs
 = 
dec_åìs
.
zùWôhIndex
.
m≠
{ (
m
, 
i
Ë=> m.
ªad
(
d_addr_hi
 >> (i+1)) }

216 
vÆ
 
	gd_öc_åì
 = 
d_öc_åìs
.
fﬁd
(
UI¡
(0))(
_
 + _)

217 
vÆ
 
d_dec_åì
 = 
d_dec_åìs
.
fﬁd
(
UI¡
(0))(
_
 + _)

218 
vÆ
 
d_öc
 = 
d_öc_byãs
.
m≠
(
_
 + 
d_öc_åì
)

219 
vÆ
 
d_dec
 = 
d_dec_byãs
.
m≠
(
_
 + 
d_dec_åì
)

220 
vÆ
 
d_shadow
 = 
shadow
.
m≠
(
_
.
ªad
(
d_addr_hi
))

221 
vÆ
 
d_vÆid
 = 
vÆid
(
d
.
sour˚
Ë
hﬁdU∆ess
 
d_fú°


224 
vÆ
 
d_¸c_ªg
 = 
Reg
(
UI¡
(
width
 = 16))

225 
vÆ
 
d_¸c_acc
 = 
Mux
(
d_fú°
, 
UI¡
(0), 
d_¸c_ªg
)

226 
vÆ
 
	gd_¸c_√w
 = 
FûlI¡îÀaved
(8, 
d_mask
Ë& 
	gd
.
d©a


227 
vÆ
 
	gd_¸c
 = 
CRC
(
divis‹
, 
C©
(
d_¸c_acc
, 
d_¸c_√w
), 16 + 
bótByãs
*8)

228 
vÆ
 
	g¸c_by∑ss
 = i‡(
edge
.
m™agî
.
möL©ícy
 > 0Ë
Boﬁ
(
Ál£
Ë
a_fúe
 && 
a
.
sour˚
 ==
d
.source

229 
vÆ
 
d_¸c_vÆid
 = 
Mux
(
¸c_by∑ss
, 
a_¸c_vÆid
, 
¸c_vÆid
.
ªad
(
d
.
sour˚
)Ë
hﬁdU∆ess
 
d_fú°


230 
vÆ
 
	gd_¸c_check
 = 
Mux
(
¸c_by∑ss
, 
a_¸c
, 
¸c
.
ªad
(
d
.
sour˚
)Ë
hﬁdU∆ess
 
d_fú°


232 
vÆ
 
	gd_no_ø˚_ªg
 = 
Reg
(
Boﬁ
())

233 
vÆ
 
d_no_ø˚
 = 
Wúe
(
öô
 = 
d_no_ø˚_ªg
)

235 
whí
 (
d_fúe
) {

236 
d_¸c_ªg
 :
d_¸c


237 
d_no_ø˚_ªg
 :
d_no_ø˚


240 
as£π
 (
d_size
 ==
d_Êight
.
size
)

243 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
Höt
) {

244 
as£π
 (
d
.
›code
 ==
TLMesßges
.
HötAck
)

248 
whí
 (
d_œ°
 && 
d_Êight
.
›code
 =/
TLMesßges
.
Höt
 && d_Êight.›codê=/TLMesßges.
Gë
) {

249 
whí
 (
d_size
 <
UI¡
(
shi·
)) {

250 
dec_byãs_wí
 :
d_mask


252 
dec_åìs_wí
 :
d_sizeOH
 >> (
shi·
+1)

254 
i
 <- 0 
u¡û
 
ídSour˚Id
) {

256 
vÆ
 
f_ba£
 = 
Êight
(
i
).
ba£


257 
vÆ
 
f_size
 = 
Êight
(
i
).
size


258 
vÆ
 
f_bôs
 = 
UI¡ToOH1
(
f_size
, 
addªssBôs
)

259 
vÆ
 
	gd_bôs
 = 
UI¡ToOH1
(
d_size
, 
addªssBôs
)

260 
vÆ
 
	govîœp
 = ~(~(
f_ba£
 ^ 
d_ba£
Ë| (
f_bôs
 | 
d_bôs
)Ë==
UI¡
(0)

261 
whí
 (
ovîœp
Ë{ 
vÆid
(
i
Ë:
Boﬁ
(
Ál£
) }

265 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
PutFuŒD©a
 || d_Êight.›codê==TLMesßges.
PutP¨tülD©a
) {

266 
as£π
 (
d
.
›code
 ==
TLMesßges
.
Ac˚ssAck
)

267 
¥ötf
(
log
 + " ")

268 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
PutFuŒD©a
Ë{ 
¥ötf
("pf") }

269 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
PutP¨tülD©a
Ë{ 
¥ötf
("pp") }

270 
¥ötf
(" 0x%x - 0x%x\n", 
d_ba£
, d_ba£ | 
UI¡ToOH1
(
d_size
, 
addªssBôs
))

273 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
Gë
 || d_Êight.›codê==TLMesßges.
ArôhmëicD©a
 || d_Êight.›codê==TLMesßges.
LogiˇlD©a
) {

274 
as£π
 (
d
.
›code
 ==
TLMesßges
.
Ac˚ssAckD©a
)

275 
i
 <- 0 
u¡û
 
bótByãs
) {

276 
vÆ
 
gŸ
 = 
d
.
d©a
(8*(
i
+1)-1, 8*i)

277 
vÆ
 
	gshadow
 = 
Wúe
(
öô
 = 
d_shadow
(
i
))

278 
whí
 (
d_mask
(
i
)) {

279 
vÆ
 
d_addr
 = 
d_addr_hi
 << 
shi·
 | 
UI¡
(
i
)

280 
¥ötf
(
log
 + " ")

281 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
Gë
Ë{ 
¥ötf
("g ") }

282 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
ArôhmëicD©a
Ë{ 
¥ötf
("a ") }

283 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
LogiˇlD©a
Ë{ 
¥ötf
("l ") }

284 
¥ötf
(" 0x%x :0x%x", 
d_addr
, 
gŸ
)

285 
whí
 (!
shadow
.
vÆid
) {

286 
¥ötf
(", undefined (uninitialized orÖrior overlappingÖuts)\n")

287 } .
ñ£whí
 (
d_öc
(
i
Ë=/
d_dec
(i)) {

288 
¥ötf
(", undeföed (c⁄cuºíàöcom∂ëêput†#%d)\n", 
d_öc
(
i
Ë- 
d_dec
(i))

289 } .
ñ£whí
 (!
d_fifo
 && !
d_vÆid
) {

290 
¥ötf
(", undefined (concurrent completedÖut)\n")

291 } .
ñ£whí
 (
Boﬁ
(
ign‹eDíõdD©a
Ë&& 
d
.
díõd
) {

292 
¥ötf
(", undefined (deniedÑesult)\n")

293 } .
ñ£whí
 (
Boﬁ
(
ign‹eC‹ru±D©a
Ë&& 
d
.
c‹ru±
) {

294 
¥ötf
(", undefined (corruptÑesult)\n")

295 } .
Ÿhîwi£
 {

296 
¥ötf
("\n")

297 
whí
 (
shadow
.
vÆue
 =/
gŸ
Ë{ 
¥ötf
("EXPECTED: 0x%x\n", shadow.value) }

298 
as£π
 (
shadow
.
vÆue
 ==
gŸ
)

304 
whí
 (
d_Êight
.
›code
 ==
TLMesßges
.
ArôhmëicD©a
 || d_Êight.›codê==TLMesßges.
LogiˇlD©a
) {

305 
vÆ
 
ø˚
 = (
d_öc
 
zù
 
d_dec
Ë
m≠
 { (
i
, 
d
Ë=> i - d =/
UI¡
(1) }

306 
whí
 (
d_fú°
Ë{ 
	gd_no_ø˚
 :
Boﬁ
(
åue
) }

307 
whí
 ((
C©
(
ø˚
.
ªvî£
Ë& 
d_mask
).
‹R
Ë{ 
d_no_ø˚
 :
Boﬁ
(
Ál£
) }

308 
whí
 (
d_œ°
) {

309 
vÆ
 
mu°_m©ch
 = 
d_¸c_vÆid
 && (
d_fifo
 || (
d_vÆid
 && 
d_no_ø˚
))

310 
vÆ
 
c‹ru±
 = (
Boﬁ
(
ign‹eC‹ru±D©a
Ë&& 
d
.c‹ru±Ë|| (Boﬁ(
ign‹eDíõdD©a
Ë&& d.
díõd
)

311 
¥ötf
(
log
 + " cr¯0x%x %d\n", 
d_¸c
, 
mu°_m©ch
.
asUI¡
)

312 
whí
 (!
c‹ru±
 && 
mu°_m©ch
 && 
d_¸c
 =/
d_¸c_check
Ë{ 
¥ötf
("EXPECTED: 0x%x\n", d_crc_check) }

313 
as£π
 (
c‹ru±
 || !
mu°_m©ch
 || 
d_¸c
 ==
d_¸c_check
)

318 
vÆ
 
	gd_waddr
 = 
Mux
(
wùe
, 
wùeIndex
, 
d_addr_hi
)

319 
	gi
 <- 0 
u¡û
 
	gbótByãs
) {

320 
vÆ
 
	gd©a
 = 
Mux
(
wùe
, 
UI¡
(0), 
d_dec_byãs
(
i
) + UInt(1))

321 
whí
 (
dec_byãs_wí
(
i
)) {

322 
dec_byãs
(
i
).
wrôe
(
d_waddr
, 
d©a
)

326 
	gi
 <- 0 
u¡û
 
	gdec_åìs
.
	gsize
) {

327 
vÆ
 
	gd©a
 = 
Mux
(
wùe
, 
UI¡
(0), 
d_dec_åìs
(
i
) + UInt(1))

328 
whí
 (
dec_åìs_wí
(
i
)) {

329 
dec_åìs
(
i
).
wrôe
(
d_waddr
 >> (i+1), 
d©a
)

336 
obje˘
 
	gTLRAMModñ


338 
def
 
≠∂y
(
log
: 
Såög
 = "", 
ign‹eC‹ru±D©a
: 
Boﬁón
 = 
Ál£
, 
ign‹eDíõdD©a
: Boﬁó¿
åue
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

340 
vÆ
 
modñ
 = 
LazyModuÀ
(
√w
 
TLRAMModñ
(
log
, 
ign‹eC‹ru±D©a
, 
ign‹eDíõdD©a
))

341 
	gmodñ
.
	gnode


344 
˛ass
 
M⁄ô‹P¨amëîs
(
addªssBôs
: 
I¡
, 
sizeBôs
: Int)

346 ˛as†
	cByãM⁄ô‹
(
∑øms
: 
M⁄ô‹P¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
) {

347 
vÆ
 
vÆid
 = 
	`Boﬁ
()

348 
vÆ
 
vÆue
 = 
	`UI¡
(
width
 = 8)

349 
	}
}

350 ˛as†
	cFlightM⁄ô‹
(
∑øms
: 
M⁄ô‹P¨amëîs
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
) {

351 
vÆ
 
ba£
 = 
	`UI¡
(
width
 = 
∑øms
.
addªssBôs
)

352 
vÆ
 
size
 = 
	`UI¡
(
width
 = 
∑øms
.
sizeBôs
)

353 
vÆ
 
›code
 = 
	`UI¡
(
width
 = 3)

354 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RationalCrossing.scala

10 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


12 
imp‹t
 
	gChi£l
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


15 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


17 ˛as†
	cTLR©i⁄ÆCrossögSour˚
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


19 
vÆ
 
node
 = 
	$TLR©i⁄ÆSour˚Node
()

21 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

22 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

23 
vÆ
 
b˚
 = 
edgeIn
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeIn.
˛õ¡
.
™ySuµ‹tProbe


24 
vÆ
 
dúe˘i⁄
 = 
edgeOut
.
m™agî
.direction

26 
out
.
a
 <> 
	`ToR©i⁄Æ
(
ö
.a, 
dúe˘i⁄
)

27 
ö
.
d
 <> 
	`FromR©i⁄Æ
(
out
.d, 
dúe˘i⁄
.
Êù
)

29 i‡(
b˚
) {

30 
ö
.
b
 <> 
	`FromR©i⁄Æ
(
out
.b, 
dúe˘i⁄
.
Êù
)

31 
out
.
c
 <> 
	`ToR©i⁄Æ
(
ö
.c, 
dúe˘i⁄
)

32 
out
.
e
 <> 
	`ToR©i⁄Æ
(
ö
.e, 
dúe˘i⁄
)

34 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

35 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

36 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

37 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

38 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

39 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

40 
out
.
b
.
sök
 :
	`UI¡
(0)

41 
out
.
c
.
sour˚
 :
	`UI¡
(0)

42 
out
.
e
.
sour˚
 :
	`UI¡
(0)

46 
	}
}

48 
˛ass
 
	$TLR©i⁄ÆCrossögSök
(
dúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


50 
vÆ
 
node
 = 
	`TLR©i⁄ÆSökNode
(
dúe˘i⁄
)

52 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

53 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

54 
vÆ
 
b˚
 = 
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 &&ÉdgeOut.
˛õ¡
.
™ySuµ‹tProbe


55 
vÆ
 
dúe˘i⁄
 = 
edgeIn
.
m™agî
.direction

57 
out
.
a
 <> 
	`FromR©i⁄Æ
(
ö
.a, 
dúe˘i⁄
)

58 
ö
.
d
 <> 
	`ToR©i⁄Æ
(
out
.d, 
dúe˘i⁄
.
Êù
)

60 i‡(
b˚
) {

61 
ö
.
b
 <> 
	`ToR©i⁄Æ
(
out
.b, 
dúe˘i⁄
.
Êù
)

62 
out
.
c
 <> 
	`FromR©i⁄Æ
(
ö
.c, 
dúe˘i⁄
)

63 
out
.
e
 <> 
	`FromR©i⁄Æ
(
ö
.e, 
dúe˘i⁄
)

65 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

66 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

67 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

68 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

69 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

70 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

71 
ö
.
b
.
sour˚
 :
	`UI¡
(0)

72 
ö
.
c
.
sök
 :
	`UI¡
(0)

73 
ö
.
e
.
sök
 :
	`UI¡
(0)

77 
	}
}

79 
obje˘
 
TLR©i⁄ÆCrossögSour˚


81 
def
 
≠∂y
()(
im∂icô
 
p
: 
P¨amëîs
) =

83 
vÆ
 
rsour˚
 = 
LazyModuÀ
(
√w
 
TLR©i⁄ÆCrossögSour˚
)

84 
rsour˚
.
node


88 
obje˘
 
TLR©i⁄ÆCrossögSök


90 
def
 
≠∂y
(
dúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
)(
im∂icô
 
p
: 
P¨amëîs
) =

92 
vÆ
 
rsök
 = 
LazyModuÀ
(
√w
 
TLR©i⁄ÆCrossögSök
(
dúe˘i⁄
))

93 
rsök
.
node


97 @
dïªˇãd
("TLRationalCrossing is fragile. Use TLRationalCrossingSourceánd TLRationalCrossingSink", "rocket-chip 1.2")

98 
˛ass
 
	$TLR©i⁄ÆCrossög
(
dúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


100 
vÆ
 
sour˚
 = 
	`LazyModuÀ
(
√w
 
TLR©i⁄ÆCrossögSour˚
)

101 
vÆ
 
sök
 = 
	`LazyModuÀ
(
√w
 
	`TLR©i⁄ÆCrossögSök
(
dúe˘i⁄
))

102 
vÆ
 
node
 = 
	`NodeH™dÀ
(
sour˚
.node, 
sök
.node)

104 
sök
.
node
 :
sour˚
.node

106 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

107 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

108 
vÆ
 
ö_˛ock
 = 
	`Clock
(
INPUT
)

109 
vÆ
 
ö_ª£t
 = 
	`Boﬁ
(
INPUT
)

110 
vÆ
 
out_˛ock
 = 
	`Clock
(
INPUT
)

111 
vÆ
 
out_ª£t
 = 
	`Boﬁ
(
INPUT
)

114 
sour˚
.
moduÀ
.
˛ock
 :
io
.
ö_˛ock


115 
sour˚
.
moduÀ
.
ª£t
 :
io
.
ö_ª£t


116 
sök
.
moduÀ
.
˛ock
 :
io
.
out_˛ock


117 
sök
.
moduÀ
.
ª£t
 :
io
.
out_ª£t


119 
	}
}

122 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


124 
˛ass
 
	$TLRAMR©i⁄ÆCrossögSour˚
(
«me
: 
Såög
, 
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

125 
vÆ
 
node
 = 
	`TLR©i⁄ÆIdítôyNode
()

126 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

127 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
(
«me
))

129 (
node


130 :
	`TLR©i⁄ÆCrossögSour˚
()

131 :
	`TLDñayî
(0.25)

132 :
modñ
.
node


133 :
fuzz
.
node
)

135 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

136 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

137 
vÆ
 
föished
 = 
	`Boﬁ
(
OUTPUT
)

139 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

141 
	}
}

143 ˛as†
	cTLRAMR©i⁄ÆCrossögSök
(
dúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

144 
vÆ
 
node
 = 
	$TLR©i⁄ÆIdítôyNode
()

145 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	$AddªssSë
(0x0, 0x3ff)))

147 (
øm
.
node


148 :
	$TLFøgmíãr
(4, 256)

149 :
	$TLDñayî
(0.25)

150 :
	$TLR©i⁄ÆCrossögSök
(
dúe˘i⁄
)

151 :
node
)

153 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) { }

154 
	}
}

156 ˛as†
	cTLRAMR©i⁄ÆCrossög
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

157 
vÆ
 
sym_Á°_sour˚
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMR©i⁄ÆCrossögSour˚
("R©i⁄ÆCrossög sym_Á°", 
txns
))

158 
vÆ
 
sym_¶ow_sök
 = 
	`LazyModuÀ
(
√w
 
	$TLRAMR©i⁄ÆCrossögSök
(
Symmëric
))

159 
sym_¶ow_sök
.
node
 :
sym_Á°_sour˚
.node

161 
vÆ
 
sym_¶ow_sour˚
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMR©i⁄ÆCrossögSour˚
("R©i⁄ÆCrossög sym_¶ow", 
txns
))

162 
vÆ
 
sym_Á°_sök
 = 
	`LazyModuÀ
(
√w
 
	$TLRAMR©i⁄ÆCrossögSök
(
Symmëric
))

163 
sym_Á°_sök
.
node
 :
sym_¶ow_sour˚
.node

165 
vÆ
 
fix_Á°_sour˚
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMR©i⁄ÆCrossögSour˚
("R©i⁄ÆCrossög fa°", 
txns
))

166 
vÆ
 
fix_¶ow_sök
 = 
	`LazyModuÀ
(
√w
 
	$TLRAMR©i⁄ÆCrossögSök
(
Fa°ToSlow
))

167 
fix_¶ow_sök
.
node
 :
fix_Á°_sour˚
.node

169 
vÆ
 
fix_¶ow_sour˚
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMR©i⁄ÆCrossögSour˚
("R©i⁄ÆCrossög slow", 
txns
))

170 
vÆ
 
fix_Á°_sök
 = 
	`LazyModuÀ
(
√w
 
	$TLRAMR©i⁄ÆCrossögSök
(
SlowToFa°
))

171 
fix_Á°_sök
.
node
 :
fix_¶ow_sour˚
.node

173 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

174 
io
.
föished
 :=

175 
sym_Á°_sour˚
.
moduÀ
.
io
.
föished
 &&

176 
sym_¶ow_sour˚
.
moduÀ
.
io
.
föished
 &&

177 
fix_Á°_sour˚
.
moduÀ
.
io
.
föished
 &&

178 
fix_¶ow_sour˚
.
moduÀ
.
io
.
föished


181 
vÆ
 
Á°
 = 
	`ModuÀ
(
√w
 
	`Pow2ClockDividî
(1))

182 
sym_Á°_sour˚
.
moduÀ
.
˛ock
 :
Á°
.
io
.
˛ock_out


183 
sym_Á°_sök
 .
moduÀ
.
˛ock
 :
Á°
.
io
.
˛ock_out


184 
fix_Á°_sour˚
.
moduÀ
.
˛ock
 :
Á°
.
io
.
˛ock_out


185 
fix_Á°_sök
 .
moduÀ
.
˛ock
 :
Á°
.
io
.
˛ock_out


188 
vÆ
 
¶ow
 = 
	`ModuÀ
(
√w
 
	`Pow2ClockDividî
(2))

189 
fix_¶ow_sour˚
.
moduÀ
.
˛ock
 :
¶ow
.
io
.
˛ock_out


190 
fix_¶ow_sök
 .
moduÀ
.
˛ock
 :
¶ow
.
io
.
˛ock_out


192 
vÆ
 
odd
 = 
	`ModuÀ
(
√w
 
ClockDividî3
)

193 
odd
.
io
.
˛k_ö
 :
˛ock


194 
sym_¶ow_sour˚
.
moduÀ
.
˛ock
 :
odd
.
io
.
˛k_out


195 
sym_¶ow_sök
 .
moduÀ
.
˛ock
 :
odd
.
io
.
˛k_out


197 
	}
}

199 
˛ass
 
	$TLRAMR©i⁄ÆCrossögTe°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

200 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMR©i⁄ÆCrossög
(
txns
)).
moduÀ
)

201 
io
.
föished
 :
dut
.io.finished

202 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegionReplication.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
˛ass
 
	$Regi⁄Rïliˇt‹
(
mask
: 
BigI¡
 = 0)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

12 
def
 
ids
 = 
AddªssSë
.
	`íumî©eMask
(
mask
)

14 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

15 
˛õ¡Fn
 = { 
˝
 => cp },

16 
m™agîFn
 = { 
mp
 => mp.
	`c›y
(
m™agîs
 = mp.m™agîs.
m≠
 { 
m
 => m.copy(

17 
addªss
 = 
m
.addªss.
Ê©M≠
 { 
a
 => 
ids
.
m≠
 { 
id
 =>

18 
	`AddªssSë
(
a
.
ba£
 | 
id
,á.
mask
) } })})})

20 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

21 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

22 
out
 <> 
ö


23 
out
.
a
.
bôs
.
addªss
 :~(~
ö
.a.bôs.addªs†| 
mask
.
U
)

26 
edgeOut
.
m™agî
.
m™agîs
.
f‹óch
 { 
m
 =>

27 
	`ªquúe
 (
m
.
ªgi⁄Ty≥
 < 
Regi⁄Ty≥
.
TRACKED
, 
s
"${m.name} hasÑegionType ${m.regionType}, whichÑequires Probe supportá RegionReplicator cannotÖrovide")

31 
	}
}

33 
obje˘
 
	gRegi⁄Rïliˇt‹
 {

34 
def
 
≠∂y
(
mask
: 
BigI¡
 = 0)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 = {

35 
vÆ
 
ª∂iˇt‹
 = 
LazyModuÀ
(
√w
 
Regi⁄Rïliˇt‹
(
mask
))

36 
ª∂iˇt‹
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
RawModuÀ


7 
imp‹t
 
	gfúπl
.
	g™nŸ©i⁄s
.
ModuÀName


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	göãºu±s
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gEœb‹©i⁄AπeÁ˘s
, 
	gGíRegDescsA¬o
, 
	gHëîogíeousBag
}

14 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmax
, 
	gmö
}

16 
˛ass
 
TLRegi°îNode
(

17 
addªss
: 
Seq
[
AddªssSë
],

18 
devi˚
: 
Devi˚
,

19 
devi˚Key
: 
Såög
 = "reg/control",

20 
c⁄cuºícy
: 
I¡
 = 0,

21 
bótByãs
: 
I¡
 = 4,

22 
undefZîo
: 
Boﬁón
 = 
åue
,

23 
execuèbÀ
: 
Boﬁón
 = 
Ál£
)(

24 
im∂icô
 
vÆName
: 
VÆName
)

25 
exãnds
 
	$SökNode
(
TLImp
)(
	`Seq
(
	`TLM™agîP‹tP¨amëîs
(

26 
	`Seq
(
	`TLM™agîP¨amëîs
(

27 
addªss
 =áddress,

28 
ªsour˚s
 = 
	`Seq
(
	`Resour˚
(
devi˚
, 
devi˚Key
)),

29 
execuèbÀ
 =Éxecutable,

30 
suµ‹tsGë
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

31 
suµ‹tsPutP¨tül
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

32 
suµ‹tsPutFuŒ
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

33 
fifoId
 = 
	`Some
(0))),

34 
bótByãs
 = beatBytes,

35 
möL©ícy
 = 
	$mö
(
c⁄cuºícy
, 1))))

37 
vÆ
 
size
 = 1 << 
	`log2Ceû
(1 + 
addªss
.
	`m≠
(
_
.
max
).max -áddªss.m≠(_.
ba£
).
mö
)

38 
	`ªquúe
 (
size
 >
bótByãs
)

39 
addªss
.
f‹óch
 { 
a
 =>

40 
	`ªquúe
 (
a
.
	`widí
(
size
-1).
ba£
 =
addªss
.
hód
.widen(size-1).base,

41 
s
"TLRegisterNodeáddresses (${address}) must beálignedÅo its size ${size}")

46 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*) = {

47 
	`vÆ
 (
bundÀIn
, 
edge
Ë
this
.
	`ö
(0)

48 
vÆ
 
a
 = 
bundÀIn
.a

49 
vÆ
 
d
 = 
bundÀIn
.d

52 
vÆ
 
ba£End
 = 0

53 
	`vÆ
 (
sizeEnd
, 
sizeOff
Ë(
edge
.
bundÀ
.
sizeBôs
 + 
ba£End
, baseEnd)

54 
	`vÆ
 (
sour˚End
, 
sour˚Off
Ë(
edge
.
bundÀ
.
sour˚Bôs
 + 
sizeEnd
, sizeEnd)

56 
vÆ
 
∑øms
 = 
	`RegM≠≥rP¨ams
(
	`log2Up
(
size
/
bótByãs
), bótByãs, 
sour˚End
)

57 
vÆ
 
ö
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`RegM≠≥rI≈ut
(
∑øms
)))

58 
ö
.
bôs
.
ªad
 :
a
.bôs.
›code
 ==
TLMesßges
.
Gë


59 
ö
.
bôs
.
ödex
 :
edge
.
	`addr_hi
(
a
.bits)

60 
ö
.
bôs
.
d©a
 :
a
.bits.data

61 
ö
.
bôs
.
mask
 :
a
.bits.mask

62 
ö
.
bôs
.
exåa
 :
	`C©
(
a
.bôs.
sour˚
,á.bôs.
size
)

65 
vÆ
 
out
 = 
	`RegM≠≥r
(
bótByãs
, 
c⁄cuºícy
, 
undefZîo
, 
ö
, 
m≠pög
:
_
*)

68 
ö
.
vÆid
 :
a
.valid

69 
a
.
ªady
 :
ö
.ready

70 
d
.
vÆid
 :
out
.valid

71 
out
.
ªady
 :
d
.ready

74 
d
.
bôs
 :
edge
.
	`Ac˚ssAck
(

75 
toSour˚
 = 
out
.
bôs
.
	`exåa
(
sour˚End
-1, 
sour˚Off
),

76 
lgSize
 = 
out
.
bôs
.
	`exåa
(
sizeEnd
-1, 
sizeOff
))

79 
d
.
bôs
.
d©a
 :
out
.bits.data

80 
d
.
bôs
.
›code
 :
	`Mux
(
out
.bôs.
ªad
, 
TLMesßges
.
Ac˚ssAckD©a
, TLMesßges.
Ac˚ssAck
)

83 
bundÀIn
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

84 
bundÀIn
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

85 
bundÀIn
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

87 
	`gíRegDescsJs⁄
(
m≠pög
:
_
*)

91 
def
 
	`gíRegDescsJs⁄
(
m≠pög
: 
RegFõld
.
M≠
*) {

93 
vÆ
 
ba£
 = 
addªss
.
hód
.base

94 
vÆ
 
ba£Hex
 = 
s
"0x${base.toInt.toHexString}"

95 
vÆ
 
«me
 = 
s
"deviceAt${baseHex}"

96 
vÆ
 
js⁄
 = 
GíRegDescsA¬o
.
	`£rülize
(
ba£
, 
«me
, 
m≠pög
:
_
*)

97 
v¨
 
suffix
 = 0

98  
Eœb‹©i⁄AπeÁ˘s
.
	`c⁄èös
(
s
"${baseHex}.${suffix}.regmap.json")) {

99 
suffix
 = suffix + 1

101 
Eœb‹©i⁄AπeÁ˘s
.
	`add
(
s
"${ba£Hex}.${suffix}.ªgm≠.js⁄", 
js⁄
)

103 
vÆ
 
moduÀ
 = 
ModuÀ
.
cuºítModuÀ
.
gë
.
asIn°™˚Of
[
RawModuÀ
]

104 
GíRegDescsA¬o
.
	`™no
(

105 
moduÀ
,

106 
ba£
,

107 
m≠pög
:
_
*)

110 
	}
}

114 
ab°ø˘
 
˛ass
 
	$TLRegi°îRouãrBa£
(
dev«me
: 
Såög
, 
devcom∑t
: 
Seq
[Såög], 
vÆ
 
addªss
: 
AddªssSë
, 
öãºu±s
: 
I¡
, 
c⁄cuºícy
: I¡, 
bótByãs
: I¡, 
undefZîo
: 
Boﬁón
, 
execuèbÀ
: Boﬁón)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


117 
def
 
	`exåaResour˚s
(
ªsour˚s
: 
Resour˚Bödögs
Ë
M≠
[
Såög
, 
Seq
[
Resour˚VÆue
]]()

118 
vÆ
 
devi˚
 = 
√w
 
	`Sim∂eDevi˚
(
dev«me
, 
devcom∑t
) {

119 
ovîride
 
def
 
	`des¸ibe
(
ªsour˚s
: 
Resour˚Bödögs
): 
Des¸ùti⁄
 = {

120 
vÆ
 
	`Des¸ùti⁄
(
«me
, 
m≠pög
Ë
su≥r
.
	`des¸ibe
(
ªsour˚s
)

121 
	`Des¸ùti⁄
(
«me
, 
m≠pög
 ++ 
	`exåaResour˚s
(
ªsour˚s
))

125 
vÆ
 
node
 = 
	`TLRegi°îNode
(
	`Seq
(
addªss
), 
devi˚
, "ªg/c⁄åﬁ", 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

126 
vÆ
 
öäode
 = 
	`I¡Sour˚Node
(
	`I¡Sour˚P‹tSim∂e
(
num
 = 
öãºu±s
, 
ªsour˚s
 = 
	`Seq
(
	`Resour˚
(
devi˚
, "int"))))

127 
	}
}

129 ˛as†
	cTLRegBundÀArg
()(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
)

131 ˛as†
	cTLRegBundÀBa£
(
¨g
: 
TLRegBundÀArg
Ë
exãnds
 
BundÀ


133 
im∂icô
 
vÆ
 
p
 = 
¨g
.p

136 
˛ass
 
TLRegBundÀ
[
P
](
vÆ
 
∑øms
: P, vÆ 
¨g
: 
TLRegBundÀArg
Ë
exãnds
 
	$TLRegBundÀBa£
(
¨g
)

138 
˛ass
 
TLRegModuÀ
[
P
, 
B
 <: 
TLRegBundÀBa£
](
vÆ
 
∑øms
: P, 
bundÀBuûdî
: => B, 
rouãr
: 
TLRegi°îRouãrBa£
)

139 
exãnds
 
	$LazyModuÀImp
(
rouãr
Ë
wôh
 
HasRegM≠


141 
vÆ
 
io
 = 
	`IO
(
bundÀBuûdî
)

142 
vÆ
 
öãºu±s
 = i‡(
rouãr
.
öäode
.
out
.
isEm±y
Ë
	`Vec
(0, 
	`Boﬁ
()Ërouãr.öäode.
	`out
(0).
_1


143 
vÆ
 
addªss
 = 
rouãr
.address

144 
def
 
	`ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*Ë
rouãr
.
node
.ªgm≠(m≠pög:
_
*)

145 
	}
}

147 
˛ass
 
TLRegi°îRouãr
[
B
 <: 
TLRegBundÀBa£
, 
M
 <: 
LazyModuÀImp
](

148 
vÆ
 
ba£
: 
BigI¡
,

149 
vÆ
 
	gdev«me
: 
Såög
,

150 
vÆ
 
	gdevcom∑t
: 
Seq
[
Såög
],

151 
vÆ
 
	göãºu±s
: 
I¡
 = 0,

152 
vÆ
 
	gsize
: 
BigI¡
 = 4096,

153 
vÆ
 
	gc⁄cuºícy
: 
I¡
 = 0,

154 
vÆ
 
	gbótByãs
: 
I¡
 = 4,

155 
vÆ
 
	gundefZîo
: 
Boﬁón
 = 
åue
,

156 
vÆ
 
	gexecuèbÀ
: 
Boﬁón
 = 
Ál£
)

157 (
bundÀBuûdî
: 
TLRegBundÀArg
 => 
B
)

158 (
moduÀBuûdî
: (=> 
B
, 
	gTLRegi°îRouãrBa£
Ë=> 
M
)(
im∂icô
 
p
: 
P¨amëîs
)

159 
exãnds
 
TLRegi°îRouãrBa£
(
dev«me
, 
devcom∑t
, 
AddªssSë
(
ba£
, 
size
-1), 
öãºu±s
, 
c⁄cuºícy
, 
bótByãs
, 
undefZîo
, 
execuèbÀ
)

161 
ªquúe
 (
isPow2
(
size
))

164 
œzy
 
vÆ
 
	gmoduÀ
 = 
moduÀBuûdî
(
bundÀBuûdî
(
TLRegBundÀArg
()), 
this
)

170 
åaô
 
	gHasTLC⁄åﬁRegM≠
 { 
	gthis
: 
Regi°îRouãr
[
_
] =>

171 
¥Ÿe˘ed
 
vÆ
 
c⁄åﬁNode
 = 
TLRegi°îNode
(

172 
addªss
 =áddress,

173 
devi˚
 = device,

174 
devi˚Key
 = "reg/control",

175 
c⁄cuºícy
 = concurrency,

176 
bótByãs
 = beatBytes,

177 
undefZîo
 = undefZero,

178 
execuèbÀ
 =Éxecutable)

181 
vÆ
 
c⁄åﬁXög
: 
TLInw¨dCrossögHñ≥r
 = 
this
.
¸ossIn
(
c⁄åﬁNode
)

184 
¥Ÿe˘ed
 
def
 
ªgm≠
(
m≠pög
: 
RegFõld
.
M≠
*Ë{ 
c⁄åﬁNode
.ªgm≠(m≠pög:
_
*) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouterTest.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
Mu…iIOModuÀ


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.{
	gPow2ClockDividî
}

13 
obje˘
 
	gLFSR16Sìd


15 
def
 
≠∂y
(
£ed
: 
I¡
): 
UI¡
 =

17 
vÆ
 
width
 = 16

18 
vÆ
 
lf§
 = 
Reg
(
öô
=
UI¡
((
£ed
*0x7231Ë% 65536, 
width
))

19 
	glf§
 :
C©
(
lf§
(0)^lf§(2)^lf§(3)^lf§(5),Üf§(
width
-1,1))

20 
	glf§


24 
˛ass
 
RRTe°Combö©i⁄Æ
(
vÆ
 
bôs
: 
I¡
, 
rvÆid
: 
Boﬁ
 => Boﬁ, 
wªady
: Boﬁ => BoﬁË
exãnds
 
ModuÀ


26 
vÆ
 
io
 = 
√w
 
BundÀ
 {

27 
vÆ
 
rvÆid
 = 
Boﬁ
(
OUTPUT
)

28 
vÆ
 
ºódy
 = 
Boﬁ
(
INPUT
)

29 
vÆ
 
rd©a
 = 
UI¡
(
OUTPUT
, 
width
 = 
bôs
)

30 
vÆ
 
wvÆid
 = 
Boﬁ
(
INPUT
)

31 
vÆ
 
wªady
 = 
Boﬁ
(
OUTPUT
)

32 
vÆ
 
wd©a
 = 
UI¡
(
INPUT
, 
width
 = 
bôs
)

35 
vÆ
 
	gªg
 = 
RegInô
(
UI¡
(0, 
width
 = 
bôs
))

37 
vÆ
 
rvÆid_s
 = 
rvÆid
(
io
.
ºódy
)

38 
vÆ
 
wªady_s
 = 
wªady
(
io
.
wvÆid
)

39 
io
.
rvÆid
 :
rvÆid_s


40 
io
.
wªady
 :
wªady_s


42 
io
.
rd©a
 :
Mux
(
rvÆid_s
 && io.
ºódy
, 
ªg
, 
UI¡
(0))

43 
whí
 (
io
.
wvÆid
 && 
wªady_s
Ë{ 
	gªg
 :io.
wd©a
 }

46 
obje˘
 
RRTe°Combö©i⁄Æ


48 
¥iv©e
 
v¨
 
£ed
 = 42

50 
def
 
Æways
: 
Boﬁ
 => Boﬁ = 
_
 => Boﬁ(
åue
)

52 
def
 
øndom
: 
Boﬁ
 => Boﬁ = { 
ªady
 =>

53 
£ed
 = seed + 1

54 
LFSR16Sìd
(
£ed
)(0)

57 
def
 
dñay
(
x
: 
I¡
): 
Boﬁ
 => Boﬁ = { 
ªady
 =>

58 
vÆ
 
ªg
 = 
RegInô
(
UI¡
(0, 
width
 = 
log2Ceû
(
x
+1)))

59 
vÆ
 
vÆid
 = 
ªg
 ==
UI¡
(0)

60 
ªg
 :
Mux
(
ªady
 && 
vÆid
, 
UI¡
(
x
), Mux(valid, UInt(0),Ñeg - UInt(1)))

61 
	gvÆid


64 
def
 
combo
(
bôs
: 
I¡
, 
rvÆid
: 
Boﬁ
 => Boﬁ, 
wªady
: Boﬁ => Boﬁ): 
RegFõld
 = {

65 
vÆ
 
combo
 = 
ModuÀ
(
√w
 
RRTe°Combö©i⁄Æ
(
bôs
, 
rvÆid
, 
wªady
))

66 
RegFõld
(
bôs
,

67 
RegRódFn
 { 
ªady
 => 
combo
.
io
.
ºódy
 :ªady; (combo.io.
rvÆid
, combo.io.
rd©a
) },

68 
RegWrôeFn
 { (
vÆid
, 
d©a
Ë=> 
combo
.
io
.
wvÆid
 :vÆid; combo.io.
wd©a
 :d©a; combo.io.
wªady
 })

72 
˛ass
 
RRTe°Reque°
(
vÆ
 
bôs
: 
I¡
,

73 
rÊow
: (
Boﬁ
, Boﬁ, 
UI¡
) => (Bool, Bool, UInt),

74 
wÊow
: (
Boﬁ
, Boﬁ, 
UI¡
Ë=> (Boﬁ, Boﬁ, UI¡)Ë
exãnds
 
	gModuÀ


76 
vÆ
 
	gio
 = 
√w
 
BundÀ
 {

77 
vÆ
 
rivÆid
 = 
Boﬁ
(
INPUT
)

78 
vÆ
 
rúódy
 = 
Boﬁ
(
OUTPUT
)

79 
vÆ
 
rovÆid
 = 
Boﬁ
(
OUTPUT
)

80 
vÆ
 
r‹ódy
 = 
Boﬁ
(
INPUT
)

81 
vÆ
 
rd©a
 = 
UI¡
(
OUTPUT
, 
width
 = 
bôs
)

82 
vÆ
 
wivÆid
 = 
Boﬁ
(
INPUT
)

83 
vÆ
 
wúódy
 = 
Boﬁ
(
OUTPUT
)

84 
vÆ
 
wovÆid
 = 
Boﬁ
(
OUTPUT
)

85 
vÆ
 
w‹ódy
 = 
Boﬁ
(
INPUT
)

86 
vÆ
 
wd©a
 = 
UI¡
(
INPUT
, 
width
 = 
bôs
)

89 
vÆ
 (
rúódy
, 
rovÆid
, 
_
Ë
rÊow
(
io
.
rivÆid
, io.
r‹ódy
, 
UI¡
(0, 
width
 = 1))

90 
vÆ
 (
wúódy
, 
wovÆid
, 
wd©a
Ë
wÊow
(
io
.
wivÆid
, io.
w‹ódy
, io.wdata)

91 
vÆ
 
	gªg
 = 
RegInô
(
UI¡
(0, 
width
 = 
bôs
))

93 
io
.
rúódy
 :=Ñiready

94 
io
.
rovÆid
 :=Ñovalid

95 
io
.
wúódy
 := wiready

96 
io
.
wovÆid
 := wovalid

98 
vÆ
 
rofúe
 = 
io
.
r‹ódy
 && 
rovÆid


99 
vÆ
 
wofúe
 = 
io
.
w‹ódy
 && 
wovÆid


101 
io
.
rd©a
 :
Mux
(
rofúe
, 
ªg
, 
UI¡
(0))

102 
whí
 (
wofúe
Ë{ 
	gªg
 :
wd©a
 }

105 
obje˘
 
RRTe°Reque°


107 
¥iv©e
 
v¨
 
£ed
 = 1231

108 
def
 
pùe
(
x
: 
I¡
): (
Boﬁ
, 
	gBoﬁ
, 
	gUI¡
Ë=> (Boﬁ, Boﬁ, UI¡Ë{ (
ivÆid
, 
‹ódy
, 
id©a
) =>

109 
vÆ
 
fuŒ
 = 
RegInô
(
Vec
.
fûl
(
x
)(
Boﬁ
(
Ál£
)))

110 
vÆ
 
ªady
 = 
Wúe
(
Vec
(
x
, 
Boﬁ
()))

111 
vÆ
 
	gd©a
 = 
Reg
(
Vec
(
x
, 
UI¡
(
width
 = 
id©a
.
gëWidth
)))

113 
ªady
(
x
-1Ë:
‹ódy
 || !
fuŒ
(x-1)

114 
whí
 (
ªady
(0)Ë{ 
d©a
(0Ë:
id©a
 }

115 
whí
 (
ªady
(0)Ë{ 
fuŒ
(0Ë:
ivÆid
 }

116 ((
ªady
.
öô
 
zù
Ñódy.
èû
Ëzù 
fuŒ
.öôË
f‹óch
 { ((
£lf
, 
	g√xt
), 
	gfuŒ
) =>

117 
£lf
 :
√xt
 || !
fuŒ


119 ((
d©a
.
öô
 
zù
 d©a.
èû
Ëzù 
ªady
.èûË
f‹óch
 { ((
¥ev
, 
	g£lf
), 
	gªady
) =>

120 
whí
 (
ªady
Ë{ 
£lf
 :
¥ev
 }

122 ((
fuŒ
.
öô
 
zù
 fuŒ.
èû
Ëzù 
ªady
.èûË
f‹óch
 { ((
¥ev
, 
	g£lf
), 
	gªady
) =>

123 
whí
 (
ªady
Ë{ 
£lf
 :
¥ev
 }

125 (
ªady
(0), 
fuŒ
(
x
-1), 
d©a
(x-1))

128 
def
 
	gbusy
: (
Boﬁ
, 
	gBoﬁ
, 
	gUI¡
) => (Bool, Bool, UInt) = {

129 
£ed
 = seed + 1

130 (
ivÆid
, 
	g‹ódy
, 
	gid©a
) => {

131 
vÆ
 
lf§
 = 
LFSR16Sìd
(
£ed
)

132 
vÆ
 
busy
 = 
RegInô
(
Boﬁ
(
Ál£
))

133 
vÆ
 
d©a
 = 
Reg
(
UI¡
(
width
 = 
id©a
.
gëWidth
))

134 
vÆ
 
¥ogªss
 = 
lf§
(0)

135 
vÆ
 
úódy
 = 
¥ogªss
 && !
busy


136 
vÆ
 
ovÆid
 = 
¥ogªss
 && 
busy


137 
whí
 (
¥ogªss
) {

138 
busy
 :
Mux
(busy, !
‹ódy
, 
ivÆid
)

140 
whí
 (
ivÆid
 && 
úódy
Ë{ 
	gd©a
 :
id©a
 }

141 (
úódy
, 
	govÆid
, 
	gd©a
)

145 
def
 
ªque°
(
bôs
: 
I¡
,

146 
rÊow
: (
Boﬁ
, Boﬁ, 
UI¡
) => (Bool, Bool, UInt),

147 
wÊow
: (
Boﬁ
, Boﬁ, 
UI¡
Ë=> (Boﬁ, Boﬁ, UI¡)): 
RegFõld
 = {

148 
vÆ
 
ªque°
 = 
ModuÀ
(
√w
 
RRTe°Reque°
(
bôs
, 
rÊow
, 
wÊow
))

149 
RegFõld
(
bôs
,

150 
RegRódFn
 { (
rivÆid
, 
r‹ódy
) =>

151 
ªque°
.
io
.
rivÆid
 :=Ñivalid

152 
ªque°
.
io
.
r‹ódy
 :=Ñoready

153 (
ªque°
.
io
.
rúódy
,Ñeque°.io.
rovÆid
,Ñeque°.io.
rd©a
) },

154 
RegWrôeFn
 { (
wivÆid
, 
w‹ódy
, 
wd©a
) =>

155 
ªque°
.
io
.
wivÆid
 := wivalid

156 
ªque°
.
io
.
w‹ódy
 := woready

157 
ªque°
.
io
.
wd©a
 := wdata

158 (
ªque°
.
io
.
wúódy
,Ñeque°.io.
wovÆid
) })

162 
obje˘
 
	gRRTe°0M≠


164 
imp‹t
 
	gRRTe°Combö©i⁄Æ
.
_


166 
def
 
Ø
(
bôs
: 
I¡
Ë
combo
(bôs, 
Æways
,álways)

167 
def
 
¨
(
bôs
: 
I¡
Ë
combo
(bôs, 
Æways
, 
øndom
)

168 
def
 
ad
(
bôs
: 
I¡
Ë
combo
(bôs, 
Æways
, 
dñay
(11))

169 
def
 
´
(
bôs
: 
I¡
Ë
combo
(bôs, 
Æways
, 
dñay
(5))

170 
def
 
ø
(
bôs
: 
I¡
Ë
combo
(bôs, 
øndom
, 
Æways
)

171 
def
 
º
(
bôs
: 
I¡
Ë
combo
(bôs, 
øndom
,Ñandom)

172 
def
 
rd
(
bôs
: 
I¡
Ë
combo
(bôs, 
øndom
, 
dñay
(11))

173 
def
 
ª
(
bôs
: 
I¡
Ë
combo
(bôs, 
øndom
, 
dñay
(5))

174 
def
 
da
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(5), 
Æways
)

175 
def
 
dr
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(5), 
øndom
)

176 
def
 
dd
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(5), delay(5))

177 
def
 
de
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(5), delay(11))

178 
def
 
ó
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(11), 
Æways
)

179 
def
 
î
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(11), 
øndom
)

180 
def
 
ed
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(11), delay(5))

181 
def
 
ì
(
bôs
: 
I¡
Ë
combo
(bôs, 
dñay
(11), delay(11))

184 
def
 
	gm≠
 = 
Seq
(

185 0 -> 
Seq
(
Ø
(8), 
¨
(8), 
ad
(8), 
´
(8)),

186 4 -> 
Seq
(
ø
(8), 
º
(8), 
rd
(8), 
ª
(8)),

187 8 -> 
Seq
(
da
(8), 
dr
(8), 
dd
(8), 
de
(8)),

188 12 -> 
Seq
(
ó
(8), 
î
(8), 
ed
(8), 
ì
(8)),

189 16 -> 
Seq
(
Ø
(3), 
¨
(5), 
ad
(1), 
´
(7), 
ø
(2), 
º
(6), 
rd
(4), 
ª
(4)),

190 20 -> 
Seq
(
da
(3), 
dr
(5), 
dd
(1), 
de
(7), 
ó
(2), 
î
(6), 
ed
(4), 
ì
(4)),

191 24 -> 
Seq
(
Ø
(8), 
º
(8), 
dd
(8), 
ì
(8)),

192 28 -> 
Seq
(
¨
(8), 
rd
(8), 
de
(8), 
ó
(8)))

195 
obje˘
 
	gRRTe°1M≠


197 
imp‹t
 
	gRRTe°Reque°
.
_


199 
def
 
µ
(
bôs
: 
I¡
Ë
ªque°
(bôs, 
pùe
(3),Öipe(3))

200 
def
 
pb
(
bôs
: 
I¡
Ë
ªque°
(bôs, 
pùe
(3), 
busy
)

201 
def
 
bp
(
bôs
: 
I¡
Ë
ªque°
(bôs, 
busy
, 
pùe
(3))

202 
def
 
bb
(
bôs
: 
I¡
Ë
ªque°
(bôs, 
busy
, busy)

204 
def
 
	gm≠
 = 
RRTe°0M≠
.
m≠
.
èke
(6Ë++ 
Seq
(

205 24 -> 
Seq
(
µ
(8), 
pb
(8), 
bp
(8), 
bb
(8)),

206 28 -> 
Seq
(
µ
(3), 
pb
(5), 
bp
(1), 
bb
(7),Öb(5), bp(3),Öp(4), bb(4)))

209 
åaô
 
	gRRTe°0BundÀ


213 
åaô
 
RRTe°0ModuÀ
 
exãnds
 
	gHasRegM≠


215 
ªgm≠
(
RRTe°0M≠
.
m≠
:
_
*)

218 
˛ass
 
	$RRTe°0
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	`TLRegi°îRouãr
◊ddªss, "ã°0", 
Nû
, 0, 32, 0, 4)(

219 
√w
 
	`TLRegBundÀ
((), 
_
Ë
wôh
 
RRTe°0BundÀ
)(

220 
√w
 
	`TLRegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°0ModuÀ
)

222 
åaô
 
RRTe°1BundÀ


224 
	}
}

226 
åaô
 
RRTe°1ModuÀ
 
exãnds
 
Mu…iIOModuÀ
 
wôh
 
	gHasRegM≠


228 
vÆ
 
	g˛ocks
 = 
ModuÀ
(
√w
 
Pow2ClockDividî
(2))

230 
def
 
x
(
bôs
: 
I¡
) = {

231 
vÆ
 
fõld
 = 
UI¡
(
width
 = 
bôs
)

233 
vÆ
 
ªadCross
 = 
ModuÀ
(
√w
 
Regi°îRódCrossög
(
fõld
))

234 
ªadCross
.
io
.
ma°î_˛ock
 :
˛ock


235 
ªadCross
.
io
.
ma°î_ª£t
 :
ª£t


236 
ªadCross
.
io
.
ma°î_by∑ss
 :
Boﬁ
(
Ál£
)

237 
ªadCross
.
io
.
¶ave_˛ock
 :
˛ocks
.io.
˛ock_out


238 
ªadCross
.
io
.
¶ave_ª£t
 :
ª£t


240 
vÆ
 
wrôeCross
 = 
ModuÀ
(
√w
 
Regi°îWrôeCrossög
(
fõld
))

241 
wrôeCross
.
io
.
ma°î_˛ock
 :
˛ock


242 
wrôeCross
.
io
.
ma°î_ª£t
 :
ª£t


243 
wrôeCross
.
io
.
ma°î_by∑ss
 :
Boﬁ
(
Ál£
)

244 
wrôeCross
.
io
.
¶ave_˛ock
 :
˛ocks
.io.
˛ock_out


245 
wrôeCross
.
io
.
¶ave_ª£t
 :
ª£t


247 
ªadCross
.
io
.
¶ave_ªgi°î
 :
wrôeCross
.io.slave_register

248 
RegFõld
(
bôs
, 
ªadCross
.
io
.
ma°î_p‹t
, 
wrôeCross
.io.master_port)

251 
vÆ
 
	gm≠
 = 
RRTe°1M≠
.
m≠
.
dr›
(1Ë++ 
Seq
(0 -> Seq(
x
(8), x(8), x(8), x(8)))

252 
ªgm≠
(
m≠
:
_
*)

255 
˛ass
 
	$RRTe°1
(
addªss
: 
BigI¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	`TLRegi°îRouãr
◊ddªss, "ã°1", 
Nû
, 0, 32, 6, 4)(

256 
√w
 
	`TLRegBundÀ
((), 
_
Ë
wôh
 
RRTe°1BundÀ
)(

257 
√w
 
	`TLRegModuÀ
((), 
_
, _Ë
wôh
 
RRTe°1ModuÀ
)

259 ˛as†
	cFuzzRRTe°0
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

260 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

261 
vÆ
 
ºå
 = 
	`LazyModuÀ
(
√w
 
	$RRTe°0
(0x400))

263 
ºå
.
node
 :
	$TLFøgmíãr
(4, 32Ë:
	$TLDñayî
(0.1Ë:
fuzz
.
node


265 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

266 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

268 
	}
}

270 
˛ass
 
	$TLRR0Te°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

271 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`FuzzRRTe°0
(
txns
)).
moduÀ
)

272 
io
.
föished
 :
dut
.io.finished

273 
	}
}

275 ˛as†
	cFuzzRRTe°1
(
txns
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

276 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	$TLFuzzî
(
txns
))

277 
vÆ
 
ºå
 = 
	`LazyModuÀ
(
√w
 
	$RRTe°1
(0x400))

279 
ºå
.
node
 :
	$TLFøgmíãr
(4, 32Ë:
	$TLDñayî
(0.1Ë:
fuzz
.
node


281 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

282 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

284 
	}
}

286 
˛ass
 
	$TLRR1Te°
(
txns
: 
I¡
 = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

287 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`FuzzRRTe°1
(
txns
)).
moduÀ
)

288 
io
.
föished
 :
dut
.io.finished

289 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SRAM.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
chi£lName


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


11 
˛ass
 
	$TLRAM
(

12 
addªss
: 
AddªssSë
,

13 
ˇchóbÀ
: 
Boﬁón
 = 
åue
,

14 
execuèbÀ
: 
Boﬁón
 = 
åue
,

15 
bótByãs
: 
I¡
 = 4,

16 
eccByãs
: 
I¡
 = 1,

17 
devName
: 
O±i⁄
[
Såög
] = 
N⁄e
,

18 
code
: 
Code
 = 
√w
 
IdítôyCode
)

19 (
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$Dùlom©icSRAM
(
addªss
, 
bótByãs
, 
devName
)

21 
	`ªquúe
 (
eccByãs
 >1 && 
	`isPow2
(eccBytes))

22 
	`ªquúe
 (
bótByãs
 >1 && 
	`isPow2
(beatBytes))

23 
	`ªquúe
 (
eccByãs
 <
bótByãs
, 
s
"TLRAMÉccBytes (${eccBytes}) > beatBytes (${beatBytes}). Useá WidthWidget=>Fragmenter=>SRAM if youÇeed high densityándÇarrow ECC; it will do burstsÉfficiently")

25 
vÆ
 
node
 = 
	`TLM™agîNode
(
	`Seq
(
	`TLM™agîP‹tP¨amëîs
(

26 
	`Seq
(
	`TLM™agîP¨amëîs
(

27 
addªss
 = 
	`Li°
(address),

28 
ªsour˚s
 = 
devi˚
.
	`ªg
("mem"),

29 
ªgi⁄Ty≥
 = i‡(
ˇchóbÀ
Ë
Regi⁄Ty≥
.
UNCACHED
 Regi⁄Ty≥.
UNCACHEABLE
,

30 
execuèbÀ
 =Éxecutable,

31 
suµ‹tsGë
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

32 
suµ‹tsPutP¨tül
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

33 
suµ‹tsPutFuŒ
 = 
	`Tøns„rSizes
(1, 
bótByãs
),

34 
fifoId
 = 
	`Some
(0))),

35 
bótByãs
 = beatBytes,

36 
möL©ícy
 = 1)))

38 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

39 
	`vÆ
 (
ö
, 
edge
Ë
node
.
	`ö
(0)

41 
vÆ
 
width
 = 
code
.
	`width
(
eccByãs
*8)

42 
vÆ
 
œ√s
 = 
bótByãs
/
eccByãs


43 
vÆ
 
addrBôs
 = (
mask
 
zù
 
edge
.
	`addr_hi
(
ö
.
a
.
bôs
).
toBoﬁs
).
	`fûãr
(
_
.
_1
).
	`m≠
(_.
_2
)

44 
vÆ
 
mem
 = 
	`makeSögÀP‹ãdByãWrôeSeqMem
(1 << 
addrBôs
.
size
, 
œ√s
, 
width
)

58 
vÆ
 
d_fuŒ
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

59 
vÆ
 
d_øm_vÆid
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

60 
vÆ
 
d_size
 = 
	`Reg
(
	`UI¡
())

61 
vÆ
 
d_sour˚
 = 
	`Reg
(
	`UI¡
())

62 
vÆ
 
d_ªad
 = 
	`Reg
(
	`Boﬁ
())

63 
vÆ
 
d_addªss
 = 
	`Reg
(
	`UI¡
(
width
 = 
addrBôs
.
size
))

64 
vÆ
 
d_rmw_mask
 = 
	`Reg
(
	`UI¡
(
width
 = 
bótByãs
))

65 
vÆ
 
d_rmw_d©a
 = 
	`Reg
(
	`UI¡
(
width
 = 8*
bótByãs
))

66 
vÆ
 
d_pois⁄
 = 
	`Reg
(
	`Boﬁ
())

69 
vÆ
 
d_øw_d©a
 = 
	`Wúe
(
	`Vec
(
œ√s
, 
	`Bôs
(
width
 = width)))

70 
vÆ
 
d_decoded
 = 
d_øw_d©a
.
	`m≠
(
œ√
 => 
code
.
	`decode
(lane))

71 
vÆ
 
d_c‹ª˘ed
 = 
	`C©
(
d_decoded
.
	`m≠
(
_
.
c‹ª˘ed
).
ªvî£
)

72 
vÆ
 
d_unc‹ª˘ed
 = 
	`C©
(
d_decoded
.
	`m≠
(
_
.
unc‹ª˘ed
).
ªvî£
)

73 
vÆ
 
d_c‹ª˘abÀ
 = 
d_decoded
.
	`m≠
(
_
.
c‹ª˘abÀ
)

74 
vÆ
 
d_unc‹ª˘abÀ
 = 
d_decoded
.
	`m≠
(
_
.
unc‹ª˘abÀ
)

75 
vÆ
 
d_√ed_fix
 = 
d_c‹ª˘abÀ
.
	`ªdu˚
(
_
 || _)

76 
vÆ
 
d_îr‹
 = 
d_unc‹ª˘abÀ
.
	`ªdu˚
(
_
 || _)

79 
vÆ
 
d_wb_d©a
 = 
	`Vec
(
Seq
.
	`èbuœã
(
bótByãs
Ë{ 
i
 =>

80 
vÆ
 
upd
 = 
	`d_rmw_mask
(
i
)

81 
vÆ
 
rmw
 = 
	`d_rmw_d©a
 (8*(
i
+1)-1, 8*i)

82 
vÆ
 
fix
 = 
	`d_c‹ª˘ed
(8*(
i
+1)-1, 8*i)

83 
	`Mux
(
upd
, 
rmw
, 
fix
)

84 }.
	`grou≥d
(
eccByãs
).
	`m≠
(
œ√
 => 
	`C©
÷™e.
ªvî£
)).
toLi°
)

85 
	`vÆ
 (
d_wb_œ√s
, 
d_wb_pois⁄
Ë
Seq
.
	`èbuœã
(
œ√s
Ë{ 
i
 =>

86 
vÆ
 
upd
 = 
	`d_rmw_mask
(
eccByãs
*(
i
+1)-1,ÉccBytes*i)

87 (
upd
.
‹R
 || 
	`d_c‹ª˘abÀ
(
i
),

88 (!
upd
.
™dR
 && 
	`d_unc‹ª˘abÀ
(
i
)Ë|| 
d_pois⁄
)

89 }.
unzù


90 
vÆ
 
d_wb
 = 
d_rmw_mask
.
‹R
 || (
d_øm_vÆid
 && 
d_√ed_fix
)

93 
vÆ
 
d_hñd_d©a
 = 
	`RegE«bÀ
(
d_c‹ª˘ed
, 
d_øm_vÆid
)

94 
vÆ
 
d_hñd_îr‹
 = 
	`RegE«bÀ
(
d_îr‹
, 
d_øm_vÆid
)

96 
ö
.
d
.
bôs
.
›code
 :
	`Mux
(
d_ªad
, 
TLMesßges
.
Ac˚ssAckD©a
, TLMesßges.
Ac˚ssAck
)

97 
ö
.
d
.
bôs
.
∑øm
 :
	`UI¡
(0)

98 
ö
.
d
.
bôs
.
size
 :
d_size


99 
ö
.
d
.
bôs
.
sour˚
 :
d_sour˚


100 
ö
.
d
.
bôs
.
sök
 :
	`UI¡
(0)

101 
ö
.
d
.
bôs
.
díõd
 :
	`Boﬁ
(
Ál£
)

103 
ö
.
d
.
bôs
.
d©a
 :
	`Mux
(
d_øm_vÆid
, 
d_unc‹ª˘ed
, 
d_hñd_d©a
)

104 
ö
.
d
.
bôs
.
c‹ru±
 :
	`Mux
(
d_øm_vÆid
, 
d_îr‹
, 
d_hñd_îr‹
Ë&& 
d_ªad


107 
vÆ
 
d_∑u£
 = 
d_ªad
 && 
d_øm_vÆid
 && 
d_√ed_fix


108 
ö
.
d
.
vÆid
 :
d_fuŒ
 && !
d_∑u£


109 
ö
.
a
.
ªady
 :!
d_fuŒ
 || (ö.
d
.ªady && !
d_∑u£
 && !
d_wb
)

111 
vÆ
 
a_addªss
 = 
	`C©
(
addrBôs
.
ªvî£
)

112 
vÆ
 
a_ªad
 = 
ö
.
a
.
bôs
.
›code
 ==
TLMesßges
.
Gë


113 
vÆ
 
a_d©a
 = 
	`Vec
(
Seq
.
	`èbuœã
(
œ√s
Ë{ 
i
 => 
ö
.
a
.
bôs
.
	`d©a
(
eccByãs
*8*(i+1)-1,ÉccBytes*8*i) })

121 
vÆ
 
a_subœ√
 = i‡(
eccByãs
 =1Ë
	`Boﬁ
(
Ál£
) 

122 
ö
.
a
.
bôs
.
›code
 ==
TLMesßges
.
PutP¨tülD©a
 ||

123 
ö
.
a
.
bôs
.
size
 < 
	`UI¡
(
	`log2Ceû
(
eccByãs
))

124 
vÆ
 
a_ªn
 = 
a_ªad
 || 
a_subœ√


125 
vÆ
 
a_œ√s
 = 
Seq
.
	`èbuœã
(
œ√s
Ë{ 
i
 => 
ö
.
a
.
bôs
.
	`mask
(
eccByãs
*(i+1)-1,ÉccByãs*i).
‹R
 }

127 
	`whí
 (
ö
.
d
.
	`fúe
()Ë{ 
d_fuŒ
 :
	`Boﬁ
(
Ál£
) }

128 
d_øm_vÆid
 :
	`Boﬁ
(
Ál£
)

129 
d_rmw_mask
 :
	`UI¡
(0)

130 
	`whí
 (
ö
.
a
.
	`fúe
()) {

131 
d_fuŒ
 :
	`Boﬁ
(
åue
)

132 
d_øm_vÆid
 :
a_ªn


133 
d_size
 :
ö
.
a
.
bôs
.
size


134 
d_sour˚
 :
ö
.
a
.
bôs
.
sour˚


135 
d_ªad
 :
a_ªad


136 
d_addªss
 :
a_addªss


137 
d_rmw_mask
 :
	`UI¡
(0)

138 
d_pois⁄
 :
ö
.
a
.
bôs
.
c‹ru±


139 
	`whí
 (!
a_ªad
 && 
a_subœ√
) {

140 
d_rmw_mask
 :
ö
.
a
.
bôs
.
mask


141 
d_rmw_d©a
 :
ö
.
a
.
bôs
.
d©a


143 
d_hñd_îr‹
:
	`Boﬁ
(
Ál£
)

147 
vÆ
 
a_fúe
 = 
ö
.
a
.
	`fúe
()

148 
vÆ
 
wí
 = 
d_wb
 || (
a_fúe
 && !
a_ªn
)

150 
vÆ
 
ªn
 = !
wí
 && 
a_fúe


152 
vÆ
 
addr
 = 
	`Mux
(
d_wb
, 
d_addªss
, 
a_addªss
)

153 
vÆ
 
£l
 = 
	`Mux
(
d_wb
, 
	`Vec
(
d_wb_œ√s
), Vec(
a_œ√s
))

154 
vÆ
 
d©
 = 
	`Mux
(
d_wb
, 
d_wb_d©a
, 
a_d©a
)

155 
vÆ
 
pois⁄
 = 
	`Mux
(
d_wb
, 
	`Vec
(
d_wb_pois⁄
), 
Vec
.
	`fûl
(
œ√s
Ë{ 
ö
.
a
.
bôs
.
c‹ru±
 })

156 
vÆ
 
coded
 = 
	`Vec
((
d©
 
zù
 
pois⁄
Ë
m≠
 { (
d
, 
p
) =>

157 i‡(
code
.
ˇnDëe˘
Ëcode.
	`ícode
(
d
, 
p
) code.encode(d)

160 
d_øw_d©a
 :
mem
.
	`ªad
(
addr
, 
ªn
)

161 
	`whí
 (
wí
Ë{ 
mem
.
	`wrôe
(
addr
, 
coded
, 
£l
) }

164 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

165 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

166 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

168 
	}
}

170 
obje˘
 
TLRAM


172 
def
 
≠∂y
(

173 
addªss
: 
AddªssSë
,

174 
ˇchóbÀ
: 
Boﬁón
 = 
åue
,

175 
execuèbÀ
: 
Boﬁón
 = 
åue
,

176 
bótByãs
: 
I¡
 = 4,

177 
eccByãs
: 
I¡
 = 1,

178 
devName
: 
O±i⁄
[
Såög
] = 
N⁄e
,

179 
code
: 
Code
 = 
√w
 
IdítôyCode
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLInw¨dNode
 =

181 
vÆ
 
øm
 = 
LazyModuÀ
(
√w
 
TLRAM
(
addªss
, 
ˇchóbÀ
, 
execuèbÀ
, 
bótByãs
, 
eccByãs
, 
devName
, 
code
))

182 
	gøm
.
	gnode


187 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


189 
˛ass
 
	$TLRAMSim∂e
(
ømBótByãs
: 
I¡
, 
txns
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

190 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

191 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("SRAMSimple"))

192 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0x0, 0x3ff), 
bótByãs
 = 
ømBótByãs
))

194 
øm
.
node
 :
	`TLDñayî
(0.25Ë:
modñ
.nodê:
fuzz
.node

196 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

197 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

199 
	}
}

201 
˛ass
 
	$TLRAMSim∂eTe°
(
ømBótByãs
: 
I¡
, 
txns
: I¡ = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

202 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMSim∂e
(
ømBótByãs
, 
txns
)).
moduÀ
)

203 
io
.
föished
 :
dut
.io.finished

204 
	}
}

206 
˛ass
 
	$TLRAMECC
(
ømBótByãs
: 
I¡
, 
eccByãs
: I¡, 
txns
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

207 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

208 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("SRAMSimple"))

209 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0x0, 0x3ff), 
bótByãs
 = 
ømBótByãs
, 
eccByãs
 =ÉccByãs, 
code
 =Çew 
SECDEDCode
))

211 
øm
.
node
 :
	`TLDñayî
(0.25Ë:
modñ
.nodê:
fuzz
.node

213 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

214 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

216 
	}
}

218 
˛ass
 
	$TLRAMECCTe°
(
ømBótByãs
: 
I¡
, 
eccByãs
: I¡, 
txns
: I¡ = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

219 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMECC
(
ømBótByãs
, 
eccByãs
, 
txns
)).
moduÀ
)

220 
io
.
föished
 :
dut
.io.finished

221 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SourceShrinker.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

11 ˛as†
	cTLSour˚Shrökî
(
maxInFlight
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


13 
	`ªquúe
 (
maxInFlight
 > 0)

16 
¥iv©e
 
vÆ
 
˛õ¡
 = 
	`TLClõ¡P¨amëîs
(

17 
«me
 = "TLSourceShrinker",

18 
sour˚Id
 = 
	$IdR™ge
(0, 
maxInFlight
))

19 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

21 
˛õ¡Fn
 = { 
˝
 => 
	`TLClõ¡P‹tP¨amëîs
(
˛õ¡s
 = 
	`Seq
(
˛õ¡
.
	`c›y
(
ªque°Fifo
 = cp.˛õ¡s.
	`exi°s
(
_
.requestFifo)))) },

22 
m™agîFn
 = { 
mp
 => mp.
	`c›y
(
m™agîs
 = mp.m™agîs.
	`m≠
(
m
 => m.c›y(
fifoId
 = i‡(
maxInFlight
==1Ë
	`Some
(0Ëm.fifoId))Ë
	}
})

24 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

25 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

27 
	`ªquúe
 (!
edgeIn
.
˛õ¡
.
™ySuµ‹tProbe
 ||

28 !
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
)

30 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

31 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

32 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

33 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

34 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

35 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

37 i‡(
maxInFlight
 >
edgeIn
.
˛õ¡
.
ídSour˚Id
) {

38 
out
.
a
 <> 
ö
.a

39 
ö
.
d
 <> 
out
.d

42 
vÆ
 
sour˚IdM≠
 = 
	`Mem
(
maxInFlight
, 
ö
.
a
.
bôs
.
sour˚
)

43 
vÆ
 
Æloˇãd
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
maxInFlight
))

44 
vÆ
 
√xtFªeOH
 = ~(
	`À·OR
(~
Æloˇãd
) << 1) & ~allocated

45 
vÆ
 
√xtFªe
 = 
	`OHToUI¡
(
√xtFªeOH
)

46 
vÆ
 
fuŒ
 = 
Æloˇãd
.
	`™dR
()

48 
vÆ
 
a_fú°
 = 
edgeIn
.
	`fú°
(
ö
.
a
)

49 
vÆ
 
d_œ°
 = 
edgeIn
.
	`œ°
(
ö
.
d
)

51 
vÆ
 
block
 = 
a_fú°
 && 
fuŒ


52 
ö
.
a
.
ªady
 :
out
.a.ªady && !
block


53 
out
.
a
.
vÆid
 :
ö
.a.vÆid && !
block


54 
out
.
a
.
bôs
 :
ö
.a.bits

55 
out
.
a
.
bôs
.
sour˚
 :
√xtFªe
 
hﬁdU∆ess
 
a_fú°


57 
vÆ
 
by∑ss
 = 
	`Boﬁ
(
edgeOut
.
m™agî
.
möL©ícy
 =0Ë&& 
ö
.
a
.
vÆid
 && !
fuŒ
 && 
a_fú°
 && 
√xtFªe
 ==
out
.
d
.
bôs
.
sour˚


58 
ö
.
d
 <> 
out
.d

59 
ö
.
d
.
bôs
.
sour˚
 :
	`Mux
(
by∑ss
, in.
a
.bôs.sour˚, 
	`sour˚IdM≠
(
out
.d.bits.source))

61 
	`whí
 (
a_fú°
 && 
ö
.
a
.
	`fúe
()) {

62 
	`sour˚IdM≠
(
√xtFªe
Ë:
ö
.
a
.
bôs
.
sour˚


65 
vÆ
 
Æloc
 = 
a_fú°
 && 
ö
.
a
.
	`fúe
()

66 
vÆ
 
‰ì
 = 
d_œ°
 && 
ö
.
d
.
	`fúe
()

67 
vÆ
 
Æloc_id
 = 
	`Mux
(
Æloc
, 
√xtFªeOH
, 
	`UI¡
(0))

68 
vÆ
 
‰ì_id
 = 
	`Mux
(
‰ì
, 
	`UI¡ToOH
(
out
.
d
.
bôs
.
sour˚
), 
	`UI¡
(0))

69 
Æloˇãd
 :◊Œoˇãd | 
Æloc_id
Ë& ~
‰ì_id


72 
	}
}

75 
obje˘
 
TLSour˚Shrökî


77 
def
 
≠∂y
(
maxInFlight
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

79 
vÆ
 
shrökî
 = 
LazyModuÀ
(
√w
 
TLSour˚Shrökî
(
maxInFlight
))

80 
shrökî
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Splitter.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
˛ass
 
	gS∂ôãrArg
[
T
](
	g√wSize
: 
I¡
, 
	gp‹ts
: 
Seq
[T])

10 
˛ass
 
TLS∂ôãrNode
(

11 
˛õ¡Fn
: 
S∂ôãrArg
[
TLClõ¡P‹tP¨amëîs
] => 
Seq
[TLClientPortParameters],

12 
m™agîFn
: 
S∂ôãrArg
[
TLM™agîP‹tP¨amëîs
] => 
Seq
[TLManagerPortParameters])(

13 
im∂icô
 
vÆName
: 
VÆName
)

14 
exãnds
 
TLCu°omNode


16 
def
 
ªsﬁveSèr
(
iKnown
: 
I¡
, 
oKnown
: I¡, 
iSèrs
: I¡, 
oSèrs
: Int): (Int, Int) = {

17 
ªquúe
 (
oKnown
 =0, 
s
"${name} (a splitter)áppearsÑight ofá := or :*=; useá :=* instead${lazyModule.line}")

18 
ªquúe
 (
iSèrs
 =0, 
s
"${name} (a splitter) cannotáppearÜeft ofá :*=; did you mean :=*?${lazyModule.line}")

19 (0, 
	giKnown
)

21 
def
 
m≠P¨amsD
(
n
: 
I¡
, 
p
: 
Seq
[
TLClõ¡P‹tP¨amëîs
]): Seq[TLClientPortParameters] = {

22 
ªquúe
 (
p
.
size
 =0 || 
n
 %Ö.sizê=0, 
s
"Diplomacy bug; splitter inputs doÇot divide outputs")

23 
vÆ
 
	gout
 = 
˛õ¡Fn
(
S∂ôãrArg
(
n
, 
p
))

24 
ªquúe
 (
out
.
size
 =
n
, 
s
"${name} createdÅhe wrongÇumber of outputs from inputs${lazyModule.line}")

25 
	gout


27 
def
 
m≠P¨amsU
(
n
: 
I¡
, 
p
: 
Seq
[
TLM™agîP‹tP¨amëîs
]): Seq[TLManagerPortParameters] = {

28 
ªquúe
 (
n
 =0 || 
p
.
size
 %Ç =0, 
s
"Diplomacy bug; splitter outputs indivisable by inputs")

29 
vÆ
 
	gout
 = 
m™agîFn
(
S∂ôãrArg
(
n
, 
p
))

30 
ªquúe
 (
out
.
size
 =
n
, 
s
"${name} createdÅhe wrongÇumber of inputs from outputs${lazyModule.line}")

31 
	gout


35 
˛ass
 
	$TLS∂ôãr
(
pﬁicy
: 
TLArbôî
.
Pﬁicy
 = TLArbôî.
roundRobö
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


37 
vÆ
 
node
 = 
	`TLS∂ôãrNode
(

38 
˛õ¡Fn
 = { 
	`S∂ôãrArg
(
√wSize
, 
p‹ts
) =>

39 i‡(
√wSize
 =0Ë
Nû
 

40 
Seq
.
	`fûl
(
√wSize
 / 
p‹ts
.
size
Ë{Ö‹t†}.
Ê©ãn


42 
m™agîFn
 = { 
	`S∂ôãrArg
(
√wSize
, 
p‹ts
) =>

43 i‡(
√wSize
 =0Ë
Nû
 

44 
p‹ts
.
	`grou≥d
(
√wSize
).
toLi°
.
å™•o£
.
m≠
 { 
£q
 =>

45 
vÆ
 
fifoIdFa˘‹y
 = 
TLXb¨
.
	`ªœbñî
()

46 
	`£q
(0).
	`c›y
(

47 
möL©ícy
 = 
£q
.
	`m≠
(
_
.möL©ícy).
mö
,

48 
ídSökId
 = 
TLXb¨
.
	`m≠OuçutIds
(
£q
).
	`m≠
(
_
.
íd
).
max
,

49 
m™agîs
 = 
£q
.
Ê©M≠
 { 
p‹t
 =>

50 
	`ªquúe
 (
p‹t
.
bótByãs
 =
	`£q
(0).beatBytes,

51 
s
"Splitter data widths don't match: ${port.managers.map(_.name)} has ${port.beatBytes}B vs ${seq(0).managers.map(_.name)} has ${seq(0).beatBytes}B")

52 
vÆ
 
fifoIdM≠≥r
 = 
	`fifoIdFa˘‹y
()

53 
p‹t
.
m™agîs
 
m≠
 { 
m™agî
 => m™agî.
	`c›y
(

54 
fifoId
 = 
m™agî
.fifoId.
	`m≠
(
	`fifoIdM≠≥r
(
_
))

61 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

62 
def
 
group
[
T
](
x
: 
Seq
[T]) =

63 i‡(
x
.
isEm±y
Ë
Nû
 x.
	`grou≥d
(
node
.
ö
.
size
).
toLi°
.
å™•o£


65 i‡(
node
.
out
.
size
 =node.
ö
.size) {

66 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((
i
, 
_
), (
o
, _)) => o <> i }

67 } (
node
.
ö
 
zù
 
	`group
“ode.
out
)Ë
f‹óch
 {

68 ((
io_ö
, 
edgeIn
), 
£q
) =>

69 
	`vÆ
 (
io_out
, 
edgesOut
Ë
£q
.
unzù


72 
vÆ
 
ouçutIdR™ges
 = 
TLXb¨
.
	`m≠OuçutIds
(
edgesOut
.
	`m≠
(
_
.
m™agî
))

75 
vÆ
 
p‹t_addrs
 = 
edgesOut
.
	`m≠
(
_
.
m™agî
.
m™agîs
.m≠(_.
addªss
).
Ê©ãn
)

76 
vÆ
 
routögMask
 = 
	`AddªssDecodî
(
p‹t_addrs
)

77 
vÆ
 
rouã_addrs
 = 
p‹t_addrs
.
	`m≠
(
£q
 => 
AddªssSë
.
	`unify
(£q.m≠(
_
.
	`widí
(~
routögMask
)).
di°ö˘
))

78 
vÆ
 
ouçutP‹ts
 = 
rouã_addrs
.
	`m≠
(
£q
 => (
addr
: 
UI¡
Ë=> seq.m≠(
_
.
	`c⁄èös
◊ddr)).
	`ªdu˚
(_ || _))

81 
vÆ
 
wide_bundÀ
 = 
TLBundÀP¨amëîs
.(
	`Seq
(
io_ö
.
∑øms
Ë++ 
io_out
.
	`m≠
(
_
.params))

84 
vÆ
 
ö
 = 
	`Wúe
(
	`TLBundÀ
(
wide_bundÀ
))

85 
ö
.
a
 <> 
io_ö
.a

86 
io_ö
.
d
 <> 
ö
.d

88 i‡(
edgeIn
.
˛õ¡
.
™ySuµ‹tProbe
 && 
edgesOut
.
	`exi°s
(
_
.
m™agî
.
™ySuµ‹tAcquúeB
)) {

89 
ö
.
c
 <> 
io_ö
.c

90 
ö
.
e
 <> 
io_ö
.e

91 
io_ö
.
b
 <> 
ö
.b

93 
ö
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

94 
ö
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

95 
ö
.
b
.
ªady
 :
	`Boﬁ
(
Ál£
)

96 
io_ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

97 
io_ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

98 
io_ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

102 
def
 
	`åim
(
id
: 
UI¡
, 
size
: 
I¡
Ëi‡(sizê<1Ë
	`UI¡
(0Ë
	`id
(
	`log2Ceû
(size)-1, 0)

105 
vÆ
 
out
 = 
	`Wúe
(
	`Vec
(
io_out
.
size
, 
	`TLBundÀ
(
wide_bundÀ
)))

106 
i
 <- 0 
u¡û
 
out
.
size
) {

107 
vÆ
 
r
 = 
	`ouçutIdR™ges
(
i
)

109 
	`io_out
(
i
).
a
 <> 
	`out
(i).a

110 
	`out
(
i
).
d
 <> 
	`io_out
(i).d

111 
	`out
(
i
).
d
.
bôs
.
sök
 :
	`io_out
(i).d.bôs.sök | 
	`UI¡
(
r
.
°¨t
)

113 i‡(
	`edgesOut
(
i
).
m™agî
.
™ySuµ‹tAcquúeB
 && 
edgeIn
.
˛õ¡
.
™ySuµ‹tProbe
) {

114 
	`io_out
(
i
).
c
 <> 
	`out
(i).c

115 
	`io_out
(
i
).
e
 <> 
	`out
(i).e

116 
	`out
(
i
).
b
 <> 
	`io_out
(i).b

117 
	`io_out
(
i
).
e
.
bôs
.
sök
 :
	`åim
(
	`out
(i).e.bôs.sök, 
r
.
size
)

119 
	`out
(
i
).
c
.
ªady
 :
	`Boﬁ
(
Ál£
)

120 
	`out
(
i
).
e
.
ªady
 :
	`Boﬁ
(
Ál£
)

121 
	`out
(
i
).
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

122 
	`io_out
(
i
).
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

123 
	`io_out
(
i
).
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

124 
	`io_out
(
i
).
b
.
ªady
 :
	`Boﬁ
(
åue
)

128 
vÆ
 
ªque°A
 = 
	`Vec
(
ouçutP‹ts
.
m≠
 { 
o
 => 
	`o
(
ö
.
a
.
bôs
.
addªss
) })

129 
vÆ
 
ªque°C
 = 
	`Vec
(
ouçutP‹ts
.
m≠
 { 
o
 => 
	`o
(
ö
.
c
.
bôs
.
addªss
) })

130 
vÆ
 
ªque°E
 = 
	`Vec
(
ouçutIdR™ges
.
m≠
 { 
o
 => o.
	`c⁄èös
(
ö
.
e
.
bôs
.
sök
) })

131 (
out
.
	`m≠
(
_
.
a
Ë
zù
 
TLXb¨
.
	`Ánout
(
ö
.a, 
ªque°A
)Ë
f‹óch
 { (
o
, 
i
) => o <> i }

132 (
out
.
	`m≠
(
_
.
c
Ë
zù
 
TLXb¨
.
	`Ánout
(
ö
.c, 
ªque°C
)Ë
f‹óch
 { (
o
, 
i
) => o <> i }

133 (
out
.
	`m≠
(
_
.
e
Ë
zù
 
TLXb¨
.
	`Ánout
(
ö
.e, 
ªque°E
)Ë
f‹óch
 { (
o
, 
i
) => o <> i }

135 
vÆ
 
bótsB
 = 
	`Vec
((
out
 
zù
 
edgesOut
Ë
m≠
 { (
o
, 
e
Ë=>É.
	`numBóts1
(o.
b
.
bôs
) })

136 
vÆ
 
bótsD
 = 
	`Vec
((
out
 
zù
 
edgesOut
Ë
m≠
 { (
o
, 
e
Ë=>É.
	`numBóts1
(o.
d
.
bôs
) })

137 
	`TLArbôî
(
pﬁicy
)(
ö
.
b
, (
bótsB
 
zù
 
out
.
	`m≠
(
_
.b)):_*)

138 
	`TLArbôî
(
pﬁicy
)(
ö
.
d
, (
bótsD
 
zù
 
out
.
	`m≠
(
_
.d)):_*)

141 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAHB.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	gahb
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
, 
	gmax
}

11 
imp‹t
 
	gAHBP¨amëîs
.
_


13 
˛ass
 
	$TLToAHBNode
(
suµ‹tHöts
: 
Boﬁón
)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$MixedAd≠ãrNode
(
TLImp
, 
AHBImp
)(

14 
dFn
 = { 
	`TLClõ¡P‹tP¨amëîs
(
˛õ¡s
, 
möL©ícy
) =>

15 
vÆ
 
ma°îs
 = 
˛õ¡s
.
m≠
 { 
c
 => 
	`AHBMa°îP¨amëîs
(
«me
 = c.«me, 
nodeP©h
 = c.nodePath) }

16 
	`AHBMa°îP‹tP¨amëîs
(
ma°îs
)

17 
	}
},

18 
	guFn
 = { 
AHBSœveP‹tP¨amëîs
(
¶aves
, 
bótByãs
) =>

19 
vÆ
 
m™agîs
 = 
¶aves
.
m≠
 { 
s
 =>

20 
TLM™agîP¨amëîs
(

21 
addªss
 = 
s
.address,

22 
ªsour˚s
 = 
s
.resources,

23 
ªgi⁄Ty≥
 = 
s
.regionType,

24 
execuèbÀ
 = 
s
.executable,

25 
nodeP©h
 = 
s
.nodePath,

26 
suµ‹tsGë
 = 
s
.
suµ‹tsRód
,

27 
suµ‹tsPutFuŒ
 = 
s
.
suµ‹tsWrôe
,

28 
suµ‹tsHöt
 = i‡(!
suµ‹tHöts
Ë
Tøns„rSizes
.
n⁄e
 

29 i‡(
s
.
suµ‹tsRód
) s.supportsRead 

30 i‡(
s
.
suµ‹tsWrôe
) s.supportsWrite 

31 
Tøns„rSizes
(1, 
bótByãs
),

32 
fifoId
 = 
Some
(0),

33 
mayDíyPut
 = 
åue
)

35 
TLM™agîP‹tP¨amëîs
(
m™agîs
, 
bótByãs
, 0, 1)

38 ˛as†
	cAHBC⁄åﬁBundÀ
(
∑øms
: 
TLEdge
Ë
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

40 
vÆ
 
fuŒ
 = 
	$Boﬁ
()

41 
vÆ
 
£nd
 = 
	$Boﬁ
()

42 
vÆ
 
fú°
 = 
	$Boﬁ
()

43 
vÆ
 
œ°
 = 
	$Boﬁ
()

44 
vÆ
 
höt
 = 
	$Boﬁ
()

45 
vÆ
 
wrôe
 = 
	$Boﬁ
()

46 
vÆ
 
size
 = 
	$UI¡
(
width
 = 
∑øms
.
bundÀ
.
sizeBôs
)

47 
vÆ
 
sour˚
 = 
	$UI¡
(
width
 = 
∑øms
.
bundÀ
.
sour˚Bôs
)

48 
vÆ
 
hsize
 = 
	$UI¡
(
width
 = 
AHBP¨amëîs
.
sizeBôs
)

49 
vÆ
 
hbur°
 = 
	$UI¡
(
width
 = 
AHBP¨amëîs
.
bur°Bôs
)

50 
vÆ
 
addr
 = 
	$UI¡
(
width
 = 
∑øms
.
bundÀ
.
addªssBôs
)

51 
vÆ
 
d©a
 = 
	`UI¡
(
width
 = 
∑øms
.
bundÀ
.
d©aBôs
)

56 
˛ass
 
	$TLToAHB
(
vÆ
 
aFlow
: 
Boﬁón
 = 
Ál£
, vÆ 
suµ‹tHöts
: Boﬁó¿
åue
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


58 
vÆ
 
node
 = 
	`TLToAHBNode
(
suµ‹tHöts
)

60 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

61 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

62 
vÆ
 
bótByãs
 = 
edgeOut
.
¶ave
.beatBytes

63 
vÆ
 
maxTøns„r
 = 
edgeOut
.
¶ave
.maxTransfer

64 
vÆ
 
lgMax
 = 
	`log2Ceû
(
maxTøns„r
)

65 
vÆ
 
lgByãs
 = 
	`log2Ceû
(
bótByãs
)

68 
vÆ
 
ª£tSèã
 = 
	`Wúe
(
√w
 
	`AHBC⁄åﬁBundÀ
(
edgeIn
))

69 
ª£tSèã
.
fuŒ
 :
	`Boﬁ
(
Ál£
)

70 
ª£tSèã
.
£nd
 :
	`Boﬁ
(
Ál£
)

71 
ª£tSèã
.
fú°
 :
	`Boﬁ
(
åue
)

73 
ª£tSèã
.
hsize
 :
	`UI¡
(0)

74 
ª£tSèã
.
hbur°
:
	`UI¡
(0)

75 
ª£tSèã
.
addr
 :
	`UI¡
(0)

78 
vÆ
 
ªg
 = 
	`RegInô
(
ª£tSèã
)

79 
vÆ
 
£nd
 = 
	`Wúe
(
öô
 = 
ªg
)

80 
vÆ
 
°ï
 = 
	`Wúe
(
öô
 = 
£nd
)

81 
vÆ
 
√xt
 = 
	`Wúe
(
öô
 = 
°ï
)

82 
ªg
 :
√xt


85 
vÆ
 
a_Êow
 = 
	`Wúe
(
	`Boﬁ
())

88 
	`whí
 (
£nd
.£nd && !
a_Êow
) {

89 
°ï
.
fuŒ
 :
	`Boﬁ
(
åue
)

90 
°ï
.
£nd
 :
	`Boﬁ
(
åue
)

91 } .
	`ñ£whí
 (
£nd
.
fuŒ
 && !send.send) {

92 
°ï
.
fuŒ
 :
	`Boﬁ
(
åue
)

93 
°ï
.
£nd
 :
	`Boﬁ
(
Ál£
)

94 } .
	`ñ£whí
 (
£nd
.
fuŒ
 && !£nd.
œ°
) {

95 
°ï
.
fuŒ
 :
	`Boﬁ
(
åue
)

96 
°ï
.
£nd
 :
	`Boﬁ
(
Ál£
)

97 
°ï
.
fú°
 :
	`Boﬁ
(
Ál£
)

98 
°ï
.
œ°
 :(i‡(
lgByãs
 + 1 >
lgMax
Ë
	`Boﬁ
(
åue
) 

99 !((
	`UI¡ToOH1
(
£nd
.
size
, 
lgMax
Ë& ~£nd.
addr
Ë>> (
lgByãs
 + 1)).
	`‹R
())

100 
°ï
.
addr
 :
	`C©
(
£nd
.
	`addr
(
edgeIn
.
bundÀ
.
addªssBôs
-1, 
lgMax
), síd.addr÷gMax-1, 0Ë+ 
	`UI¡
(
bótByãs
))

101 } .
Ÿhîwi£
 {

102 
°ï
.
fuŒ
 :
	`Boﬁ
(
Ál£
)

103 
°ï
.
£nd
 :
	`Boﬁ
(
Ál£
)

104 
°ï
.
fú°
 :
	`Boﬁ
(
åue
)

107 
vÆ
 
d_block
 = 
	`Wúe
(
	`Boﬁ
())

108 
vÆ
 
¥e
 = i‡(
aFlow
Ë
ªg
 
°ï


109 
vÆ
 
po°
 = i‡(
aFlow
Ë
£nd
 
√xt


112 
vÆ
 
a_sizeDñè
 = 
	`C©
(
	`UI¡
(0, 
width
 = 1), 
ö
.
a
.
bôs
.
size
Ë- UI¡(
lgByãs
+1)

113 
vÆ
 
a_höt
 = 
ö
.
a
.
bôs
.
›code
 ==
TLMesßges
.
Höt
 && 
	`Boﬁ
(
suµ‹tHöts
)

114 
vÆ
 
a_sögÀBót
 = 
a_höt
 || 
	`Boﬁ
(
lgByãs
 >
lgMax
Ë|| 
	`a_sizeDñè
(
edgeIn
.
bundÀ
.
sizeBôs
)

115 
vÆ
 
a_logBóts1
 = 
	`a_sizeDñè
(
edgeIn
.
bundÀ
.
sizeBôs
-1, 0)

118 
vÆ
 
a_commô
 = 
	`Wúe
(
	`Boﬁ
())

121 
	`whí
 (
¥e
.
£nd
) {

122 
a_commô
 :
	`Boﬁ
(
Ál£
)

123 
ö
.
a
.
ªady
 :
	`Boﬁ
(
Ál£
)

124 } .
	`ñ£whí
 (
¥e
.
fuŒ
) {

125 
po°
.
£nd
 :!
d_block
 && (!
¥e
.
wrôe
 || 
ö
.
a
.
vÆid
)

126 
po°
.
d©a
 :
ö
.
a
.
bôs
.data

127 
a_commô
 :!
d_block
 && !
¥e
.
wrôe


128 
ö
.
a
.
ªady
 :!
d_block
 && 
¥e
.
wrôe


129 } .
Ÿhîwi£
 {

130 
a_commô
 :
ö
.
a
.
	`fúe
()

131 
ö
.
a
.
ªady
 :!
d_block


132 
	`whí
 (
ö
.
a
.
	`fúe
()) {

133 
po°
.
fuŒ
 :
	`Boﬁ
(
åue
)

134 
po°
.
£nd
 :
	`Boﬁ
(
åue
)

135 
po°
.
œ°
 :
a_sögÀBót


136 
po°
.
höt
 :
a_höt


137 
po°
.
size
 :
ö
.
a
.
bôs
.size

138 
po°
.
sour˚
:
ö
.
a
.
bôs
.source

140 
	`whí
 (
ö
.
a
.
	`fúe
(Ë&& !
a_höt
) {

141 
po°
.
wrôe
 :
edgeIn
.
	`hasD©a
(
ö
.
a
.
bôs
)

142 
po°
.
hsize
 :
	`Mux
(
a_sögÀBót
, 
ö
.
a
.
bôs
.
size
, 
	`UI¡
(
lgByãs
))

143 
po°
.
hbur°
:
	`Mux
(
a_sögÀBót
, 
BURST_SINGLE
, (
a_logBóts1
<<1Ë| 
	`UI¡
(1))

144 
po°
.
addr
 :
ö
.
a
.
bôs
.
addªss


145 
po°
.
d©a
 :
ö
.
a
.
bôs
.data

149 
out
.
hma°lock
 :
	`Boﬁ
(
Ál£
)

150 
out
.
hå™s
 :
	`Mux
(
£nd
.£nd && !£nd.
höt
,

151 
	`Mux
(
£nd
.
fú°
, 
TRANS_NONSEQ
, 
TRANS_SEQ
),

152 
	`Mux
(
£nd
.
fú°
, 
TRANS_IDLE
, 
TRANS_BUSY
))

153 
out
.
h£l
 :(
£nd
.£nd && !£nd.
höt
Ë|| !£nd.
fú°


154 
out
.
hªady
 :out.
hªadyout


155 
out
.
hwrôe
 :
£nd
.
wrôe


156 
out
.
haddr
 :
£nd
.
addr


157 
out
.
hsize
 :
£nd
.hsize

158 
out
.
hbur°
 :
£nd
.hburst

159 
out
.
h¥Ÿ
 :
PROT_DEFAULT


160 
out
.
hwd©a
 :
	`RegE«bÀ
(
£nd
.
d©a
, out.
hªadyout
)

168 
vÆ
 
dïth
 = i‡(
aFlow
) 2 3

169 
vÆ
 
d
 = 
	`Wúe
(
ö
.d)

170 
ö
.
d
 <> 
	`Queue
(d, 
dïth
, 
Êow
=
åue
)

171 
	`as£π
 (!
d
.
vÆid
 || d.
ªady
)

173 
vÆ
 
d_Êight
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 2))

174 
	`as£π
 (
d_Êight
 <
	`UI¡
(
dïth
))

175 
d_Êight
 :d_Êighà+ 
a_commô
.
asUI¡
 - 
ö
.
d
.
	`fúe
().asUInt

176 
d_block
 :
d_Êight
 >
	`UI¡
(
dïth
)

178 
vÆ
 
d_vÆid
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

179 
vÆ
 
d_díõd
 = 
	`Reg
(
	`Boﬁ
())

180 
vÆ
 
d_höt
 = 
	`RegE«bÀ
(
£nd
.
höt
, 
a_Êow
 && send.send)

181 
vÆ
 
d_wrôe
 = 
	`RegE«bÀ
(
£nd
.
wrôe
, 
a_Êow
 && send.send)

182 
vÆ
 
d_sour˚
 = 
	`RegE«bÀ
(
£nd
.
sour˚
, 
a_Êow
 && send.send)

183 
vÆ
 
d_size
 = 
	`RegE«bÀ
(
£nd
.
size
, 
a_Êow
 && send.send)

185 
	`whí
 (
out
.
hªadyout
) {

186 
d_vÆid
 :
£nd
.£nd && (£nd.
œ°
 || !£nd.
wrôe
)

187 
	`whí
 (
out
.
hª•
Ë{ 
d_díõd
 :
	`Boﬁ
(
åue
) }

188 
	`whí
 (
£nd
.
fú°
Ë{ 
d_díõd
 :
	`Boﬁ
(
Ál£
) }

189 } .
	`ñ£whí
 (
d_höt
) {

190 
d_vÆid
 :
	`Boﬁ
(
Ál£
)

193 
d
.
vÆid
 :
d_vÆid
 && (
out
.
hªadyout
 || 
d_höt
)

194 
d
.
bôs
 :
edgeIn
.
	`Ac˚ssAck
(
d_sour˚
, 
d_size
, 
out
.
hrd©a
)

195 
d
.
bôs
.
›code
 :
	`Mux
(
d_höt
, 
TLMesßges
.
HötAck
, Mux(
d_wrôe
, TLMesßges.
Ac˚ssAck
, TLMesßges.
Ac˚ssAckD©a
))

196 
d
.
bôs
.
díõd
 :(
out
.
hª•
 || 
d_díõd
Ë&& 
d_wrôe
 && !
d_höt


197 
d
.
bôs
.
c‹ru±
 :
out
.
hª•
 && !
d_wrôe
 && !
d_höt


200 
vÆ
 
skù
 = 
	`Boﬁ
(
suµ‹tHöts
Ë&& 
£nd
.
höt
 && (!
d_vÆid
 || 
d_höt
)

201 
a_Êow
 :
out
.
hªadyout
 || 
skù


204 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

205 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

206 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

209 
	}
}

211 
obje˘
 
TLToAHB


213 
def
 
≠∂y
(
aFlow
: 
Boﬁón
 = 
åue
, 
suµ‹tHöts
: Boﬁó¿åue)(
im∂icô
 
p
: 
P¨amëîs
) =

215 
vÆ
 
é2ahb
 = 
LazyModuÀ
(
√w
 
TLToAHB
(
aFlow
, 
suµ‹tHöts
))

216 
	gé2ahb
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAPB.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	g≠b
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
, 
	gmax
}

10 
imp‹t
 
	gAPBP¨amëîs
.
_


12 
˛ass
 
	$TLToAPBNode
()(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$MixedAd≠ãrNode
(
TLImp
, 
APBImp
)(

13 
dFn
 = { 
	`TLClõ¡P‹tP¨amëîs
(
˛õ¡s
, 
möL©ícy
) =>

14 
vÆ
 
ma°îs
 = 
˛õ¡s
.
m≠
 { 
c
 => 
	`APBMa°îP¨amëîs
(
«me
 = c.«me, 
nodeP©h
 = c.nodePath) }

15 
	`APBMa°îP‹tP¨amëîs
(
ma°îs
)

16 
	}
},

17 
	guFn
 = { 
APBSœveP‹tP¨amëîs
(
¶aves
, 
bótByãs
) =>

18 
vÆ
 
m™agîs
 = 
¶aves
.
m≠
 { 
s
 =>

19 
TLM™agîP¨amëîs
(

20 
addªss
 = 
s
.address,

21 
ªsour˚s
 = 
s
.resources,

22 
ªgi⁄Ty≥
 = 
s
.regionType,

23 
execuèbÀ
 = 
s
.executable,

24 
nodeP©h
 = 
s
.nodePath,

25 
suµ‹tsGë
 = i‡(
s
.
suµ‹tsRód
Ë
Tøns„rSizes
(1, 
bótByãs
ËTøns„rSizes.
n⁄e
,

26 
suµ‹tsPutP¨tül
 = i‡(
s
.
suµ‹tsWrôe
Ë
Tøns„rSizes
(1, 
bótByãs
ËTøns„rSizes.
n⁄e
,

27 
suµ‹tsPutFuŒ
 = i‡(
s
.
suµ‹tsWrôe
Ë
Tøns„rSizes
(1, 
bótByãs
ËTøns„rSizes.
n⁄e
,

28 
fifoId
 = 
Some
(0),

29 
mayDíyPut
 = 
åue
)

31 
TLM™agîP‹tP¨amëîs
(
m™agîs
, 
bótByãs
, 0, 1)

36 
˛ass
 
	$TLToAPB
(
vÆ
 
aFlow
: 
Boﬁón
 = 
åue
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


38 
vÆ
 
node
 = 
	`TLToAPBNode
()

40 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

41 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

42 
vÆ
 
bótByãs
 = 
edgeOut
.
¶ave
.beatBytes

43 
vÆ
 
lgByãs
 = 
	`log2Ceû
(
bótByãs
)

46 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

47 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

48 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

56 
vÆ
 
d
 = 
	`Wúe
(
ö
.d)

57 
ö
.
d
 <> 
	`Queue
(d, 1, 
Êow
 = 
åue
)

60 
vÆ
 
a
 = 
	`Queue
(
ö
.a, 1, 
Êow
 = 
aFlow
, 
pùe
 = !aFlow)

62 
vÆ
 
a_íabÀ
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

63 
vÆ
 
a_£l
 = 
a
.
vÆid
 && 
	`RegNext
(!
ö
.
d
.vÆid || in.d.
ªady
)

64 
vÆ
 
a_wrôe
 = 
edgeIn
.
	`hasD©a
(
a
.
bôs
)

66 
vÆ
 
íabÀ_d
 = 
a_£l
 && !
a_íabÀ


67 
vÆ
 
d_wrôe
 = 
	`RegE«bÀ
(
a_wrôe
, 
íabÀ_d
)

68 
vÆ
 
d_sour˚
 = 
	`RegE«bÀ
(
a
.
bôs
.
sour˚
, 
íabÀ_d
)

69 
vÆ
 
d_size
 = 
	`RegE«bÀ
(
a
.
bôs
.
size
, 
íabÀ_d
)

71 
	`whí
 (
a_£l
Ë{ 
a_íabÀ
 :
	`Boﬁ
(
åue
) }

72 
	`whí
 (
d
.
	`fúe
()Ë{ 
a_íabÀ
 :
	`Boﬁ
(
Ál£
) }

74 
out
.
p£l
 :
a_£l


75 
out
.
≥«bÀ
 :
a_íabÀ


76 
out
.
pwrôe
 :
a_wrôe


77 
out
.
∑ddr
 :
a
.
bôs
.
addªss


78 
out
.
µrŸ
 :
PROT_DEFAULT


79 
out
.
pwd©a
 :
a
.
bôs
.
d©a


80 
out
.
p°rb
 :
	`Mux
(
a_wrôe
, 
a
.
bôs
.
mask
, 
	`UI¡
(0))

82 
a
.
ªady
 :
a_íabÀ
 && 
out
.
¥ódy


83 
d
.
vÆid
 :
a_íabÀ
 && 
out
.
¥ódy


84 
	`as£π
 (!
d
.
vÆid
 || d.
ªady
)

86 
d
.
bôs
.
›code
 :
	`Mux
(
d_wrôe
, 
TLMesßges
.
Ac˚ssAck
, TLMesßges.
Ac˚ssAckD©a
)

87 
d
.
bôs
.
∑øm
 :
	`UI¡
(0)

88 
d
.
bôs
.
size
 :
d_size


89 
d
.
bôs
.
sour˚
 :
d_sour˚


90 
d
.
bôs
.
sök
 :
	`UI¡
(0)

91 
d
.
bôs
.
díõd
 :
d_wrôe
 && 
out
.
p¶vîr


92 
d
.
bôs
.
d©a
 :
out
.
¥d©a


93 
d
.
bôs
.
c‹ru±
 :!
d_wrôe
 && 
out
.
p¶vîr


96 
	}
}

98 
obje˘
 
TLToAPB


100 
def
 
≠∂y
(
aFlow
: 
Boﬁón
 = 
åue
)(
im∂icô
 
p
: 
P¨amëîs
) =

102 
vÆ
 
é2≠b
 = 
LazyModuÀ
(
√w
 
TLToAPB
(
aFlow
))

103 
é2≠b
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAXI4.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	gaxi4
.
_


10 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
, 
	gmax
}

12 
˛ass
 
	$TLtoAXI4IdM≠
(
é
: 
TLClõ¡P‹tP¨amëîs
, 
axi4
: 
AXI4Ma°îP‹tP¨amëîs
) {

13 
¥iv©e
 
vÆ
 
axiDigôs
 = 
Såög
.
	`vÆueOf
(
axi4
.
ídId
-1).
	`Àngth
()

14 
¥iv©e
 
vÆ
 
éDigôs
 = 
Såög
.
	`vÆueOf
(
é
.
ídSour˚Id
-1).
	`Àngth
()

15 
¥iv©e
 
vÆ
 
fmt
 = 
s
"\t[%${axiDigits}d, %${axiDigits}d) <= [%${tlDigits}d, %${tlDigits}d) %s%s%s"

16 
¥iv©e
 
vÆ
 
s‹ãd
 = 
é
.
˛õ¡s
.
	`s‹tWôh
(
TLToAXI4
.
s‹tByTy≥
)

18 
vÆ
 
m≠pög
: 
Seq
[
TLToAXI4IdM≠E¡ry
] = (
s‹ãd
 
zù
 
axi4
.
ma°îs
Ë
m≠
 { (
c
, 
m
) =>

19 
	`TLToAXI4IdM≠E¡ry
(
m
.
id
, 
c
.
sour˚Id
, c.
«me
, c.
suµ‹tsProbe
, c.
ªque°Fifo
)

22 
def
 
¥ëty
: 
Såög
 = 
m≠pög
.
	`m≠
(
_
.
	`¥ëty
(
fmt
)).
	`mkSåög
(",\n")

23 
	}
}

25 
˛ass
 
	$TLToAXI4IdM≠E¡ry
(
axi4Id
: 
IdR™ge
, 
éId
: IdR™ge, 
«me
: 
Såög
, 
isCache
: 
Boﬁón
, 
ªque°Fifo
: Boolean) {

26 
def
 
	`¥ëty
(
fmt
: 
Såög
Ëfmt.
	`f‹m©
(

27 
axi4Id
.
°¨t
,

28 
axi4Id
.
íd
,

29 
éId
.
°¨t
,

30 
éId
.
íd
,

31 
s
""""
$«me
"""",

32 i‡(
isCache
) " [CACHE]" "",

33 i‡(
ªque°Fifo
) " [FIFO]" "")

34 
	}
}

36 
˛ass
 
	$TLToAXI4Node
(
°rùBôs
: 
I¡
 = 0)(
im∂icô
 
vÆName
: 
VÆName
Ë
exãnds
 
	$MixedAd≠ãrNode
(
TLImp
, 
AXI4Imp
)(

37 
dFn
 = { 
p
 =>

38 
p
.
˛õ¡s
.
f‹óch
 { 
c
 =>

39 
	`ªquúe
 (
c
.
sour˚Id
.
°¨t
 % (1 << 
°rùBôs
) == 0 &&

40 
c
.
sour˚Id
.
íd
 % (1 << 
°rùBôs
) == 0,

41 
s
"Cannot strip bits ofáligned client ${c.name}: ${c.sourceId}")

43 
vÆ
 
˛õ¡s
 = 
p
.˛õ¡s.
	`s‹tWôh
(
TLToAXI4
.
s‹tByTy≥
 
_
)

44 
vÆ
 
idSize
 = 
˛õ¡s
.
m≠
 { 
c
 => i‡(c.
ªque°Fifo
Ë1 (c.
sour˚Id
.
size
 >> 
°rùBôs
) }

45 
vÆ
 
idSèπ
 = 
idSize
.
	`sˇnLe·
(0)(
_
+_).
öô


46 
vÆ
 
ma°îs
 = ((
idSèπ
 
zù
 
idSize
Ëzù 
˛õ¡s
Ë
m≠
 { ((
°¨t
, 
size
), 
c
) =>

47 
	`AXI4Ma°îP¨amëîs
(

48 
«me
 = 
c
.name,

49 
id
 = 
	`IdR™ge
(
°¨t
, sèπ+
size
),

50 
Æig√d
 = 
åue
,

51 
maxFlight
 = 
	`Some
(i‡(
c
.
ªque°Fifo
Ëc.
sour˚Id
.
size
 (1 << 
°rùBôs
)),

52 
nodeP©h
 = 
c
.nodePath)

54 
	`AXI4Ma°îP‹tP¨amëîs
(

55 
ma°îs
 = masters,

56 
u£rBôs
 = 
	`log2Ceû
(
p
.
ídSour˚Id
) + 4)

57 
	}
},

58 
	guFn
 = { 
p
 => 
TLM™agîP‹tP¨amëîs
(

59 
m™agîs
 = 
p
.
¶aves
.
m≠
 { 
s
 =>

60 
TLM™agîP¨amëîs
(

61 
addªss
 = 
s
.address,

62 
ªsour˚s
 = 
s
.resources,

63 
ªgi⁄Ty≥
 = 
s
.regionType,

64 
execuèbÀ
 = 
s
.executable,

65 
nodeP©h
 = 
s
.nodePath,

66 
suµ‹tsGë
 = 
s
.
suµ‹tsRód
,

67 
suµ‹tsPutFuŒ
 = 
s
.
suµ‹tsWrôe
,

68 
suµ‹tsPutP¨tül
 = 
s
.
suµ‹tsWrôe
,

69 
fifoId
 = 
Some
(0),

70 
mayDíyPut
 = 
åue
,

71 
mayDíyGë
 = 
åue
)},

72 
bótByãs
 = 
p
.beatBytes,

73 
möL©ícy
 = 
p
.minLatency)

76 
˛ass
 
	$TLToAXI4
(
vÆ
 
combö©i⁄Æ
: 
Boﬁón
 = 
åue
, vÆ 
ad≠ãrName
: 
O±i⁄
[
Såög
] = 
N⁄e
, vÆ 
°rùBôs
: 
I¡
 = 0)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


78 
vÆ
 
node
 = 
	`TLToAXI4Node
(
°rùBôs
)

80 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

81 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

82 
vÆ
 
¶aves
 = 
edgeOut
.
¶ave
.slaves

85 
	`ªquúe
 (
	`¶aves
(0).
öãæóvedId
.
isDeföed
)

86 
¶aves
.
f‹óch
 { 
s
 => 
	`ªquúe
 (s.
öãæóvedId
 =
	`¶aves
(0).interleavedId) }

89 
vÆ
 
m≠
 = 
√w
 
	`TLtoAXI4IdM≠
(
edgeIn
.
˛õ¡
, 
edgeOut
.
ma°î
)

90 
vÆ
 
sour˚SèŒ
 = 
	`Wúe
(
	`Vec
(
edgeIn
.
˛õ¡
.
ídSour˚Id
, 
	`Boﬁ
()))

91 
vÆ
 
sour˚TabÀ
 = 
	`Wúe
(
	`Vec
(
edgeIn
.
˛õ¡
.
ídSour˚Id
, 
out
.
aw
.
bôs
.
id
))

92 
vÆ
 
idSèŒ
 = 
	`Wúe
(
öô
 = 
Vec
.
	`fûl
(
edgeOut
.
ma°î
.
ídId
Ë{ 
	`Boﬁ
(
Ál£
) })

93 
v¨
 
idCou¡
 = 
Aºay
.
	`fûl
(
edgeOut
.
ma°î
.
ídId
Ë{ 
N⁄e
:
O±i⁄
[
I¡
] }

95 
A¬Ÿ©ed
.
	`idM≠pög
(
this
, 
m≠
.
m≠pög
).
f‹óch
 { 
	`TLToAXI4IdM≠E¡ry
(
axi4Id
, 
éId
, 
_
, _, 
fifo
) =>

96 
i
 <- 0 
u¡û
 
éId
.
size
) {

97 
vÆ
 
id
 = 
axi4Id
.
°¨t
 + (i‡(
fifo
Ë0 (
i
 >> 
°rùBôs
))

98 
	`sour˚SèŒ
(
éId
.
°¨t
 + 
i
Ë:
	`idSèŒ
(
id
)

99 
	`sour˚TabÀ
(
éId
.
°¨t
 + 
i
Ë:
	`UI¡
(
id
)

101 i‡(
fifo
Ë{ 
	`idCou¡
(
axi4Id
.
°¨t
Ë
	`Some
(
éId
.
size
) }

104 
ad≠ãrName
.
f‹óch
 { 
n
 =>

105 
	`¥öén
(
s
"$n AXI4-ID <= TL-Source mapping:\n${map.pretty}\n")

106 
Eœb‹©i⁄AπeÁ˘s
.
	`add
(
s
"$n.axi4.js⁄", s"""{"
m≠pög
":[${map.mapping.mkString(",")}]}""")

113 
vÆ
 
sour˚Bôs
 = 
	`log2Ceû
(
edgeIn
.
˛õ¡
.
ídSour˚Id
)

114 
vÆ
 
sizeBôs
 = 
	`log2Ceû
(
edgeIn
.
maxLgSize
+1)

115 
vÆ
 
°©eBôs
 = 
sizeBôs
 + 
sour˚Bôs


116 
	`ªquúe
 (
°©eBôs
 <
out
.
aw
.
bôs
.
∑øms
.
u£rBôs
)

118 
vÆ
 
a_addªss
 = 
edgeIn
.
	`addªss
(
ö
.
a
.
bôs
)

119 
vÆ
 
a_sour˚
 = 
ö
.
a
.
bôs
.
sour˚


120 
vÆ
 
a_size
 = 
edgeIn
.
	`size
(
ö
.
a
.
bôs
)

121 
vÆ
 
a_isPut
 = 
edgeIn
.
	`hasD©a
(
ö
.
a
.
bôs
)

122 
	`vÆ
 (
a_fú°
, 
a_œ°
, 
_
Ë
edgeIn
.
	`fú°œ°
(
ö
.
a
)

125 
	`as£π
 (
a_sour˚
 < 
	`UI¡
(
	`BigI¡
(1Ë<< 
sour˚Bôs
))

126 
	`as£π
 (
a_size
 < 
	`UI¡
(
	`BigI¡
(1Ë<< 
sizeBôs
))

129 
vÆ
 
ba£End
 = 0

130 
	`vÆ
 (
sour˚End
, 
sour˚Off
Ë(
sour˚Bôs
 + 
ba£End
, baseEnd)

131 
	`vÆ
 (
sizeEnd
, 
sizeOff
Ë(
sizeBôs
 + 
sour˚End
, sourceEnd)

132 
	`ªquúe
 (
sizeEnd
 =
°©eBôs
)

134 
vÆ
 
a_°©e
 = (
a_sour˚
 << 
sour˚Off
Ë| (
a_size
 << 
sizeOff
)

136 
vÆ
 
r_°©e
 = 
out
.
r
.
bôs
.
u£r
.
	`gëOrEl£
(
	`UI¡
(0))

137 
vÆ
 
r_sour˚
 = i‡(
sour˚Bôs
 > 0Ë
	`r_°©e
(
sour˚End
-1, 
sour˚Off
Ë
	`UI¡
(0)

138 
vÆ
 
r_size
 = i‡(
sizeBôs
 > 0Ë
	`r_°©e
(
sizeEnd
 -1, 
sizeOff
Ë
	`UI¡
(0)

140 
vÆ
 
b_°©e
 = 
out
.
b
.
bôs
.
u£r
.
	`gëOrEl£
(
	`UI¡
(0))

141 
vÆ
 
b_sour˚
 = i‡(
sour˚Bôs
 > 0Ë
	`b_°©e
(
sour˚End
-1, 
sour˚Off
Ë
	`UI¡
(0)

142 
vÆ
 
b_size
 = i‡(
sizeBôs
 > 0Ë
	`b_°©e
(
sizeEnd
 -1, 
sizeOff
Ë
	`UI¡
(0)

145 
vÆ
 
dïth
 = i‡(
combö©i⁄Æ
) 1 2

146 
vÆ
 
out_¨w
 = 
	`Wúe
(
	`Decou∂ed
(
√w
 
	`AXI4BundÀARW
(
out
.
∑øms
)))

147 
vÆ
 
out_w
 = 
	`Wúe
(
out
.
w
)

148 
out
.
w
 <> 
Queue
.
	`úªvoˇbÀ
(
out_w
, 
íåõs
=
dïth
, 
Êow
=
combö©i⁄Æ
)

149 
vÆ
 
queue_¨w
 = 
Queue
.
	`úªvoˇbÀ
(
out_¨w
, 
íåõs
=
dïth
, 
Êow
=
combö©i⁄Æ
)

152 
out
.
¨
.
bôs
 :
queue_¨w
.bits

153 
out
.
aw
.
bôs
 :
queue_¨w
.bits

154 
out
.
¨
.
vÆid
 :
queue_¨w
.vÆid && !queue_¨w.
bôs
.
wí


155 
out
.
aw
.
vÆid
 :
queue_¨w
.vÆid && queue_¨w.
bôs
.
wí


156 
queue_¨w
.
ªady
 :
	`Mux
(queue_¨w.
bôs
.
wí
, 
out
.
aw
.ªady, out.
¨
.ready)

158 
vÆ
 
bótByãs
 = 
edgeIn
.
m™agî
.beatBytes

159 
vÆ
 
maxSize
 = 
	`UI¡
(
	`log2Ceû
(
bótByãs
))

160 
vÆ
 
d⁄eAW
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

161 
	`whí
 (
ö
.
a
.
	`fúe
()Ë{ 
d⁄eAW
 :!
a_œ°
 }

163 
vÆ
 
¨w
 = 
out_¨w
.
bôs


164 
¨w
.
wí
 :
a_isPut


165 
¨w
.
id
 :
	`sour˚TabÀ
(
a_sour˚
)

166 
¨w
.
addr
 :
a_addªss


167 
¨w
.
Àn
 :
	`UI¡ToOH1
(
a_size
, 
AXI4P¨amëîs
.
ÀnBôs
 + 
	`log2Ceû
(
bótByãs
)) >>Üog2Ceil(beatBytes)

168 
¨w
.
size
 :
	`Mux
(
a_size
 >
maxSize
, maxSize,á_size)

169 
¨w
.
bur°
 :
AXI4P¨amëîs
.
BURST_INCR


170 
¨w
.
lock
 :
	`UI¡
(0)

171 
¨w
.
ˇche
 :
	`UI¡
(0)

172 
¨w
.
¥Ÿ
 :
AXI4P¨amëîs
.
PROT_PRIVILEDGED


173 
¨w
.
qos
 :
	`UI¡
(0)

174 
¨w
.
u£r
.
f‹óch
 { 
_
 :
a_°©e
 }

176 
vÆ
 
°Æl
 = 
	`sour˚SèŒ
(
ö
.
a
.
bôs
.
sour˚
Ë&& 
a_fú°


177 
ö
.
a
.
ªady
 :!
°Æl
 && 
	`Mux
(
a_isPut
, (
d⁄eAW
 || 
out_¨w
.ªadyË&& 
out_w
.ready, out_arw.ready)

178 
out_¨w
.
vÆid
 :!
°Æl
 && 
ö
.
a
.vÆid && 
	`Mux
(
a_isPut
, !
d⁄eAW
 && 
out_w
.
ªady
, 
	`Boﬁ
(
åue
))

180 
out_w
.
vÆid
 :!
°Æl
 && 
ö
.
a
.vÆid && 
a_isPut
 && (
d⁄eAW
 || 
out_¨w
.
ªady
)

181 
out_w
.
bôs
.
d©a
 :
ö
.
a
.bits.data

182 
out_w
.
bôs
.
°rb
 :
ö
.
a
.bôs.
mask


183 
out_w
.
bôs
.
œ°
 :
a_œ°


184 
out_w
.
bôs
.
c‹ru±
.
f‹óch
 { 
_
 :
ö
.
a
.bits.corrupt }

187 
vÆ
 
r_hﬁds_d
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

188 
	`whí
 (
out
.
r
.
	`fúe
()Ë{ 
r_hﬁds_d
 :!out.r.
bôs
.
œ°
 }

190 
vÆ
 
r_wös
 = 
out
.
r
.
vÆid
 || 
r_hﬁds_d


192 
out
.
r
.
ªady
 :
ö
.
d
.ready

193 
out
.
b
.
ªady
 :
ö
.
d
.ªady && !
r_wös


194 
ö
.
d
.
vÆid
 :
	`Mux
(
r_wös
, 
out
.
r
.vÆid, out.
b
.valid)

199 
vÆ
 
r_fú°
 = 
	`RegInô
(
	`Boﬁ
(
åue
))

200 
	`whí
 (
out
.
r
.
	`fúe
()Ë{ 
r_fú°
 :out.r.
bôs
.
œ°
 }

201 
vÆ
 
r_díõd
 = 
out
.
r
.
bôs
.
ª•
 ==
AXI4P¨amëîs
.
RESP_DECERR
 
hﬁdU∆ess
 
r_fú°


202 
vÆ
 
r_c‹ru±
 = 
out
.
r
.
bôs
.
ª•
 =/
AXI4P¨amëîs
.
RESP_OKAY


203 
vÆ
 
b_díõd
 = 
out
.
b
.
bôs
.
ª•
 =/
AXI4P¨amëîs
.
RESP_OKAY


205 
vÆ
 
r_d
 = 
edgeIn
.
	`Ac˚ssAck
(
r_sour˚
, 
r_size
, 
	`UI¡
(0), 
díõd
 = 
r_díõd
, 
c‹ru±
 = 
r_c‹ru±
 ||Ñ_denied)

206 
vÆ
 
b_d
 = 
edgeIn
.
	`Ac˚ssAck
(
b_sour˚
, 
b_size
, 
díõd
 = 
b_díõd
)

208 
ö
.
d
.
bôs
 :
	`Mux
(
r_wös
, 
r_d
, 
b_d
)

209 
ö
.
d
.
bôs
.
d©a
 :
out
.
r
.bits.data

213 
vÆ
 
a_£l
 = 
	`UI¡ToOH
(
¨w
.
id
, 
edgeOut
.
ma°î
.
ídId
).
toBoﬁs


214 
vÆ
 
d_£l
 = 
	`UI¡ToOH
(
	`Mux
(
r_wös
, 
out
.
r
.
bôs
.
id
, out.
b
.bôs.id), 
edgeOut
.
ma°î
.
ídId
).
toBoﬁs


215 
vÆ
 
d_œ°
 = 
	`Mux
(
r_wös
, 
out
.
r
.
bôs
.
œ°
, 
	`Boﬁ
(
åue
))

217 (
a_£l
 
zù
 
d_£l
 zù 
idSèŒ
 zù 
idCou¡
Ë
f‹óch
 { (((
as
, 
ds
), 
s
), 
n
) =>

224 
vÆ
 
maxCou¡
 = 
n
.
	`gëOrEl£
(1)

225 
vÆ
 
cou¡
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
	`log2Ceû
(
maxCou¡
 + 1)))

226 
vÆ
 
wrôe
 = 
	`Reg
(
	`Boﬁ
())

227 
vÆ
 
idÀ
 = 
cou¡
 ==
	`UI¡
(0)

229 
vÆ
 
öc
 = 
as
 && 
out_¨w
.
	`fúe
()

230 
vÆ
 
dec
 = 
ds
 && 
d_œ°
 && 
ö
.
d
.
	`fúe
()

231 
cou¡
 :cou¡ + 
öc
.
asUI¡
 - 
dec
.asUInt

233 
	`as£π
 (!
dec
 || 
cou¡
 =/
	`UI¡
(0))

234 
	`as£π
 (!
öc
 || 
cou¡
 =/
	`UI¡
(
maxCou¡
))

236 
	`whí
 (
öc
Ë{ 
wrôe
 :
¨w
.
wí
 }

238 
vÆ
 
mism©ch
 = i‡(
maxCou¡
 > 1Ë{ 
wrôe
 =/
¨w
.
wí
 } { 
	`Boﬁ
(
Ál£
) }

239 
s
 :(!
idÀ
 && 
mism©ch
Ë|| (
cou¡
 ==
	`UI¡
(
maxCou¡
))

243 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

244 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

245 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

248 
	}
}

250 
obje˘
 
TLToAXI4


252 
def
 
≠∂y
(
combö©i⁄Æ
: 
Boﬁón
 = 
åue
, 
ad≠ãrName
: 
O±i⁄
[
Såög
] = 
N⁄e
, 
°rùBôs
: 
I¡
 = 0)(
im∂icô
 
p
: 
P¨amëîs
) =

254 
vÆ
 
é2axi4
 = 
LazyModuÀ
(
√w
 
TLToAXI4
(
combö©i⁄Æ
, 
ad≠ãrName
, 
°rùBôs
))

255 
	gé2axi4
.
	gnode


258 
def
 
s‹tByTy≥
(
a
: 
TLClõ¡P¨amëîs
, 
b
: TLClõ¡P¨amëîs): 
Boﬁón
 = {

259 i‡–
a
.
suµ‹tsProbe
 && !
b
.suµ‹tsProbeË 
Ál£


260 i‡(!
a
.
suµ‹tsProbe
 && 
b
.suµ‹tsProbeË 
åue


261 i‡–
a
.
ªque°Fifo
 && !
b
.ªque°FifÿË 
Ál£


262 i‡(!
a
.
ªque°Fifo
 && 
b
.ªque°FifÿË 
åue


263  
Ál£


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/WidthWidget.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


9 
imp‹t
 
	gsˇœ
.
	gm©h
.{
	gmö
,
	gmax
}

12 ˛as†
	cTLWidthWidgë
(
ö√rBótByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


14 
vÆ
 
node
 = 
	`TLAd≠ãrNode
(

15 
˛õ¡Fn
 = { 
c
 => c },

16 
m™agîFn
 = { 
m
 => m.
	`c›y
(
bótByãs
 = 
ö√rBótByãs
Ë
	}
})

18 
œzy
 
vÆ
 
	gmoduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

19 
def
 
mîge
[
T
 <: 
TLD©aCh™√l
](
edgeIn
: 
TLEdge
, 
ö
: 
Decou∂edIO
[T], 
edgeOut
: TLEdge, 
out
: DecoupledIO[T]) = {

20 
vÆ
 
öByãs
 = 
edgeIn
.
m™agî
.
bótByãs


21 
vÆ
 
outByãs
 = 
edgeOut
.
m™agî
.
bótByãs


22 
vÆ
 
øtio
 = 
outByãs
 / 
öByãs


23 
vÆ
 
kìpBôs
 = 
	`log2Ceû
(
outByãs
)

24 
vÆ
 
dr›Bôs
 = 
	`log2Ceû
(
öByãs
)

25 
vÆ
 
cou¡Bôs
 = 
	`log2Ceû
(
øtio
)

27 
vÆ
 
size
 = 
edgeIn
.
	`size
(
ö
.
bôs
)

28 
vÆ
 
hasD©a
 = 
edgeIn
.
	`hasD©a
(
ö
.
bôs
)

29 
vÆ
 
limô
 = 
	`UI¡ToOH1
(
size
, 
kìpBôs
Ë>> 
dr›Bôs


31 
vÆ
 
cou¡
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
cou¡Bôs
))

32 
vÆ
 
fú°
 = 
cou¡
 ==
	`UI¡
(0)

33 
vÆ
 
œ°
 = 
cou¡
 ==
limô
 || !
hasD©a


34 
vÆ
 
íabÀ
 = 
Seq
.
	`èbuœã
(
øtio
Ë{ 
i
 => !((
cou¡
 ^ 
	`UI¡
(i)Ë& 
limô
).
‹R
 }

36 
vÆ
 
c‹ru±_ªg
 = 
	`RegInô
(
	`Boﬁ
(
Ál£
))

37 
vÆ
 
c‹ru±_ö
 = 
edgeIn
.
	`c‹ru±
(
ö
.
bôs
)

38 
vÆ
 
c‹ru±_out
 = 
c‹ru±_ö
 || 
c‹ru±_ªg


40 
	`whí
 (
ö
.
	`fúe
()) {

41 
cou¡
 :cou¡ + 
	`UI¡
(1)

42 
c‹ru±_ªg
 :
c‹ru±_out


43 
	`whí
 (
œ°
) {

44 
cou¡
 :
	`UI¡
(0)

45 
c‹ru±_ªg
 :
	`Boﬁ
(
Ál£
)

49 
def
 
	`hñ≥r
(
id©a
: 
UI¡
): UInt = {

50 
vÆ
 
od©a
 = 
Seq
.
	`fûl
(
øtio
Ë{ 
id©a
 }

51 
vÆ
 
rd©a
 = 
	`Reg
(
	`Vec
(
øtio
-1, 
id©a
))

52 
vÆ
 
pd©a
 = 
rd©a
 :+ 
id©a


53 
vÆ
 
md©a
 = (
íabÀ
 
	`zù
 (
od©a
 
zù
 
pd©a
)Ë
m≠
 { (
e
, (
o
, 
p
)Ë=> 
	`Mux
(e, o,Ö) }

54 
	`whí
 (
ö
.
	`fúe
(Ë&& !
œ°
) {

55 (
rd©a
 
zù
 
md©a
Ë
f‹óch
 { (
r
, 
m
) =>Ñ := m }

57 
	`C©
(
md©a
.
ªvî£
)

60 
ö
.
ªady
 :
out
.ªady || !
œ°


61 
out
.
vÆid
 :
ö
.vÆid && 
œ°


62 
out
.
bôs
 :
ö
.bits

65 
edgeOut
.
	`d©a
(
out
.
bôs
Ë:(i‡(
edgeIn
.
	`°©icHasD©a
(
ö
.bôsË=
	`Some
(
Ál£
)Ë
	`UI¡
(0Ë
	`hñ≥r
(edgeIn.data(in.bits)))

66 
edgeOut
.
	`c‹ru±
(
out
.
bôs
Ë:
c‹ru±_out


68 (
out
.
bôs
, 
ö
.bôsË
m©ch
 {

69 (
o
: 
TLBundÀA
, 
i
: TLBundÀAË=> o.
mask
 :
edgeOut
.
	`mask
(o.
addªss
, o.
size
Ë& 
	`Mux
(
hasD©a
, 
	`hñ≥r
(i.mask), ~
	`UI¡
(0, 
width
=
outByãs
))

70 (
o
: 
TLBundÀB
, 
i
: TLBundÀBË=> o.
mask
 :
edgeOut
.
	`mask
(o.
addªss
, o.
size
Ë& 
	`Mux
(
hasD©a
, 
	`hñ≥r
(i.mask), ~
	`UI¡
(0, 
width
=
outByãs
))

71 (
o
: 
TLBundÀC
, 
i
: TLBundleC) => ()

72 (
o
: 
TLBundÀD
, 
i
: TLBundleD) => ()

73 
_
 => 
	`ªquúe
(
Ál£
, "Impossible bundle combination in WidthWidget")

77 
def
 
•lô
[
T
 <: 
TLD©aCh™√l
](
edgeIn
: 
TLEdge
, 
ö
: 
Decou∂edIO
[T], 
edgeOut
: TLEdge, 
out
: Decou∂edIO[T], 
sour˚M≠
: 
UI¡
 => UInt) = {

78 
vÆ
 
öByãs
 = 
edgeIn
.
m™agî
.
bótByãs


79 
vÆ
 
outByãs
 = 
edgeOut
.
m™agî
.
bótByãs


80 
vÆ
 
øtio
 = 
öByãs
 / 
outByãs


81 
vÆ
 
kìpBôs
 = 
	`log2Ceû
(
öByãs
)

82 
vÆ
 
dr›Bôs
 = 
	`log2Ceû
(
outByãs
)

83 
vÆ
 
cou¡Bôs
 = 
	`log2Ceû
(
øtio
)

85 
vÆ
 
size
 = 
edgeIn
.
	`size
(
ö
.
bôs
)

86 
vÆ
 
hasD©a
 = 
edgeIn
.
	`hasD©a
(
ö
.
bôs
)

87 
vÆ
 
limô
 = 
	`UI¡ToOH1
(
size
, 
kìpBôs
Ë>> 
dr›Bôs


89 
vÆ
 
cou¡
 = 
	`RegInô
(
	`UI¡
(0, 
width
 = 
cou¡Bôs
))

90 
vÆ
 
fú°
 = 
cou¡
 ==
	`UI¡
(0)

91 
vÆ
 
œ°
 = 
cou¡
 ==
limô
 || !
hasD©a


93 
	`whí
 (
out
.
	`fúe
()) {

94 
cou¡
 :cou¡ + 
	`UI¡
(1)

95 
	`whí
 (
œ°
Ë{ 
cou¡
 :
	`UI¡
(0) }

99 
vÆ
 
£l
 = 
ö
.
bôs
 
m©ch
 {

100 
a
: 
TLBundÀA
 =>á.
	`addªss
(
kìpBôs
-1, 
dr›Bôs
)

101 
b
: 
TLBundÀB
 => b.
	`addªss
(
kìpBôs
-1, 
dr›Bôs
)

102 
c
: 
TLBundÀC
 => c.
	`addªss
(
kìpBôs
-1, 
dr›Bôs
)

103 
d
: 
TLBundÀD
 => {

104 
vÆ
 
£l
 = 
	`sour˚M≠
(
d
.
sour˚
)

105 
vÆ
 
hﬁd
 = 
	`Mux
(
fú°
, 
£l
, 
	`RegE«bÀ
(sel, first))

106 
hﬁd
 & ~
limô


110 
vÆ
 
ödex
 = 
£l
 | 
cou¡


111 
def
 
	`hñ≥r
(
id©a
: 
UI¡
, 
width
: 
I¡
): UInt = {

112 
vÆ
 
mux
 = 
Vec
.
	`èbuœã
(
øtio
Ë{ 
i
 => 
	`id©a
((i+1)*
outByãs
*
width
-1, i*outBytes*width) }

113 
	`mux
(
ödex
)

116 
out
 <> 
ö


119 
edgeOut
.
	`d©a
(
out
.
bôs
Ë:(i‡(
edgeIn
.
	`°©icHasD©a
(
ö
.bôsË=
	`Some
(
Ál£
)Ë
	`UI¡
(0Ë
	`hñ≥r
(edgeIn.data(in.bits), 8))

121 (
out
.
bôs
, 
ö
.bôsË
m©ch
 {

122 (
o
: 
TLBundÀA
, 
i
: TLBundÀAË=> o.
mask
 :
	`hñ≥r
(i.mask, 1)

123 (
o
: 
TLBundÀB
, 
i
: TLBundÀBË=> o.
mask
 :
	`hñ≥r
(i.mask, 1)

124 (
o
: 
TLBundÀC
, 
i
: TLBundleC) => ()

125 (
o
: 
TLBundÀD
, 
i
: TLBundleD) => ()

126 
_
 => 
	`ªquúe
(
Ál£
, "Impossbile bundle combination in WidthWidget")

130 !
œ°


133 
def
 
•li˚
[
T
 <: 
TLD©aCh™√l
](
edgeIn
: 
TLEdge
, 
ö
: 
Decou∂edIO
[T], 
edgeOut
: TLEdge, 
out
: Decou∂edIO[T], 
sour˚M≠
: 
UI¡
 => UInt) = {

134 i‡(
edgeIn
.
m™agî
.
bótByãs
 =
edgeOut
.manager.beatBytes) {

136 
out
 <> 
ö


137 } i‡(
edgeIn
.
m™agî
.
bótByãs
 > 
edgeOut
.manager.beatBytes) {

139 
vÆ
 
ª≥©
 = 
	`Wúe
(
	`Boﬁ
())

140 
vÆ
 
ª≥©ed
 = 
	`Rïóãr
(
ö
, 
ª≥©
)

141 
vÆ
 
ˇãd
 = 
	`Wúe
(
ª≥©ed
)

142 
ˇãd
 <> 
ª≥©ed


143 
edgeIn
.
	`d©a
(
ˇãd
.
bôs
Ë:
	`C©
(

144 
edgeIn
.
	`d©a
(
ª≥©ed
.
bôs
)”dgeIn.
m™agî
.
bótByãs
*8-1, 
edgeOut
.manager.beatBytes*8),

145 
edgeIn
.
	`d©a
(
ö
.
bôs
)(
edgeOut
.
m™agî
.
bótByãs
*8-1, 0))

146 
ª≥©
 :
	`•lô
(
edgeIn
, 
ˇãd
, 
edgeOut
, 
out
, 
sour˚M≠
)

149 
	`mîge
(
edgeIn
, 
ö
, 
edgeOut
, 
out
)

153 (
node
.
ö
 
zù
Çode.
out
Ë
f‹óch
 { ((ö, 
edgeIn
), (out, 
edgeOut
)) =>

162 
def
 
	`sour˚M≠
(
sour˚
: 
UI¡
) = {

163 
	`ªquúe
 (
edgeOut
.
m™agî
.
bótByãs
 > 
edgeIn
.manager.beatBytes)

164 
vÆ
 
kìpBôs
 = 
	`log2Ceû
(
edgeOut
.
m™agî
.
bótByãs
)

165 
vÆ
 
dr›Bôs
 = 
	`log2Ceû
(
edgeIn
.
m™agî
.
bótByãs
)

166 
vÆ
 
sour˚s
 = 
	`Reg
(
	`Vec
(
edgeIn
.
˛õ¡
.
ídSour˚Id
, 
	`UI¡
(
width
 = 
kìpBôs
-
dr›Bôs
)))

167 
vÆ
 
a_£l
 = 
ö
.
a
.
bôs
.
	`addªss
(
kìpBôs
-1, 
dr›Bôs
)

168 
	`whí
 (
ö
.
a
.
	`fúe
()) {

169 
	`sour˚s
(
ö
.
a
.
bôs
.
sour˚
Ë:
a_£l


173 
edgeIn
.
˛õ¡
.
unu£dSour˚s
.
f‹óch
 { 
id
 => 
	`sour˚s
(idË:
	`UI¡
(0) }

175 
vÆ
 
by∑ss
 = 
	`Boﬁ
(
edgeIn
.
m™agî
.
möL©ícy
 =0Ë&& 
ö
.
a
.
vÆid
 && in.a.
bôs
.
sour˚
 === source

176 
	`Mux
(
by∑ss
, 
a_£l
, 
	`sour˚s
(
sour˚
))

179 
	`•li˚
(
edgeIn
, 
ö
.
a
, 
edgeOut
, 
out
.a, 
sour˚M≠
)

180 
	`•li˚
(
edgeOut
, 
out
.
d
, 
edgeIn
, 
ö
.d, 
sour˚M≠
)

182 i‡(
edgeOut
.
m™agî
.
™ySuµ‹tAcquúeB
 && 
edgeIn
.
˛õ¡
.
™ySuµ‹tProbe
) {

183 
	`•li˚
(
edgeOut
, 
out
.
b
, 
edgeIn
, 
ö
.b, 
sour˚M≠
)

184 
	`•li˚
(
edgeIn
, 
ö
.
c
, 
edgeOut
, 
out
.c, 
sour˚M≠
)

185 
out
.
e
 <> 
ö
.e

187 
ö
.
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

188 
ö
.
c
.
ªady
 :
	`Boﬁ
(
åue
)

189 
ö
.
e
.
ªady
 :
	`Boﬁ
(
åue
)

190 
out
.
b
.
ªady
 :
	`Boﬁ
(
åue
)

191 
out
.
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

192 
out
.
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

195 
	}
}

198 
obje˘
 
TLWidthWidgë


200 
def
 
≠∂y
(
ö√rBótByãs
: 
I¡
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

202 
vÆ
 
widgë
 = 
LazyModuÀ
(
√w
 
TLWidthWidgë
(
ö√rBótByãs
))

203 
widgë
.
node


208 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


210 
˛ass
 
	$TLRAMWidthWidgë
(
fú°
: 
I¡
, 
£c⁄d
: I¡, 
txns
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

211 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

212 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("WidthWidget"))

213 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0x0, 0x3ff)))

215 (
øm
.
node


216 :
	`TLDñayî
(0.1)

217 :
	`TLFøgmíãr
(4, 256)

218 :
	`TLWidthWidgë
(
£c⁄d
)

219 :
	`TLWidthWidgë
(
fú°
)

220 :
	`TLDñayî
(0.1)

221 :
modñ
.
node


222 :
fuzz
.
node
)

224 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

225 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

227 
	}
}

229 
˛ass
 
	$TLRAMWidthWidgëTe°
(
lôée
: 
I¡
, 
big
: I¡, 
txns
: I¡ = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

230 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMWidthWidgë
(
lôée
,
big
,
txns
)).
moduÀ
)

231 
io
.
föished
 :
dut
.io.finished

232 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Xbar.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


10 
obje˘
 
	gF‹˚F™out


12 
def
 
	g≠∂y
[
T
](

13 
	ga
: 
TriSèãVÆue
 = TriSèãVÆue.
un£t
,

14 
	gb
: 
TriSèãVÆue
 = TriSèãVÆue.
un£t
,

15 
	gc
: 
TriSèãVÆue
 = TriSèãVÆue.
un£t
,

16 
	gd
: 
TriSèãVÆue
 = TriSèãVÆue.
un£t
,

17 
	ge
: 
TriSèãVÆue
 = TriSèãVÆue.
un£t
)(
body
: 
P¨amëîs
 => 
T
)(
im∂icô
 
p
: Parameters) =

19 
body
(
p
.
ÆãrP¨tül
 {

20 
F‹˚F™outKey
 => 
p
(F‹˚F™outKeyË
m©ch
 {

21 
F‹˚F™outP¨ams
(
∑
, 
pb
, 
pc
, 
pd
, 
≥
) =>

22 
F‹˚F™outP¨ams
(
a
.
upd©e
(
∑
), 
b
.upd©e(
pb
), 
c
.upd©e(
pc
), 
d
.upd©e(
pd
), 
e
.upd©e(
≥
))

28 
¥iv©e
 
˛ass
 
	$F‹˚F™outP¨ams
(
a
: 
Boﬁón
, 
b
: Boﬁón, 
c
: Boﬁón, 
d
: Boﬁón, 
e
: Boolean)

29 
¥iv©e
 
obje˘
 
F‹˚F™outKey
 
exãnds
 
	`Fõld
(
	$F‹˚F™outP¨ams
(
Ál£
, false, false, false, false))

31 
˛ass
 
	$TLXb¨
(
pﬁicy
: 
TLArbôî
.
Pﬁicy
 = TLArbôî.
roundRobö
)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


33 
vÆ
 
node
 = 
	`TLNexusNode
(

34 
˛õ¡Fn
 = { 
£q
 =>

35 
	`£q
(0).
	`c›y
(

36 
möL©ícy
 = 
£q
.
	`m≠
(
_
.möL©ícy).
mö
,

37 
˛õ¡s
 = (
TLXb¨
.
	`m≠I≈utIds
(
£q
Ë
zù
 seqË
Ê©M≠
 { (
ønge
, 
p‹t
) =>

38 
p‹t
.
˛õ¡s
 
m≠
 { 
˛õ¡
 => clõ¡.
	`c›y
(

39 
sour˚Id
 = 
˛õ¡
.sour˚Id.
	`shi·
(
ønge
.
°¨t
)

44 
m™agîFn
 = { 
£q
 =>

45 
vÆ
 
fifoIdFa˘‹y
 = 
TLXb¨
.
	`ªœbñî
()

46 
	`£q
(0).
	`c›y
(

47 
möL©ícy
 = 
£q
.
	`m≠
(
_
.möL©ícy).
mö
,

48 
ídSökId
 = 
TLXb¨
.
	`m≠OuçutIds
(
£q
).
	`m≠
(
_
.
íd
).
max
,

49 
m™agîs
 = 
£q
.
Ê©M≠
 { 
p‹t
 =>

50 
	`ªquúe
 (
p‹t
.
bótByãs
 =
	`£q
(0).beatBytes,

51 
s
"Xbar data widths don't match: ${port.managers.map(_.name)} has ${port.beatBytes}B vs ${seq(0).managers.map(_.name)} has ${seq(0).beatBytes}B")

52 
vÆ
 
fifoIdM≠≥r
 = 
	`fifoIdFa˘‹y
()

53 
p‹t
.
m™agîs
 
m≠
 { 
m™agî
 => m™agî.
	`c›y
(

54 
fifoId
 = 
m™agî
.fifoId.
	`m≠
(
	`fifoIdM≠≥r
(
_
))

60 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
) {

61 i‡((
node
.
ö
.
size
 *Çode.
out
.size) > (8*32)) {

62 
	`¥öén
 (
s
"!!! WARNING !!!")

63 
	`¥öén
 (
s
" Your TLXbar ($name) is veryÜarge, with ${node.in.size} Mastersánd ${node.out.size} Slaves.")

64 
	`¥öén
 (
s
"!!! WARNING !!!")

67 
	`vÆ
 (
io_ö
, 
edgesIn
Ë
node
.
ö
.
unzù


68 
	`vÆ
 (
io_out
, 
edgesOut
Ë
node
.
out
.
unzù


71 
vÆ
 
ªachabÀIO
 = 
edgesIn
.
m≠
 { 
˝
 => 
edgesOut
.m≠ { 
mp
 =>

72 
˝
.
˛õ¡
.
˛õ¡s
.
exi°s
 { 
c
 => 
mp
.
m™agî
.
m™agîs
.exi°†{ 
m
 =>

73 
c
.
visibûôy
.
exi°s
 { 
ˇ
 => 
m
.
addªss
.exi°†{ 
ma
 =>

74 
ˇ
.
	`ovîœps
(
ma
)}}}}

75 }.
toVe˘‹
}.toVector

76 
vÆ
 
¥obeIO
 = (
edgesIn
 
zù
 
ªachabÀIO
).
m≠
 { (
˝
, 
ªachabÀO
) =>

77 (
edgesOut
 
zù
 
ªachabÀO
).
m≠
 { (
mp
, 
ªachabÀ
) =>

78 
ªachabÀ
 && 
˝
.
˛õ¡
.
™ySuµ‹tProbe
 && 
mp
.
m™agî
.
m™agîs
.
	`exi°s
(
_
.
ªgi⁄Ty≥
 >
Regi⁄Ty≥
.
TRACKED
)

79 }.
toVe˘‹
}.toVector

80 
vÆ
 
ªÀa£IO
 = (
edgesIn
 
zù
 
ªachabÀIO
).
m≠
 { (
˝
, 
ªachabÀO
) =>

81 (
edgesOut
 
zù
 
ªachabÀO
).
m≠
 { (
mp
, 
ªachabÀ
) =>

82 
ªachabÀ
 && 
˝
.
˛õ¡
.
™ySuµ‹tProbe
 && 
mp
.
m™agî
.
™ySuµ‹tAcquúeB


83 }.
toVe˘‹
}.toVector

85 
vÆ
 
c⁄√˘AIO
 = 
ªachabÀIO


86 
vÆ
 
c⁄√˘BIO
 = 
¥obeIO


87 
vÆ
 
c⁄√˘CIO
 = 
ªÀa£IO


88 
vÆ
 
c⁄√˘DIO
 = 
ªachabÀIO


89 
vÆ
 
c⁄√˘EIO
 = 
ªÀa£IO


91 
def
 
å™•o£
[
T
](
x
: 
Seq
[Seq[T]]Ëi‡(x.
isEm±y
Ë
Nû
 
Ve˘‹
.
	`èbuœã
(
	`x
(0).
size
Ë{ 
i
 => Ve˘‹.èbuœã(x.sizeË{ 
j
 => x(j)(i) } }

92 
vÆ
 
c⁄√˘AOI
 = 
	`å™•o£
(
c⁄√˘AIO
)

93 
vÆ
 
c⁄√˘BOI
 = 
	`å™•o£
(
c⁄√˘BIO
)

94 
vÆ
 
c⁄√˘COI
 = 
	`å™•o£
(
c⁄√˘CIO
)

95 
vÆ
 
c⁄√˘DOI
 = 
	`å™•o£
(
c⁄√˘DIO
)

96 
vÆ
 
c⁄√˘EOI
 = 
	`å™•o£
(
c⁄√˘EIO
)

99 
vÆ
 
öputIdR™ges
 = 
TLXb¨
.
	`m≠I≈utIds
(
edgesIn
.
	`m≠
(
_
.
˛õ¡
))

100 
vÆ
 
ouçutIdR™ges
 = 
TLXb¨
.
	`m≠OuçutIds
(
edgesOut
.
	`m≠
(
_
.
m™agî
))

103 
vÆ
 
wide_bundÀ
 = 
TLBundÀP¨amëîs
.(
io_ö
.
	`m≠
(
_
.
∑øms
Ë++ 
io_out
.map(_.params))

106 
def
 
	`åim
(
id
: 
UI¡
, 
size
: 
I¡
Ëi‡(sizê<1Ë
	`UI¡
(0Ë
	`id
(
	`log2Ceû
(size)-1, 0)

109 
vÆ
 
ö
 = 
	`Wúe
(
	`Vec
(
io_ö
.
size
, 
	`TLBundÀ
(
wide_bundÀ
)))

110 
i
 <- 0 
u¡û
 
ö
.
size
) {

111 
vÆ
 
r
 = 
	`öputIdR™ges
(
i
)

113 i‡(
	`c⁄√˘AIO
(
i
).
	`exi°s
(
x
=>x)) {

114 
	`ö
(
i
).
a
 <> 
	`io_ö
(i).a

115 
	`ö
(
i
).
a
.
bôs
.
sour˚
 :
	`io_ö
(i).a.bôs.sour˚ | 
	`UI¡
(
r
.
°¨t
)

117 
	`ö
(
i
).
a
.
vÆid
 :
	`Boﬁ
(
Ál£
)

118 
	`io_ö
(
i
).
a
.
ªady
 :
	`Boﬁ
(
åue
)

121 i‡(
	`c⁄√˘BIO
(
i
).
	`exi°s
(
x
=>x)) {

122 
	`io_ö
(
i
).
b
 <> 
	`ö
(i).b

123 
	`io_ö
(
i
).
b
.
bôs
.
sour˚
 :
	`åim
(
	`ö
(i).b.bôs.sour˚, 
r
.
size
)

125 
	`ö
(
i
).
b
.
ªady
 :
	`Boﬁ
(
åue
)

126 
	`io_ö
(
i
).
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

129 i‡(
	`c⁄√˘CIO
(
i
).
	`exi°s
(
x
=>x)) {

130 
	`ö
(
i
).
c
 <> 
	`io_ö
(i).c

131 
	`ö
(
i
).
c
.
bôs
.
sour˚
 :
	`io_ö
(i).c.bôs.sour˚ | 
	`UI¡
(
r
.
°¨t
)

133 
	`ö
(
i
).
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

134 
	`io_ö
(
i
).
c
.
ªady
 :
	`Boﬁ
(
åue
)

137 i‡(
	`c⁄√˘DIO
(
i
).
	`exi°s
(
x
=>x)) {

138 
	`io_ö
(
i
).
d
 <> 
	`ö
(i).d

139 
	`io_ö
(
i
).
d
.
bôs
.
sour˚
 :
	`åim
(
	`ö
(i).d.bôs.sour˚, 
r
.
size
)

141 
	`ö
(
i
).
d
.
ªady
 :
	`Boﬁ
(
åue
)

142 
	`io_ö
(
i
).
d
.
vÆid
 :
	`Boﬁ
(
Ál£
)

145 i‡(
	`c⁄√˘EIO
(
i
).
	`exi°s
(
x
=>x)) {

146 
	`ö
(
i
).
e
 <> 
	`io_ö
(i).e

148 
	`ö
(
i
).
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

149 
	`io_ö
(
i
).
e
.
ªady
 :
	`Boﬁ
(
åue
)

154 
vÆ
 
out
 = 
	`Wúe
(
	`Vec
(
io_out
.
size
, 
	`TLBundÀ
(
wide_bundÀ
)))

155 
o
 <- 0 
u¡û
 
out
.
size
) {

156 
vÆ
 
r
 = 
	`ouçutIdR™ges
(
o
)

158 i‡(
	`c⁄√˘AOI
(
o
).
	`exi°s
(
x
=>x)) {

159 
	`io_out
(
o
).
a
 <> 
	`out
(o).a

161 
	`out
(
o
).
a
.
ªady
 :
	`Boﬁ
(
åue
)

162 
	`io_out
(
o
).
a
.
vÆid
 :
	`Boﬁ
(
Ál£
)

165 i‡(
	`c⁄√˘BOI
(
o
).
	`exi°s
(
x
=>x)) {

166 
	`out
(
o
).
b
 <> 
	`io_out
(o).b

168 
	`out
(
o
).
b
.
vÆid
 :
	`Boﬁ
(
Ál£
)

169 
	`io_out
(
o
).
b
.
ªady
 :
	`Boﬁ
(
åue
)

172 i‡(
	`c⁄√˘COI
(
o
).
	`exi°s
(
x
=>x)) {

173 
	`io_out
(
o
).
c
 <> 
	`out
(o).c

175 
	`out
(
o
).
c
.
ªady
 :
	`Boﬁ
(
åue
)

176 
	`io_out
(
o
).
c
.
vÆid
 :
	`Boﬁ
(
Ál£
)

179 i‡(
	`c⁄√˘DOI
(
o
).
	`exi°s
(
x
=>x)) {

180 
	`out
(
o
).
d
 <> 
	`io_out
(o).d

181 
	`out
(
o
).
d
.
bôs
.
sök
 :
	`io_out
(o).d.bôs.sök | 
	`UI¡
(
r
.
°¨t
)

183 
	`out
(
o
).
d
.
vÆid
 :
	`Boﬁ
(
Ál£
)

184 
	`io_out
(
o
).
d
.
ªady
 :
	`Boﬁ
(
åue
)

187 i‡(
	`c⁄√˘EOI
(
o
).
	`exi°s
(
x
=>x)) {

188 
	`io_out
(
o
).
e
 <> 
	`out
(o).e

189 
	`io_out
(
o
).
e
.
bôs
.
sök
 :
	`åim
(
	`out
(o).e.bôs.sök, 
r
.
size
)

191 
	`out
(
o
).
e
.
ªady
 :
	`Boﬁ
(
åue
)

192 
	`io_out
(
o
).
e
.
vÆid
 :
	`Boﬁ
(
Ál£
)

197 
def
 
fûãr
[
T
](
d©a
: 
Seq
[T], 
mask
: Seq[
Boﬁón
]Ë(d©®
zù
 mask).
	`fûãr
(
_
.
_2
).
	`m≠
(_.
_1
)

200 
vÆ
 
ªquúedAC
 = (
c⁄√˘AIO
 ++ 
c⁄√˘CIO
).
di°ö˘


201 
vÆ
 
ouçutP‹tFns
: 
M≠
[
Ve˘‹
[
Boﬁón
], 
Seq
[
UI¡
 => 
Boﬁ
]] = 
ªquúedAC
.
m≠
 { 
c⁄√˘O
 =>

202 
vÆ
 
p‹t_addrs
 = 
edgesOut
.
	`m≠
(
_
.
m™agî
.
m™agîs
.
	`Ê©M≠
(_.
addªss
))

203 
vÆ
 
routögMask
 = 
	`AddªssDecodî
(
	`fûãr
(
p‹t_addrs
, 
c⁄√˘O
))

204 
vÆ
 
rouã_addrs
 = 
p‹t_addrs
.
	`m≠
(
£q
 => 
AddªssSë
.
	`unify
(£q.m≠(
_
.
	`widí
(~
routögMask
)).
di°ö˘
))

207 i‡(
Ál£
) {

208 
	`¥öén
("Xbar mapping:")

209 
rouã_addrs
.
f‹óch
 { 
p
 =>

210 
	`¥öt
(" ")

211 
p
.
f‹óch
 { 
a
 => 
	`¥öt
(
s
" ${a}") }

212 
	`¥öén
("")

214 
	`¥öén
("--")

217 (
c⁄√˘O
, 
rouã_addrs
.
	`m≠
(
£q
 => (
addr
: 
UI¡
Ë=> seq.m≠(
_
.
	`c⁄èös
◊ddr)).
	`ªdu˚
(_ || _)))

218 }.
toM≠


221 i‡(
Ál£
) {

222 
	`¥öén
(
s
"XBar ${name} mapping:")

223 (
edgesIn
 
zù
 
öputIdR™ges
).
zùWôhIndex
.
f‹óch
 { ((
edge
, 
id
), 
i
) =>

224 
	`¥öén
(
s
"\t$iássigned ${id} for ${edge.client.clients.map(_.name).mkString(", ")}")

226 
	`¥öén
("")

229 
vÆ
 
addªssA
 = (
ö
 
zù
 
edgesIn
Ë
m≠
 { (
i
, 
e
Ë=>É.
	`addªss
(i.
a
.
bôs
) }

230 
vÆ
 
addªssC
 = (
ö
 
zù
 
edgesIn
Ë
m≠
 { (
i
, 
e
Ë=>É.
	`addªss
(i.
c
.
bôs
) }

232 
def
 
	`unique
(
x
: 
Ve˘‹
[
Boﬁón
]Ë
	`Boﬁ
(x.
	`fûãr
(x=>x).
size
 <= 1)

233 
vÆ
 
ªque°AIO
 = (
c⁄√˘AIO
 
zù
 
addªssA
Ë
m≠
 { (
c
, 
i
Ë=> 
	`ouçutP‹tFns
(c).m≠ { 
o
 => 
	`unique
(cË|| 
	`o
(i) } }

234 
vÆ
 
ªque°CIO
 = (
c⁄√˘CIO
 
zù
 
addªssC
Ë
m≠
 { (
c
, 
i
Ë=> 
	`ouçutP‹tFns
(c).m≠ { 
o
 => 
	`unique
(cË|| 
	`o
(i) } }

235 
vÆ
 
ªque°BOI
 = 
out
.
m≠
 { 
o
 => 
öputIdR™ges
.m≠ { 
i
 => i.
	`c⁄èös
(o.
b
.
bôs
.
sour˚
) } }

236 
vÆ
 
ªque°DOI
 = 
out
.
m≠
 { 
o
 => 
öputIdR™ges
.m≠ { 
i
 => i.
	`c⁄èös
(o.
d
.
bôs
.
sour˚
) } }

237 
vÆ
 
ªque°EIO
 = 
ö
.
m≠
 { 
i
 => 
ouçutIdR™ges
.m≠ { 
o
 => o.
	`c⁄èös
(i.
e
.
bôs
.
sök
) } }

239 
vÆ
 
bótsAI
 = (
ö
 
zù
 
edgesIn
Ë
m≠
 { (
i
, 
e
Ë=>É.
	`numBóts1
(i.
a
.
bôs
) }

240 
vÆ
 
bótsBO
 = (
out
 
zù
 
edgesOut
Ë
m≠
 { (
o
, 
e
Ë=>É.
	`numBóts1
(o.
b
.
bôs
) }

241 
vÆ
 
bótsCI
 = (
ö
 
zù
 
edgesIn
Ë
m≠
 { (
i
, 
e
Ë=>É.
	`numBóts1
(i.
c
.
bôs
) }

242 
vÆ
 
bótsDO
 = (
out
 
zù
 
edgesOut
Ë
m≠
 { (
o
, 
e
Ë=>É.
	`numBóts1
(o.
d
.
bôs
) }

243 
vÆ
 
bótsEI
 = (
ö
 
zù
 
edgesIn
Ë
m≠
 { (
i
, 
e
Ë=>É.
	`numBóts1
(i.e.
bôs
) }

246 
vÆ
 
p‹tsAOI
 = 
	`å™•o£
((
ö
 
zù
 
ªque°AIO
Ë
m≠
 { (
i
, 
r
Ë=> 
TLXb¨
.
	`Ánout
(i.
a
,Ñ, 
edgesOut
.
	`m≠
(
_
.
	`∑øms
(
F‹˚F™outKey
).a)) })

247 
vÆ
 
p‹tsBIO
 = 
	`å™•o£
((
out
 
zù
 
ªque°BOI
Ë
m≠
 { (
o
, 
r
Ë=> 
TLXb¨
.
	`Ánout
(o.
b
,Ñ, 
edgesIn
 .
	`m≠
(
_
.
	`∑øms
(
F‹˚F™outKey
).b)) })

248 
vÆ
 
p‹tsCOI
 = 
	`å™•o£
((
ö
 
zù
 
ªque°CIO
Ë
m≠
 { (
i
, 
r
Ë=> 
TLXb¨
.
	`Ánout
(i.
c
,Ñ, 
edgesOut
.
	`m≠
(
_
.
	`∑øms
(
F‹˚F™outKey
).c)) })

249 
vÆ
 
p‹tsDIO
 = 
	`å™•o£
((
out
 
zù
 
ªque°DOI
Ë
m≠
 { (
o
, 
r
Ë=> 
TLXb¨
.
	`Ánout
(o.
d
,Ñ, 
edgesIn
 .
	`m≠
(
_
.
	`∑øms
(
F‹˚F™outKey
).d)) })

250 
vÆ
 
p‹tsEOI
 = 
	`å™•o£
((
ö
 
zù
 
ªque°EIO
Ë
m≠
 { (
i
, 
r
Ë=> 
TLXb¨
.
	`Ánout
(i.
e
,Ñ, 
edgesOut
.
	`m≠
(
_
.
	`∑øms
(
F‹˚F™outKey
).e)) })

253 
o
 <- 0 
u¡û
 
out
.
size
) {

254 
	`TLArbôî
(
pﬁicy
)(
	`out
(
o
).
a
, 
	`fûãr
(
bótsAI
 
zù
 
	`p‹tsAOI
(o), 
	`c⁄√˘AOI
(o)):
_
*)

255 
	`TLArbôî
(
pﬁicy
)(
	`out
(
o
).
c
, 
	`fûãr
(
bótsCI
 
zù
 
	`p‹tsCOI
(o), 
	`c⁄√˘COI
(o)):
_
*)

256 
	`TLArbôî
(
pﬁicy
)(
	`out
(
o
).
e
, 
	`fûãr
(
bótsEI
 
zù
 
	`p‹tsEOI
(o), 
	`c⁄√˘EOI
(o)):
_
*)

259 
i
 <- 0 
u¡û
 
ö
.
size
) {

260 
	`TLArbôî
(
pﬁicy
)(
	`ö
(
i
).
b
, 
	`fûãr
(
bótsBO
 
zù
 
	`p‹tsBIO
(i), 
	`c⁄√˘BIO
(i)):
_
*)

261 
	`TLArbôî
(
pﬁicy
)(
	`ö
(
i
).
d
, 
	`fûãr
(
bótsDO
 
zù
 
	`p‹tsDIO
(i), 
	`c⁄√˘DIO
(i)):
_
*)

264 
	}
}

266 
obje˘
 
TLXb¨


268 
def
 
≠∂y
(
pﬁicy
: 
TLArbôî
.
Pﬁicy
 = TLArbôî.
roundRobö
)(
im∂icô
 
p
: 
P¨amëîs
): 
TLNode
 =

270 
vÆ
 
xb¨
 = 
LazyModuÀ
(
√w
 
TLXb¨
(
pﬁicy
))

271 
xb¨
.
node


274 
def
 
m≠I≈utIds
 (
p‹ts
: 
Seq
[
TLClõ¡P‹tP¨amëîs
 ]Ë
assignR™ges
’‹ts.
m≠
(
_
.
ídSour˚Id
))

275 
def
 
m≠OuçutIds
(
p‹ts
: 
Seq
[
TLM™agîP‹tP¨amëîs
]Ë
assignR™ges
’‹ts.
m≠
(
_
.
ídSökId
))

277 
def
 
assignR™ges
(
sizes
: 
Seq
[
I¡
]) = {

278 
vÆ
 
pow2Sizes
 = 
sizes
.
m≠
 { 
z
 => i‡(z =0Ë0 1 << 
log2Ceû
(z) }

279 
vÆ
 
tu∂es
 = 
pow2Sizes
.
zùWôhIndex
.
s‹tBy
(
_
.
_1
)

280 
vÆ
 
°¨ts
 = 
tu∂es
.
sˇnRight
(0)(
_
.
_1
 + _).
èû


281 
vÆ
 
ønges
 = (
tu∂es
 
zù
 
°¨ts
Ë
m≠
 { ((
sz
, 
i
), 
°
) =>

282 (i‡(
sz
 =0Ë
IdR™ge
(0,0ËIdR™ge(
°
, st+sz), 
	gi
)

284 
	gønges
.
s‹tBy
(
_
.
_2
).
m≠
(_.
_1
)

287 
def
 
ªœbñî
() = {

288 
v¨
 
idFa˘‹y
 = 0

290 
vÆ
 
fifoM≠
 = 
sˇœ
.
cﬁÀ˘i⁄
.
muèbÀ
.
HashM≠
.
em±y
[
I¡
, Int]

291 (
	gx
: 
I¡
) => {

292 i‡(
fifoM≠
.
c⁄èös
(
x
)) fifoMap(x) {

293 
vÆ
 
out
 = 
idFa˘‹y


294 
idFa˘‹y
 = idFactory + 1

295 
fifoM≠
 +(
x
 -> 
out
)

296 
out


303 
def
 
Ánout
[
T
 <: 
TLCh™√l
](
öput
: 
Decou∂edIO
[T], 
	g£À˘
: 
Seq
[
Boﬁ
], 
	gf‹˚
: Seq[
Boﬁón
] = 
Nû
): Seq[DecoupledIO[T]] = {

304 
vÆ
 
fûãªd
 = 
Wúe
(
Vec
(
£À˘
.
size
, 
öput
))

305 
	gi
 <- 0 
u¡û
 
	g£À˘
.
	gsize
) {

306 
fûãªd
(
i
).
	gbôs
 :(i‡(
f‹˚
.
li·
(i).
gëOrEl£
(
Ál£
)Ë
IdítôyModuÀ
(
öput
.
bôs
) input.bits)

307 
fûãªd
(
i
).
vÆid
 :
öput
.vÆid && (
£À˘
(iË|| 
Boﬁ
(£À˘.
size
 == 1))

309 
öput
.
ªady
 :
Mux1H
(
£À˘
, 
fûãªd
.
m≠
(
_
.ready))

310 
	gfûãªd


315 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
_


317 
˛ass
 
	$TLRAMXb¨
(
nM™agîs
: 
I¡
, 
txns
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

318 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

319 
vÆ
 
modñ
 = 
	`LazyModuÀ
(
√w
 
	`TLRAMModñ
("Xbar"))

320 
vÆ
 
xb¨
 = 
	`LazyModuÀ
(
√w
 
TLXb¨
)

322 
xb¨
.
node
 :
	`TLDñayî
(0.1Ë:
modñ
.nodê:
fuzz
.node

323 (0 
u¡û
 
nM™agîs
Ë
f‹óch
 { 
n
 =>

324 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0x0+0x400*
n
, 0x3ff)))

325 
øm
.
node
 :
	`TLFøgmíãr
(4, 256Ë:
	`TLDñayî
(0.1Ë:
xb¨
.node

328 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

329 
io
.
föished
 :
fuzz
.
moduÀ
.io.finished

331 
	}
}

333 
˛ass
 
	$TLRAMXb¨Te°
(
nM™agîs
: 
I¡
, 
txns
: I¡ = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

334 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLRAMXb¨
(
nM™agîs
,
txns
)).
moduÀ
)

335 
io
.
föished
 :
dut
.io.finished

336 
	}
}

338 
˛ass
 
	$TLMu…i˛õ¡Xb¨
(
nM™agîs
: 
I¡
, 
nClõ¡s
: I¡, 
txns
: I¡)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ
 {

339 
vÆ
 
xb¨
 = 
	`LazyModuÀ
(
√w
 
TLXb¨
)

341 
vÆ
 
fuzzîs
 = (0 
u¡û
 
nClõ¡s
Ë
m≠
 { 
n
 =>

342 
vÆ
 
fuzz
 = 
	`LazyModuÀ
(
√w
 
	`TLFuzzî
(
txns
))

343 
xb¨
.
node
 :
	`TLDñayî
(0.1Ë:
fuzz
.node

344 
fuzz


347 (0 
u¡û
 
nM™agîs
Ë
f‹óch
 { 
n
 =>

348 
vÆ
 
øm
 = 
	`LazyModuÀ
(
√w
 
	`TLRAM
(
	`AddªssSë
(0x0+0x400*
n
, 0x3ff)))

349 
øm
.
node
 :
	`TLFøgmíãr
(4, 256Ë:
	`TLDñayî
(0.1Ë:
xb¨
.node

352 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	`LazyModuÀImp
(
this
Ë
wôh
 
UnôTe°ModuÀ
 {

353 
io
.
föished
 :
fuzzîs
.
œ°
.
moduÀ
.io.finished

355 
	}
}

357 
˛ass
 
	$TLMu…i˛õ¡Xb¨Te°
(
nM™agîs
: 
I¡
, 
nClõ¡s
: I¡, 
txns
: I¡ = 5000, 
timeout
: I¡ = 500000)(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
	$UnôTe°
(
timeout
) {

358 
vÆ
 
dut
 = 
	`ModuÀ
(
	`LazyModuÀ
(
√w
 
	`TLMu…i˛õ¡Xb¨
(
nM™agîs
, 
nClõ¡s
, 
txns
)).
moduÀ
)

359 
io
.
föished
 :
dut
.io.finished

360 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


8 
∑ckage
 
obje˘
 
	gtûñök


10 
ty≥
 
	gTLInw¨dNode
 = 
Inw¨dNodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
, 
TLM™agîP‹tP¨amëîs
, 
TLEdgeIn
, 
TLBundÀ
]

11 
ty≥
 
	gTLOutw¨dNode
 = 
Outw¨dNodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
, 
TLM™agîP‹tP¨amëîs
, 
TLEdgeOut
, 
TLBundÀ
]

12 
ty≥
 
	gTLNode
 = 
NodeH™dÀ
[
TLClõ¡P‹tP¨amëîs
, 
TLM™agîP‹tP¨amëîs
, 
TLEdgeIn
, 
TLBundÀ
, TLClõ¡P‹tP¨amëîs, TLM™agîP‹tP¨amëîs, 
TLEdgeOut
, TLBundle]

14 
im∂icô
 cœs†
	cTLClockDomaöCrossög
(
vÆ
 
x
: 
HasClockDomaöCrossög
Ë
exãnds
 
AnyVÆ
 {

15 
def
 
	`¸ossIn
 (
n
: 
TLInw¨dNode
Ë(
im∂icô
 
vÆName
: 
VÆName
Ë
	`TLInw¨dCrossögHñ≥r
 (vÆName.
«me
, 
x
,Ç)

16 
def
 
	`¸ossOut
(
n
: 
TLOutw¨dNode
)(
im∂icô
 
vÆName
: 
VÆName
Ë
	`TLOutw¨dCrossögHñ≥r
(vÆName.
«me
, 
x
,Ç)

17 
def
 
	`¸oss
(
n
: 
TLInw¨dNode
Ë(
im∂icô
 
vÆName
: 
VÆName
Ë
	`¸ossIn
(n)

18 
def
 
	`¸oss
(
n
: 
TLOutw¨dNode
)(
im∂icô
 
vÆName
: 
VÆName
Ë
	`¸ossOut
(n)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Configs.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
unôã°


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	gahb
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	g≠b
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	gaxi4
.
_


9 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsubsy°em
.{
	gBa£Subsy°emC⁄fig
}

11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdevi˚s
.
	gtûñök
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


15 
obje˘
 
Te°Duøti⁄Mu…ùlõr
 
exãnds
 
	gFõld
[
I¡
]

17 
˛ass
 
	$WôhTe°Duøti⁄
(
x
: 
I¡
Ë
exãnds
 
	`C⁄fig
((
sôe
, 
hîe
, 
up
) => {

18 
Te°Duøti⁄Mu…ùlõr
 => 
x


19 
	}
})

21 
˛ass
 
WôhAMBAUnôTe°s
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

22 
UnôTe°s
 => (
q
: 
P¨amëîs
) => {

23 
im∂icô
 
vÆ
 
p
 = 
q


24 
vÆ
 
txns
 = 100 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

25 
vÆ
 
timeout
 = 50000 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

26 
Seq
(

27 
ModuÀ
(
√w
 
AHBBridgeTe°
(
åue
, 
txns
=8*txns, 
timeout
=timeout)),

28 
ModuÀ
(
√w
 
AHBN©iveTe°
(
åue
, 
txns
=6*txns, 
timeout
=timeout)),

29 
ModuÀ
(
√w
 
AHBN©iveTe°
(
Ál£
,
txns
=6*txns, 
timeout
=timeout)),

30 
ModuÀ
(
√w
 
APBBridgeTe°
(
åue
, 
txns
=6*txns, 
timeout
=timeout)),

31 
ModuÀ
(
√w
 
APBBridgeTe°
(
Ál£
,
txns
=6*txns, 
timeout
=timeout)),

32 
ModuÀ
(
√w
 
AXI4LôeFuzzRAMTe°
(
txns
=6*txns, 
timeout
=timeout)),

33 
ModuÀ
(
√w
 
AXI4FuŒFuzzRAMTe°
(
txns
=3*txns, 
timeout
=timeout)),

34 
ModuÀ
(
√w
 
AXI4BridgeTe°
–
txns
=3*txns, 
timeout
=timeout)),

35 
ModuÀ
(
√w
 
AXI4Xb¨Te°
–
txns
=1*txns, 
timeout
=timeout)),

36 
ModuÀ
(
√w
 
AXI4RAMAsyncCrossögTe°
(
txns
=3*txns, 
timeout
=timeout))) }

39 
˛ass
 
WôhTLSim∂eUnôTe°s
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

40 
UnôTe°s
 => (
q
: 
P¨amëîs
) => {

41 
im∂icô
 
vÆ
 
p
 = 
q


42 
vÆ
 
txns
 = 100 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

43 
vÆ
 
timeout
 = 50000 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

44 
Seq
(

45 
ModuÀ
(
√w
 
TLRAMSim∂eTe°
(1, 
txns
=15*txns, 
timeout
=timeout)),

46 
ModuÀ
(
√w
 
TLRAMSim∂eTe°
(4, 
txns
=15*txns, 
timeout
=timeout)),

47 
ModuÀ
(
√w
 
TLRAMSim∂eTe°
(16, 
txns
=15*txns, 
timeout
=timeout)),

48 
ModuÀ
(
√w
 
TLRAMZîoDñayTe°
(4, 
txns
=15*txns, 
timeout
=timeout)),

49 
ModuÀ
(
√w
 
TLRAMHötH™dÀrTe°
–
txns
=15*txns, 
timeout
=timeout)),

50 
ModuÀ
(
√w
 
TLFuzzRAMTe°
–
txns
3*txns, 
timeout
=timeout)),

51 
ModuÀ
(
√w
 
TLRR0Te°
–
txns
3*txns, 
timeout
=timeout)),

52 
ModuÀ
(
√w
 
TLRR1Te°
–
txns
3*txns, 
timeout
=timeout)),

53 
ModuÀ
(
√w
 
TLRAMR©i⁄ÆCrossögTe°
(
txns
3*txns, 
timeout
=timeout)),

54 
ModuÀ
(
√w
 
TLRAMAsyncCrossögTe°
–
txns
5*txns, 
timeout
=timeout)),

55 
ModuÀ
(
√w
 
TLRAMAtomicAutom©aTe°
–
txns
=10*txns, 
timeout
=timeout)),

56 
ModuÀ
(
√w
 
TLRAMECCTe°
(8, 4, 
txns
=15*txns, 
timeout
=timeout)),

57 
ModuÀ
(
√w
 
TLRAMECCTe°
(4, 1, 
txns
=15*txns, 
timeout
=timeout)),

58 
ModuÀ
(
√w
 
TLRAMECCTe°
(1, 1, 
txns
=15*txns, 
timeout
=timeout)) ) }

61 
˛ass
 
WôhTLWidthUnôTe°s
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

62 
UnôTe°s
 => (
q
: 
P¨amëîs
) => {

63 
im∂icô
 
vÆ
 
p
 = 
q


64 
vÆ
 
txns
 = 100 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

65 
vÆ
 
timeout
 = 50000 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

66 
Seq
(

67 
ModuÀ
(
√w
 
TLRAMFøgmíãrTe°
–4, 256, 
txns
5*txns, 
timeout
=timeout)),

68 
ModuÀ
(
√w
 
TLRAMFøgmíãrTe°
(16, 64, 
txns
=15*txns, 
timeout
=timeout)),

69 
ModuÀ
(
√w
 
TLRAMFøgmíãrTe°
–4, 16, 
txns
=15*txns, 
timeout
=timeout)),

70 
ModuÀ
(
√w
 
TLRAMWidthWidgëTe°
–1, 1, 
txns
1*txns, 
timeout
=timeout)),

71 
ModuÀ
(
√w
 
TLRAMWidthWidgëTe°
–4, 64, 
txns
4*txns, 
timeout
=timeout)),

72 
ModuÀ
(
√w
 
TLRAMWidthWidgëTe°
(64, 4, 
txns
5*txns, 
timeout
=timeout)) ) }

75 
˛ass
 
WôhTLXb¨UnôTe°s
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

76 
UnôTe°s
 => (
q
: 
P¨amëîs
) => {

77 
im∂icô
 
vÆ
 
p
 = 
q


78 
vÆ
 
txns
 = 100 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

79 
vÆ
 
timeout
 = 50000 * 
sôe
(
Te°Duøti⁄Mu…ùlõr
)

80 
Seq
(

81 
ModuÀ
(
√w
 
TLRAMXb¨Te°
(1, 
txns
=5*txns, 
timeout
=timeout)),

82 
ModuÀ
(
√w
 
TLRAMXb¨Te°
(2, 
txns
=5*txns, 
timeout
=timeout)),

83 
ModuÀ
(
√w
 
TLRAMXb¨Te°
(8, 
txns
=5*txns, 
timeout
=timeout)),

84 
ModuÀ
(
√w
 
TLMu…i˛õ¡Xb¨Te°
(4,4, 
txns
=2*txns, 
timeout
=timeout)),

85 
ModuÀ
(
√w
 
TLMa°îMuxTe°
–
txns
=5*txns, 
timeout
=timeout)) ) }

88 
˛ass
 
WôhECCTe°s
 
exãnds
 
C⁄fig
((
sôe
, 
hîe
, 
up
) => {

89 
UnôTe°s
 => (
q
: 
P¨amëîs
) => {

90 
Seq
(

92 
ModuÀ
(
√w
 
ECCTe°
(1)),

93 
ModuÀ
(
√w
 
ECCTe°
(4)),

94 
ModuÀ
(
√w
 
ECCTe°
(11)),

96 
ModuÀ
(
√w
 
ECCTe°
(2)),

97 
ModuÀ
(
√w
 
ECCTe°
(5)),

98 
ModuÀ
(
√w
 
ECCTe°
(12)),

100 
ModuÀ
(
√w
 
ECCTe°
(3)),

101 
ModuÀ
(
√w
 
ECCTe°
(10)),

103 
ModuÀ
(
√w
 
ECCTe°
(8)) ) }

106 
˛ass
 
AMBAUnôTe°C⁄fig
 
exãnds
 
C⁄fig
(
√w
 
WôhAMBAUnôTe°s
 ++Çew 
WôhTe°Duøti⁄
(10Ë++Çew 
Ba£Subsy°emC⁄fig
)

107 
˛ass
 
TLSim∂eUnôTe°C⁄fig
 
exãnds
 
C⁄fig
(
√w
 
WôhTLSim∂eUnôTe°s
 ++Çew 
WôhTe°Duøti⁄
(10Ë++Çew 
Ba£Subsy°emC⁄fig
)

108 
˛ass
 
TLWidthUnôTe°C⁄fig
 
exãnds
 
C⁄fig
(
√w
 
WôhTLWidthUnôTe°s
 ++Çew 
WôhTe°Duøti⁄
(10Ë++Çew 
Ba£Subsy°emC⁄fig
)

109 
˛ass
 
TLXb¨UnôTe°C⁄fig
 
exãnds
 
C⁄fig
(
√w
 
WôhTLXb¨UnôTe°s
 ++Çew 
WôhTe°Duøti⁄
(10Ë++Çew 
Ba£Subsy°emC⁄fig
)

110 
˛ass
 
ECCUnôTe°C⁄fig
 
exãnds
 
C⁄fig
(
√w
 
WôhECCTe°s
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Generator.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
unôã°


5 
obje˘
 
Gíî©‹
 
exãnds
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
	gGíî©‹Aµ
 {

6 
vÆ
 
	gl⁄gName
 = 
«mes
.
t›ModuÀProje˘
 + "." +Çames.
c⁄figs


7 
gíî©eFúπl


8 
gíî©eA¬o


9 
gíî©eTe°SuôeMake‰ags


10 
gíî©eAπeÁ˘s


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestGenerator.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
unôã°


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


9 
ab°ø˘
 cœs†
	cLazyUnôTe°
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
LazyModuÀ


10 { 
£lf
 =>

11 
¥Ÿe˘ed
 
def
 
föished
: 
Boﬁ


13 
œzy
 
vÆ
 
moduÀ
 = 
√w
 
	$LazyModuÀImp
(
this
) {

14 
vÆ
 
föished
 = 
	`IO
(
	`Boﬁ
(
OUTPUT
))

15 
föished
 :
£lf
.finished

17 
	}
}

20 
˛ass
 
Te°Gíî©‹
(
gí
: 
LazyModuÀ
 => 
Seq
[
LazyUnôTe°
])

22 
def
 
≠∂y
(
lm
: 
LazyModuÀ
Ë
gí
(lm)

23 
def
 ++ (
Ÿhî
: 
Te°Gíî©‹
Ë
√w
 Te°Gíî©‹(
gí
 = 
lm
 => gen(lm) ++ other(lm))

26 
obje˘
 
Te°Gíî©‹


28 
def
 
≠∂y
(
m©chî
: 
P¨tülFun˘i⁄
[
LazyModuÀ
, 
Seq
[
LazyUnôTe°
]]): 
Te°Gíî©‹
 =

29 
√w
 
Te°Gíî©‹
(
gí
 = 
m©chî
.
li·
(
_
).
gëOrEl£
(
Nû
))

30 
def
 
ªcur£
(
Ÿhî
: 
Te°Gíî©‹
): TestGenerator = {

31 
def
 
hñ≥r
(
lm
: 
LazyModuÀ
, 
èû
: 
Seq
[
LazyUnôTe°
]): Seq[LazyUnitTest] =

32 
lm
.
gëChûdªn
.
fﬁdLe·
(
Ÿhî
÷mË++ 
èû
Ë{ —aû, 
chûd
Ë=> 
hñ≥r
(child,Åail) }

33 
√w
 
Te°Gíî©‹
(
gí
 = 
hñ≥r
(
_
, 
Nû
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestHarness.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
unôã°


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 ˛as†
	cTe°H¨√ss
(
im∂icô
 
vÆ
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

9 
vÆ
 
io
 = 
√w
 
BundÀ
 { vÆ 
suc˚ss
 = 
	`Boﬁ
(
OUTPUT
) }

10 
io
.
suc˚ss
 :
	`ModuÀ
(
√w
 
UnôTe°Suôe
).io.
föished


11 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/UnitTest.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
unôã°


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
Mu…iIOModuÀ


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
_


10 
åaô
 
	gUnôTe°IO
 {

11 
vÆ
 
	gföished
 = 
Boﬁ
(
OUTPUT
)

12 
vÆ
 
°¨t
 = 
Boﬁ
(
INPUT
)

15 
åaô
 
	gHasUnôTe°IO
 {

16 
vÆ
 
	gio
: 
UnôTe°IO


19 
åaô
 
UnôTe°LegacyModuÀ
 
exãnds
 
HasUnôTe°IO
 {

20 
vÆ
 
io
 = 
√w
 
BundÀ
 
wôh
 
UnôTe°IO


23 
åaô
 
UnôTe°ModuÀ
 
exãnds
 
Mu…iIOModuÀ
 
wôh
 
HasUnôTe°IO
 {

24 
vÆ
 
io
 = 
IO
(
√w
 
BundÀ
 
wôh
 
UnôTe°IO
)

25 
Eœb‹©i⁄AπeÁ˘s
.
add
("∂usArgs", 
PlusArgAπeÁ˘s
.
£rülize_cHódî
)

28 
ab°ø˘
 
˛ass
 
	$UnôTe°
(
vÆ
 
timeout
: 
I¡
 = 4096Ë
exãnds
 
ModuÀ
 
wôh
 
UnôTe°LegacyModuÀ
 {

29 
vÆ
 
ã°Name
 = 
this
.
gëCœss
.
gëSim∂eName


31 
	`whí
 (
io
.
°¨t
Ë{ 
	`¥ötf
(
s
"Started UnitTest $testName\n") }

33 
vÆ
 
timed_out
 = 
	`Sim∂eTimî
(
timeout
, 
io
.
°¨t
, io.
föished
)

34 
	`as£π
(!
timed_out
, 
s
"UnitTest $testNameÅimed out")

35 
	}
}

37 
obje˘
 
UnôTe°s
 
exãnds
 
	gFõld
[
P¨amëîs
 => 
Seq
[
UnôTe°
]]

39 ˛as†
	cUnôTe°Suôe
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

40 
vÆ
 
io
 = 
√w
 
BundÀ
 {

41 
vÆ
 
föished
 = 
	`Boﬁ
(
OUTPUT
)

44 
vÆ
 
ã°s
 = 
	$p
(
UnôTe°s
)(
p
)

46 
vÆ
 
s_idÀ
 :: 
s_°¨t
 :: 
s_busy
 :: 
s_d⁄e
 :: 
Nû
 = 
	`Enum
(
	`Bôs
(), 4)

47 
vÆ
 
°©e
 = 
	$Reg
(
öô
 = 
s_idÀ
)

48 
vÆ
 
ã°s_föished
 = 
	`Vec
(
ã°s
.
	`m≠
(
_
.
io
.
föished
)).
	$ªdu˚
(
_
&&_)

50 
ã°s
.
f‹óch
 { 
_
.
io
.
°¨t
 :(
°©e
 ==
s_°¨t
Ë
	}
}

51 
io
.
föished
 :(
°©e
 ==
s_d⁄e
)

53 
	$whí
 (
°©e
 ==
s_idÀ
Ë{ sèã :
s_°¨t
 
	}
}

54 
	$whí
 (
°©e
 ==
s_°¨t
Ë{ sèã :
s_busy
 
	}
}

55 
	$whí
 (
°©e
 ==
s_busy
 && 
ã°s_föished
Ë{ sèã :
s_d⁄e
 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
imp‹t
 
	gChi£l
.
_


7 
∑ckage
 
obje˘
 
	gunôã°


9 
im∂icô
 
˛ass
 
LazyUnôTe°Seq
(
vÆ
 
£q
: 
Seq
[
LazyUnôTe°
]) {

10 
def
 
föished
 = 
£q
.
m≠
(
_
.
moduÀ
.föished).
fﬁdLe·
(
Boﬁ
(
åue
))(_ && _)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Annotations.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
In°™˚Id


7 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.{
	g™nŸ©e
, 
	gChi£lA¬Ÿ©i⁄
, 
	gRawModuÀ
}

8 
imp‹t
 
	gfúπl
.
	g™nŸ©i⁄s
.
_


10 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gªgm≠≥r
.
_


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gtûñök
.
TLToAXI4IdM≠E¡ry


14 
imp‹t
 
	g‹g
.
	gjs⁄4s
.
	gJs⁄DSL
.
_


15 
imp‹t
 
	g‹g
.
	gjs⁄4s
.
	gjacks⁄
.
	gJs⁄Mëhods
.{
	g¥ëty
, 
	gªndî
}

18 
˛ass
 
	$SRAMA¬Ÿ©i⁄
(
èrgë
: 
Named
,

19 
addªss_width
: 
I¡
,

20 
«me
: 
Såög
,

21 
d©a_width
: 
I¡
,

22 
dïth
: 
I¡
,

23 
des¸ùti⁄
: 
Såög
,

24 
wrôe_mask_gønuœrôy
: 
I¡
Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[
Named
] {

25 
def
 
	`du∂iˇã
(
n
: 
Named
Ë
this
.
	`c›y
(n)

26 
	}
}

29 
˛ass
 
	$I¡îru±sP‹tA¬Ÿ©i⁄
(
èrgë
: 
Named
, 
«me
: 
Såög
, 
öãºu±Indexes
: 
Seq
[
I¡
]Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[Named] {

30 
def
 
	`du∂iˇã
(
n
: 
Named
Ë
this
.
	`c›y
(n)

31 
	}
}

34 
˛ass
 
	$GlobÆC⁄°™tsA¬Ÿ©i⁄
(
èrgë
: 
Named
, 
xLí
: 
I¡
Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[Named] {

35 
def
 
	`du∂iˇã
(
n
: 
Named
Ë
this
.
	`c›y
(n)

36 
	}
}

38 
˛ass
 
GlobÆC⁄°™tsChi£lA¬Ÿ©i⁄
[
T
 <: 
Produ˘
](
èrgë
: 
In°™˚Id
, 
	gxLí
: 
I¡
Ë
exãnds
 
Chi£lA¬Ÿ©i⁄
 {

39 
def
 
toFúπl
 = 
GlobÆC⁄°™tsA¬Ÿ©i⁄
(
èrgë
.
toNamed
, 
xLí
)

43 
˛ass
 
	$P¨amsA¬Ÿ©i⁄
(
èrgë
: 
Named
, 
∑ømsCœssName
: 
Såög
, 
∑øms
: 
M≠
[Såög,
Any
]Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[Named] {

44 
def
 
	`du∂iˇã
(
n
: 
Named
Ë
this
.
	`c›y
(n)

45 
	}
}

47 
˛ass
 
P¨amsChi£lA¬Ÿ©i⁄
[
T
 <: 
Produ˘
](
èrgë
: 
In°™˚Id
, 
	g∑øms
: TË
exãnds
 
Chi£lA¬Ÿ©i⁄
 {

48 
¥iv©e
 
vÆ
 
∑ømM≠
 = 
∑øms
.
gëCœss
.
gëDe˛¨edFõlds
.
m≠
(
_
.
gëName
).
zù
’¨ams.
¥odu˘Iãøt‹
.
to
).
toM≠


49 
def
 
toFúπl
 = 
P¨amsA¬Ÿ©i⁄
(
èrgë
.
toNamed
, 
∑øms
.
gëCœss
.
gëName
, 
∑ømM≠
)

53 
˛ass
 
	$AddªssM≠A¬Ÿ©i⁄
(
èrgë
: 
Named
, 
m≠pög
: 
Seq
[
AddªssM≠E¡ry
], 
œbñ
: 
Såög
Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[Named] {

54 
def
 
	`du∂iˇã
(
n
: 
Named
Ë
this
.
	`c›y
(n)

56 
def
 
toUVM
: 
Såög
 =

57 
s
"// Instance Name: ${target.serialize}\n" +

58 
m≠pög
.
	`m≠
(
_
.
ønge
.
toUVM
).
	`mkSåög
("\n")

60 
def
 
toJSON
: 
Såög
 =

61 
s
"""{\¿ "
$
{
œbñ
}": [\n""" +

62 
m≠pög
.
	`m≠
(
_
.
ønge
.
toJSON
).
	`mkSåög
(",\n") +

64 
	}
}

67 
˛ass
 
	$TLToAXI4IdM≠A¬Ÿ©i⁄
(
èrgë
: 
Named
, 
m≠pög
: 
Seq
[
TLToAXI4IdM≠E¡ry
]Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[Named] {

68 
def
 
	`du∂iˇã
(
n
: 
Named
Ë
this
.
	`c›y
(n)

69 
	}
}

72 
˛ass
 
	$RëimeModuÀA¬Ÿ©i⁄
(
èrgë
: 
ModuÀName
Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[ModuleName] {

73 
def
 
	`du∂iˇã
(
n
: 
ModuÀName
Ë
this
.
	`c›y
(n)

74 
	}
}

77 
˛ass
 
	$SœveAddªssM≠Chi£lA¬Ÿ©i⁄
(

78 
èrgë
: 
In°™˚Id
,

79 
addªs£s
: 
Seq
[
AddªssSë
],

80 
≥rms
: 
Resour˚Pîmissi⁄s
Ë
exãnds
 
Chi£lA¬Ÿ©i⁄
 {

81 
¥iv©e
 
vÆ
 
ønge
 = 
AddªssR™ge
.
	`‰omSës
(
addªs£s
)

82 
def
 
toFúπl
 = 
	`AddªssM≠A¬Ÿ©i⁄
(

83 
èrgë
 =Å¨gë.
toNamed
,

84 
m≠pög
 = 
ønge
.
m≠
 { 
r
 => 
	`AddªssM≠E¡ry
‘, 
≥rms
, 
Nû
) },

85 
œbñ
 = "slaves")

86 
	}
}

89 
˛ass
 
	$T›LevñP‹tA¬Ÿ©i⁄
(

90 
èrgë
: 
Comp⁄ítName
,

91 
¥Ÿocﬁ
: 
Såög
,

92 
ègs
: 
Seq
[
Såög
],

93 
«mes
: 
Seq
[
Såög
],

94 
width
: 
I¡
,

95 
addªss
: 
Seq
[
AddªssSë
]Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[
Comp⁄ítName
] {

96 
def
 
	`du∂iˇã
(
n
: 
Comp⁄ítName
): 
T›LevñP‹tA¬Ÿ©i⁄
 = 
this
.
	`c›y
(n)

97 
	}
}

100 
˛ass
 
	$Re£tVe˘‹A¬Ÿ©i⁄
(
èrgë
: 
Named
, 
ª£tVec
: 
BigI¡
Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[Named] {

101 
def
 
	`du∂iˇã
(
n
: 
Named
): 
Re£tVe˘‹A¬Ÿ©i⁄
 = 
this
.
	`c›y
(n)

102 
	}
}

105 
obje˘
 
A¬Ÿ©ed
 {

107 
def
 
§ams
(

108 
comp⁄ít
: 
In°™˚Id
,

109 
«me
: 
Såög
,

110 
addªss_width
: 
I¡
,

111 
d©a_width
: 
I¡
,

112 
dïth
: 
I¡
,

113 
des¸ùti⁄
: 
Såög
,

114 
wrôe_mask_gønuœrôy
: 
I¡
): 
Unô
 = {

115 
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 {
def
 
toFúπl
: 
A¬Ÿ©i⁄
 = 
SRAMA¬Ÿ©i⁄
(

116 
comp⁄ít
.
toNamed
,

117 
addªss_width
 =áddress_width,

118 
«me
 =Çame,

119 
d©a_width
 = data_width,

120 
dïth
 = depth,

121 
des¸ùti⁄
 = description,

122 
wrôe_mask_gønuœrôy
 = write_mask_granularity

125 
def
 
öãºu±s
(
comp⁄ít
: 
In°™˚Id
, 
«me
: 
Såög
, i¡îru±s: 
Seq
[
I¡
]): 
Unô
 = {

126 
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 {
def
 
toFúπl
: 
A¬Ÿ©i⁄
 = 
I¡îru±sP‹tA¬Ÿ©i⁄
(

127 
comp⁄ít
.
toNamed
,

128 
«me
,

129 
öãºu±s


133 
def
 
ª£tVe˘‹
(
comp⁄ít
: 
In°™˚Id
, 
ª£tVec
: 
BigI¡
): 
Unô
 = {

134 
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 {
def
 
toFúπl
: 
A¬Ÿ©i⁄
 = 
Re£tVe˘‹A¬Ÿ©i⁄
(
comp⁄ít
.
toNamed
, 
ª£tVec
)})

137 
def
 
c⁄°™ts
(
comp⁄ít
: 
In°™˚Id
, 
xLí
: 
I¡
): 
Unô
 = {

138 
™nŸ©e
(
GlobÆC⁄°™tsChi£lA¬Ÿ©i⁄
(
comp⁄ít
, 
xLí
 ))

141 
def
 
∑øms
[
T
 <: 
Produ˘
](
comp⁄ít
: 
In°™˚Id
, 
	g∑øms
: T): T = {

142 
™nŸ©e
(
P¨amsChi£lA¬Ÿ©i⁄
(
comp⁄ít
, 
∑øms
))

143 
∑øms


146 
def
 
addªssM≠pög
(
comp⁄ít
: 
In°™˚Id
, 
m≠pög
: 
Seq
[
AddªssM≠E¡ry
]): Seq[AddressMapEntry] = {

147 
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 { 
def
 
toFúπl
 = 
AddªssM≠A¬Ÿ©i⁄
(
comp⁄ít
.
toNamed
, 
m≠pög
, "mapping") })

148 
	gm≠pög


151 
def
 
idM≠pög
(
comp⁄ít
: 
In°™˚Id
, 
m≠pög
: 
Seq
[
TLToAXI4IdM≠E¡ry
]): Seq[TLToAXI4IdMapEntry] = {

152 
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 { 
def
 
toFúπl
 = 
TLToAXI4IdM≠A¬Ÿ©i⁄
(
comp⁄ít
.
toNamed
, 
m≠pög
) })

153 
	gm≠pög


156 
def
 
	gp‹t
[
T
 <: 
D©a
](

157 
d©a
: 
T
,

158 
	g¥Ÿocﬁ
: 
Såög
,

159 
	gègs
: 
Seq
[
Såög
],

160 
	g«mes
: 
Seq
[
Såög
],

161 
	gwidth
: 
I¡
,

162 
	gaddªss
: 
Seq
[
AddªssSë
] = 
Nû
): 
T
 = {

163 
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 { 
def
 
toFúπl
 = 
T›LevñP‹tA¬Ÿ©i⁄
(
d©a
.
toNamed
, 
¥Ÿocﬁ
, 
ègs
, 
«mes
, 
width
, 
addªss
) })

164 
	gd©a


169 
åaô
 
	gD⁄tTouch
 { 
	g£lf
: 
RawModuÀ
 =>

172 
def
 
d⁄tTouch
(
d©a
: 
D©a
): 
Unô
 = d©®
m©ch
 {

173 
agg
: 
Aggªg©e
 =>ágg.
gëEÀmíts
.
f‹óch
(
d⁄tTouch
)

174 
ñt
: 
EÀmít
 => 
chi£l3
.
c‹e
.
d⁄tTouch
(elt)

182 
def
 
d⁄tTouchP‹ts
(): 
this
.
ty≥
 = {

183 
£lf
.
gëModuÀP‹ts
.
f‹óch
(
d⁄tTouch
(
_
))

184 
£lf


187 
def
 
d⁄tTouchP‹tsEx˚±
(
f
: 
D©a
 => 
Boﬁón
): 
this
.
ty≥
 = {

188 
£lf
.
gëModuÀP‹ts
.
fûãrNŸ
(
f
).
f‹óch
(
d⁄tTouch
(
_
))

189 
£lf


194 
åaô
 
ShouldBeRëimed
 { 
£lf
: 
RawModuÀ
 =>

195 
chi£l3
.
ex≥rimíèl
.
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 { 
def
 
toFúπl
: 
RëimeModuÀA¬Ÿ©i⁄
 = RëimeModuÀA¬Ÿ©i⁄(
£lf
.
toNamed
) })

198 
˛ass
 
	$RegFõldDescM≠pögA¬Ÿ©i⁄
(

199 
èrgë
: 
ModuÀName
,

200 
ªgM≠pögSî
: 
Regi°îsSî
Ë
exãnds
 
SögÀT¨gëA¬Ÿ©i⁄
[
ModuÀName
] {

201 
def
 
	`du∂iˇã
(
n
: 
ModuÀName
): 
RegFõldDescM≠pögA¬Ÿ©i⁄
 = 
this
.
	`c›y
(
èrgë
 =Ç)

202 
	}
}

204 
obje˘
 
I¡îru±sP‹tA¬Ÿ©i⁄
 {

205 
vÆ
 
GLOBAL_EXTERNAL_INTERRUPTS
 = "global-external-interrupts"

206 
vÆ
 
LOCAL_EXTERNAL_INTERRUPTS
 = "local-external-interrupts"

207 
vÆ
 
LOCAL_INTERRUPTS_STARTING_NUMBER
 = 16

212 
obje˘
 
GíRegDescsA¬o
 {

214 
def
 
makeRegM≠pögSî
(

215 
øwModuÀ
: 
RawModuÀ
,

216 
moduÀName
: 
Såög
,

217 
ba£Addªss
: 
BigI¡
,

218 
width
: 
I¡
,

219 
byãOff£t
: 
I¡
,

220 
bôOff£t
: 
I¡
,

221 
ªgFõld
: 
RegFõld
): 
RegFõldDescSî
 = {

223 
vÆ
 
™⁄RegFõldName
 = 
s
"unnamedRegField${byteOffset.toHexString}_${bitOffset}"

224 
vÆ
 
£À˘edRegFõldName
 = 
ªgFõld
.
desc
.
m≠
(
_
.
«me
).
gëOrEl£
(
™⁄RegFõldName
)

226 
vÆ
 
m≠
 = 
M≠
[
BigI¡
, (
Såög
, String)]()

234 
vÆ
 
	gdesc
 = 
ªgFõld
.
desc


236 
vÆ
 
ªgFõldDescSî
 = 
RegFõldDescSî
(

237 
byãOff£t
 = 
s
"0x${byteOffset.toInt.toHexString}",

238 
bôOff£t
 = bitOffset,

239 
bôWidth
 = 
width
,

240 
«me
 = 
£À˘edRegFõldName
,

241 
desc
 = desc.
m≠
 {
_
.desc}.
gëOrEl£
("None"),

242 
group
 = 
desc
.
m≠
 {
_
.group.
gëOrEl£
("None")}.getOrElse("None"),

243 
groupDesc
 = 
desc
.
m≠
 {
_
.groupDesc.
gëOrEl£
("None")}.getOrElse("None"),

244 
ac˚ssTy≥
 = 
desc
.
m≠
 {
_
.
ac˚ss
.
toSåög
}.
gëOrEl£
("None"),

245 
wrTy≥
 = 
desc
.
m≠
(
_
.wrTy≥.
toSåög
).
gëOrEl£
("None"),

246 
rdA˘i⁄
 = 
desc
.
m≠
(
_
.rdA˘i⁄.
toSåög
).
gëOrEl£
("None"),

247 vﬁ©ûê
desc
.
m≠
(
_
.vﬁ©ûe).
gëOrEl£
(
Ál£
),

248 
hasRe£t
 = 
desc
.
m≠
 {
_
.
ª£t
 !
N⁄e
 }.
gëOrEl£
(
Ál£
),

249 
ª£tVÆue
 = 
desc
.
m≠
{
_
.
ª£t
.
gëOrEl£
(
BigI¡
(0))}.getOrElse(BigInt(0)),

250 
íumî©i⁄s
 = 
m≠


253 
ªgFõldDescSî


257 
def
 
™no
(

258 
øwModuÀ
: 
RawModuÀ
,

259 
ba£Addªss
: 
BigI¡
,

260 
m≠pög
: 
RegFõld
.
M≠
*): 
Seq
[RegField.Map] = {

262 
vÆ
 
moduÀName
 = 
øwModuÀ
.
«me


263 
vÆ
 
ba£Hex
 = 
s
"0x${baseAddress.toInt.toHexString}"

264 
vÆ
 
di•œyName
 = 
s
"${moduleName}.${baseHex}"

266 
vÆ
 
ªgFõldSîs
 = 
m≠pög
.
Ê©M≠
 {

267 (
byãOff£t
, 
£q
) =>

268 
£q
.
m≠
(
_
.
width
).
sˇnLe·
(0)(_ + _).
zù
(£q).m≠ { (
bôOff£t
, 
ªgFõld
) =>

269 
makeRegM≠pögSî
(

270 
øwModuÀ
,

271 
moduÀName
,

272 
ba£Addªss
,

273 
ªgFõld
.
width
,

274 
byãOff£t
,

275 
bôOff£t
,

276 
ªgFõld


281 
vÆ
 
	gªgi°îsSî
 = 
Regi°îsSî
(

282 
di•œyName
 = 
moduÀName
,

283 
devi˚Name
 = 
moduÀName
,

284 
ba£Addªss
 = baseAddress,

285 
ªgFõlds
 = 
ªgFõldSîs


289 
™nŸ©e
(
√w
 
Chi£lA¬Ÿ©i⁄
 { 
def
 
toFúπl
 = 
RegFõldDescM≠pögA¬Ÿ©i⁄
(
øwModuÀ
.
toNamed
, 
ªgi°îsSî
) })

291 
	gm≠pög


295 
def
 
£rülize
(
ba£
: 
BigI¡
, 
«me
: 
Såög
, 
m≠pög
: 
RegFõld
.
M≠
*): String = {

298 
vÆ
 
ªgDescs
 = 
m≠pög
.
Ê©M≠
 { (
byã
, 
£q
) =>

299 
£q
.
m≠
(
_
.
width
).
sˇnLe·
(0)(_ + _).
zù
(£q).m≠ { (
bô
, 
f
) =>

300 
vÆ
 
™⁄Name
 = 
s
"unnamedRegField${byte.toHexString}_${bit}"

301 (
f
.
desc
.
m≠
{ 
_
.
«me
}.
gëOrEl£
(
™⁄Name
)Ë-> f.
toJs⁄
(
byã
, 
bô
)

305 
¥ëty
(
ªndî
(

307 ("di•œyName" -> 
«me
) ~

308 ("ba£Addªss" -> 
s
"0x${base.toInt.toHexString}") ~

309 ("ªgfõlds" -> 
ªgDescs
)))))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Arbiters.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


10 
ab°ø˘
 
˛ass
 
	gHñœLockögArbôî
[
T
 <: 
D©a
](
typ
: T, 
	g¨bN
: 
I¡
, 
	gº
: 
Boﬁón
 = 
Ál£
)

11 
exãnds
 
ModuÀ
 {

13 
vÆ
 
io
 = 
√w
 
BundÀ
 {

14 
vÆ
 
ö
 = 
Vec
(
¨bN
, 
Decou∂ed
(
typ
.
˛⁄eTy≥
)).
Êù


15 
vÆ
 
	gout
 = 
Decou∂ed
(
typ
.
˛⁄eTy≥
)

18 
def
 
	grŸ©eLe·
[
T
 <: 
D©a
](
n‹m
: 
Vec
[T], 
	grŸ
: 
UI¡
): Vec[T] = {

19 
vÆ
 
n
 = 
n‹m
.
size


20 
Vec
.
èbuœã
(
n
Ë{ 
i
 =>

21 
Mux
(
rŸ
 < 
UI¡
(
n
 - 
i
), 
n‹m
(UInt(i) +Ñot),Çorm(rot - UInt(n - i)))

25 
vÆ
 
	glockIdx
 = 
Reg
(
öô
 = 
UI¡
(0, 
log2Up
(
¨bN
)))

26 
vÆ
 
	glocked
 = 
Reg
(
öô
 = 
Boﬁ
(
Ál£
))

28 
vÆ
 
choi˚
 = i‡(
º
) {

29 
Pri‹ôyMux
(

30 
rŸ©eLe·
(
Vec
(
io
.
ö
.
m≠
(
_
.
vÆid
)), 
lockIdx
 + 
UI¡
(1)),

31 
rŸ©eLe·
(
Vec
((0 
u¡û
 
¨bN
).
m≠
(
UI¡
(
_
))), 
lockIdx
 + UInt(1)))

33 
Pri‹ôyEncodî
(
io
.
ö
.
m≠
(
_
.
vÆid
))

36 
vÆ
 
cho£n
 = 
Mux
(
locked
, 
lockIdx
, 
choi˚
)

38 
	gi
 <- 0 
u¡û
 
	g¨bN
) {

39 
	gio
.
ö
(
i
).
	gªady
 :
io
.
out
.
ªady
 && 
cho£n
 ==
UI¡
(i)

42 
io
.
out
.
vÆid
 :io.
ö
(
cho£n
).valid

43 
io
.
out
.
bôs
 :io.
ö
(
cho£n
).bits

48 
˛ass
 
HñœPìkögArbôî
[
T
 <: 
D©a
](

49 
typ
: 
T
, 
	g¨bN
: 
I¡
,

50 
	gˇnU∆ock
: 
T
 => 
Boﬁ
,

51 
	g√edsLock
: 
O±i⁄
[
T
 => 
Boﬁ
] = 
N⁄e
,

52 
	gº
: 
Boﬁón
 = 
Ál£
)

53 
exãnds
 
	$HñœLockögArbôî
(
typ
, 
¨bN
, 
º
) {

55 
def
 
	`ªÆNìdsLock
(
d©a
: 
T
): 
Boﬁ
 =

56 
√edsLock
.
	`m≠
(
	`_
(
d©a
)).
	`gëOrEl£
(
	`Boﬁ
(
åue
))

58 
	`whí
 (
io
.
out
.
	`fúe
()) {

59 
	`whí
 (!
locked
 && 
	`ªÆNìdsLock
(
io
.
out
.
bôs
)) {

60 
lockIdx
 :
choi˚


61 
locked
 :
	`Boﬁ
(
åue
)

64 
	`whí
 (
	`ˇnU∆ock
(
io
.
out
.
bôs
)) {

65 
locked
 :
	`Boﬁ
(
Ál£
)

68 
	}
}

71 
˛ass
 
HñœCou¡ögArbôî
[
T
 <: 
D©a
](

72 
typ
: 
T
, 
	g¨bN
: 
I¡
, 
	gcou¡
: Int,

73 
vÆ
 
	g√edsLock
: 
O±i⁄
[
T
 => 
Boﬁ
] = 
N⁄e
,

74 
	gº
: 
Boﬁón
 = 
Ál£
)

75 
exãnds
 
	$HñœLockögArbôî
(
typ
, 
¨bN
, 
º
) {

77 
def
 
	`ªÆNìdsLock
(
d©a
: 
T
): 
Boﬁ
 =

78 
√edsLock
.
	`m≠
(
	`_
(
d©a
)).
	`gëOrEl£
(
	`Boﬁ
(
åue
))

81 
	`ªquúe
(
cou¡
 > 1, "CountingArbiter cannot have count <= 1")

83 
vÆ
 
lock_˘r
 = 
	`Cou¡î
(
cou¡
)

85 
	`whí
 (
io
.
out
.
	`fúe
()) {

86 
	`whí
 (!
locked
 && 
	`ªÆNìdsLock
(
io
.
out
.
bôs
)) {

87 
lockIdx
 :
choi˚


88 
locked
 :
	`Boﬁ
(
åue
)

89 
lock_˘r
.
	`öc
()

92 
	`whí
 (
locked
) {

93 
	`whí
 (
lock_˘r
.
	`öc
()Ë{ 
locked
 :
	`Boﬁ
(
Ál£
) }

96 
	}
}

99 
˛ass
 
InOrdîArbôî
[
T
 <: 
D©a
, 
U
 <: D©a](
ªqTyp
: T, 
	gª•Typ
: U, 
	gn
: 
I¡
)

100 (
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
ModuÀ
 {

101 
vÆ
 
io
 = 
√w
 
BundÀ
 {

102 
vÆ
 
ö_ªq
 = 
Vec
(
n
, 
Decou∂ed
(
ªqTyp
)).
Êù


103 
vÆ
 
	gö_ª•
 = 
Vec
(
n
, 
Decou∂ed
(
ª•Typ
))

104 
vÆ
 
	gout_ªq
 = 
Decou∂ed
(
ªqTyp
)

105 
vÆ
 
out_ª•
 = 
Decou∂ed
(
ª•Typ
).
Êù


108 i‡(
	gn
 > 1) {

109 
vÆ
 
	grouã_q
 = 
ModuÀ
(
√w
 
Queue
(
UI¡
(
width
 = 
log2Up
(
n
)), 2))

110 
vÆ
 
	gªq_¨b
 = 
ModuÀ
(
√w
 
RRArbôî
(
ªqTyp
, 
n
))

111 
	gªq_¨b
.
	gio
.
	gö
 <> io.
ö_ªq


113 
vÆ
 
	gªq_hñ≥r
 = 
Decou∂edHñ≥r
(

114 
ªq_¨b
.
io
.
out
.
vÆid
,

115 
rouã_q
.
io
.
íq
.
ªady
,

116 
io
.
out_ªq
.
ªady
)

118 
	gio
.
	gout_ªq
.
	gbôs
 :
ªq_¨b
.
io
.
out
.
bôs


119 
io
.
out_ªq
.
vÆid
 :
ªq_hñ≥r
.
fúe
(io.out_ªq.
ªady
)

121 
rouã_q
.
io
.
íq
.
bôs
 :
ªq_¨b
.io.
cho£n


122 
rouã_q
.
io
.
íq
.
vÆid
 :
ªq_hñ≥r
.
fúe
‘ouã_q.io.íq.
ªady
)

124 
ªq_¨b
.
io
.
out
.
ªady
 :
ªq_hñ≥r
.
fúe
‘eq_¨b.io.out.
vÆid
)

126 
vÆ
 
ª•_£l
 = 
rouã_q
.
io
.
deq
.
bôs


127 
vÆ
 
ª•_ªady
 = 
io
.
ö_ª•
(
ª•_£l
).
ªady


128 
vÆ
 
ª•_hñ≥r
 = 
Decou∂edHñ≥r
(

129 
ª•_ªady
,

130 
rouã_q
.
io
.
deq
.
vÆid
,

131 
io
.
out_ª•
.
vÆid
)

133 
vÆ
 
	gª•_vÆid
 = 
ª•_hñ≥r
.
fúe
(
ª•_ªady
)

134 
i
 <- 0 
u¡û
 
n
) {

135 
io
.
ö_ª•
(
i
).
bôs
 :io.
out_ª•
.bits

136 
io
.
ö_ª•
(
i
).
vÆid
 :
ª•_vÆid
 && 
ª•_£l
 ==
UI¡
(i)

139 
rouã_q
.
io
.
deq
.
ªady
 :
ª•_hñ≥r
.
fúe
‘ouã_q.io.deq.
vÆid
)

140 
io
.
out_ª•
.
ªady
 :
ª•_hñ≥r
.
fúe
(io.out_ª•.
vÆid
)

142 
io
.
out_ªq
 <> io.
ö_ªq
.
hód


143 
io
.
ö_ª•
.
hód
 <> io.
out_ª•


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncQueue.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
_


8 
˛ass
 
	$AsyncQueueP¨ams
(

9 
dïth
: 
I¡
 = 8,

10 
sync
: 
I¡
 = 3,

11 
ß„
: 
Boﬁón
 = 
åue
,

14 
«ºow
: 
Boﬁón
 = 
Ál£
)

19 
	`ªquúe
 (
dïth
 > 0 && 
	`isPow2
(depth))

20 
	`ªquúe
 (
sync
 >= 2)

22 
vÆ
 
bôs
 = 
	`log2Ceû
(
dïth
)

23 
vÆ
 
wúes
 = i‡(
«ºow
Ë1 
dïth


24 
	}
}

26 
obje˘
 
AsyncQueueP¨ams
 {

28 
def
 
sögÀt⁄
(
sync
: 
I¡
 = 3, 
ß„
: 
Boﬁón
 = 
åue
Ë
AsyncQueueP¨ams
(1, sync, sa„, 
Ál£
)

31 ˛as†
	cAsyncBundÀSa„ty
 
exãnds
 
	mBundÀ
 {

32 
vÆ
 
	mridx_vÆid
 = 
I≈ut
 (
	$Boﬁ
())

33 
vÆ
 
widx_vÆid
 = 
	`Ouçut
(
	$Boﬁ
())

34 
vÆ
 
sour˚_ª£t_n
 = 
	`Ouçut
(
	$Boﬁ
())

35 
vÆ
 
sök_ª£t_n
 = 
	`I≈ut
 (
	`Boﬁ
())

38 
˛ass
 
AsyncBundÀ
[
T
 <: 
D©a
](
¥iv©e
 
vÆ
 
gí
: T, vÆ 
∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
()Ë
exãnds
 
BundÀ
 {

40 
vÆ
 
mem
 = 
	`Ouçut
(
	`Vec
(
∑øms
.
wúes
, 
gí
))

41 
vÆ
 
ridx
 = 
	`I≈ut
 (
	`UI¡
((
∑øms
.
bôs
+1).
W
))

42 
vÆ
 
widx
 = 
	`Ouçut
(
	`UI¡
((
∑øms
.
bôs
+1).
W
))

43 
vÆ
 
ödex
 = 
∑øms
.
«ºow
.
	`›ti⁄
(
	`I≈ut
(
	`UI¡
’¨ams.
bôs
.
W
)))

46 
vÆ
 
ß„
 = 
∑øms
.ß„.
	`›ti⁄
(
√w
 
AsyncBundÀSa„ty
)

47 
	}
}

49 
obje˘
 
	gGøyCou¡î
 {

50 
def
 
≠∂y
(
bôs
: 
I¡
, 
ö¸emít
: 
Boﬁ
 = 
åue
.
B
, 
˛ór
: Boﬁ = 
Ál£
.B, 
«me
: 
Såög
 = "bö¨y"): 
UI¡
 = {

51 
vÆ
 
ö¸emíãd
 = 
Wúe
(
UI¡
(
bôs
.
W
))

52 
vÆ
 
bö¨y
 = 
AsyncRe£tReg
(
ö¸emíãd
, 
«me
)

53 
	gö¸emíãd
 :
Mux
(
˛ór
, 0.U, 
bö¨y
 + 
ö¸emít
.
asUI¡
())

54 
	gö¸emíãd
 ^ (incremented >> 1)

58 
˛ass
 
	$AsyncVÆidSync
(
sync
: 
I¡
, 
desc
: 
Såög
Ë
exãnds
 
ModuÀ
 {

59 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

60 
vÆ
 
ö
 = 
	`I≈ut
(
	`Boﬁ
())

61 
vÆ
 
out
 = 
	`Ouçut
(
	`Boﬁ
())

63 
io
.
out
 :
	`AsyncRe£tSynchr⁄izîShi·Reg
(io.
ö
, 
sync
, 
	`Some
(
desc
))

64 
	}
}

66 
˛ass
 
	gAsyncQueueSour˚
[
T
 <: 
D©a
](
gí
: T, 
	g∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
()Ë
exãnds
 
ModuÀ
 {

67 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

69 
vÆ
 
íq
 = 
	`Flù≥d
(
	`Decou∂ed
(
gí
))

71 
vÆ
 
async
 = 
√w
 
	`AsyncBundÀ
(
gí
, 
∑øms
)

74 
vÆ
 
bôs
 = 
∑øms
.bits

75 
vÆ
 
sök_ªady
 = 
	`WúeInô
(
åue
.
B
)

76 
vÆ
 
mem
 = 
	`Reg
(
	`Vec
(
∑øms
.
dïth
, 
gí
))

77 
vÆ
 
widx
 = 
	`GøyCou¡î
(
bôs
+1, 
io
.
íq
.
	`fúe
(), !
sök_ªady
, "widx_bin")

78 
vÆ
 
ridx
 = 
	`AsyncRe£tSynchr⁄izîShi·Reg
(
io
.
async
.ridx, 
∑øms
.
sync
, 
	`Some
("ridx_gray"))

79 
vÆ
 
ªady
 = 
sök_ªady
 && 
widx
 =/(
ridx
 ^ (
∑øms
.
dïth
 |Ö¨ams.dïth >> 1).
U
)

81 
vÆ
 
ödex
 = i‡(
bôs
 =0Ë0.U 
io
.
async
.
	`widx
(bits-1, 0) ^ (io.async.widx(bits, bits) << (bits-1))

82 
	`whí
 (
io
.
íq
.
	`fúe
()Ë{ 
	`mem
(
ödex
Ë:io.íq.
bôs
 }

84 
vÆ
 
ªady_ªg
 = 
	`AsyncRe£tReg
(
ªady
.
asUI¡
, "ready_reg")(0)

85 
io
.
íq
.
ªady
 :
ªady_ªg
 && 
sök_ªady


87 
vÆ
 
widx_ªg
 = 
	`AsyncRe£tReg
(
widx
, "widx_gray")

88 
io
.
async
.
widx
 :
widx_ªg


90 
io
.
async
.
ödex
 
m©ch
 {

91 
	`Some
(
ödex
Ë=> 
io
.
async
.
	`mem
(0) := mem(index)

92 
N⁄e
 => 
io
.
async
.
mem
 := mem

95 
io
.
async
.
ß„
.
f‹óch
 { 
sio
 =>

96 
vÆ
 
sour˚_vÆid
 = 
	`ModuÀ
(
√w
 
	`AsyncVÆidSync
(
∑øms
.
sync
+1, "source_valid"))

97 
vÆ
 
sök_exãnd
 = 
	`ModuÀ
(
√w
 
	`AsyncVÆidSync
(1, "sink_extend"))

98 
vÆ
 
sök_vÆid
 = 
	`ModuÀ
(
√w
 
	`AsyncVÆidSync
(
∑øms
.
sync
, "sink_valid"))

99 
sour˚_vÆid
.
ª£t
 :ª£t.
toBoﬁ
 || !
sio
.
sök_ª£t_n


100 
sök_exãnd
 .
ª£t
 :ª£t.
toBoﬁ
 || !
sio
.
sök_ª£t_n


102 
sour˚_vÆid
.
io
.
ö
 :
åue
.
B


103 
sio
.
widx_vÆid
 :
sour˚_vÆid
.
io
.
out


104 
sök_exãnd
.
io
.
ö
 :
sio
.
ridx_vÆid


105 
sök_vÆid
.
io
.
ö
 :
sök_exãnd
.io.
out


106 
sök_ªady
 :
sök_vÆid
.
io
.
out


107 
sio
.
sour˚_ª£t_n
 :!
ª£t
.
toBoﬁ


118 
	}
}

120 
˛ass
 
AsyncQueueSök
[
T
 <: 
D©a
](
gí
: T, 
	g∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
()Ë
exãnds
 
ModuÀ
 {

121 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

123 
vÆ
 
deq
 = 
	`Decou∂ed
(
gí
)

125 
vÆ
 
async
 = 
	`Flù≥d
(
√w
 
	`AsyncBundÀ
(
gí
, 
∑øms
))

128 
vÆ
 
bôs
 = 
∑øms
.bits

129 
vÆ
 
sour˚_ªady
 = 
	`WúeInô
(
åue
.
B
)

130 
vÆ
 
ridx
 = 
	`GøyCou¡î
(
bôs
+1, 
io
.
deq
.
	`fúe
(), !
sour˚_ªady
, "ridx_bin")

131 
vÆ
 
widx
 = 
	`AsyncRe£tSynchr⁄izîShi·Reg
(
io
.
async
.widx, 
∑øms
.
sync
, 
	`Some
("widx_gray"))

132 
vÆ
 
vÆid
 = 
sour˚_ªady
 && 
ridx
 =/
widx


138 
vÆ
 
ödex
 = i‡(
bôs
 =0Ë0.U 
	`ridx
(bits-1, 0) ^ (ridx(bits, bits) << (bits-1))

139 
io
.
async
.
ödex
.
f‹óch
 { 
_
 := index }

144 
vÆ
 
deq_bôs_nxt
 = 
	`Mux
(
vÆid
, 
io
.
async
.
	`mem
(i‡(
∑øms
.
«ºow
Ë0.U 
ödex
), io.
deq
.
bôs
)

145 
io
.
deq
.
bôs
 :
	`Synchr⁄izîShi·Reg
(
deq_bôs_nxt
, 
sync
 = 1, 
«me
 = 
	`Some
("deq_bits_reg"))

147 
vÆ
 
vÆid_ªg
 = 
	`AsyncRe£tReg
(
vÆid
.
asUI¡
, "valid_reg")(0)

148 
io
.
deq
.
vÆid
 :
vÆid_ªg
 && 
sour˚_ªady


150 
vÆ
 
ridx_ªg
 = 
	`AsyncRe£tReg
(
ridx
, "ridx_gray")

151 
io
.
async
.
ridx
 :
ridx_ªg


153 
io
.
async
.
ß„
.
f‹óch
 { 
sio
 =>

154 
vÆ
 
sök_vÆid
 = 
	`ModuÀ
(
√w
 
	`AsyncVÆidSync
(
∑øms
.
sync
+1, "sink_valid"))

155 
vÆ
 
sour˚_exãnd
 = 
	`ModuÀ
(
√w
 
	`AsyncVÆidSync
(1, "source_extend"))

156 
vÆ
 
sour˚_vÆid
 = 
	`ModuÀ
(
√w
 
	`AsyncVÆidSync
(
∑øms
.
sync
, "source_valid"))

157 
sök_vÆid
 .
ª£t
 :ª£t.
toBoﬁ
 || !
sio
.
sour˚_ª£t_n


158 
sour˚_exãnd
.
ª£t
 :ª£t.
toBoﬁ
 || !
sio
.
sour˚_ª£t_n


160 
sök_vÆid
.
io
.
ö
 :
åue
.
B


161 
sio
.
ridx_vÆid
 :
sök_vÆid
.
io
.
out


162 
sour˚_exãnd
.
io
.
ö
 :
sio
.
widx_vÆid


163 
sour˚_vÆid
.
io
.
ö
 :
sour˚_exãnd
.io.
out


164 
sour˚_ªady
 :
sour˚_vÆid
.
io
.
out


165 
sio
.
sök_ª£t_n
 :!
ª£t
.
toBoﬁ


167 
vÆ
 
ª£t_™d_exãnd
 = !
sour˚_ªady
 || !
sio
.
sour˚_ª£t_n
 || 
ª£t
.
toBoﬁ


168 
vÆ
 
ª£t_™d_exãnd_¥ev
 = 
	`RegNext
(
ª£t_™d_exãnd
, 
åue
.
B
)

169 
vÆ
 
ª£t_ri£
 = !
ª£t_™d_exãnd_¥ev
 && 
ª£t_™d_exãnd


170 
vÆ
 
¥ev_idx_m©ch
 = 
	`AsyncRe£tReg
(
upd©eD©a
=(
io
.
async
.
widx
===io.async.
ridx
), 
ª£tD©a
=0)

176 
	}
}

178 
obje˘
 
	gFromAsyncBundÀ


181 
def
 
	g≠∂y
[
T
 <: 
D©a
](
x
: 
AsyncBundÀ
[T]): 
Decou∂edIO
[T] = 
≠∂y
(x, x.
∑øms
.
sync
)

182 
def
 
	g≠∂y
[
T
 <: 
D©a
](
x
: 
AsyncBundÀ
[T], 
	gsync
: 
I¡
): 
Decou∂edIO
[T] = {

183 
vÆ
 
sök
 = 
ModuÀ
(
√w
 
AsyncQueueSök
(
chi£lTy≥Of
(
x
.
mem
(0)), x.
∑øms
.
c›y
(
sync
 = sync)))

184 
sök
.
io
.
async
 <> 
x


185 
sök
.
io
.
deq


189 
obje˘
 
	gToAsyncBundÀ


191 
def
 
	g≠∂y
[
T
 <: 
D©a
](
x
: 
RódyVÆidIO
[T], 
	g∑øms
: 
AsyncQueueP¨ams
 = AsyncQueueP¨ams()): 
AsyncBundÀ
[T] = {

192 
vÆ
 
sour˚
 = 
ModuÀ
(
√w
 
AsyncQueueSour˚
(
chi£lTy≥Of
(
x
.
bôs
), 
∑øms
))

193 
	gsour˚
.
	gio
.
	gíq
 <> 
x


194 
	gsour˚
.
	gio
.
	gasync


198 
˛ass
 
	gAsyncQueue
[
T
 <: 
D©a
](
gí
: T, 
	g∑øms
: 
AsyncQueueP¨ams
 = 
	$AsyncQueueP¨ams
()Ë
exãnds
 
Crossög
[
T
] {

199 
vÆ
 
io
 = 
	`IO
(
√w
 
	`CrossögIO
(
gí
))

200 
vÆ
 
sour˚
 = 
	`ModuÀ
(
√w
 
	`AsyncQueueSour˚
(
gí
, 
∑øms
))

201 
vÆ
 
sök
 = 
	`ModuÀ
(
√w
 
	`AsyncQueueSök
 (
gí
, 
∑øms
))

203 
sour˚
.
˛ock
 :
io
.
íq_˛ock


204 
sour˚
.
ª£t
 :
io
.
íq_ª£t


205 
sök
.
˛ock
 :
io
.
deq_˛ock


206 
sök
.
ª£t
 :
io
.
deq_ª£t


208 
sour˚
.
io
.
íq
 <> io.enq

209 
io
.
deq
 <> 
sök
.io.deq

210 
sök
.
io
.
async
 <> 
sour˚
.io.async

211 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncResetReg.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
HasBœckBoxResour˚


7 
imp‹t
 
	gchi£l3
.
	gc‹e
.
I¡P¨am


35 
˛ass
 
	$AsyncRe£tReg
(
ª£tVÆue
: 
I¡
 = 0)

36 
exãnds
 
	`BœckBox
(
	`M≠
("RESET_VALUE" -> 
	$I¡P¨am
(
ª£tVÆue
))Ë
wôh
 
HasBœckBoxResour˚


38 
vÆ
 
io
 = 
√w
 
BundÀ
 {

39 
vÆ
 
d
 = 
	`Boﬁ
(
INPUT
)

40 
vÆ
 
q
 = 
	`Boﬁ
(
OUTPUT
)

41 
vÆ
 
í
 = 
	`Boﬁ
(
INPUT
)

43 
vÆ
 
˛k
 = 
	`Clock
(
INPUT
)

44 
vÆ
 
r°
 = 
	`Boﬁ
(
INPUT
)

47 
	`£tResour˚
("/vsrc/AsyncResetReg.v")

48 
	}
}

50 ˛as†
	cSim∂eRegIO
(
vÆ
 
w
: 
I¡
Ë
exãnds
 
BundÀ
{

51 
vÆ
 
d
 = 
	$UI¡
(
INPUT
, 
width
 = 
w
)

52 
vÆ
 
q
 = 
	$UI¡
(
OUTPUT
, 
width
 = 
w
)

53 
vÆ
 
í
 = 
	`Boﬁ
(
INPUT
)

56 
˛ass
 
	$AsyncRe£tRegVec
(
vÆ
 
w
: 
I¡
, vÆ 
öô
: 
BigI¡
Ë
exãnds
 
ModuÀ
 {

57 
vÆ
 
io
 = 
√w
 
	`Sim∂eRegIO
(
w
)

59 
vÆ
 
async_ªgs
 = 
Li°
.
	`èbuœã
(
w
Ë{ 
idx
 =>

60 
vÆ
 
⁄
 = i‡(
öô
.
	`ã°Bô
(
idx
)) 1 0

61 
	`ModuÀ
(
√w
 
	`AsyncRe£tReg
(
⁄
))

64 
vÆ
 
q
 = (
ªg
, 
idx
Ë<- 
async_ªgs
.
zùWôhIndex
Ë
yõld
 {

65 
ªg
.
io
.
˛k
 :
˛ock


66 
ªg
.
io
.
r°
 :
ª£t


67 
ªg
.
io
.
d
 :io.
	`d
(
idx
)

68 
ªg
.
io
.
í
 := io.en

69 
ªg
.
	`sugge°Name
(
s
"reg_$idx")

70 
ªg
.
io
.
q


73 
io
.
q
 :q.
asUI¡


75 
ovîride
 
def
 
desúedName
 = 
s
"AsyncResetRegVec_w${w}_i${init}"

77 
	}
}

79 
obje˘
 
AsyncRe£tReg
 {

81 
def
 
≠∂y
(
d
: 
Boﬁ
, 
˛k
: 
Clock
, 
r°
: Boﬁ, 
öô
: 
Boﬁón
, 
«me
: 
O±i⁄
[
Såög
]): Bool = {

82 
vÆ
 
ªg
 = 
ModuÀ
(
√w
 
AsyncRe£tReg
(i‡(
öô
) 1 0))

83 
ªg
.
io
.
d
 := d

84 
ªg
.
io
.
˛k
 := clk

85 
ªg
.
io
.
r°
 :=Ñst

86 
ªg
.
io
.
í
 :
Boﬁ
(
åue
)

87 
«me
.
f‹óch
(
ªg
.
sugge°Name
(
_
))

88 
ªg
.
io
.
q


91 
def
 
≠∂y
(
d
: 
Boﬁ
, 
˛k
: 
Clock
, 
r°
: Boﬁ): Boﬁ =áµly(d, clk,Ñ°, 
Ál£
, 
N⁄e
)

92 
def
 
≠∂y
(
d
: 
Boﬁ
, 
˛k
: 
Clock
, 
r°
: Boﬁ, 
«me
: 
Såög
): Boﬁ =áµly(d, clk,Ñ°, 
Ál£
, 
Some
(name))

95 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
, 
ª£tD©a
: 
BigI¡
, 
íabÀ
: 
Boﬁ
, 
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): UInt = {

96 
vÆ
 
w
 = 
upd©eD©a
.
gëWidth
 
max
 
ª£tD©a
.
bôLígth


97 
vÆ
 
ªg
 = 
ModuÀ
(
√w
 
AsyncRe£tRegVec
(
w
, 
ª£tD©a
))

98 
	g«me
.
f‹óch
(
ªg
.
sugge°Name
(
_
))

99 
	gªg
.
	gio
.
	gd
 :
upd©eD©a


100 
ªg
.
io
.
í
 :
íabÀ


101 
ªg
.
io
.
q


103 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
, 
ª£tD©a
: 
BigI¡
, 
íabÀ
: 
Boﬁ
, 
«me
: 
Såög
): UInt =ápply(updateData,

104 
ª£tD©a
, 
íabÀ
, 
Some
(
«me
))

107 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
, 
ª£tD©a
: 
BigI¡
): UI¡ =áµly(upd©eD©a,Ñe£tD©a, 
íabÀ
=
Boﬁ
(
åue
))

108 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
, 
ª£tD©a
: 
BigI¡
, 
«me
: 
Såög
): UI¡ =áµly(upd©eD©a,Ñe£tD©a, 
íabÀ
=
Boﬁ
(
åue
), 
Some
(name))

110 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
, 
íabÀ
: 
Boﬁ
): UI¡ =áµly(upd©eD©a, 
ª£tD©a
=
BigI¡
(0),Énable)

111 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
, 
íabÀ
: 
Boﬁ
, 
«me
: 
Såög
): UI¡ =áµly(upd©eD©a, 
ª£tD©a
=
BigI¡
(0),É«bÀ, 
Some
(name))

113 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
): UI¡ =áµly(upd©eD©a, 
ª£tD©a
=
BigI¡
(0), 
íabÀ
=
Boﬁ
(
åue
))

114 
def
 
≠∂y
(
upd©eD©a
: 
UI¡
, 
«me
:
Såög
): UI¡ =áµly(upd©eD©a, 
ª£tD©a
=
BigI¡
(0), 
íabÀ
=
Boﬁ
(
åue
), 
Some
(name))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Broadcaster.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


11 
˛ass
 
	gBrﬂdˇ°î
[
T
 <: 
D©a
](
typ
: T, 
	gn
: 
I¡
Ë
exãnds
 
ModuÀ
 {

12 
vÆ
 
io
 = 
√w
 
BundÀ
 {

13 
vÆ
 
ö
 = 
Decou∂ed
(
typ
).
Êù


14 
vÆ
 
out
 = 
Vec
(
n
, 
Decou∂ed
(
typ
))

17 
ªquúe
 (
n
 > 0)

19 i‡(
	gn
 == 1) {

20 
io
.
out
.
hód
 <> io.
ö


22 
vÆ
 
idx
 = 
Reg
(
öô
 = 
UI¡
(0, 
log2Up
(
n
)))

23 
vÆ
 
	gßve
 = 
Reg
(
typ
)

25 
io
.
out
.
hód
.
vÆid
 :
idx
 ==
UI¡
(0Ë&& io.
ö
.valid

26 
io
.
out
.
hód
.
bôs
 :io.
ö
.bits

27 
i
 <- 1 
u¡û
 
n
) {

28 
io
.
out
(
i
).
vÆid
 :
idx
 ==
UI¡
(i)

29 
io
.
out
(
i
).
bôs
 :
ßve


31 
io
.
ö
.
ªady
 :io.
out
.
hód
.ªady && 
idx
 ==
UI¡
(0)

33 
whí
 (
io
.
ö
.
fúe
()Ë{ 
ßve
 :io.ö.
bôs
 }

35 
whí
 (
io
.
out
(
idx
).
fúe
()) {

36 
whí
 (
idx
 ==
UI¡
(
n
 - 1)) { idx := UInt(0) }

37 .
Ÿhîwi£
 { 
idx
 :idx + 
UI¡
(1) }

42 
obje˘
 
Brﬂdˇ°î
 {

43 
def
 
≠∂y
[
T
 <: 
D©a
](
ö
: 
Decou∂edIO
[T], 
	gn
: 
I¡
): 
Vec
[DecoupledIO[T]] = {

44 
vÆ
 
•lô
 = 
ModuÀ
(
√w
 
Brﬂdˇ°î
(
ö
.
bôs
, 
n
))

45 
	g•lô
.
	gio
.
	gö
 <> 
ö


46 
	g•lô
.
	gio
.
	gout


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/BundleMonitorKey.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


7 
imp‹t
 
	gChi£l
.
_


12 
obje˘
 
BundÀM⁄ô‹Key
 
exãnds
 
	gFõld
[
O±i⁄
[(
Såög
, 
BundÀ
Ë=> 
Unô
]] (
N⁄e
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/CRC.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


7 
obje˘
 
	gCRC


13 
def
 
≠∂y
(
divis‹
: 
BigI¡
, 
c€fficõ¡
: 
UI¡
, 
width
: 
I¡egî
): UInt = {

14 
ªquúe
 (
divis‹
 > 0 && divis‹.
ã°Bô
(0))

15 
ªquúe
 (
width
 > 0)

16 
as£π
 (
c€fficõ¡
 >> 
width
 ==
UI¡
(0))

17 
vÆ
 
n
 = 
log2Flo‹
(
divis‹
)

18 
vÆ
 
m
 = 
width


19 i‡(
m
 <
n
Ë 
c€fficõ¡


22 
vÆ
 
¨øy
 = 
Aºay
.
èbuœã
(
m
Ë{ 
BigI¡
(1Ë<< 
_
 }

25 
i
 <- (
n
 
u¡û
 
m
).
ªvî£


26 
j
 <- 0 
to
 
n


27 
divis‹
.
ã°Bô
(
j
)

28 } 
¨øy
(
i
-(
n
-
j
)) ^=árray(i)

30 
C©
(
Seq
.
èbuœã
(
n
Ë{ 
i
 => (
UI¡
(
¨øy
(i)Ë& 
c€fficõ¡
).
x‹R
 } .
ªvî£
)

34 
vÆ
 
CRC_16F_4_2
 = 
BigI¡
(0x1a2eb)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockDivider.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
HasBœckBoxResour˚


7 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
wôhClock


18 ˛as†
	cClockDividî2
 
exãnds
 
BœckBox
 
wôh
 
	mHasBœckBoxResour˚
 {

19 
vÆ
 
	mio
 = 
√w
 
BundÀ
 {

20 
vÆ
 
˛k_out
 = 
Clock
(
OUTPUT
)

21 
vÆ
 
˛k_ö
 = 
Clock
(
INPUT
)

24 
£tResour˚
("/vsrc/ClockDivider2.v")

26 ˛as†
	cClockDividî3
 
exãnds
 
BœckBox
 
wôh
 
	mHasBœckBoxResour˚
 {

27 
vÆ
 
	mio
 = 
√w
 
BundÀ
 {

28 
vÆ
 
˛k_out
 = 
Clock
(
OUTPUT
)

29 
vÆ
 
˛k_ö
 = 
Clock
(
INPUT
)

32 
£tResour˚
("/vsrc/ClockDivider3.v")

37 ˛as†
	cPow2ClockDividî
(
pow2
: 
I¡
Ë
exãnds
 
ModuÀ
 {

38 
vÆ
 
io
 = 
√w
 
BundÀ
 {

39 
vÆ
 
˛ock_out
 = 
	`Clock
(
OUTPUT
)

42 i‡(
pow2
 == 0) {

43 
io
.
˛ock_out
 :
˛ock


44 
	}
} {

45 
vÆ
 
dividîs
 = 
Seq
.
fûl
(
pow2
Ë{ 
ModuÀ
(
√w
 
ClockDividî2
) }

47 
dividîs
.
öô
.
zù
(dividîs.
èû
).
m≠
 { (
œ°
, 
√xt
) =>

48 
√xt
.
io
.
˛k_ö
 :
œ°
.io.
˛k_out


51 
dividîs
.
hód
.
io
.
˛k_ö
 :
˛ock


52 
io
.
˛ock_out
 :
dividîs
.
œ°
.io.
˛k_out


56 
obje˘
 
Pow2ClockDividî
 {

57 
def
 
≠∂y
(
pow2
: 
I¡
): 
Clock
 = 
ModuÀ
(
√w
 
Pow2ClockDividî
’ow2)).
io
.
˛ock_out


58 
def
 
≠∂y
(
˛ock_ö
: 
Clock
, 
pow2
: 
I¡
): Clock = 
wôhClock
(clock_in) {ápply(pow2) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockGate.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.{
	gFõld
, 
	gP¨amëîs
}

8 
obje˘
 
ClockG©eIm∂
 
exãnds
 
	gFõld
[(Ë=> 
ClockG©e
]((Ë=> 
√w
 
EICG_wøµî
)

10 
ab°ø˘
 cœs†
	cClockG©e
 
exãnds
 
BœckBox
 {

11 
vÆ
 
io
 = 
IO
(
√w
 
BundÀ
{

12 
vÆ
 
ö
 = 
I≈ut
(
Clock
())

13 
vÆ
 
í
 = 
I≈ut
(
Boﬁ
())

14 
vÆ
 
out
 = 
Ouçut
(
Clock
())

18 
obje˘
 
	gClockG©e
 {

19 
def
 
	g≠∂y
[
T
 <: 
ClockG©e
](

20 
ö
: 
Clock
,

21 
	gí
: 
Boﬁ
,

22 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
)(
im∂icô
 
p
: 
P¨amëîs
): 
Clock
 = {

23 
vÆ
 
cg
 = 
ModuÀ
(
p
(
ClockG©eIm∂
)())

24 
«me
.
f‹óch
(
cg
.
sugge°Name
(
_
))

25 
cg
.
io
.
ö
 := in

26 
cg
.
io
.
í
 :=Én

27 
cg
.
io
.
out


30 
def
 
≠∂y
[
T
 <: 
ClockG©e
](

31 
ö
: 
Clock
,

32 
	gí
: 
Boﬁ
,

33 
	g«me
: 
Såög
)(
im∂icô
 
p
: 
P¨amëîs
): 
Clock
 =

34 
≠∂y
(
ö
, 
í
, 
Some
(
«me
))

38 
˛ass
 
EICG_wøµî
 
exãnds
 
	gClockG©e


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Counters.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	gsˇœ
.
	gm©h
.
max


10 ˛as†
	cZCou¡î
(
vÆ
 
n
: 
I¡
) {

11 
vÆ
 
vÆue
 = 
	`Reg
(
öô
=
	`UI¡
(0, 
	$log2Ceû
(
n
)))

12 
def
 
	$öc
(): 
Boﬁ
 = {

13 i‡(
n
 =1Ë
	`Boﬁ
(
åue
)

15 
vÆ
 
wøp
 = 
vÆue
 ==
	`UI¡
(
n
-1)

16 
vÆue
 :
	`Mux
(
	`Boﬁ
(!
	`isPow2
(
n
)Ë&& 
wøp
, 
	`UI¡
(0), value + UInt(1))

17 
wøp


20 
	}
}

22 
obje˘
 
	gZCou¡î
 {

23 
def
 
≠∂y
(
n
: 
I¡
Ë
√w
 
ZCou¡î
(n)

24 
def
 
≠∂y
(
c⁄d
: 
Boﬁ
, 
n
: 
I¡
): (
UI¡
, 
	gBoﬁ
) = {

25 
vÆ
 
c
 = 
√w
 
ZCou¡î
(
n
)

26 
v¨
 
wøp
: 
Boﬁ
 = 
nuŒ


27 
whí
 (
c⁄d
Ë{ 
wøp
 = 
c
.
öc
() }

28 (
c
.
vÆue
, 
	gc⁄d
 && 
	gwøp
)

32 
obje˘
 
	gTwoWayCou¡î
 {

33 
def
 
≠∂y
(
up
: 
Boﬁ
, 
down
: Boﬁ, 
max
: 
I¡
): 
UI¡
 = {

34 
vÆ
 
˙t
 = 
Reg
(
öô
 = 
UI¡
(0, 
log2Up
(
max
+1)))

35 
whí
 (
up
 && !
down
Ë{ 
	g˙t
 :
˙t
 + 
UI¡
(1) }

36 
whí
 (
down
 && !
up
Ë{ 
˙t
 :˙à- 
UI¡
(1) }

37 
˙t


42 
˛ass
 
WideCou¡î
(
width
: 
I¡
, 
öc
: 
UI¡
 = UI¡(1), 
ª£t
: 
Boﬁón
 = 
åue
)

44 
¥iv©e
 
vÆ
 
isWide
 = 
width
 > 2*
öc
.
gëWidth


45 
¥iv©e
 
vÆ
 
smÆlWidth
 = i‡(
isWide
Ë
öc
.
gëWidth
 
max
 
log2Up
(
width
) width

46 
¥iv©e
 
vÆ
 
smÆl
 = i‡(
ª£t
Ë
Reg
(
öô
=
UI¡
(0, 
smÆlWidth
)ËReg(UI¡(
width
 = smallWidth))

47 
¥iv©e
 
vÆ
 
√xtSmÆl
 = 
smÆl
 +& 
öc


48 
smÆl
 :
√xtSmÆl


50 
¥iv©e
 
vÆ
 
œrge
 = i‡(
isWide
) {

51 
vÆ
 
r
 = i‡(
ª£t
Ë
Reg
(
öô
=
UI¡
(0, 
width
 - 
smÆlWidth
)) Reg(UInt(width = width - smallWidth))

52 
whí
 (
√xtSmÆl
(
smÆlWidth
)Ë{ 
r
 :∏+ 
UI¡
(1) }

53 
r


54 } 
nuŒ


56 
vÆ
 
vÆue
 = i‡(
isWide
Ë
C©
(
œrge
, 
smÆl
) small

57 
œzy
 
vÆ
 
	gˇºyOut
 = {

58 
vÆ
 
lo
 = (
smÆl
 ^ 
√xtSmÆl
) >> 1

59 i‡(!
isWide
Ë
lo
 {

60 
vÆ
 
hi
 = 
Mux
(
√xtSmÆl
(
smÆlWidth
), 
œrge
 ^ (œrgê+& 
UI¡
(1)), UInt(0)) >> 1

61 
C©
(
hi
, 
lo
)

65 
	gdef
 :(
x
: 
UI¡
) = {

66 
smÆl
 :
x


67 i‡(
isWide
Ë
œrge
 :
x
 >> 
smÆlWidth


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Crossing.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.{
	gDecou∂edIO
, 
	gDecou∂ed
, 
	gIºevoˇbÀ
, 
	gIºevoˇbÀIO
, 
	gRódyVÆidIO
}

8 
˛ass
 
	gCrossögIO
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ
 {

10 
vÆ
 
íq_˛ock
 = 
Clock
(
INPUT
)

11 
vÆ
 
íq_ª£t
 = 
Boﬁ
(
INPUT
)

12 
vÆ
 
íq
 = 
Decou∂ed
(
gí
).
Êù


14 
vÆ
 
deq_˛ock
 = 
Clock
(
INPUT
)

15 
vÆ
 
deq_ª£t
 = 
Boﬁ
(
INPUT
)

16 
vÆ
 
deq
 = 
Decou∂ed
(
gí
)

19 
ab°ø˘
 
˛ass
 
Crossög
[
T
 <: 
D©a
] 
exãnds
 
ModuÀ
 {

20 
vÆ
 
io
: 
CrossögIO
[
T
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/DescribedSRAM.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
In°™˚Id


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
A¬Ÿ©ed


8 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
Dùlom©icSRAM


9 
imp‹t
 
	gChi£l
.
_


10 
imp‹t
 
	gchi£l3
.
SyncRódMem


11 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gamba
.
	gaxi4
.
AXI4RAM


13 
imp‹t
 
	gsˇœ
.
	gm©h
.
log10


15 
obje˘
 
	gDes¸ibedSRAM
 {

16 
def
 
	g≠∂y
[
T
 <: 
D©a
](

17 
«me
: 
Såög
,

18 
	gdesc
: 
Såög
,

19 
	gsize
: 
I¡
,

20 
	gd©a
: 
T


21 ): 
SyncRódMem
[
T
] = {

23 
vÆ
 
mem
 = 
SeqMem
(
size
, 
d©a
)

25 
	gmem
.
sugge°Name
(
«me
)

27 
vÆ
 
	ggønWidth
 = 
d©a
 
m©ch
 {

28 
v
: 
Vec
[
_
] => v.
hód
.
gëWidth


29 
d
 => d.
gëWidth


32 
A¬Ÿ©ed
.
§ams
(

33 
comp⁄ít
 = 
mem
,

34 
«me
 =Çame,

35 
addªss_width
 = 
log2Ceû
(
size
),

36 
d©a_width
 = 
d©a
.
gëWidth
,

37 
dïth
 = 
size
,

38 
des¸ùti⁄
 = 
desc
,

39 
wrôe_mask_gønuœrôy
 = 
gønWidth
)

41 
mem


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ECC.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


7 
ab°ø˘
 cœs†
	cDecodög


9 
def
 
	munc‹ª˘ed
: 
UI¡


10 
def
 
c‹ª˘ed
: 
UI¡


11 
def
 
c‹ª˘abÀ
: 
Boﬁ


12 
def
 
unc‹ª˘abÀ
: 
Boﬁ


13 
def
 
îr‹
 = 
c‹ª˘abÀ
 || 
unc‹ª˘abÀ


16 
ab°ø˘
 cœs†
	cCode


18 
def
 
ˇnDëe˘
: 
Boﬁón


19 
def
 
ˇnC‹ª˘
: 
Boﬁón


21 
def
 
	$width
(
w0
: 
I¡
): Int

27 
def
 
	`ícode
(
x
: 
UI¡
, 
pois⁄
: 
Boﬁ
 = 
	$Boﬁ
(
Ál£
)): 
UI¡


28 
def
 
	$decode
(
x
: 
UI¡
): 
Decodög


35 
def
 
	$swizzÀ
(
x
: 
UI¡
): UInt

38 ˛as†
	cIdítôyCode
 
exãnds
 
Code


40 
def
 
ˇnDëe˘
 = 
Ál£


41 
def
 
ˇnC‹ª˘
 = 
Ál£


43 
def
 
	`width
(
w0
: 
I¡
) = w0

44 
def
 
	`ícode
(
x
: 
UI¡
, 
pois⁄
: 
Boﬁ
 = 
	`Boﬁ
(
Ál£
)) = {

45 
	`ªquúe
 (
pois⁄
.
isLô
 &&Öois⁄.
lôVÆue
 == 0, "IdentityCode canÇot beÖoisoned")

46 
x


48 
def
 
	`swizzÀ
(
x
: 
UI¡
) = x

49 
def
 
	`decode
(
y
: 
UI¡
Ë
√w
 
Decodög
 {

50 
def
 
unc‹ª˘ed
 = 
y


51 
def
 
c‹ª˘ed
 = 
y


52 
def
 
c‹ª˘abÀ
 = 
	`Boﬁ
(
Ál£
)

53 
def
 
unc‹ª˘abÀ
 = 
	`Boﬁ
(
Ál£
)

54 
	}
}

57 ˛as†
	cP¨ôyCode
 
exãnds
 
Code


59 
def
 
ˇnDëe˘
 = 
åue


60 
def
 
ˇnC‹ª˘
 = 
Ál£


62 
def
 
width
(
w0
: 
I¡
) = w0+1

63 
def
 
ícode
(
x
: 
UI¡
, 
pois⁄
: 
Boﬁ
 = Boﬁ(
Ál£
)Ë
C©
(x.
x‹R
 ^Öoison, x)

64 
def
 
swizzÀ
(
x
: 
UI¡
Ë
	$C©
(
Ál£
.
B
, 
x
)

65 
def
 
	`decode
(
y
: 
UI¡
Ë
√w
 
Decodög
 {

66 
vÆ
 
unc‹ª˘ed
 = 
	`y
(
y
.
gëWidth
-2,0)

67 
vÆ
 
c‹ª˘ed
 = 
unc‹ª˘ed


68 
vÆ
 
c‹ª˘abÀ
 = 
	`Boﬁ
(
Ál£
)

69 
vÆ
 
unc‹ª˘abÀ
 = 
y
.
x‹R


71 
	}
}

73 ˛as†
	cSECCode
 
exãnds
 
	mCode


75 
def
 
	mˇnDëe˘
 = 
åue


76 
def
 
ˇnC‹ª˘
 = 
åue


80 
def
 
pois⁄ous
(
n
: 
I¡
Ë!
isPow2
(n+1)

82 
def
 
width
(
k
: 
I¡
) = {

83 
vÆ
 
m
 = 
log2Flo‹
(
k
) + 1

84 
k
 + 
m
 + (if((1 << m) < m+k+1) 1 0)

86 
def
 
swizzÀ
(
x
: 
UI¡
) = {

87 
vÆ
 
k
 = 
x
.
gëWidth


88 
vÆ
 
n
 = 
width
(
k
)

89 
C©
(
UI¡
(0, 
width
=
n
-
k
), 
x
)

100 
¥iv©e
 
def
 
im∂
(
n
: 
I¡
, 
k
: Int) = {

101 
ªquúe
 (
n
 >3 && 
k
 >1 && !
isPow2
(n))

102 
vÆ
 
hamm2sys
 = 
IndexedSeq
.
èbuœã
(
n
+1Ë{ 
i
 =>

103 i‡(
i
 == 0) {

104 
n


105 } i‡(
isPow2
(
i
)) {

106 
k
 + 
log2Ceû
(
i
)

108 
i
 - 1 - 
log2Ceû
(i)

111 
vÆ
 
sys2hamm
 = 
hamm2sys
.
zùWôhIndex
.
s‹tBy
(
_
.
_1
).
m≠
(_.
_2
).
toIndexedSeq


112 
def
 
syndrome
(
j
: 
I¡
) = {

113 
vÆ
 
bô
 = 1 << 
j


114 
UI¡
("b" + 
Seq
.
èbuœã
(
n
Ë{ 
i
 =>

115 i‡((
sys2hamm
(
i
Ë& 
bô
) != 0) "1" "0"

116 }.
ªvî£
.
mkSåög
)

118 (
hamm2sys
, 
	gsys2hamm
, 
syndrome
 
	g_
)

121 
def
 
ícode
(
x
: 
UI¡
, 
pois⁄
: 
Boﬁ
 = Boﬁ(
Ál£
)) = {

122 
vÆ
 
k
 = 
x
.
gëWidth


123 
vÆ
 
n
 = 
width
(
k
)

124 
vÆ
 (
_
, _, 
syndrome
Ë
im∂
(
n
, 
k
)

126 
ªquúe
 ((
pois⁄
.
isLô
 &&Öois⁄.
lôVÆue
 =0Ë|| 
pois⁄ous
(
n
), 
s
"SEC code ofÜength ${n} cannot beÖoisoned")

129 
vÆ
 
	gsyndromeUI¡
 = 
Vec
.
èbuœã
(
n
-
k
Ë{ 
j
 => (
syndrome
(j)(k-1, 0Ë& 
	gx
).
	gx‹R
 ^ 
	gpois⁄
 }.
asUI¡


130 
C©
(
syndromeUI¡
, 
x
)

133 
def
 
decode
(
y
: 
UI¡
Ë
√w
 
Decodög
 {

134 
vÆ
 
n
 = 
y
.
gëWidth


135 
vÆ
 
k
 = 
n
 - 
log2Ceû
(n)

136 
vÆ
 (
_
, 
sys2hamm
, 
syndrome
Ë
im∂
(
n
, 
k
)

138 
vÆ
 
	gsyndromeUI¡
 = 
Vec
.
èbuœã
(
n
-
k
Ë{ 
j
 => (
syndrome
(jË& 
y
).
x‹R
 }.
asUI¡


140 
vÆ
 
	ghammBadBôOH
 = 
UI¡ToOH
(
syndromeUI¡
, 
n
+1)

141 
vÆ
 
	gsysBadBôOH
 = 
Vec
.
èbuœã
(
k
Ë{ 
i
 => 
hammBadBôOH
(
sys2hamm
(i)Ë}.
asUI¡


143 
vÆ
 
	gunc‹ª˘ed
 = 
y
(
k
-1, 0)

144 
vÆ
 
	gc‹ª˘ed
 = 
unc‹ª˘ed
 ^ 
sysBadBôOH


145 
vÆ
 
c‹ª˘abÀ
 = 
syndromeUI¡
.
‹R


146 
vÆ
 
unc‹ª˘abÀ
 = i‡(
pois⁄ous
(
n
)Ë{ 
syndromeUI¡
 > 
UI¡
“Ë} { 
Boﬁ
(
Ál£
) }

150 ˛as†
	cSECDEDCode
 
exãnds
 
	mCode


152 
def
 
	mˇnDëe˘
 = 
åue


153 
def
 
ˇnC‹ª˘
 = 
åue


155 
¥iv©e
 
vÆ
 
£c
 = 
√w
 
SECCode


156 
¥iv©e
 
vÆ
 
∑r
 = 
√w
 
P¨ôyCode


158 
def
 
width
(
k
: 
I¡
Ë
£c
.width(k)+1

159 
def
 
ícode
(
x
: 
UI¡
, 
pois⁄
: 
Boﬁ
 = Boﬁ(
Ál£
)) = {

165 
vÆ
 
toggÀ_lo
 = 
C©
(
pois⁄
.
asUI¡
,Öoison.asUInt)

166 
vÆ
 
	mtoggÀ_hi
 = 
toggÀ_lo
 << (
£c
.
width
(
x
.
gëWidth
)-1)

167 
∑r
.
ícode
(
£c
.ícode(
x
)Ë^ 
toggÀ_hi


169 
def
 
swizzÀ
(
x
: 
UI¡
Ë
∑r
.swizzÀ(
£c
.
	$swizzÀ
(
x
))

170 
def
 
	`decode
(
x
: 
UI¡
Ë
√w
 
Decodög
 {

171 
vÆ
 
£cdec
 = 
£c
.
	`decode
(
	`x
(
x
.
gëWidth
-2,0))

172 
vÆ
 
∑rdec
 = 
∑r
.
	`decode
(
x
)

174 
vÆ
 
unc‹ª˘ed
 = 
£cdec
.uncorrected

175 
vÆ
 
c‹ª˘ed
 = 
£cdec
.corrected

176 
vÆ
 
c‹ª˘abÀ
 = 
∑rdec
.
unc‹ª˘abÀ


177 
vÆ
 
unc‹ª˘abÀ
 = !
∑rdec
.unc‹ª˘abÀ && 
£cdec
.
c‹ª˘abÀ


178 
	}
}

181 
obje˘
 
	gEºGí


184 
def
 
≠∂y
(
width
: 
I¡
, 
f
: I¡): 
UI¡
 = {

185 
ªquúe
(
width
 > 0 && 
f
 >0 && 
log2Up
(width) + f <= 16)

186 
UI¡ToOH
(
LFSR16
()(
log2Up
(
width
)+
f
-1,0))(
	gwidth
-1,0)

188 
def
 
≠∂y
(
x
: 
UI¡
, 
f
: 
I¡
): UI¡ = x ^áµly(x.
gëWidth
, f)

191 
åaô
 
C™HaveEº‹s
 
exãnds
 
	gBundÀ
 {

192 
vÆ
 
	gc‹ª˘abÀ
: 
O±i⁄
[
VÆidIO
[
UI¡
]]

193 
vÆ
 
unc‹ª˘abÀ
: 
O±i⁄
[
VÆidIO
[
UI¡
]]

196 
obje˘
 
Code
 {

197 
def
 
‰omSåög
(
s
: 
O±i⁄
[
Såög
]): 
Code
 = fromSåög(s.
gëOrEl£
("none"))

198 
def
 
‰omSåög
(
s
: 
Såög
): 
Code
 = s.
toLowîCa£
 
m©ch
 {

199 "n⁄e" => 
√w
 
IdítôyCode


200 "idítôy" => 
√w
 
IdítôyCode


201 "∑rôy" => 
√w
 
P¨ôyCode


202 "£c" => 
√w
 
SECCode


203 "£cded" => 
√w
 
SECDEDCode


204 
_
 => 
throw
 
√w
 
IŒegÆArgumítEx˚±i⁄
("Unknown ECCÅype")

209 
imp‹t
 
‰ìchùs
.
rockëchù
.
unôã°
.
_


211 
˛ass
 
	$ECCTe°
(
k
: 
I¡
, 
timeout
: I¡ = 500000Ë
exãnds
 
	$UnôTe°
(
timeout
) {

212 
vÆ
 
code
 = 
√w
 
SECDEDCode


213 
vÆ
 
n
 = 
code
.
	`width
(
k
)

216 
vÆ
 
ã°
 = 
	`RegInô
(
	`UI¡
(0, 
width
=
n
+1))

217 
vÆ
 
œ°
 = 
	`ã°
(
n
)

218 
ã°
 :ã° + !
œ°


219 
io
.
föished
 :
	`RegNext
(
œ°
, 
	`Boﬁ
(
Ál£
))

222 
vÆ
 
decoded
 = 
code
.
	`decode
(
	`ã°
(
n
-1, 0))

223 
vÆ
 
ªcoded
 = 
code
.
	`ícode
(
decoded
.
c‹ª˘ed
)

224 
vÆ
 
di°™˚
 = 
	`P›Cou¡
(
ªcoded
 ^ 
ã°
)

227 
vÆ
 
c‹ª˘
 = 
	`RegInô
(
	`UI¡
(0, 
width
=
n
))

228 
vÆ
 
c‹ª˘abÀ
 = 
	`RegInô
(
	`UI¡
(0, 
width
=
n
))

229 
vÆ
 
unc‹ª˘abÀ
 = 
	`RegInô
(
	`UI¡
(0, 
width
=
n
))

231 
	`whí
 (!
œ°
) {

232 
	`whí
 (
decoded
.
unc‹ª˘abÀ
) {

233 
	`as£π
 (
di°™˚
 >
	`UI¡
(2))

234 
unc‹ª˘abÀ
 :unc‹ª˘abÀ + 
	`UI¡
(1)

235 } .
	`ñ£whí
 (
decoded
.
c‹ª˘abÀ
) {

236 
	`as£π
 (
	`di°™˚
(0))

237 
c‹ª˘abÀ
 :c‹ª˘abÀ + 
	`UI¡
(1)

238 } .
Ÿhîwi£
 {

239 
	`as£π
 (
di°™˚
 ==
	`UI¡
(0))

240 
	`as£π
 (
decoded
.
unc‹ª˘ed
 ==decoded.
c‹ª˘ed
)

241 
c‹ª˘
 :c‹ª˘ + 
	`UI¡
(1)

246 
vÆ
 
nCodes
 = 
	`BigI¡
(1Ë<< 
n


247 
vÆ
 
nC‹ª˘
 = 
	`BigI¡
(1Ë<< 
k


248 
vÆ
 
nC‹ª˘abÀ
 = 
nCodes
 / 2

249 
vÆ
 
nUnc‹ª˘abÀ
 = 
nCodes
 - 
nC‹ª˘abÀ
 - 
nC‹ª˘


251 
	`whí
 (
œ°
) {

252 
	`as£π
 (
c‹ª˘
 ==
	`UI¡
(
nC‹ª˘
))

253 
	`as£π
 (
c‹ª˘abÀ
 ==
	`UI¡
(
nC‹ª˘abÀ
))

254 
	`as£π
 (
unc‹ª˘abÀ
 ==
	`UI¡
(
nUnc‹ª˘abÀ
))

256 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Frequency.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


12 
obje˘
 
	gFªquícy
 {

13 
def
 
≠∂y
(
di°
 : 
Li°
[(
I¡
, 
Bôs
)]) : Bits = {

15 
ªquúe
(
di°
.
Àngth
 > 0)

18 
vÆ
 (
‰eqs
, 
vÆs
Ë
di°
.
unzù


19 
vÆ
 
tŸÆ
 = 
‰eqs
.
sum


20 
ªquúe
(
isPow2
(
tŸÆ
))

23 
vÆ
 (
fú°Fªq
, 
fú°VÆ
Ë
di°
.
hód


26 
vÆ
 
ªsu…
 = 
Wúe
(
Bôs
(
width
 = 
fú°VÆ
.
gëWidth
))

27 
ªsu…
 :
UI¡
(0)

30 
vÆ
 
øndVÆ
 = 
LCG
(
log2Up
(
tŸÆ
))

33 
v¨
 
cou¡
 = 
fú°Fªq


34 
v¨
 
£À˘
 = 
whí
 (
øndVÆ
 < 
UI¡
(
fú°Fªq
)Ë{ 
ªsu…
 :
fú°VÆ
 }

35 
p
 <- 
di°
.
dr›
(1)) {

36 
cou¡
 = cou¡ + 
p
.
_1


37 
£À˘
 = sñe˘.
ñ£whí
(
øndVÆ
 < 
UI¡
(
cou¡
)Ë{ 
ªsu…
 :
p
.
_2
 }

40  
ªsu…


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GeneratorUtils.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.
RawModuÀ


7 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gfúπl
.
Cúcuô


9 
imp‹t
 
	gjava
.
	gio
.{
	gFûe
, 
	gFûeWrôî
}

11 
imp‹t
 
	gfúπl
.
	g™nŸ©i⁄s
.
Js⁄PrŸocﬁ


12 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


13 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gdùlomacy
.
_


14 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gsy°em
.{
	gDeÁu…Te°Suôes
, 
	gTe°Gíî©i⁄
}

17 
˛ass
 
	$P¨£dI≈utNames
(

18 
èrgëDú
: 
Såög
,

19 
t›ModuÀProje˘
: 
Såög
,

20 
t›ModuÀCœss
: 
Såög
,

21 
c⁄figProje˘
: 
Såög
,

22 
c⁄figs
: 
Såög
) {

23 
vÆ
 
c⁄figCœs£s
: 
Seq
[
Såög
] = 
c⁄figs
.
	`•lô
('_')

24 
vÆ
 
fuŒC⁄figCœs£s
: 
Seq
[
Såög
] = 
c⁄figCœs£s
.
	`m≠
(
c⁄figProje˘
 + "." + 
_
)

25 
vÆ
 
fuŒT›ModuÀCœss
: 
Såög
 = 
t›ModuÀProje˘
 + "." + 
t›ModuÀCœss


26 
	}
}

31 
åaô
 
HasGíî©‹Utûôõs
 {

32 
def
 
gëC⁄fig
(
fuŒC⁄figCœssNames
: 
Seq
[
Såög
]): 
C⁄fig
 = {

33 
√w
 
C⁄fig
(
fuŒC⁄figCœssNames
.
fﬁdRight
(
P¨amëîs
.
em±y
Ë{ (
cuºítName
, 
c⁄fig
) =>

34 
vÆ
 
cuºítC⁄fig
 = 
åy
 {

35 
Cœss
.
f‹Name
(
cuºítName
).
√wIn°™˚
.
asIn°™˚Of
[
C⁄fig
]

36 } 
ˇtch
 {

37 
e
: 
java
.
œng
.
CœssNŸFoundEx˚±i⁄
 =>

38 
throwEx˚±i⁄
(
s
"""U«bÀÅÿfödÖ¨à"
$cuºítName
" from "
$fuŒC⁄figCœssNames
", did you mis•ñ»ô?""", 
e
)

40 
cuºítC⁄fig
 ++ 
c⁄fig


44 
def
 
gëP¨amëîs
(
«mes
: 
Seq
[
Såög
]): 
P¨amëîs
 = gëP¨amëîs(
gëC⁄fig
(names))

46 
def
 
gëP¨amëîs
(
c⁄fig
: 
C⁄fig
): 
P¨amëîs
 = c⁄fig.
toIn°™˚


48 
def
 
ñab‹©e
(
fuŒT›ModuÀCœssName
: 
Såög
, 
∑øms
: 
P¨amëîs
): 
Cúcuô
 = {

49 
vÆ
 
t›
 = () =>

50 
Cœss
.
f‹Name
(
fuŒT›ModuÀCœssName
)

51 .
gëC⁄°ru˘‹
(
˛assOf
[
P¨amëîs
])

52 .
√wIn°™˚
(
∑øms
Ë
m©ch
 {

53 
m
: 
RawModuÀ
 => m

54 
l
: 
LazyModuÀ
 => LazyModuÀ÷).
moduÀ


57 
Drivî
.
ñab‹©e
(
t›
)

60 
def
 
íumî©eROMs
(
cúcuô
: 
Cúcuô
): 
Såög
 = {

61 
vÆ
 
ªs
 = 
√w
 
SåögBuûdî


62 
vÆ
 
c⁄figs
 =

63 
cúcuô
.
comp⁄íts
 
Ê©M≠
 { 
m
 =>

64 
m
.
id
 
m©ch
 {

65 
rom
: 
BœckBoxedROM
 => 
Some
(‘om.
«me
, 
ROMGíî©‹
.
lookup
(rom)))

66 
	g_
 => 
N⁄e


69 
c⁄figs
 
	gf‹óch
 { (
	g«me
, 
	gc
) =>

70 
ªs
 
≠≥nd
 
s
"name ${name} depth ${c.depth} width ${c.width}\n"

72 
	gªs
.
	gtoSåög


77 
åaô
 
Gíî©‹Aµ
 
exãnds
 
Aµ
 
wôh
 
	gHasGíî©‹Utûôõs
 {

78 
œzy
 
vÆ
 
	g«mes
: 
P¨£dI≈utNames
 = {

79 
ªquúe
(
¨gs
.
size
 == 5, "Usage: sbt> " +

82 
P¨£dI≈utNames
(

83 
èrgëDú
 = 
¨gs
(0),

84 
t›ModuÀProje˘
 = 
¨gs
(1),

85 
t›ModuÀCœss
 = 
¨gs
(2),

86 
c⁄figProje˘
 = 
¨gs
(3),

87 
c⁄figs
 = 
¨gs
(4))

91 
œzy
 
vÆ
 
	gtd
: 
Såög
 = 
«mes
.
èrgëDú


92 
œzy
 
vÆ
 
c⁄fig
: 
C⁄fig
 = 
gëC⁄fig
(
«mes
.
fuŒC⁄figCœs£s
)

93 
œzy
 
vÆ
 
∑øms
: 
P¨amëîs
 = 
c⁄fig
.
toIn°™˚


94 
œzy
 
vÆ
 
cúcuô
: 
Cúcuô
 = 
ñab‹©e
(
«mes
.
fuŒT›ModuÀCœss
, 
∑øms
)

96 
vÆ
 
	gl⁄gName
: 
Såög


99 
def
 
gíî©eFúπl
 {

100 
Drivî
.
dumpFúπl
(
cúcuô
, 
Some
(
√w
 
Fûe
(
td
, 
s
"$longName.fir")))

103 
def
 
	ggíî©eA¬o
 {

104 
vÆ
 
	g™nŸ©i⁄Fûe
 = 
√w
 
Fûe
(
td
, 
s
"$longName.anno.json")

105 
vÆ
 
	gaf
 = 
√w
 
FûeWrôî
(
™nŸ©i⁄Fûe
)

106 
af
.
wrôe
(
Js⁄PrŸocﬁ
.
£rülize
(
cúcuô
.
™nŸ©i⁄s
.
m≠
(
_
.
toFúπl
)))

107 
af
.
˛o£
()

111 
def
 
	ggíî©eTe°SuôeMake‰ags
 {

112 
addTe°Suôes


113 
wrôeOuçutFûe
(
td
, 
s
"$l⁄gName.d", 
Te°Gíî©i⁄
.
gíî©eMake‰ag
)

116 
def
 
	gaddTe°Suôes
 {

117 
	gTe°Gíî©i⁄
.
addSuôe
(
DeÁu…Te°Suôes
.
groundã°64
("p"))

118 
	gTe°Gíî©i⁄
.
addSuôe
(
DeÁu…Te°Suôes
.
em±yBm¨ks
)

119 
	gTe°Gíî©i⁄
.
addSuôe
(
DeÁu…Te°Suôes
.
sögÀRegªssi⁄
)

122 
def
 
	ggíî©eROMs
 {

123 
wrôeOuçutFûe
(
td
, 
s
"$l⁄gName.rom.c⁄f", 
íumî©eROMs
(
cúcuô
))

127 
def
 
	ggíî©eAπeÁ˘s
 {

128 
	gEœb‹©i⁄AπeÁ˘s
.
	gfûes
.
	gf‹óch
 { (
	gexãnsi⁄
, 
	gc⁄ã¡s
) =>

129 
wrôeOuçutFûe
(
td
, 
s
"$l⁄gName.$exãnsi⁄", 
c⁄ã¡s
 ())

133 
def
 
wrôeOuçutFûe
(
èrgëDú
: 
Såög
, 
‚ame
: Såög, 
c⁄ã¡s
: Såög): 
Fûe
 = {

134 
vÆ
 
f
 = 
√w
 
Fûe
(
èrgëDú
, 
‚ame
)

135 
vÆ
 
	gfw
 = 
√w
 
FûeWrôî
(
f
)

136 
fw
.
wrôe
(
c⁄ã¡s
)

137 
fw
.
˛o£


138 
f


142 
obje˘
 
	gEœb‹©i⁄AπeÁ˘s
 {

143 
v¨
 
	gfûes
: 
Seq
[(
Såög
, (Ë=> Såög)] = 
Nû


145 
def
 
add
(
exãnsi⁄
: 
Såög
, 
c⁄ã¡s
: => String) {

146 
fûes
 = (
exãnsi⁄
, (Ë=> 
c⁄ã¡s
) +: files

149 
def
 
c⁄èös
(
exãnsi⁄
: 
Såög
): 
Boﬁón
 = {

150 
fûes
.
fﬁdLe·
(
Ál£
)((
t
, 
s
Ë=> {s.
_1
 =
exãnsi⁄
 |Å})

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GenericParameterizedBundle.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


7 
ab°ø˘
 
˛ass
 
	gGíîicP¨amëîizedBundÀ
[+
T
 <: 
Obje˘
](
vÆ
 
∑øms
: TË
exãnds
 
BundÀ


9 
ovîride
 
def
 
˛⁄eTy≥
 = {

10 
åy
 {

11 
this
.
gëCœss
.
gëC⁄°ru˘‹s
.
hód
.
√wIn°™˚
(
∑øms
).
asIn°™˚Of
[this.
ty≥
]

12 } 
ˇtch
 {

13 
e
: 
java
.
œng
.
IŒegÆArgumítEx˚±i⁄
 =>

14 
throw
 
√w
 
Ex˚±i⁄
("UnableÅo use GenericParameterizedBundle.cloneType on " +

15 
this
.
gëCœss
 + ",Örobably because " +Åhis.getClass +

17 "˛⁄eTy≥(Ë⁄ " + 
this
.
gëCœss
, 
e
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HellaQueue.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


7 
˛ass
 
	gHñœFlowQueue
[
T
 <: 
D©a
](
vÆ
 
íåõs
: 
I¡
)(
d©a
: => TË
exãnds
 
ModuÀ
 {

8 
vÆ
 
io
 = 
√w
 
QueueIO
(
d©a
, 
íåõs
)

9 
ªquúe
(
íåõs
 > 1)

11 
vÆ
 
	gdo_Êow
 = 
Wúe
(
Boﬁ
())

12 
vÆ
 
do_íq
 = 
io
.
íq
.
fúe
(Ë&& !
do_Êow


13 
vÆ
 
do_deq
 = 
io
.
deq
.
fúe
(Ë&& !
do_Êow


15 
vÆ
 
maybe_fuŒ
 = 
Reg
(
öô
=
Boﬁ
(
Ál£
))

16 
vÆ
 
íq_±r
 = 
Cou¡î
(
do_íq
, 
íåõs
).
_1


17 
vÆ
 (
deq_±r
, 
deq_d⁄e
Ë
Cou¡î
(
do_deq
, 
íåõs
)

18 
whí
 (
do_íq
 =/
do_deq
Ë{ 
maybe_fuŒ
 := do_enq }

20 
vÆ
 
±r_m©ch
 = 
íq_±r
 ==
deq_±r


21 
vÆ
 
em±y
 = 
±r_m©ch
 && !
maybe_fuŒ


22 
vÆ
 
fuŒ
 = 
±r_m©ch
 && 
maybe_fuŒ


23 
vÆ
 
©Ló°Two
 = 
fuŒ
 || 
íq_±r
 - 
deq_±r
 >
UI¡
(2)

24 
do_Êow
 :
em±y
 && 
io
.
deq
.
ªady


26 
vÆ
 
øm
 = 
SeqMem
(
íåõs
, 
d©a
)

27 
whí
 (
do_íq
Ë{ 
	gøm
.
wrôe
(
íq_±r
, 
io
.
íq
.
bôs
) }

29 
vÆ
 
	gªn
 = 
io
.
deq
.
ªady
 && (
©Ló°Two
 || !io.deq.
vÆid
 && !
em±y
)

30 
vÆ
 
øddr
 = 
Mux
(
io
.
deq
.
vÆid
, Mux(
deq_d⁄e
, 
UI¡
(0), 
deq_±r
 + UInt(1)), deq_ptr)

31 
vÆ
 
	gøm_out_vÆid
 = 
Reg
(
√xt
 = 
ªn
)

33 
io
.
deq
.
vÆid
 :
Mux
(
em±y
, io.
íq
.vÆid, 
øm_out_vÆid
)

34 
	gio
.
	gíq
.
	gªady
 :!
fuŒ


35 
io
.
deq
.
bôs
 :
Mux
(
em±y
, io.
íq
.bôs, 
øm
.
ªad
(
øddr
, 
ªn
))

38 
˛ass
 
	gHñœQueue
[
T
 <: 
D©a
](
vÆ
 
íåõs
: 
I¡
)(
d©a
: => TË
exãnds
 
ModuÀ
 {

39 
vÆ
 
io
 = 
√w
 
QueueIO
(
d©a
, 
íåõs
)

41 
vÆ
 
	gfq
 = 
ModuÀ
(
√w
 
HñœFlowQueue
(
íåõs
)(
d©a
))

42 
fq
.
io
.
íq
 <> io.enq

43 
io
.
deq
 <> 
Queue
(
fq
.io.deq, 1, 
pùe
 = 
åue
)

46 
obje˘
 
	gHñœQueue
 {

47 
def
 
	g≠∂y
[
T
 <: 
D©a
](
íq
: 
Decou∂edIO
[T], 
	gíåõs
: 
I¡
) = {

48 
vÆ
 
q
 = 
ModuÀ
((
√w
 
HñœQueue
(
íåõs
)Ë{ 
íq
.
bôs
 })

49 
q
.
io
.
íq
.
vÆid
 :=Énq.valid

50 
q
.
io
.
íq
.
bôs
 :=Énq.bits

51 
íq
.
ªady
 :
q
.
io
.enq.ready

52 
q
.
io
.
deq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HeterogeneousBag.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gc‹e
.
Rec‹d


7 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gimmuèbÀ
.
Li°M≠


9 
föÆ
 
˛ass
 
	gHëîogíeousBag
[
T
 <: 
D©a
](
ñts
: 
Seq
[T]Ë
exãnds
 
Rec‹d
 
wôh
 
cﬁÀ˘i⁄
.
IndexedSeq
[T] {

10 
def
 
≠∂y
(
x
: 
I¡
Ë
ñts
(x)

11 
def
 
Àngth
 = 
ñts
.length

13 
vÆ
 
ñemíts
 = 
Li°M≠
(
ñts
.
zùWôhIndex
.
m≠
 { (
n
,
i
Ë=> (i.
toSåög
,ÇË}:
_
*)

14 
ovîride
 
def
 
˛⁄eTy≥
: 
this
.
ty≥
 = (
√w
 
HëîogíeousBag
(
ñts
.
m≠
(
_
.
chi£lCl⁄eTy≥
))).
asIn°™˚Of
[this.type]

17 
ovîride
 
def
 
hashCode
: 
I¡
 = 
su≥r
[
Rec‹d
].hashCode

18 
ovîride
 
def
 
equÆs
(
th©
: 
Any
): 
Boﬁón
 = 
su≥r
[
Rec‹d
].equals(that)

21 
obje˘
 
HëîogíeousBag


23 
def
 
‰omNode
[
D
 <: 
D©a
, 
E
](
	gñts
: 
Seq
[(D, E)]Ë
√w
 
HëîogíeousBag
(
ñts
.
m≠
(
_
.
_1
.
˛⁄eTy≥
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IDPool.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gchi£l3
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
_


8 ˛as†
	cIDPoﬁ
(
numIds
: 
I¡
Ë
exãnds
 
ModuÀ
 {

9 
	`ªquúe
 (
numIds
 > 0)

10 
vÆ
 
idWidth
 = 
	$log2Up
(
numIds
)

12 
vÆ
 
io
 = 
	`IO
(
√w
 
BundÀ
 {

13 
vÆ
 
‰ì
 = 
	`Flù≥d
(
	`VÆid
(
	`UI¡
(
idWidth
.
W
)))

14 
vÆ
 
Æloc
 = 
	`IºevoˇbÀ
(
	`UI¡
(
idWidth
.
W
))

18 
vÆ
 
bôm≠
 = 
	`RegInô
(~0.U(
numIds
.
W
))

19 
vÆ
 
£À˘
 = 
	`RegInô
(0.U(
idWidth
.
W
))

20 
vÆ
 
vÆid
 = 
	$RegInô
(
åue
.
B
)

22 
io
.
Æloc
.
vÆid
 := valid

23 
io
.
Æloc
.
bôs
 :
£À˘


25 
vÆ
 
èkí
 = (
io
.
Æloc
.
ªady
 << io.Æloc.
bôs
)(
numIds
-1, 0)

26 
vÆ
 
giví
 = (
io
.
‰ì
 .
vÆid
 << io.‰ì .
bôs
)(
numIds
-1, 0)

27 
vÆ
 
bôm≠1
 = (
bôm≠
 & ~
èkí
Ë| 
giví


28 
vÆ
 
£À˘1
 = 
	`OHToUI¡
(~(
	`À·OR
(
bôm≠1
, 
numIds
) << 1) & bitmap1,ÇumIds)

29 
vÆ
 
vÆid1
 = 
bôm≠1
.
‹R


32 
	`whí
 (
io
.
Æloc
.
ªady
 || io.
‰ì
.
vÆid
) {

33 
bôm≠
 :
bôm≠1


34 
vÆid
 :
vÆid1


35 
	}
}

38 
whí
 (
io
.
Æloc
.
ªady
 || (!io.Æloc.
vÆid
 && io.
‰ì
.valid)) {

39 
£À˘
 :
£À˘1


43 
as£π
 (!
io
.
‰ì
.
vÆid
 || !(
bôm≠
 & ~
èkí
)(io.‰ì.
bôs
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IdentityModule.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
tûñök


5 
imp‹t
 
	gChi£l
.
_


7 
˛ass
 
	gIdítôyModuÀ
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
ModuÀ


9 
vÆ
 
io
 = 
√w
 
BundÀ
 {

10 
vÆ
 
ö
 = 
gí
.
˛⁄eTy≥
.
Êù


11 
vÆ
 
out
 = 
gí
.
˛⁄eTy≥


14 
io
.
out
 :io.
ö


17 
obje˘
 
IdítôyModuÀ


19 
def
 
≠∂y
[
T
 <: 
D©a
](
x
: T): T = {

20 
vÆ
 
idítôy
 = 
ModuÀ
(
√w
 
IdítôyModuÀ
(
x
))

21 
idítôy
.
io
.
ö
 :
x


22 
idítôy
.
io
.
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LCG.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


14 ˛as†
	cLCG16
 
exãnds
 
	mModuÀ
 {

15 
vÆ
 
	mio
 = 
√w
 
BundÀ
 {

16 
vÆ
 
out
 = 
UI¡
(
OUTPUT
, 16)

17 
vÆ
 
	möc
 = 
Boﬁ
(
INPUT
)

19 
vÆ
 
	g°©e
 = 
Reg
(
	$UI¡
(
width
 = 32))

20 
	$whí
 (
io
.
öc
) {

21 
°©e
 :°©ê* 
	`UI¡
(1103515245, 32) + UInt(12345, 32)

22 
	}
}

23 
	gio
.
	gout
 :
°©e
(30, 15)

29 ˛as†
	cLCG
(
vÆ
 
w
: 
I¡
Ë
exãnds
 
ModuÀ
 {

30 
vÆ
 
io
 = 
√w
 
BundÀ
 {

31 
vÆ
 
out
 = 
	`UI¡
(
OUTPUT
, 
w
)

32 
vÆ
 
öc
 = 
	`Boﬁ
(
INPUT
)

34 
	`ªquúe
(
w
 > 0)

35 
vÆ
 
numLCG16s
 : 
I¡
 = (
w
+15)/16

36 
vÆ
 
outs
 = 
Seq
.
	$fûl
(
numLCG16s
Ë{ 
	`LCG16
(
io
.
öc
Ë
	}
}

37 
io
.
out
 :
C©
(
outs
)

40 
obje˘
 
LCG16
 {

41 
def
 
≠∂y
(
öc
: 
Boﬁ
 = Boﬁ(
åue
)): 
UI¡
 = {

42 
vÆ
 
lcg
 = 
ModuÀ
(
√w
 
LCG16
)

43 
lcg
.
io
.
öc
 := inc

44 
lcg
.
io
.
out


48 
obje˘
 
LCG
 {

49 
def
 
≠∂y
(
w
: 
I¡
, 
öc
: 
Boﬁ
 = Boﬁ(
åue
)): 
UI¡
 = {

50 
vÆ
 
lcg
 = 
ModuÀ
(
√w
 
LCG
(
w
))

51 
lcg
.
io
.
öc
 := inc

52 
lcg
.
io
.
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LatencyPipe.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


7 
˛ass
 
	gL©ícyPùe
[
T
 <: 
D©a
](
typ
: T, 
	gœãncy
: 
I¡
Ë
exãnds
 
ModuÀ
 {

8 
vÆ
 
io
 = 
√w
 
BundÀ
 {

9 
vÆ
 
ö
 = 
Decou∂ed
(
typ
).
Êù


10 
vÆ
 
out
 = 
Decou∂ed
(
typ
)

13 
def
 
doN
[
T
](
n
: 
I¡
, 
	gfunc
: T => T, 
	gö
: T): T =

14 (0 
u¡û
 
n
).
fﬁdLe·
(
ö
)((
œ°
, 
	g_
Ë=> 
func
(last))

16 
io
.
out
 <> 
doN
(
œãncy
, (
œ°
: 
Decou∂edIO
[
T
]Ë=> 
Queue
÷a°, 1, 
pùe
=
åue
), io.
ö
)

19 
obje˘
 
	gL©ícyPùe
 {

20 
def
 
	g≠∂y
[
T
 <: 
D©a
](
ö
: 
Decou∂edIO
[T], 
	gœãncy
: 
I¡
): DecoupledIO[T] = {

21 
vÆ
 
pùe
 = 
ModuÀ
(
√w
 
L©ícyPùe
(
ö
.
bôs
, 
œãncy
))

22 
	gpùe
.
	gio
.
	gö
 <> 
ö


23 
	gpùe
.
	gio
.
	gout


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Misc.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


7 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
P¨amëîs


8 
imp‹t
 
	gsˇœ
.
	gm©h
.
_


10 ˛as†
	cP¨amëîizedBundÀ
(
im∂icô
 
p
: 
P¨amëîs
Ë
exãnds
 
BundÀ


12 
åaô
 
Clocked
 
exãnds
 
BundÀ
 {

13 
vÆ
 
˛ock
 = 
	$Clock
()

14 
vÆ
 
ª£t
 = 
	`Boﬁ
()

17 
åaô
 
C™HÆtAndC©chFúe
 
exãnds
 
BundÀ
 {

18 
vÆ
 
hÆt_™d_ˇtch_fúe
: 
O±i⁄
[
Boﬁ
]

19 
	}
}

21 
obje˘
 
Decou∂edHñ≥r
 {

22 
def
 
≠∂y
(
rvs
: 
Boﬁ
*Ë
√w
 
Decou∂edHñ≥r
(rvs)

25 
˛ass
 
	$Decou∂edHñ≥r
(
vÆ
 
rvs
: 
Seq
[
Boﬁ
]) {

26 
def
 
	`fúe
(
ex˛ude
: 
Boﬁ
, 
ö˛udes
: Bool*) = {

27 
	`ªquúe
(
rvs
.
	`c⁄èös
(
ex˛ude
), "Excluded BoolÇotÖresent in DecoupledHelper! NoteÅhat DecoupledHelper usesÑeferentialÉquality forÉxclusion! If you don't wantÅoÉxcludeánything, use fire()!")

28 (
rvs
.
	`fûãr
(
_
 
√
 
ex˛ude
Ë++ 
ö˛udes
).
	`ªdu˚
(_ && _)

30 
def
 
	`fúe
() = {

31 
rvs
.
	`ªdu˚
(
_
 && _)

33 
	}
}

35 
obje˘
 
	gMuxT
 {

36 
def
 
	g≠∂y
[
T
 <: 
D©a
, 
U
 <: D©a](
c⁄d
: 
Boﬁ
, 
	gc⁄
: (T, 
	gU
), 
	gÆt
: (T, U)): (T, U) =

37 (
Mux
(
c⁄d
, 
c⁄
.
_1
, 
Æt
._1), Mux(c⁄d, c⁄.
_2
,ált._2))

39 
def
 
	g≠∂y
[
T
 <: 
D©a
, 
U
 <: D©a, 
W
 <: D©a](
c⁄d
: 
Boﬁ
, 
	gc⁄
: (T, 
	gU
, 
	gW
), 
	gÆt
: (T, U, W)): (T, U, W) =

40 (
Mux
(
c⁄d
, 
c⁄
.
_1
, 
Æt
._1), Mux(c⁄d, c⁄.
_2
,á…._2), Mux(c⁄d, c⁄.
_3
,ált._3))

42 
def
 
	g≠∂y
[
T
 <: 
D©a
, 
U
 <: D©a, 
W
 <: D©a, 
X
 <: D©a](
c⁄d
: 
Boﬁ
, 
	gc⁄
: (T, 
	gU
, 
	gW
, 
	gX
), 
	gÆt
: (T, U, W, X)): (T, U, W, X) =

43 (
Mux
(
c⁄d
, 
c⁄
.
_1
, 
Æt
._1), Mux(c⁄d, c⁄.
_2
,á…._2), Mux(c⁄d, c⁄.
_3
,á…._3), Mux(c⁄d, c⁄.
_4
,ált._4))

47 
obje˘
 
	gMuxTLookup
 {

48 
def
 
	g≠∂y
[
S
 <: 
UI¡
, 
T
 <: 
D©a
, 
U
 <: D©a](
key
: S, : (T, 
	gU
), 
	gm≠pög
: 
Seq
[(S, (T, U))]): (T, U) = {

49 
v¨
 
ªs
 = 

50 (
k
, 
	gv
Ë<- 
	gm≠pög
.
	gªvî£
)

51 
	gªs
 = 
MuxT
(
k
 ==
key
, 
v
, 
ªs
)

52 
	gªs


55 
def
 
	g≠∂y
[
S
 <: 
UI¡
, 
T
 <: 
D©a
, 
U
 <: D©a, 
W
 <: D©a](
key
: S, : (T, 
	gU
, 
	gW
), 
	gm≠pög
: 
Seq
[(S, (T, U, W))]): (T, U, W) = {

56 
v¨
 
ªs
 = 

57 (
k
, 
	gv
Ë<- 
	gm≠pög
.
	gªvî£
)

58 
	gªs
 = 
MuxT
(
k
 ==
key
, 
v
, 
ªs
)

59 
	gªs


63 
obje˘
 
	gVÆidMux
 {

64 
def
 
	g≠∂y
[
T
 <: 
D©a
](
v1
: 
VÆidIO
[T], 
	gv2
: ValidIO[T]*): ValidIO[T] = {

65 
≠∂y
(
v1
 +: 
v2
.
toSeq
)

67 
def
 
≠∂y
[
T
 <: 
D©a
](
vÆids
: 
Seq
[
VÆidIO
[T]]): ValidIO[T] = {

68 
vÆ
 
out
 = 
Wúe
(
VÆid
(
vÆids
.
hód
.
bôs
.
˛⁄eTy≥
))

69 
out
.
vÆid
 :
vÆids
.
m≠
(
_
.vÆid).
ªdu˚
(_ || _)

70 
out
.
bôs
 :
MuxCa£
(
vÆids
.
hód
.bits,

71 
vÆids
.
m≠
(
v
 => (v.
vÆid
 -> v.
bôs
)))

72 
out


76 
obje˘
 
	gSå


78 
def
 
≠∂y
(
s
: 
Såög
): 
UI¡
 = {

79 
v¨
 
i
 = 
BigI¡
(0)

80 
ªquúe
(
s
.
f‹Æl
(
vÆidCh¨
 
_
))

81 
c
 <- 
s
)

82 
i
 = (ò<< 8Ë| 
c


83 
UI¡
(
i
, 
s
.
Àngth
*8)

85 
def
 
≠∂y
(
x
: 
Ch¨
): 
UI¡
 = {

86 
ªquúe
(
vÆidCh¨
(
x
))

87 
UI¡
(
x
.
toI¡
, 8)

89 
def
 
≠∂y
(
x
: 
UI¡
): UInt =ápply(x, 10)

90 
def
 
≠∂y
(
x
: 
UI¡
, 
ødix
: 
I¡
): UInt = {

91 
vÆ
 
ød
 = 
UI¡
(
ødix
)

92 
vÆ
 
w
 = 
x
.
gëWidth


93 
ªquúe
(
w
 > 0)

95 
v¨
 
q
 = 
x


96 
v¨
 
s
 = 
digô
(
q
 % 
ød
)

97 
i
 <- 1 
u¡û
 
˚û
(
log
(2)/log(
ødix
)*
w
).
toI¡
) {

98 
q
 = q / 
ød


99 
s
 = 
C©
(
Mux
(
Boﬁ
(
ødix
 =10Ë&& 
q
 ==
UI¡
(0), 
Så
(' '), 
digô
(q % 
ød
)), s)

101 
	gs


103 
def
 
≠∂y
(
x
: 
SI¡
): 
UI¡
 =ápply(x, 10)

104 
def
 
≠∂y
(
x
: 
SI¡
, 
ødix
: 
I¡
): 
UI¡
 = {

105 
vÆ
 
√g
 = 
x
 < 
SI¡
(0)

106 
vÆ
 
abs
 = 
x
.abs.
asUI¡


107 i‡(
ødix
 != 10) {

108 
C©
(
Mux
(
√g
, 
Så
('-'), Så(' ')), Så(
abs
, 
ødix
))

110 
vÆ
 
ød
 = 
UI¡
(
ødix
)

111 
vÆ
 
w
 = 
abs
.
gëWidth


112 
ªquúe
(
w
 > 0)

114 
v¨
 
q
 = 
abs


115 
v¨
 
s
 = 
digô
(
q
 % 
ød
)

116 
v¨
 
√edSign
 = 
√g


117 
i
 <- 1 
u¡û
 
˚û
(
log
(2)/log(
ødix
)*
w
).
toI¡
) {

118 
q
 = q / 
ød


119 
vÆ
 
∂a˚S∑˚
 = 
q
 ==
UI¡
(0)

120 
vÆ
 
•a˚
 = 
Mux
(
√edSign
, 
Så
('-'), Str(' '))

121 
	g√edSign
 = 
√edSign
 && !
∂a˚S∑˚


122 
s
 = 
C©
(
Mux
(
∂a˚S∑˚
, 
•a˚
, 
digô
(
q
 % 
ød
)), s)

124 
C©
(
Mux
(
√edSign
, 
Så
('-'), Så(' ')), 
s
)

128 
¥iv©e
 
def
 
digô
(
d
: 
UI¡
): UI¡ = 
Mux
(d < UI¡(10), 
Så
('0')+d, Så(('a'-10).
toCh¨
)+d)(7,0)

129 
¥iv©e
 
def
 
vÆidCh¨
(
x
: 
Ch¨
) = x == (x & 0xFF)

132 
obje˘
 
S∂ô


134 
def
 
≠∂y
(
x
: 
UI¡
, 
n0
: 
I¡
) = {

135 
vÆ
 
w
 = 
x
.
gëWidth


136 (
x
.
exåa˘
(
w
-1,
n0
), 
	gx
.extract(n0-1,0))

138 
def
 
≠∂y
(
x
: 
UI¡
, 
n1
: 
I¡
, 
n0
: Int) = {

139 
vÆ
 
w
 = 
x
.
gëWidth


140 (
x
.
exåa˘
(
w
-1,
n1
), 
	gx
.exåa˘“1-1,
n0
), x.extract(n0-1,0))

142 
def
 
≠∂y
(
x
: 
UI¡
, 
n2
: 
I¡
, 
n1
: I¡, 
n0
: Int) = {

143 
vÆ
 
w
 = 
x
.
gëWidth


144 (
x
.
exåa˘
(
w
-1,
n2
), 
	gx
.exåa˘“2-1,
n1
), x.exåa˘“1-1,
n0
), x.extract(n0-1,0))

148 
obje˘
 
	gR™dom


150 
def
 
≠∂y
(
mod
: 
I¡
, 
øndom
: 
UI¡
): UInt = {

151 i‡(
isPow2
(
mod
)Ë
øndom
(
log2Up
(mod)-1,0)

152 
Pri‹ôyEncodî
(
∑πôi⁄
(
≠∂y
(1 << 
log2Up
(
mod
*8), 
øndom
), mod))

154 
def
 
≠∂y
(
mod
: 
I¡
): 
UI¡
 =áµly(mod, 
øndomizî
)

155 
def
 
⁄eHŸ
(
mod
: 
I¡
, 
øndom
: 
UI¡
): UInt = {

156 i‡(
isPow2
(
mod
)Ë
UI¡ToOH
(
øndom
(
log2Up
(mod)-1,0))

157 
Pri‹ôyEncodîOH
(
∑πôi⁄
(
≠∂y
(1 << 
log2Up
(
mod
*8), 
øndom
), mod)).
asUI¡


159 
def
 
⁄eHŸ
(
mod
: 
I¡
): 
UI¡
 = o√HŸ(mod, 
øndomizî
)

161 
¥iv©e
 
def
 
	gøndomizî
 = 
LFSR16
()

162 
¥iv©e
 
def
 
round
(
x
: 
DoubÀ
): 
I¡
 =

163 i‡(
x
.
toI¡
.
toDoubÀ
 == x) x.toInt (x.toInt + 1) & -2

164 
¥iv©e
 
def
 
∑πôi⁄
(
vÆue
: 
UI¡
, 
¶i˚s
: 
I¡
) =

165 
Seq
.
èbuœã
(
¶i˚s
)(
i
 => 
vÆue
 < 
UI¡
(
round
((ò<< vÆue.
gëWidth
).
toDoubÀ
 / slices)))

168 
obje˘
 
Maj‹ôy
 {

169 
def
 
≠∂y
(
ö
: 
Së
[
Boﬁ
]): Bool = {

170 
vÆ
 
n
 = (
ö
.
size
 >> 1) + 1

171 
vÆ
 
˛au£s
 = 
ö
.
sub£ts
(
n
).
m≠
(
_
.
ªdu˚
(_ && _))

172 
˛au£s
.
ªdu˚
(
_
 || _)

175 
def
 
≠∂y
(
ö
: 
Seq
[
Boﬁ
]): Boﬁ =áµly(ö.
toSë
)

177 
def
 
≠∂y
(
ö
: 
UI¡
): 
Boﬁ
 =áµly(ö.
toBoﬁs
.
toSë
)

180 
obje˘
 
P›Cou¡AtLó°
 {

181 
¥iv©e
 
def
 
two
(
x
: 
UI¡
): (
Boﬁ
, 
	gBoﬁ
Ëx.
gëWidth
 
m©ch
 {

182 1 => (
x
.
toBoﬁ
, 
Boﬁ
(
Ál£
))

183 
	gn
 =>

184 
vÆ
 
hÆf
 = 
x
.
gëWidth
 / 2

185 
vÆ
 (
À·O√
, 
À·Two
Ë
two
(
x
(
hÆf
 - 1, 0))

186 
vÆ
 (
rightO√
, 
rightTwo
Ë
two
(
x
(x.
gëWidth
 - 1, 
hÆf
))

187 (
	gÀ·O√
 || 
	grightO√
, 
	gÀ·Two
 || 
	grightTwo
 || (leftOne &&ÑightOne))

189 
def
 
≠∂y
(
x
: 
UI¡
, 
n
: 
I¡
): 
Boﬁ
 =Ç 
m©ch
 {

190 0 => 
Boﬁ
(
åue
)

191 1 => 
x
.
‹R


192 2 => 
two
(
x
).
_2


193 3 => 
P›Cou¡
(
x
Ë>
UI¡
(
n
)

201 
obje˘
 
MaskGí
 {

202 
def
 
≠∂y
(
addr_lo
: 
UI¡
, 
lgSize
: UI¡, 
bótByãs
: 
I¡
, 
groupBy
: Int = 1): UInt = {

203 
ªquúe
 (
groupBy
 >1 && 
bótByãs
 >= groupBy)

204 
ªquúe
 (
isPow2
(
bótByãs
Ë&& isPow2(
groupBy
))

205 
vÆ
 
lgByãs
 = 
log2Ceû
(
bótByãs
)

206 
vÆ
 
sizeOH
 = 
UI¡ToOH
(
lgSize
 | 0.U(
log2Up
(
bótByãs
).
W
),Üog2Up(bótByãs)Ë| 
UI¡
(
groupBy
*2 - 1)

208 
def
 
hñ≥r
(
i
: 
I¡
): 
Seq
[(
Boﬁ
, Bool)] = {

209 i‡(
i
 == 0) {

210 
Seq
((
lgSize
 >
UI¡
(
lgByãs
), 
Boﬁ
(
åue
)))

212 
vÆ
 
	gsub
 = 
hñ≥r
(
i
-1)

213 
vÆ
 
size
 = 
sizeOH
(
lgByãs
 - 
i
)

214 
vÆ
 
bô
 = 
addr_lo
(
lgByãs
 - 
i
)

215 
vÆ
 
nbô
 = !
bô


216 
Seq
.
èbuœã
 (1 << 
i
Ë{ 
j
 =>

217 
vÆ
 (
sub_acc
, 
sub_eq
Ë
sub
(
j
/2)

218 
vÆ
 
eq
 = 
sub_eq
 && (i‡(
j
 % 2 =1Ë
bô
 
nbô
)

219 
vÆ
 
acc
 = 
sub_acc
 || (
size
 && 
eq
)

220 (
acc
, 
	geq
)

225 i‡(
	ggroupBy
 =
bótByãs
Ë
UI¡
(1) 

226 
C©
(
hñ≥r
(
lgByãs
-
log2Ceû
(
groupBy
)).
m≠
(
_
.
_1
).
ªvî£
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MultiWidthFifo.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gunôã°
.
UnôTe°


8 
˛ass
 
	$Mu…iWidthFifo
(
öW
: 
I¡
, 
outW
: I¡, 
n
: I¡Ë
exãnds
 
ModuÀ
 {

9 
vÆ
 
io
 = 
√w
 
BundÀ
 {

10 
vÆ
 
ö
 = 
	`Decou∂ed
(
	`Bôs
(
width
 = 
öW
)).
Êù


11 
vÆ
 
out
 = 
	`Decou∂ed
(
	`Bôs
(
width
 = 
outW
))

12 
vÆ
 
cou¡
 = 
	`UI¡
(
OUTPUT
, 
	`log2Up
(
n
 + 1))

15 i‡(
öW
 =
outW
) {

16 
vÆ
 
q
 = 
	`ModuÀ
(
√w
 
	`Queue
(
	`Bôs
(
width
 = 
öW
), 
n
))

17 
q
.
io
.
íq
 <> io.
ö


18 
io
.
out
 <> 
q
.io.
deq


19 
io
.
cou¡
 :
q
.io.count

20 } i‡(
öW
 > 
outW
) {

21 
vÆ
 
nBóts
 = 
öW
 / 
outW


23 
	`ªquúe
(
öW
 % 
outW
 =0, 
s
"MultiWidthFifo: in: $inWÇot divisible by out: $outW")

24 
	`ªquúe
(
n
 % 
nBóts
 =0, 
s
"Cannot store $n output words when output beats is $nBeats")

26 
vÆ
 
wd©a
 = 
	`Reg
(
	`Vec
(
n
 / 
nBóts
, 
	`Bôs
(
width
 = 
öW
)))

27 
vÆ
 
rd©a
 = 
	`Vec
(
wd©a
.
Ê©M≠
 { 
öd©
 =>

28 (0 
u¡û
 
nBóts
).
	`m≠
(
i
 => 
	`öd©
(
outW
 * (i + 1) - 1, outW * i)) })

30 
vÆ
 
hód
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
	`log2Up
(
n
 / 
nBóts
)))

31 
vÆ
 
èû
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
	`log2Up
(
n
)))

32 
vÆ
 
size
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
	`log2Up
(
n
 + 1)))

34 
	`whí
 (
io
.
ö
.
	`fúe
()) {

35 
	`wd©a
(
hód
Ë:
io
.
ö
.
bôs


36 
hód
 :hód + 
	`UI¡
(1)

39 
	`whí
 (
io
.
out
.
	`fúe
()Ë{ 
èû
 :èû + 
	`UI¡
(1) }

41 
size
 :
	`MuxCa£
(size, 
	`Seq
(

42 (
io
.
ö
.
	`fúe
(Ë&& io.
out
.fúe()Ë-> (
size
 + 
	`UI¡
(
nBóts
 - 1)),

43 
io
.
ö
.
	`fúe
(Ë-> (
size
 + 
	`UI¡
(
nBóts
)),

44 
io
.
out
.
	`fúe
(Ë-> (
size
 - 
	`UI¡
(1))))

46 
io
.
out
.
vÆid
 :
size
 > 
	`UI¡
(0)

47 
io
.
out
.
bôs
 :
	`rd©a
(
èû
)

48 
io
.
ö
.
ªady
 :
size
 < 
	`UI¡
(
n
)

49 
io
.
cou¡
 :
size


51 
vÆ
 
nBóts
 = 
outW
 / 
öW


53 
	`ªquúe
(
outW
 % 
öW
 =0, 
s
"MultiWidthFifo: out: $outWÇot divisible by in: $inW")

55 
vÆ
 
wd©a
 = 
	`Reg
(
	`Vec
(
n
 * 
nBóts
, 
	`Bôs
(
width
 = 
öW
)))

56 
vÆ
 
rd©a
 = 
Vec
.
	`èbuœã
(
n
Ë{ 
i
 =>

57 
	`C©
(
wd©a
.
	`¶i˚
(
i
 * 
nBóts
, (ò+ 1Ë*ÇBóts).
ªvî£
)}

59 
vÆ
 
hód
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
	`log2Up
(
n
 * 
nBóts
)))

60 
vÆ
 
èû
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
	`log2Up
(
n
)))

61 
vÆ
 
size
 = 
	`Reg
(
öô
 = 
	`UI¡
(0, 
	`log2Up
(
n
 * 
nBóts
 + 1)))

63 
	`whí
 (
io
.
ö
.
	`fúe
()) {

64 
	`wd©a
(
hód
Ë:
io
.
ö
.
bôs


65 
hód
 :hód + 
	`UI¡
(1)

68 
	`whí
 (
io
.
out
.
	`fúe
()Ë{ 
èû
 :èû + 
	`UI¡
(1) }

70 
size
 :
	`MuxCa£
(size, 
	`Seq
(

71 (
io
.
ö
.
	`fúe
(Ë&& io.
out
.fúe()Ë-> (
size
 - 
	`UI¡
(
nBóts
 - 1)),

72 
io
.
ö
.
	`fúe
(Ë-> (
size
 + 
	`UI¡
(1)),

73 
io
.
out
.
	`fúe
(Ë-> (
size
 - 
	`UI¡
(
nBóts
))))

75 
io
.
cou¡
 :
size
 >> 
	`UI¡
(
	`log2Up
(
nBóts
))

76 
io
.
out
.
vÆid
 :io.
cou¡
 > 
	`UI¡
(0)

77 
io
.
out
.
bôs
 :
	`rd©a
(
èû
)

78 
io
.
ö
.
ªady
 :
size
 < 
	`UI¡
(
n
 * 
nBóts
)

80 
	}
}

82 ˛as†
	cMu…iWidthFifoTe°
 
exãnds
 
UnôTe°
 {

83 
vÆ
 
big2lôée
 = 
ModuÀ
(
√w
 
	$Mu…iWidthFifo
(16, 8, 8))

84 
vÆ
 
lôée2big
 = 
	`ModuÀ
(
√w
 
	$Mu…iWidthFifo
(8, 16, 4))

86 
vÆ
 
bl_£nd
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

87 
vÆ
 
lb_£nd
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

88 
vÆ
 
bl_ªcv
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

89 
vÆ
 
lb_ªcv
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

90 
vÆ
 
bl_föished
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

91 
vÆ
 
lb_föished
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

93 
vÆ
 
bl_d©a
 = 
Vec
.
	$èbuœã
(4){
i
 => 
	`UI¡
((2 * i + 1) * 256 + 2 * i, 16)}

94 
vÆ
 
lb_d©a
 = 
Vec
.
	$èbuœã
(8){
i
 => 
	`UI¡
(i, 8)
	}
}

96 
vÆ
 (
bl_£nd_˙t
, 
bl_£nd_d⁄e
Ë
Cou¡î
(
big2lôée
.
io
.
ö
.
fúe
(), 4)

97 
vÆ
 (
lb_£nd_˙t
, 
lb_£nd_d⁄e
Ë
Cou¡î
(
lôée2big
.
io
.
ö
.
fúe
(), 8)

99 
vÆ
 (
bl_ªcv_˙t
, 
bl_ªcv_d⁄e
Ë
Cou¡î
(
big2lôée
.
io
.
out
.
fúe
(), 8)

100 
vÆ
 (
lb_ªcv_˙t
, 
lb_ªcv_d⁄e
Ë
Cou¡î
(
lôée2big
.
io
.
out
.
fúe
(), 4)

102 
	gbig2lôée
.
	gio
.
	gö
.
	gvÆid
 :
bl_£nd


103 
big2lôée
.
io
.
ö
.
bôs
 :
	$bl_d©a
(
bl_£nd_˙t
)

104 
big2lôée
.
io
.
out
.
ªady
 :
bl_ªcv


106 
lôée2big
.
io
.
ö
.
vÆid
 :
lb_£nd


107 
lôée2big
.
io
.
ö
.
bôs
 :
	$lb_d©a
(
lb_£nd_˙t
)

108 
lôée2big
.
io
.
out
.
ªady
 :
lb_ªcv


110 
vÆ
 
bl_ªcv_d©a_idx
 = 
bl_ªcv_˙t
 >> 
	$UI¡
(1)

111 
vÆ
 
bl_ªcv_d©a
 = 
	`Mux
(
	`bl_ªcv_˙t
(0),

112 
	`bl_d©a
(
bl_ªcv_d©a_idx
)(15, 8),

113 
	`bl_d©a
(
bl_ªcv_d©a_idx
)(7, 0))

115 
vÆ
 
lb_ªcv_d©a
 = 
	`C©
(

116 
	`lb_d©a
(
	`C©
(
lb_ªcv_˙t
, 
	`UI¡
(1, 1))),

117 
	`lb_d©a
(
	`C©
(
lb_ªcv_˙t
, 
	$UI¡
(0, 1))))

119 
	$whí
 (
io
.
°¨t
) {

120 
bl_£nd
 :
	`Boﬁ
(
åue
)

121 
lb_£nd
 :
	`Boﬁ
(
åue
)

122 
	}
}

124 
	$whí
 (
bl_£nd_d⁄e
) {

125 
bl_£nd
 :
	`Boﬁ
(
Ál£
)

126 
bl_ªcv
 :
	`Boﬁ
(
åue
)

127 
	}
}

129 
	$whí
 (
lb_£nd_d⁄e
) {

130 
lb_£nd
 :
	`Boﬁ
(
Ál£
)

131 
lb_ªcv
 :
	`Boﬁ
(
åue
)

132 
	}
}

134 
	$whí
 (
bl_ªcv_d⁄e
) {

135 
bl_ªcv
 :
	`Boﬁ
(
Ál£
)

136 
bl_föished
 :
	`Boﬁ
(
åue
)

137 
	}
}

139 
	$whí
 (
lb_ªcv_d⁄e
) {

140 
lb_ªcv
 :
	`Boﬁ
(
Ál£
)

141 
lb_föished
 :
	`Boﬁ
(
åue
)

142 
	}
}

144 
io
.
föished
 :
bl_föished
 && 
lb_föished


146 
vÆ
 
bl_°¨t_ªcv
 = 
	$Reg
(
√xt
 = 
bl_£nd_d⁄e
)

147 
vÆ
 
lb_°¨t_ªcv
 = 
	$Reg
(
√xt
 = 
lb_£nd_d⁄e
)

149 
	`as£π
(!
lôée2big
.
io
.
out
.
vÆid
 ||Üôée2big.io.out.
bôs
 ==
lb_ªcv_d©a
,

151 
	`as£π
(!
big2lôée
.
io
.
out
.
vÆid
 || big2lôée.io.out.
bôs
 ==
bl_ªcv_d©a
,

154 
	`as£π
(!
lb_°¨t_ªcv
 || 
lôée2big
.
io
.
cou¡
 ==
	`UI¡
(4),

156 
	`as£π
(!
bl_°¨t_ªcv
 || 
big2lôée
.
io
.
cou¡
 ==
	`UI¡
(8),

158 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MuxLiteral.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gsˇœ
.
	gªÊe˘
.
CœssTag


11 
obje˘
 
	gMuxLôîÆ


13 
def
 
	g≠∂y
[
T
 <: 
D©a
:
CœssTag
](
ödex
: 
UI¡
, : T, 
	gfú°
: (UI¡, 
	gT
), 
	gª°
: (UInt, T)*): T =

14 
≠∂y
(
ödex
, , 
fú°
 :: 
ª°
.
toLi°
)

15 
def
 
≠∂y
[
T
 <: 
D©a
:
CœssTag
](
ödex
: 
UI¡
, : T, 
	gˇ£s
: 
Seq
[(UInt, T)]): T =

16 
MuxTabÀ
(
ödex
, , 
ˇ£s
.
m≠
 { (
k
, 
v
Ë=> (k.
lôVÆue
, v) })

19 
obje˘
 
	gMuxSeq


21 
def
 
	g≠∂y
[
T
 <: 
D©a
:
CœssTag
](
ödex
: 
UI¡
, : T, 
	gfú°
: T, 
	gª°
: T*): T =

22 
≠∂y
(
ödex
, , 
fú°
 :: 
ª°
.
toLi°
)

23 
def
 
≠∂y
[
T
 <: 
D©a
:
CœssTag
](
ödex
: 
UI¡
, : T, 
	gˇ£s
: 
Seq
[T]): T =

24 
MuxTabÀ
(
ödex
, , 
ˇ£s
.
zùWôhIndex
.
m≠
 { (
v
, 
i
Ë=> (
BigI¡
(i), v) })

27 
obje˘
 
	gMuxTabÀ


29 
def
 
	g≠∂y
[
T
 <: 
D©a
:
CœssTag
](
ödex
: 
UI¡
, : T, 
	gfú°
: (
BigI¡
, 
	gT
), 
	gª°
: (BigInt, T)*): T =

30 
≠∂y
(
ödex
, , 
fú°
 :: 
ª°
.
toLi°
)

31 
def
 
≠∂y
[
T
 <: 
D©a
:
CœssTag
](
ödex
: 
UI¡
, : T, 
	gˇ£s
: 
Seq
[(
BigI¡
, T)]): T = {

33 
ˇ£s
.
f‹óch
 { (
k
, 
_
Ë=> 
ªquúe
 (k >= 0) }

34 
ªquúe
 (
ˇ£s
.
m≠
(
_
.
_1
).
di°ö˘
.
size
 == cases.size)

37 
vÆ
 
sim∂e
 = 
ˇ£s
.
fûãr
 { (
k
, 
v
Ë=> !.
isLô
 || !v.isLô || v.
lôVÆue
 != .litValue }

39 
vÆ
 
	gmaxKey
 = (
BigI¡
(0Ë+: 
sim∂e
.
m≠
(
_
.
_1
)).
max


40 
vÆ
 
ídIndex
 = 
BigI¡
(1Ë<< 
log2Ceû
(
maxKey
+1)

42 i‡(
sim∂e
.
isEm±y
) {

44 } i‡(
ídIndex
 <2*
sim∂e
.
size
) {

46 
vÆ
 
èbÀ
 = 
Aºay
.
fûl
(
ídIndex
.
toI¡
) {  }

47 
sim∂e
.
f‹óch
 { (
k
, 
v
Ë=> 
èbÀ
(k.
toI¡
) = v }

48 
Mux
(
ödex
 >
UI¡
(
ídIndex
), , 
Vec
(
èbÀ
)(index))

51 
vÆ
 
	gout
 = 
Wúe
(
öô
 = )

52 
sim∂e
.
fﬁdLe·
(
√w
 
chi£l3
.
utû
.
SwôchC⁄ãxt
(
ödex
, 
N⁄e
, 
Së
.
em±y
)Ë{ (
	gacc
, (
	gk
, 
	gv
)) =>

53 
acc
.
is
 (
UI¡
(
k
)Ë{ 
out
 :
v
 }

55 
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PSDTestMode.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	g‰ìchùs
.
	grockëchù
.
	gc⁄fig
.
_


8 
obje˘
 
In˛udePSDTe°
 
exãnds
 
	gFõld
[
Boﬁón
](
	gÁl£
)

10 ˛as†
	cPSDTe°Mode
 
exãnds
 
	mBundÀ
 {

11 
vÆ
 
	mã°_mode
 = 
	$Boﬁ
()

12 
vÆ
 
ã°_mode_ª£t
 = 
	`Boﬁ
()

16 
åaô
 
C™HavePSDTe°ModeIO
 {

17 
im∂icô
 
vÆ
 
p
: 
P¨amëîs


18 
vÆ
 
psd
 = 
	`p
(
In˛udePSDTe°
).
	`›ti⁄
(
√w
 
	`PSDTe°Mode
().
asI≈ut
)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PlusArg.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gutû
.
HasBœckBoxResour˚


8 
˛ass
 
	$PlusArgInfo
(: 
I¡
, 
doc°rög
: 
Såög
)

10 
˛ass
 
	$∂ußrg_ªadî
(
vÆ
 
f‹m©
: 
Såög
, vÆ : 
I¡
, vÆ 
doc°rög
: SåögË
exãnds
 
	`BœckBox
(
	`M≠
(

11 "FORMAT" -> 
chi£l3
.
c‹e
.
	`SåögP¨am
(
f‹m©
),

12 "DEFAULT" -> 
chi£l3
.
c‹e
.
	$I¡P¨am
())Ë
wôh
 
HasBœckBoxResour˚
 {

13 
vÆ
 
io
 = 
√w
 
BundÀ
 {

14 
vÆ
 
out
 = 
	`UI¡
(
OUTPUT
, 
width
 = 32)

17 
	`£tResour˚
("/vsrc/plusarg_reader.v")

18 
	}
}

21 
˛ass
 
	$PlusArgTimeout
(
vÆ
 
f‹m©
: 
Såög
, vÆ : 
I¡
, vÆ 
doc°rög
: SåögË
exãnds
 
ModuÀ
 {

22 
vÆ
 
io
 = 
√w
 
BundÀ
 {

23 
vÆ
 
cou¡
 = 
	`UI¡
(
INPUT
, 
width
 = 32)

25 
vÆ
 
max
 = 
	`ModuÀ
(
√w
 
	`∂ußrg_ªadî
(
f‹m©
, , 
doc°rög
)).
io
.
out


27 
	`whí
 (
max
 > 
	`UI¡
(0)) {

28 
	`as£π
 (
io
.
cou¡
 < 
max
, 
s
"TimeoutÉxceeded: $docstring")

30 
	}
}

32 
obje˘
 
	gPlusArg


40 
def
 
≠∂y
(
«me
: 
Såög
, : 
I¡
 = 0, 
doc°rög
: Såög = ""): 
UI¡
 = {

41 
PlusArgAπeÁ˘s
.
≠≥nd
(
«me
, , 
doc°rög
)

42 
ModuÀ
(
√w
 
∂ußrg_ªadî
(
«me
 + "=%d", , 
doc°rög
)).
io
.
out


49 
def
 
timeout
(
«me
: 
Såög
, : 
I¡
 = 0, 
doc°rög
: Såög = "")(
cou¡
: 
UI¡
) {

50 
PlusArgAπeÁ˘s
.
≠≥nd
(
«me
, , 
doc°rög
)

51 
ModuÀ
(
√w
 
PlusArgTimeout
(
«me
 + "=%d", , 
doc°rög
)).
io
.
cou¡
 := count

55 
obje˘
 
PlusArgAπeÁ˘s
 {

56 
¥iv©e
 
v¨
 
¨ãÁ˘s
: 
M≠
[
Såög
, 
PlusArgInfo
] = M≠.
em±y


59 
def
 
≠≥nd
(
«me
: 
Såög
, : 
I¡
, 
doc°rög
: Såög): 
Unô
 =

60 
¨ãÁ˘s
 =áπeÁ˘†++ 
M≠
(
«me
 -> 
PlusArgInfo
(, 
doc°rög
))

63 
¥iv©e
 
def
 
£rülizeHñp_cHódî
(
èb
: 
Såög
 = ""): Såög = 
¨ãÁ˘s


64 .
m≠
{ (
¨g
, 
PlusArgInfo
(, 
doc°rög
)) =>

65 
s
"""|$tab+$arg=INT\\n\\

66 |
$èb$
{" "*20}
$doc°rög
\\
n
\\

67 |
$èb$
{" "*22}(=
$deÁu…
)""".stripMargin }.toSeq

68 .
mkSåög
("\\n\\\n") ++ "\""

71 
¥iv©e
 
def
 
£rülizeAºay_cHódî
(
èb
: 
Såög
 = ""): String = {

72 
vÆ
 
¥ëtyTab
 = 
èb
 + " " * 44

73 
s
"${tab}static const char * verilog_plusargs [] = {\\\n" ++

74 
¨ãÁ˘s


75 .
m≠
{ (
¨g
, 
_
Ë=> 
s
"""$¥ëtyTab"
$¨g
",\\\n""" }

76 .
mkSåög
("")++

77 
	gs
"${prettyTab}0};"

82 
def
 
£rülize_cHódî
(): 
Såög
 =

83 
s
"""|#define PLUSARG_USAGE_OPTIONS \"EMULATOR VERILOG PLUSARGS\\n\\

84 |
$
{
£rülizeHñp_cHódî
(" "*7)}

85 |
$
{
£rülizeAºay_cHódî
()}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PositionalMultiQueue.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


7 
˛ass
 
	gPosôi⁄ÆMu…iQueueP¨amëîs
[
T
 <: 
D©a
](
gí
: T, 
	gposôi⁄s
: 
I¡
, 
	gways
: Int)

9 
˛ass
 
Posôi⁄ÆMu…iQueueE¡ry
[
T
 <: 
D©a
](
∑øms
: 
Posôi⁄ÆMu…iQueueP¨amëîs
[T])

10 
exãnds
 
	$GíîicP¨amëîizedBundÀ
(
∑øms
)

12 
vÆ
 
d©a
 = 
∑øms
.
gí
.
asOuçut


13 
vÆ
 
pos
 = 
	`UI¡
(
width
 = 
	`log2Up
(
∑øms
.
posôi⁄s
))

14 
	}
}

16 
˛ass
 
Posôi⁄ÆMu…iQueuePush
[
T
 <: 
D©a
](
∑øms
: 
Posôi⁄ÆMu…iQueueP¨amëîs
[T])

17 
exãnds
 
	$Posôi⁄ÆMu…iQueueE¡ry
(
∑øms
)

19 
vÆ
 
way
 = 
	`UI¡
(
width
 = 
	`log2Up
(
∑øms
.
ways
))

20 
	}
}

29 
˛ass
 
Posôi⁄ÆMu…iQueue
[
T
 <: 
D©a
](
∑øms
: 
Posôi⁄ÆMu…iQueueP¨amëîs
[T], 
	gcombö©i⁄Æ
: 
Boﬁón
Ë
exãnds
 
ModuÀ


31 
vÆ
 
io
 = 
√w
 
BundÀ
 {

32 
vÆ
 
íq
 = 
VÆid
(
√w
 
Posôi⁄ÆMu…iQueuePush
(
∑øms
)).
Êù


33 
vÆ
 
deq
 = 
Vec
(
∑øms
.
ways
, 
Decou∂ed
(
√w
 
Posôi⁄ÆMu…iQueueE¡ry
(params)))

36 
vÆ
 
	gem±y
 = 
RegInô
(
Vec
.
fûl
(
∑øms
.
ways
Ë{ 
Boﬁ
(
åue
) })

37 
vÆ
 
hód
 = 
Reg
(
Vec
(
∑øms
.
ways
, 
UI¡
(
width
 = 
log2Up
’¨ams.
posôi⁄s
))))

38 
vÆ
 
èû
 = 
Reg
(
Vec
(
∑øms
.
ways
, 
UI¡
(
width
 = 
log2Up
’¨ams.
posôi⁄s
))))

39 
vÆ
 
√xt
 = 
Mem
(
∑øms
.
posôi⁄s
, 
UI¡
(
width
 = 
log2Up
(params.positions)))

40 
vÆ
 
d©a
 = 
Mem
(
∑øms
.
posôi⁄s
,Ö¨ams.
gí
)

42 
vÆ
 
	ggu¨d
 = 
RegInô
(
UI¡
(0, 
width
 = 
∑øms
.
posôi⁄s
))

44 
whí
 (
io
.
íq
.
fúe
()) {

45 
d©a
(
io
.
íq
.
bôs
.
pos
) := io.enq.bits.data

47 
as£π
 (!
gu¨d
(
io
.
íq
.
bôs
.
pos
))

49 
whí
 (!
em±y
(
io
.
íq
.
bôs
.
way
)) {

50 
√xt
(
èû
(
io
.
íq
.
bôs
.
way
)Ë:io.íq.bôs.
pos


53 
vÆ
 
£tGu¨d
 = 
io
.
íq
.
fúe
(Ë<< io.íq.
bôs
.
pos


55 
vÆ
 
deq
 = 
Wúe
(
io
.deq)

56 
io
.
deq
 <> deq

58 
vÆ
 
waySñe˘
 = 
UI¡ToOH
(
io
.
íq
.
bôs
.
way
, 
∑øms
.
ways
)

59 
v¨
 
	g˛rGu¨d
 = 
UI¡
(0)

60 
i
 <- 0 
u¡û
 
∑øms
.
ways
) {

61 
vÆ
 
íq
 = 
io
.íq.
fúe
(Ë&& 
waySñe˘
(
i
)

62 
vÆ
 
œ°
 = 
hód
(
i
Ë==
èû
(i)

64 
whí
 (
íq
) {

65 
èû
(
i
Ë:
io
.
íq
.
bôs
.
pos


66 
whí
 (
em±y
(
i
)) {

67 
hód
(
i
Ë:
io
.
íq
.
bôs
.
pos


71 i‡(
combö©i⁄Æ
) {

72 
deq
(
i
).
vÆid
 :!
em±y
(iË|| 
íq


73 
deq
(
i
).
bôs
.
pos
 :
Mux
(
em±y
(i), 
io
.
íq
.bôs.pos, 
hód
(i))

74 
deq
(
i
).
	gbôs
.
	gd©a
 :
Mux
(
em±y
(i), 
io
.
íq
.
bôs
.
d©a
, d©a(
hód
(i)))

76 
deq
(
i
).
	gvÆid
 :!
em±y
(i)

77 
deq
(
i
).
bôs
.
pos
 :
hód
(i)

78 
deq
(
i
).
bôs
.
d©a
 :d©a(
hód
(i))

81 
whí
 (
deq
(
i
).
fúe
()) {

82 
hód
(
i
Ë:
Mux
(
œ°
, 
io
.
íq
.
bôs
.
pos
, 
√xt
(head(i)))

84 
	g˛rGu¨d
 = 
˛rGu¨d
 | (
deq
(
i
).
fúe
(Ë<< deq(i).
bôs
.
pos
)

86 
whí
 (
íq
 =/
deq
(
i
).
fúe
()) {

87 
em±y
(
i
Ë:
deq
(i).
fúe
(Ë&& 
œ°


91 
gu¨d
 :(gu¨d | 
£tGu¨d
Ë& ~
˛rGu¨d


94 
obje˘
 
Posôi⁄ÆMu…iQueue


96 
def
 
≠∂y
[
T
 <: 
D©a
](
gí
: T, 
	gposôi⁄s
: 
I¡
, 
	gways
: I¡ = 1, 
	gcombö©i⁄Æ
: 
Boﬁón
 = 
åue
) = {

97 
ModuÀ
(
√w
 
Posôi⁄ÆMu…iQueue
(
Posôi⁄ÆMu…iQueueP¨amëîs
(
gí
, 
posôi⁄s
, 
ways
), 
combö©i⁄Æ
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Property.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
	gutû
.
¥›îty


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	göã∫Æ
.
	gsour˚öfo
.{
	gSour˚Info
, 
	gSour˚Löe
}

7 
imp‹t
 
	gchi£l3
.
	gutû
.{
	gRódyVÆidIO
}

9 
£Æed
 
ab°ø˘
 cœs†
	cPr›îtyTy≥
(
«me
: 
Såög
) {

10 
ovîride
 
def
 
toSåög
: 
Såög
 = 
«me


13 
obje˘
 
Pr›îtyTy≥
 {

14 
obje˘
 
As£π
 
exãnds
 
	`Pr›îtyTy≥
("Assert")

15 
obje˘
 
Assume
 
exãnds
 
	`Pr›îtyTy≥
("Assume")

16 
obje˘
 
Covî
 
exãnds
 
	`Pr›îtyTy≥
("Cover")

17 
	}
}

19 
åaô
 
Ba£Pr›îtyP¨amëîs
 {

20 
vÆ
 
pTy≥
: 
Pr›îtyTy≥


21 
vÆ
 
c⁄d
: 
Boﬁ


22 
vÆ
 
œbñ
: 
Såög


23 
vÆ
 
mesßge
: 
Såög


26 
˛ass
 
CovîPr›îtyP¨amëîs
(

27 
c⁄d
: 
Boﬁ
,

28 
œbñ
: 
Såög
 = "",

29 
mesßge
: 
Såög
 = ""Ë
exãnds
 
Ba£Pr›îtyP¨amëîs
 {

30 
vÆ
 
pTy≥
 = 
Pr›îtyTy≥
.
Covî


33 
ab°ø˘
 cœs†
	cBa£Pr›îtyLibøry
 {

34 
def
 
	$gíî©ePr›îty
(
¥›_∑øm
: 
Ba£Pr›îtyP¨amëîs
)(
im∂icô
 
sour˚Info
: 
Sour˚Info
)

37 ˛as†
	cDeÁu…Pr›îtyLibøry
 
exãnds
 
Ba£Pr›îtyLibøry
 {

38 
def
 
	$gíî©ePr›îty
(
¥›_∑øm
: 
Ba£Pr›îtyP¨amëîs
)(
im∂icô
 
sour˚Info
: 
Sour˚Info
) {

40 
Unô


42 
	}
}

44 
ab°ø˘
 cœs†
	cBa£Pr›îty
 {

45 
def
 
	$gíî©ePr›îtõs
(): 
Seq
[
Ba£Pr›îtyP¨amëîs
]

48 
˛ass
 
	$CovîBoﬁón
(
c⁄d
: 
Boﬁ
, 
œbñs
: 
Seq
[
Såög
]) {

49 
	}
}

75 
˛ass
 
	$CrossPr›îty
(
c⁄d
: 
Seq
[Seq[
CovîBoﬁón
]], 
ex˛ude
: Seq[Seq[
Såög
]], 
mesßge
: SåögË
exãnds
 
Ba£Pr›îty
 {

76 
def
 
	`li°Pr›îtõs
(
c1
: 
CovîBoﬁón
, 
c2
: 
Seq
[CoverBoolean]): Seq[CoverBoolean] = {

77 i‡(
c2
.
isEm±y
) {

78 
	`Seq
(
c1
)

80 
c2
.
	`m≠
–(
c
: 
CovîBoﬁón
) => {

81 
√w
 
	`CovîBoﬁón
(
c1
.
c⁄d
 && 
c
.c⁄d, c1.
œbñs
 ++ c.labels)

86 
def
 
	`¸ossPr›îtõs
(
c⁄d
: 
Seq
[Seq[
CovîBoﬁón
]]): Seq[CoverBoolean] = {

87 i‡(
c⁄d
.
isEm±y
) {

88 
	`Seq
()

90 
c⁄d
.
hód
.
	`m≠
–(
c1
: 
CovîBoﬁón
) => {

91 
	`li°Pr›îtõs
(
c1
, 
	`¸ossPr›îtõs
(
c⁄d
.
èû
))

92 }).
	`ªdu˚
(
_
 ++ _)

95 
def
 
	`öSequí˚
(
£¨ch
: 
Seq
[
Såög
], 
föd
: Seq[Såög]): 
Boﬁón
 = {

96 i‡(
föd
.
isEm±y
) {

97 
åue


99 
föd
.
	`m≠
–(
s
:
Såög
) => {

100 
£¨ch
.
	`c⁄èös
(
s
)

101 }).
	`ªdu˚
–
_
 && _ )

104 
def
 
	`SeqsöSequí˚
(
£¨ch
: 
Seq
[
Såög
], 
föd
: Seq[Seq[Såög]]): 
Boﬁón
 = {

105 i‡(
föd
.
isEm±y
) {

106 
Ál£


108 
föd
.
	`m≠
–(
s
: 
Seq
[
Såög
]) => {

109 
	`öSequí˚
(
£¨ch
, 
s
)

110 }).
	`ªdu˚
 (
_
 || _)

114 
def
 
	`gíî©ePr›îtõs
(): 
Seq
[
CovîPr›îtyP¨amëîs
] = {

115 
	`¸ossPr›îtõs
(
c⁄d
).
	`m≠
–(
c
: 
CovîBoﬁón
) => {

116 i‡(!
	`SeqsöSequí˚
(
c
.
œbñs
, 
ex˛ude
)) {

117 
√w
 
	`CovîPr›îtyP¨amëîs
(

118 
c⁄d
 = 
c
.cond,

119 
œbñ
 = 
c
.
œbñs
.
	`ªdu˚
–(
s1
: 
Såög
, 
s2
: String) => {s1 + "_" + s2} ),

120 
mesßge
 = mesßgê+ " " + 
c
.
œbñs
.
	`m≠
("<" + 
_
 + ">").
	`ªdu˚
 ( (
s1
: 
Såög
, 
s2
: String) => { s1 + " X " + s2 }))

122 
√w
 
	`CovîPr›îtyP¨amëîs
(

123 
c⁄d
 = 
åue
.
B
,

124 
œbñ
 = 
c
.
œbñs
.
	`ªdu˚
–(
s1
: 
Såög
, 
s2
: String) => {s1 + "_" + s2} ) + "_EXCLUDE",

125 
mesßge
 = mesßgê+ " " + 
c
.
œbñs
.
	`m≠
("<" + 
_
 + ">").
	`ªdu˚
 ( (
s1
: 
Såög
, 
s2
: String) => { s1 + " X " + s2 }))

130 
	}
}

134 
obje˘
 
covî
 {

135 
¥iv©e
 
v¨
 
¥›Lib
: 
Ba£Pr›îtyLibøry
 = 
√w
 
DeÁu…Pr›îtyLibøry


136 
def
 
£tPr›Lib
(
lib
: 
Ba£Pr›îtyLibøry
): 
Unô
 = 
this
.
synchr⁄ized
 {

137 
¥›Lib
 = 
lib


139 
def
 
≠∂y
(
c⁄d
: 
Boﬁ
)(
im∂icô
 
sour˚Info
: 
Sour˚Info
): 
Unô
 = {

140 
¥›Lib
.
gíî©ePr›îty
(
CovîPr›îtyP¨amëîs
(
c⁄d
))

142 
def
 
≠∂y
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
)(
im∂icô
 
sour˚Info
: 
Sour˚Info
): 
Unô
 = {

143 
¥›Lib
.
gíî©ePr›îty
(
CovîPr›îtyP¨amëîs
(
c⁄d
, 
œbñ
))

145 
def
 
≠∂y
(
c⁄d
: 
Boﬁ
, 
œbñ
: 
Såög
, 
mesßge
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
): 
Unô
 = {

146 
¥›Lib
.
gíî©ePr›îty
(
CovîPr›îtyP¨amëîs
(
c⁄d
, 
œbñ
, 
mesßge
))

148 
def
 
≠∂y
(
¥›
: 
Ba£Pr›îty
)(
im∂icô
 
sour˚Info
: 
Sour˚Info
): 
Unô
 = {

149 
¥›
.
gíî©ePr›îtõs
().
f‹óch
–(
µ
: 
Ba£Pr›îtyP¨amëîs
) => {

150 i‡(
µ
.
pTy≥
 =
Pr›îtyTy≥
.
Covî
) {

151 
¥›Lib
.
gíî©ePr›îty
(
CovîPr›îtyP¨amëîs
(
µ
.
c⁄d
,Öp.
œbñ
,Öp.
mesßge
))

155 
def
 
	g≠∂y
[
T
 <: 
D©a
](
rv
: 
RódyVÆidIO
[T], 
	gœbñ
: 
Såög
, 
	gmesßge
: Såög)(
im∂icô
 
sour˚Info
: 
Sour˚Info
): 
Unô
 = {

156 
≠∂y
–
rv
.
vÆid
 &&Ñv.
ªady
, 
œbñ
 + "_FIRE", 
mesßge
 + ": validándÑeady")

157 
≠∂y
–
rv
.
vÆid
 && !rv.
ªady
, 
œbñ
 + "_STALL", 
mesßge
 + ": validándÇotÑeady")

158 
≠∂y
(!
rv
.
vÆid
 &&Ñv.
ªady
, 
œbñ
 + "_IDLE", 
mesßge
 + ":Çot validándÑeady")

159 
≠∂y
(!
rv
.
vÆid
 && !rv.
ªady
, 
œbñ
 + "_FULL", 
mesßge
 + ":Çot validándÇotÑeady")

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ROMGenerator.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gsˇœ
.
	gcﬁÀ˘i⁄
.
	gmuèbÀ
.{
	gHashM≠
}

8 
˛ass
 
	$ROMC⁄fig
(
«me
: 
Såög
, 
dïth
: 
I¡
, 
width
: Int)

10 ˛as†
	cBœckBoxedROM
(
c
: 
ROMC⁄fig
Ë
exãnds
 
BœckBox
 {

11 
vÆ
 
io
 = 
√w
 
BundÀ
 {

12 
vÆ
 
˛ock
 = 
	`Clock
(
INPUT
)

13 
vÆ
 
addªss
 = 
	`UI¡
(
INPUT
, 
	`log2Ceû
(
c
.
dïth
))

14 
vÆ
 
€
 = 
	`Boﬁ
(
INPUT
)

15 
vÆ
 
me
 = 
	`Boﬁ
(
INPUT
)

16 
vÆ
 
q
 = 
	`UI¡
(
OUTPUT
, 
c
.
width
)

19 
ovîride
 
def
 
desúedName
: 
Såög
 = 
c
.
«me


20 
	}
}

22 
obje˘
 
ROMGíî©‹
 {

23 
¥iv©e
 
v¨
 
föÆized
 = 
Ál£


24 
¥iv©e
 
vÆ
 
roms
 = 
HashM≠
[
BœckBoxedROM
, 
ROMC⁄fig
]()

25 
def
 
≠∂y
(
c
: 
ROMC⁄fig
): 
BœckBoxedROM
 = {

26 
ªquúe
(!
föÆized
)

27 
vÆ
 
m
 = 
ModuÀ
(
√w
 
BœckBoxedROM
(
c
))

28 
roms
(
m
Ë
c


29 
m


31 
def
 
lookup
(
m
: 
BœckBoxedROM
): 
ROMC⁄fig
 = {

32 
föÆized
 = 
åue


33 
roms
(
m
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/RationalCrossing.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


14 
£Æed
 
åaô
 
	gR©i⁄ÆDúe˘i⁄
 {

15 
def
 
	gÊù
: 
R©i⁄ÆDúe˘i⁄


23 
obje˘
 
Symmëric
 
exãnds
 
R©i⁄ÆDúe˘i⁄
 {

24 
def
 
Êù
 = 
Symmëric


32 
obje˘
 
FÀxibÀ
 
exãnds
 
R©i⁄ÆDúe˘i⁄
 {

33 
def
 
Êù
 = 
FÀxibÀ


39 
obje˘
 
Fa°ToSlow
 
exãnds
 
R©i⁄ÆDúe˘i⁄
 {

40 
def
 
Êù
 = 
SlowToFa°


46 
obje˘
 
SlowToFa°
 
exãnds
 
R©i⁄ÆDúe˘i⁄
 {

47 
def
 
Êù
 = 
Fa°ToSlow


50 
föÆ
 
˛ass
 
R©i⁄ÆIO
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
BundÀ


52 
vÆ
 
bôs0
 = 
gí
.
chi£lCl⁄eTy≥


53 
vÆ
 
bôs1
 = 
gí
.
chi£lCl⁄eTy≥


54 
vÆ
 
vÆid
 = 
Boﬁ
()

55 
vÆ
 
sour˚
 = 
UI¡
(
width
 = 2)

56 
vÆ
 
ªady
 = 
Boﬁ
().
Êù


57 
vÆ
 
sök
 = 
UI¡
(
width
 = 2).
Êù


59 
ovîride
 
def
 
˛⁄eTy≥
: 
this
.
ty≥
 = 
√w
 
R©i⁄ÆIO
(
gí
).
asIn°™˚Of
[this.type]

62 
obje˘
 
R©i⁄ÆIO


64 
def
 
≠∂y
[
T
 <: 
D©a
](
gí
: TË
√w
 
R©i⁄ÆIO
(gen)

67 
˛ass
 
R©i⁄ÆCrossögSour˚
[
T
 <: 
D©a
](
gí
: T, 
	gdúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
Ë
exãnds
 
ModuÀ


69 
vÆ
 
io
 = 
√w
 
BundÀ
 {

70 
vÆ
 
íq
 = 
Decou∂edIO
(
gí
).
Êù


71 
vÆ
 
deq
 = 
R©i⁄ÆIO
(
gí
)

74 
vÆ
 
deq
 = 
io
.deq

75 
vÆ
 
íq
 = 
dúe˘i⁄
 
m©ch
 {

76 
Symmëric
 => 
Shi·Queue
(
io
.
íq
, 1, 
Êow
=
åue
)

77 
FÀxibÀ
 => 
Shi·Queue
(
io
.
íq
, 2)

78 
	gFa°ToSlow
 => 
io
.
íq


79 
SlowToFa°
 => 
Shi·Queue
(
io
.
íq
, 2)

82 
vÆ
 
	gcou¡
 = 
RegInô
(
UI¡
(0, 
width
 = 2))

83 
vÆ
 
equÆ
 = 
cou¡
 ==
deq
.
sök


85 
deq
.
vÆid
 :
íq
.valid

86 
deq
.
sour˚
 :
cou¡


87 
deq
.
bôs0
 :
íq
.
bôs


88 
deq
.
bôs1
 :
RegE«bÀ
(
íq
.
bôs
, 
equÆ
)

89 
	gíq
.
	gªady
 :
Mux
(
equÆ
, 
deq
.
ªady
, 
cou¡
(1Ë=/deq.
sök
(0))

91 
whí
 (
íq
.
fúe
()Ë{ 
cou¡
 :
C©
(count(0), !count(1)) }

94 
dúe˘i⁄
 
	gm©ch
 {

95 
	gSymmëric
 => ()

96 
FÀxibÀ
 => ()

97 
Fa°ToSlow
 => 
as£π
 (
equÆ
 || 
cou¡
(1Ë==
deq
.
sök
(0))

98 
SlowToFa°
 => 
as£π
 (
equÆ
 || 
cou¡
(1Ë=/
deq
.
sök
(0))

102 
˛ass
 
	gR©i⁄ÆCrossögSök
[
T
 <: 
D©a
](
gí
: T, 
	gdúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
Ë
exãnds
 
ModuÀ


104 
vÆ
 
io
 = 
√w
 
BundÀ
 {

105 
vÆ
 
íq
 = 
R©i⁄ÆIO
(
gí
).
Êù


106 
vÆ
 
deq
 = 
Decou∂edIO
(
gí
)

109 
vÆ
 
íq
 = 
io
.enq

110 
vÆ
 
deq
 = 
Wúe
(
io
.deq)

111 
dúe˘i⁄
 
m©ch
 {

112 
Symmëric
 => 
io
.
deq
 <> 
Shi·Queue
(deq, 1, 
pùe
=
åue
)

113 
FÀxibÀ
 => 
io
.
deq
 <> 
Shi·Queue
(deq, 2)

114 
	gFa°ToSlow
 => 
io
.
deq
 <> 
Shi·Queue
(deq, 2)

115 
	gSlowToFa°
 => 
io
.
deq
 <> deq

118 
vÆ
 
	gcou¡
 = 
RegInô
(
UI¡
(0, 
width
 = 2))

119 
vÆ
 
equÆ
 = 
cou¡
 ==
íq
.
sour˚


121 
íq
.
ªady
 :
deq
.ready

122 
íq
.
sök
 :
cou¡


123 
deq
.
bôs
 :
Mux
(
equÆ
, 
íq
.
bôs0
,Énq.
bôs1
)

124 
	gdeq
.
	gvÆid
 :
Mux
(
equÆ
, 
íq
.
vÆid
, 
cou¡
(1Ë=/íq.
sour˚
(0))

126 
whí
 (
deq
.
fúe
()Ë{ 
cou¡
 :
C©
(count(0), !count(1)) }

129 
dúe˘i⁄
 
	gm©ch
 {

130 
	gSymmëric
 => ()

131 
FÀxibÀ
 => ()

132 
Fa°ToSlow
 => 
as£π
 (
equÆ
 || 
cou¡
(1Ë=/
íq
.
sour˚
(0))

133 
SlowToFa°
 => 
as£π
 (
equÆ
 || 
cou¡
(1Ë==
íq
.
sour˚
(0))

137 
˛ass
 
	gR©i⁄ÆCrossögFuŒ
[
T
 <: 
D©a
](
gí
: T, 
	gdúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
Ë
exãnds
 
ModuÀ


139 
vÆ
 
io
 = 
√w
 
CrossögIO
(
gí
)

141 
vÆ
 
sour˚
 = 
ModuÀ
(
√w
 
R©i⁄ÆCrossögSour˚
(
gí
, 
dúe˘i⁄
))

142 
vÆ
 
	gsök
 = 
ModuÀ
(
√w
 
R©i⁄ÆCrossögSök
(
gí
, 
dúe˘i⁄
))

144 
	gsour˚
.
	g˛ock
 :
io
.
íq_˛ock


145 
sour˚
.
ª£t
 :
io
.
íq_ª£t


146 
sök
 .
˛ock
 :
io
.
deq_˛ock


147 
sök
 .
ª£t
 :
io
.
deq_ª£t


149 
sour˚
.
io
.
íq
 <> io.enq

150 
io
.
deq
 <> 
sök
.io.deq

153 
obje˘
 
ToR©i⁄Æ


155 
def
 
≠∂y
[
T
 <: 
D©a
](
x
: 
Decou∂edIO
[T], 
	gdúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
): 
R©i⁄ÆIO
[T] = {

156 
vÆ
 
sour˚
 = 
ModuÀ
(
√w
 
R©i⁄ÆCrossögSour˚
(
x
.
bôs
, 
dúe˘i⁄
))

157 
	gsour˚
.
	gio
.
	gíq
 <> 
x


158 
	gsour˚
.
	gio
.
	gdeq


162 
obje˘
 
	gFromR©i⁄Æ


164 
def
 
	g≠∂y
[
T
 <: 
D©a
](
x
: 
R©i⁄ÆIO
[T], 
	gdúe˘i⁄
: 
R©i⁄ÆDúe˘i⁄
 = 
Symmëric
): 
Decou∂edIO
[T] = {

165 
vÆ
 
sök
 = 
ModuÀ
(
√w
 
R©i⁄ÆCrossögSök
(
x
.
bôs0
, 
dúe˘i⁄
))

166 
	gsök
.
	gio
.
	gíq
 <> 
x


167 
	gsök
.
	gio
.
	gdeq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReduceOthers.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


7 
obje˘
 
	gRedu˚Othîs
 {

10 
def
 
≠∂y
(
x
: 
Seq
[
Boﬁ
]): Seq[Bool] = {

11 
vÆ
 (
lôîÆs
, 
v¨übÀs
Ë
x
.
∑πôi⁄
(
_
.
isLô
)

13 
vÆ
 
Ál£s
 = 
lôîÆs
.
cou¡
(
_
.
lôVÆue
 == 0)

14 i‡(
Ál£s
 > 2) {

15 
Seq
.
fûl
(
x
.
size
Ë{ 
Boﬁ
(
Ál£
) }

16 } i‡(
Ál£s
 == 1) {

17 
x
.
m≠
 { 
b
 =>

18 i‡(
b
.
isLô
 && b.
lôVÆue
 == 0) {

19 
v¨übÀs
.
fﬁdLe·
(
Boﬁ
(
åue
))(
_
 && _)

21 
Boﬁ
(
Ál£
)

25 
v¨
 (
out
, 
Æl
Ë
hñ≥r
(
v¨übÀs
)

26 
x
.
m≠
 { 
b
 =>

27 i‡(
b
.
isLô
) {

28 
Æl


30 
vÆ
 
£l
 = 
out
.
hód


31 
out
 = out.
èû


32 
£l


38 
def
 
≠∂y
(
x
: 
Seq
[(
Boﬁ
, Bool)]) {

39 (
	gx
.
m≠
(
_
.
_1
Ë
zù
 
≠∂y
(
x
.m≠(_.
_2
))Ë
	gf‹óch
 { (
	gw
, xË=> 
w
 := x }

41 
¥iv©e
 
def
 
hñ≥r
(
x
: 
Seq
[
Boﬁ
]): (Seq[Boﬁ], 
	gBoﬁ
) = {

42 i‡(
x
.
size
 <= 1) {

43 (
Seq
.
fûl
(
x
.
size
Ë{ 
Boﬁ
(
åue
Ë}, x.
hódO±i⁄
.
gëOrEl£
(Bool(true)))

44 } i‡(
x
.
size
 <= 3) {

45 (
Seq
.
èbuœã
(
x
.
size
Ë{ 
i
 =>

46 (
x
.
èke
(
i
Ë++ x.
dr›
(i+1)).
ªdu˚
(
_
 && _)

47 }, 
	gx
.
ªdu˚
(
_
 && _))

49 
vÆ
 (
hÆf
, 
Æl
Ë
hñ≥r
(
x
.
grou≥d
(2).
m≠
(
_
.
ªdu˚
(_ && _)).
toLi°
)

50 (
Seq
.
èbuœã
(
x
.
size
Ë{ 
i
 =>

51 i‡((
i
 ^ 1Ë>
x
.
size
Ë
hÆf
(i/2) x(i ^ 1) && half(i / 2)

52 }, 
	gÆl
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReorderQueue.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


8 
˛ass
 
	gRe‹dîQueueWrôe
[
T
 <: 
D©a
](
dTy≥
: T, 
	gègWidth
: 
I¡
Ë
exãnds
 
BundÀ
 {

9 
vÆ
 
d©a
 = 
dTy≥
.
˛⁄eTy≥


10 
vÆ
 
èg
 = 
UI¡
(
width
 = 
ègWidth
)

12 
ovîride
 
def
 
˛⁄eTy≥
 =

13 
√w
 
Re‹dîQueueWrôe
(
dTy≥
, 
ègWidth
).
	gasIn°™˚Of
[
this
.
ty≥
]

16 
˛ass
 
	gRe‹dîEnqueueIO
[
T
 <: 
D©a
](
dTy≥
: T, 
	gègWidth
: 
I¡
)

17 
exãnds
 
Decou∂edIO
(
√w
 
	$Re‹dîQueueWrôe
(
dTy≥
, 
ègWidth
)) {

19 
ovîride
 
def
 
˛⁄eTy≥
 =

20 
√w
 
	`Re‹dîEnqueueIO
(
dTy≥
, 
ègWidth
).
asIn°™˚Of
[
this
.
ty≥
]

21 
	}
}

23 
˛ass
 
	gRe‹dîDequeueIO
[
T
 <: 
D©a
](
dTy≥
: T, 
	gègWidth
: 
I¡
Ë
exãnds
 
BundÀ
 {

24 
vÆ
 
vÆid
 = 
Boﬁ
(
INPUT
)

25 
vÆ
 
èg
 = 
UI¡
(
INPUT
, 
ègWidth
)

26 
vÆ
 
	gd©a
 = 
dTy≥
.
˛⁄eTy≥
.
asOuçut


27 
vÆ
 
m©ches
 = 
Boﬁ
(
OUTPUT
)

29 
ovîride
 
def
 
˛⁄eTy≥
 =

30 
√w
 
Re‹dîDequeueIO
(
dTy≥
, 
ègWidth
).
	gasIn°™˚Of
[
this
.
ty≥
]

33 
˛ass
 
	gRe‹dîQueue
[
T
 <: 
D©a
](
dTy≥
: T, 
	gègWidth
: 
I¡
, 
	gsize
: 
O±i⁄
[I¡] = 
N⁄e
)

34 
exãnds
 
ModuÀ
 {

35 
vÆ
 
io
 = 
√w
 
BundÀ
 {

36 
vÆ
 
íq
 = 
√w
 
Re‹dîEnqueueIO
(
dTy≥
, 
ègWidth
).
Êù


37 
vÆ
 
	gdeq
 = 
√w
 
Re‹dîDequeueIO
(
dTy≥
, 
ègWidth
)

40 
vÆ
 
	gègS∑˚Size
 = 1 << 
ègWidth


41 
vÆ
 
a˘uÆSize
 = 
size
.
gëOrEl£
(
ègS∑˚Size
)

43 i‡(
ègS∑˚Size
 > 
a˘uÆSize
) {

44 
vÆ
 
roq_d©a
 = 
Reg
(
Vec
(
a˘uÆSize
, 
dTy≥
))

45 
vÆ
 
	groq_ègs
 = 
Reg
(
Vec
(
a˘uÆSize
, 
UI¡
(
width
 = 
ègWidth
)))

46 
vÆ
 
roq_‰ì
 = 
Reg
(
öô
 = 
Vec
.
fûl
(
a˘uÆSize
)(
Boﬁ
(
åue
)))

48 
vÆ
 
roq_íq_addr
 = 
Pri‹ôyEncodî
(
roq_‰ì
)

49 
vÆ
 
roq_m©ches
 = 
roq_ègs
.
zù
(
roq_‰ì
)

50 .
m≠
 { (
èg
, 
‰ì
Ë=>Åag ==
io
.
deq
.tag && !free }

51 
vÆ
 
	groq_deq_⁄ehŸ
 = 
Pri‹ôyEncodîOH
(
roq_m©ches
)

53 
io
.
íq
.
ªady
 :
roq_‰ì
.
ªdu˚
(
_
 || _)

54 
io
.
deq
.
d©a
 :
Mux1H
(
roq_deq_⁄ehŸ
, 
roq_d©a
)

55 
	gio
.
	gdeq
.
	gm©ches
 :
roq_m©ches
.
ªdu˚
(
_
 || _)

57 
whí
 (
io
.
íq
.
vÆid
 && io.íq.
ªady
) {

58 
roq_d©a
(
roq_íq_addr
Ë:
io
.
íq
.
bôs
.
d©a


59 
roq_ègs
(
roq_íq_addr
Ë:
io
.
íq
.
bôs
.
èg


60 
roq_‰ì
(
roq_íq_addr
Ë:
Boﬁ
(
Ál£
)

63 
whí
 (
io
.
deq
.
vÆid
) {

64 
roq_‰ì
(
OHToUI¡
(
roq_deq_⁄ehŸ
)Ë:
Boﬁ
(
åue
)

67 
¥öén
(
s
"Warning - usingá CAM for ReorderQueue,ÅagBits: ${tagWidth} size: ${actualSize}")

69 
vÆ
 
roq_d©a
 = 
Mem
(
ègS∑˚Size
, 
dTy≥
)

70 
vÆ
 
	groq_‰ì
 = 
Reg
(
öô
 = 
Vec
.
fûl
(
ègS∑˚Size
)(
Boﬁ
(
åue
)))

72 
io
.
íq
.
ªady
 :
roq_‰ì
(io.íq.
bôs
.
èg
)

73 
io
.
deq
.
d©a
 :
roq_d©a
(io.deq.
èg
)

74 
io
.
deq
.
m©ches
 :!
roq_‰ì
(io.deq.
èg
)

76 
whí
 (
io
.
íq
.
vÆid
 && io.íq.
ªady
) {

77 
roq_d©a
(
io
.
íq
.
bôs
.
èg
Ë:io.íq.bôs.
d©a


78 
roq_‰ì
(
io
.
íq
.
bôs
.
èg
Ë:
Boﬁ
(
Ál£
)

81 
whí
 (
io
.
deq
.
vÆid
) {

82 
roq_‰ì
(
io
.
deq
.
èg
Ë:
Boﬁ
(
åue
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Repeater.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


9 
˛ass
 
	gRïóãr
[
T
 <: 
D©a
](
gí
: TË
exãnds
 
ModuÀ


11 
vÆ
 
io
 = 
√w
 
BundÀ
 {

12 
vÆ
 
ª≥©
 = 
Boﬁ
(
INPUT
)

13 
vÆ
 
fuŒ
 = 
Boﬁ
(
OUTPUT
)

14 
vÆ
 
íq
 = 
Decou∂ed
(
gí
).
Êù


15 
vÆ
 
deq
 = 
Decou∂ed
(
gí
)

18 
vÆ
 
fuŒ
 = 
RegInô
(
Boﬁ
(
Ál£
))

19 
vÆ
 
ßved
 = 
Reg
(
gí
)

22 
io
.
deq
.
vÆid
 :io.
íq
.vÆid || 
fuŒ


23 
io
.
íq
.
ªady
 :io.
deq
.ªady && !
fuŒ


24 
io
.
deq
.
bôs
 :
Mux
(
fuŒ
, 
ßved
, io.
íq
.bits)

25 
	gio
.
	gfuŒ
 :
fuŒ


27 
whí
 (
io
.
íq
.
fúe
(Ë&& io.
ª≥©
Ë{ 
fuŒ
 :
Boﬁ
(
åue
); 
	gßved
 :io.íq.
bôs
 }

28 
whí
 (
io
.
deq
.
fúe
(Ë&& !io.
ª≥©
Ë{ 
fuŒ
 :
Boﬁ
(
Ál£
) }

31 
obje˘
 
Rïóãr


33 
def
 
≠∂y
[
T
 <: 
D©a
](
íq
: 
Decou∂edIO
[T], 
	gª≥©
: 
Boﬁ
): DecoupledIO[T] = {

34 
vÆ
 
ª≥©î
 = 
ModuÀ
(
√w
 
Rïóãr
(
íq
.
bôs
))

35 
ª≥©î
.
io
.
ª≥©
 :=Ñepeat

36 
ª≥©î
.
io
.
íq
 :=Énq

37 
ª≥©î
.
io
.
deq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Replacement.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


8 
ab°ø˘
 cœs†
	cRïœ˚mítPﬁicy
 {

9 
def
 
	mway
: 
UI¡


10 
def
 
miss
: 
Unô


11 
def
 
hô
: 
Unô


14 ˛as†
	cR™domRïœ˚mít
(
ways
: 
I¡
Ë
exãnds
 
Rïœ˚mítPﬁicy
 {

15 
¥iv©e
 
vÆ
 
ª∂a˚
 = 
	`Wúe
(
	$Boﬁ
())

16 
ª∂a˚
 :
	$Boﬁ
(
Ál£
)

17 
vÆ
 
lf§
 = 
	$LFSR16
(
ª∂a˚
)

19 
def
 
way
 = if(
ways
 =1Ë
	$UI¡
(0Ë
	`lf§
(
	`log2Up
(
ways
)-1,0)

20 
def
 
miss
 = 
ª∂a˚
 :
	$Boﬁ
(
åue
)

21 
def
 
hô
 = {}

22 
	}
}

24 
ab°ø˘
 cœs†
	cSeqRïœ˚mítPﬁicy
 {

25 
def
 
	$ac˚ss
(
£t
: 
UI¡
): 
Unô


26 
def
 
	$upd©e
(
vÆid
: 
Boﬁ
, 
hô
: Boﬁ, 
£t
: 
UI¡
, 
way
: UI¡): 
Unô


27 
def
 
way
: 
UI¡


30 ˛as†
	cSeqR™dom
(
n_ways
: 
I¡
Ë
exãnds
 
SeqRïœ˚mítPﬁicy
 {

31 
vÆ
 
logic
 = 
√w
 
	$R™domRïœ˚mít
(
n_ways
)

32 
def
 
	`ac˚ss
(
£t
: 
UI¡
) = { }

33 
def
 
	`upd©e
(
vÆid
: 
Boﬁ
, 
hô
: Boﬁ, 
£t
: 
UI¡
, 
way
: UInt) = {

34 
	`whí
 (
vÆid
 && !
hô
Ë{ 
logic
.
miss
 }

35 
	}
}

36 
def
 
way
 = 
logic
.way

39 ˛as†
	cP£udoLRU
(
n
: 
I¡
)

41 
¥iv©e
 
vÆ
 
°©e_ªg
 = 
	`Reg
(
	`UI¡
(
width
 = 
n
-1))

42 
def
 
	$ac˚ss
(
way
: 
UI¡
) {

43 
°©e_ªg
 :
	`gë_√xt_°©e
(°©e_ªg,
way
)

45 
def
 
	`gë_√xt_°©e
(
°©e
: 
UI¡
, 
way
: UInt) = {

46 
v¨
 
√xt_°©e
 = 
°©e
 << 1

47 
v¨
 
idx
 = 
	`UI¡
(1,1)

48 
i
 <- 
	`log2Up
(
n
)-1 
to
 0 
by
 -1) {

49 
vÆ
 
bô
 = 
	`way
(
i
)

50 
√xt_°©e
 =Çext_°©e.
	`bôSë
(
idx
, !
bô
)

51 
idx
 = 
	`C©
(idx, 
bô
)

53 
√xt_°©e
.
	`exåa˘
(
n
-1, 1)

54 
	}
}

55 
def
 
	gª∂a˚
 = 
	$gë_ª∂a˚_way
(
°©e_ªg
)

56 
def
 
	`gë_ª∂a˚_way
(
°©e
: 
UI¡
) = {

57 
vÆ
 
shi·ed_°©e
 = 
°©e
 << 1

58 
v¨
 
idx
 = 
	`UI¡
(1,1)

59 
i
 <- 
	`log2Up
(
n
)-1 
to
 0 
by
 -1) {

60 
vÆ
 
ö_bounds
 = 
	`C©
(
idx
, 
	`UI¡
(
	`BigI¡
(1Ë<< 
i
))(
	`log2Up
(
n
)-1, 0) < UInt(n)

61 
idx
 = 
	`C©
(idx, 
ö_bounds
 && 
	`shi·ed_°©e
(idx))

63 
	`idx
(
	`log2Up
(
n
)-1,0)

64 
	}
}

67 
˛ass
 
	$SeqPLRU
(
n_£ts
: 
I¡
, 
n_ways
: I¡Ë
exãnds
 
SeqRïœ˚mítPﬁicy
 {

68 
vÆ
 
°©e
 = 
	`SeqMem
(
n_£ts
, 
	`UI¡
(
width
 = 
n_ways
-1))

69 
vÆ
 
logic
 = 
√w
 
	`P£udoLRU
(
n_ways
)

70 
vÆ
 
cuºít_°©e
 = 
	`Wúe
(
	`UI¡
())

71 
vÆ
 
∂ru_way
 = 
logic
.
	`gë_ª∂a˚_way
(
cuºít_°©e
)

72 
vÆ
 
√xt_°©e
 = 
	`Wúe
(
	`UI¡
())

74 
def
 
	`ac˚ss
(
£t
: 
UI¡
) = {

75 
cuºít_°©e
 :
°©e
.
	`ªad
(
£t
)

78 
def
 
	`upd©e
(
vÆid
: 
Boﬁ
, 
hô
: Boﬁ, 
£t
: 
UI¡
, 
way
: UInt) = {

79 
vÆ
 
upd©e_way
 = 
	`Mux
(
hô
, 
way
, 
∂ru_way
)

80 
√xt_°©e
 :
logic
.
	`gë_√xt_°©e
(
cuºít_°©e
, 
upd©e_way
)

81 
	`whí
 (
vÆid
Ë{ 
°©e
.
	`wrôe
(
£t
, 
√xt_°©e
) }

84 
def
 
way
 = 
∂ru_way


85 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ResetCatchAndSync.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gchi£l3
.
	gex≥rimíèl
.{
	gwôhClockAndRe£t
, 
	gwôhRe£t
}

13 
˛ass
 
	$Re£tC©chAndSync
 (
sync
: 
I¡
 = 3Ë
exãnds
 
ModuÀ
 {

15 
ovîride
 
def
 
desúedName
 = 
s
"ResetCatchAndSync_d${sync}"

17 
vÆ
 
io
 = 
√w
 
BundÀ
 {

18 
vÆ
 
sync_ª£t
 = 
	`Boﬁ
(
OUTPUT
)

19 
vÆ
 
psd
 = 
√w
 
	`PSDTe°Mode
().
asI≈ut


26 
vÆ
 
po°_psd_ª£t
 = 
	`Mux
(
io
.
psd
.
ã°_mode
, io.psd.
ã°_mode_ª£t
, 
ª£t
)

27 
	`wôhRe£t
(
po°_psd_ª£t
) {

28 
io
.
sync_ª£t
 :
	`Mux
(io.
psd
.
ã°_mode
, io.psd.
ã°_mode_ª£t
,

29 ~
	`AsyncRe£tSynchr⁄izîShi·Reg
(
	`Boﬁ
(
åue
), 
sync
))

31 
	}
}

33 
obje˘
 
	gRe£tC©chAndSync
 {

35 
def
 
≠∂y
(
˛k
: 
Clock
, 
r°
: 
Boﬁ
, 
sync
: 
I¡
 = 3, 
«me
: 
O±i⁄
[
Såög
] = 
N⁄e
,

36 
psd
: 
O±i⁄
[
PSDTe°Mode
] = 
N⁄e
): 
Boﬁ
 = {

38 
wôhClockAndRe£t
(
˛k
, 
r°
) {

39 
vÆ
 
ˇtchî
 = 
ModuÀ
 (
√w
 
Re£tC©chAndSync
(
sync
))

40 i‡(
«me
.
isDeföed
Ë{
ˇtchî
.
sugge°Name
“ame.
gë
)}

41 
ˇtchî
.
io
.
psd
 <>Ösd.
gëOrEl£
(
Wúe
(
√w
 
PSDTe°Mode
()).
‰omBôs
(
UI¡
(0)))

42 
ˇtchî
.
io
.
sync_ª£t


46 
def
 
≠∂y
(
˛k
: 
Clock
, 
r°
: 
Boﬁ
, 
sync
: 
I¡
, 
«me
: 
Såög
): Boﬁ =áµly(˛k,Ñ°, sync, 
Some
(name))

47 
def
 
≠∂y
(
˛k
: 
Clock
, 
r°
: 
Boﬁ
, 
«me
: 
Såög
): Boﬁ =áµly(˛k,Ñ°,Çamê
Some
(name))

49 
def
 
≠∂y
(
˛k
: 
Clock
, 
r°
: 
Boﬁ
, 
sync
: 
I¡
, 
«me
: 
Såög
, 
psd
: 
PSDTe°Mode
): Bool =

50 
≠∂y
(
˛k
, 
r°
, 
sync
, 
Some
(
«me
), Some(
psd
))

51 
def
 
≠∂y
(
˛k
: 
Clock
, 
r°
: 
Boﬁ
, 
«me
: 
Såög
, 
psd
: 
PSDTe°Mode
): Bool =

52 
≠∂y
(
˛k
, 
r°
, 
«me
 = 
Some
“ame), 
psd
 = Some(psd))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/SeededRandom.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


9 
obje˘
 
	gSìdedR™dom
 {

10 
vÆ
 
	g‰omSìd
 = 
√w
 
sˇœ
.
utû
.
R™dom
(42)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftQueue.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


11 
˛ass
 
	gShi·Queue
[
T
 <: 
D©a
](
gí
: T,

12 
vÆ
 
	gíåõs
: 
I¡
,

13 
	gpùe
: 
Boﬁón
 = 
Ál£
,

14 
	gÊow
: 
Boﬁón
 = 
Ál£
)

15 
exãnds
 
ModuÀ
 {

16 
vÆ
 
io
 = 
IO
(
√w
 
QueueIO
(
gí
, 
íåõs
) {

17 
vÆ
 
mask
 = 
UI¡
(
OUTPUT
, 
íåõs
)

20 
¥iv©e
 
vÆ
 
	gvÆid
 = 
RegInô
(
Vec
.
fûl
(
íåõs
Ë{ 
Boﬁ
(
Ál£
) })

21 
¥iv©e
 
vÆ
 
ñts
 = 
Reg
(
Vec
(
íåõs
, 
gí
))

23 
	gi
 <- 0 
u¡û
 
	gíåõs
) {

24 
def
 
∑ddedVÆid
(
i
: 
I¡
Ëi‡(ò=-1Ë
åue
.
B
 i‡(ò=
íåõs
Ë
Ál£
.B 
vÆid
(i)

26 
vÆ
 
wd©a
 = i‡(
i
 =
íåõs
-1Ë
io
.
íq
.
bôs
 
Mux
(
vÆid
(i+1), 
ñts
(i+1), io.enq.bits)

27 
vÆ
 
	gwí
 =

28 
Mux
(
io
.
deq
.
ªady
,

29 
∑ddedVÆid
(
i
+1Ë|| 
io
.
íq
.
fúe
(Ë&& (
Boﬁ
(ò=0 && !
Êow
Ë|| 
vÆid
(i)),

30 
io
.
íq
.
fúe
(Ë&& 
∑ddedVÆid
(
i
-1Ë&& !
vÆid
(i))

31 
whí
 (
wí
Ë{ 
ñts
(
i
Ë:
wd©a
 }

33 
vÆid
(
i
) :=

34 
Mux
(
io
.
deq
.
ªady
,

35 
∑ddedVÆid
(
i
+1Ë|| 
io
.
íq
.
fúe
(Ë&& (
Boﬁ
(ò=0 && !
Êow
Ë|| 
vÆid
(i)),

36 
io
.
íq
.
fúe
(Ë&& 
∑ddedVÆid
(
i
-1Ë|| 
vÆid
(i))

39 
	gio
.
	gíq
.
	gªady
 :!
vÆid
(
íåõs
-1)

40 
io
.
deq
.
vÆid
 := valid(0)

41 
io
.
deq
.
bôs
 :
ñts
.
hód


43 i‡(
Êow
) {

44 
whí
 (
io
.
íq
.
vÆid
Ë{ io.
deq
.vÆid :
åue
.
B
 }

45 
whí
 (!
vÆid
(0)Ë{ 
io
.
deq
.
bôs
 :io.
íq
.bits }

48 i‡(
pùe
) {

49 
whí
 (
io
.
deq
.
ªady
Ë{ io.
íq
.ªady :
åue
.
B
 }

52 
io
.
mask
 :
vÆid
.
asUI¡


53 
io
.
cou¡
 :
P›Cou¡
(io.
mask
)

56 
obje˘
 
Shi·Queue


58 
def
 
≠∂y
[
T
 <: 
D©a
](
íq
: 
Decou∂edIO
[T], 
	gíåõs
: 
I¡
 = 2, 
	gpùe
: 
Boﬁón
 = 
Ál£
, 
	gÊow
: Boolean = false): DecoupledIO[T] = {

59 
vÆ
 
q
 = 
ModuÀ
(
√w
 
Shi·Queue
(
íq
.
bôs
.
˛⁄eTy≥
, 
íåõs
, 
pùe
, 
Êow
))

60 
	gq
.
	gio
.
	gíq
 <> 
íq


61 
	gq
.
	gio
.
	gdeq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftReg.scala

3 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


5 
imp‹t
 
	gChi£l
.
_


10 
obje˘
 
	gShi·RegInô
 {

11 
def
 
	g≠∂y
[
T
 <: 
D©a
](
ö
: T, 
	gn
: 
I¡
, 
	göô
: T, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): T =

13 (0 
u¡û
 
n
).
fﬁdRight
(
ö
) {

14 (
i
, 
√xt
) => {

15 
vÆ
 
r
 = 
Reg
(
√xt
,Çexà√xt, 
öô
 = init)

16 
«me
.
f‹óch
 { 
«
 => 
r
.
sugge°Name
(
s
"${na}_${i}") }

17 
	gr


38 
ab°ø˘
 
˛ass
 
	$Ab°ø˘PùñöeReg
(
w
: 
I¡
 = 1Ë
exãnds
 
ModuÀ
 {

39 
vÆ
 
io
 = 
√w
 
BundÀ
 {

40 
vÆ
 
d
 = 
	`UI¡
(
INPUT
, 
width
 = 
w
)

41 
vÆ
 
q
 = 
	`UI¡
(
OUTPUT
, 
width
 = 
w
)

43 
	}
}

45 
obje˘
 
	gAb°ø˘PùñöeReg
 {

46 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
gí
: => 
Ab°ø˘PùñöeReg
, 
	gö
: T, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): T = {

47 
vÆ
 
chaö
 = 
ModuÀ
(
gí
)

48 
«me
.
f‹óch
{ 
chaö
.
sugge°Name
(
_
) }

49 
chaö
.
io
.
d
 :
ö
.
asUI¡


50 
chaö
.
io
.
q
.
asTy≥Of
(
ö
)

54 
˛ass
 
AsyncRe£tShi·Reg
(
w
: 
I¡
 = 1, 
dïth
: I¡ = 1, 
öô
: I¡ = 0, 
«me
: 
Såög
 = "pùe"Ë
exãnds
 
	$Ab°ø˘PùñöeReg
(
w
) {

55 
	`ªquúe
(
dïth
 > 0, "Depth must be greaterÅhan 0.")

57 
ovîride
 
def
 
desúedName
 = 
s
"AsyncResetShiftReg_w${w}_d${depth}_i${init}"

59 
vÆ
 
chaö
 = 
Li°
.
	`èbuœã
(
dïth
Ë{ 
i
 =>

60 
	`ModuÀ
 (
√w
 
	`AsyncRe£tRegVec
(
w
, 
öô
)).
	`sugge°Name
(
s
"${name}_${i}")

63 
chaö
.
œ°
.
io
.
d
 := io.d

64 
chaö
.
œ°
.
io
.
í
 :
	`Boﬁ
(
åue
)

66 (
chaö
.
öô
 
zù
 chaö.
èû
).
f‹óch
 { (
sök
, 
sour˚
) =>

67 
sök
.
io
.
d
 :
sour˚
.io.
q


68 
sök
.
io
.
í
 :
	`Boﬁ
(
åue
)

70 
io
.
q
 :
chaö
.
hód
.io.q

71 
	}
}

73 
obje˘
 
AsyncRe£tShi·Reg
 {

74 
def
 
≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	göô
: I¡ = 0, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): T =

75 
Ab°ø˘PùñöeReg
(
√w
 
AsyncRe£tShi·Reg
(
ö
.
gëWidth
, 
dïth
, 
öô
), in, 
«me
)

77 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	g«me
: 
O±i⁄
[
Såög
]): T =

78 
≠∂y
(
ö
, 
dïth
, 0, 
«me
)

80 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	göô
: T, 
	g«me
: 
O±i⁄
[
Såög
]): T =

81 
≠∂y
(
ö
, 
dïth
, 
öô
.
lôVÆue
.
toI¡
, 
«me
)

83 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	göô
: T): T =

84 
≠∂y
 (
ö
, 
dïth
, 
öô
.
lôVÆue
.
toI¡
, 
N⁄e
)

89 
˛ass
 
	$AsyncRe£tSynchr⁄izîShi·Reg
(
w
: 
I¡
 = 1, 
sync
: I¡ = 3, 
öô
: I¡ = 0Ë
exãnds
 
	`AsyncRe£tShi·Reg
(w, 
dïth
 = sync, inô, 
«me
 = "sync") {

90 
	`ªquúe
(
sync
 > 0, "Sync must be greaterÅhan 0.")

91 
ovîride
 
def
 
desúedName
 = 
s
"AsyncResetSynchronizerShiftReg_w${w}_d${sync}_i${init}"

92 
	}
}

94 
obje˘
 
	gAsyncRe£tSynchr⁄izîShi·Reg
 {

95 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	göô
: I¡ = 0, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): T =

96 
Ab°ø˘PùñöeReg
(
√w
 
AsyncRe£tSynchr⁄izîShi·Reg
(
ö
.
gëWidth
, 
dïth
, 
öô
), in, 
«me
)

98 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	g«me
: 
O±i⁄
[
Såög
]): T =

99 
≠∂y
(
ö
, 
dïth
, 0, 
«me
)

101 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	göô
: T, 
	g«me
: 
O±i⁄
[
Såög
]): T =

102 
≠∂y
(
ö
, 
dïth
, 
öô
.
lôVÆue
.
toI¡
, 
«me
)

104 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gdïth
: 
I¡
, 
	göô
: T): T =

105 
≠∂y
 (
ö
, 
dïth
, 
öô
.
lôVÆue
.
toI¡
, 
N⁄e
)

108 
˛ass
 
	$Synchr⁄izîShi·Reg
(
w
: 
I¡
 = 1, 
sync
: I¡ = 3Ë
exãnds
 
	$Ab°ø˘PùñöeReg
(
w
) {

109 
	`ªquúe
(
sync
 > 0, "Sync must be greaterÅhan 0.")

111 
ovîride
 
def
 
desúedName
 = 
s
"SynchronizerShiftReg_w${w}_d${sync}"

113 
vÆ
 
syncv
 = 
Li°
.
	`èbuœã
(
sync
Ë{ 
i
 =>

114 
vÆ
 
r
 = 
	`Reg
(
	`UI¡
(
width
 = 
w
))

115 
r
.
	`sugge°Name
(
s
"sync_${i}")

118 
syncv
.
œ°
 :
io
.
d


120 (
syncv
.
öô
 
zù
 syncv.
èû
).
f‹óch
 { (
sök
, 
sour˚
) =>

121 
sök
 :
sour˚


123 
io
.
q
 :
syncv
.
hód


124 
	}
}

127 
obje˘
 
Synchr⁄izîShi·Reg
 {

128 
def
 
≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gsync
: 
I¡
 = 3, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): T = {

129 i‡(
sync
 =0Ë
ö


130 
Ab°ø˘PùñöeReg
(
√w
 
Synchr⁄izîShi·Reg
(
ö
.
gëWidth
, 
sync
), in, 
«me
)

134 
˛ass
 
	$SyncRe£tSynchr⁄izîShi·Reg
(
w
: 
I¡
 = 1, 
sync
: I¡ = 3, 
öô
: I¡ = 0Ë
exãnds
 
	$Ab°ø˘PùñöeReg
(
w
) {

135 
	`ªquúe
 (
sync
 >= 0, "Sync must be greaterÅhan orÉqualÅo 0")

137 
ovîride
 
def
 
desúedName
 = 
s
"SyncResetSynchronizerShiftReg_w${w}_d${sync}_i${init}"

139 
io
.
q
 :
	`Shi·RegInô
(io.
d
, 
n
 = 
sync
, 
öô
 = inô.
U
, 
«me
 = 
	`Some
("sync"))

141 
	}
}

143 
obje˘
 
	gSyncRe£tSynchr⁄izîShi·Reg
 {

144 
def
 
	g≠∂y
 [
T
 <: 
Chi£l
.
D©a
](
ö
: T, 
	gsync
: 
I¡
 = 3, 
	göô
: T, 
	g«me
: 
O±i⁄
[
Såög
] = 
N⁄e
): T =

145 
Ab°ø˘PùñöeReg
(
√w
 
SyncRe£tSynchr⁄izîShi·Reg
(
ö
.
gëWidth
, 
sync
, 
öô
.
lôVÆue
.
toI¡
), in, 
«me
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Timer.scala

4 
∑ckage
 
	g‰ìchùs
.
	grockëchù
.
utû


6 
imp‹t
 
	gChi£l
.
_


12 
˛ass
 
	$Timî
(
öôCou¡
: 
I¡
, 
maxInÊight
: I¡Ë
exãnds
 
ModuÀ
 {

13 
vÆ
 
io
 = 
√w
 
BundÀ
 {

14 
vÆ
 
°¨t
 = 
	`VÆid
(
	`UI¡
(
width
 = 
	`log2Up
(
maxInÊight
))).
Êù


15 
vÆ
 
°›
 = 
	`VÆid
(
	`UI¡
(
width
 = 
	`log2Up
(
maxInÊight
))).
Êù


16 
vÆ
 
timeout
 = 
	`VÆid
(
	`UI¡
(
width
 = 
	`log2Up
(
maxInÊight
)))

19 
vÆ
 
öÊight
 = 
	`Reg
(
öô
 = 
Vec
.
	`fûl
(
maxInÊight
Ë{ 
	`Boﬁ
(
Ál£
) })

20 
vÆ
 
cou¡down
 = 
	`Reg
(
	`UI¡
(
width
 = 
	`log2Up
(
öôCou¡
)))

21 
vÆ
 
a˘ive
 = 
öÊight
.
	`ªdu˚
(
_
 || _)

23 
	`whí
 (
a˘ive
Ë{ 
cou¡down
 :cou¡dow¿- 
	`UI¡
(1) }

25 
	`whí
 (
io
.
°¨t
.
vÆid
) {

26 
	`öÊight
(
io
.
°¨t
.
bôs
Ë:
	`Boﬁ
(
åue
)

27 
cou¡down
 :
	`UI¡
(
öôCou¡
 - 1)

30 
	`whí
 (
io
.
°›
.
vÆid
Ë{ 
	`öÊight
(io.°›.
bôs
Ë:
	`Boﬁ
(
Ál£
) }

32 
io
.
timeout
.
vÆid
 :
cou¡down
 ==
	`UI¡
(0Ë&& 
a˘ive


33 
io
.
timeout
.
bôs
 :
	`Pri‹ôyEncodî
(
öÊight
)

35 
	`as£π
(!
io
.
°›
.
vÆid
 || 
	`öÊight
(io.°›.
bôs
),

37 
	}
}

42 ˛as†
	cSim∂eTimî
(
öôCou¡
: 
I¡
Ë
exãnds
 
ModuÀ
 {

43 
vÆ
 
io
 = 
√w
 
BundÀ
 {

44 
vÆ
 
°¨t
 = 
	`Boﬁ
(
INPUT
)

45 
vÆ
 
°›
 = 
	`Boﬁ
(
INPUT
)

46 
vÆ
 
timeout
 = 
	`Boﬁ
(
OUTPUT
)

49 
vÆ
 
cou¡down
 = 
	`Reg
(
	`UI¡
(
width
 = 
	$log2Up
(
öôCou¡
)))

50 
vÆ
 
a˘ive
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

52 
	$whí
 (
a˘ive
Ë{ 
cou¡down
 :cou¡dow¿- 
	`UI¡
(1Ë
	}
}

54 
	$whí
 (
io
.
°¨t
) {

55 
a˘ive
 :
	`Boﬁ
(
åue
)

56 
cou¡down
 :
	`UI¡
(
öôCou¡
 - 1)

57 
	}
}

59 
	$whí
 (
io
.
°›
Ë{ 
a˘ive
 :
	`Boﬁ
(
Ál£
Ë
	}
}

61 
io
.
timeout
 :
cou¡down
 ==
UI¡
(0Ë&& 
a˘ive


64 
obje˘
 
Sim∂eTimî
 {

65 
def
 
≠∂y
(
öôCou¡
: 
I¡
, 
°¨t
: 
Boﬁ
, 
°›
: Bool): Bool = {

66 
vÆ
 
timî
 = 
ModuÀ
(
√w
 
Sim∂eTimî
(
öôCou¡
))

67 
timî
.
io
.
°¨t
 := start

68 
timî
.
io
.
°›
 := stop

69 
timî
.
io
.
timeout


74 ˛as†
	cDy«micTimî
(
w
: 
I¡
Ë
exãnds
 
ModuÀ
 {

75 
vÆ
 
io
 = 
√w
 
BundÀ
 {

76 
vÆ
 
°¨t
 = 
	`Boﬁ
(
INPUT
)

77 
vÆ
 
≥riod
 = 
	`UI¡
(
INPUT
, 
w
)

78 
vÆ
 
°›
 = 
	`Boﬁ
(
INPUT
)

79 
vÆ
 
timeout
 = 
	`Boﬁ
(
OUTPUT
)

82 
vÆ
 
cou¡down
 = 
	`Reg
(
öô
 = 
	$UI¡
(0, 
w
))

83 
vÆ
 
a˘ive
 = 
	`Reg
(
öô
 = 
	$Boﬁ
(
Ál£
))

85 
	$whí
 (
io
.
°¨t
) {

86 
cou¡down
 :
io
.
≥riod


87 
a˘ive
 :
	`Boﬁ
(
åue
)

88 
	}
} .
ñ£whí
 (
io
.
°›
 || 
cou¡down
 ==
	$UI¡
(0)) {

89 
a˘ive
 :
	`Boﬁ
(
Ál£
)

90 
	}
} .
	$ñ£whí
 (
a˘ive
) {

91 
cou¡down
 :cou¡dow¿- 
	`UI¡
(1)

92 
	}
}

94 
io
.
timeout
 :
cou¡down
 ==
UI¡
(0Ë&& 
a˘ive


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/package.scala

3 
∑ckage
 
	g‰ìchùs
.
rockëchù


5 
imp‹t
 
	gChi£l
.
_


6 
imp‹t
 
	gsˇœ
.
	gm©h
.
mö


8 
∑ckage
 
obje˘
 
	gutû
 {

9 
im∂icô
 
˛ass
 
	gUnzù∑bÀO±i⁄
[
S
, 
T
](
vÆ
 
	gx
: 
O±i⁄
[(S, T)]) {

10 
def
 
	gunzù
 = (
x
.
m≠
(
_
.
_1
), 
	gx
.m≠(_.
_2
))

13 
im∂icô
 cœs†
	cUI¡IsO√Of
(
vÆ
 
x
: 
UI¡
Ë
exãnds
 
AnyVÆ
 {

14 
def
 
	`isO√Of
(
s
: 
Seq
[
UI¡
]): 
Boﬁ
 = s.
	`m≠
(
x
 ==
_
).
	`ªdu˚
(_||_)

16 
def
 
	`isO√Of
(
u1
: 
UI¡
, 
u2
: UI¡*): 
Boﬁ
 = isO√Of(u1 +: u2.
toSeq
)

17 
	}
}

19 
im∂icô
 
˛ass
 
SeqToAugmíãdSeq
[
T
 <: 
D©a
](
vÆ
 
x
: 
Seq
[T]Ë
exãnds
 
AnyVÆ
 {

20 
def
 
≠∂y
(
idx
: 
UI¡
): 
T
 = {

21 i‡(
x
.
size
 <= 1) {

22 
x
.
hód


23 } i‡(!
isPow2
(
x
.
size
)) {

25 (
x
 ++ x.
èkeRight
(x.
size
 & -x.size)).
toSeq
(
idx
)

28 
vÆ
 
åuncIdx
 =

29 i‡(
idx
.
isWidthKnown
 && idx.
gëWidth
 <
log2Ceû
(
x
.
size
)) idx

30 (
idx
 | 
UI¡
(0, 
log2Ceû
(
x
.
size
)))(log2Ceil(x.size)-1, 0)

31 (
	gx
.
	ghód
 /: 
x
.
zùWôhIndex
.
èû
Ë{ (
¥ev
, (
	gcur
, 
	gi
)Ë=> 
Mux
(
åuncIdx
 ==
i
.
U
, 
cur
,Örev) }

35 
def
 
asUI¡
(): 
UI¡
 = 
C©
(
x
.
m≠
(
_
.asUI¡).
ªvî£
)

37 
def
 
rŸ©e
(
n
: 
I¡
): 
Seq
[
T
] = 
x
.
dr›
“Ë++ x.
èke
(n)

39 
def
 
rŸ©e
(
n
: 
UI¡
): 
Seq
[
T
] = {

40 
ªquúe
(
isPow2
(
x
.
size
))

41 
vÆ
 
amt
 = 
n
.
∑dTo
(
log2Ceû
(
x
.
size
))

42 (
x
 /: (0 
u¡û
 
log2Ceû
(x.
size
)))((
r
, 
	gi
Ë=> (r.
rŸ©e
(1 << 
i
Ë
zù
Ñ).
m≠
 { (
s
, 
a
Ë=> 
Mux
(
amt
(i), s,á) })

45 
def
 
rŸ©eRight
(
n
: 
I¡
): 
Seq
[
T
] = 
x
.
èkeRight
“Ë++ x.
dr›Right
(n)

47 
def
 
rŸ©eRight
(
n
: 
UI¡
): 
Seq
[
T
] = {

48 
ªquúe
(
isPow2
(
x
.
size
))

49 
vÆ
 
amt
 = 
n
.
∑dTo
(
log2Ceû
(
x
.
size
))

50 (
x
 /: (0 
u¡û
 
log2Ceû
(x.
size
)))((
r
, 
	gi
Ë=> (r.
rŸ©eRight
(1 << 
i
Ë
zù
Ñ).
m≠
 { (
s
, 
a
Ë=> 
Mux
(
amt
(i), s,á) })

55 
im∂icô
 
˛ass
 
	$SeqBoﬁBôwi£Ops
(
vÆ
 
x
: 
Seq
[
Boﬁ
]Ë
exãnds
 
AnyVÆ
 {

56 
def
 & (
y
: 
Seq
[
Boﬁ
]): Seq[Boﬁ] = (
x
 
zù
 y).
m≠
 { (
a
, 
b
) =>á && b }

57 
def
 | (
y
: 
Seq
[
Boﬁ
]): Seq[Boﬁ] = 
	`∑dZù
(
x
, y).
m≠
 { (
a
, 
b
) =>á || b }

58 
def
 ^ (
y
: 
Seq
[
Boﬁ
]): Seq[Boﬁ] = 
	`∑dZù
(
x
, y).
m≠
 { (
a
, 
b
) =>á ^ b }

59 
def
 << (
n
: 
I¡
): 
Seq
[
Boﬁ
] = Seq.
	`fûl
“)(
Ál£
.
B
Ë++ 
x


60 
def
 >> (
n
: 
I¡
): 
Seq
[
Boﬁ
] = 
x
 
dr›
Ç

61 
def
 
u«ry_
~(): 
Seq
[
Boﬁ
] = 
x
.
	`m≠
(!
_
)

62 
def
 
™dR
: 
Boﬁ
 = i‡(
x
.
isEm±y
Ë
åue
.
B
 x.
	`ªdu˚
(
_
&&_)

63 
def
 
‹R
: 
Boﬁ
 = i‡(
x
.
isEm±y
Ë
Ál£
.
B
 x.
	`ªdu˚
(
_
||_)

64 
def
 
x‹R
: 
Boﬁ
 = i‡(
x
.
isEm±y
Ë
Ál£
.
B
 x.
	`ªdu˚
(
_
^_)

66 
¥iv©e
 
def
 
	`∑dZù
(
y
: 
Seq
[
Boﬁ
], 
z
: Seq[Boﬁ]): Seq[(Boﬁ, Boﬁ)] = y.
	`∑dTo
(z.
size
, 
Ál£
.
B
Ë
zù
 z.padTo(y.size, false.B)

67 
	}
}

69 
im∂icô
 
˛ass
 
	gD©aToAugmíãdD©a
[
T
 <: 
D©a
](
vÆ
 
x
: TË
exãnds
 
AnyVÆ
 {

70 
def
 
hﬁdU∆ess
(
íabÀ
: 
Boﬁ
): 
T
 = 
Mux
”«bÀ, 
x
, 
RegE«bÀ
(x,Énable))

73 
im∂icô
 
˛ass
 
	gSeqMemToAugmíãdSeqMem
[
T
 <: 
D©a
](
vÆ
 
x
: 
SeqMem
[T]Ë
exãnds
 
AnyVÆ
 {

74 
def
 
ªadAndHﬁd
(
addr
: 
UI¡
, 
íabÀ
: 
Boﬁ
): 
T
 = 
x
.
ªad
◊ddr,É«bÀË
hﬁdU∆ess
 
RegNext
(enable)

77 
im∂icô
 cœs†
	cSåögToAugmíãdSåög
(
vÆ
 
x
: 
Såög
Ë
exãnds
 
AnyVÆ
 {

79 
def
 
undîsc‹e
: 
Såög
 = 
x
.
èû
.
	`fﬁdLe·
(x.
hódO±i⁄
.
	`m≠
(
_
.
toLowî
 + ""Ë
gëOrEl£
 "") {

80 (
acc
, 
c
Ëc.
isUµî
 =>ác¯+ "_" + c.
toLowî


81 (
acc
, 
c
) c == ' ' =>ácc

82 (
acc
, 
c
) =>ácc + c

86 
def
 
kebab
: 
Såög
 = 
x
.
toLowîCa£
 
m≠
 {

89 
c
 => c

92 
def
 
	`«med
(
«me
: 
O±i⁄
[
Såög
]): String = {

93 
x
 + 
«me
.
	`m≠
("_«med_" + 
_
 ).
	`gëOrEl£
("_with_no_name")

96 
def
 
	`«med
(
«me
: 
Såög
): Såög =Çamed(
	`Some
(name))

97 
	}
}

99 
im∂icô
 
def
 
	$uötToBôP©
(
x
: 
UI¡
): 
BôP©
 = 
	$BôP©
(
x
)

100 
im∂icô
 
def
 
	$wcToUI¡
(
c
: 
WideCou¡î
): 
UI¡
 = c.
vÆue


102 
im∂icô
 cœs†
	cUI¡ToAugmíãdUI¡
(
vÆ
 
x
: 
UI¡
Ë
exãnds
 
AnyVÆ
 {

103 
def
 
	`£xtTo
(
n
: 
I¡
): 
UI¡
 = {

104 
	`ªquúe
(
x
.
gëWidth
 <
n
)

105 i‡(
x
.
gëWidth
 =
n
) x

106 
	`C©
(
	`Fûl
(
n
 - 
x
.
gëWidth
, 
	`x
(x.getWidth-1)), x)

109 
def
 
	`∑dTo
(
n
: 
I¡
): 
UI¡
 = {

110 
	`ªquúe
(
x
.
gëWidth
 <
n
)

111 i‡(
x
.
gëWidth
 =
n
) x

112 
	`C©
(
	`UI¡
(0, 
n
 - 
x
.
gëWidth
), x)

116 
def
 
	`exåa˘
(
hi
: 
I¡
, 
lo
: I¡): 
UI¡
 = {

117 
	`ªquúe
(
hi
 >
lo
-1)

118 i‡(
hi
 =
lo
-1Ë
	`UI¡
(0)

119 
	`x
(
hi
, 
lo
)

123 
def
 
	`exåa˘O±i⁄
(
hi
: 
I¡
, 
lo
: I¡): 
O±i⁄
[
UI¡
] = {

124 
	`ªquúe
(
hi
 >
lo
-1)

125 i‡(
hi
 =
lo
-1Ë
N⁄e


126 
	`Some
(
	`x
(
hi
, 
lo
))

129 
def
 
	`rŸ©eRight
(
n
: 
I¡
): 
UI¡
 = i‡“ =0Ë
x
 
	`C©
(
	`x
(n-1, 0), x >>Ç)

131 
def
 
	`rŸ©eRight
(
n
: 
UI¡
): UInt = {

132 
vÆ
 
amt
 = 
n
.
	`∑dTo
(
	`log2Ceû
(
x
.
gëWidth
))

133 (
x
 /: (0 
u¡û
 
	`log2Ceû
(x.
gëWidth
)))((
r
, 
i
Ë=> 
	`Mux
(
	`amt
(i),Ñ.
	`rŸ©eRight
(1 << i),Ñ))

136 
def
 
	`rŸ©eLe·
(
n
: 
I¡
): 
UI¡
 = i‡“ =0Ë
x
 
	`C©
(
	`x
(x.
gëWidth
-1-n,0), x(x.getWidth-1,x.getWidth-n))

138 
def
 
	`rŸ©eLe·
(
n
: 
UI¡
): UInt = {

139 
vÆ
 
amt
 = 
n
.
	`∑dTo
(
	`log2Ceû
(
x
.
gëWidth
))

140 (
x
 /: (0 
u¡û
 
	`log2Ceû
(x.
gëWidth
)))((
r
, 
i
Ë=> 
	`Mux
(
	`amt
(i),Ñ.
	`rŸ©eLe·
(1 << i),Ñ))

144 
def
 
	`addWøp
(
y
: 
UI¡
, 
n
: 
I¡
): UInt = {

145 
vÆ
 
z
 = 
x
 +& 
y


146 i‡(
	`isPow2
(
n
)Ë
	`z
“.
log2
-1, 0Ë
	`Mux
(
z
 >n.
U
, z -Ç.U, z)(
	`log2Ceû
(n)-1, 0)

150 
def
 
	`subWøp
(
y
: 
UI¡
, 
n
: 
I¡
): UInt = {

151 
vÆ
 
z
 = 
x
 -& 
y


152 i‡(
	`isPow2
(
n
)Ë
	`z
“.
log2
-1, 0Ë
	`Mux
(z(
z
.
gëWidth
-1), z +Ç.
U
, z)(
	`log2Ceû
(n)-1, 0)

155 
def
 
	`grou≥d
(
width
: 
I¡
): 
Seq
[
UI¡
] =

156 (0 
u¡û
 
x
.
gëWidth
 
by
 
width
).
	`m≠
(
ba£
 => 
	`x
(base + width - 1, base))

158 
def
 
	`öR™ge
(
ba£
: 
UI¡
, 
bounds
: UI¡Ë
x
 >= base && x < bounds

160 
def
 ## (
y
: 
O±i⁄
[
UI¡
]): UI¡ = y.
	`m≠
(
x
 ## 
_
).
	`gëOrEl£
(x)

161 
	}
}

163 
im∂icô
 
˛ass
 
	$O±i⁄UI¡ToAugmíãdO±i⁄UI¡
(
vÆ
 
x
: 
O±i⁄
[
UI¡
]Ë
exãnds
 
AnyVÆ
 {

164 
def
 ## (
y
: 
UI¡
): UI¡ = 
x
.
	`m≠
(
_
 ## y).
	`gëOrEl£
(y)

165 
def
 ## (
y
: 
O±i⁄
[
UI¡
]): O±i⁄[UI¡] = 
x
.
	`m≠
(
_
 ## y)

166 
	}
}

168 
im∂icô
 cœs†
	cBoﬁónToAugmíãdBoﬁón
(
vÆ
 
x
: 
Boﬁón
Ë
exãnds
 
AnyVÆ
 {

169 
def
 
toI¡
: 
I¡
 = i‡(
x
) 1 0

172 
def
 
›ti⁄
[
T
](
z
: => T): 
O±i⁄
[T] = i‡(
x
Ë
	`Some
(zË
N⁄e


173 
	}
}

175 
im∂icô
 cœs†
	cI¡ToAugmíãdI¡
(
vÆ
 
x
: 
I¡
Ë
exãnds
 
AnyVÆ
 {

177 
def
 
log2
: 
I¡
 = {

178 
	`ªquúe
(
	`isPow2
(
x
))

179 
	`log2Ceû
(
x
)

181 
	}
}

183 
def
 
	$OH1ToOH
(
x
: 
UI¡
): UI¡ = (x << 1 | 
	`UI¡
(1)Ë& ~
	`C©
(UI¡(0, 
width
=1), x)

184 
def
 
	$OH1ToUI¡
(
x
: 
UI¡
): UI¡ = 
	`OHToUI¡
(
	$OH1ToOH
(
x
))

185 
def
 
	$UI¡ToOH1
(
x
: 
UI¡
, 
width
: 
I¡
): UI¡ = ~(
	`SI¡
(-1, width=width).
asUI¡
 << x)(width-1, 0)

187 
def
 
	$åaûögZîos
(
x
: 
I¡
): 
O±i⁄
[I¡] = i‡(x > 0Ë
	`Some
(
	`log2Ceû
(x & -x)Ë
N⁄e


190 
def
 
	$À·OR
(
x
: 
UI¡
): UI¡ = 
	$À·OR
(
x
, x.
gëWidth
, x.getWidth)

191 
def
 
	$À·OR
(
x
: 
UI¡
, 
width
: 
I¡egî
, 
ˇp
: Integer = 999999): UInt = {

192 
vÆ
 
°›
 = 
	`mö
(
width
, 
ˇp
)

193 
def
 
	`hñ≥r
(
s
: 
I¡
, 
x
: 
UI¡
): UInt =

194 i‡(
s
 >
°›
Ë
x
 
	`hñ≥r
(s+s, x | (x << s)(
width
-1,0))

195 
	`hñ≥r
(1, 
x
)(
width
-1, 0)

196 
	}
}

199 
def
 
	$rightOR
(
x
: 
UI¡
): UI¡ = 
	$rightOR
(
x
, x.
gëWidth
, x.getWidth)

200 
def
 
	$rightOR
(
x
: 
UI¡
, 
width
: 
I¡egî
, 
ˇp
: Integer = 999999): UInt = {

201 
vÆ
 
°›
 = 
	`mö
(
width
, 
ˇp
)

202 
def
 
	`hñ≥r
(
s
: 
I¡
, 
x
: 
UI¡
): UInt =

203 i‡(
s
 >
°›
Ë
x
 
	`hñ≥r
(s+s, x | (x >> s))

204 
	`hñ≥r
(1, 
x
)(
width
-1, 0)

205 
	}
}

207 
def
 
	$O±imiz©i⁄B¨rõr
(
x
: 
UI¡
): UInt = ~(~x)

208 
def
 
O±imiz©i⁄B¨rõr
[
T
 <: 
D©a
](
x
: T): T = 
	`O±imiz©i⁄B¨rõr
(x.
asUI¡
).
	`asTy≥Of
(x)

209 
	}
}

	@
1
.
1
/usr/include
253
21713
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Protocol.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Test.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/ToTL.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Protocol.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Test.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/AsyncCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Buffer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/CrossingHelper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Deinterleaver.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Delayer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Filter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Fragmenter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/IdIndexer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Protocol.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Test.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/ToTL.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/UserYanker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/config/Config.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Custom.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DMI.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Debug.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugRomContents.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugTransport.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Periphery.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/SBA.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/abstract_commands.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/dm_registers.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BootROM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBlocker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBypass.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/CLINT.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Deadlock.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/DevNull.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Error.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MaskROM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MasterMux.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/PhysicalFilter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Plic.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/TestRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Zero.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressDecoder.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressRange.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/BundleBridge.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ClockDomain.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Clone.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/CloneModule.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/DeviceTree.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/FixedClockResource.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/JSON.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/LazyModule.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Resources.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ValName.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/DummyPTW.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Generator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/GroundTestSubsystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Status.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TestHarness.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Tile.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TraceGen.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Crossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/CrossingHelper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/NullIntSource.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagShifter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagStateMachine.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagTap.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagUtils.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/Utils.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/Annotation.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/DescribedReg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegField.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegMapper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ALU.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/AMOALU.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BTB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Breakpoint.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BusErrorUnit.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/CSR.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Consts.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/DCache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Decode.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Events.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Frontend.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCacheArbiter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IBuf.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ICache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IDecode.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Instructions.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Multiplier.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/NBDcache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PMP.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PTW.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RVC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RocketCore.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ScratchpadSlavePort.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/SimpleHellaCacheIF.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLBPermissions.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/scie/SCIE.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/BaseSubsystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/CrossingWrapper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/FrontBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/HasTiles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/InterruptBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/MemoryBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/PeripheryBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Ports.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RTC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/ResetVector.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RocketSubsystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/SystemBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/ExampleRocketSystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Generator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/RocketTestSuite.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/TestHarness.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/BaseTile.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Core.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/CustomCSRs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/FPU.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Interrupts.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/L1Cache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/LazyRoCC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/RocketTile.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AddressAdjuster.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Arbiter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AsyncCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AtomicAutomata.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Atomics.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BankBinder.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Broadcast.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Buffer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BusWrapper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CacheCork.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CrossingHelper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Delayer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Edges.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ErrorEvaluator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Example.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/FIFOFixer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Filter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fragmenter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fuzzer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/HintHandler.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Isolation.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Map.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Metadata.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Monitor.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/NodeNumberer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/PatternPusher.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ProbePicker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RAMModel.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RationalCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegionReplication.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouterTest.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SourceShrinker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Splitter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAHB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAPB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAXI4.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/WidthWidget.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Generator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestGenerator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestHarness.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/UnitTest.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Annotations.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Arbiters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncResetReg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Broadcaster.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/BundleMonitorKey.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/CRC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockDivider.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockGate.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Counters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Crossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/DescribedSRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ECC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Frequency.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GeneratorUtils.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GenericParameterizedBundle.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HellaQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HeterogeneousBag.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IDPool.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IdentityModule.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LCG.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LatencyPipe.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Misc.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MultiWidthFifo.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MuxLiteral.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PSDTestMode.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PlusArg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PositionalMultiQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Property.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ROMGenerator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/RationalCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReduceOthers.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReorderQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Repeater.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Replacement.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ResetCatchAndSync.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/SeededRandom.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftReg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Timer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/package.scala
