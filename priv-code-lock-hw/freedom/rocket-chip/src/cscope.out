cscope 15 $HOME/priv-code-lock/freedom/rocket-chip/src               0001424036
	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Bundles.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
G’”icP¬am‘”izedBundË


8 
ab¡¿ù
 cÏs 
	cAHBBundËBa£
(
·¿ms
: 
AHBBundËP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

11 şas 
	cAHBBundË
(
·¿ms
: 
AHBBundËP¬am‘”s
è
ex‹nds
 
	$AHBBundËBa£
(
·¿ms
)

14 
v®
 
hma¡lock
 = 
	$BoŞ
(
OUTPUT
)

15 
v®
 
hŒªs
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
ŒªsB™s
)

16 
v®
 
h£l
 = 
	$BoŞ
(
OUTPUT
)

17 
v®
 
h»ady
 = 
	$BoŞ
(
OUTPUT
)

20 
v®
 
hwr™e
 = 
	$BoŞ
(
OUTPUT
)

21 
v®
 
haddr
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
addrB™s
)

22 
v®
 
hsize
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
sizeB™s
)

23 
v®
 
hbur¡
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
bur¡B™s
)

24 
v®
 
h´Ù
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
´ÙB™s
)

25 
v®
 
hwd©a
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
d©aB™s
)

27 
v®
 
h»adyout
 = 
	$BoŞ
(
INPUT
)

28 
v®
 
h»¥
 = 
	$BoŞ
(
INPUT
)

29 
v®
 
hrd©a
 = 
	$UIÁ
(
INPUT
, 
width
 = 
·¿ms
.
d©aB™s
)

31 
def
 
	$t›off
() {

32 
h»adyout
.
dœ
 
m©ch
 {

33 
INPUT
 =>

34 
h»adyout
 :ğ
	`BoŞ
(
çl£
)

35 
h»¥
 :ğ
AHBP¬am‘”s
.
RESP_OKAY


36 
hrd©a
 :ğ
	`UIÁ
(0)

37 
OUTPUT
 =>

38 
hma¡lock
 :ğ
	`BoŞ
(
çl£
)

39 
hŒªs
 :ğ
AHBP¬am‘”s
.
TRANS_IDLE


40 
h£l
 :ğ
	`BoŞ
(
çl£
)

41 
h»ady
 :ğ
	`BoŞ
(
çl£
)

42 
hwr™e
 :ğ
	`BoŞ
(
çl£
)

43 
haddr
 :ğ
	`UIÁ
(0)

44 
hsize
 :ğ
	`UIÁ
(0)

45 
hbur¡
 :ğ
AHBP¬am‘”s
.
BURST_SINGLE


46 
h´Ù
 :ğ
AHBP¬am‘”s
.
PROT_DEFAULT


47 
hwd©a
 :ğ
	`UIÁ
(0)

48 
_
 =>

51 
	}
}

53 
objeù
 
AHBBundË


55 
def
 
­¶y
(
·¿ms
: 
AHBBundËP¬am‘”s
èğ
Ãw
 
AHBBundË
(params)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Nodes.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
objeù
 
AHBImp
 
ex‹nds
 
	gSim¶eNodeImp
[
AHBMa¡”PÜtP¬am‘”s
, 
AHBSÏvePÜtP¬am‘”s
, 
AHBEdgeP¬am‘”s
, 
AHBBundË
]

12 
def
 
edge
(
pd
: 
AHBMa¡”PÜtP¬am‘”s
, 
pu
: 
AHBSÏvePÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
AHBEdgeP¬am‘”s
(pd,…u,…, sourceInfo)

13 
def
 
bundË
(
e
: 
AHBEdgeP¬am‘”s
èğ
AHBBundË
(e.bundle)

14 
def
 
»nd”
(
e
: 
AHBEdgeP¬am‘”s
èğ
R’d”edEdge
(
cŞour
 = "#00ccff" , 
Ïb–
 = (e.
¦ave
.
b—tBy‹s
 * 8).
toSŒšg
)

16 
ov”ride
 
def
 
mixO
(
pd
: 
AHBMa¡”PÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[AHBMa¡”PÜtP¬am‘”s, 
AHBSÏvePÜtP¬am‘”s
, 
AHBBundË
]): AHBMasterPortParameters =

17 
pd
.
cİy
(
ma¡”s
 =…d.ma¡”s.
m­
 { 
c
 => c.cİy (
nodeP©h
 = 
node
 +: c.nodePath) })

18 
ov”ride
 
def
 
mixI
(
pu
: 
AHBSÏvePÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
AHBMa¡”PÜtP¬am‘”s
, AHBSÏvePÜtP¬am‘”s, 
AHBBundË
]): AHBSlavePortParameters =

19 
pu
.
cİy
(
¦aves
 =…u.¦aves.
m­
 { 
m
 => m.cİy (
nodeP©h
 = 
node
 +: m.nodePath) })

23 
şass
 
	$AHBMa¡”Node
(
pÜtP¬ams
: 
Seq
[
AHBMa¡”PÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SourûNode
(
AHBImp
)(
pÜtP¬ams
)

24 
şass
 
	$AHBSÏveNode
(
pÜtP¬ams
: 
Seq
[
AHBSÏvePÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SškNode
(
AHBImp
)(
pÜtP¬ams
)

25 
şass
 
	`AHBNexusNode
(

26 
ma¡”Fn
: 
Seq
[
AHBMa¡”PÜtP¬am‘”s
] => AHBMasterPortParameters,

27 
¦aveFn
: 
Seq
[
AHBSÏvePÜtP¬am‘”s
] => AHBSlavePortParameters)(

28 
im¶ic™
 
v®Name
: 
V®Name
)

29 
ex‹nds
 
	$NexusNode
(
AHBImp
)(
ma¡”Fn
, 
¦aveFn
)

31 
şass
 
	$AHBId’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	`Id’t™yNode
(
AHBImp
)()

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Parameters.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.
max


11 
şass
 
AHBSÏveP¬am‘”s
(

12 
add»ss
: 
Seq
[
Add»ssS‘
],

13 
»sourûs
: 
Seq
[
Resourû
] = 
N
,

14 
»giÚTy³
: 
RegiÚTy³
.
T
 = RegiÚTy³.
GET_EFFECTS
,

15 
execubË
: 
BoŞ—n
 = 
çl£
,

16 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

17 
suµÜtsWr™e
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

18 
suµÜtsR—d
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
)

20 
add»ss
.
fÜ—ch
 { 
a
 => 
»quœe
 (a.
fš™e
) }

21 
add»ss
.
combš©iÚs
(2).
fÜ—ch
 { 
Seq
(
x
,
y
è=> 
»quœe
 (!x.
ov”Ïps
(y)) }

23 
v®
 
	gÇme
 = 
nodeP©h
.
Ï¡O±iÚ
.
m­
(
_
.
ÏzyModuË
.
Çme
).
g‘OrEl£
("disconnected")

24 
v®
 
maxT¿nsãr
 = 
max
(
suµÜtsWr™e
.max, 
suµÜtsR—d
.max)

25 
v®
 
	gmaxAdd»ss
 = 
add»ss
.
m­
(
_
.
max
).max

26 
v®
 
mšAlignm’t
 = 
add»ss
.
m­
(
_
.
®ignm’t
).
mš


29 
»quœe
 (
mšAlignm’t
 >ğ
maxT¿nsãr
)

32 
şass
 
	$AHBSÏvePÜtP¬am‘”s
(

33 
¦aves
: 
Seq
[
AHBSÏveP¬am‘”s
],

34 
b—tBy‹s
: 
IÁ
)

36 
	`»quœe
 (!
¦aves
.
isEm±y
)

37 
	`»quœe
 (
	`isPow2
(
b—tBy‹s
))

39 
v®
 
maxT¿nsãr
 = 
¦aves
.
	`m­
(
_
.maxT¿nsãr).
max


40 
v®
 
maxAdd»ss
 = 
¦aves
.
	`m­
(
_
.maxAdd»ss).
max


43 
	`»quœe
 (
maxT¿nsãr
 >ğ
b—tBy‹s
)

45 
	`»quœe
 (
maxT¿nsãr
 <ğ
b—tBy‹s
 * 
AHBP¬am‘”s
.maxTransfer)

48 
¦aves
.
	`combš©iÚs
(2).
fÜ—ch
 { 
	`Seq
(
x
,
y
) =>

49 
x
.
add»ss
.
fÜ—ch
 { 
a
 => 
y
.add»ss.fÜ—ch { 
b
 =>

50 
	`»quœe
 (!
a
.
	`ov”Ïps
(
b
))

53 
	}
}

55 
şass
 
AHBMa¡”P¬am‘”s
(

56 
Çme
: 
SŒšg
,

57 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

59 
şass
 
	$AHBMa¡”PÜtP¬am‘”s
(

60 
ma¡”s
: 
Seq
[
AHBMa¡”P¬am‘”s
])

62 
şass
 
	$AHBBundËP¬am‘”s
(

63 
addrB™s
: 
IÁ
,

64 
d©aB™s
: 
IÁ
)

66 
	`»quœe
 (
d©aB™s
 >= 8)

67 
	`»quœe
 (
addrB™s
 >= 1)

68 
	`»quœe
 (
	`isPow2
(
d©aB™s
))

71 
v®
 
ŒªsB™s
 = 
AHBP¬am‘”s
.transBits

72 
v®
 
bur¡B™s
 = 
AHBP¬am‘”s
.burstBits

73 
v®
 
´ÙB™s
 = 
AHBP¬am‘”s
.protBits

74 
v®
 
sizeB™s
 = 
AHBP¬am‘”s
.sizeBits

76 
def
 (
x
: 
AHBBundËP¬am‘”s
) =

77 
	`AHBBundËP¬am‘”s
(

78 
	`max
(
addrB™s
, 
x
.addrBits),

79 
	`max
(
d©aB™s
, 
x
.dataBits))

80 
	}
}

82 
objeù
 
	gAHBBundËP¬am‘”s


84 
v®
 
	gem±yBundËP¬ams
 = 
AHBBundËP¬am‘”s
(
addrB™s
 = 1, 
d©aB™s
 = 8)

85 
def
 (
x
: 
Seq
[
AHBBundËP¬am‘”s
]èğx.
fŞdLeá
(
em±yBundËP¬ams
)((x,
	gy
è=> x.(
y
))

87 
def
 
­¶y
(
ma¡”
: 
AHBMa¡”PÜtP¬am‘”s
, 
¦ave
: 
AHBSÏvePÜtP¬am‘”s
) =

88 
Ãw
 
AHBBundËP¬am‘”s
(

89 
addrB™s
 = 
log2Up
(
¦ave
.
maxAdd»ss
+1),

90 
d©aB™s
 = 
¦ave
.
b—tBy‹s
 * 8)

93 
şass
 
	$AHBEdgeP¬am‘”s
(

94 
ma¡”
: 
AHBMa¡”PÜtP¬am‘”s
,

95 
¦ave
: 
AHBSÏvePÜtP¬am‘”s
,

96 
·¿ms
: 
P¬am‘”s
,

97 
sourûInfo
: 
SourûInfo
)

99 
v®
 
bundË
 = 
	`AHBBundËP¬am‘”s
(
ma¡”
, 
¦ave
)

100 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Protocol.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


7 
objeù
 
	gAHBP¬am‘”s


10 
v®
 
	gŒªsB™s
 = 2

11 
v®
 
bur¡B™s
 = 3

12 
v®
 
´ÙB™s
 = 4

13 
v®
 
sizeB™s
 = 3

15 
def
 
TRANS_IDLE
 = 
UIÁ
(0, 
width
 = 
ŒªsB™s
)

16 
def
 
TRANS_BUSY
 = 
UIÁ
(1, 
width
 = 
ŒªsB™s
)

17 
def
 
TRANS_NONSEQ
 = 
UIÁ
(2, 
width
 = 
ŒªsB™s
)

18 
def
 
TRANS_SEQ
 = 
UIÁ
(3, 
width
 = 
ŒªsB™s
)

20 
def
 
BURST_SINGLE
 = 
UIÁ
(0, 
width
 = 
bur¡B™s
)

21 
def
 
BURST_INCR
 = 
UIÁ
(1, 
width
 = 
bur¡B™s
)

22 
def
 
BURST_WRAP4
 = 
UIÁ
(2, 
width
 = 
bur¡B™s
)

23 
def
 
BURST_INCR4
 = 
UIÁ
(3, 
width
 = 
bur¡B™s
)

24 
def
 
BURST_WRAP8
 = 
UIÁ
(4, 
width
 = 
bur¡B™s
)

25 
def
 
BURST_INCR8
 = 
UIÁ
(5, 
width
 = 
bur¡B™s
)

26 
def
 
BURST_WRAP16
 = 
UIÁ
(6, 
width
 = 
bur¡B™s
)

27 
def
 
BURST_INCR16
 = 
UIÁ
(7, 
width
 = 
bur¡B™s
)

29 
v®
 
maxT¿nsãr
 = 16

31 
def
 
RESP_OKAY
 = 
BoŞ
(
çl£
)

32 
def
 
RESP_ERROR
 = 
BoŞ
(
Œue
)

34 
def
 
PROT_DATA
 = 
UIÁ
(1, 
width
 = 
´ÙB™s
)

35 
def
 
PROT_PRIVILEDGED
 = 
UIÁ
(2, 
width
 = 
´ÙB™s
)

36 
def
 
PROT_BUFFERABLE
 = 
UIÁ
(4, 
width
 = 
´ÙB™s
)

37 
def
 
PROT_CACHEABLE
 = 
UIÁ
(8, 
width
 = 
´ÙB™s
)

38 
def
 
PROT_DEFAULT
 = 
PROT_DATA
 | 
PROT_PRIVILEDGED


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/RegisterRouter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.{
	gIÁSourûNode
, 
	gIÁSourûPÜtSim¶e
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gH‘”og’eousBag
, 
	gMaskG’
}

11 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

13 
şass
 
	$AHBRegi¡”Node
(
add»ss
: 
Add»ssS‘
, 
cÚcu¼’cy
: 
IÁ
 = 0, 
b—tBy‹s
: IÁ = 4, 
undefZ”o
: 
BoŞ—n
 = 
Œue
, 
execubË
: BoŞ—Àğ
çl£
)(
im¶ic™
 
v®Name
: 
V®Name
)

14 
ex‹nds
 
	$SškNode
(
AHBImp
)(
	`Seq
(
	`AHBSÏvePÜtP¬am‘”s
(

15 
	`Seq
(
	`AHBSÏveP¬am‘”s
(

16 
add»ss
 = 
	`Seq
(address),

17 
execubË
 =ƒxecutable,

18 
suµÜtsWr™e
 = 
	`T¿nsãrSizes
(1, 
	`mš
(
add»ss
.
®ignm’t
.
toIÁ
, 
b—tBy‹s
 * 
AHBP¬am‘”s
.
maxT¿nsãr
)),

19 
suµÜtsR—d
 = 
	`T¿nsãrSizes
(1, 
	`mš
(
add»ss
.
®ignm’t
.
toIÁ
, 
b—tBy‹s
 * 
AHBP¬am‘”s
.
maxT¿nsãr
)))),

20 
b—tBy‹s
 = beatBytes)))

22 
	`»quœe
 (
add»ss
.
cÚtiguous
)

26 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*) = {

27 
	`v®
 (
ahb
, 
_
èğ
this
.
	`š
(0)

29 
v®
 
šdexB™s
 = 
	`log2Up
((
add»ss
.
mask
+1)/
b—tBy‹s
)

30 
v®
 
·¿ms
 = 
	`RegM­³rP¬ams
(
šdexB™s
, 
b—tBy‹s
, 1)

31 
v®
 
š
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`RegM­³rIÅut
(
·¿ms
)))

32 
v®
 
out
 = 
	`RegM­³r
(
b—tBy‹s
, 
cÚcu¼’cy
, 
undefZ”o
, 
š
, 
m­pšg
:
_
*)

34 
v®
 
d_pha£
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

35 
v®
 
d_k’
 = 
	`Reg
(
	`BoŞ
())

36 
v®
 
d_»ad
 = 
	`Reg
(
	`BoŞ
())

37 
v®
 
d_šdex
 = 
	`Reg
(
	`UIÁ
(
width
 = 
šdexB™s
))

38 
v®
 
d_mask
 = 
	`Reg
(
	`UIÁ
(
width
 = 
b—tBy‹s
))

41 
d_k’
 :ğ
d_pha£
 && 
š
.
»ady


42 
š
.
v®id
 :ğ
d_pha£
 && !
d_k’


44 
š
.
b™s
.
»ad
 :ğ
d_»ad


45 
š
.
b™s
.
šdex
 :ğ
d_šdex


46 
š
.
b™s
.
d©a
 :ğ
ahb
.
hwd©a


47 
š
.
b™s
.
mask
 :ğ
d_mask


48 
š
.
b™s
.
exŒa
 :ğ
	`UIÁ
(0)

50 
	`wh’
 (
ahb
.
h»ady
è{ 
d_pha£
 :ğ
	`BoŞ
(
çl£
) }

51 
ahb
.
h»adyout
 :ğ!
d_pha£
 || 
out
.
v®id


52 
ahb
.
h»¥
 :ğ
AHBP¬am‘”s
.
RESP_OKAY


53 
ahb
.
hrd©a
 :ğ
out
.
b™s
.
d©a


55 
v®
 
»que¡
 = 
ahb
.
hŒªs
 ==ğ
AHBP¬am‘”s
.
TRANS_NONSEQ
 ||‡hb.hŒª ==ğAHBP¬am‘”s.
TRANS_SEQ


56 
	`wh’
 (
ahb
.
h»ady
 &&‡hb.
h£l
 && 
»que¡
) {

57 
	`as£¹
 (!
š
.
v®id
 || in.
»ady
)

58 
d_pha£
 :ğ
	`BoŞ
(
Œue
)

59 
d_k’
 :ğ
	`BoŞ
(
çl£
)

60 
d_»ad
 :ğ!
ahb
.
hwr™e


61 
d_šdex
 :ğ
ahb
.
haddr
 >> 
	`log2Ce
(
b—tBy‹s
)

62 
d_mask
 :ğ
	`MaskG’
(
ahb
.
haddr
,‡hb.
hsize
, 
b—tBy‹s
)

65 
out
.
»ady
 :ğ
	`BoŞ
(
Œue
)

66 
	`as£¹
 (
d_pha£
 || !
out
.
v®id
)

68 
	}
}

73 
ab¡¿ù
 
şass
 
	$AHBRegi¡”Rou‹rBa£
(
add»ss
: 
Add»ssS‘
, 
š‹¼u±s
: 
IÁ
, 
cÚcu¼’cy
: IÁ, 
b—tBy‹s
: IÁ, 
undefZ”o
: 
BoŞ—n
, 
execubË
: BoŞ—n)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


75 
v®
 
node
 = 
	`AHBRegi¡”Node
(
add»ss
, 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

76 
v®
 
šŠode
 = 
	`IÁSourûNode
(
	`IÁSourûPÜtSim¶e
(
num
 = 
š‹¼u±s
))

77 
	}
}

79 şas 
	cAHBRegBundËArg
()(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
)

81 şas 
	cAHBRegBundËBa£
(
¬g
: 
AHBRegBundËArg
è
ex‹nds
 
BundË


83 
im¶ic™
 
v®
 
p
 = 
¬g
.p

86 
şass
 
AHBRegBundË
[
P
](
v®
 
·¿ms
: P, 
¬g
: 
AHBRegBundËArg
è
ex‹nds
 
	$AHBRegBundËBa£
(
¬g
)

88 
şass
 
AHBRegModuË
[
P
, 
B
 <: 
AHBRegBundËBa£
](
v®
 
·¿ms
: P, 
bundËBud”
: => B, 
rou‹r
: 
AHBRegi¡”Rou‹rBa£
)

89 
ex‹nds
 
	$LazyModuËImp
(
rou‹r
è
w™h
 
HasRegM­


91 
v®
 
io
 = 
	`IO
(
bundËBud”
)

92 
v®
 
š‹¼u±s
 = ià(
rou‹r
.
šŠode
.
out
.
isEm±y
è
	`Vec
(0, 
	`BoŞ
()èrou‹r.šŠode.
	`out
(0).
_1


93 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*èğ
rou‹r
.
node
.»gm­(m­pšg:
_
*)

94 
	}
}

96 
şass
 
AHBRegi¡”Rou‹r
[
B
 <: 
AHBRegBundËBa£
, 
M
 <: 
LazyModuËImp
]

97 (
v®
 
ba£
: 
BigIÁ
, v® 
	gš‹¼u±s
: 
IÁ
 = 0, v® 
	gsize
: BigIÁ = 4096, v® 
	gcÚcu¼’cy
: IÁ = 0, v® 
	gb—tBy‹s
: IÁ = 4, 
	gundefZ”o
: 
BoŞ—n
 = 
Œue
, 
	gexecubË
: BoŞ—Àğ
çl£
)

98 (
bundËBud”
: 
AHBRegBundËArg
 => 
B
)

99 (
moduËBud”
: (=> 
B
, 
	gAHBRegi¡”Rou‹rBa£
è=> 
M
)(
im¶ic™
 
p
: 
P¬am‘”s
)

100 
ex‹nds
 
AHBRegi¡”Rou‹rBa£
(
Add»ssS‘
(
ba£
, 
size
-1), 
š‹¼u±s
, 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

102 
»quœe
 (
isPow2
(
size
))

105 
Ïzy
 
v®
 
	gmoduË
 = 
moduËBud”
(
bundËBud”
(
AHBRegBundËArg
()), 
this
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/SRAM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
LFSRNoi£Mak”


11 
şass
 
	$AHBRAM
(

12 
add»ss
: 
Add»ssS‘
,

13 
execubË
: 
BoŞ—n
 = 
Œue
,

14 
b—tBy‹s
: 
IÁ
 = 4,

15 
fuzzH»adyout
: 
BoŞ—n
 = 
çl£
,

16 
devName
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

17 
”rÜs
: 
Seq
[
Add»ssS‘
] = 
N
)

18 (
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Dlom©icSRAM
(
add»ss
, 
b—tBy‹s
, 
devName
)

20 
v®
 
node
 = 
	`AHBSÏveNode
(
	`Seq
(
	`AHBSÏvePÜtP¬am‘”s
(

21 
	`Seq
(
	`AHBSÏveP¬am‘”s
(

22 
add»ss
 = 
	`Li¡
×dd»ssè++ 
”rÜs
,

23 
»sourûs
 =„esources,

24 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

25 
execubË
 =ƒxecutable,

26 
suµÜtsR—d
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
 * 
AHBP¬am‘”s
.
maxT¿nsãr
),

27 
suµÜtsWr™e
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
 * 
AHBP¬am‘”s
.
maxT¿nsãr
))),

28 
b—tBy‹s
 = beatBytes)))

30 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

31 
	`v®
 (
š
, 
_
èğ
node
.
	`š
(0)

32 
v®
 
mem
 = 
	`makeSšgËPÜ‹dBy‹Wr™eSeqMem
(1 << 
mask
.
	`f‹r
(
b
=>b).
size
)

35 
v®
 
a_acûss
 = 
š
.
hŒªs
 ==ğ
AHBP¬am‘”s
.
TRANS_NONSEQ
 || in.hŒª ==ğAHBP¬am‘”s.
TRANS_SEQ


36 
v®
 
a_»que¡
 = 
š
.
h»ady
 && in.
h£l
 && 
a_acûss


37 
v®
 
a_mask
 = 
	`MaskG’
(
š
.
haddr
, in.
hsize
, 
b—tBy‹s
)

38 
v®
 
a_add»ss
 = 
	`C©
((
mask
 
	`z
 (
š
.
haddr
 >> 
	`log2Ce
(
b—tBy‹s
)).
toBoŞs
).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
).
»v”£
)

39 
v®
 
a_wr™e
 = 
š
.
hwr™e


40 
v®
 
a_Ëg®
 = 
add»ss
.
	`cÚšs
(
š
.
haddr
)

43 
v®
 
d_wd©a
 = 
Vec
.
	`buÏ‹
(
b—tBy‹s
è{ 
i
 => 
š
.
	`hwd©a
(8*(i+1)-1, 8*i) }

57 
v®
 
p_v®id
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

58 
v®
 
p_add»ss
 = 
	`Reg
(
a_add»ss
)

59 
v®
 
p_mask
 = 
	`Reg
(
a_mask
)

60 
v®
 
p_Ïtch_d
 = 
	`Reg
(
	`BoŞ
())

61 
v®
 
p_wd©a
 = 
d_wd©a
 
hŞdUÆess
 
p_Ïtch_d


64 
v®
 
»ad
 = 
a_»que¡
 && !
a_wr™e


66 
v®
 
d_rd©a
 = 
mem
.
	`»adAndHŞd
(
a_add»ss
, 
»ad
)

67 
v®
 
d_Ëg®
 = 
	`RegEÇbË
(
a_Ëg®
, 
š
.
h»adyout
)

69 
	`wh’
 (!
»ad
 && 
p_v®id
) {

70 
p_v®id
 :ğ
	`BoŞ
(
çl£
)

71 
mem
.
	`wr™e
(
p_add»ss
, 
p_wd©a
, 
p_mask
.
toBoŞs
)

75 
p_Ïtch_d
 :ğ
a_»que¡
 && 
a_wr™e


76 
	`wh’
 (
a_»que¡
 && 
a_wr™e
 && 
a_Ëg®
) {

77 
p_v®id
 :ğ
	`BoŞ
(
Œue
)

78 
p_add»ss
 :ğ
a_add»ss


79 
p_mask
 :ğ
a_mask


83 
v®
 
a_by·ss
 = 
a_add»ss
 ==ğ
p_add»ss
 && 
p_v®id


84 
v®
 
d_by·ss
 = 
	`RegEÇbË
(
a_by·ss
, 
a_»que¡
)

87 
v®
 
muxd©a
 = 
	`Vec
((
p_mask
.
toBoŞs
 
	`z
 (
p_wd©a
 
z
 
d_rd©a
))

88 
m­
 { (
m
, (
p
, 
r
)è=> 
	`Mux
(
d_by·ss
 && m,…,„) })

91 
v®
 
d_»que¡
 = 
	`Reg
(
	`BoŞ
(
çl£
))

92 
	`wh’
 (
š
.
h»ady
è{ 
d_»que¡
 :ğ
	`BoŞ
(
çl£
) }

93 
	`wh’
 (
a_»que¡
è{ 
d_»que¡
 :ğ
	`BoŞ
(
Œue
) }

96 
š
.
h»adyout
 :ğ(if(
fuzzH»adyout
è{ !
d_»que¡
 || 
	`LFSRNoi£Mak”
(1)(0è} { 
	`BoŞ
(
Œue
) })

97 
š
.
h»¥
 :ğ
	`Mux
(
d_Ëg®
 || !š.
h»adyout
, 
AHBP¬am‘”s
.
RESP_OKAY
, AHBP¬am‘”s.
RESP_ERROR
)

98 
š
.
hrd©a
 :ğ
	`Mux
(š.
h»adyout
, 
muxd©a
.
asUIÁ
, 
	`UIÁ
(0))

100 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Test.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
TLTe¡RAM


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


12 
şass
 
	$RRTe¡0
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$AHBRegi¡”Rou‹r
(
add»ss
, 0, 32, 0, 4)(

13 
Ãw
 
	`AHBRegBundË
((), 
_
è
w™h
 
RRTe¡0BundË
)(

14 
Ãw
 
	`AHBRegModuË
((), 
_
, _è
w™h
 
RRTe¡0ModuË
)

16 
şass
 
	$RRTe¡1
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$AHBRegi¡”Rou‹r
(
add»ss
, 0, 32, 1, 4, 
çl£
)(

17 
Ãw
 
	`AHBRegBundË
((), 
_
è
w™h
 
RRTe¡1BundË
)(

18 
Ãw
 
	`AHBRegModuË
((), 
_
, _è
w™h
 
RRTe¡1ModuË
)

20 
şass
 
	$AHBFuzzN©ive
(
aFlow
: 
BoŞ—n
, 
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


22 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

23 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AHBFuzzNative"))

24 
v®
 
xb¬
 = 
	`LazyModuË
(
Ãw
 
AHBFªout
)

25 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`AHBRAM
(
	`Add»ssS‘
(0x0, 0xff)))

26 
v®
 
gpio
 = 
	`LazyModuË
(
Ãw
 
	`RRTe¡0
(0x100))

28 
xb¬
.
node
 :ğ
	`TLToAHB
(
aFlow
è:ğ
	`TLD–ay”
(0.1è:ğ
mod–
.nod:ğ
fuzz
.node

29 
¿m
.
node
 :ğ
xb¬
.node

30 
gpio
.
node
 :ğ
xb¬
.node

32 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

33 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

35 
	}
}

37 
şass
 
	$AHBN©iveTe¡
(
aFlow
: 
BoŞ—n
, 
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

38 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AHBFuzzN©ive
(
aFlow
, 
txns
)).
moduË
)

39 
io
.
fšished
 :ğ
dut
.io.finished

40 
	}
}

42 
Œa™
 
HasFuzzT¬g‘
 {

43 
v®
 
fuzzAddr
 = 
Add»ssS‘
(0x0, 0xfff)

44 
v®
 
	g·‰”n
 = 
Seq
(
Add»ssS‘
(0x8, ~0x808),

45 
Add»ssS‘
(0x900, ~0x900))

48 
şass
 
	$AHBFuzzMa¡”
(
aFlow
: 
BoŞ—n
, 
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 
w™h
 
HasFuzzT¬g‘


50 
v®
 
node
 = 
	`AHBId’t™yNode
()

51 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
, 
ov”rideAdd»ss
 = 
	`Some
(
fuzzAddr
)))

52 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AHBFuzzMa¡”", 
ignÜeCÜru±D©a
=
Œue
))

54 (
node


55 :ğ
	`TLToAHB
(
aFlow
)

56 :ğ
	`TLD–ay”
(0.2)

57 :ğ
	`TLBufãr
(
BufãrP¬ams
.
æow
)

58 :ğ
	`TLD–ay”
(0.2)

59 :ğ
	`TLE¼ÜEv®u©Ü
(
·‰”n
, 
‹¡On
=
Œue
, 
‹¡Off
=true)

60 :ğ
mod–
.
node


61 :ğ
fuzz
.
node
)

63 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

64 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

65 
v®
 
fšished
 = 
	`BoŞ
(
OUTPUT
)

68 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

70 
	}
}

72 şas 
	cAHBFuzzSÏve
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
Sim¶eLazyModuË
 
w™h
 
HasFuzzT¬g‘


74 
v®
 
node
 = 
	$AHBId’t™yNode
()

75 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	$TLTe¡RAM
(
fuzzAddr
, 
ŒackCÜru±iÚ
=
çl£
))

77 (
¿m
.
node


78 :ğ
	$TLE¼ÜEv®u©Ü
(
·‰”n
)

79 :ğ
	$TLF¿gm’‹r
(4, 16)

80 :ğ
	$TLD–ay”
(0.2)

81 :ğ
	$TLBufãr
(
BufãrP¬ams
.
æow
)

82 :ğ
	$TLD–ay”
(0.2)

83 :ğ
	$AHBToTL
()

84 :ğ
node
)

87 
şass
 
	$AHBFuzzBridge
(
aFlow
: 
BoŞ—n
, 
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


89 
v®
 
ma¡”
 = 
	`LazyModuË
(
Ãw
 
	`AHBFuzzMa¡”
(
aFlow
, 
txns
))

90 
v®
 
¦ave
 = 
	`LazyModuË
(
Ãw
 
AHBFuzzSÏve
)

92 
¦ave
.
node
 :ğ
ma¡”
.node

94 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

95 
io
.
fšished
 :ğ
ma¡”
.
moduË
.io.finished

97 
	}
}

99 
şass
 
	$AHBBridgeTe¡
(
aFlow
: 
BoŞ—n
, 
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

100 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AHBFuzzBridge
(
aFlow
, 
txns
)).
moduË
)

101 
io
.
fšished
 :ğ
dut
.io.finished

102 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/ToTL.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
MaskG’


11 
şass
 
	$AHBToTLNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$MixedAd­‹rNode
(
AHBImp
, 
TLImp
)(

12 
dFn
 = { 
	`AHBMa¡”PÜtP¬am‘”s
(
ma¡”s
) =>

13 
	`TLCl›ÁPÜtP¬am‘”s
(
ş›Ás
 = 
ma¡”s
.
m­
 { 
m
 =>

14 
	`TLCl›ÁP¬am‘”s
(
Çme
 = 
m
.Çme, 
nodeP©h
 = m.nodePath)

16 
	}
},

17 
	guFn
 = { 
mp
 => 
AHBSÏvePÜtP¬am‘”s
(

18 
¦aves
 = 
mp
.
mªag”s
.
m­
 { 
m
 =>

19 
def
 
adju¡
(
x
: 
T¿nsãrSizes
) = {

20 ià(
x
.
cÚšs
(
mp
.
b—tBy‹s
)) {

21 
T¿nsãrSizes
(
x
.
mš
, 
m
.
mšAlignm’t
.mš(
mp
.
b—tBy‹s
 * 
AHBP¬am‘”s
.
maxT¿nsãr
).
toIÁ
)

23 
x
.
š‹r£ù
(
T¿nsãrSizes
(1, 
mp
.
b—tBy‹s
))

27 
AHBSÏveP¬am‘”s
(

28 
add»ss
 = 
m
.address,

29 
»sourûs
 = 
m
.resources,

30 
»giÚTy³
 = 
m
.regionType,

31 
execubË
 = 
m
.executable,

32 
nodeP©h
 = 
m
.nodePath,

33 
suµÜtsWr™e
 = 
adju¡
(
m
.
suµÜtsPutFuÎ
),

34 
suµÜtsR—d
 = 
adju¡
(
m
.
suµÜtsG‘
))},

35 
b—tBy‹s
 = 
mp
.beatBytes)

38 şas 
	cAHBToTL
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


40 
v®
 
node
 = 
	$AHBToTLNode
()

42 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

43 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

44 
v®
 
b—tBy‹s
 = 
edgeOut
.
mªag”
.beatBytes

46 
v®
 
d_£nd
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

47 
v®
 
d_»cv
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

48 
v®
 
d_·u£
 = 
	`RegIn™
(
	`BoŞ
(
Œue
))

49 
v®
 
d_ç
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

50 
v®
 
d_wr™e
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

51 
v®
 
d_addr
 = 
	`Reg
(
š
.
haddr
)

52 
v®
 
d_size
 = 
	`Reg
(
š
.
hsize
)

54 
	`wh’
 (
out
.
d
.
v®id
è{ 
d_»cv
 :ğ
	`BoŞ
(
çl£
) }

55 
	`wh’
 (
out
.
a
.
»ady
è{ 
d_£nd
 :ğ
	`BoŞ
(
çl£
) }

56 
	`wh’
 (
š
.
h»¥
è{ 
d_·u£
 :ğ
	`BoŞ
(
çl£
) }

58 
v®
 
a_couÁ
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 4))

59 
v®
 
a_fœ¡
 = 
a_couÁ
 ==ğ
	`UIÁ
(0)

60 
v®
 
d_Ï¡
 = 
a_fœ¡


62 
v®
 
bur¡_sizes
 = 
	`Seq
(1, 1, 4, 4, 8, 8, 16, 16)

63 
v®
 
a_bur¡_size
 = 
	`Vec
(
bur¡_sizes
.
	`m­
(
b—ts
 => 
	`UIÁ
(
	`log2Ce
(b—t * 
b—tBy‹s
))))(
š
.
hbur¡
)

64 
v®
 
a_bur¡_mask
 = 
	`Vec
(
bur¡_sizes
.
	`m­
(
b—ts
 => 
	`UIÁ
(b—t * 
b—tBy‹s
 - 1)))(
š
.
hbur¡
)

66 
v®
 
a_bur¡_ok
 =

67 
š
.
hŒªs
 ==ğ
AHBP¬am‘”s
.
TRANS_NONSEQ
 &&

68 
š
.
hsize
 ==ğ
	`UIÁ
(
	`log2Ce
(
b—tBy‹s
)) &&

69 (
š
.
haddr
 & 
a_bur¡_mask
è==ğ
	`UIÁ
(0) &&

70 
š
.
hbur¡
 =/ğ
AHBP¬am‘”s
.
BURST_INCR
 &&

71 
	`Mux
(
š
.
hwr™e
,

72 
edgeOut
.
mªag”
.
	`suµÜtsPutFuÎSaã
(
š
.
haddr
, 
a_bur¡_size
),

73 
edgeOut
.
mªag”
.
	`suµÜtsG‘Saã
 (
š
.
haddr
, 
a_bur¡_size
))

75 
v®
 
b—t
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
)

76 
v®
 
a_Ëg®
 =

77 
	`Mux
(
š
.
hwr™e
,

78 
edgeOut
.
mªag”
.
	`suµÜtsPutFuÎSaã
(
š
.
haddr
, in.
hsize
, 
	`Some
(
b—t
)),

79 
edgeOut
.
mªag”
.
	`suµÜtsG‘Saã
 (
š
.
haddr
, in.
hsize
, 
	`Some
(
b—t
)))

81 
v®
 
a_acûss
 = 
š
.
hŒªs
 ==ğ
AHBP¬am‘”s
.
TRANS_NONSEQ
 || in.hŒª ==ğAHBP¬am‘”s.
TRANS_SEQ


82 
v®
 
a_acû±
 = 
š
.
h»ady
 && in.
h£l
 && 
a_acûss


84 
	`wh’
 (
a_acû±
) {

85 
a_couÁ
 :ğa_couÁ - 
	`UIÁ
(1)

86 
	`wh’
 ( 
š
.
hwr™e
è{ 
d_£nd
 :ğ
	`BoŞ
(
Œue
) }

87 
	`wh’
 (!
š
.
hwr™e
è{ 
d_»cv
 :ğ
	`BoŞ
(
Œue
) }

88 
	`wh’
 (
a_fœ¡
) {

89 
a_couÁ
 :ğ
	`Mux
(
a_bur¡_ok
, 
a_bur¡_mask
 >> 
	`log2Ce
(
b—tBy‹s
), 
	`UIÁ
(0))

90 
d_£nd
 :ğ
a_Ëg®


91 
d_»cv
 :ğ
a_Ëg®


92 
d_·u£
 :ğ
	`BoŞ
(
Œue
)

93 
d_wr™e
 :ğ
š
.
hwr™e


94 
d_addr
 :ğ
š
.
haddr


95 
d_size
 :ğ
	`Mux
(
a_bur¡_ok
, 
a_bur¡_size
, 
š
.
hsize
)

99 
out
.
a
.
v®id
 :ğ
d_£nd


100 
out
.
a
.
b™s
.
İcode
 :ğ
	`Mux
(
d_wr™e
, 
TLMes§ges
.
PutFuÎD©a
, TLMes§ges.
G‘
)

101 
out
.
a
.
b™s
.
·¿m
 :ğ
	`UIÁ
(0)

102 
out
.
a
.
b™s
.
size
 :ğ
d_size


103 
out
.
a
.
b™s
.
sourû
 :ğ
	`UIÁ
(0)

104 
out
.
a
.
b™s
.
add»ss
 :ğ
d_addr


105 
out
.
a
.
b™s
.
d©a
 :ğ
š
.
hwd©a


106 
out
.
a
.
b™s
.
mask
 :ğ
	`MaskG’
(
d_addr
, 
d_size
, 
b—tBy‹s
)

107 
out
.
a
.
b™s
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

109 
out
.
d
.
»ady
 :ğ
d_»cv


117 
š
.
hrd©a
 :ğ
out
.
d
.
b™s
.
d©a


120 
v®
 
h»¥
 = 
d_ç
 || (
out
.
d
.
v®id
 && (out.d.
b™s
.
d’›d
 || out.d.b™s.
cÜru±
))

121 
v®
 
h»adyout
 = 
	`Mux
(
d_wr™e
, (!
d_£nd
 || 
out
.
a
.
»ady
è&& (!
d_Ï¡
 || !
d_»cv
 || out.
d
.
v®id
), out.d.valid || !d_recv)

124 
d_ç
 :=

125 (
h»¥
 && !(
a_fœ¡
 && 
š
.
h»ady
)) ||

126 (
a_acû±
 && !
a_Ëg®
)

129 
š
.
h»¥
 :ğ
h»adyout
 && (h»¥ && 
d_Ï¡
)

130 
š
.
h»adyout
 :ğh»adyouˆ&& !(
h»¥
 && 
d_Ï¡
 && 
d_·u£
)

133 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

134 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

135 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

138 
	}
}

140 
objeù
 
AHBToTL


142 
def
 
­¶y
()(
im¶ic™
 
p
: 
P¬am‘”s
) =

144 
v®
 
ahb2
 = 
LazyModuË
(
Ãw
 
AHBToTL
)

145 
ahb2
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Xbar.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
ahb


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

11 şas 
	cAHBFªout
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

12 
v®
 
node
 = 
	`AHBNexusNode
(

13 
ma¡”Fn
 = { 
	`Seq
(
m
) => m },

14 
¦aveFn
 = { 
£q
 => 
	`£q
(0).
	`cİy
(
¦aves
 = seq.
	`æ©M­
(
_
.¦aves)è
	}
})

16 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

17 ià(
node
.
edges
.
š
.
size
 >= 1) {

18 
	`»quœe
 (
node
.
edges
.
š
.
size
 == 1, "AHBFanout does‚ot support multiple masters")

19 
	`»quœe
 (
node
.
edges
.
out
.
size
 > 0, "AHBFanout„equires‡t†east one slave")

22 
	`v®
 (
io_out
, 
edgesOut
èğ
node
.
out
.
unz


23 
v®
 
pÜt0
 = 
	`edgesOut
(0).
¦ave


24 
edgesOut
.
fÜ—ch
 { 
edge
 =>

25 
v®
 
pÜt
 = 
edge
.
¦ave


26 
	`»quœe
 (
pÜt
.
b—tBy‹s
 =ğ
pÜt0
.beatBytes,

27 
s
"${port.slaves.map(_.name)} ${port.beatBytes} vs ${port0.slaves.map(_.name)} ${port0.beatBytes}")

30 
v®
 
pÜt_addrs
 = 
edgesOut
.
	`m­
(
_
.
¦ave
.
¦aves
.m­(_.
add»ss
).
æ©‹n
)

31 
v®
 
routšgMask
 = 
	`Add»ssDecod”
(
pÜt_addrs
)

32 
v®
 
rou‹_addrs
 = 
pÜt_addrs
.
	`m­
(
_
.m­(_.
	`wid’
(~
routšgMask
)).
di¡šù
)

34 
	`v®
 (
š
, 
_
èğ
node
.
	`š
(0)

35 
v®
 
a_£l
 = 
	`Vec
(
rou‹_addrs
.
	`m­
(
£q
 => seq.m­(
_
.
	`cÚšs
(
š
.
haddr
)).
	`»duû
(_ || _)))

36 
v®
 
d_£l
 = 
	`Reg
(
a_£l
)

38 
	`wh’
 (
š
.
h»ady
è{ 
d_£l
 :ğ
a_£l
 }

39 (
a_£l
 
z
 
io_out
è
fÜ—ch
 { (
£l
, 
out
) =>

40 
out
 :ğ
š


41 
out
.
h£l
 :ğ
š
.h£È&& 
£l


44 
š
.
h»adyout
 :ğ!
	`Mux1H
(
d_£l
, 
io_out
.
	`m­
(!
_
.hreadyout))

45 
š
.
h»¥
 :ğ
	`Mux1H
(
d_£l
, 
io_out
.
	`m­
(
_
.hresp))

46 
š
.
hrd©a
 :ğ
	`Mux1H
(
d_£l
, 
io_out
.
	`m­
(
_
.hrdata))

48 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/package.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
amba


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
·ckage
 
objeù
 
	gahb


10 
ty³
 
	gAHBOutw¬dNode
 = 
Outw¬dNodeHªdË
[
AHBMa¡”PÜtP¬am‘”s
, 
AHBSÏvePÜtP¬am‘”s
, 
AHBEdgeP¬am‘”s
, 
AHBBundË
]

11 
ty³
 
	gAHBInw¬dNode
 = 
Inw¬dNodeHªdË
[
AHBMa¡”PÜtP¬am‘”s
, 
AHBSÏvePÜtP¬am‘”s
, 
AHBEdgeP¬am‘”s
, 
AHBBundË
]

12 
ty³
 
	gAHBNode
 = 
Sim¶eNodeHªdË
[
AHBMa¡”PÜtP¬am‘”s
, 
AHBSÏvePÜtP¬am‘”s
, 
AHBEdgeP¬am‘”s
, 
AHBBundË
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Bundles.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
G’”icP¬am‘”izedBundË


8 
ab¡¿ù
 cÏs 
	cAPBBundËBa£
(
·¿ms
: 
APBBundËP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

11 şas 
	cAPBBundË
(
·¿ms
: 
APBBundËP¬am‘”s
è
ex‹nds
 
	$APBBundËBa£
(
·¿ms
)

14 
v®
 
p£l
 = 
	$BoŞ
(
OUTPUT
)

15 
v®
 
³ÇbË
 = 
	$BoŞ
(
OUTPUT
)

18 
v®
 
pwr™e
 = 
	$BoŞ
(
OUTPUT
)

19 
v®
 
·ddr
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
addrB™s
)

20 
v®
 
µrÙ
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
´ÙB™s
)

21 
v®
 
pwd©a
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
d©aB™s
)

22 
v®
 
p¡rb
 = 
	`UIÁ
(
OUTPUT
, 
width
 = 
·¿ms
.
d©aB™s
/8)

24 
v®
 
´—dy
 = 
	$BoŞ
(
INPUT
)

25 
v®
 
p¦v”r
 = 
	$BoŞ
(
INPUT
)

26 
v®
 
´d©a
 = 
	$UIÁ
(
INPUT
, 
width
 = 
·¿ms
.
d©aB™s
)

28 
def
 
	$t›off
() {

29 
´—dy
.
dœ
 
m©ch
 {

30 
INPUT
 =>

31 
´—dy
 :ğ
	`BoŞ
(
çl£
)

32 
p¦v”r
 :ğ
	`BoŞ
(
çl£
)

33 
´d©a
 :ğ
	`UIÁ
(0)

34 
OUTPUT
 =>

35 
pwr™e
 :ğ
	`BoŞ
(
çl£
)

36 
·ddr
 :ğ
	`UIÁ
(0)

37 
µrÙ
 :ğ
APBP¬am‘”s
.
PROT_DEFAULT


38 
pwd©a
 :ğ
	`UIÁ
(0)

39 
p¡rb
 :ğ
	`UIÁ
(0)

40 
_
 =>

43 
	}
}

45 
objeù
 
APBBundË


47 
def
 
­¶y
(
·¿ms
: 
APBBundËP¬am‘”s
èğ
Ãw
 
APBBundË
(params)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Nodes.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
objeù
 
APBImp
 
ex‹nds
 
	gSim¶eNodeImp
[
APBMa¡”PÜtP¬am‘”s
, 
APBSÏvePÜtP¬am‘”s
, 
APBEdgeP¬am‘”s
, 
APBBundË
]

12 
def
 
edge
(
pd
: 
APBMa¡”PÜtP¬am‘”s
, 
pu
: 
APBSÏvePÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
APBEdgeP¬am‘”s
(pd,…u,…, sourceInfo)

13 
def
 
bundË
(
e
: 
APBEdgeP¬am‘”s
èğ
APBBundË
(e.bundle)

14 
def
 
»nd”
(
e
: 
APBEdgeP¬am‘”s
èğ
R’d”edEdge
(
cŞour
 = "#00ccff" , (e.
¦ave
.
b—tBy‹s
 * 8).
toSŒšg
)

16 
ov”ride
 
def
 
mixO
(
pd
: 
APBMa¡”PÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[APBMa¡”PÜtP¬am‘”s, 
APBSÏvePÜtP¬am‘”s
, 
APBBundË
]): APBMasterPortParameters =

17 
pd
.
cİy
(
ma¡”s
 =…d.ma¡”s.
m­
 { 
c
 => c.cİy (
nodeP©h
 = 
node
 +: c.nodePath) })

18 
ov”ride
 
def
 
mixI
(
pu
: 
APBSÏvePÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
APBMa¡”PÜtP¬am‘”s
, APBSÏvePÜtP¬am‘”s, 
APBBundË
]): APBSlavePortParameters =

19 
pu
.
cİy
(
¦aves
 =…u.¦aves.
m­
 { 
m
 => m.cİy (
nodeP©h
 = 
node
 +: m.nodePath) })

22 
şass
 
	$APBMa¡”Node
(
pÜtP¬ams
: 
Seq
[
APBMa¡”PÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SourûNode
(
APBImp
)(
pÜtP¬ams
)

23 
şass
 
	$APBSÏveNode
(
pÜtP¬ams
: 
Seq
[
APBSÏvePÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SškNode
(
APBImp
)(
pÜtP¬ams
)

24 
şass
 
	`APBNexusNode
(

25 
ma¡”Fn
: 
Seq
[
APBMa¡”PÜtP¬am‘”s
] => APBMasterPortParameters,

26 
¦aveFn
: 
Seq
[
APBSÏvePÜtP¬am‘”s
] => APBSlavePortParameters)(

27 
im¶ic™
 
v®Name
: 
V®Name
)

28 
ex‹nds
 
	$NexusNode
(
APBImp
)(
ma¡”Fn
, 
¦aveFn
)

30 
şass
 
	$APBId’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	`Id’t™yNode
(
APBImp
)()

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Parameters.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.
max


11 
şass
 
APBSÏveP¬am‘”s
(

12 
add»ss
: 
Seq
[
Add»ssS‘
],

13 
»sourûs
: 
Seq
[
Resourû
] = 
N
,

14 
»giÚTy³
: 
RegiÚTy³
.
T
 = RegiÚTy³.
GET_EFFECTS
,

15 
execubË
: 
BoŞ—n
 = 
çl£
,

16 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

17 
suµÜtsWr™e
: 
BoŞ—n
 = 
Œue
,

18 
suµÜtsR—d
: 
BoŞ—n
 = 
Œue
)

20 
add»ss
.
fÜ—ch
 { 
a
 => 
»quœe
 (a.
fš™e
) }

21 
add»ss
.
combš©iÚs
(2).
fÜ—ch
 { 
Seq
(
x
,
y
è=> 
»quœe
 (!x.
ov”Ïps
(y)) }

23 
v®
 
	gÇme
 = 
nodeP©h
.
Ï¡O±iÚ
.
m­
(
_
.
ÏzyModuË
.
Çme
).
g‘OrEl£
("disconnected")

24 
v®
 
maxAdd»ss
 = 
add»ss
.
m­
(
_
.
max
).max

25 
v®
 
mšAlignm’t
 = 
add»ss
.
m­
(
_
.
®ignm’t
).
mš


28 
şass
 
	$APBSÏvePÜtP¬am‘”s
(

29 
¦aves
: 
Seq
[
APBSÏveP¬am‘”s
],

30 
b—tBy‹s
: 
IÁ
)

32 
	`»quœe
 (!
¦aves
.
isEm±y
)

33 
	`»quœe
 (
	`isPow2
(
b—tBy‹s
))

35 
v®
 
maxAdd»ss
 = 
¦aves
.
	`m­
(
_
.maxAdd»ss).
max


38 
¦aves
.
	`combš©iÚs
(2).
fÜ—ch
 { 
	`Seq
(
x
,
y
) =>

39 
x
.
add»ss
.
fÜ—ch
 { 
a
 => 
y
.add»ss.fÜ—ch { 
b
 =>

40 
	`»quœe
 (!
a
.
	`ov”Ïps
(
b
))

43 
	}
}

45 
şass
 
APBMa¡”P¬am‘”s
(

46 
Çme
: 
SŒšg
,

47 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

49 
şass
 
	$APBMa¡”PÜtP¬am‘”s
(

50 
ma¡”s
: 
Seq
[
APBMa¡”P¬am‘”s
])

52 
şass
 
	$APBBundËP¬am‘”s
(

53 
addrB™s
: 
IÁ
,

54 
d©aB™s
: 
IÁ
)

56 
	`»quœe
 (
d©aB™s
 >= 8)

57 
	`»quœe
 (
addrB™s
 >= 1)

58 
	`»quœe
 (
	`isPow2
(
d©aB™s
))

61 
v®
 
´ÙB™s
 = 
APBP¬am‘”s
.protBits

63 
def
 (
x
: 
APBBundËP¬am‘”s
) =

64 
	`APBBundËP¬am‘”s
(

65 
	`max
(
addrB™s
, 
x
.addrBits),

66 
	`max
(
d©aB™s
, 
x
.dataBits))

67 
	}
}

69 
objeù
 
	gAPBBundËP¬am‘”s


71 
v®
 
	gem±yBundËP¬ams
 = 
APBBundËP¬am‘”s
(
addrB™s
 = 1, 
d©aB™s
 = 8)

72 
def
 (
x
: 
Seq
[
APBBundËP¬am‘”s
]èğx.
fŞdLeá
(
em±yBundËP¬ams
)((x,
	gy
è=> x.(
y
))

74 
def
 
­¶y
(
ma¡”
: 
APBMa¡”PÜtP¬am‘”s
, 
¦ave
: 
APBSÏvePÜtP¬am‘”s
) =

75 
Ãw
 
APBBundËP¬am‘”s
(

76 
addrB™s
 = 
log2Up
(
¦ave
.
maxAdd»ss
+1),

77 
d©aB™s
 = 
¦ave
.
b—tBy‹s
 * 8)

80 
şass
 
	$APBEdgeP¬am‘”s
(

81 
ma¡”
: 
APBMa¡”PÜtP¬am‘”s
,

82 
¦ave
: 
APBSÏvePÜtP¬am‘”s
,

83 
·¿ms
: 
P¬am‘”s
,

84 
sourûInfo
: 
SourûInfo
)

86 
v®
 
bundË
 = 
	`APBBundËP¬am‘”s
(
ma¡”
, 
¦ave
)

87 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Protocol.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


7 
objeù
 
	gAPBP¬am‘”s


10 
v®
 
	g´ÙB™s
 = 3

12 
def
 
PROT_PRIVILEDGED
 = 
UIÁ
(1, 
width
 = 
´ÙB™s
)

13 
def
 
PROT_NONSECURE
 = 
UIÁ
(2, 
width
 = 
´ÙB™s
)

14 
def
 
PROT_INSTRUCTION
 = 
UIÁ
(4, 
width
 = 
´ÙB™s
)

15 
def
 
PROT_DEFAULT
 = 
PROT_PRIVILEDGED


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/RegisterRouter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.{
	gIÁSourûNode
, 
	gIÁSourûPÜtSim¶e
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
H‘”og’eousBag


11 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

13 
şass
 
	$APBRegi¡”Node
(
add»ss
: 
Add»ssS‘
, 
cÚcu¼’cy
: 
IÁ
 = 0, 
b—tBy‹s
: IÁ = 4, 
undefZ”o
: 
BoŞ—n
 = 
Œue
, 
execubË
: BoŞ—Àğ
çl£
)(
im¶ic™
 
v®Name
: 
V®Name
)

14 
ex‹nds
 
	$SškNode
(
APBImp
)(
	`Seq
(
	`APBSÏvePÜtP¬am‘”s
(

15 
	`Seq
(
	`APBSÏveP¬am‘”s
(

16 
add»ss
 = 
	`Seq
(address),

17 
execubË
 =ƒxecutable,

18 
suµÜtsWr™e
 = 
Œue
,

19 
suµÜtsR—d
 = 
Œue
)),

20 
b—tBy‹s
 = beatBytes)))

22 
	`»quœe
 (
add»ss
.
cÚtiguous
)

26 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*) = {

27 
	`v®
 (
­b
, 
_
èğ
this
.
	`š
(0)

29 
v®
 
šdexB™s
 = 
	`log2Up
((
add»ss
.
mask
+1)/
b—tBy‹s
)

30 
v®
 
·¿ms
 = 
	`RegM­³rP¬ams
(
šdexB™s
, 
b—tBy‹s
, 1)

31 
v®
 
š
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`RegM­³rIÅut
(
·¿ms
)))

32 
v®
 
out
 = 
	`RegM­³r
(
b—tBy‹s
, 
cÚcu¼’cy
, 
undefZ”o
, 
š
, 
m­pšg
:
_
*)

35 
v®
 
k’
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

36 
	`wh’
 (
š
.
	`fœe
()è{ 
k’
 :ğ
	`BoŞ
(
Œue
) }

37 
	`wh’
 (
out
.
	`fœe
()è{ 
k’
 :ğ
	`BoŞ
(
çl£
) }

39 
š
.
b™s
.
»ad
 :ğ!
­b
.
pwr™e


40 
š
.
b™s
.
šdex
 :ğ
­b
.
·ddr
 >> 
	`log2Ce
(
b—tBy‹s
)

41 
š
.
b™s
.
d©a
 :ğ
­b
.
pwd©a


42 
š
.
b™s
.
mask
 :ğ
	`Mux
(
­b
.
pwr™e
,‡pb.
p¡rb
, 
	`UIÁ
((1<<
b—tBy‹s
) - 1))

43 
š
.
b™s
.
exŒa
 :ğ
	`UIÁ
(0)

45 
š
.
v®id
 :ğ
­b
.
p£l
 && !
k’


46 
out
.
»ady
 :ğ
­b
.
³ÇbË


48 
­b
.
´—dy
 :ğ
out
.
v®id


49 
­b
.
p¦v”r
 :ğ
	`BoŞ
(
çl£
)

50 
­b
.
´d©a
 :ğ
out
.
b™s
.
d©a


52 
	}
}

57 
ab¡¿ù
 
şass
 
	$APBRegi¡”Rou‹rBa£
(
add»ss
: 
Add»ssS‘
, 
š‹¼u±s
: 
IÁ
, 
cÚcu¼’cy
: IÁ, 
b—tBy‹s
: IÁ, 
undefZ”o
: 
BoŞ—n
, 
execubË
: BoŞ—n)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


59 
v®
 
node
 = 
	`APBRegi¡”Node
(
add»ss
, 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

60 
v®
 
šŠode
 = 
	`IÁSourûNode
(
	`IÁSourûPÜtSim¶e
(
num
 = 
š‹¼u±s
))

61 
	}
}

63 şas 
	cAPBRegBundËArg
()(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
)

65 şas 
	cAPBRegBundËBa£
(
¬g
: 
APBRegBundËArg
è
ex‹nds
 
BundË


67 
im¶ic™
 
v®
 
p
 = 
¬g
.p

70 
şass
 
APBRegBundË
[
P
](
v®
 
·¿ms
: P, 
¬g
: 
APBRegBundËArg
è
ex‹nds
 
	$APBRegBundËBa£
(
¬g
)

72 
şass
 
APBRegModuË
[
P
, 
B
 <: 
APBRegBundËBa£
](
v®
 
·¿ms
: P, 
bundËBud”
: => B, 
rou‹r
: 
APBRegi¡”Rou‹rBa£
)

73 
ex‹nds
 
	$LazyModuËImp
(
rou‹r
è
w™h
 
HasRegM­


75 
v®
 
io
 = 
	`IO
(
bundËBud”
)

76 
v®
 
š‹¼u±s
 = ià(
rou‹r
.
šŠode
.
out
.
isEm±y
è
	`Vec
(0, 
	`BoŞ
()èrou‹r.šŠode.
	`out
(0).
_1


77 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*èğ
rou‹r
.
node
.»gm­(m­pšg:
_
*)

78 
	}
}

80 
şass
 
APBRegi¡”Rou‹r
[
B
 <: 
APBRegBundËBa£
, 
M
 <: 
LazyModuËImp
]

81 (
v®
 
ba£
: 
BigIÁ
, v® 
	gš‹¼u±s
: 
IÁ
 = 0, v® 
	gsize
: BigIÁ = 4096, v® 
	gcÚcu¼’cy
: IÁ = 0, v® 
	gb—tBy‹s
: IÁ = 4, 
	gundefZ”o
: 
BoŞ—n
 = 
Œue
, 
	gexecubË
: BoŞ—Àğ
çl£
)

82 (
bundËBud”
: 
APBRegBundËArg
 => 
B
)

83 (
moduËBud”
: (=> 
B
, 
	gAPBRegi¡”Rou‹rBa£
è=> 
M
)(
im¶ic™
 
p
: 
P¬am‘”s
)

84 
ex‹nds
 
APBRegi¡”Rou‹rBa£
(
Add»ssS‘
(
ba£
, 
size
-1), 
š‹¼u±s
, 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

86 
»quœe
 (
isPow2
(
size
))

89 
Ïzy
 
v®
 
	gmoduË
 = 
moduËBud”
(
bundËBud”
(
APBRegBundËArg
()), 
this
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/SRAM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
LFSRNoi£Mak”


11 
şass
 
	$APBRAM
(

12 
add»ss
: 
Add»ssS‘
,

13 
execubË
: 
BoŞ—n
 = 
Œue
,

14 
b—tBy‹s
: 
IÁ
 = 4,

15 
devName
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

16 
”rÜs
: 
Seq
[
Add»ssS‘
] = 
N
,

17 
fuzzR—dy
: 
BoŞ—n
 = 
çl£
,

18 
fuzzE¼Ü
: 
BoŞ—n
 = 
çl£
)

19 (
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Dlom©icSRAM
(
add»ss
, 
b—tBy‹s
, 
devName
)

21 
v®
 
node
 = 
	`APBSÏveNode
(
	`Seq
(
	`APBSÏvePÜtP¬am‘”s
(

22 
	`Seq
(
	`APBSÏveP¬am‘”s
(

23 
add»ss
 = 
	`Li¡
×dd»ssè++ 
”rÜs
,

24 
»sourûs
 =„esources,

25 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

26 
execubË
 =ƒxecutable,

27 
suµÜtsR—d
 = 
Œue
,

28 
suµÜtsWr™e
 = 
Œue
)),

29 
b—tBy‹s
 = beatBytes)))

31 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

32 
	`v®
 (
š
, 
_
èğ
node
.
	`š
(0)

33 
v®
 
mem
 = 
	`makeSšgËPÜ‹dBy‹Wr™eSeqMem
(1 << 
mask
.
	`f‹r
(
b
=>b).
size
)

35 
v®
 
·ddr
 = 
	`C©
((
mask
 
	`z
 (
š
.·dd¸>> 
	`log2Ce
(
b—tBy‹s
)).
toBoŞs
).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
).
»v”£
)

36 
v®
 
Ëg®
 = 
add»ss
.
	`cÚšs
(
š
.
·ddr
)

38 
v®
 
»ad
 = 
š
.
p£l
 && !š.
³ÇbË
 && !š.
pwr™e


39 
	`wh’
 (
š
.
p£l
 && !š.
³ÇbË
 && in.
pwr™e
 && 
Ëg®
) {

40 
mem
.
	`wr™e
(
·ddr
, 
Vec
.
	`buÏ‹
(
b—tBy‹s
è{ 
i
 => 
š
.
	`pwd©a
(8*(i+1)-1, 8*iè}, in.
p¡rb
.
toBoŞs
)

43 
š
.
´—dy
 :ğ
	`BoŞ
(!
fuzzR—dy
è|| 
	`LFSRNoi£Mak”
(1)(0)

44 
š
.
p¦v”r
 :ğ
	`RegEÇbË
(!
Ëg®
, !š.
³ÇbË
è|| (
	`BoŞ
(
fuzzE¼Ü
è&& 
	`LFSRNoi£Mak”
(1)(0))

45 
š
.
´d©a
 :ğ
mem
.
	`»adAndHŞd
(
·ddr
, 
»ad
).
asUIÁ


47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Test.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


11 
şass
 
	$RRTe¡0
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$APBRegi¡”Rou‹r
(
add»ss
, 0, 32, 0, 4)(

12 
Ãw
 
	`APBRegBundË
((), 
_
è
w™h
 
RRTe¡0BundË
)(

13 
Ãw
 
	`APBRegModuË
((), 
_
, _è
w™h
 
RRTe¡0ModuË
)

15 
şass
 
	$RRTe¡1
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$APBRegi¡”Rou‹r
(
add»ss
, 0, 32, 1, 4, 
çl£
)(

16 
Ãw
 
	`APBRegBundË
((), 
_
è
w™h
 
RRTe¡1BundË
)(

17 
Ãw
 
	`APBRegModuË
((), 
_
, _è
w™h
 
RRTe¡1ModuË
)

19 
şass
 
	$APBFuzzBridge
(
aFlow
: 
BoŞ—n
, 
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


21 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

22 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("APBFuzzMaster"))

23 
v®
 
xb¬
 = 
	`LazyModuË
(
Ãw
 
APBFªout
)

24 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`APBRAM
(
	`Add»ssS‘
(0x0, 0xff), 
fuzzR—dy
 = 
Œue
, 
fuzzE¼Ü
 =rue))

25 
v®
 
gpio
 = 
	`LazyModuË
(
Ãw
 
	`RRTe¡0
(0x100))

27 
¿m
.
node
 :ğ
xb¬
.node

28 
gpio
.
node
 :ğ
xb¬
.node

29 (
xb¬
.
node


30 :ğ
	`TLToAPB
(
aFlow
)

31 :ğ
	`TLD–ay”
(0.2)

32 :ğ
	`TLBufãr
(
BufãrP¬ams
.
æow
)

33 :ğ
	`TLD–ay”
(0.2)

34 :ğ
	`TLF¿gm’‹r
(4, 8)

35 :ğ
mod–
.
node


36 :ğ
fuzz
.
node
)

38 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

39 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

41 
	}
}

43 
şass
 
	$APBBridgeTe¡
(
aFlow
: 
BoŞ—n
, 
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

44 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`APBFuzzBridge
(
aFlow
, 
txns
)).
moduË
)

45 
io
.
fšished
 :ğ
dut
.io.finished

46 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Xbar.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
­b


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

11 şas 
	cAPBFªout
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

12 
v®
 
node
 = 
	`APBNexusNode
(

13 
ma¡”Fn
 = { 
	`Seq
(
m
) => m },

14 
¦aveFn
 = { 
£q
 => 
	`£q
(0).
	`cİy
(
¦aves
 = seq.
	`æ©M­
(
_
.¦aves)è
	}
})

16 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

17 ià(
node
.
edges
.
š
.
size
 >= 1) {

18 
	`»quœe
 (
node
.
edges
.
š
.
size
 == 1, "APBFanout does‚ot support multiple masters")

19 
	`»quœe
 (
node
.
edges
.
out
.
size
 > 0, "APBFanout„equires‡t†east one slave")

21 
	`v®
 (
š
, 
_
èğ
node
.
	`š
(0)

24 
	`v®
 (
io_out
, 
edgesOut
èğ
node
.
out
.
unz


25 
v®
 
pÜt0
 = 
	`edgesOut
(0).
¦ave


26 
edgesOut
.
fÜ—ch
 { 
edge
 =>

27 
v®
 
pÜt
 = 
edge
.
¦ave


28 
	`»quœe
 (
pÜt
.
b—tBy‹s
 =ğ
pÜt0
.beatBytes,

29 
s
"${port.slaves.map(_.name)} ${port.beatBytes} vs ${port0.slaves.map(_.name)} ${port0.beatBytes}")

32 
v®
 
pÜt_addrs
 = 
edgesOut
.
	`m­
(
_
.
¦ave
.
¦aves
.m­(_.
add»ss
).
æ©‹n
)

33 
v®
 
routšgMask
 = 
	`Add»ssDecod”
(
pÜt_addrs
)

34 
v®
 
rou‹_addrs
 = 
pÜt_addrs
.
	`m­
(
_
.m­(_.
	`wid’
(~
routšgMask
)).
di¡šù
)

36 
v®
 
£l
 = 
	`Vec
(
rou‹_addrs
.
	`m­
(
£q
 => seq.m­(
_
.
	`cÚšs
(
š
.
·ddr
)).
	`»duû
(_ || _)))

37 (
£l
 
z
 
io_out
è
fÜ—ch
 { (£l, 
out
) =>

38 
out
 :ğ
š


39 
out
.
p£l
 :ğ
£l
 && 
š
.psel

40 
out
.
³ÇbË
 :ğ
£l
 && 
š
.penable

43 
š
.
´—dy
 :ğ!
	`Mux1H
(
£l
, 
io_out
.
	`m­
(!
_
.pready))

44 
š
.
p¦v”r
 :ğ
	`Mux1H
(
£l
, 
io_out
.
	`m­
(
_
.pslverr))

45 
š
.
´d©a
 :ğ
	`Mux1H
(
£l
, 
io_out
.
	`m­
(
_
.prdata))

47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/package.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
amba


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
·ckage
 
objeù
 
	g­b


10 
ty³
 
	gAPBOutw¬dNode
 = 
Outw¬dNodeHªdË
[
APBMa¡”PÜtP¬am‘”s
, 
APBSÏvePÜtP¬am‘”s
, 
APBEdgeP¬am‘”s
, 
APBBundË
]

11 
ty³
 
	gAPBInw¬dNode
 = 
Inw¬dNodeHªdË
[
APBMa¡”PÜtP¬am‘”s
, 
APBSÏvePÜtP¬am‘”s
, 
APBEdgeP¬am‘”s
, 
APBBundË
]

12 
ty³
 
	gAPBNode
 = 
Sim¶eNodeHªdË
[
APBMa¡”PÜtP¬am‘”s
, 
APBSÏvePÜtP¬am‘”s
, 
APBEdgeP¬am‘”s
, 
APBBundË
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/AsyncCrossing.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
CrossšgW¿µ”


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
şass
 
	$AXI4AsyncCrossšgSourû
(
sync
: 
O±iÚ
[
IÁ
])(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
def
 
	`this
(
x
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
èğthis(
	`Some
(x))

15 
def
 
	`this
()(
im¶ic™
 
p
: 
P¬am‘”s
èğthis(
NÚe
)

17 
v®
 
node
 = 
	`AXI4AsyncSourûNode
(
sync
)

19 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

20 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

21 
v®
 
psync
 = 
sync
.
	`g‘OrEl£
(
edgeOut
.
¦ave
.
async
.sync)

22 
v®
 
·¿ms
 = 
edgeOut
.
¦ave
.
async
.
	`cİy
(
sync
 = 
psync
)

23 
out
.
¬
 <> 
	`ToAsyncBundË
(
š
.¬, 
·¿ms
)

24 
out
.
aw
 <> 
	`ToAsyncBundË
(
š
.aw, 
·¿ms
)

25 
out
. 
w
 <> 
	`ToAsyncBundË
(
š
. w, 
·¿ms
)

26 
š
 .
r
 <> 
	`FromAsyncBundË
(
out
.r, 
psync
)

27 
š
 .
b
 <> 
	`FromAsyncBundË
(
out
.b, 
psync
)

30 
	}
}

32 
şass
 
AXI4AsyncCrossšgSšk
(
·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
())(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


34 
v®
 
node
 = 
	`AXI4AsyncSškNode
(
·¿ms
)

36 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

37 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

38 
out
.
¬
 <> 
	`FromAsyncBundË
(
š
.¬, 
·¿ms
.
sync
)

39 
out
.
aw
 <> 
	`FromAsyncBundË
(
š
.aw, 
·¿ms
.
sync
)

40 
out
. 
w
 <> 
	`FromAsyncBundË
(
š
. w, 
·¿ms
.
sync
)

41 
š
 .
r
 <> 
	`ToAsyncBundË
(
out
.r, 
·¿ms
)

42 
š
 .
b
 <> 
	`ToAsyncBundË
(
out
.b, 
·¿ms
)

45 
	}
}

47 
objeù
 
	gAXI4AsyncCrossšgSourû


49 
def
 
­¶y
()(
im¶ic™
 
	gp
: 
P¬am‘”s
): 
AXI4AsyncSourûNode
 =‡µly(
NÚe
)

50 
def
 
­¶y
(
sync
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4AsyncSourûNode
 =‡µly(
Some
(sync))

51 
def
 
­¶y
(
sync
: 
O±iÚ
[
IÁ
])(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4AsyncSourûNode
 = {

52 
v®
 
axi4asourû
 = 
LazyModuË
(
Ãw
 
AXI4AsyncCrossšgSourû
(
sync
))

53 
axi4asourû
.
node


57 
objeù
 
AXI4AsyncCrossšgSšk


59 
def
 
­¶y
(
·¿ms
: 
AsyncQueueP¬ams
 = AsyncQueueP¬ams())(
im¶ic™
 
p
: 
P¬am‘”s
) = {

60 
v®
 
axi4asšk
 = 
LazyModuË
(
Ãw
 
AXI4AsyncCrossšgSšk
(
·¿ms
))

61 
axi4asšk
.
node


65 @
d•»ÿ‹d
("AXI4AsyncCrossing is fragile. Use AXI4AsyncCrossingSource‡nd AXI4AsyncCrossingSink", "rocket-chip 1.2")

66 
şass
 
AXI4AsyncCrossšg
(
·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
())(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


68 
v®
 
sourû
 = 
	`LazyModuË
(
Ãw
 
	`AXI4AsyncCrossšgSourû
())

69 
v®
 
sšk
 = 
	`LazyModuË
(
Ãw
 
	`AXI4AsyncCrossšgSšk
(
·¿ms
))

70 
v®
 
node
 = 
	`NodeHªdË
(
sourû
.node, 
sšk
.node)

72 
sšk
.
node
 :ğ
sourû
.node

74 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

75 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

76 
v®
 
š_şock
 = 
	`Clock
(
INPUT
)

77 
v®
 
š_»£t
 = 
	`BoŞ
(
INPUT
)

78 
v®
 
out_şock
 = 
	`Clock
(
INPUT
)

79 
v®
 
out_»£t
 = 
	`BoŞ
(
INPUT
)

82 
sourû
.
moduË
.
şock
 :ğ
io
.
š_şock


83 
sourû
.
moduË
.
»£t
 :ğ
io
.
š_»£t


84 
sšk
.
moduË
.
şock
 :ğ
io
.
out_şock


85 
sšk
.
moduË
.
»£t
 :ğ
io
.
out_»£t


87 
	}
}

90 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


92 şas 
	cAXI4RAMAsyncCrossšg
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

93 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AsyncCrossing"))

94 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

95 
v®
 
tßxi
 = 
	$LazyModuË
(
Ãw
 
TLToAXI4
)

96 
v®
 
i¦ªd
 = 
	`LazyModuË
(
Ãw
 
	`CrossšgW¿µ”
(
	$AsynchrÚousCrossšg
()))

97 
v®
 
¿m
 = 
i¦ªd
 { 
	`LazyModuË
(
Ãw
 
	`AXI4RAM
(
	`Add»ssS‘
(0x0, 0x3ff))) }

99 
mod–
.
node
 :ğ
fuzz
.node

100 
tßxi
.
node
 :ğ
mod–
.node

101 
i¦ªd
.
	$üossAXI4In
(
¿m
.
node
è:ğ
tßxi
.node

103 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

104 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

107 
v®
 
şocks
 = 
	`ModuË
(
Ãw
 
	`Pow2ClockDivid”
(2))

108 
i¦ªd
.
moduË
.
şock
 :ğ
şocks
.
io
.
şock_out


109 
	}
}

112 
şass
 
	$AXI4RAMAsyncCrossšgTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

113 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AXI4RAMAsyncCrossšg
(
txns
)).
moduË
)

114 
io
.
fšished
 :ğ
dut
.io.finished

115 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Buffer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
I¼evoÿbËIO


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

12 
şass
 
	$AXI4Bufãr
(

13 
aw
: 
BufãrP¬ams
,

14 
w
: 
BufãrP¬ams
,

15 
b
: 
BufãrP¬ams
,

16 
¬
: 
BufãrP¬ams
,

17 
r
: 
BufãrP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


19 
def
 
	`this
(
aw
: 
BufãrP¬ams
, 
br
: BufãrP¬ams)(
im¶ic™
 
p
: 
P¬am‘”s
) =his(aw,‡w, br,‡w, br)

20 
def
 
	`this
(
x
: 
BufãrP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
) =his(x, x)

21 
def
 
	`this
()(
im¶ic™
 
p
: 
P¬am‘”s
èğthis(
BufãrP¬ams
.)

23 
v®
 
node
 = 
	`AXI4Ad­‹rNode
(

24 
ma¡”Fn
 = { 
p
 =>… },

25 
¦aveFn
 = { 
p
 =>….
	`cİy
(
mšL©’cy
 =….mšL©’cy + 
	`mš
(
aw
.
Ï‹ncy
,
¬
.Ï‹ncyè+ mš(
r
.Ï‹ncy,
b
.latency)) })

27 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

28 
def
 
bufãr
[
T
 <: 
D©a
](
cÚfig
: 
BufãrP¬ams
, 
d©a
: 
I¼evoÿbËIO
[T]): IrrevocableIO[T] = {

29 ià(
cÚfig
.
isDefšed
) {

30 
Queue
.
	`œ»voÿbË
(
d©a
, 
cÚfig
.
d•th
, 
pe
=cÚfig.pe, 
æow
=config.flow)

32 
d©a


36 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

37 
out
.
aw
 <> 
	`bufãr
×w, 
š
 .aw)

38 
out
.
w
 <> 
	`bufãr
(w, 
š
 .w)

39 
š
 .
b
 <> 
	`bufãr
(b, 
out
.b)

40 
out
.
¬
 <> 
	`bufãr
×r, 
š
 .ar)

41 
š
 .
r
 <> 
	`bufãr
Ô, 
out
.r)

44 
	}
}

46 
objeù
 
	gAXI4Bufãr


48 
def
 
­¶y
(è(
im¶ic™
 
	gp
: 
P¬am‘”s
): 
AXI4Node
 =‡µly(
BufãrP¬ams
.)

49 
def
 
­¶y
(
z
: 
BufãrP¬ams
è(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =‡pply(z, z)

50 
def
 
­¶y
(
aw
: 
BufãrP¬ams
, 
br
: BufãrP¬ams)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =‡pply(aw,‡w, br,‡w, br)

51 
def
 
­¶y
(

52 
aw
: 
BufãrP¬ams
,

53 
w
: 
BufãrP¬ams
,

54 
b
: 
BufãrP¬ams
,

55 
¬
: 
BufãrP¬ams
,

56 
r
: 
BufãrP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =

58 
v®
 
axi4buf
 = 
LazyModuË
(
Ãw
 
AXI4Bufãr
(
aw
, 
w
, 
b
, 
¬
, 
r
))

59 
	gaxi4buf
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Bundles.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
I¼evoÿbË


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
ab¡¿ù
 cÏs 
	cAXI4BundËBa£
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

11 
ab¡¿ù
 cÏs 
	cAXI4BundËA
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËBa£
(
·¿ms
)

13 
v®
 
id
 = 
	$UIÁ
(
width
 = 
·¿ms
.
idB™s
)

14 
v®
 
addr
 = 
	$UIÁ
(
width
 = 
·¿ms
.
addrB™s
)

15 
v®
 
Ën
 = 
	$UIÁ
(
width
 = 
·¿ms
.
ËnB™s
)

16 
v®
 
size
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sizeB™s
)

17 
v®
 
bur¡
 = 
	$UIÁ
(
width
 = 
·¿ms
.
bur¡B™s
)

18 
v®
 
lock
 = 
	$UIÁ
(
width
 = 
·¿ms
.
lockB™s
)

19 
v®
 
ÿche
 = 
	$UIÁ
(
width
 = 
·¿ms
.
ÿcheB™s
)

20 
v®
 
´Ù
 = 
	$UIÁ
(
width
 = 
·¿ms
.
´ÙB™s
)

21 
v®
 
qos
 = 
	$UIÁ
(
width
 = 
·¿ms
.
qosB™s
)

22 
v®
 
u£r
 = ià(
·¿ms
.
u£rB™s
 > 0è
	`Some
(
	$UIÁ
(
width
 = 
·¿ms
.
u£rB™s
)è
NÚe


26 
def
 
	`by‹s1
(
x
:
IÁ
=0) = {

27 
v®
 
maxShiá
 = 1 << 
·¿ms
.
sizeB™s


28 
v®
 

 = 
	`UIÁ
((
	`BigIÁ
(1è<< 
maxShiá
) - 1)

29 (
	`C©
(
Ën
, 

è<< 
size
è>> 
maxShiá


31 
	}
}

34 şas 
	cAXI4BundËARW
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËA
(
·¿ms
)

36 
v®
 
w’
 = 
	`BoŞ
()

39 şas 
	cAXI4BundËAW
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËA
(
·¿ms
)

40 şas 
	cAXI4BundËAR
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËA
(
·¿ms
)

42 şas 
	cAXI4BundËW
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËBa£
(
·¿ms
)

45 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

46 
v®
 
¡rb
 = 
	`UIÁ
(
width
 = 
·¿ms
.
d©aB™s
/8)

47 
v®
 
Ï¡
 = 
	$BoŞ
()

48 
v®
 
cÜru±
 = ià(
·¿ms
.
wcÜru±
è
	`Some
(
	$BoŞ
()è
NÚe


51 şas 
	cAXI4BundËR
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËBa£
(
·¿ms
)

53 
v®
 
id
 = 
	$UIÁ
(
width
 = 
·¿ms
.
idB™s
)

54 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

55 
v®
 
»¥
 = 
	$UIÁ
(
width
 = 
·¿ms
.
»¥B™s
)

56 
v®
 
u£r
 = ià(
·¿ms
.
u£rB™s
 > 0è
	`Some
(
	$UIÁ
(
width
 = 
·¿ms
.
u£rB™s
)è
NÚe


57 
v®
 
Ï¡
 = 
	`BoŞ
()

60 şas 
	cAXI4BundËB
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËBa£
(
·¿ms
)

62 
v®
 
id
 = 
	$UIÁ
(
width
 = 
·¿ms
.
idB™s
)

63 
v®
 
»¥
 = 
	$UIÁ
(
width
 = 
·¿ms
.
»¥B™s
)

64 
v®
 
u£r
 = ià(
·¿ms
.
u£rB™s
 > 0è
	`Some
(
	$UIÁ
(
width
 = 
·¿ms
.
u£rB™s
)è
NÚe


67 şas 
	cAXI4BundË
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËBa£
(
·¿ms
)

69 
v®
 
aw
 = 
	`I¼evoÿbË
(
Ãw
 
	$AXI4BundËAW
(
·¿ms
))

70 
v®
 
w
 = 
	`I¼evoÿbË
(
Ãw
 
	$AXI4BundËW
 (
·¿ms
))

71 
v®
 
b
 = 
	`I¼evoÿbË
(
Ãw
 
	`AXI4BundËB
 (
·¿ms
)).
æ


72 
v®
 
¬
 = 
	`I¼evoÿbË
(
Ãw
 
	$AXI4BundËAR
(
·¿ms
))

73 
v®
 
r
 = 
	`I¼evoÿbË
(
Ãw
 
	`AXI4BundËR
 (
·¿ms
)).
æ


75 
def
 
	$t›off
() {

76 
¬
.
»ady
.
dœ
 
m©ch
 {

77 
INPUT
 =>

78 
¬
.
»ady
 :ğ
	`BoŞ
(
çl£
)

79 
aw
.
»ady
 :ğ
	`BoŞ
(
çl£
)

80 
w
.
»ady
 :ğ
	`BoŞ
(
çl£
)

81 
r
.
v®id
 :ğ
	`BoŞ
(
çl£
)

82 
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

83 
OUTPUT
 =>

84 
¬
.
v®id
 :ğ
	`BoŞ
(
çl£
)

85 
aw
.
v®id
 :ğ
	`BoŞ
(
çl£
)

86 
w
.
v®id
 :ğ
	`BoŞ
(
çl£
)

87 
r
.
»ady
 :ğ
	`BoŞ
(
çl£
)

88 
b
.
»ady
 :ğ
	`BoŞ
(
çl£
)

89 
_
 =>

92 
	}
}

94 
objeù
 
AXI4BundË


96 
def
 
­¶y
(
·¿ms
: 
AXI4BundËP¬am‘”s
èğ
Ãw
 
AXI4BundË
(params)

99 şas 
	cAXI4AsyncBundËBa£
(
·¿ms
: 
AXI4AsyncBundËP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

101 şas 
	cAXI4AsyncBundË
(
·¿ms
: 
AXI4AsyncBundËP¬am‘”s
è
ex‹nds
 
	$AXI4AsyncBundËBa£
(
·¿ms
)

103 
v®
 
aw
 = 
Ãw
 
	`AsyncBundË
Òew 
	`AXI4BundËAW
(
·¿ms
.
ba£
),…¬ams.
async
)

104 
v®
 
w
 = 
Ãw
 
	`AsyncBundË
Òew 
	`AXI4BundËW
 (
·¿ms
.
ba£
),…¬ams.
async
)

105 
v®
 
b
 = 
Ãw
 
	`AsyncBundË
Òew 
	`AXI4BundËB
 (
·¿ms
.
ba£
),…¬ams.
async
).
æ


106 
v®
 
¬
 = 
Ãw
 
	`AsyncBundË
Òew 
	`AXI4BundËAR
(
·¿ms
.
ba£
),…¬ams.
async
)

107 
v®
 
r
 = 
Ãw
 
	`AsyncBundË
Òew 
	`AXI4BundËR
 (
·¿ms
.
ba£
),…¬ams.
async
).
æ


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/CrossingHelper.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
şass
 
	$AXI4Inw¬dCrossšgH–³r
(
Çme
: 
SŒšg
, 
scİe
: 
LazyScİe
, 
node
: 
AXI4Inw¬dNode
) {

9 
def
 
	`­¶y
(
xšg
: 
ClockCrossšgTy³
 = 
NoCrossšg
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Inw¬dNode
 = {

10 
xšg
 
m©ch
 {

11 
x
: 
AsynchrÚousCrossšg
 =>

12 
node
 :*=* 
scİe
 { 
	`AXI4AsyncCrossšgSšk
(
x
.
asSškP¬ams
è:*=* 
	`AXI4AsyncNameNode
(
Çme
è} :*=* AXI4AsyncNameNodeÒameè:*=* 
	`AXI4AsyncCrossšgSourû
(x.
sourûSync
)

13 
	`R©iÚ®Crossšg
(
dœeùiÚ
) =>

14 
throw
 
Ãw
 
	`IÎeg®Argum’tExû±iÚ
("AXI4 Rational crossing unimplemented")

15 
	`SynchrÚousCrossšg
(
bufãr
) =>

16 
node
 :*=* 
scİe
 { 
	`AXI4Bufãr
(
bufãr
è:*=* 
	`AXI4NameNode
(
Çme
) } :*=* AXI4NameNode(name)

19 
	}
}

21 
şass
 
	$AXI4Outw¬dCrossšgH–³r
(
Çme
: 
SŒšg
, 
scİe
: 
LazyScİe
, 
node
: 
AXI4Outw¬dNode
) {

22 
def
 
	`­¶y
(
xšg
: 
ClockCrossšgTy³
 = 
NoCrossšg
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Outw¬dNode
 = {

23 
xšg
 
m©ch
 {

24 
x
: 
AsynchrÚousCrossšg
 =>

25 
	`AXI4AsyncCrossšgSšk
(
x
.
asSškP¬ams
è:*=* 
	`AXI4AsyncNameNode
(
Çme
è:*=* 
scİe
 { AXI4AsyncNameNodeÒameè:*=* 
	`AXI4AsyncCrossšgSourû
(x.
sourûSync
è} :*=* 
node


26 
	`R©iÚ®Crossšg
(
dœeùiÚ
) =>

27 
throw
 
Ãw
 
	`IÎeg®Argum’tExû±iÚ
("AXI4 Rational crossing unimplemented")

28 
	`SynchrÚousCrossšg
(
bufãr
) =>

29 
	`AXI4NameNode
(
Çme
è:*=* 
scİe
 { AXI4NameNodeÒameè:*=* 
	`AXI4Bufãr
(
bufãr
è} :*=* 
node


32 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Deinterleaver.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
I¼evoÿbËIO


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gËáOR
, 
	grightOR
, 
	gUIÁToOH1
, 
	gOH1ToOH
}

10 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

12 şas 
	cAXI4Deš‹¾—v”
(
maxR—dBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
	`»quœe
 (
maxR—dBy‹s
 >ğ1 && 
	$isPow2
(
maxR—dBy‹s
))

16 
v®
 
node
 = 
	`AXI4Ad­‹rNode
(

17 
ma¡”Fn
 = { 
mp
 => mp },

18 
¦aveFn
 = { 
¥
 => sp.
	`cİy
(
¦aves
 = sp.¦aves.
	`m­
(
s
 => s.copy(

19 
suµÜtsR—d
 = 
s
.suµÜtsR—d.
	`š‹r£ù
(
	`T¿nsãrSizes
(1, 
maxR—dBy‹s
)),

20 
š‹¾—vedId
 = 
	`Some
(0))))

21 
	}
})

23 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

24 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

25 
v®
 
’dId
 = 
edgeOut
.
ma¡”
.endId

26 
v®
 
b—tBy‹s
 = 
edgeOut
.
¦ave
.beatBytes

27 
v®
 
b—ts
 = (
maxR—dBy‹s
+
b—tBy‹s
-1) / beatBytes

30 
out
.
¬
 <> 
š
.ar

31 
out
.
aw
 <> 
š
.aw

32 
out
.
w
 <> 
š
.w

33 
š
.
b
 <> 
out
.b

35 ià(
b—ts
 <= 1) {

37 
š
.
r
 <> 
out
.r

40 
v®
 
qs
 = 
Seq
.
	`buÏ‹
(
’dId
è{ 
i
 =>

41 
v®
 
d•th
 = 
edgeOut
.
ma¡”
.
ma¡”s
.
	`fšd
(
_
.
id
.
	`cÚšs
(
i
)).
	`æ©M­
(_.
maxFlight
).
	`g‘OrEl£
(0)

42 ià(
d•th
 > 0) {

43 
	`ModuË
(
Ãw
 
	`Queue
(
out
.
r
.
b™s
.
şÚeTy³
, 
b—ts
)).
io


45 
	`Wœe
(
Ãw
 
	`QueueIO
(
out
.
r
.
b™s
.
şÚeTy³
, 
b—ts
))

50 
v®
 
locked
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

51 
v®
 
deq_id
 = 
	`Reg
(
	`UIÁ
(
width
=
	`log2Up
(
’dId
)))

52 
v®
 
’q_id
 = 
out
.
r
.
b™s
.
id


53 
v®
 
deq_OH
 = 
	`UIÁToOH
(
deq_id
, 
’dId
)

54 
v®
 
’q_OH
 = 
	`UIÁToOH
(
’q_id
, 
’dId
)

57 
v®
 
³ndšg
 = 
	`C©
(
Seq
.
	`buÏ‹
(
’dId
è{ 
i
 =>

58 
v®
 
d•th
 = 
edgeOut
.
ma¡”
.
ma¡”s
.
	`fšd
(
_
.
id
.
	`cÚšs
(
i
)).
	`æ©M­
(_.
maxFlight
).
	`g‘OrEl£
(0)

59 ià(
d•th
 == 0) {

60 
	`BoŞ
(
çl£
)

62 
v®
 
couÁ
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
=
	`log2Ce
(
b—ts
+1)))

63 
v®
 
Ãxt
 = 
	`Wœe
(
couÁ
)

64 
v®
 
šc
 = 
	`’q_OH
(
i
è&& 
out
.
r
.
	`fœe
(è&& out.r.
b™s
.
Ï¡


65 
v®
 
dec
 = 
	`deq_OH
(
i
è&& 
š
.
r
.
	`fœe
(è&& in.r.
b™s
.
Ï¡


66 
Ãxt
 :ğ
couÁ
 + 
šc
.
asUIÁ
 - 
dec
.asUInt

67 
couÁ
 :ğ
Ãxt


69 
	`as£¹
 (!
dec
 || 
couÁ
 =/ğ
	`UIÁ
(0))

70 
	`as£¹
 (!
šc
 || 
couÁ
 =/ğ
	`UIÁ
(
b—ts
))

71 
Ãxt
 =/ğ
	`UIÁ
(0)

73 }.
»v”£
)

76 
v®
 
wšÃr
 = 
³ndšg
 & ~(
	`ËáOR
(pending) << 1)

77 
	`wh’
 (!
locked
 || (
š
.
r
.
	`fœe
(è&& in.r.
b™s
.
Ï¡
)) {

78 
locked
 :ğ
³ndšg
.
ÜR


79 
deq_id
 :ğ
	`OHToUIÁ
(
wšÃr
)

83 
š
.
r
.
v®id
 :ğ
locked


84 
š
.
r
.
b™s
 :ğ
	`Vec
(
qs
.
	`m­
(
_
.
deq
.b™s))(
deq_id
)

85 (
deq_OH
.
toBoŞs
 
z
 
qs
è
fÜ—ch
 { (
s
, 
q
) =>

86 
q
.
deq
.
»ady
 :ğ
s
 && 
š
.
r
.
	`fœe
()

90 
out
.
r
.
»ady
 :ğ
	`Vec
(
qs
.
	`m­
(
_
.
’q
.»ady))(
’q_id
)

91 (
’q_OH
.
toBoŞs
 
z
 
qs
è
fÜ—ch
 { (
s
, 
q
) =>

92 
q
.
’q
.
v®id
 :ğ
s
 && 
out
.
r
.valid

93 
q
.
’q
.
b™s
 :ğ
out
.
r
.bits

97 
	}
}

100 
objeù
 
AXI4Deš‹¾—v”


102 
def
 
­¶y
(
maxR—dBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =

104 
v®
 
axi4dešt
 = 
LazyModuË
(
Ãw
 
AXI4Deš‹¾—v”
(
maxR—dBy‹s
))

105 
axi4dešt
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Delayer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
I¼evoÿbËIO


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
LFSRNoi£Mak”


12 şas 
	cAXI4D–ay”
(
q
: 
DoubË
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
node
 = 
	$AXI4Ad­‹rNode
()

15 
	`»quœe
 (0.0 <ğ
q
 && q < 1)

17 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

18 
def
 
ãed
[
T
 <: 
D©a
](
sšk
: 
I¼evoÿbËIO
[T], 
sourû
: I¼evoÿbËIO[T], 
noi£
: T) {

20 
v®
 
hŞd
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

21 
	`wh’
 (
sšk
.
v®id
è{ 
hŞd
 :ğ
	`BoŞ
(
Œue
) }

22 
	`wh’
 (
sšk
.
	`fœe
()è{ 
hŞd
 :ğ
	`BoŞ
(
çl£
) }

24 
v®
 
®low
 = 
hŞd
 || 
	`UIÁ
((
q
 * 65535.0).
toIÁ
è<ğ
	`LFSRNoi£Mak”
(16, 
sourû
.
v®id
)

25 
sšk
.
v®id
 :ğ
sourû
.v®id && 
®low


26 
sourû
.
»ady
 :ğ
sšk
.»ady && 
®low


27 
sšk
.
b™s
 :ğ
sourû
.bits

28 
	`wh’
 (!
sšk
.
v®id
è{ sšk.
b™s
 :ğ
noi£
 }

31 
def
 
ªoi£
[
T
 <: 
AXI4BundËA
](
b™s
: T) {

32 
b™s
.
id
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
idB™s
)

33 
b™s
.
addr
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
addrB™s
)

34 
b™s
.
Ën
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
ËnB™s
)

35 
b™s
.
size
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
sizeB™s
)

36 
b™s
.
bur¡
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
bur¡B™s
)

37 
b™s
.
lock
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
lockB™s
)

38 
b™s
.
ÿche
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
ÿcheB™s
)

39 
b™s
.
´Ù
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
´ÙB™s
)

40 
b™s
.
qos
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
qosB™s
)

41 ià(
b™s
.
·¿ms
.
u£rB™s
 > 0)

42 
b™s
.
u£r
.
g‘
 :ğ
	`LFSRNoi£Mak”
(b™s.
·¿ms
.
u£rB™s
)

45 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
_
), (out, _)) =>

46 
v®
 
¬noi£
 = 
	`Wœe
(
š
.
¬
.
b™s
)

47 
v®
 
awnoi£
 = 
	`Wœe
(
š
.
aw
.
b™s
)

48 
v®
 
wnoi£
 = 
	`Wœe
(
š
.
w
 .
b™s
)

49 
v®
 
ºoi£
 = 
	`Wœe
(
š
.
r
 .
b™s
)

50 
v®
 
bnoi£
 = 
	`Wœe
(
š
.
b
 .
b™s
)

52 
	`ªoi£
(
¬noi£
)

53 
	`ªoi£
(
awnoi£
)

55 
wnoi£
.
d©a
 :ğ
	`LFSRNoi£Mak”
(wnoi£.
·¿ms
.
d©aB™s
)

56 
wnoi£
.
¡rb
 :ğ
	`LFSRNoi£Mak”
(wnoi£.
·¿ms
.
d©aB™s
/8)

57 
wnoi£
.
Ï¡
 :ğ
	`LFSRNoi£Mak”
(1)(0)

59 
ºoi£
.
id
 :ğ
	`LFSRNoi£Mak”
Ônoi£.
·¿ms
.
idB™s
)

60 
ºoi£
.
d©a
 :ğ
	`LFSRNoi£Mak”
Ônoi£.
·¿ms
.
d©aB™s
)

61 
ºoi£
.
»¥
 :ğ
	`LFSRNoi£Mak”
Ônoi£.
·¿ms
.
»¥B™s
)

62 
ºoi£
.
Ï¡
 :ğ
	`LFSRNoi£Mak”
(1)(0)

63 ià(
ºoi£
.
·¿ms
.
u£rB™s
 > 0)

64 
ºoi£
.
u£r
.
g‘
 :ğ
	`LFSRNoi£Mak”
Ônoi£.
·¿ms
.
u£rB™s
)

66 
bnoi£
.
id
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
idB™s
)

67 
bnoi£
.
»¥
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
»¥B™s
)

68 ià(
bnoi£
.
·¿ms
.
u£rB™s
 > 0)

69 
bnoi£
.
u£r
.
g‘
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
u£rB™s
)

71 
	`ãed
(
out
.
¬
, 
š
.¬, 
¬noi£
)

72 
	`ãed
(
out
.
aw
, 
š
.aw, 
awnoi£
)

73 
	`ãed
(
out
.
w
, 
š
.w, 
wnoi£
)

74 
	`ãed
(
š
.
b
, 
out
.b, 
bnoi£
)

75 
	`ãed
(
š
.
r
, 
out
.r, 
ºoi£
)

78 
	}
}

80 
objeù
 
	gAXI4D–ay”


82 
def
 
­¶y
(
q
: 
DoubË
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =

84 
v®
 
axi4d–ay
 = 
LazyModuË
(
Ãw
 
AXI4D–ay”
(
q
))

85 
axi4d–ay
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Filter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
şass
 
AXI4F‹r
(

10 
Sf‹r
: 
AXI4SÏveP¬am‘”s
 => 
O±iÚ
[AXI4SÏveP¬am‘”s] = 
AXI4F‹r
.
Sid’t™y
,

11 
Mf‹r
: 
AXI4Ma¡”P¬am‘”s
 => 
O±iÚ
[AXI4Ma¡”P¬am‘”s] = 
AXI4F‹r
.
Mid’t™y


12 )(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
node
 = 
AXI4Ad­‹rNode
(

15 
¦aveFn
 = { 
¥
 => sp.
cİy
(
¦aves
 = sp.¦aves.
æ©M­
 { 
s
 =>

16 
v®
 
out
 = 
Sf‹r
(
s
)

17 
out
.
fÜ—ch
 { 
o
 =>

18 
o
.
add»ss
.
fÜ—ch
 { 
a
 => 
»quœe
 (
s
.add»ss.
m­
(
_
.
cÚšs
×)).
»duû
(_||_)) }

19 
»quœe
 (
o
.
»giÚTy³
 <ğ
s
.regionType)

21 
»quœe
 (
s
.
suµÜtsWr™e
.
cÚšs
(
o
.supportsWrite))

22 
»quœe
 (
s
.
suµÜtsR—d
 .
cÚšs
(
o
.supportsRead))

23 
»quœe
 (!
o
.
š‹¾—vedId
.
isDefšed
 || 
s
.interleavedId == o.interleavedId)

25 
out


27 
ma¡”Fn
 = { 
mp
 => mp.
cİy
(
ma¡”s
 = mp.ma¡”s.
æ©M­
 { 
m
 =>

28 
v®
 
out
 = 
Mf‹r
(
m
)

29 
out
.
fÜ—ch
 { 
o
 => 
»quœe
 (
m
.
id
.
cÚšs
(o.id)) }

30 
out


33 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

34 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

35 
out
 <> 
š


40 
objeù
 
	gAXI4F‹r


42 
def
 
	gMid’t™y
: 
AXI4Ma¡”P¬am‘”s
 => 
O±iÚ
[AXI4Ma¡”P¬am‘”s] = { 
m
 => 
Some
(m) }

43 
def
 
Sid’t™y
: 
AXI4SÏveP¬am‘”s
 => 
O±iÚ
[AXI4SÏveP¬am‘”s] = { 
s
 => 
Some
(s) }

44 
def
 
Smask
(
£Ëù
: 
Add»ssS‘
): 
AXI4SÏveP¬am‘”s
 => 
O±iÚ
[AXI4SÏveP¬am‘”s] = { 
s
 =>

45 
v®
 
f‹»d
 = 
s
.
add»ss
.
m­
(
_
.
š‹r£ù
(
£Ëù
)).
æ©‹n


46 
v®
 
®ignm’t
 = 
£Ëù
.alignment

47 
v®
 
maxT¿nsãr
 = 1 << 30

48 
v®
 
ÿpT¿nsãr
 = ià(
®ignm’t
 =ğ0 ||‡lignm’ˆ> 
maxT¿nsãr
èmaxT¿nsã¸®ignm’t.
toIÁ


49 
v®
 
ÿp
 = 
T¿nsãrSizes
(1, 
ÿpT¿nsãr
)

50 ià(
	gf‹»d
.
	gisEm±y
è{ 
	gNÚe
 } {

51 
Some
(
s
.
cİy
(

52 
add»ss
 = 
f‹»d
,

53 
suµÜtsWr™e
 = 
s
.suµÜtsWr™e.
š‹r£ù
(
ÿp
),

54 
suµÜtsR—d
 = 
s
.suµÜtsR—d .
š‹r£ù
(
ÿp
)))

58 
def
 
­¶y
(

59 
Sf‹r
: 
AXI4SÏveP¬am‘”s
 => 
O±iÚ
[AXI4SÏveP¬am‘”s] = 
AXI4F‹r
.
Sid’t™y
,

60 
Mf‹r
: 
AXI4Ma¡”P¬am‘”s
 => 
O±iÚ
[AXI4Ma¡”P¬am‘”s] = 
AXI4F‹r
.
Mid’t™y


61 )(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =

63 
v®
 
axi4ft
 = 
LazyModuË
(
Ãw
 
AXI4F‹r
(
Sf‹r
, 
Mf‹r
))

64 
	gaxi4ft
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Fragmenter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
I¼evoÿbËIO


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gËáOR
, 
	grightOR
, 
	gUIÁToOH1
, 
	gOH1ToOH
}

10 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

12 şas 
	cAXI4F¿gm’‹r
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
maxB—ts
 = 1 << 
AXI4P¬am‘”s
.
ËnB™s


15 
def
 
	`ex·ndT¿nsãr
(
x
: 
T¿nsãrSizes
, 
b—tBy‹s
: 
IÁ
, 
®ignm’t
: 
BigIÁ
) =

16 ià(!
x
èx 
	`T¿nsãrSizes
(x.
mš
, 
®ignm’t
.
	`mš
(
maxB—ts
*
b—tBy‹s
).
štV®ue
)

17 
def
 
	`m­SÏve
(
s
: 
AXI4SÏveP¬am‘”s
, 
b—tBy‹s
: 
IÁ
èğs.
	`cİy
(

18 
suµÜtsWr™e
 = 
	`ex·ndT¿nsãr
(
s
.suµÜtsWr™e, 
b—tBy‹s
, s.
mšAlignm’t
),

19 
suµÜtsR—d
 = 
	`ex·ndT¿nsãr
(
s
.suµÜtsR—d, 
b—tBy‹s
, s.
mšAlignm’t
),

20 
š‹¾—vedId
 = 
NÚe
)

21 
def
 
	`m­Ma¡”
(
m
: 
AXI4Ma¡”P¬am‘”s
èğm.
	$cİy
(
®igÃd
 = 
Œue
)

23 
v®
 
node
 = 
	`AXI4Ad­‹rNode
(

24 
ma¡”Fn
 = { 
mp
 => mp.
	`cİy
(
ma¡”s
 = mp.ma¡”s.
	`m­
(
m
 => 
	`m­Ma¡”
(m)), 
u£rB™s
 = mp.userBits + 1) },

25 
¦aveFn
 = { 
¥
 => sp.
	`cİy
(
¦aves
 = sp.¦ave .
	`m­
(
s
 => 
	`m­SÏve
(s, sp.
b—tBy‹s
))è
	}
})

27 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

28 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

29 
v®
 
¦ave
 = 
edgeOut
.slave

30 
v®
 
¦aves
 = 
¦ave
.slaves

31 
v®
 
b—tBy‹s
 = 
¦ave
.beatBytes

32 
v®
 
lgBy‹s
 = 
	`log2Ce
(
b—tBy‹s
)

33 
v®
 
ma¡”
 = 
edgeIn
.master

34 
v®
 
ma¡”s
 = 
ma¡”
.masters

37 
¦aves
.
fÜ—ch
 { 
s
 =>

38 
	`»quœe
 (!
s
.
suµÜtsR—d
 || s.suµÜtsR—d.
	`cÚšs
(
b—tBy‹s
))

39 
	`»quœe
 (!
s
.
suµÜtsWr™e
 || s.suµÜtsWr™e.
	`cÚšs
(
b—tBy‹s
))

55 
def
 
	`äagm’t
(
a
: 
I¼evoÿbËIO
[
AXI4BundËA
], 
suµÜ‹dSizes1
: 
Seq
[
IÁ
]): (I¼evoÿbËIO[AXI4BundËA], 
BoŞ
, 
UIÁ
) = {

56 
v®
 
out
 = 
	`Wœe
(
a
)

58 
v®
 
busy
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

59 
v®
 
r_addr
 = 
	`Reg
(
	`UIÁ
(
width
 = 
a
.
b™s
.
·¿ms
.
addrB™s
))

60 
v®
 
r_Ën
 = 
	`Reg
(
	`UIÁ
(
width
 = 
AXI4P¬am‘”s
.
ËnB™s
))

62 
v®
 
Ën
 = 
	`Mux
(
busy
, 
r_Ën
, 
a
.
b™s
.len)

63 
v®
 
addr
 = 
	`Mux
(
busy
, 
r_addr
, 
a
.
b™s
.addr)

65 
v®
 
lo
 = ià(
lgBy‹s
 =ğ0è
	`UIÁ
(0è
	`addr
(lgBytes-1, 0)

66 
v®
 
hi
 = 
addr
 >> 
lgBy‹s


67 
v®
 
®ignm’t
 = 
	`hi
(
AXI4P¬am‘”s
.
ËnB™s
-1,0)

71 
v®
 
sizes1
 = (
suµÜ‹dSizes1
 
z
 
¦ave
.
¦aves
.
	`m­
(
_
.
add»ss
)).
	`f‹r
(_.
_1
 >ğ0).
	`groupBy
(_._1).
	`m­V®ues
(_.
	`æ©M­
(_.
_2
))

72 
v®
 
»duùiÚMask
 = 
	`Add»ssDecod”
(
sizes1
.
v®ues
.
toLi¡
)

73 
v®
 
suµÜt1
 = 
	`Mux1H
(
sizes1
.
toLi¡
.
m­
 { (
v
, 
a
) =>

74 (
Add»ssS‘
.
	`unify
(
a
.
	`m­
(
_
.
	`wid’
(~
»duùiÚMask
)).
di¡šù
).m­(_.
	`cÚšs
(
addr
)).
	`»duû
(_||_), 
	`UIÁ
(
v
))

83 
v®
 
flLow
 = 
	`rightOR
(
Ën
) >> 1

84 
v®
 
weHigh
 = ~
	`ËáOR
(~
Ën
)

85 
v®
 
»maš1
 = 
flLow
 | 
weHigh


86 
v®
 
®ign1
 = ~
	`ËáOR
(
®ignm’t
)

87 
v®
 
maxSuµÜ‹d1
 = 
»maš1
 & 
®ign1
 & 
suµÜt1


90 
v®
 
fixed
 = 
a
.
b™s
.
bur¡
 ==ğ
AXI4P¬am‘”s
.
BURST_FIXED


91 
v®
 
Ç¼ow
 = 
a
.
b™s
.
size
 =/ğ
	`UIÁ
(
lgBy‹s
)

92 
v®
 
bad
 = 
fixed
 || 
Ç¼ow


95 
v®
 
b—ts1
 = 
	`Mux
(
bad
, 
	`UIÁ
(0), 
maxSuµÜ‹d1
)

96 
v®
 
b—ts
 = 
	`OH1ToOH
(
b—ts1
)

98 
v®
 
šc_addr
 = 
addr
 + (
b—ts
 << 
a
.
b™s
.
size
)

99 
v®
 
w¿pMask
 = 
a
.
b™s
.
	`by‹s1
()

100 
v®
 
mux_addr
 = 
	`Wœe
(
š™
 = 
šc_addr
)

101 
	`wh’
 (
a
.
b™s
.
bur¡
 ==ğ
AXI4P¬am‘”s
.
BURST_WRAP
) {

102 
mux_addr
 :ğ(
šc_addr
 & 
w¿pMask
è| ~(~
a
.
b™s
.
addr
 | wrapMask)

104 
	`wh’
 (
a
.
b™s
.
bur¡
 ==ğ
AXI4P¬am‘”s
.
BURST_FIXED
) {

105 
mux_addr
 :ğ
a
.
b™s
.
addr


108 
v®
 
Ï¡
 = 
b—ts1
 ==ğ
Ën


109 
a
.
»ady
 :ğ
out
.»ady && 
Ï¡


110 
out
.
v®id
 :ğ
a
.valid

112 
out
.
b™s
 :ğ
a
.bits

113 
out
.
b™s
.
Ën
 :ğ
b—ts1


120 
out
.
b™s
.
addr
 :ğ~(~add¸| 
	`UIÁToOH1
(
a
.b™s.
size
, 
lgBy‹s
))

122 
	`wh’
 (
out
.
	`fœe
()) {

123 
busy
 :ğ!
Ï¡


124 
r_addr
 :ğ
mux_addr


125 
r_Ën
 :ğ
Ën
 - 
b—ts


128 (
out
, 
Ï¡
, 
b—ts
)

132 
v®
 
»adSizes1
 = 
¦aves
.
	`m­
(
s
 => s.
suµÜtsR—d
 .
max
/
b—tBy‹s
-1)

133 
v®
 
wr™eSizes1
 = 
¦aves
.
	`m­
(
s
 => s.
suµÜtsWr™e
.
max
/
b—tBy‹s
-1)

136 
	`v®
 (
š_¬
, 
¬_Ï¡
, 
_
èğ
	`äagm’t
(
Queue
.
	`œ»voÿbË
(
š
.
¬
, 1, 
æow
=
Œue
), 
»adSizes1
)

137 
	`v®
 (
š_aw
, 
aw_Ï¡
, 
w_b—ts
èğ
	`äagm’t
(
Queue
.
	`œ»voÿbË
(
š
.
aw
, 1, 
æow
=
Œue
), 
wr™eSizes1
)

141 
v®
 
š_w
 = 
Queue
.
	`œ»voÿbË
(
š
.
w
, 1, 
æow
=
Œue
)

144 
out
.
¬
 <> 
š_¬


145 
out
.
¬
.
b™s
.
u£r
.
g‘
 :ğ
	`C©
(
š_¬
.b™s.u£r.
toLi¡
 ++ 
	`Seq
(
¬_Ï¡
))

148 
v®
 
wb—ts_Ïtched
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

149 
v®
 
wb—ts_»ady
 = 
	`Wœe
(
	`BoŞ
())

150 
v®
 
wb—ts_v®id
 = 
	`Wœe
(
	`BoŞ
())

151 
	`wh’
 (
wb—ts_v®id
 && 
wb—ts_»ady
è{ 
wb—ts_Ïtched
 :ğ
	`BoŞ
(
Œue
) }

152 
	`wh’
 (
out
.
aw
.
	`fœe
()è{ 
wb—ts_Ïtched
 :ğ
	`BoŞ
(
çl£
) }

155 
out
.
aw
.
v®id
 :ğ
š_aw
.v®id && (
wb—ts_»ady
 || 
wb—ts_Ïtched
)

156 
š_aw
.
»ady
 :ğ
out
.
aw
.»ady && (
wb—ts_»ady
 || 
wb—ts_Ïtched
)

157 
wb—ts_v®id
 :ğ
š_aw
.
v®id
 && !
wb—ts_Ïtched


158 
out
.
aw
.
b™s
 :ğ
š_aw
.bits

159 
out
.
aw
.
b™s
.
u£r
.
g‘
 :ğ
	`C©
(
š_aw
.b™s.u£r.
toLi¡
 ++ 
	`Seq
(
aw_Ï¡
))

162 
v®
 
w_couÁ”
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
AXI4P¬am‘”s
.
ËnB™s
+1))

163 
v®
 
w_idË
 = 
w_couÁ”
 ==ğ
	`UIÁ
(0)

164 
v®
 
w_todo
 = 
	`Mux
(
w_idË
, Mux(
wb—ts_v®id
, 
w_b—ts
, 
	`UIÁ
(0)), 
w_couÁ”
)

165 
v®
 
w_Ï¡
 = 
w_todo
 ==ğ
	`UIÁ
(1)

166 
w_couÁ”
 :ğ
w_todo
 - 
out
.
w
.
	`fœe
()

167 
	`as£¹
 (!
out
.
w
.
	`fœe
(è|| 
w_todo
 =/ğ
	`UIÁ
(0))

170 
wb—ts_»ady
 :ğ
w_idË


171 
out
.
w
.
v®id
 :ğ
š_w
.v®id && (!
wb—ts_»ady
 || 
wb—ts_v®id
)

172 
š_w
.
»ady
 :ğ
out
.
w
.»ady && (!
wb—ts_»ady
 || 
wb—ts_v®id
)

173 
out
.
w
.
b™s
 :ğ
š_w
.bits

174 
out
.
w
.
b™s
.
Ï¡
 :ğ
w_Ï¡


176 
	`as£¹
 (!
out
.
w
.
v®id
 || !
š_w
.
b™s
.
Ï¡
 || 
w_Ï¡
)

179 
v®
 
r_Ï¡
 = 
out
.
r
.
b™s
.
u£r
.
	`g‘
(0)

180 
š
.
r
 <> 
out
.r

181 
š
.
r
.
b™s
.
Ï¡
 :ğ
out
.r.b™s.Ï¡ && 
r_Ï¡


182 
š
.
r
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
out
.r.b™s.u£r.
g‘
 >> 1 }

185 
v®
 
b_Ï¡
 = 
out
.
b
.
b™s
.
u£r
.
	`g‘
(0)

186 
š
.
b
 <> 
out
.b

187 
š
.
b
.
v®id
 :ğ
out
.b.v®id && 
b_Ï¡


188 
out
.
b
.
»ady
 :ğ
š
.b.»ady || !
b_Ï¡


189 
š
.
b
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
out
.b.b™s.u£r.
g‘
 >> 1 }

192 
v®
 
”rÜ
 = 
	`RegIn™
(
Vec
.
	`fl
(
edgeIn
.
ma¡”
.
’dId
è{ 
	`UIÁ
(0, 
width
 = 
AXI4P¬am‘”s
.
»¥B™s
)})

193 
š
.
b
.
b™s
.
»¥
 :ğ
out
.b.b™s.»¥ | 
	`”rÜ
(out.b.b™s.
id
)

194 (
”rÜ
 
z
 
	`UIÁToOH
(
out
.
b
.
b™s
.
id
, 
edgeIn
.
ma¡”
.
’dId
).
toBoŞs
è
fÜ—ch
 { (
»g
, 
£l
) =>

195 
	`wh’
 (
£l
 && 
out
.
b
.
	`fœe
()è{ 
»g
 :ğ
	`Mux
(
b_Ï¡
, 
	`UIÁ
(0),„eg | out.b.
b™s
.
»¥
) }

198 
	}
}

201 
objeù
 
	gAXI4F¿gm’‹r


203 
def
 
­¶y
()(
im¶ic™
 
	gp
: 
P¬am‘”s
): 
AXI4Node
 =

205 
v®
 
axi4äag
 = 
LazyModuË
(
Ãw
 
AXI4F¿gm’‹r
)

206 
axi4äag
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/IdIndexer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

10 şas 
	cAXI4IdIndex”
(
idB™s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


12 
	`»quœe
 (
idB™s
 >= 0)

14 
v®
 
node
 = 
	`AXI4Ad­‹rNode
(

15 
ma¡”Fn
 = { 
mp
 =>

17 
v®
 
ma¡”s
 = 
A¼ay
.
	`buÏ‹
(1 << 
idB™s
è{ 
i
 => 
	`AXI4Ma¡”P¬am‘”s
(

18 
Çme
 = "",

19 
id
 = 
	`IdRªge
(
i
, i+1),

20 
®igÃd
 = 
Œue
,

21 
maxFlight
 = 
	`Some
(0))

24 
v®
 
Çmes
 = 
A¼ay
.
	`fl
(1 << 
idB™s
è{ 
Ãw
 
sÿÏ
.
cŞËùiÚ
.
mubË
.
HashS‘
[
SŒšg
]() }

26 
mp
.
ma¡”s
.
fÜ—ch
 { 
m
 =>

27 
i
 <- 
m
.
id
.
¡¬t
 
uÁ
 m.id.
’d
) {

28 
v®
 
j
 = 
i
 % (1 << 
idB™s
)

29 
v®
 
Şd
 = 
	`ma¡”s
(
j
)

30 
	`Çmes
(
j
è+ğ
m
.
Çme


31 
	`ma¡”s
(
j
èğ
Şd
.
	`cİy
(

32 
®igÃd
 = 
Şd
.®igÃd && 
m
.aligned,

33 
maxFlight
 = 
Şd
.maxFlight.
æ©M­
 { 
o
 => 
m
.maxFlight.
m­
 { 
n
 => o+n } })

36 
mp
.
	`cİy
(

37 
u£rB™s
 = 
mp
.u£rB™ + 
	`max
(0, 
	`log2Ce
(mp.
’dId
è- 
idB™s
),

38 
ma¡”s
 = ma¡”s.
zW™hIndex
.
m­
 { (
m
,
i
è=> m.
	`cİy
(
Çme
 = 
	`Çmes
(i).
toLi¡
.
	`mkSŒšg
(", "))})

40 
¦aveFn
 = { 
¥
 => sp

41 
	}
})

43 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

44 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

47 
out
.
¬
 <> 
š
.ar

48 
out
.
aw
 <> 
š
.aw

49 
out
.
w
 <> 
š
.w

50 
š
.
b
 <> 
out
.b

51 
š
.
r
 <> 
out
.r

53 
v®
 
b™s
 = 
	`log2Ce
(
edgeIn
.
ma¡”
.
’dId
è- 
idB™s


54 ià(
b™s
 > 0) {

56 
out
.
¬
.
b™s
.
u£r
.
g‘
 :ğ
	`C©
(
š
.¬.b™s.u£r.
toLi¡
 ++ 
	`Seq
(š.¬.b™s.
id
 >> 
idB™s
))

57 
out
.
aw
.
b™s
.
u£r
.
g‘
 :ğ
	`C©
(
š
.aw.b™s.u£r.
toLi¡
 ++ 
	`Seq
(š.aw.b™s.
id
 >> 
idB™s
))

59 
š
.
r
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
out
.r.b™s.u£r.
g‘
 >> bits }

60 
š
.
b
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
out
.b.b™s.u£r.
g‘
 >> bits }

62 ià(
idB™s
 == 0) {

63 
out
.
¬
.
b™s
.
id
 :ğ
	`UIÁ
(0)

64 
out
.
aw
.
b™s
.
id
 :ğ
	`UIÁ
(0)

65 
š
.
r
.
b™s
.
id
 :ğ
out
.r.b™s.
u£r
.
g‘


66 
š
.
b
.
b™s
.
id
 :ğ
out
.b.b™s.
u£r
.
g‘


68 
š
.
r
.
b™s
.
id
 :ğ
	`C©
(
out
.r.b™s.
u£r
.
g‘
, out.r.bits.id)

69 
š
.
b
.
b™s
.
id
 :ğ
	`C©
(
out
.b.b™s.
u£r
.
g‘
, out.b.bits.id)

73 
	}
}

76 
objeù
 
	gAXI4IdIndex”


78 
def
 
­¶y
(
idB™s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =

80 
v®
 
axi4šdex
 = 
LazyModuË
(
Ãw
 
AXI4IdIndex”
(
idB™s
))

81 
axi4šdex
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Nodes.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
AsyncQueueP¬ams


11 
objeù
 
AXI4Imp
 
ex‹nds
 
	gSim¶eNodeImp
[
AXI4Ma¡”PÜtP¬am‘”s
, 
AXI4SÏvePÜtP¬am‘”s
, 
AXI4EdgeP¬am‘”s
, 
AXI4BundË
]

13 
def
 
edge
(
pd
: 
AXI4Ma¡”PÜtP¬am‘”s
, 
pu
: 
AXI4SÏvePÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
AXI4EdgeP¬am‘”s
(pd,…u,…, sourceInfo)

14 
def
 
bundË
(
e
: 
AXI4EdgeP¬am‘”s
èğ
AXI4BundË
(e.bundle)

15 
def
 
»nd”
(
e
: 
AXI4EdgeP¬am‘”s
èğ
R’d”edEdge
(
cŞour
 = "#00ccff" , 
Ïb–
 = (e.
¦ave
.
b—tBy‹s
 * 8).
toSŒšg
)

17 
ov”ride
 
def
 
mixO
(
pd
: 
AXI4Ma¡”PÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[AXI4Ma¡”PÜtP¬am‘”s, 
AXI4SÏvePÜtP¬am‘”s
, 
AXI4BundË
]): AXI4MasterPortParameters =

18 
pd
.
cİy
(
ma¡”s
 =…d.ma¡”s.
m­
 { 
c
 => c.cİy (
nodeP©h
 = 
node
 +: c.nodePath) })

19 
ov”ride
 
def
 
mixI
(
pu
: 
AXI4SÏvePÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
AXI4Ma¡”PÜtP¬am‘”s
, AXI4SÏvePÜtP¬am‘”s, 
AXI4BundË
]): AXI4SlavePortParameters =

20 
pu
.
cİy
(
¦aves
 =…u.¦aves.
m­
 { 
m
 => m.cİy (
nodeP©h
 = 
node
 +: m.nodePath) })

23 
şass
 
	$AXI4Ma¡”Node
(
pÜtP¬ams
: 
Seq
[
AXI4Ma¡”PÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SourûNode
(
AXI4Imp
)(
pÜtP¬ams
)

24 
şass
 
	$AXI4SÏveNode
(
pÜtP¬ams
: 
Seq
[
AXI4SÏvePÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SškNode
(
AXI4Imp
)(
pÜtP¬ams
)

25 
şass
 
	`AXI4NexusNode
(

26 
ma¡”Fn
: 
Seq
[
AXI4Ma¡”PÜtP¬am‘”s
] => AXI4MasterPortParameters,

27 
¦aveFn
: 
Seq
[
AXI4SÏvePÜtP¬am‘”s
] => AXI4SlavePortParameters)(

28 
im¶ic™
 
v®Name
: 
V®Name
)

29 
ex‹nds
 
	$NexusNode
(
AXI4Imp
)(
ma¡”Fn
, 
¦aveFn
)

30 
şass
 
	`AXI4Ad­‹rNode
(

31 
ma¡”Fn
: 
AXI4Ma¡”PÜtP¬am‘”s
 => AXI4Ma¡”PÜtP¬am‘” ğ{ 
m
 => m 
	}
},

32 
	g¦aveFn
: 
AXI4SÏvePÜtP¬am‘”s
 => AXI4SÏvePÜtP¬am‘” ğ{ 
s
 => s })(

33 
im¶ic™
 
v®Name
: 
V®Name
)

34 
ex‹nds
 
	$Ad­‹rNode
(
AXI4Imp
)(
ma¡”Fn
, 
¦aveFn
)

35 şas 
	cAXI4Id’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$Id’t™yNode
(
AXI4Imp
)()

37 
objeù
 
AXI4NameNode
 {

38 
def
 
	`­¶y
(
Çme
: 
V®Name
èğ
	$AXI4Id’t™yNode
()(
Çme
)

39 
def
 
	$­¶y
(
Çme
: 
O±iÚ
[
SŒšg
]): 
AXI4Id’t™yNode
 = 
	`­¶y
((
	`V®Name
Òame.
	`g‘OrEl£
("with_no_name"))))

40 
def
 
	$­¶y
(
Çme
: 
SŒšg
): 
AXI4Id’t™yNode
 = 
	`­¶y
(
	`Some
(name))

43 
objeù
 
AXI4AsyncImp
 
ex‹nds
 
Sim¶eNodeImp
[
AXI4AsyncMa¡”PÜtP¬am‘”s
, 
AXI4AsyncSÏvePÜtP¬am‘”s
, 
AXI4AsyncEdgeP¬am‘”s
, 
AXI4AsyncBundË
]

45 
def
 
	`edge
(
pd
: 
AXI4AsyncMa¡”PÜtP¬am‘”s
, 
pu
: 
AXI4AsyncSÏvePÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
	`AXI4AsyncEdgeP¬am‘”s
(pd,…u,…, sourceInfo)

46 
def
 
	`bundË
(
e
: 
AXI4AsyncEdgeP¬am‘”s
èğ
Ãw
 
	`AXI4AsyncBundË
Ó.
bundË
)

47 
def
 
	`»nd”
(
e
: 
AXI4AsyncEdgeP¬am‘”s
èğ
	`R’d”edEdge
(
cŞour
 = "#ff0000" , 
Ïb–
 =ƒ.
¦ave
.
async
.
d•th
.
toSŒšg
)

49 
ov”ride
 
def
 
	`mixO
(
pd
: 
AXI4AsyncMa¡”PÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[AXI4AsyncMa¡”PÜtP¬am‘”s, 
AXI4AsyncSÏvePÜtP¬am‘”s
, 
AXI4AsyncBundË
]): AXI4AsyncMasterPortParameters =

50 
pd
.
	`cİy
(
ba£
 =…d.ba£.cİy(
ma¡”s
 =…d.ba£.ma¡”s.
m­
 { 
c
 => c.cİy (
nodeP©h
 = 
node
 +: c.nodePath) }))

51 
ov”ride
 
def
 
	`mixI
(
pu
: 
AXI4AsyncSÏvePÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
AXI4AsyncMa¡”PÜtP¬am‘”s
, AXI4AsyncSÏvePÜtP¬am‘”s, 
AXI4AsyncBundË
]): AXI4AsyncSlavePortParameters =

52 
pu
.
	`cİy
(
ba£
 =…u.ba£.cİy(
¦aves
 =…u.ba£.¦aves.
m­
 { 
m
 => m.cİy (
nodeP©h
 = 
node
 +: m.nodePath) }))

53 
	}
}

55 
şass
 
	$AXI4AsyncSourûNode
(
sync
: 
O±iÚ
[
IÁ
])(
im¶ic™
 
v®Name
: 
V®Name
)

56 
ex‹nds
 
	$MixedAd­‹rNode
(
AXI4Imp
, 
AXI4AsyncImp
)(

57 
dFn
 = { 
p
 => 
	`AXI4AsyncMa¡”PÜtP¬am‘”s
Õè
	}
},

58 
	guFn
 = { 
p
 =>….
ba£
.
cİy
(
mšL©’cy
 =….ba£.mšL©’cy + 
sync
.
g‘OrEl£
Õ.
async
.sync)) })

60 
şass
 
	$AXI4AsyncSškNode
(
async
: 
AsyncQueueP¬ams
)(
im¶ic™
 
v®Name
: 
V®Name
)

61 
ex‹nds
 
	$MixedAd­‹rNode
(
AXI4AsyncImp
, 
AXI4Imp
)(

62 
dFn
 = { 
p
 =>….
ba£
 
	}
},

63 
	guFn
 = { 
p
 => 
AXI4AsyncSÏvePÜtP¬am‘”s
(
async
,…) })

65 şas 
	cAXI4AsyncId’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$Id’t™yNode
(
AXI4AsyncImp
)()

67 
objeù
 
AXI4AsyncNameNode
 {

68 
def
 
	`­¶y
(
Çme
: 
V®Name
èğ
	$AXI4AsyncId’t™yNode
()(
Çme
)

69 
def
 
	$­¶y
(
Çme
: 
O±iÚ
[
SŒšg
]): 
AXI4AsyncId’t™yNode
 = 
	`­¶y
((
	`V®Name
Òame.
	`g‘OrEl£
("with_no_name"))))

70 
def
 
	$­¶y
(
Çme
: 
SŒšg
): 
AXI4AsyncId’t™yNode
 = 
	`­¶y
(
	`Some
(name))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Parameters.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
AsyncQueueP¬ams


10 
impÜt
 
	gsÿÏ
.
	gm©h
.
max


12 
şass
 
AXI4SÏveP¬am‘”s
(

13 
add»ss
: 
Seq
[
Add»ssS‘
],

14 
»sourûs
: 
Seq
[
Resourû
] = 
N
,

15 
»giÚTy³
: 
RegiÚTy³
.
T
 = RegiÚTy³.
GET_EFFECTS
,

16 
execubË
: 
BoŞ—n
 = 
çl£
,

17 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

18 
suµÜtsWr™e
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

19 
suµÜtsR—d
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

20 
š‹¾—vedId
: 
O±iÚ
[
IÁ
] = 
NÚe
)

22 
add»ss
.
fÜ—ch
 { 
a
 => 
»quœe
 (a.
fš™e
) }

23 
add»ss
.
combš©iÚs
(2).
fÜ—ch
 { 
Seq
(
x
,
y
è=> 
»quœe
 (!x.
ov”Ïps
(y), 
s
"$x‡nd $y overlap") }

25 
v®
 
	gÇme
 = 
nodeP©h
.
Ï¡O±iÚ
.
m­
(
_
.
ÏzyModuË
.
Çme
).
g‘OrEl£
("disconnected")

26 
v®
 
maxT¿nsãr
 = 
max
(
suµÜtsWr™e
.max, 
suµÜtsR—d
.max)

27 
v®
 
	gmaxAdd»ss
 = 
add»ss
.
m­
(
_
.
max
).max

28 
v®
 
mšAlignm’t
 = 
add»ss
.
m­
(
_
.
®ignm’t
).
mš


31 
»quœe
 (
mšAlignm’t
 >ğ
maxT¿nsãr
,

32 
s
"minAlignment ($minAlignment) must be >= maxTransfer ($maxTransfer)")

35 
şass
 
	$AXI4SÏvePÜtP¬am‘”s
(

36 
¦aves
: 
Seq
[
AXI4SÏveP¬am‘”s
],

37 
b—tBy‹s
: 
IÁ
,

38 
wcÜru±
: 
BoŞ—n
 = 
çl£
,

39 
mšL©’cy
: 
IÁ
 = 1)

41 
	`»quœe
 (!
¦aves
.
isEm±y
)

42 
	`»quœe
 (
	`isPow2
(
b—tBy‹s
))

44 
v®
 
maxT¿nsãr
 = 
¦aves
.
	`m­
(
_
.maxT¿nsãr).
max


45 
v®
 
maxAdd»ss
 = 
¦aves
.
	`m­
(
_
.maxAdd»ss).
max


48 
	`»quœe
 (
maxT¿nsãr
 >ğ
b—tBy‹s
,

49 
s
"maxTransfer ($maxTransfer) should‚ot be smallerhan bus width ($beatBytes)")

51 
v®
 
lim™
 = 
b—tBy‹s
 * (1 << 
AXI4P¬am‘”s
.
ËnB™s
)

52 
	`»quœe
 (
maxT¿nsãr
 <ğ
lim™
,

53 
s
"maxTransfer ($maxTransfer) cannot be†argerhan $limit on‡ $beatBytes*8 width bus")

56 
¦aves
.
	`combš©iÚs
(2).
fÜ—ch
 { 
	`Seq
(
x
,
y
) =>

57 
x
.
add»ss
.
fÜ—ch
 { 
a
 => 
y
.add»ss.fÜ—ch { 
b
 =>

58 
	`»quœe
 (!
a
.
	`ov”Ïps
(
b
), 
s
"$a‡nd $b overlap")

61 
	}
}

63 
şass
 
AXI4Ma¡”P¬am‘”s
(

64 
Çme
: 
SŒšg
,

65 
id
: 
IdRªge
 = IdRange(0, 1),

66 
®igÃd
: 
BoŞ—n
 = 
çl£
,

67 
maxFlight
: 
O±iÚ
[
IÁ
] = 
NÚe
,

68 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

70 
maxFlight
.
fÜ—ch
 { 
m
 => 
	`»quœe
 (m >= 0) }

71 
	}
}

73 
şass
 
	$AXI4Ma¡”PÜtP¬am‘”s
(

74 
ma¡”s
: 
Seq
[
AXI4Ma¡”P¬am‘”s
],

75 
u£rB™s
: 
IÁ
 = 0)

77 
v®
 
’dId
 = 
ma¡”s
.
	`m­
(
_
.
id
.
’d
).
max


78 
	`»quœe
 (
u£rB™s
 >= 0)

81 
IdRªge
.
	`ov”Ïps
(
ma¡”s
.
	`m­
(
_
.
id
)).
fÜ—ch
 { (
x
, 
y
) =>

82 
	`»quœe
 (!
x
.
	`ov”Ïps
(
y
), 
s
"AXI4MasterParameters.id $x‡nd $y overlap")

84 
	}
}

86 
şass
 
	$AXI4BundËP¬am‘”s
(

87 
addrB™s
: 
IÁ
,

88 
d©aB™s
: 
IÁ
,

89 
idB™s
: 
IÁ
,

90 
u£rB™s
: 
IÁ
 = 0,

91 
wcÜru±
: 
BoŞ—n
 = 
çl£
)

93 
	`»quœe
 (
d©aB™s
 >ğ8, 
s
"AXI4 data bits must be >= 8 (got $dataBits)")

94 
	`»quœe
 (
addrB™s
 >ğ1, 
s
"AXI4‡ddr bits must be >= 1 (got $addrBits)")

95 
	`»quœe
 (
idB™s
 >ğ1, 
s
"AXI4 id bits must be >= 1 (got $idBits)")

96 
	`»quœe
 (
	`isPow2
(
d©aB™s
), 
s
"AXI4 data bits must be…ow2 (got $dataBits)")

99 
v®
 
ËnB™s
 = 
AXI4P¬am‘”s
.lenBits

100 
v®
 
sizeB™s
 = 
AXI4P¬am‘”s
.sizeBits

101 
v®
 
bur¡B™s
 = 
AXI4P¬am‘”s
.burstBits

102 
v®
 
lockB™s
 = 
AXI4P¬am‘”s
.lockBits

103 
v®
 
ÿcheB™s
 = 
AXI4P¬am‘”s
.cacheBits

104 
v®
 
´ÙB™s
 = 
AXI4P¬am‘”s
.protBits

105 
v®
 
qosB™s
 = 
AXI4P¬am‘”s
.qosBits

106 
v®
 
»¥B™s
 = 
AXI4P¬am‘”s
.respBits

108 
def
 (
x
: 
AXI4BundËP¬am‘”s
) =

109 
	`AXI4BundËP¬am‘”s
(

110 
	`max
(
addrB™s
, 
x
.addrBits),

111 
	`max
(
d©aB™s
, 
x
.dataBits),

112 
	`max
(
idB™s
, 
x
.idBits),

113 
	`max
(
u£rB™s
, 
x
.userBits),

114 
wcÜru±
 || 
x
.wcorrupt)

115 
	}
}

117 
objeù
 
	gAXI4BundËP¬am‘”s


119 
v®
 
	gem±yBundËP¬ams
 = 
AXI4BundËP¬am‘”s
(
addrB™s
=1, 
d©aB™s
=8, 
idB™s
=1, 
u£rB™s
=0, 
wcÜru±
=
çl£
)

120 
def
 (
x
: 
Seq
[
AXI4BundËP¬am‘”s
]èğx.
fŞdLeá
(
em±yBundËP¬ams
)((x,
	gy
è=> x.(
y
))

122 
def
 
­¶y
(
ma¡”
: 
AXI4Ma¡”PÜtP¬am‘”s
, 
¦ave
: 
AXI4SÏvePÜtP¬am‘”s
) =

123 
Ãw
 
AXI4BundËP¬am‘”s
(

124 
addrB™s
 = 
log2Up
(
¦ave
.
maxAdd»ss
+1),

125 
d©aB™s
 = 
¦ave
.
b—tBy‹s
 * 8,

126 
idB™s
 = 
log2Up
(
ma¡”
.
’dId
),

127 
u£rB™s
 = 
ma¡”
.userBits,

128 
wcÜru±
 = 
¦ave
.wcorrupt)

131 
şass
 
	$AXI4EdgeP¬am‘”s
(

132 
ma¡”
: 
AXI4Ma¡”PÜtP¬am‘”s
,

133 
¦ave
: 
AXI4SÏvePÜtP¬am‘”s
,

134 
·¿ms
: 
P¬am‘”s
,

135 
sourûInfo
: 
SourûInfo
)

137 
v®
 
bundË
 = 
	`AXI4BundËP¬am‘”s
(
ma¡”
, 
¦ave
)

138 
	}
}

140 
şass
 
	$AXI4AsyncSÏvePÜtP¬am‘”s
(
async
: 
AsyncQueueP¬ams
, 
ba£
: 
AXI4SÏvePÜtP¬am‘”s
)

141 
şass
 
	$AXI4AsyncMa¡”PÜtP¬am‘”s
(
ba£
: 
AXI4Ma¡”PÜtP¬am‘”s
)

143 
şass
 
	$AXI4AsyncBundËP¬am‘”s
(
async
: 
AsyncQueueP¬ams
, 
ba£
: 
AXI4BundËP¬am‘”s
)

144 
şass
 
	$AXI4AsyncEdgeP¬am‘”s
(
ma¡”
: 
AXI4AsyncMa¡”PÜtP¬am‘”s
, 
¦ave
: 
AXI4AsyncSÏvePÜtP¬am‘”s
, 
·¿ms
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
)

146 
v®
 
bundË
 = 
	`AXI4AsyncBundËP¬am‘”s
(
¦ave
.
async
, 
	`AXI4BundËP¬am‘”s
(
ma¡”
.
ba£
, slave.base))

147 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Protocol.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.{
	gI¼evoÿbË
, 
	gI¼evoÿbËIO
}

8 
objeù
 
	gAXI4P¬am‘”s


11 
v®
 
	gËnB™s
 = 8

12 
v®
 
sizeB™s
 = 3

13 
v®
 
bur¡B™s
 = 2

14 
v®
 
lockB™s
 = 1

15 
v®
 
ÿcheB™s
 = 4

16 
v®
 
´ÙB™s
 = 3

17 
v®
 
qosB™s
 = 4

18 
v®
 
»¥B™s
 = 2

20 
def
 
CACHE_RALLOCATE
 = 
UIÁ
(8, 
width
 = 
ÿcheB™s
)

21 
def
 
CACHE_WALLOCATE
 = 
UIÁ
(4, 
width
 = 
ÿcheB™s
)

22 
def
 
CACHE_MODIFIABLE
 = 
UIÁ
(2, 
width
 = 
ÿcheB™s
)

23 
def
 
CACHE_BUFFERABLE
 = 
UIÁ
(1, 
width
 = 
ÿcheB™s
)

25 
def
 
PROT_PRIVILEDGED
 = 
UIÁ
(1, 
width
 = 
´ÙB™s
)

26 
def
 
PROT_INSECURE
 = 
UIÁ
(2, 
width
 = 
´ÙB™s
)

27 
def
 
PROT_INSTRUCTION
 = 
UIÁ
(4, 
width
 = 
´ÙB™s
)

29 
def
 
BURST_FIXED
 = 
UIÁ
(0, 
width
 = 
bur¡B™s
)

30 
def
 
BURST_INCR
 = 
UIÁ
(1, 
width
 = 
bur¡B™s
)

31 
def
 
BURST_WRAP
 = 
UIÁ
(2, 
width
 = 
bur¡B™s
)

33 
def
 
RESP_OKAY
 = 
UIÁ
(0, 
width
 = 
»¥B™s
)

34 
def
 
RESP_EXOKAY
 = 
UIÁ
(1, 
width
 = 
»¥B™s
)

35 
def
 
RESP_SLVERR
 = 
UIÁ
(2, 
width
 = 
»¥B™s
)

36 
def
 
RESP_DECERR
 = 
UIÁ
(3, 
width
 = 
»¥B™s
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/RegisterRouter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.{
	gIÁSourûNode
, 
	gIÁSourûPÜtSim¶e
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gH‘”og’eousBag
, 
	gMaskG’
}

11 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

13 
şass
 
	$AXI4Regi¡”Node
(
add»ss
: 
Add»ssS‘
, 
cÚcu¼’cy
: 
IÁ
 = 0, 
b—tBy‹s
: IÁ = 4, 
undefZ”o
: 
BoŞ—n
 = 
Œue
, 
execubË
: BoŞ—Àğ
çl£
)(
im¶ic™
 
v®Name
: 
V®Name
)

14 
ex‹nds
 
	$SškNode
(
AXI4Imp
)(
	`Seq
(
	`AXI4SÏvePÜtP¬am‘”s
(

15 
	`Seq
(
	`AXI4SÏveP¬am‘”s
(

16 
add»ss
 = 
	`Seq
(address),

17 
execubË
 =ƒxecutable,

18 
suµÜtsWr™e
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

19 
suµÜtsR—d
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

20 
š‹¾—vedId
 = 
	`Some
(0))),

21 
b—tBy‹s
 = beatBytes,

22 
mšL©’cy
 = 1)))

24 
	`»quœe
 (
add»ss
.
cÚtiguous
)

28 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*) = {

29 
	`v®
 (
io
, 
_
èğ
this
.
	`š
(0)

30 
v®
 
¬
 = 
io
.ar

31 
v®
 
aw
 = 
io
.aw

32 
v®
 
w
 = 
io
.w

33 
v®
 
r
 = 
io
.r

34 
v®
 
b
 = 
io
.b

36 
v®
 
·¿ms
 = 
	`RegM­³rP¬ams
(
	`log2Up
((
add»ss
.
mask
+1)/
b—tBy‹s
), b—tBy‹s, 
¬
.
b™s
.·¿ms.
idB™s
 +‡r.b™s.·¿ms.
u£rB™s
)

37 
v®
 
š
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`RegM­³rIÅut
(
·¿ms
)))

40 
š
.
v®id
 :ğ
¬
.v®id || (
aw
.v®id && 
w
.valid)

41 
¬
.
»ady
 :ğ
š
.ready

42 
aw
.
»ady
 :ğ
š
.»ady && !
¬
.
v®id
 && 
w
 .valid

43 
w
 .
»ady
 :ğ
š
.»ady && !
¬
.
v®id
 && 
aw
.valid

45 
v®
 
¬_exŒa
 = 
	`C©
(
	`Seq
(
¬
.
b™s
.
id
è++‡r.b™s.
u£r
.
toLi¡
)

46 
v®
 
aw_exŒa
 = 
	`C©
(
	`Seq
(
aw
.
b™s
.
id
è++‡w.b™s.
u£r
.
toLi¡
)

47 
v®
 
š_exŒa
 = 
	`Mux
(
¬
.
v®id
, 
¬_exŒa
, 
aw_exŒa
)

48 
v®
 
addr
 = 
	`Mux
(
¬
.
v®id
,‡r.
b™s
.addr, 
aw
.bits.addr)

49 
v®
 
mask
 = 
	`MaskG’
(
¬
.
b™s
.
addr
,‡r.b™s.
size
, 
b—tBy‹s
)

51 
š
.
b™s
.
»ad
 :ğ
¬
.
v®id


52 
š
.
b™s
.
šdex
 :ğ
addr
 >> 
	`log2Ce
(
b—tBy‹s
)

53 
š
.
b™s
.
d©a
 :ğ
w
.bits.data

54 
š
.
b™s
.
mask
 :ğ
	`Mux
(
¬
.
v®id
, mask, 
w
.b™s.
¡rb
)

55 
š
.
b™s
.
exŒa
 :ğ
š_exŒa


58 
v®
 
out
 = 
Queue
.
	`œ»voÿbË
(

59 
	`RegM­³r
(
b—tBy‹s
, 
cÚcu¼’cy
, 
undefZ”o
, 
š
, 
m­pšg
:
_
*),

60 
’Œ›s
 = 2)

63 
out
.
»ady
 :ğ
	`Mux
(out.
b™s
.
»ad
, 
r
.»ady, 
b
.ready)

64 
r
.
v®id
 :ğ
out
.v®id && out.
b™s
.
»ad


65 
b
.
v®id
 :ğ
out
.v®id && !out.
b™s
.
»ad


67 
v®
 
out_id
 = ià(
r
.
b™s
.
·¿ms
.
idB™s
 =ğ0è
	`UIÁ
(0è(
out
.b™s.
exŒa
 >> 
¬
.b™s.·¿ms.
u£rB™s
)

69 
r
.
b™s
.
id
 :ğ
out_id


70 
r
.
b™s
.
d©a
 :ğ
out
.bits.data

71 
r
.
b™s
.
Ï¡
 :ğ
	`BoŞ
(
Œue
)

72 
r
.
b™s
.
»¥
 :ğ
AXI4P¬am‘”s
.
RESP_OKAY


73 
r
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
out
.b™s.
exŒa
 }

75 
b
.
b™s
.
id
 :ğ
out_id


76 
b
.
b™s
.
»¥
 :ğ
AXI4P¬am‘”s
.
RESP_OKAY


77 
b
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
out
.b™s.
exŒa
 }

79 
	}
}

84 
ab¡¿ù
 
şass
 
	$AXI4Regi¡”Rou‹rBa£
(
add»ss
: 
Add»ssS‘
, 
š‹¼u±s
: 
IÁ
, 
cÚcu¼’cy
: IÁ, 
b—tBy‹s
: IÁ, 
undefZ”o
: 
BoŞ—n
, 
execubË
: BoŞ—n)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


86 
v®
 
node
 = 
	`AXI4Regi¡”Node
(
add»ss
, 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

87 
v®
 
šŠode
 = 
	`IÁSourûNode
(
	`IÁSourûPÜtSim¶e
(
num
 = 
š‹¼u±s
))

88 
	}
}

90 şas 
	cAXI4RegBundËArg
()(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
)

92 şas 
	cAXI4RegBundËBa£
(
¬g
: 
AXI4RegBundËArg
è
ex‹nds
 
BundË


94 
im¶ic™
 
v®
 
p
 = 
¬g
.p

97 
şass
 
AXI4RegBundË
[
P
](
v®
 
·¿ms
: P, 
¬g
: 
AXI4RegBundËArg
è
ex‹nds
 
	$AXI4RegBundËBa£
(
¬g
)

99 
şass
 
AXI4RegModuË
[
P
, 
B
 <: 
AXI4RegBundËBa£
](
v®
 
·¿ms
: P, 
bundËBud”
: => B, 
rou‹r
: 
AXI4Regi¡”Rou‹rBa£
)

100 
ex‹nds
 
	$LazyModuËImp
(
rou‹r
è
w™h
 
HasRegM­


102 
v®
 
io
 = 
	`IO
(
bundËBud”
)

103 
v®
 
š‹¼u±s
 = ià(
rou‹r
.
šŠode
.
out
.
isEm±y
è
	`Vec
(0, 
	`BoŞ
()èrou‹r.šŠode.
	`out
(0).
_1


104 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*èğ
rou‹r
.
node
.»gm­(m­pšg:
_
*)

105 
	}
}

107 
şass
 
AXI4Regi¡”Rou‹r
[
B
 <: 
AXI4RegBundËBa£
, 
M
 <: 
LazyModuËImp
]

108 (
v®
 
ba£
: 
BigIÁ
, v® 
	gš‹¼u±s
: 
IÁ
 = 0, v® 
	gsize
: BigIÁ = 4096, v® 
	gcÚcu¼’cy
: IÁ = 0, v® 
	gb—tBy‹s
: IÁ = 4, 
	gundefZ”o
: 
BoŞ—n
 = 
Œue
, 
	gexecubË
: BoŞ—Àğ
çl£
)

109 (
bundËBud”
: 
AXI4RegBundËArg
 => 
B
)

110 (
moduËBud”
: (=> 
B
, 
	gAXI4Regi¡”Rou‹rBa£
è=> 
M
)(
im¶ic™
 
p
: 
P¬am‘”s
)

111 
ex‹nds
 
AXI4Regi¡”Rou‹rBa£
(
Add»ssS‘
(
ba£
, 
size
-1), 
š‹¼u±s
, 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

113 
»quœe
 (
isPow2
(
size
))

116 
Ïzy
 
v®
 
	gmoduË
 = 
moduËBud”
(
bundËBud”
(
AXI4RegBundËArg
()), 
this
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/SRAM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
şass
 
	$AXI4RAM
(

11 
add»ss
: 
Add»ssS‘
,

12 
execubË
: 
BoŞ—n
 = 
Œue
,

13 
b—tBy‹s
: 
IÁ
 = 4,

14 
devName
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

15 
”rÜs
: 
Seq
[
Add»ssS‘
] = 
N
,

16 
wcÜru±
: 
BoŞ—n
 = 
çl£
)

17 (
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Dlom©icSRAM
(
add»ss
, 
b—tBy‹s
, 
devName
)

19 
v®
 
node
 = 
	`AXI4SÏveNode
(
	`Seq
(
	`AXI4SÏvePÜtP¬am‘”s
(

20 
	`Seq
(
	`AXI4SÏveP¬am‘”s
(

21 
add»ss
 = 
	`Li¡
×dd»ssè++ 
”rÜs
,

22 
»sourûs
 =„esources,

23 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

24 
execubË
 =ƒxecutable,

25 
suµÜtsR—d
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

26 
suµÜtsWr™e
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

27 
š‹¾—vedId
 = 
	`Some
(0))),

28 
b—tBy‹s
 = beatBytes,

29 
wcÜru±
 = wcorrupt,

30 
mšL©’cy
 = 1)))

32 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

33 
	`v®
 (
š
, 
_
èğ
node
.
	`š
(0)

34 
v®
 
mem
 = 
	`makeSšgËPÜ‹dBy‹Wr™eSeqMem
(1 << 
mask
.
	`f‹r
(
b
=>b).
size
)

35 
v®
 
cÜru±
 = ià(
wcÜru±
è
	`Some
(
	`SeqMem
(1 << 
mask
.
	`f‹r
(
b
=>b).
size
, 
	`UIÁ
(
width
=2))è
NÚe


37 
v®
 
r_addr
 = 
	`C©
((
mask
 
	`z
 (
š
.
¬
.
b™s
.
addr
 >> 
	`log2Ce
(
b—tBy‹s
)).
toBoŞs
).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
).
»v”£
)

38 
v®
 
w_addr
 = 
	`C©
((
mask
 
	`z
 (
š
.
aw
.
b™s
.
addr
 >> 
	`log2Ce
(
b—tBy‹s
)).
toBoŞs
).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
).
»v”£
)

39 
v®
 
r_£l0
 = 
add»ss
.
	`cÚšs
(
š
.
¬
.
b™s
.
addr
)

40 
v®
 
w_£l0
 = 
add»ss
.
	`cÚšs
(
š
.
aw
.
b™s
.
addr
)

42 
v®
 
w_fuÎ
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

43 
v®
 
w_id
 = 
	`Reg
(
	`UIÁ
())

44 
v®
 
w_u£r
 = 
	`Reg
(
	`UIÁ
(
width
 = 1 
max
 
š
.
·¿ms
.
u£rB™s
))

45 
v®
 
r_£l1
 = 
	`Reg
(
r_£l0
)

46 
v®
 
w_£l1
 = 
	`Reg
(
w_£l0
)

48 
	`wh’
 (
š
. 
b
.
	`fœe
()è{ 
w_fuÎ
 :ğ
	`BoŞ
(
çl£
) }

49 
	`wh’
 (
š
.
aw
.
	`fœe
()è{ 
w_fuÎ
 :ğ
	`BoŞ
(
Œue
) }

51 
	`wh’
 (
š
.
aw
.
	`fœe
()) {

52 
w_id
 :ğ
š
.
aw
.
b™s
.
id


53 
w_£l1
 :ğ
w_£l0


54 
š
.
aw
.
b™s
.
u£r
.
fÜ—ch
 { 
w_u£r
 :ğ
_
 }

57 
v®
 
wd©a
 = 
Vec
.
	`buÏ‹
(
b—tBy‹s
è{ 
i
 => 
š
.
w
.
b™s
.
	`d©a
(8*(i+1)-1, 8*i) }

58 
	`wh’
 (
š
.
aw
.
	`fœe
(è&& 
w_£l0
) {

59 
mem
.
	`wr™e
(
w_addr
, 
wd©a
, 
š
.
w
.
b™s
.
¡rb
.
toBoŞs
)

60 
cÜru±
.
fÜ—ch
 { 
_
.
	`wr™e
(
w_addr
, 
š
.
w
.
b™s
.cÜru±.
g‘
.
asUIÁ
) }

63 
š
. 
b
.
v®id
 :ğ
w_fuÎ


64 
š
.
aw
.
»ady
 :ğš. 
w
.
v®id
 && (š.
b
.»ady || !
w_fuÎ
)

65 
š
. 
w
.
»ady
 :ğš.
aw
.
v®id
 && (š.
b
.»ady || !
w_fuÎ
)

67 
š
.
b
.
b™s
.
id
 :ğ
w_id


68 
š
.
b
.
b™s
.
»¥
 :ğ
	`Mux
(
w_£l1
, 
AXI4P¬am‘”s
.
RESP_OKAY
, AXI4P¬am‘”s.
RESP_DECERR
)

69 
š
.
b
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
w_u£r
 }

71 
v®
 
r_fuÎ
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

72 
v®
 
r_id
 = 
	`Reg
(
	`UIÁ
())

73 
v®
 
r_u£r
 = 
	`Reg
(
	`UIÁ
(
width
 = 1 
max
 
š
.
·¿ms
.
u£rB™s
))

75 
	`wh’
 (
š
. 
r
.
	`fœe
()è{ 
r_fuÎ
 :ğ
	`BoŞ
(
çl£
) }

76 
	`wh’
 (
š
.
¬
.
	`fœe
()è{ 
r_fuÎ
 :ğ
	`BoŞ
(
Œue
) }

78 
	`wh’
 (
š
.
¬
.
	`fœe
()) {

79 
r_id
 :ğ
š
.
¬
.
b™s
.
id


80 
r_£l1
 :ğ
r_£l0


81 
š
.
¬
.
b™s
.
u£r
.
fÜ—ch
 { 
r_u£r
 :ğ
_
 }

84 
v®
 
»n
 = 
š
.
¬
.
	`fœe
()

85 
v®
 
rd©a
 = 
mem
.
	`»adAndHŞd
(
r_addr
, 
»n
)

86 
v®
 
rcÜru±
 = 
cÜru±
.
	`m­
(
_
.
	`»adAndHŞd
(
r_addr
, 
»n
)(0)).
	`g‘OrEl£
(
	`BoŞ
(
çl£
))

88 
š
. 
r
.
v®id
 :ğ
r_fuÎ


89 
š
.
¬
.
»ady
 :ğš.
r
.»ady || !
r_fuÎ


91 
š
.
r
.
b™s
.
id
 :ğ
r_id


92 
š
.
r
.
b™s
.
»¥
 :ğ
	`Mux
(
r_£l1
, Mux(
rcÜru±
, 
AXI4P¬am‘”s
.
RESP_SLVERR
, AXI4P¬am‘”s.
RESP_OKAY
), AXI4P¬am‘”s.
RESP_DECERR
)

93 
š
.
r
.
b™s
.
d©a
 :ğ
	`C©
(
rd©a
.
»v”£
)

94 
š
.
r
.
b™s
.
u£r
.
fÜ—ch
 { 
_
 :ğ
r_u£r
 }

95 
š
.
r
.
b™s
.
Ï¡
 :ğ
	`BoŞ
(
Œue
)

97 
	}
}

99 
objeù
 
AXI4RAM


101 
def
 
­¶y
(

102 
add»ss
: 
Add»ssS‘
,

103 
execubË
: 
BoŞ—n
 = 
Œue
,

104 
b—tBy‹s
: 
IÁ
 = 4,

105 
devName
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

106 
”rÜs
: 
Seq
[
Add»ssS‘
] = 
N
)

107 (
im¶ic™
 
p
: 
P¬am‘”s
) =

109 
v®
 
axi4¿m
 = 
LazyModuË
(
Ãw
 
AXI4RAM
(
add»ss
, 
execubË
, 
b—tBy‹s
, 
devName
, 
”rÜs
))

110 
	gaxi4¿m
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Test.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


12 
şass
 
	$RRTe¡0
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$AXI4Regi¡”Rou‹r
(
add»ss
, 0, 32, 0, 4)(

13 
Ãw
 
	`AXI4RegBundË
((), 
_
è
w™h
 
RRTe¡0BundË
)(

14 
Ãw
 
	`AXI4RegModuË
((), 
_
, _è
w™h
 
RRTe¡0ModuË
)

16 
şass
 
	$RRTe¡1
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$AXI4Regi¡”Rou‹r
(
add»ss
, 0, 32, 6, 4, 
çl£
)(

17 
Ãw
 
	`AXI4RegBundË
((), 
_
è
w™h
 
RRTe¡1BundË
)(

18 
Ãw
 
	`AXI4RegModuË
((), 
_
, _è
w™h
 
RRTe¡1ModuË
)

20 şas 
	cAXI4L™eFuzzRAM
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


22 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

23 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AXI4LiteFuzzRAM"))

24 
v®
 
xb¬
 = 
	$LazyModuË
(
Ãw
 
TLXb¬
)

25 
v®
 
gpio
 = 
	`LazyModuË
(
Ãw
 
	$RRTe¡1
(0x400))

26 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`AXI4RAM
(
	$Add»ssS‘
(0x0, 0x3ff)))

28 
xb¬
.
node
 :ğ
	$TLD–ay”
(0.1è:ğ
	$TLBufãr
(
BufãrP¬ams
.
æow
è:ğ
	$TLD–ay”
(0.2è:ğ
mod–
.
node
 :ğ
fuzz
.node

29 
¿m
.
node
 :ğ
	$AXI4U£rYªk”
(è:ğ
	$AXI4IdIndex”
(0è:ğ
	$TLToAXI4
(
Œue
 ) :ğ
	$TLF¿gm’‹r
(4, 16, 
hŞdFœ¡D’y
=
Œue
è:ğ
xb¬
.
node


30 
gpio
.
node
 :ğ
	$AXI4U£rYªk”
(è:ğ
	$AXI4IdIndex”
(0è:ğ
	$TLToAXI4
(
çl£
è:ğ
	$TLF¿gm’‹r
(4, 16, 
hŞdFœ¡D’y
=
Œue
è:ğ
xb¬
.
node


32 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

33 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

35 
	}
}

37 
şass
 
	$AXI4L™eFuzzRAMTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

38 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AXI4L™eFuzzRAM
(
txns
)).
moduË
)

39 
io
.
fšished
 :ğ
dut
.io.finished

40 
	}
}

42 şas 
	cAXI4FuÎFuzzRAM
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


44 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

45 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AXI4FullFuzzRAM"))

46 
v®
 
xb¬
 = 
	$LazyModuË
(
Ãw
 
TLXb¬
)

47 
v®
 
gpio
 = 
	`LazyModuË
(
Ãw
 
	$RRTe¡0
(0x400))

48 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`AXI4RAM
(
	$Add»ssS‘
(0x0, 0x3ff)))

50 
xb¬
.
node
 :ğ
	$TLD–ay”
(0.1è:ğ
	$TLBufãr
(
BufãrP¬ams
.
æow
è:ğ
	$TLD–ay”
(0.2è:ğ
mod–
.
node
 :ğ
fuzz
.node

51 
¿m
.
node
 :ğ
	$AXI4F¿gm’‹r
(è:ğ
	$AXI4Deš‹¾—v”
(16è:ğ
	$TLToAXI4
(
çl£
è:ğ
xb¬
.
node


52 
gpio
.
node
 :ğ
	$AXI4F¿gm’‹r
(è:ğ
	$AXI4Deš‹¾—v”
(16è:ğ
	$TLToAXI4
(
Œue
 ) :ğ
xb¬
.
node


54 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

55 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

57 
	}
}

59 
şass
 
	$AXI4FuÎFuzzRAMTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

60 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AXI4FuÎFuzzRAM
(
txns
)).
moduË
)

61 
io
.
fšished
 :ğ
dut
.io.finished

62 
	}
}

64 
Œa™
 
HasFuzzT¬g‘
 {

65 
v®
 
fuzzAddr
 = 
Add»ssS‘
(0x0, 0xfff)

66 
v®
 
	g·‰”n
 = 
Seq
(
Add»ssS‘
(0x8, ~0x808),

67 
Add»ssS‘
(0x900, ~0x900))

70 şas 
	cAXI4FuzzMa¡”
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 
w™h
 
HasFuzzT¬g‘


72 
v®
 
node
 = 
	$AXI4Id’t™yNode
()

73 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
, 
ov”rideAdd»ss
 = 
	$Some
(
fuzzAddr
)))

74 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AXI4FuzzMaster"))

76 (
node


77 :ğ
	$AXI4U£rYªk”
()

78 :ğ
	$AXI4Deš‹¾—v”
(64)

79 :ğ
	$TLToAXI4
()

80 :ğ
	$TLD–ay”
(0.1)

81 :ğ
	$TLBufãr
(
BufãrP¬ams
.
æow
)

82 :ğ
	$TLD–ay”
(0.1)

83 :ğ
	$TLE¼ÜEv®u©Ü
(
·‰”n
, 
‹¡On
=
Œue
, 
‹¡Off
=true)

84 :ğ
mod–
.
node


85 :ğ
fuzz
.
node
)

87 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

88 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

89 
v®
 
fšished
 = 
	`BoŞ
(
OUTPUT
)

92 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

94 
	}
}

96 şas 
	cAXI4FuzzSÏve
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
Sim¶eLazyModuË
 
w™h
 
HasFuzzT¬g‘


98 
v®
 
node
 = 
	$AXI4Id’t™yNode
()

99 
v®
 
xb¬
 = 
	$LazyModuË
(
Ãw
 
TLXb¬
)

100 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	$TLRAM
(
fuzzAddr
))

101 
v®
 
”rÜ
ğ
	`LazyModuË
(
Ãw
 
	`TLE¼Ü
(
	`DevNuÎP¬ams
(
	`Seq
(
	`Add»ssS‘
(0x1800, 0xff)), 
maxAtomic
 = 8, 
maxT¿nsãr
 = 256)))

103 
¿m
.
node
 :ğ
	$TLE¼ÜEv®u©Ü
(
·‰”n
è:ğ
	$TLF¿gm’‹r
(4, 16è:ğ
xb¬
.
node


104 
”rÜ
.
node
 :ğ
xb¬
.node

106 (
xb¬
.
node


107 :ğ
	$TLFIFOFix”
()

108 :ğ
	$TLD–ay”
(0.1)

109 :ğ
	$TLBufãr
(
BufãrP¬ams
.
æow
)

110 :ğ
	$TLD–ay”
(0.1)

111 :ğ
	$AXI4ToTL
()

112 :ğ
	`AXI4U£rYªk”
(
	$Some
(4))

113 :ğ
	$AXI4F¿gm’‹r
()

114 :ğ
	$AXI4IdIndex”
(2)

115 :ğ
node
)

118 şas 
	cAXI4FuzzBridge
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


120 
v®
 
ma¡”
 = 
	`LazyModuË
(
Ãw
 
	$AXI4FuzzMa¡”
(
txns
))

121 
v®
 
¦ave
 = 
	$LazyModuË
(
Ãw
 
AXI4FuzzSÏve
)

123 
¦ave
.
node
 :ğ
ma¡”
.node

125 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

126 
io
.
fšished
 :ğ
ma¡”
.
moduË
.io.finished

128 
	}
}

130 
şass
 
	$AXI4BridgeTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

131 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AXI4FuzzBridge
(
txns
)).
moduË
)

132 
io
.
fšished
 :ğ
dut
.io.finished

133 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/ToTL.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
şass
 
	$AXI4ToTLNode
(
wcÜru±
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$MixedAd­‹rNode
(
AXI4Imp
, 
TLImp
)(

12 
dFn
 = { 
	`AXI4Ma¡”PÜtP¬am‘”s
(
ma¡”s
, 
u£rB™s
) =>

13 
ma¡”s
.
fÜ—ch
 { 
m
 => 
	`»quœe
 (m.
maxFlight
.
isDefšed
, "AXI4 must include‡ransaction maximum…er IDo converto TL") }

14 
v®
 
maxFlight
 = 
ma¡”s
.
	`m­
(
_
.maxFlight.
g‘
).
max


15 
	`TLCl›ÁPÜtP¬am‘”s
(

16 
ş›Ás
 = 
ma¡”s
.
	`f‹r
(
_
.
maxFlight
 !ğ
	`Some
(0)).
æ©M­
 { 
m
 =>

17 
id
 <- 
m
.id.
¡¬t
 
uÁ
 m.id.
’d
)

18 
y›ld
 
	`TLCl›ÁP¬am‘”s
(

19 
Çme
 = 
s
"${m.name} ID#${id}",

20 
sourûId
 = 
	`IdRªge
(
id
 * 
maxFlight
*2, (id+1) * maxFlight*2),

21 
nodeP©h
 = 
m
.nodePath,

22 
»que¡Fifo
 = 
Œue
)

24 
	}
},

25 
	guFn
 = { 
mp
 => 
AXI4SÏvePÜtP¬am‘”s
(

26 
¦aves
 = 
mp
.
mªag”s
.
m­
 { 
m
 =>

27 
v®
 
maxXãr
 = 
T¿nsãrSizes
(1, 
mp
.
b—tBy‹s
 * (1 << 
AXI4P¬am‘”s
.
ËnB™s
))

28 
AXI4SÏveP¬am‘”s
(

29 
add»ss
 = 
m
.address,

30 
»sourûs
 = 
m
.resources,

31 
»giÚTy³
 = 
m
.regionType,

32 
execubË
 = 
m
.executable,

33 
nodeP©h
 = 
m
.nodePath,

34 
suµÜtsWr™e
 = 
m
.
suµÜtsPutP¬tŸl
.
š‹r£ù
(
maxXãr
),

35 
suµÜtsR—d
 = 
m
.
suµÜtsG‘
.
š‹r£ù
(
maxXãr
),

36 
š‹¾—vedId
 = 
Some
(0))},

37 
b—tBy‹s
 = 
mp
.beatBytes,

38 
wcÜru±
 = wcorrupt,

39 
mšL©’cy
 = 
mp
.minLatency)

42 
şass
 
	$AXI4ToTL
(
wcÜru±
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


44 
v®
 
node
 = 
	`AXI4ToTLNode
(
wcÜru±
)

46 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

47 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

48 
v®
 
numIds
 = 
edgeIn
.
ma¡”
.
’dId


49 
v®
 
b—tBy‹s
 = 
edgeOut
.
mªag”
.beatBytes

50 
v®
 
b—tCouÁB™s
 = 
AXI4P¬am‘”s
.
ËnB™s
 + (1 << AXI4P¬am‘”s.
sizeB™s
) - 1

51 
v®
 
maxFlight
 = 
edgeIn
.
ma¡”
.
ma¡”s
.
	`m­
(
_
.maxFlight.
g‘
).
max


52 
v®
 
logFlight
 = 
	`log2Ce
(
maxFlight
)

53 
v®
 
txnCouÁB™s
 = 
	`log2Ce
(
maxFlight
+1)

54 
v®
 
addedB™s
 = 
logFlight
 + 1

56 
	`»quœe
 (
edgeIn
.
ma¡”
.
u£rB™s
 == 0, "AXI4 user bits cannot beransported by TL")

57 
	`»quœe
 (
edgeIn
.
ma¡”
.
	`ma¡”s
(0).
®igÃd
)

58 
edgeOut
.
mªag”
.
	`»quœeFifo
()

61 
v®
 
”rÜDevs
 = 
edgeOut
.
mªag”
.
mªag”s
.
	`f‹r
(
_
.
nodeP©h
.
Ï¡
.
ÏzyModuË
.
şassName
 == "TLError")

62 
	`»quœe
 (!
”rÜDevs
.
isEm±y
, "There is‚o TLError„eachable from AXI4ToTL. One must be instantiated.")

63 
v®
 
”rÜ
 = 
”rÜDevs
.
h—d
.
add»ss
.h—d.
ba£


64 
	`»quœe
 (
”rÜDevs
.
h—d
.
suµÜtsPutP¬tŸl
.
	`cÚšs
(
edgeOut
.
mªag”
.
maxT¿nsãr
),

65 
s
"Error device supports ${errorDevs.head.supportsPutPartial} PutPartial but must support ${edgeOut.manager.maxTransfer}")

66 
	`»quœe
 (
”rÜDevs
.
h—d
.
suµÜtsG‘
.
	`cÚšs
(
edgeOut
.
mªag”
.
maxT¿nsãr
),

67 
s
"Error device supports ${errorDevs.head.supportsGet} Get but must support ${edgeOut.manager.maxTransfer}")

69 
v®
 
r_out
 = 
	`Wœe
(
out
.
a
)

70 
v®
 
r_size1
 = 
š
.
¬
.
b™s
.
	`by‹s1
()

71 
v®
 
r_size
 = 
	`OH1ToUIÁ
(
r_size1
)

72 
v®
 
r_ok
 = 
edgeOut
.
mªag”
.
	`suµÜtsG‘Saã
(
š
.
¬
.
b™s
.
addr
, 
r_size
)

73 
v®
 
r_addr
 = 
	`Mux
(
r_ok
, 
š
.
¬
.
b™s
.
addr
, 
	`UIÁ
(
”rÜ
è| in.¬.b™s.
	`addr
(
	`log2Up
(
b—tBy‹s
)-1, 0))

74 
v®
 
r_couÁ
 = 
	`RegIn™
(
Vec
.
	`fl
(
numIds
è{ 
	`UIÁ
(0, 
width
 = 
txnCouÁB™s
) })

75 
v®
 
r_id
 = 
	`C©
(
š
.
¬
.
b™s
.
id
, 
	`r_couÁ
(š.¬.b™s.id)(
logFlight
-1,0), 
	`UIÁ
(0, 
width
=1))

77 
	`as£¹
 (!
š
.
¬
.
v®id
 || 
r_size1
 ==ğ
	`UIÁToOH1
(
r_size
, 
b—tCouÁB™s
))

78 
š
.
¬
.
»ady
 :ğ
r_out
.ready

79 
r_out
.
v®id
 :ğ
š
.
¬
.valid

80 
r_out
.
b™s
 :ğ
edgeOut
.
	`G‘
(
r_id
, 
r_addr
, 
r_size
).
_2


82 
v®
 
r_£l
 = 
	`UIÁToOH
(
š
.
¬
.
b™s
.
id
, 
numIds
)

83 (
r_£l
.
toBoŞs
 
z
 
r_couÁ
è
fÜ—ch
 { (
s
, 
r
) =>

84 
	`wh’
 (
š
.
¬
.
	`fœe
(è&& 
s
è{ 
r
 :ğ¸+ 
	`UIÁ
(1) }

87 
v®
 
w_out
 = 
	`Wœe
(
out
.
a
)

88 
v®
 
w_size1
 = 
š
.
aw
.
b™s
.
	`by‹s1
()

89 
v®
 
w_size
 = 
	`OH1ToUIÁ
(
w_size1
)

90 
v®
 
w_ok
 = 
edgeOut
.
mªag”
.
	`suµÜtsPutP¬tŸlSaã
(
š
.
aw
.
b™s
.
addr
, 
w_size
)

91 
v®
 
w_addr
 = 
	`Mux
(
w_ok
, 
š
.
aw
.
b™s
.
addr
, 
	`UIÁ
(
”rÜ
è| in.aw.b™s.
	`addr
(
	`log2Up
(
b—tBy‹s
)-1, 0))

92 
v®
 
w_couÁ
 = 
	`RegIn™
(
Vec
.
	`fl
(
numIds
è{ 
	`UIÁ
(0, 
width
 = 
txnCouÁB™s
) })

93 
v®
 
w_id
 = 
	`C©
(
š
.
aw
.
b™s
.
id
, 
	`w_couÁ
(š.aw.b™s.id)(
logFlight
-1,0), 
	`UIÁ
(1, 
width
=1))

95 
	`as£¹
 (!
š
.
aw
.
v®id
 || 
w_size1
 ==ğ
	`UIÁToOH1
(
w_size
, 
b—tCouÁB™s
))

96 
	`as£¹
 (!
š
.
aw
.
v®id
 || in.aw.
b™s
.
Ën
 ==ğ
	`UIÁ
(0è|| in.aw.b™s.
size
 ==ğUIÁ(
	`log2Ce
(
b—tBy‹s
)))

97 
š
.
aw
.
»ady
 :ğ
w_out
.»ady && in.
w
.
v®id
 && in.w.
b™s
.
Ï¡


98 
š
.
w
.
»ady
 :ğ
w_out
.»ady && in.
aw
.
v®id


99 
w_out
.
v®id
 :ğ
š
.
aw
.v®id && in.
w
.valid

100 
w_out
.
b™s
 :ğ
edgeOut
.
	`Put
(
w_id
, 
w_addr
, 
w_size
, 
š
.
w
.b™s.
d©a
, in.w.b™s.
¡rb
).
_2


101 
š
.
w
.
b™s
.
cÜru±
.
fÜ—ch
 { 
w_out
.b™s.cÜru± :ğ
_
 }

103 
v®
 
w_£l
 = 
	`UIÁToOH
(
š
.
aw
.
b™s
.
id
, 
numIds
)

104 (
w_£l
.
toBoŞs
 
z
 
w_couÁ
è
fÜ—ch
 { (
s
, 
r
) =>

105 
	`wh’
 (
š
.
aw
.
	`fœe
(è&& 
s
è{ 
r
 :ğ¸+ 
	`UIÁ
(1) }

108 
	`TLArb™”
(
TLArb™”
.
roundRobš
)(
out
.
a
, (
	`UIÁ
(0), 
r_out
), (
š
.
aw
.
b™s
.
Ën
, 
w_out
))

110 
v®
 
ok_b
 = 
	`Wœe
(
š
.
b
)

111 
v®
 
ok_r
 = 
	`Wœe
(
š
.
r
)

113 
v®
 
d_»¥
 = 
	`Mux
(
out
.
d
.
b™s
.
d’›d
 || out.d.b™s.
cÜru±
, 
AXI4P¬am‘”s
.
RESP_SLVERR
, AXI4P¬am‘”s.
RESP_OKAY
)

114 
v®
 
d_hasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
b™s
)

115 
v®
 
d_Ï¡
 = 
edgeOut
.
	`Ï¡
(
out
.
d
)

117 
out
.
d
.
»ady
 :ğ
	`Mux
(
d_hasD©a
, 
ok_r
.»ady, 
ok_b
.ready)

118 
ok_r
.
v®id
 :ğ
out
.
d
.v®id && 
d_hasD©a


119 
ok_b
.
v®id
 :ğ
out
.
d
.v®id && !
d_hasD©a


121 
ok_r
.
b™s
.
id
 :ğ
out
.
d
.b™s.
sourû
 >> 
addedB™s


122 
ok_r
.
b™s
.
d©a
 :ğ
out
.
d
.bits.data

123 
ok_r
.
b™s
.
»¥
 :ğ
d_»¥


124 
ok_r
.
b™s
.
Ï¡
 :ğ
d_Ï¡


127 
š
.
r
 <> 
Queue
.
	`œ»voÿbË
(
ok_r
, 1, 
æow
=
Œue
)

129 
ok_b
.
b™s
.
id
 :ğ
out
.
d
.b™s.
sourû
 >> 
addedB™s


130 
ok_b
.
b™s
.
»¥
 :ğ
d_»¥


133 
v®
 
q_b
 = 
Queue
.
	`œ»voÿbË
(
ok_b
, 1, 
æow
=
Œue
)

137 
v®
 
b_couÁ
 = 
	`RegIn™
(
Vec
.
	`fl
(
numIds
è{ 
	`UIÁ
(0, 
width
 = 
txnCouÁB™s
) })

138 
v®
 
b_®low
 = 
	`b_couÁ
(
š
.
b
.
b™s
.
id
è=/ğ
	`w_couÁ
(in.b.bits.id)

139 
v®
 
b_£l
 = 
	`UIÁToOH
(
š
.
b
.
b™s
.
id
, 
numIds
)

141 (
b_£l
.
toBoŞs
 
z
 
b_couÁ
è
fÜ—ch
 { (
s
, 
r
) =>

142 
	`wh’
 (
š
.
b
.
	`fœe
(è&& 
s
è{ 
r
 :ğ¸+ 
	`UIÁ
(1) }

145 
š
.
b
.
b™s
 :ğ
q_b
.bits

146 
š
.
b
.
v®id
 :ğ
q_b
.v®id && 
b_®low


147 
q_b
.
»ady
 :ğ
š
.
b
.»ady && 
b_®low


150 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

151 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

152 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

155 
	}
}

157 şas 
	cAXI4BundËRE¼Ü
(
·¿ms
: 
AXI4BundËP¬am‘”s
è
ex‹nds
 
	$AXI4BundËBa£
(
·¿ms
)

159 
v®
 
id
 = 
	$UIÁ
(
width
 = 
·¿ms
.
idB™s
)

160 
v®
 
Ï¡
 = 
	`BoŞ
()

163 
objeù
 
AXI4ToTL


165 
def
 
	`­¶y
(
wcÜru±
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
) =

167 
v®
 
axi42
 = 
	`LazyModuË
(
Ãw
 
	`AXI4ToTL
(
wcÜru±
))

168 
axi42
.
node


170 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/UserYanker.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
UIÁToOH1


10 
şass
 
	$AXI4U£rYªk”
(
ÿpMaxFlight
: 
O±iÚ
[
IÁ
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


12 
v®
 
node
 = 
	`AXI4Ad­‹rNode
(

13 
ma¡”Fn
 = { 
mp
 => mp.
	`cİy
(

14 
u£rB™s
 = 0,

15 
ma¡”s
 = 
mp
.ma¡”s.
m­
 { 
m
 => m.
	`cİy
(

16 
maxFlight
 = (
m
.maxFlight, 
ÿpMaxFlight
è
m©ch
 {

17 (
	`Some
(
x
), Some(
y
)è=> Some(x 
mš
 y)

18 (
	`Some
(
x
), 
NÚe
) => Some(x)

19 (
NÚe
, 
	`Some
(
y
)) => Some(y)

20 (
NÚe
, None) => None })})},

21 
¦aveFn
 = { 
¥
 => sp })

23 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

24 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

25 
v®
 
b™s
 = 
edgeIn
.
bundË
.
u£rB™s


26 
v®
 
Ãed_by·ss
 = 
edgeOut
.
¦ave
.
mšL©’cy
 < 1

27 
	`»quœe
 (
b™s
 > 0)

29 
edgeOut
.
ma¡”
.
ma¡”s
.
fÜ—ch
 { 
m
 =>

30 
	`»quœe
 (
m
.
maxFlight
.
isDefšed
, "UserYanker‚eeds‡ flight cap onƒach ID")

33 
def
 
	`queue
(
id
: 
IÁ
) = {

34 
v®
 
d•th
 = 
edgeOut
.
ma¡”
.
ma¡”s
.
	`fšd
(
_
.
id
.
	`cÚšs
(id)).
	`æ©M­
(_.
maxFlight
).
	`g‘OrEl£
(0)

35 ià(
d•th
 == 0) {

36 
	`Wœe
(
Ãw
 
	`QueueIO
(
	`UIÁ
(
width
 = 
b™s
), 1))

38 
	`ModuË
(
Ãw
 
	`Queue
(
	`UIÁ
(
width
 = 
b™s
), 
d•th
, 
æow
=
Ãed_by·ss
)).
io


42 
v®
 
rqueues
 = 
Seq
.
	`buÏ‹
(
edgeIn
.
ma¡”
.
’dId
è{ 
i
 => 
	`queue
(i) }

43 
v®
 
wqueues
 = 
Seq
.
	`buÏ‹
(
edgeIn
.
ma¡”
.
’dId
è{ 
i
 => 
	`queue
(i) }

45 
v®
 
¬id
 = 
š
.
¬
.
b™s
.
id


46 
v®
 
¬_»ady
 = 
	`Vec
(
rqueues
.
	`m­
(
_
.
’q
.
»ady
))(
¬id
)

47 
š
 .
¬
.
»ady
 :ğ
out
.¬.»ady && 
¬_»ady


48 
out
.
¬
.
v®id
 :ğ
š
 .¬.v®id && 
¬_»ady


49 
out
.
¬
.
b™s
 :ğ
š
 .ar.bits

51 
v®
 
rid
 = 
out
.
r
.
b™s
.
id


52 
v®
 
r_v®id
 = 
	`Vec
(
rqueues
.
	`m­
(
_
.
deq
.
v®id
))(
rid
)

53 
v®
 
r_b™s
 = 
	`Vec
(
rqueues
.
	`m­
(
_
.
deq
.
b™s
))(
rid
)

54 
	`as£¹
 (!
out
.
r
.
v®id
 || 
r_v®id
)

55 
š
.
r
 <> 
out
.r

56 
š
.
r
.
b™s
.
u£r
.
g‘
 :ğ
r_b™s


58 
v®
 
¬£l
 = 
	`UIÁToOH
(
¬id
, 
edgeIn
.
ma¡”
.
’dId
).
toBoŞs


59 
v®
 
r£l
 = 
	`UIÁToOH
(
rid
, 
edgeIn
.
ma¡”
.
’dId
).
toBoŞs


60 (
rqueues
 
	`z
 (
¬£l
 
z
 
r£l
)è
fÜ—ch
 { (
q
, (
¬
, 
r
)) =>

61 
q
.
deq
.
»ady
 :ğ
out
.
r
 .
v®id
 && 
š
 .¸.»ady &&„ && out.r.
b™s
.
Ï¡


62 
q
.
’q
.
v®id
 :ğ
š
 .
¬
.v®id && 
out
.¬.
»ady
 &&‡r

63 
q
.
’q
.
b™s
 :ğ
š
.
¬
.b™s.
u£r
.
g‘


66 
v®
 
awid
 = 
š
.
aw
.
b™s
.
id


67 
v®
 
aw_»ady
 = 
	`Vec
(
wqueues
.
	`m­
(
_
.
’q
.
»ady
))(
awid
)

68 
š
 .
aw
.
»ady
 :ğ
out
.aw.»ady && 
aw_»ady


69 
out
.
aw
.
v®id
 :ğ
š
 .aw.v®id && 
aw_»ady


70 
out
.
aw
.
b™s
 :ğ
š
 .aw.bits

72 
v®
 
bid
 = 
out
.
b
.
b™s
.
id


73 
v®
 
b_v®id
 = 
	`Vec
(
wqueues
.
	`m­
(
_
.
deq
.
v®id
))(
bid
)

74 
v®
 
b_b™s
 = 
	`Vec
(
wqueues
.
	`m­
(
_
.
deq
.
b™s
))(
bid
)

75 
	`as£¹
 (!
out
.
b
.
v®id
 || 
b_v®id
)

76 
š
.
b
 <> 
out
.b

77 
š
.
b
.
b™s
.
u£r
.
g‘
 :ğ
b_b™s


79 
v®
 
aw£l
 = 
	`UIÁToOH
(
awid
, 
edgeIn
.
ma¡”
.
’dId
).
toBoŞs


80 
v®
 
b£l
 = 
	`UIÁToOH
(
bid
, 
edgeIn
.
ma¡”
.
’dId
).
toBoŞs


81 (
wqueues
 
	`z
 (
aw£l
 
z
 
b£l
)è
fÜ—ch
 { (
q
, (
aw
, 
b
)) =>

82 
q
.
deq
.
»ady
 :ğ
out
.
b
 .
v®id
 && 
š
 .b .ready && b

83 
q
.
’q
.
v®id
 :ğ
š
 .
aw
.v®id && 
out
.aw.
»ady
 &&‡w

84 
q
.
’q
.
b™s
 :ğ
š
.
aw
.b™s.
u£r
.
g‘


87 
out
.
w
 <> 
š
.w

90 
	}
}

92 
objeù
 
AXI4U£rYªk”


94 
def
 
­¶y
(
ÿpMaxFlight
: 
O±iÚ
[
IÁ
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
AXI4Node
 =

96 
v®
 
axi4yªk
 = 
LazyModuË
(
Ãw
 
AXI4U£rYªk”
(
ÿpMaxFlight
))

97 
axi4yªk
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Xbar.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gamba
.
axi4


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
I¼evoÿbËIO


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


12 
şass
 
	$AXI4Xb¬
(

13 
¬b™¿tiÚPŞicy
: 
TLArb™”
.
PŞicy
 = TLArb™”.
roundRobš
,

14 
maxFlightP”Id
: 
IÁ
 = 7,

15 
awQueueD•th
: 
IÁ
 = 2)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


17 
	`»quœe
 (
maxFlightP”Id
 >= 1)

18 
	`»quœe
 (
awQueueD•th
 >= 1)

20 
v®
 
node
 = 
	`AXI4NexusNode
(

21 
ma¡”Fn
 = { 
£q
 =>

22 
	`£q
(0).
	`cİy
(

23 
u£rB™s
 = 
£q
.
	`m­
(
_
.u£rB™s).
max
,

24 
ma¡”s
 = (
AXI4Xb¬
.
	`m­IÅutIds
(
£q
è
z
 seqè
æ©M­
 { (
¿nge
, 
pÜt
) =>

25 
pÜt
.
ma¡”s
 
m­
 { 
ma¡”
 => ma¡”.
	`cİy
(
id
 = ma¡”.id.
	`shiá
(
¿nge
.
¡¬t
)) }

29 
¦aveFn
 = { 
£q
 =>

30 
	`£q
(0).
	`cİy
(

31 
mšL©’cy
 = 
£q
.
	`m­
(
_
.mšL©’cy).
mš
,

32 
wcÜru±
 = 
£q
.
	`exi¡s
(
_
.wcorrupt),

33 
¦aves
 = 
£q
.
æ©M­
 { 
pÜt
 =>

34 
	`»quœe
 (
pÜt
.
b—tBy‹s
 =ğ
	`£q
(0).beatBytes,

35 
s
"Xbar data widths don't match: ${port.slaves.map(_.name)} has ${port.beatBytes}B vs ${seq(0).slaves.map(_.name)} has ${seq(0).beatBytes}B")

36 
pÜt
.
¦aves


41 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

42 
	`v®
 (
io_š
, 
edgesIn
èğ
node
.
š
.
unz


43 
	`v®
 (
io_out
, 
edgesOut
èğ
node
.
out
.
unz


46 
v®
 
šputIdRªges
 = 
AXI4Xb¬
.
	`m­IÅutIds
(
edgesIn
.
	`m­
(
_
.
ma¡”
))

49 
v®
 
pÜt_addrs
 = 
edgesOut
.
	`m­
(
_
.
¦ave
.
¦aves
.m­(_.
add»ss
).
æ©‹n
)

50 
v®
 
routšgMask
 = 
	`Add»ssDecod”
(
pÜt_addrs
)

51 
v®
 
rou‹_addrs
 = 
pÜt_addrs
.
	`m­
(
£q
 => 
Add»ssS‘
.
	`unify
(£q.m­(
_
.
	`wid’
(~
routšgMask
)).
di¡šù
))

52 
v®
 
ouutPÜts
 = 
rou‹_addrs
.
	`m­
(
£q
 => (
addr
: 
UIÁ
è=> seq.m­(
_
.
	`cÚšs
×ddr)).
	`»duû
(_ || _))

55 
v®
 
awIn
 = 
Seq
.
	`fl
(
io_š
 .
size
è{ 
	`ModuË
(
Ãw
 
	`Queue
(
	`UIÁ
(
width
 = 
io_out
.size), 
awQueueD•th
, 
æow
 = 
Œue
)) }

56 
v®
 
awOut
 = 
Seq
.
	`fl
(
io_out
.
size
è{ 
	`ModuË
(
Ãw
 
	`Queue
(
	`UIÁ
(
width
 = 
io_š
 .size), 
awQueueD•th
, 
æow
 = 
Œue
)) }

58 
v®
 
»que¡ARIO
 = 
io_š
.
m­
 { 
i
 => 
	`Vec
(
ouutPÜts
.m­ { 
o
 => 
	`o
(i.
¬
.
b™s
.
addr
) }) }

59 
v®
 
»que¡AWIO
 = 
io_š
.
m­
 { 
i
 => 
	`Vec
(
ouutPÜts
.m­ { 
o
 => 
	`o
(i.
aw
.
b™s
.
addr
) }) }

60 
v®
 
»que¡ROI
 = 
io_out
.
m­
 { 
o
 => 
šputIdRªges
.m­ { 
i
 => i.
	`cÚšs
(o.
r
.
b™s
.
id
) } }

61 
v®
 
»que¡BOI
 = 
io_out
.
m­
 { 
o
 => 
šputIdRªges
.m­ { 
i
 => i.
	`cÚšs
(o.
b
.
b™s
.
id
) } }

64 
i
 <- 0 
uÁ
 
io_š
.
size
è{ 
	`awIn
(i).
io
.
’q
.
b™s
 :ğ
	`»que¡AWIO
(i).
asUIÁ
 }

65 
v®
 
»que¡WIO
 = 
awIn
.
m­
 { 
q
 => ià(
io_out
.
size
 > 1èq.
io
.
deq
.
b™s
.
toBoŞs
 
	`Seq
(
	`BoŞ
(
Œue
)) }

68 
v®
 
wide_bundË
 = 
AXI4BundËP¬am‘”s
.(
io_š
.
	`m­
(
_
.
·¿ms
è++ 
io_out
.map(_.params))

71 
v®
 
š
 = 
	`Wœe
(
	`Vec
(
io_š
.
size
, 
	`AXI4BundË
(
wide_bundË
)))

72 
i
 <- 0 
uÁ
 
š
.
size
) {

73 
	`š
(
i
è<> 
	`io_š
(i)

76 
def
 
	`Œim
(
id
: 
UIÁ
, 
size
: 
IÁ
èğià(siz<ğ1è
	`UIÁ
(0è
	`id
(
	`log2Ce
(size)-1, 0)

78 
v®
 
r
 = 
	`šputIdRªges
(
i
)

79 
	`š
(
i
).
aw
.
b™s
.
id
 :ğ
	`io_š
(i).aw.b™s.id | 
	`UIÁ
(
r
.
¡¬t
)

80 
	`š
(
i
).
¬
.
b™s
.
id
 :ğ
	`io_š
(i).¬.b™s.id | 
	`UIÁ
(
r
.
¡¬t
)

81 
	`io_š
(
i
).
r
.
b™s
.
id
 :ğ
	`Œim
(
	`š
(i).r.b™s.id,„.
size
)

82 
	`io_š
(
i
).
b
.
b™s
.
id
 :ğ
	`Œim
(
	`š
(i).b.b™s.id, 
r
.
size
)

84 ià(
io_out
.
size
 > 1) {

86 
v®
 
’dId
 = 
	`edgesIn
(
i
).
ma¡”
.endId

87 
v®
 
¬FIFOM­
 = 
	`Wœe
(
š™
 = 
Vec
.
	`fl
(
’dId
è{ 
	`BoŞ
(
Œue
) })

88 
v®
 
awFIFOM­
 = 
	`Wœe
(
š™
 = 
Vec
.
	`fl
(
’dId
è{ 
	`BoŞ
(
Œue
) })

89 
v®
 
¬S–
 = 
	`UIÁToOH
(
	`io_š
(
i
).
¬
.
b™s
.
id
, 
’dId
)

90 
v®
 
awS–
 = 
	`UIÁToOH
(
	`io_š
(
i
).
aw
.
b™s
.
id
, 
’dId
)

91 
v®
 
rS–
 = 
	`UIÁToOH
(
	`io_š
(
i
).
r
 .
b™s
.
id
, 
’dId
)

92 
v®
 
bS–
 = 
	`UIÁToOH
(
	`io_š
(
i
).
b
 .
b™s
.
id
, 
’dId
)

93 
v®
 
¬Tag
 = 
	`OHToUIÁ
(
	`»que¡ARIO
(
i
).
asUIÁ
, 
io_out
.
size
)

94 
v®
 
awTag
 = 
	`OHToUIÁ
(
	`»que¡AWIO
(
i
).
asUIÁ
, 
io_out
.
size
)

96 
ma¡”
 <- 
	`edgesIn
(
i
).ma¡”.
ma¡”s
) {

97 
def
 
	`idT¿ck”
(
pÜt
: 
UIÁ
, 
»q_fœe
: 
BoŞ
, 
»¥_fœe
: Bool) = {

98 ià(
ma¡”
.
maxFlight
 =ğ
	`Some
(0)) {

99 
	`BoŞ
(
Œue
)

101 
v®
 
Ëg®Flight
 = 
ma¡”
.
maxFlight
.
	`g‘OrEl£
(
maxFlightP”Id
+1)

102 
v®
 
æight
 = 
Ëg®Flight
 
mš
 
maxFlightP”Id


103 
v®
 
ÿnOv”æow
 = 
Ëg®Flight
 > 
æight


104 
v®
 
couÁ
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
	`log2Ce
(
æight
+1)))

105 
v®
 
Ï¡
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Ce
(
io_out
.
size
)))

106 
couÁ
 :ğcouÁ + 
»q_fœe
.
asUIÁ
 - 
»¥_fœe
.asUInt

107 
	`as£¹
 (!
»¥_fœe
 || 
couÁ
 =/ğ
	`UIÁ
(0))

108 
	`as£¹
 (!
»q_fœe
 || 
couÁ
 =/ğ
	`UIÁ
(
æight
))

109 
	`wh’
 (
»q_fœe
è{ 
Ï¡
 :ğ
pÜt
 }

111 
v®
 
pÜtM©ch
 = ià(
æight
 =ğ1è{ 
	`BoŞ
(
Œue
è} { 
Ï¡
 ==ğ
pÜt
 }

112 (
couÁ
 ==ğ
	`UIÁ
(0è|| 
pÜtM©ch
è&& (
	`BoŞ
(!
ÿnOv”æow
è|| couÁ =/ğUIÁ(
æight
))

116 
id
 <- 
ma¡”
.id.
¡¬t
 
uÁ
 ma¡”.id.
’d
) {

117 
	`¬FIFOM­
(
id
è:ğ
	`idT¿ck”
(

118 
¬Tag
,

119 
	`¬S–
(
id
è&& 
	`io_š
(
i
).
¬
.
	`fœe
(),

120 
	`rS–
(
id
è&& 
	`io_š
(
i
).
r
.
	`fœe
(è&& io_š(i).r.
b™s
.
Ï¡
)

121 
	`awFIFOM­
(
id
è:ğ
	`idT¿ck”
(

122 
awTag
,

123 
	`awS–
(
id
è&& 
	`io_š
(
i
).
aw
.
	`fœe
(),

124 
	`bS–
(
id
è&& 
	`io_š
(
i
).
b
.
	`fœe
())

128 
v®
 
®lowAR
 = 
	`¬FIFOM­
(
	`io_š
(
i
).
¬
.
b™s
.
id
)

129 
	`š
(
i
).
¬
.
v®id
 :ğ
	`io_š
(i).¬.v®id && 
®lowAR


130 
	`io_š
(
i
).
¬
.
»ady
 :ğ
	`š
(i).¬.»ady && 
®lowAR


136 
v®
 
®lowAW
 = 
	`awFIFOM­
(
	`io_š
(
i
).
aw
.
b™s
.
id
)

137 
v®
 
Ïtched
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

138 
	`š
(
i
).
aw
.
v®id
 :ğ
	`io_š
(i).aw.v®id && (
Ïtched
 || 
	`awIn
(i).
io
.
’q
.
»ady
è&& 
®lowAW


139 
	`io_š
(
i
).
aw
.
»ady
 :ğ
	`š
(i).aw.»ady && (
Ïtched
 || 
	`awIn
(i).
io
.
’q
.»adyè&& 
®lowAW


140 
	`awIn
(
i
).
io
.
’q
.
v®id
 :ğ
	`io_š
(i).
aw
.v®id && !
Ïtched


141 
	`wh’
 (
	`awIn
(
i
).
io
.
’q
.
	`fœe
()è{ 
Ïtched
 :ğ
	`BoŞ
(
Œue
) }

142 
	`wh’
 (
	`š
(
i
).
aw
.
	`fœe
()è{ 
Ïtched
 :ğ
	`BoŞ
(
çl£
) }

145 
	`š
(
i
).
w
.
v®id
 :ğ
	`io_š
(i).w.v®id && 
	`awIn
(i).
io
.
deq
.valid

146 
	`io_š
(
i
).
w
.
»ady
 :ğ
	`š
(i).w.»ady && 
	`awIn
(i).
io
.
deq
.
v®id


147 
	`awIn
(
i
).
io
.
deq
.
»ady
 :ğ
	`io_š
(i).
w
.
v®id
 && io_š(i).w.
b™s
.
Ï¡
 && 
	`š
(i).w.ready

152 
v®
 
out
 = 
	`Wœe
(
	`Vec
(
io_out
.
size
, 
	`AXI4BundË
(
wide_bundË
)))

153 
i
 <- 0 
uÁ
 
out
.
size
) {

154 
	`io_out
(
i
è<> 
	`out
(i)

156 ià(
io_š
.
size
 > 1) {

158 
v®
 
Ïtched
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

159 
	`io_out
(
i
).
aw
.
v®id
 :ğ
	`out
(i).aw.v®id && (
Ïtched
 || 
	`awOut
(i).
io
.
’q
.
»ady
)

160 
	`out
(
i
).
aw
.
»ady
 :ğ
	`io_out
(i).aw.»ady && (
Ïtched
 || 
	`awOut
(i).
io
.
’q
.ready)

161 
	`awOut
(
i
).
io
.
’q
.
v®id
 :ğ
	`out
(i).
aw
.v®id && !
Ïtched


162 
	`wh’
 (
	`awOut
(
i
).
io
.
’q
.
	`fœe
()è{ 
Ïtched
 :ğ
	`BoŞ
(
Œue
) }

163 
	`wh’
 (
	`out
(
i
).
aw
.
	`fœe
()è{ 
Ïtched
 :ğ
	`BoŞ
(
çl£
) }

166 
	`io_out
(
i
).
w
.
v®id
 :ğ
	`out
(i).w.v®id && 
	`awOut
(i).
io
.
deq
.valid

167 
	`out
(
i
).
w
.
»ady
 :ğ
	`io_out
(i).w.»ady && 
	`awOut
(i).
io
.
deq
.
v®id


168 
	`awOut
(
i
).
io
.
deq
.
»ady
 :ğ
	`out
(i).
w
.
v®id
 && out(i).w.
b™s
.
Ï¡
 && 
	`io_out
(i).w.ready

173 
def
 
Œª¥o£
[
T
](
x
: 
Seq
[Seq[T]]èğSeq.
	`buÏ‹
(
	`x
(0).
size
è{ 
i
 => Seq.buÏ‹(x.sizeè{ 
j
 => x(j)(i) } }

174 
v®
 
pÜtsAROI
 = 
	`Œª¥o£
((
š
 
z
 
»que¡ARIO
è
m­
 { (
i
, 
r
è=> 
AXI4Xb¬
.
	`çnout
(i.
¬
,„) })

175 
v®
 
pÜtsAWOI
 = 
	`Œª¥o£
((
š
 
z
 
»que¡AWIO
è
m­
 { (
i
, 
r
è=> 
AXI4Xb¬
.
	`çnout
(i.
aw
,„) })

176 
v®
 
pÜtsWOI
 = 
	`Œª¥o£
((
š
 
z
 
»que¡WIO
è
m­
 { (
i
, 
r
è=> 
AXI4Xb¬
.
	`çnout
(i.
w
,„) })

177 
v®
 
pÜtsRIO
 = 
	`Œª¥o£
((
out
 
z
 
»que¡ROI
è
m­
 { (
o
, 
r
è=> 
AXI4Xb¬
.
	`çnout
(o.r,„) })

178 
v®
 
pÜtsBIO
 = 
	`Œª¥o£
((
out
 
z
 
»que¡BOI
è
m­
 { (
o
, 
r
è=> 
AXI4Xb¬
.
	`çnout
(o.
b
,„) })

181 
o
 <- 0 
uÁ
 
out
.
size
) {

182 
	`awOut
(
o
).
io
.
’q
.
b™s
 :=

183 
AXI4Arb™”
.
	`»tuºWšÃr
(
¬b™¿tiÚPŞicy
)(
	`out
(
o
).
aw
, 
	`pÜtsAWOI
(o):
_
*).
asUIÁ


184 
	`AXI4Arb™”
(
¬b™¿tiÚPŞicy
)(
	`out
(
o
).
¬
, 
	`pÜtsAROI
(o):
_
*)

186 
	`out
(
o
).
w
.
v®id
 :ğ
	`Mux1H
(
	`awOut
(o).
io
.
deq
.
b™s
, 
	`pÜtsWOI
(o).
	`m­
(
_
.valid))

187 
	`out
(
o
).
w
.
b™s
 :ğ
	`Mux1H
(
	`awOut
(o).
io
.
deq
.b™s, 
	`pÜtsWOI
(o).
	`m­
(
_
.bits))

188 
	`pÜtsWOI
(
o
).
zW™hIndex
.
m­
 { (
p
, 
i
) =>

189 ià(
š
.
size
 > 1) {

190 
p
.
»ady
 :ğ
	`out
(
o
).
w
.»ady && 
	`awOut
(o).
io
.
deq
.
	`b™s
(
i
)

192 
p
.
»ady
 :ğ
	`out
(
o
).
w
.ready

197 
i
 <- 0 
uÁ
 
š
.
size
) {

198 
	`AXI4Arb™”
(
¬b™¿tiÚPŞicy
)(
	`š
(
i
).
r
, 
	`pÜtsRIO
(i):
_
*)

199 
	`AXI4Arb™”
(
¬b™¿tiÚPŞicy
)(
	`š
(
i
).
b
, 
	`pÜtsBIO
(i):
_
*)

202 
	}
}

204 
objeù
 
AXI4Xb¬


206 
def
 
­¶y
(

207 
¬b™¿tiÚPŞicy
: 
TLArb™”
.
PŞicy
 = TLArb™”.
roundRobš
,

208 
maxFlightP”Id
: 
IÁ
 = 7,

209 
awQueueD•th
: 
IÁ
 = 2)(
im¶ic™
 
p
: 
P¬am‘”s
) =

211 
v®
 
axi4xb¬
 = 
LazyModuË
(
Ãw
 
AXI4Xb¬
(
¬b™¿tiÚPŞicy
, 
maxFlightP”Id
, 
awQueueD•th
))

212 
	gaxi4xb¬
.
	gnode


215 
def
 
m­IÅutIds
(
pÜts
: 
Seq
[
AXI4Ma¡”PÜtP¬am‘”s
]èğ
TLXb¬
.
assignRªges
ÕÜts.
m­
(
_
.
’dId
))

218 
def
 
çnout
[
T
 <: 
AXI4BundËBa£
](
šput
: 
I¼evoÿbËIO
[T], 
	g£Ëù
: 
Seq
[
BoŞ
]) = {

219 
v®
 
f‹»d
 = 
Wœe
(
Vec
(
£Ëù
.
size
, 
šput
))

220 
	gi
 <- 0 
uÁ
 
	g£Ëù
.
	gsize
) {

221 
f‹»d
(
i
).
	gb™s
 :ğ
šput
.
b™s


222 
f‹»d
(
i
).
v®id
 :ğ
šput
.v®id && 
£Ëù
(i)

224 
šput
.
»ady
 :ğ
Mux1H
(
£Ëù
, 
f‹»d
.
m­
(
_
.ready))

225 
	gf‹»d


229 
objeù
 
	gAXI4Arb™”


231 
def
 
	g­¶y
[
T
 <: 
D©a
](
pŞicy
: 
TLArb™”
.
PŞicy
)(
sšk
: 
I¼evoÿbËIO
[T], 
	gsourûs
: IrrevocableIO[T]*) {

232 ià(
sourûs
.
isEm±y
) {

233 
sšk
.
v®id
 :ğ
BoŞ
(
çl£
)

235 
»tuºWšÃr
(
pŞicy
)(
sšk
, 
	gsourûs
:
_
*)

238 
def
 
»tuºWšÃr
[
T
 <: 
D©a
](
pŞicy
: 
TLArb™”
.
PŞicy
)(
sšk
: 
I¼evoÿbËIO
[T], 
	gsourûs
: IrrevocableIO[T]*) = {

239 
»quœe
 (!
sourûs
.
isEm±y
)

242 
v®
 
idË
 = 
RegIn™
(
BoŞ
(
Œue
))

245 
v®
 
v®ids
 = 
sourûs
.
m­
(
_
.
v®id
)

246 
v®
 
ªyV®id
 = 
v®ids
.
»duû
(
_
 || _)

248 
v®
 
»adys
 = 
Vec
(
pŞicy
(
v®ids
.
size
, 
C©
(v®ids.
»v”£
), 
idË
).
toBoŞs
)

250 
v®
 
	gwšÃr
 = 
Vec
((
»adys
 
z
 
v®ids
è
m­
 { (
r
,
v
) =>„&&v })

253 
»quœe
 (
»adys
.
size
 =ğ
v®ids
.size)

255 
v®
 
´efixOR
 = 
wšÃr
.
sÿnLeá
(
BoŞ
(
çl£
))(
_
||_).
š™


256 
as£¹
((
´efixOR
 
z
 
wšÃr
è
m­
 { (
p
,
w
è=> !°|| !w } 
»duû
 {
_
 && _})

258 
as£¹
 (!
ªyV®id
 || 
wšÃr
.
»duû
(
_
||_))

261 
v®
 
	g¡©e
 = 
RegIn™
(
Vec
.
fl
(
sourûs
.
size
)(
BoŞ
(
çl£
)))

262 
v®
 
muxS‹
 = 
Mux
(
idË
, 
wšÃr
, 
¡©e
)

263 
	g¡©e
 :ğ
muxS‹


266 
wh’
 (
ªyV®id
è{ 
idË
 :ğ
BoŞ
(
çl£
) }

267 
wh’
 (
sšk
.
fœe
()è{ 
idË
 :ğ
BoŞ
(
Œue
) }

269 ià(
sourûs
.
size
 > 1) {

270 
v®
 
®lowed
 = 
Mux
(
idË
, 
»adys
, 
¡©e
)

271 (
sourûs
 
z
 
	g®lowed
è
	gfÜ—ch
 { (
	gs
, 
	gr
) =>

272 
s
.
»ady
 :ğ
sšk
.»ady && 
r


275 
sourûs
(0).
»ady
 :ğ
sšk
.ready

278 
sšk
.
v®id
 :ğ
Mux
(
idË
, 
ªyV®id
, 
Mux1H
(
¡©e
, 
v®ids
))

279 
	gsšk
.
	gb™s
 :ğ
Mux1H
(
muxS‹
, 
sourûs
.
m­
(
_
.
b™s
))

280 
	gmuxS‹


284 
şass
 
	$AXI4Xb¬FuzzTe¡
(
Çme
: 
SŒšg
, 
txns
: 
IÁ
, 
nMa¡”s
: IÁ, 
nSÏves
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


286 
v®
 
xb¬
 = 
	`AXI4Xb¬
()

287 
v®
 
¦aveSize
 = 0x1000

288 
v®
 
ma¡”BªdSize
 = 
¦aveSize
 >> 
	`log2Ce
(
nMa¡”s
)

289 
def
 
	`f‹r
(
i
: 
IÁ
èğ
TLF‹r
.
	`mS–eùIÁ”£ù
(
	`Add»ssS‘
(˜* 
ma¡”BªdSize
, ~
	`BigIÁ
(
¦aveSize
 - masterBandSize)))

291 
v®
 
¦aves
 = 
Seq
.
	`buÏ‹
(
nSÏves
è{ 
i
 => 
	`LazyModuË
(
Ãw
 
	`AXI4RAM
(
	`Add»ssS‘
(
¦aveSize
 * i, slaveSize-1))) }

292 
¦aves
.
fÜ—ch
 { 
s
 => (s.
node


293 :ğ
	`AXI4F¿gm’‹r
()

294 :ğ
	`AXI4Bufãr
(
BufãrP¬ams
.
æow
)

295 :ğ
	`AXI4Bufãr
(
BufãrP¬ams
.
æow
)

296 :ğ
	`AXI4D–ay”
(0.25)

297 :ğ
xb¬
) }

299 
v®
 
ma¡”s
 = 
Seq
.
	`fl
(
nMa¡”s
è{ 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
, 4, 
nOrd”ed
 = 
	`Some
(1))) }

300 
ma¡”s
.
zW™hIndex
.
fÜ—ch
 { (
m
, 
i
è=> (
xb¬


301 :ğ
	`AXI4D–ay”
(0.25)

302 :ğ
	`AXI4Deš‹¾—v”
(4096)

303 :ğ
	`TLToAXI4
()

304 :ğ
	`TLF‹r
(
	`f‹r
(
i
))

305 :ğ
	`TLRAMMod–
(
s
"${name} Master $i")

306 :ğ
m
.
node
) }

308 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

309 
io
.
fšished
 :ğ
ma¡”s
.
	`m­
(
_
.
moduË
.io.fšished).
	`»duû
(_ || _)

311 
	}
}

313 
şass
 
	$AXI4Xb¬Te¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

314 
v®
 
dut21
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AXI4Xb¬FuzzTe¡
("Xb¬ DUT21", 
txns
, 2, 1)).
moduË
)

315 
v®
 
dut12
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AXI4Xb¬FuzzTe¡
("Xb¬ DUT12", 
txns
, 1, 2)).
moduË
)

316 
v®
 
dut22
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`AXI4Xb¬FuzzTe¡
("Xb¬ DUT22", 
txns
, 2, 2)).
moduË
)

317 
io
.
fšished
 :ğ
	`Seq
(
dut21
, 
dut12
, 
dut22
).
	`m­
(
_
.io.fšished).
	`»duû
(_ || _)

318 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/package.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
amba


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
·ckage
 
objeù
 
	gaxi4


10 
ty³
 
	gAXI4Node
 = 
Sim¶eNodeHªdË
[
AXI4Ma¡”PÜtP¬am‘”s
, 
AXI4SÏvePÜtP¬am‘”s
, 
AXI4EdgeP¬am‘”s
, 
AXI4BundË
]

11 
ty³
 
	gAXI4Outw¬dNode
 = 
Outw¬dNodeHªdË
[
AXI4Ma¡”PÜtP¬am‘”s
, 
AXI4SÏvePÜtP¬am‘”s
, 
AXI4EdgeP¬am‘”s
, 
AXI4BundË
]

12 
ty³
 
	gAXI4Inw¬dNode
 = 
Inw¬dNodeHªdË
[
AXI4Ma¡”PÜtP¬am‘”s
, 
AXI4SÏvePÜtP¬am‘”s
, 
AXI4EdgeP¬am‘”s
, 
AXI4BundË
]

14 
im¶ic™
 cÏs 
	cAXI4ClockDomašCrossšg
(
v®
 
x
: 
HasClockDomašCrossšg
è
ex‹nds
 
AnyV®
 {

15 
def
 
	`üossIn
 (
n
: 
AXI4Inw¬dNode
è(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`AXI4Inw¬dCrossšgH–³r
(v®Name.
Çme
, 
x
,‚)

16 
def
 
	`üossOut
(
n
: 
AXI4Outw¬dNode
)(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`AXI4Outw¬dCrossšgH–³r
(v®Name.
Çme
, 
x
,‚)

17 
def
 
	`üoss
(
n
: 
AXI4Inw¬dNode
è(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`üossIn
(n)

18 
def
 
	`üoss
(
n
: 
AXI4Outw¬dNode
)(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`üossOut
(n)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/config/Config.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
cÚfig


5 
ab¡¿ù
 
şass
 
	gF›ld
[
T
] 
	$´iv©e
 (
v®
 : 
O±iÚ
[
T
])

7 
def
 
	`this
(èğthis(
NÚe
)

8 
def
 
	`this
(: 
T
èğthis(
	`Some
())

9 
	}
}

11 
ab¡¿ù
 cÏs 
	cV›w
 {

12 
fš®
 
def
 
­¶y
[
T
](
²ame
: 
F›ld
[T]): T = 
	$­¶y
(
²ame
, 
this
)

13 
fš®
 
def
 
­¶y
[
T
](
²ame
: 
F›ld
[T], 
s™e
: 
V›w
): T = {

14 
v®
 
out
 = 
	`fšd
(
²ame
, 
s™e
)

15 
	`»quœe
 (
out
.
isDefšed
, 
s
"Key ${pname} is‚ot defined in Parameters")

16 
out
.
g‘


19 
fš®
 
def
 
liá
[
T
](
²ame
: 
F›ld
[T]): 
O±iÚ
[T] = 
	$liá
(
²ame
, 
this
)

20 
fš®
 
def
 
liá
[
T
](
²ame
: 
F›ld
[T], 
s™e
: 
V›w
): 
O±iÚ
[T] = 
	`fšd
ÕÇme, s™e).
	$m­
(
_
.
asIn¡ªûOf
[
T
])

22 
´Ùeùed
[
cÚfig
] 
def
 
fšd
[
T
](
²ame
: 
F›ld
[T], 
s™e
: 
V›w
): 
O±iÚ
[T]

23 
	}
}

25 
ab¡¿ù
 cÏs 
	cP¬am‘”s
 
ex‹nds
 
V›w
 {

26 
fš®
 
def
 ++ (
x
: 
P¬am‘”s
): Parameters =

27 
Ãw
 
	$ChašP¬am‘”s
(
this
, 
x
)

29 
fš®
 
def
 
	`®‹r
(
f
: (
V›w
, V›w, V›wè=> 
P¬tŸlFunùiÚ
[
Any
,Any]): 
P¬am‘”s
 =

30 
	`P¬am‘”s
(
f
è++ 
this


32 
fš®
 
def
 
	$®‹rP¬tŸl
(
f
: 
P¬tŸlFunùiÚ
[
Any
,Any]): 
P¬am‘”s
 =

33 
	`P¬am‘”s
((
_
,_,_è=> 
f
è++ 
this


35 
fš®
 
def
 
	$®‹rM­
(
m
: 
M­
[
Any
,Any]): 
P¬am‘”s
 =

36 
Ãw
 
	`M­P¬am‘”s
(
m
è++ 
this


38 
´Ùeùed
[
cÚfig
] 
def
 
chaš
[
T
](
s™e
: 
V›w
, 

: V›w, 
²ame
: 
F›ld
[T]): 
O±iÚ
[T]

39 
´Ùeùed
[
cÚfig
] 
def
 
fšd
[
T
](
²ame
: 
F›ld
[T], 
s™e
: 
V›w
èğ
	`chaš
(s™e, 
Ãw
 
T”mš®V›w
,…name)

42 
objeù
 
P¬am‘”s
 {

43 
def
 
em±y
: 
P¬am‘”s
 = 
Ãw
 
Em±yP¬am‘”s


44 
def
 
	`­¶y
(
f
: (
V›w
, V›w, V›wè=> 
P¬tŸlFunùiÚ
[
Any
,Any]): 
P¬am‘”s
 = 
Ãw
 
	`P¬tŸlP¬am‘”s
(f)

45 
	}
}

47 şas 
	cCÚfig
(
p
: 
P¬am‘”s
è
ex‹nds
 Parameters {

48 
def
 
	`this
(
f
: (
V›w
, V›w, V›wè=> 
P¬tŸlFunùiÚ
[
Any
,Any]èğthis(
	$P¬am‘”s
(
f
))

50 
´Ùeùed
[
cÚfig
] 
def
 
chaš
[
T
](
s™e
: 
V›w
, 

: V›w, 
²ame
: 
F›ld
[T]èğ
p
.
	$chaš
(
s™e
, 

, 
²ame
)

51 
ov”ride
 
def
 
toSŒšg
 = 
this
.
g‘CÏss
.
g‘Sim¶eName


52 
def
 
toIn¡ªû
 = 
this


57 
´iv©e
 cÏs 
	cT”mš®V›w
 
ex‹nds
 
V›w
 {

58 
def
 
fšd
[
T
](
²ame
: 
F›ld
[T], 
s™e
: 
V›w
): 
O±iÚ
[T] =…name.

61 
´iv©e
 
şass
 
	$ChašV›w
(
h—d
: 
P¬am‘”s
, 

: 
V›w
è
ex‹nds
 View {

62 
def
 
fšd
[
T
](
²ame
: 
F›ld
[T], 
s™e
: 
V›w
èğ
h—d
.
	`chaš
(s™e, 

,…name)

63 
	}
}

65 
´iv©e
 
şass
 
	$ChašP¬am‘”s
(
x
: 
P¬am‘”s
, 
y
: P¬am‘”sè
ex‹nds
 Parameters {

66 
def
 
chaš
[
T
](
s™e
: 
V›w
, 

: V›w, 
²ame
: 
F›ld
[T]èğ
x
.
	`chaš
(s™e, 
Ãw
 
	`ChašV›w
(
y
,ail),…name)

67 
	}
}

69 
´iv©e
 cÏs 
	cEm±yP¬am‘”s
 
ex‹nds
 
	mP¬am‘”s
 {

70 
def
 
	mchaš
[
T
](
	ms™e
: 
V›w
, 
	m
: V›w, 
	m²ame
: 
F›ld
[T]èğ

.
fšd
(
²ame
, 
s™e
)

73 
´iv©e
 
şass
 
P¬tŸlP¬am‘”s
(
f
: (
V›w
, V›w, V›wè=> 
P¬tŸlFunùiÚ
[
Any
,Any]è
ex‹nds
 
	gP¬am‘”s
 {

74 
	g´Ùeùed
[
cÚfig
] 
def
 
	gchaš
[
T
](
	gs™e
: 
V›w
, 
	g
: V›w, 
	g²ame
: 
F›ld
[T]) = {

75 
v®
 
g
 = 
f
(
s™e
, 
this
, 

)

76 ià(
	gg
.
isDefšedAt
(
²ame
)è
Some
(
g
.
­¶y
ÕÇme).
asIn¡ªûOf
[
T
]è
	g
.
fšd
ÕÇme, 
s™e
)

80 
´iv©e
 
şass
 
	$M­P¬am‘”s
(
m­
: 
M­
[
Any
, Any]è
ex‹nds
 
P¬am‘”s
 {

81 
´Ùeùed
[
cÚfig
] 
def
 
chaš
[
T
](
s™e
: 
V›w
, 

: V›w, 
²ame
: 
F›ld
[T]) = {

82 
v®
 
g
 = 
m­
.
	`g‘
(
²ame
)

83 ià(
g
.
isDefšed
è
	`Some
(g.
g‘
.
asIn¡ªûOf
[
T
]è

.
	`fšd
(
²ame
, 
s™e
)

85 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Custom.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gcÜe
.{
	gIÅut
, 
	gOuut
}

7 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.{
	gLazyModuË
, 
	gLazyModuËImp
, 
	gNexusNode
, 
	gR’d”edEdge
,

9 
	gSim¶eNodeImp
, 
	gSškNode
, 
	gSourûNode
, 
	gV®Name
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


12 
şass
 
	$DebugCu¡omP¬ams
(

13 
addrs
: 
Li¡
[
IÁ
],

14 
width
: 
IÁ


16 
	`»quœe
 (
width
 % 8 =ğ0, 
s
"Currently only support custom debug widths which‡re multiples of 8,‚ot ${width}")

17 
	}
}

19 şas 
	cDebugCu¡omNuÎ
()

21 şas 
	cDebugCu¡omBundË
(
v®
 
p
: 
DebugCu¡omP¬ams
è
ex‹nds
 
BundË
 {

22 
v®
 
addr
 = 
	`IÅut
(
	`UIÁ
(
	`log2Up
(
p
.
addrs
.
	$fŞdLeá
(0){
_
 
max
 _}).
W
))

23 
v®
 
d©a
 = 
	`Ouut
(
	$UIÁ
(
p
.
width
.
W
))

24 
v®
 
»ady
 = 
	`Ouut
(
	$BoŞ
())

25 
v®
 
v®id
 = 
	`IÅut
(
	`BoŞ
())

26 
	}
}

28 
şass
 
DebugCu¡omImp
 
ex‹nds
 
Sim¶eNodeImp
[
DebugCu¡omP¬ams
, 
DebugCu¡omNuÎ
, DebugCu¡omP¬ams, 
DebugCu¡omBundË
] {

30 
def
 
edge
(
pd
: 
DebugCu¡omP¬ams
, 
pu
: 
DebugCu¡omNuÎ
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
) =…d

31 
def
 
bundË
(
e
: 
DebugCu¡omP¬ams
èğ
Ãw
 
DebugCu¡omBundË
(e)

32 
def
 
»nd”
(
e
: 
DebugCu¡omP¬ams
èğ
R’d”edEdge
(
cŞour
 = "#20B2AA" )

37 
şass
 
	$DebugCu¡omSšk
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SškNode
(
Ãw
 
DebugCu¡omImp
)(
pi
 = 
	`Seq
(
	$DebugCu¡omNuÎ
()))

40 
şass
 
	$DebugCu¡omSourû
(
¢oİabË
: 
DebugCu¡omP¬ams
)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SourûNode
(
Ãw
 
DebugCu¡omImp
)(
	$Seq
(
¢oİabË
))

43 
şass
 
	`DebugCu¡omNexusNode
(

44 
sourûFn
: 
Seq
[
DebugCu¡omP¬ams
] => DebugCustomParams,

45 
sškFn
 : 
Seq
[
DebugCu¡omNuÎ
] => DebugCustomNull,

46 
šputRequœesOuut
: 
BoŞ—n
 = 
Œue
,

47 
ouutRequœesIÅut
: 
BoŞ—n
 = 
Œue


48 )Ğ
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$NexusNode
(
Ãw
 
DebugCu¡omImp
è(
sourûFn
, 
sškFn
, 
šputRequœesOuut
, 
ouutRequœesIÅut
)

50 
şass
 
	$DebugCu¡omXb¬
(

51 
šputRequœesOuut
: 
BoŞ—n
 = 
Œue
,

52 
ouutRequœesIÅut
: 
BoŞ—n
 = 
Œue


53 )(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

54 
v®
 
node
 = 
	`DebugCu¡omNexusNode
(

55 
sourûFn
 = { 
£q
 =>

56 ià(
£q
.
size
 == 0) {

57 
	`DebugCu¡omP¬ams
(
N
, 0)

59 
v®
 
®l_addrs
 = 
£q
.
m­
{
_
.
addrs
}.
æ©‹n


60 
	`»quœe
(
®l_addrs
.
size
 =ğ®l_addrs.
di¡šù
.size, "Different Custom sources can't usehe same‡ddresses.")

61 
v®
 
max_width
 = 
£q
.
	`fŞdLeá
(0){(
»suÉ
, 
cu¼’t
è=>„esuÉ 
max
 cu¼’t.
width
}

62 
	`DebugCu¡omP¬ams
(
®l_addrs
.
toLi¡
, 
max_width
)

65 
sškFn
 = { 
£q
 => 
Ãw
 
	`DebugCu¡omNuÎ
()},

66 
šputRequœesOuut
,

67 
ouutRequœesIÅut


70 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

72 
	`»quœe
(
node
.
out
.
size
 == 1, "Must haveƒxactly one sink‚ode,‚ot ${node.out.size}")

74 
	`v®
 (
sšk
, 
sškP¬am
èğ
node
.
out
.
h—d


75 
	`v®
 (
sourûs
, 
sourûP¬ams
èğ
node
.
š
.
unz


76 
v®
 
decoded
 = 
sourûP¬ams
.
m­
 { 
x
 => x.
addrs
.
	`fŞdLeá
(
çl£
.
B
è{ (
»suÉ
, 
cu¼’t
è=>„esuÉ || cu¼’t.
U
 ==ğ
sšk
.
addr
}}

77 
sourûs
.
zW™hIndex
.
fÜ—ch
 { (
sourû
, 
i
) =>

78 
sourû
.
addr
 :ğ
sšk
.addr

80 
sourû
.
v®id
 :ğ
sšk
.v®id & 
	`decoded
(
i
)

83 
sšk
.
»ady
 :ğ(
decoded
 
z
 
sourûs
).
	`fŞdLeá
(
çl£
.
B
){(
»suÉ
, (
d
, 
i
)) =>„esult || (d & i.ready)}

84 
sšk
.
d©a
 :ğ(
decoded
 
z
 
sourûs
).
	`fŞdLeá
(0.U){ (
»suÉ
, (
d
, 
i
)è=>„esuÉ | 
	`Mux
(i.
»ady
, i.data, 0.U)}

87 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DMI.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


15 
objeù
 
	gDMICÚ¡s
{

17 
def
 
	gdmiD©aSize
 = 32

19 
def
 
dmiOpSize
 = 2

20 
def
 
dmi_OP_NONE
 = "b00".
U


21 
def
 
dmi_OP_READ
 = "b01".
U


22 
def
 
dmi_OP_WRITE
 = "b10".
U


24 
def
 
dmiRe¥Size
 = 2

25 
def
 
dmi_RESP_SUCCESS
 = "b00".
U


26 
def
 
dmi_RESP_FAILURE
 = "b01".
U


27 
def
 
dmi_RESP_HW_FAILURE
 = "b10".
U


30 
def
 
dmi_RESP_RESERVED
 = "b11".
U


40 şas 
	cDMIReq
(
addrB™s
 : 
IÁ
è
ex‹nds
 
BundË
 {

41 
v®
 
addr
 = 
	$UIÁ
(
addrB™s
.
W
)

42 
v®
 
d©a
 = 
	$UIÁ
(
DMICÚ¡s
.
dmiD©aSize
.
W
)

43 
v®
 
İ
 = 
	$UIÁ
(
DMICÚ¡s
.
dmiOpSize
.
W
)

45 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`DMIReq
(
addrB™s
).
asIn¡ªûOf
[
this
.
ty³
]

50 şas 
	cDMIRe¥
Ğè
ex‹nds
 
BundË
 {

51 
v®
 
d©a
 = 
	$UIÁ
(
DMICÚ¡s
.
dmiD©aSize
.
W
)

52 
v®
 
»¥
 = 
	`UIÁ
(
DMICÚ¡s
.
dmiRe¥Size
.
W
)

60 şas 
	cDMIIO
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
) {

61 
v®
 
»q
 = 
Ãw
 
	`Decou¶edIO
Òew 
	`DMIReq
(
	`p
(
DebugModuËP¬ams
).
nDMIAddrSize
))

62 
v®
 
»¥
 = 
Ãw
 
	`Decou¶edIO
Òew 
DMIRe¥
).
	`æ
()

70 şas 
	cClockedDMIIO
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
){

71 
v®
 
dmi
 = 
Ãw
 
	$DMIIO
()(
p
)

72 
v®
 
dmiClock
 = 
	$Clock
(
OUTPUT
)

73 
v®
 
dmiRe£t
 = 
	`BoŞ
(
OUTPUT
)

80 şas 
	cDMIToTL
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

82 
v®
 
node
 = 
	`TLCl›ÁNode
(
	`Seq
(
	`TLCl›ÁPÜtP¬am‘”s
(Seq(
	`TLCl›ÁP¬am‘”s
("debug")))))

84 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

85 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

86 
v®
 
dmi
 = 
Ãw
 
	`DMIIO
()(
p
).
	`æ
()

89 
	`v®
 (

, 
edge
èğ
node
.
	`out
(0)

91 
v®
 
¤c
 = 
	`Wœe
(
š™
 = 0.U)

92 
v®
 
addr
 = 
	`Wœe
(
š™
 = (
io
.
dmi
.
»q
.
b™s
.addr << 2))

93 
v®
 
size
 = (
	`log2Ce
(
DMICÚ¡s
.
dmiD©aSize
 / 8)).
U


95 
	`v®
 (
_
, 
gb™s
èğ
edge
.
	`G‘
(
¤c
, 
addr
, 
size
)

96 
	`v®
 (
_
, 
pfb™s
èğ
edge
.
	`Put
(
¤c
, 
addr
, 
size
, 
io
.
dmi
.
»q
.
b™s
.
d©a
)

104 
	`v®
 (
_
, 
nb™s
èğ
edge
.
	`Put
(
¤c
, 
toAdd»ss
 = (
DMI_RegAddrs
.
DMI_DMCONTROL
 << 2).
U
, 
size
, 
d©a
=0.U, 
mask
 = 0.U)

106 
	`wh’
 (
io
.
dmi
.
»q
.
b™s
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_WRITE
è{ 

.
a
.b™ :ğ
pfb™s


107 }.
	`–£wh’
 (
io
.
dmi
.
»q
.
b™s
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_READ
è{ 

.
a
.b™ :ğ
gb™s


108 }.
Ùh”wi£
 { 

.
a
.
b™s
 :ğ
nb™s


111 

.
a
.
v®id
 :ğ
io
.
dmi
.
»q
.valid

112 
io
.
dmi
.
»q
.
»ady
 :ğ

.
a
.ready

114 
io
.
dmi
.
»¥
.
v®id
 :ğ

.
d
.valid

115 

.
d
.
»ady
 :ğ
io
.
dmi
.
»¥
.ready

116 
io
.
dmi
.
»¥
.
b™s
.»¥ :ğ
	`Mux
(

.
d
.b™s.
cÜru±
 ||l.d.b™s.
d’›d
, 
DMICÚ¡s
.
dmi_RESP_FAILURE
, DMICÚ¡s.
dmi_RESP_SUCCESS
)

117 
io
.
dmi
.
»¥
.
b™s
.
d©a
 :ğ

.
d
.bits.data

120 

.
b
.
»ady
 :ğ
çl£
.
B


121 

.
c
.
v®id
 :ğ
çl£
.
B


122 

.
e
.
v®id
 :ğ
çl£
.
B


125 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Debug.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
In¡ruùiÚs


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.
	gsy¡embu§cûss
.
_


16 
objeù
 
	gDsbBusCÚ¡s
 {

17 
def
 
	gsbAddrWidth
 = 12

18 
def
 
sbIdWidth
 = 10

22 
objeù
 
	gDsbRegAddrs
{

25 
def
 
	gHALTED
 = 0x100

26 
def
 
GOING
 = 0x104

27 
def
 
RESUMING
 = 0x108

28 
def
 
EXCEPTION
 = 0x10C

30 
def
 
WHERETO
 = 0x300

36 
def
 
DATA
 = 0x380

41 
def
 
PROGBUF
(
cfg
:
DebugModuËP¬ams
) = {

42 
v®
 
tmp
 = 
DATA
 - (
cfg
.
nProg¿mBufãrWÜds
 * 4)

43 ià(
cfg
.
hasIm¶ic™Eb»ak
è(
tmp
 - 4) tmp

46 
def
 
IMPEBREAK
(
cfg
: 
DebugModuËP¬ams
èğ{ 
DATA
 - 4 }

50 
def
 
ABSTRACT
(
cfg
:
DebugModuËP¬ams
èğ
PROGBUF
(cfg) - 8

52 
def
 
FLAGS
 = 0x400

53 
def
 
ROMBASE
 = 0x800

61 
objeù
 
DebugModuËAcûssTy³
 
ex‹nds
 
sÿÏ
.
Enum”©iÚ
 {

62 
ty³
 
DebugModuËAcûssTy³
 = 
V®ue


63 
v®
 
Acûss8B™
, 
	gAcûss16B™
, 
	gAcûss32B™
, 
	gAcûss64B™
, 
	gAcûss128B™
 = 
V®ue


65 
impÜt
 
	gDebugModuËAcûssTy³
.
_


67 
objeù
 
DebugAb¡¿ùCommªdE¼Ü
 
ex‹nds
 
	gsÿÏ
.
	gEnum”©iÚ
 {

68 
ty³
 
	gDebugAb¡¿ùCommªdE¼Ü
 = 
V®ue


69 
v®
 
Sucûss
, 
	gE¼Busy
, 
	gE¼NÙSuµÜ‹d
, 
	gE¼Exû±iÚ
, 
	gE¼H®tResume
 = 
V®ue


71 
impÜt
 
	gDebugAb¡¿ùCommªdE¼Ü
.
_


73 
objeù
 
DebugAb¡¿ùCommªdTy³
 
ex‹nds
 
	gsÿÏ
.
	gEnum”©iÚ
 {

74 
ty³
 
	gDebugAb¡¿ùCommªdTy³
 = 
V®ue


75 
v®
 
AcûssRegi¡”
, 
	gQuickAcûss
 = 
V®ue


77 
impÜt
 
	gDebugAb¡¿ùCommªdTy³
.
	g_


96 
şass
 
	$DebugModuËP¬ams
 (

97 
nDMIAddrSize
 : 
IÁ
 = 7,

98 
nProg¿mBufãrWÜds
: 
IÁ
 = 16,

99 
nAb¡¿ùD©aWÜds
 : 
IÁ
 = 4,

100 
nSü©ch
 : 
IÁ
 = 1,

101 
hasBusMa¡”
 : 
BoŞ—n
 = 
çl£
,

102 
maxSuµÜ‹dSBAcûss
 : 
IÁ
 = 32,

103 
suµÜtQuickAcûss
 : 
BoŞ—n
 = 
çl£
,

104 
suµÜtH¬tA¼ay
 : 
BoŞ—n
 = 
çl£
,

105 
hasIm¶ic™Eb»ak
 : 
BoŞ—n
 = 
çl£


108 
	`»quœe
 ((
nDMIAddrSize
 >ğ7è&& (nDMIAddrSiz<ğ32), 
s
"Legal DMIAddrSize is 7-32,‚ot ${nDMIAddrSize}")

110 
	`»quœe
 ((
nAb¡¿ùD©aWÜds
 > 0è&& (nAb¡¿ùD©aWÜd <ğ16), 
s
"Legal‚AbstractDataWords is 0-16,‚ot ${nAbstractDataWords}")

111 
	`»quœe
 ((
nProg¿mBufãrWÜds
 >ğ0è&& (nProg¿mBufãrWÜd <ğ16), 
s
"Legal‚ProgramBufferWords is 0-16,‚ot ${nProgramBufferWords}")

113 ià(
suµÜtQuickAcûss
) {

117 
	}
}

119 
objeù
 
	gDeçuÉDebugModuËP¬ams
 {

121 
def
 
­¶y
(
xËn
:
IÁ
 ): 
DebugModuËP¬ams
 = {

122 
Ãw
 
DebugModuËP¬ams
().
cİy
(

123 
nAb¡¿ùD©aWÜds
 = (ià(
xËn
 == 32) 1 if (xlen == 64) 2 4),

124 
maxSuµÜ‹dSBAcûss
 = 
xËn


130 
objeù
 
DebugModuËP¬ams
 
ex‹nds
 
	gF›ld
[DebugModuleParams]

137 
şass
 
DebugModuËH¬tS–Funcs
 (

138 
h¬tIdToH¬tS–
 : (
UIÁ
è=> UIÁ = (
x
:UInt) => x,

139 
h¬tS–ToH¬tId
 : (
UIÁ
è=> UIÁ = (
x
:UInt) => x

142 
objeù
 
DebugModuËH¬tS–Key
 
ex‹nds
 
F›ld
(
	$DebugModuËH¬tS–Funcs
())

152 şas 
	cDebugIÁ”ÇlBundË
 ()(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
) {

153 
v®
 
»sum”eq
 = 
	$BoŞ
()

154 
v®
 
h¬t£l
 = 
	$UIÁ
(10.
W
)

155 
v®
 
ackhav”e£t
 = 
	`BoŞ
()

161 şas 
	cDebugCŒlBundË
 (
nCompÚ’ts
: 
IÁ
)(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
) {

162 
v®
 
debugUÇva
 = 
	`Vec
(
nCompÚ’ts
, 
	`BoŞ
()).
asIÅut


163 
v®
 
nd»£t
 = 
	$BoŞ
(
OUTPUT
)

164 
v®
 
dmaùive
 = 
	`BoŞ
(
OUTPUT
)

197 
objeù
 
WNÙifyWœe
 {

198 
def
 
	`­¶y
(
n
: 
IÁ
, 
v®ue
: 
UIÁ
, 
£t
: 
BoŞ
, 
Çme
: 
SŒšg
, 
desc
: SŒšgè: 
RegF›ld
 = {

199 
	`RegF›ld
(
n
, 
	`UIÁ
(0), 
	`RegWr™eFn
((
v®id
, 
d©a
) => {

200 
£t
 :ğ
v®id


201 
v®ue
 :ğ
d©a


202 
	`BoŞ
(
Œue
)

203 }), 
	`Some
(
	`RegF›ldDesc
(
Çme
 =‚ame, 
desc
 = desc,

204 
acûss
 = 
RegF›ldAcûssTy³
.
W
)))

206 
	}
}

209 
objeù
 
	gRWNÙify
 {

210 
def
 
­¶y
 (
n
: 
IÁ
, 
rV®
: 
UIÁ
, 
wV®
: UIÁ, 
rNÙify
: 
BoŞ
, 
wNÙify
: BoŞ, 
desc
: 
O±iÚ
[
RegF›ldDesc
] = 
NÚe
): 
RegF›ld
 = {

211 
RegF›ld
(
n
,

212 
RegR—dFn
 ((
»ady
è=> {
rNÙify
 :ğ»ady ; (
BoŞ
(
Œue
), 
rV®
)}),

213 
RegWr™eFn
((
v®id
, 
d©a
) => {

214 
wNÙify
 :ğ
v®id


215 
wh’
 (
v®id
è{
wV®
 :ğ
d©a
}

216 
BoŞ
(
Œue
)

218 ), 
desc
)

222 şas 
	cTLDebugModuËOu‹r
(
deviû
: 
Deviû
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

225 
impÜt
 
DMI_RegAddrs
.
_


227 
v®
 
šŠode
 = 
	`IÁNexusNode
(

228 
sourûFn
 = { 
_
 => 
	`IÁSourûPÜtP¬am‘”s
(
	`Seq
(
	`IÁSourûP¬am‘”s
(1, Seq(
	`Resourû
(
deviû
, "int"))))) },

229 
sškFn
 = { 
_
 => 
	`IÁSškPÜtP¬am‘”s
(
	`Seq
(
	`IÁSškP¬am‘”s
())è
	}
},

230 
	gouutRequœesIÅut
 = 
çl£
)

232 
v®
 
dmiNode
 = 
TLRegi¡”Node
 (

233 
add»ss
 = 
Add»ssS‘
.
mi§ligÃd
(
DMI_DMCONTROL
 << 2, 4),

234 
deviû
 = device,

235 
b—tBy‹s
 = 4,

236 
execubË
 = 
çl£


239 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

240 
	`»quœe
 (
šŠode
.
edges
.
š
.
size
 == 0, "Debug Module does‚ot‡ccept interrupts")

242 
v®
 
nCompÚ’ts
 = 
šŠode
.
out
.
size


244 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

245 
v®
 
ù¾
 = (
Ãw
 
	`DebugCŒlBundË
(
nCompÚ’ts
))

246 
v®
 
šÃrCŒl
 = 
Ãw
 
	`Decou¶edIO
Òew 
	`DebugIÁ”ÇlBundË
())

254 
v®
 
DMCONTROLRe£t
 = 
	`Wœe
(
š™
 = (
Ãw
 
	`DMCONTROLF›lds
().
	`äomB™s
(0.U)))

255 
v®
 
DMCONTROLNxt
 = 
	`Wœe
(
š™
 = 
Ãw
 
	`DMCONTROLF›lds
().
	`äomB™s
(0.U))

257 
v®
 
DMCONTROLReg
 = 
	`Wœe
(
š™
 = 
Ãw
 
	`DMCONTROLF›lds
().
	`äomB™s
(
	`AsyncRe£tReg
(
upd©eD©a
 = 
DMCONTROLNxt
.
asUIÁ
,

258 
»£tD©a
 = 
	`BigIÁ
(0),

259 
’abË
 = 
Œue
.
B
,

260 
Çme
 = "DMCONTROL"

263 
v®
 
DMCONTROLRdD©a
 = 
	`Wœe
(
š™
 = 
DMCONTROLReg
)

265 
v®
 
DMCONTROLWrD©aV®
 = 
	`Wœe
(
š™
 = 0.U(32.
W
))

266 
v®
 
DMCONTROLWrD©a
 = (
Ãw
 
	`DMCONTROLF›lds
()).
	`äomB™s
(
DMCONTROLWrD©aV®
)

267 
v®
 
DMCONTROLWrEn
 = 
	`Wœe
(
š™
 = 
çl£
.
B
)

268 
v®
 
DMCONTROLRdEn
 = 
	`Wœe
(
š™
 = 
çl£
.
B
)

270 
v®
 
dmaùive
 = 
DMCONTROLReg
.dmactive

272 
DMCONTROLNxt
 :ğ
DMCONTROLReg


273 
	`wh’
 (~
dmaùive
) {

274 
DMCONTROLNxt
 :ğ
DMCONTROLRe£t


275 } .
Ùh”wi£
 {

276 
	`wh’
 (
DMCONTROLWrEn
) {

277 
DMCONTROLNxt
.
ndm»£t
 :ğ
DMCONTROLWrD©a
.ndmreset

278 
DMCONTROLNxt
.
h¬t£Îo
 :ğ
DMCONTROLWrD©a
.hartsello

279 
DMCONTROLNxt
.
h®Œeq
 :ğ
DMCONTROLWrD©a
.haltreq

280 
DMCONTROLNxt
.
»sum”eq
 :ğ
DMCONTROLWrD©a
.resumereq

281 
DMCONTROLNxt
.
ackhav”e£t
 :ğ
DMCONTROLWrD©a
.ackhavereset

286 
	`wh’
 (
DMCONTROLWrEn
) {

287 
DMCONTROLNxt
.
dmaùive
 :ğ
DMCONTROLWrD©a
.dmactive

291 
dmiNode
.
	`»gm­
(

292 0 -> 
	`Seq
(
	`RWNÙify
(32, 
DMCONTROLRdD©a
.
	`asUIÁ
(),

293 
DMCONTROLWrD©aV®
, 
DMCONTROLRdEn
, 
DMCONTROLWrEn
, 
	`Some
(
	`RegF›ldDesc
("dmi_dmcÚŒŞ", "", 
»£t
=Some(0)))))

300 
v®
 
debugIÁNxt
 = 
	`Wœe
(
š™
 = 
Vec
.
	`fl
(
nCompÚ’ts
){
çl£
.
B
})

301 
v®
 
debugIÁRegs
 = 
	`Wœe
(
š™
 = 
	`Vec
(
	`AsyncRe£tReg
(
upd©eD©a
 = 
debugIÁNxt
.
asUIÁ
,

302 
»£tD©a
 = 0,

303 
’abË
 = 
Œue
.
B
,

304 
Çme
 = "debugIÁ”ru±s").
toBoŞs
))

306 
debugIÁNxt
 :ğ
debugIÁRegs


308 
	`v®
 (
šŠode_out
, 
_
èğ
šŠode
.
out
.
unz


309 
compÚ’t
 <- 0 
uÁ
 
nCompÚ’ts
) {

310 
	`šŠode_out
(
compÚ’t
)(0è:ğ
	`debugIÁRegs
(component)

321 
compÚ’t
 <- 0 
uÁ
 
nCompÚ’ts
) {

322 
	`wh’
 (~
dmaùive
) {

323 
	`debugIÁNxt
(
compÚ’t
è:ğ
çl£
.
B


324 }. 
Ùh”wi£
 {

325 
	`wh’
 (
DMCONTROLWrEn
 && 
DMCONTROLWrD©a
.
h¬t£Îo
 ==ğ
compÚ’t
.
U
) {

326 
	`debugIÁNxt
(
compÚ’t
è:ğ
DMCONTROLWrD©a
.
h®Œeq


331 
io
.
šÃrCŒl
.
v®id
 :ğ
DMCONTROLWrEn


332 
io
.
šÃrCŒl
.
b™s
.
h¬t£l
 :ğ
DMCONTROLWrD©a
.
h¬t£Îo


333 
io
.
šÃrCŒl
.
b™s
.
»sum”eq
 :ğ
DMCONTROLWrD©a
.resumereq

334 
io
.
šÃrCŒl
.
b™s
.
ackhav”e£t
 :ğ
DMCONTROLWrD©a
.ackhavereset

336 
io
.
ù¾
.
nd»£t
 :ğ
DMCONTROLReg
.
ndm»£t


337 
io
.
ù¾
.
dmaùive
 :ğ
DMCONTROLReg
.dmactive

339 
	}
}

342 şas 
	cTLDebugModuËOu‹rAsync
(
deviû
: 
Deviû
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

344 
v®
 
dmi2
 = 
	`LazyModuË
(
Ãw
 
	$DMIToTL
())

345 
v®
 
dmiXb¬
 = 
	`LazyModuË
 (
Ãw
 
	$TLXb¬
())

347 
v®
 
dmOu‹r
 = 
	`LazyModuË
Ğ
Ãw
 
	$TLDebugModuËOu‹r
(
deviû
))

348 
v®
 
šŠode
 = 
	$IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
 = 
Œue
è:*ğ
dmOu‹r
.
šŠode


350 
v®
 
dmiIÂ”Node
 = 
	$TLAsyncCrossšgSourû
(è:ğ
dmiXb¬
.
node


352 
dmiXb¬
.
node
 :ğ
dmi2
.node

353 
dmOu‹r
.
dmiNode
 :ğ
dmiXb¬
.
node


355 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

357 
v®
 
nCompÚ’ts
 = 
dmOu‹r
.
šŠode
.
edges
.
out
.
size


359 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

360 
v®
 
dmi
 = 
Ãw
 
	`DMIIO
()(
p
).
	`æ
()

361 
v®
 
ù¾
 = 
Ãw
 
	`DebugCŒlBundË
(
nCompÚ’ts
)

362 
v®
 
šÃrCŒl
 = 
Ãw
 
	`AsyncBundË
Òew 
	`DebugIÁ”ÇlBundË
(), 
AsyncQueueP¬ams
.
	`sšgËtÚ
())

365 
dmi2
.
moduË
.
io
.
dmi
 <> io.dmi

367 
io
.
ù¾
 <> 
dmOu‹r
.
moduË
.io.ctrl

368 
io
.
šÃrCŒl
 :ğ
	`ToAsyncBundË
(
dmOu‹r
.
moduË
.io.šÃrCŒl, 
AsyncQueueP¬ams
.
	`sšgËtÚ
())

371 
	}
}

373 
şass
 
TLDebugModuËIÂ”
(
deviû
: 
Deviû
, 
g‘NCompÚ’ts
: (è=> 
IÁ
, 
b—tBy‹s
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


376 
v®
 
cfg
 = 
p
(
DebugModuËP¬ams
)

377 
v®
 
h¬tS–Funcs
 = 
p
(
DebugModuËH¬tS–Key
)

379 
v®
 
dmiNode
 = 
TLRegi¡”Node
(

380 
add»ss
 = 
Add»ssS‘
.
mi§ligÃd
(0, 
DMI_RegAddrs
.
DMI_DMCONTROL
 << 2) ++

381 
Add»ssS‘
.
mi§ligÃd
((
DMI_RegAddrs
.
DMI_DMCONTROL
 + 1) << 2, (0x200 - ((DMI_RegAddrs.DMI_DMCONTROL + 1) << 2))),

382 
deviû
 = device,

383 
b—tBy‹s
 = 4,

384 
execubË
 = 
çl£


387 
v®
 
Node
 = 
TLRegi¡”Node
(

388 
add»ss
=
Seq
(
Add»ssS‘
(0, 0xFFF)),

389 
deviû
=device,

390 
b—tBy‹s
=beatBytes,

391 
execubË
=
Œue


394 
v®
 
sb2O±
 = 
cfg
.
hasBusMa¡”
.
İtiÚ
(
LazyModuË
(
Ãw
 
SBToTL
()))

399 
v®
 
cu¡omNode
 = 
Ãw
 
DebugCu¡omSšk
()

401 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
LazyModuËImp
(
this
){

402 
v®
 
nCompÚ’ts
 = 
g‘NCompÚ’ts
()

403 
AÂÙ©ed
.
·¿ms
(
this
, 
cfg
)

405 
v®
 
	gio
 = 
IO
(
Ãw
 
BundË
 {

406 
v®
 
dmaùive
 = 
BoŞ
(
INPUT
)

407 
v®
 
šÃrCŒl
 = (
Ãw
 
Decou¶edIO
Òew 
DebugIÁ”ÇlBundË
())).
æ


408 
v®
 
debugUÇva
 = 
Vec
(
nCompÚ’ts
, 
BoŞ
()).
asIÅut


416 
impÜt
 
	gDMI_RegAddrs
.
_


417 
impÜt
 
	gDsbRegAddrs
.
_


418 
impÜt
 
	gDsbBusCÚ¡s
.
_


419 
impÜt
 
	gDMICÚ¡s
.
_


425 
»quœe
 (
cfg
.
suµÜtQuickAcûss
 =ğ
çl£
, "No Quick Access support yet")

426 
»quœe
 (
cfg
.
suµÜtH¬tA¼ay
 =ğ
çl£
, "No Hart Array support yet")

432 
v®
 
	gh®‹dB™Regs
 = 
RegIn™
(
Vec
.
fl
(
nCompÚ’ts
){
çl£
.
B
})

433 
v®
 
»sumeReqRegs
 = 
RegIn™
(
Vec
.
fl
(
nCompÚ’ts
){
çl£
.
B
})

434 
v®
 
haveRe£tB™Regs
 = 
RegIn™
(
Vec
.
fl
(
nCompÚ’ts
){
Œue
.
B
})

438 
v®
 
h¬tH®‹dWrEn
 = 
Wœe
(
BoŞ
())

439 
v®
 
h¬tH®‹dId
 = 
Wœe
(
UIÁ
(
sbIdWidth
.
W
))

440 
v®
 
h¬tGošgWrEn
 = 
Wœe
(
BoŞ
())

441 
v®
 
h¬tGošgId
 = 
Wœe
(
UIÁ
(
sbIdWidth
.
W
))

442 
v®
 
h¬tResumšgWrEn
 = 
Wœe
(
BoŞ
())

443 
v®
 
h¬tResumšgId
 = 
Wœe
(
UIÁ
(
sbIdWidth
.
W
))

444 
v®
 
h¬tExû±iÚWrEn
 = 
Wœe
(
BoŞ
())

445 
v®
 
h¬tExû±iÚId
 = 
Wœe
(
UIÁ
(
sbIdWidth
.
W
))

447 
v®
 
dmiProg¿mBufãrRdEn
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nProg¿mBufãrWÜds
 * 4){
çl£
.
B
})

448 
v®
 
dmiProg¿mBufãrAcûssLeg®
 = 
Wœe
(
š™
 = 
çl£
.
B
)

449 
v®
 
dmiProg¿mBufãrWrEnMaybe
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nProg¿mBufãrWÜds
 * 4){
çl£
.
B
})

451 
v®
 
dmiAb¡¿ùD©aRdEn
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nAb¡¿ùD©aWÜds
 * 4){
çl£
.
B
})

452 
v®
 
dmiAb¡¿ùD©aAcûssLeg®
 = 
Wœe
 (
š™
 = 
çl£
.
B
)

453 
v®
 
dmiAb¡¿ùD©aWrEnMaybe
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nAb¡¿ùD©aWÜds
 * 4){
çl£
.
B
})

459 
v®
 
£ËùedH¬tReg
 = 
RegIn™
(0.U(10.
W
))

461 
wh’
 (
io
.
šÃrCŒl
.
fœe
()){

462 
£ËùedH¬tReg
 :ğ
io
.
šÃrCŒl
.
b™s
.
h¬t£l


465 
io
.
šÃrCŒl
.
»ady
 :ğ
Œue
.
B


473 
v®
 
DMSTATUSRdD©a
 = 
Wœe
(
š™
 = (
Ãw
 
DMSTATUSF›lds
()).
äomB™s
(0.U))

474 
DMSTATUSRdD©a
.
auth’tiÿ‹d
 :ğ
Œue
.
B


475 
DMSTATUSRdD©a
.
v”siÚ
 := 2.U

477 
wh’
 (
£ËùedH¬tReg
 >ğ
nCompÚ’ts
.
U
) {

478 
DMSTATUSRdD©a
.
®ÊÚexi¡’t
 :ğ
Œue
.
B


479 
DMSTATUSRdD©a
.
ªynÚexi¡’t
 :ğ
Œue
.
B


480 }.
–£wh’
 (
io
.
debugUÇva
(
£ËùedH¬tReg
)) {

481 
DMSTATUSRdD©a
.
®luÇva
 :ğ
Œue
.
B


482 
DMSTATUSRdD©a
.
ªyuÇva
 :ğ
Œue
.
B


483 }.
–£wh’
 (
h®‹dB™Regs
(
£ËùedH¬tReg
)) {

484 
DMSTATUSRdD©a
.
®lh®‹d
 :ğ
Œue
.
B


485 
DMSTATUSRdD©a
.
ªyh®‹d
 :ğ
Œue
.
B


486 }.
Ùh”wi£
 {

487 
DMSTATUSRdD©a
.
®ÌuÂšg
 :ğ
Œue
.
B


488 
DMSTATUSRdD©a
.
ªyruÂšg
 :ğ
Œue
.
B


490 
DMSTATUSRdD©a
.
®lhav”e£t
 :ğ
haveRe£tB™Regs
(
£ËùedH¬tReg
)

491 
DMSTATUSRdD©a
.
ªyhav”e£t
 :ğ
haveRe£tB™Regs
(
£ËùedH¬tReg
)

493 
v®
 
»sum”eq
 = 
io
.
šÃrCŒl
.
fœe
(è&& io.šÃrCŒl.
b™s
.resumereq

495 
wh’
 (
io
.
šÃrCŒl
.
fœe
()){

496 
wh’
 (
io
.
šÃrCŒl
.
b™s
.
ackhav”e£t
) {

497 
haveRe£tB™Regs
(
io
.
šÃrCŒl
.
b™s
.
h¬t£l
è:ğ
çl£
.
B


501 
DMSTATUSRdD©a
.
®Ìesum—ck
 :ğ~
»sumeReqRegs
(
£ËùedH¬tReg
è&& ~
»sum”eq


502 
DMSTATUSRdD©a
.
ªy»sum—ck
 :ğ~
»sumeReqRegs
(
£ËùedH¬tReg
è&& ~
»sum”eq


505 
DMSTATUSRdD©a
.
devŒ“v®id
 :ğ
çl£
.
B


507 
DMSTATUSRdD©a
.
im³b»ak
 :ğ(
cfg
.
hasIm¶ic™Eb»ak
).
B


511 
v®
 
HARTINFORdD©a
 = 
Wœe
 (
š™
 = (
Ãw
 
HARTINFOF›lds
()).
äomB™s
(0.U))

512 
HARTINFORdD©a
.
d©¯cûss
 :ğ
Œue
.
B


513 
HARTINFORdD©a
.
d©asize
 :ğ
cfg
.
nAb¡¿ùD©aWÜds
.
U


514 
HARTINFORdD©a
.
d©¯ddr
 :ğ
DsbRegAddrs
.
DATA
.
U


515 
HARTINFORdD©a
.
nsü©ch
 :ğ
cfg
.
nSü©ch
.
U


518 
v®
 
numH®‹dStus
 = ((
nCompÚ’ts
 - 1) / 32) + 1

519 
v®
 
h®‹dStus
 = 
Wœe
(
Vec
(
numH®‹dStus
, 
B™s
(
width
 = 32)))

521 
ii
 <- 0 
uÁ
 
numH®‹dStus
) {

522 
h®‹dStus
(
ii
è:ğ
C©
(
h®‹dB™Regs
.
¦iû
(i˜* 32, (i˜+ 1è* 32).
»v”£
)

525 
v®
 
	gh®‹dSumm¬y
 = 
C©
(
h®‹dStus
.
m­
(
_
.
ÜR
).
»v”£
)

526 
v®
 
HALTSUM1RdD©a
 = (
Ãw
 
HALTSUM1F›lds
()).
äomB™s
(
h®‹dSumm¬y
)

528 
v®
 
£ËùedH®‹dStus
 = 
Mux
((
£ËùedH¬tReg
 >> 5è> 
numH®‹dStus
.
U
, 0.U, 
h®‹dStus
(selectedHartReg >> 5))

529 
v®
 
	gHALTSUM0RdD©a
 = (
Ãw
 
HALTSUM0F›lds
()).
äomB™s
(
£ËùedH®‹dStus
)

535 
v®
 
ABSTRACTCSRe£t
 = 
Wœe
(
š™
 = (
Ãw
 
ABSTRACTCSF›lds
()).
äomB™s
(0.U))

536 
ABSTRACTCSRe£t
.
d©acouÁ
 :ğ
cfg
.
nAb¡¿ùD©aWÜds
.
U


537 
ABSTRACTCSRe£t
.
´ogbufsize
 :ğ
cfg
.
nProg¿mBufãrWÜds
.
U


539 
v®
 
ABSTRACTCSReg
 = 
Reg
(
Ãw
 
ABSTRACTCSF›lds
())

540 
v®
 
ABSTRACTCSWrD©aV®
 = 
Wœe
(
š™
 = 0.U(32.
W
))

541 
v®
 
ABSTRACTCSWrD©a
 = (
Ãw
 
ABSTRACTCSF›lds
()).
äomB™s
(
ABSTRACTCSWrD©aV®
)

542 
v®
 
ABSTRACTCSRdD©a
 = 
Wœe
(
š™
 = 
ABSTRACTCSReg
)

544 
v®
 
ABSTRACTCSRdEn
 = 
Wœe
(
š™
 = 
çl£
.
B
)

545 
v®
 
ABSTRACTCSWrEnMaybe
 = 
Wœe
(
š™
 = 
çl£
.
B
)

547 
v®
 
ABSTRACTCSWrEnLeg®
 = 
Wœe
(
š™
 = 
çl£
.
B
)

548 
v®
 
ABSTRACTCSWrEn
 = 
ABSTRACTCSWrEnMaybe
 && 
ABSTRACTCSWrEnLeg®


550 
v®
 
”rÜBusy
 = 
Wœe
(
š™
 = 
çl£
.
B
)

551 
v®
 
”rÜExû±iÚ
 = 
Wœe
(
š™
 = 
çl£
.
B
)

552 
v®
 
”rÜUnsuµÜ‹d
 = 
Wœe
(
š™
 = 
çl£
.
B
)

553 
v®
 
”rÜH®tResume
 = 
Wœe
(
š™
 = 
çl£
.
B
)

555 
wh’
(~
io
.
dmaùive
){

556 
ABSTRACTCSReg
 :ğ
ABSTRACTCSRe£t


557 }.
Ùh”wi£
 {

558 
wh’
 (
”rÜBusy
){

559 
ABSTRACTCSReg
.
cmd”r
 :ğ
DebugAb¡¿ùCommªdE¼Ü
.
E¼Busy
.
id
.
U


560 }.
–£wh’
 (
”rÜExû±iÚ
) {

561 
ABSTRACTCSReg
.
cmd”r
 :ğ
DebugAb¡¿ùCommªdE¼Ü
.
E¼Exû±iÚ
.
id
.
U


562 }.
–£wh’
 (
”rÜUnsuµÜ‹d
) {

563 
ABSTRACTCSReg
.
cmd”r
 :ğ
DebugAb¡¿ùCommªdE¼Ü
.
E¼NÙSuµÜ‹d
.
id
.
U


564 }.
–£wh’
 (
”rÜH®tResume
) {

565 
ABSTRACTCSReg
.
cmd”r
 :ğ
DebugAb¡¿ùCommªdE¼Ü
.
E¼H®tResume
.
id
.
U


566 }.
Ùh”wi£
 {

567 
wh’
 (
ABSTRACTCSWrEn
){

568 
ABSTRACTCSReg
.
cmd”r
 :ğABSTRACTCSReg.cmd”¸& ~(
ABSTRACTCSWrD©a
.cmderr);

574 
v®
 
	gab¡¿ùCommªdBusy
 = 
Wœe
(
š™
 = 
Œue
.
B
)

575 
ABSTRACTCSRdD©a
.
busy
 :ğ
ab¡¿ùCommªdBusy


579 
v®
 
ABSTRACTAUTORe£t
 = 
Wœe
(
š™
 = (
Ãw
 
ABSTRACTAUTOF›lds
()).
äomB™s
(0.U))

580 
v®
 
ABSTRACTAUTOReg
 = 
Reg
(
Ãw
 
ABSTRACTAUTOF›lds
())

581 
v®
 
ABSTRACTAUTOWrD©aV®
 = 
Wœe
(
š™
 = 0.U(32.
W
))

582 
v®
 
ABSTRACTAUTOWrD©a
 = (
Ãw
 
ABSTRACTAUTOF›lds
()).
äomB™s
(
ABSTRACTAUTOWrD©aV®
)

583 
v®
 
ABSTRACTAUTORdD©a
 = 
Wœe
(
š™
 = 
ABSTRACTAUTOReg
)

585 
v®
 
ABSTRACTAUTORdEn
 = 
Wœe
(
š™
 = 
çl£
.
B
)

586 
v®
 
ABSTRACTAUTOWrEnMaybe
 = 
Wœe
(
š™
 = 
çl£
.
B
)

588 
v®
 
ABSTRACTAUTOWrEnLeg®
 = 
Wœe
(
š™
 = 
çl£
.
B
)

589 
v®
 
ABSTRACTAUTOWrEn
 = 
ABSTRACTAUTOWrEnMaybe
 && 
ABSTRACTAUTOWrEnLeg®


591 
wh’
 (~
io
.
dmaùive
) {

592 
ABSTRACTAUTOReg
 :ğ
ABSTRACTAUTORe£t


593 }.
–£wh’
 (
ABSTRACTAUTOWrEn
) {

594 
ABSTRACTAUTOReg
.
autÛxeırogbuf
 :ğ
ABSTRACTAUTOWrD©a
.autÛxeırogbuà& ( (1 << 
cfg
.
nProg¿mBufãrWÜds
è- 1).
U


595 
ABSTRACTAUTOReg
.
autÛxecd©a
 :ğ
ABSTRACTAUTOWrD©a
.autÛxecd©¨& ( (1 << 
cfg
.
nAb¡¿ùD©aWÜds
è- 1).
U


598 
v®
 
dmiAb¡¿ùD©aAcûssVec
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nAb¡¿ùD©aWÜds
 * 4){
çl£
.
B
})

599 
dmiAb¡¿ùD©aAcûssVec
 :ğ(
dmiAb¡¿ùD©aWrEnMaybe
 
z
 
dmiAb¡¿ùD©aRdEn
).
m­
{ (
r
,
w
) =>„ | w}

601 
v®
 
	gdmiProg¿mBufãrAcûssVec
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nProg¿mBufãrWÜds
 * 4){
çl£
.
B
})

602 
dmiProg¿mBufãrAcûssVec
 :ğ(
dmiProg¿mBufãrWrEnMaybe
 
z
 
dmiProg¿mBufãrRdEn
).
m­
{ (
r
,
w
) =>„ | w}

604 
v®
 
	gdmiAb¡¿ùD©aAcûss
 = 
dmiAb¡¿ùD©aAcûssVec
.
»duû
(
_
 || _ )

605 
v®
 
dmiProg¿mBufãrAcûss
 = 
dmiProg¿mBufãrAcûssVec
.
»duû
(
_
 || _)

608 
v®
 
autÛxecD©a
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nAb¡¿ùD©aWÜds
){
çl£
.
B
})

609 
v®
 
autÛxecProg
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
cfg
.
nProg¿mBufãrWÜds
){
çl£
.
B
})

610 (
autÛxecD©a
 
z
 
ABSTRACTAUTOReg
.
autÛxecd©a
.
toBoŞs
).
zW™hIndex
.
fÜ—ch
 {(
t
, 
i
è=>.
_1
 :ğ
dmiAb¡¿ùD©aAcûssVec
(˜* 4è&&.
_2
 }

611 (
autÛxecProg
 
z
 
ABSTRACTAUTOReg
.
autÛxeırogbuf
.
toBoŞs
).
zW™hIndex
.
fÜ—ch
 {(
t
, 
	gi
è=>.
_1
 :ğ
dmiProg¿mBufãrAcûssVec
(
i
 * 4è&&.
_2
}

613 
v®
 
autÛxec
 = 
autÛxecD©a
.
»duû
(
_
 || _è|| 
autÛxecProg
.reduce(_ || _)

617 
v®
 
COMMANDRe£t
 = 
Wœe
(
š™
 = (
Ãw
 
COMMANDF›lds
()).
äomB™s
(0.U))

618 
v®
 
COMMANDReg
 = 
Reg
(
Ãw
 
COMMANDF›lds
())

620 
v®
 
COMMANDWrD©aV®
 = 
Wœe
(
š™
 = 0.U(32.
W
))

621 
v®
 
COMMANDWrD©a
 = 
Wœe
(
š™
 = (
Ãw
 
COMMANDF›lds
()).
äomB™s
(
COMMANDWrD©aV®
))

622 
v®
 
COMMANDWrEnMaybe
 = 
Wœe
(
š™
 = 
çl£
.
B
)

623 
v®
 
COMMANDWrEnLeg®
 = 
Wœe
(
š™
 = 
çl£
.
B
)

624 
v®
 
COMMANDRdEn
 = 
Wœe
(
š™
 = 
çl£
.
B
)

626 
v®
 
COMMANDWrEn
 = 
COMMANDWrEnMaybe
 && 
COMMANDWrEnLeg®


627 
v®
 
COMMANDRdD©a
 = 
COMMANDReg


629 
wh’
 (~
io
.
dmaùive
) {

630 
COMMANDReg
 :ğ
COMMANDRe£t


631 }.
Ùh”wi£
 {

632 
wh’
 (
COMMANDWrEn
) {

633 
COMMANDReg
 :ğ
COMMANDWrD©a


641 
v®
 
ab¡¿ùD©aMem
 = 
Reg
(
Vec
(
cfg
.
nAb¡¿ùD©aWÜds
*4, 
UIÁ
(8.
W
)))

642 
v®
 
	gab¡¿ùD©aNxt
 = 
Wœe
(
š™
 = 
ab¡¿ùD©aMem
)

645 
v®
 
´og¿mBufãrMem
 = 
Reg
(
Vec
(
cfg
.
nProg¿mBufãrWÜds
*4, 
UIÁ
(8.
W
)))

646 
v®
 
	g´og¿mBufãrNxt
 = 
Wœe
(
š™
 = 
´og¿mBufãrMem
)

653 
compÚ’t
 <- 0 
uÁ
 
nCompÚ’ts
) {

654 
wh’
 (~
io
.
dmaùive
) {

655 
h®‹dB™Regs
(
compÚ’t
è:ğ
çl£
.
B


656 
»sumeReqRegs
(
compÚ’t
è:ğ
çl£
.
B


657 }.
Ùh”wi£
 {

659 
wh’
 (
h¬tH®‹dWrEn
) {

660 
wh’
 (
h¬tS–Funcs
.
h¬tIdToH¬tS–
(
h¬tH®‹dId
è==ğ
compÚ’t
.
U
) {

661 
h®‹dB™Regs
(
compÚ’t
è:ğ
Œue
.
B


663 }.
–£wh’
 (
h¬tResumšgWrEn
) {

664 
wh’
 (
h¬tS–Funcs
.
h¬tIdToH¬tS–
(
h¬tResumšgId
è==ğ
compÚ’t
.
U
) {

665 
h®‹dB™Regs
(
compÚ’t
è:ğ
çl£
.
B


673 
wh’
 (
h¬tResumšgWrEn
) {

674 
wh’
 (
h¬tS–Funcs
.
h¬tIdToH¬tS–
(
h¬tResumšgId
è==ğ
compÚ’t
.
U
) {

675 
»sumeReqRegs
(
compÚ’t
è:ğ
çl£
.
B


678 
wh’
(
»sum”eq
) {

679 
»sumeReqRegs
(
io
.
šÃrCŒl
.
b™s
.
h¬t£l
è:ğ
Œue
.
B


684 
v®
 (
sbcsF›lds
, 
sbAddrF›lds
, 
sbD©aF›lds
):

685 (
Seq
[
RegF›ld
], 
	gSeq
[Seq[RegF›ld]], Seq[Seq[RegF›ld]]èğ
sb2O±
.
m­
{ 
sb2
 =>

686 
Sy¡emBusAcûssModuË
(
sb2
,
io
.
dmaùive
)(
	gp
)

687 }.
g‘OrEl£
((
Seq
.
em±y
[
RegF›ld
], Seq.
fl
[Seq[RegField]](4)(Seq.empty[RegField]), Seq.fill[Seq[RegField]](4)(Seq.empty[RegField])))

692 
	gdmiNode
.
»gm­
(

693 (
DMI_DMSTATUS
 << 2è-> 
Seq
(
RegF›ld
.
r
(32, 
DMSTATUSRdD©a
.
asUIÁ
(), 
RegF›ldDesc
("dmi_dmstatus", ""))),

695 (
DMI_HARTINFO
 << 2è-> 
Seq
(
RegF›ld
.
r
(32, 
HARTINFORdD©a
.
asUIÁ
(), 
RegF›ldDesc
("dmi_hartinfo", "" ))),

696 (
DMI_HALTSUM0
 << 2è-> 
Seq
(
RegF›ld
.
r
(32, 
HALTSUM0RdD©a
.
asUIÁ
(), 
RegF›ldDesc
("dmi_haltsum0", ""))),

697 (
DMI_HALTSUM1
 << 2è-> 
Seq
(
RegF›ld
.
r
(32, 
HALTSUM1RdD©a
.
asUIÁ
(), 
RegF›ldDesc
("dmi_haltsum1", ""))),

698 (
DMI_ABSTRACTCS
 << 2è-> 
Seq
(
RWNÙify
(32, 
ABSTRACTCSRdD©a
.
asUIÁ
(), 
ABSTRACTCSWrD©aV®
, 
ABSTRACTCSRdEn
, 
ABSTRACTCSWrEnMaybe
,

699 
Some
(
RegF›ldDesc
("dmi_abstractcs", "" )))),

700 (
DMI_ABSTRACTAUTO
<< 2è-> 
Seq
(
RWNÙify
(32, 
ABSTRACTAUTORdD©a
.
asUIÁ
(), 
ABSTRACTAUTOWrD©aV®
, 
ABSTRACTAUTORdEn
, 
ABSTRACTAUTOWrEnMaybe
,

701 
Some
(
RegF›ldDesc
("dmi_ab¡¿ùauto", "", 
»£t
=Some(0))))),

702 (
DMI_COMMAND
 << 2è-> 
Seq
(
RWNÙify
(32, 
COMMANDRdD©a
.
asUIÁ
(), 
COMMANDWrD©aV®
, 
COMMANDRdEn
, 
COMMANDWrEnMaybe
,

703 
Some
(
RegF›ldDesc
("dmi_commªd", "", 
»£t
=Some(0))))),

704 (
DMI_DATA0
 << 2è-> 
RegF›ldGroup
("dmi_d©a", 
NÚe
, 
ab¡¿ùD©aMem
.
zW™hIndex
.
m­
{(
x
, 
i
è=> 
RWNÙify
(8, x, 
ab¡¿ùD©aNxt
(i),

705 
dmiAb¡¿ùD©aRdEn
(
i
),

706 
dmiAb¡¿ùD©aWrEnMaybe
(
i
),

707 
Some
(
RegF›ldDesc
(
s
"dmi_d©a_$i", "", 
»£t
 = Some(0))))}),

708 (
DMI_PROGBUF0
 << 2è-> 
RegF›ldGroup
("dmi_´ogbuf", 
NÚe
, 
´og¿mBufãrMem
.
zW™hIndex
.
m­
{(
x
, 
i
è=> 
RWNÙify
(8, x, 
´og¿mBufãrNxt
(i),

709 
dmiProg¿mBufãrRdEn
(
i
),

710 
dmiProg¿mBufãrWrEnMaybe
(
i
),

711 
Some
(
RegF›ldDesc
(
s
"dmi_´ogbuf_$i", "", 
»£t
 = Some(0))))}),

712 (
DMI_SBCS
 << 2è-> 
sbcsF›lds
,

713 (
DMI_SBDATA0
 << 2è-> 
sbD©aF›lds
(0),

714 (
DMI_SBDATA1
 << 2è-> 
sbD©aF›lds
(1),

715 (
DMI_SBDATA2
 << 2è-> 
sbD©aF›lds
(2),

716 (
DMI_SBDATA3
 << 2è-> 
sbD©aF›lds
(3),

717 (
DMI_SBADDRESS0
 << 2è-> 
sbAddrF›lds
(0),

718 (
DMI_SBADDRESS1
 << 2è-> 
sbAddrF›lds
(1),

719 (
DMI_SBADDRESS2
 << 2è-> 
sbAddrF›lds
(2),

720 (
DMI_SBADDRESS3
 << 2è-> 
sbAddrF›lds
(3)

724 
	gab¡¿ùD©aMem
.
	gzW™hIndex
.
	gfÜ—ch
 { (
	gx
, 
	gi
) =>

725 
wh’
 (
dmiAb¡¿ùD©aWrEnMaybe
(
i
è&& 
dmiAb¡¿ùD©aAcûssLeg®
) {

726 
x
 :ğ
ab¡¿ùD©aNxt
(
i
)

730 
v®
 (
cu¡oms
, 
cu¡omP¬ams
èğ
cu¡omNode
.
š
.
unz


731 
v®
 
ÃedCu¡om
 = (
cu¡oms
.
size
 > 0è&& (
cu¡omP¬ams
.
h—d
.
addrs
.size > 0)

732 ià(
ÃedCu¡om
) {

733 
v®
 (
cu¡om
, 
cu¡omP
èğ
cu¡omNode
.
š
.
h—d


734 
»quœe
(
cu¡omP
.
width
 % 8 =ğ0, 
s
"Debug Custom width must be divisible by 8,‚ot ${customP.width}")

735 
v®
 
	gcu¡om_d©a
 = 
cu¡om
.
d©a
.
toBoŞs


736 
v®
 
cu¡om_by‹s
 = 
Seq
.
buÏ‹
(
cu¡omP
.
width
/8){
i
 => 
cu¡om_d©a
.
¦iû
(i*8, (i+1)*8).
	gasUIÁ
}

737 
wh’
 (
cu¡om
.
»ady
 && cu¡om.
v®id
) {

738 (
ab¡¿ùD©aMem
 
z
 
	gcu¡om_by‹s
).
	gzW™hIndex
.
	gfÜ—ch
 {((
	ga
, 
	gb
), 
	gi
) =>

739 
a
 :ğ
b


744 
´og¿mBufãrMem
.
zW™hIndex
.
fÜ—ch
 { (
x
, 
	gi
) =>

745 
wh’
 (
dmiProg¿mBufãrWrEnMaybe
(
i
è&& 
dmiProg¿mBufãrAcûssLeg®
) {

746 
x
 :ğ
´og¿mBufãrNxt
(
i
)

754 
v®
 
goReg
 = 
Reg
(
BoŞ
())

755 
v®
 
goAb¡¿ù
 = 
Wœe
(
š™
 = 
çl£
.
B
)

756 
v®
 
goCu¡om
 = 
Wœe
(
š™
 = 
çl£
.
B
)

757 
v®
 
j®Ab¡¿ù
 = 
Wœe
(
š™
 = (
Ãw
 
G’”©edUJ
()).
äomB™s
(
In¡ruùiÚs
.
JAL
.
v®ue
.
U
))

758 
j®Ab¡¿ù
.
£tImm
(
ABSTRACT
(
cfg
è- 
WHERETO
)

760 
wh’
 (~
io
.
dmaùive
){

761 
goReg
 :ğ
çl£
.
B


762 }.
Ùh”wi£
 {

763 
wh’
 (
goAb¡¿ù
) {

764 
goReg
 :ğ
Œue
.
B


765 }.
–£wh’
 (
h¬tGošgWrEn
){

766 
as£¹
(
h¬tGošgId
 === 0.U, "Unexpected 'GOING' hart.")

767 
	ggoReg
 :ğ
çl£
.
B


771 şas 
	cæagBundË
 
ex‹nds
 
BundË
 {

772 
v®
 
»£rved
 = 
UIÁ
(6.
W
)

773 
v®
 
»sume
 = 
BoŞ
()

774 
v®
 
go
 = 
BoŞ
()

777 
v®
 
æags
 = 
Wœe
(
š™
 = 
Vec
.
fl
(1024){
Ãw
 
æagBundË
().
äomB™s
(0.U)})

778 
as£¹
 ((
h¬tS–Funcs
.
h¬tS–ToH¬tId
(
£ËùedH¬tReg
) < 1024.U),

780 
æags
(
h¬tS–Funcs
.
h¬tS–ToH¬tId
(
£ËùedH¬tReg
)).
	ggo
 :ğ
goReg


781 
compÚ’t
 <- 0 
uÁ
 
nCompÚ’ts
) {

782 
v®
 
compÚ’tS–
 = 
Wœe
(
š™
 = 
compÚ’t
.
U
)

783 
æags
(
h¬tS–Funcs
.
h¬tS–ToH¬tId
(
compÚ’tS–
)).
»sume
 :ğ
»sumeReqRegs
(
compÚ’t
)

790 
v®
 
acûssRegi¡”CommªdWr
 = 
Wœe
(
š™
 = (
Ãw
 
ACCESS_REGISTERF›lds
()).
äomB™s
(
COMMANDWrD©a
.
asUIÁ
()))

791 
v®
 
acûssRegi¡”CommªdReg
 = 
Wœe
(
š™
 = (
Ãw
 
ACCESS_REGISTERF›lds
()).
äomB™s
(
COMMANDReg
.
asUIÁ
()))

795 şas 
	cG’”©edI
 
ex‹nds
 
BundË
 {

796 
v®
 
imm
 = 
UIÁ
(12.
W
)

797 
v®
 
rs1
 = 
UIÁ
(5.
W
)

798 
v®
 
funù3
 = 
UIÁ
(3.
W
)

799 
v®
 
rd
 = 
UIÁ
(5.
W
)

800 
v®
 
İcode
 = 
UIÁ
(7.
W
)

803 şas 
	cG’”©edS
 
ex‹nds
 
BundË
 {

804 
v®
 
immhi
 = 
UIÁ
(7.
W
)

805 
v®
 
rs2
 = 
UIÁ
(5.
W
)

806 
v®
 
rs1
 = 
UIÁ
(5.
W
)

807 
v®
 
funù3
 = 
UIÁ
(3.
W
)

808 
v®
 
immlo
 = 
UIÁ
(5.
W
)

809 
v®
 
İcode
 = 
UIÁ
(7.
W
)

812 şas 
	cG’”©edUJ
 
ex‹nds
 
BundË
 {

813 
v®
 
imm3
 = 
UIÁ
(1.
W
)

814 
v®
 
imm0
 = 
UIÁ
(10.
W
)

815 
v®
 
imm1
 = 
UIÁ
(1.
W
)

816 
v®
 
imm2
 = 
UIÁ
(8.
W
)

817 
v®
 
rd
 = 
UIÁ
(5.
W
)

818 
v®
 
İcode
 = 
UIÁ
(7.
W
)

820 
def
 
£tImm
(
imm
: 
IÁ
è: 
Un™
 = {

823 
»quœe
(
imm
 % 2 == 0, "Immediate must beƒven for UJƒncoding.")

824 
v®
 
	gimmWœe
 = 
Wœe
(
š™
 = 
imm
.
S
(21.
W
))

825 
v®
 
immB™s
 = 
Wœe
(
š™
 = 
Vec
(
immWœe
.
toBoŞs
))

827 
imm0
 :ğ
immB™s
.
¦iû
(1, 1 + 10).
asUIÁ
()

828 
	gimm1
 :ğ
immB™s
.
¦iû
(11, 11 + 11).
asUIÁ
()

829 
	gimm2
 :ğ
immB™s
.
¦iû
(12, 12 + 8).
asUIÁ
()

830 
	gimm3
 :ğ
immB™s
.
¦iû
(20, 20 + 1).
asUIÁ
()

834 
v®
 
	gab¡¿ùG’”©edMem
 = 
Reg
(
Vec
(2, (
UIÁ
(32.
W
))))

835 
v®
 
	gab¡¿ùG’”©edI
 = 
Wœe
(
Ãw
 
G’”©edI
())

836 
v®
 
ab¡¿ùG’”©edS
 = 
Wœe
(
Ãw
 
G’”©edS
())

837 
v®
 
nİ
 = 
Wœe
(
Ãw
 
G’”©edI
())

839 
ab¡¿ùG’”©edI
.
İcode
 :ğ((
Ãw
 
G’”©edI
()).
äomB™s
(
In¡ruùiÚs
.
LW
.
v®ue
.
U
)).opcode

840 
ab¡¿ùG’”©edI
.
rd
 :ğ(
acûssRegi¡”CommªdReg
.
»gno
 & 0x1F.U)

841 
ab¡¿ùG’”©edI
.
funù3
 :ğ
acûssRegi¡”CommªdReg
.
size


842 
ab¡¿ùG’”©edI
.
rs1
 := 0.U

843 
ab¡¿ùG’”©edI
.
imm
 :ğ
DATA
.
U


845 
ab¡¿ùG’”©edS
.
İcode
 :ğ((
Ãw
 
G’”©edS
()).
äomB™s
(
In¡ruùiÚs
.
SW
.
v®ue
.
U
)).opcode

846 
ab¡¿ùG’”©edS
.
immlo
 :ğ(
DATA
 & 0x1F).
U


847 
ab¡¿ùG’”©edS
.
funù3
 :ğ
acûssRegi¡”CommªdReg
.
size


848 
ab¡¿ùG’”©edS
.
rs1
 := 0.U

849 
ab¡¿ùG’”©edS
.
rs2
 :ğ(
acûssRegi¡”CommªdReg
.
»gno
 & 0x1F.U)

850 
ab¡¿ùG’”©edS
.
immhi
 :ğ(
DATA
 >> 5).
U


852 
nİ
 :ğ((
Ãw
 
G’”©edI
()).
äomB™s
(
In¡ruùiÚs
.
ADDI
.
v®ue
.
U
))

853 
nİ
.
rd
 := 0.U

854 
nİ
.
rs1
 := 0.U

855 
nİ
.
imm
 := 0.U

857 
wh’
 (
goAb¡¿ù
) {

858 
ab¡¿ùG’”©edMem
(0è:ğ
Mux
(
acûssRegi¡”CommªdReg
.
Œªsãr
,

859 
Mux
(
acûssRegi¡”CommªdReg
.
wr™e
,

861 
ab¡¿ùG’”©edI
.
asUIÁ
(),

863 
ab¡¿ùG’”©edS
.
asUIÁ
()),

864 
nİ
.
asUIÁ
()

866 
ab¡¿ùG’”©edMem
(1è:ğ
Mux
(
acûssRegi¡”CommªdReg
.
po¡exec
,

867 
nİ
.
asUIÁ
(),

868 
In¡ruùiÚs
.
EBREAK
.
v®ue
.
U
)

874 ià(
	gÃedCu¡om
) {

875 
v®
 (
cu¡om
, 
cu¡omP
èğ
cu¡omNode
.
š
.
h—d


876 
cu¡om
.
addr
 :ğ
acûssRegi¡”CommªdReg
.
»gno


877 
cu¡om
.
v®id
 :ğ
goCu¡om


883 
Node
.
»gm­
(

885 
HALTED
 -> 
Seq
(
WNÙifyWœe
(
sbIdWidth
, 
h¬tH®‹dId
, 
h¬tH®‹dWrEn
,

887 
GOING
 -> 
Seq
(
WNÙifyWœe
(
sbIdWidth
, 
h¬tGošgId
, 
h¬tGošgWrEn
,

889 
RESUMING
 -> 
Seq
(
WNÙifyWœe
(
sbIdWidth
, 
h¬tResumšgId
, 
h¬tResumšgWrEn
,

891 
EXCEPTION
 -> 
Seq
(
WNÙifyWœe
(
sbIdWidth
, 
h¬tExû±iÚId
, 
h¬tExû±iÚWrEn
,

893 
DATA
 -> 
RegF›ldGroup
("debug_d©a", 
Some
("Data usedo communicate with Debug Module"),

894 
ab¡¿ùD©aMem
.
zW™hIndex
.
m­
 {(
x
, 
i
è=> 
RegF›ld
(8, x, 
RegF›ldDesc
(
s
"debug_data_$i", ""))}),

895 
PROGBUF
(
cfg
)-> 
RegF›ldGroup
("debug_´ogbuf", 
Some
("Program buffer usedo communicate with Debug Module"),

896 
´og¿mBufãrMem
.
zW™hIndex
.
m­
 {(
x
, 
i
è=> 
RegF›ld
(8, x, 
RegF›ldDesc
(
s
"debug_progbuf_$i", ""))}),

899 
IMPEBREAK
(
cfg
)-> {ià(cfg.
hasIm¶ic™Eb»ak
è
Seq
(
RegF›ld
.
r
(32, 
In¡ruùiÚs
.
EBREAK
.
v®ue
.
U
,

900 
RegF›ldDesc
("debug_im³b»ak", "Debug Im¶ic™ EBREAK", 
»£t
=
Some
(
In¡ruùiÚs
.
EBREAK
.
v®ue
)))è
N
},

901 
WHERETO
 -> 
Seq
(
RegF›ld
.
r
(32, 
j®Ab¡¿ù
.
asUIÁ
, 
RegF›ldDesc
("debug_wh”‘o", "In¡ruùiÚ fËd iÀby Debug ModuËØcÚŒŞ h¬ˆš Debug Mode", vŞ©ğ
Œue
))),

902 
ABSTRACT
(
cfg
è-> 
RegF›ldGroup
("debug_ab¡¿ù", 
Some
("Instructions generated by Debug Module"),

903 
ab¡¿ùG’”©edMem
.
zW™hIndex
.
m­
{ (
x
,
i
è=> 
RegF›ld
.
r
(32, x, 
RegF›ldDesc
(
s
"debug_ab¡¿ù_$i", "", vŞ©e=
Œue
))}),

904 
FLAGS
 -> 
RegF›ldGroup
("debug_æags", 
Some
("Memory„egion usedo control hart going/resuming in Debug Mode"),

905 
æags
.
zW™hIndex
.
m­
{(
x
, 
i
è=> 
RegF›ld
.
r
(8, x.
asUIÁ
(), 
RegF›ldDesc
(
s
"debug_æags_$i", "", vŞ©e=
Œue
))}),

906 
ROMBASE
 -> 
RegF›ldGroup
("debug_rom", 
Some
("Debug ROM"),

907 
DebugRomCÚ‹Ás
().
zW™hIndex
.
m­
{(
x
, 
i
è=> 
RegF›ld
.
r
(8, (x & 0xFF).
U
(8.
W
), 
RegF›ldDesc
(
s
"debug_rom_$i", "", 
»£t
=
Some
(x)))})

911 
wh’
 (~
io
.
dmaùive
){

912 
	gab¡¿ùD©aMem
.
	gfÜ—ch
 {
	gx
 => 
x
 := 0.U}

913 
´og¿mBufãrMem
.
fÜ—ch
 {
x
 => x := 0.U}

920 
objeù
 
CŒlS‹
 
ex‹nds
 
sÿÏ
.
Enum”©iÚ
 {

921 
ty³
 
CŒlS‹
 = 
V®ue


922 
v®
 
Wa™šg
, 
	gCheckG’”©e
, 
	gExec
, 
	gCu¡om
 = 
V®ue


924 
def
 
­¶y
Ğ
t
 : 
V®ue
è: 
UIÁ
 = {

925 
t
.
id
.
U
(
log2Up
(
v®ues
.
size
).
W
)

928 
impÜt
 
CŒlS‹
.
_


931 
v®
 
ù¾S‹Reg
 = 
Reg
(
CŒlS‹
(
Wa™šg
))

933 
v®
 
h¬tH®‹d
 = 
h®‹dB™Regs
(
£ËùedH¬tReg
)

934 
v®
 
ù¾S‹Nxt
 = 
Wœe
(
š™
 = 
ù¾S‹Reg
)

939 
ab¡¿ùCommªdBusy
 :ğ(
ù¾S‹Reg
 =/ğ
CŒlS‹
(
Wa™šg
))

941 
ABSTRACTCSWrEnLeg®
 :ğ(
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Wa™šg
))

942 
COMMANDWrEnLeg®
 :ğ(
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Wa™šg
))

943 
ABSTRACTAUTOWrEnLeg®
 :ğ(
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Wa™šg
))

944 
dmiAb¡¿ùD©aAcûssLeg®
 :ğ(
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Wa™šg
))

945 
dmiProg¿mBufãrAcûssLeg®
 :ğ(
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Wa™šg
))

947 
”rÜBusy
 :ğ(
ABSTRACTCSWrEnMaybe
 && ~
ABSTRACTCSWrEnLeg®
) ||

948 (
ABSTRACTAUTOWrEnMaybe
 && ~
ABSTRACTAUTOWrEnLeg®
) ||

949 (
COMMANDWrEnMaybe
 && ~
COMMANDWrEnLeg®
) ||

950 (
dmiAb¡¿ùD©aAcûss
 && ~
dmiAb¡¿ùD©aAcûssLeg®
) ||

951 (
dmiProg¿mBufãrAcûss
 && ~
dmiProg¿mBufãrAcûssLeg®
)

954 
v®
 
commªdWrIsAcûssRegi¡”
 = (
COMMANDWrD©a
.
cmdty³
 ==ğ
DebugAb¡¿ùCommªdTy³
.
AcûssRegi¡”
.
id
.
U
)

955 
v®
 
commªdRegIsAcûssRegi¡”
 = (
COMMANDReg
.
cmdty³
 ==ğ
DebugAb¡¿ùCommªdTy³
.
AcûssRegi¡”
.
id
.
U
)

957 
v®
 
commªdWrIsUnsuµÜ‹d
 = 
COMMANDWrEn
 && !
commªdWrIsAcûssRegi¡”
;

959 
v®
 
	gcommªdRegIsUnsuµÜ‹d
 = 
Wœe
(
š™
 = 
Œue
.
B
)

960 
v®
 
commªdRegBadH®tResume
 = 
Wœe
(
š™
 = 
çl£
.
B
)

963 
v®
 
acûssRegIsGPR
 = (
acûssRegi¡”CommªdReg
.
»gno
 >= 0x1000.U &&‡ccessRegisterCommandReg.regno <= 0x101F.U)

964 
v®
 
acûssRegIsCu¡om
 = ià(
ÃedCu¡om
) {

965 
v®
 (
cu¡om
, 
cu¡omP
èğ
cu¡omNode
.
š
.
h—d


966 
cu¡omP
.
addrs
.
fŞdLeá
(
çl£
.
B
){

967 (
»suÉ
, 
cu¼’t
è=>„esuÉ || (cu¼’t.
U
 ==ğ
acûssRegi¡”CommªdReg
.
»gno
)}

968 } 
	gçl£
.
B


970 
wh’
 (
commªdRegIsAcûssRegi¡”
) {

971 
wh’
 (
acûssRegIsCu¡om
 && 
acûssRegi¡”CommªdReg
.
Œªsãr
 &&‡cûssRegi¡”CommªdReg.
wr™e
 ==ğ
çl£
.
B
) {

972 
commªdRegIsUnsuµÜ‹d
 :ğ
çl£
.
B


973 }.
–£wh’
 (!
acûssRegi¡”CommªdReg
.
Œªsãr
 || 
acûssRegIsGPR
) {

974 
commªdRegIsUnsuµÜ‹d
 :ğ
çl£
.
B


975 
commªdRegBadH®tResume
 :ğ~
h¬tH®‹d


979 
v®
 
wrAcûssRegi¡”Commªd
 = 
COMMANDWrEn
 && 
commªdWrIsAcûssRegi¡”
 && (
ABSTRACTCSReg
.
cmd”r
 === 0.U)

980 
v®
 
»gAcûssRegi¡”Commªd
 = 
autÛxec
 && 
commªdRegIsAcûssRegi¡”
 && (
ABSTRACTCSReg
.
cmd”r
 === 0.U)

986 
wh’
 (
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Wa™šg
)){

987 
wh’
 (
wrAcûssRegi¡”Commªd
 || 
»gAcûssRegi¡”Commªd
) {

988 
ù¾S‹Nxt
 :ğ
CŒlS‹
(
CheckG’”©e
)

989 }.
–£wh’
 (
commªdWrIsUnsuµÜ‹d
) {

990 
”rÜUnsuµÜ‹d
 :ğ
Œue
.
B


991 }.
–£wh’
 (
autÛxec
 && 
commªdRegIsUnsuµÜ‹d
) {

992 
”rÜUnsuµÜ‹d
 :ğ
Œue
.
B


994 }.
–£wh’
 (
ù¾S‹Reg
 ==ğ
CŒlS‹
(
CheckG’”©e
)){

1001 
wh’
 (
commªdRegIsUnsuµÜ‹d
) {

1002 
”rÜUnsuµÜ‹d
 :ğ
Œue
.
B


1003 
ù¾S‹Nxt
 :ğ
CŒlS‹
(
Wa™šg
)

1004 }.
–£wh’
 (
commªdRegBadH®tResume
){

1005 
”rÜH®tResume
 :ğ
Œue
.
B


1006 
ù¾S‹Nxt
 :ğ
CŒlS‹
(
Wa™šg
)

1007 }.
Ùh”wi£
 {

1008 
wh’
(
acûssRegIsCu¡om
) {

1009 
ù¾S‹Nxt
 :ğ
CŒlS‹
(
Cu¡om
)

1010 }.
Ùh”wi£
 {

1011 
ù¾S‹Nxt
 :ğ
CŒlS‹
(
Exec
)

1012 
goAb¡¿ù
 :ğ
Œue
.
B


1015 }.
–£wh’
 (
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Exec
)) {

1020 
wh’
(
goReg
 ==ğ
çl£
.
B
 && 
h¬tH®‹dWrEn
 && (
h¬tS–Funcs
.
h¬tIdToH¬tS–
(
h¬tH®‹dId
è==ğ
£ËùedH¬tReg
)){

1021 
ù¾S‹Nxt
 :ğ
CŒlS‹
(
Wa™šg
)

1023 
wh’
(
h¬tExû±iÚWrEn
) {

1024 
as£¹
(
h¬tExû±iÚId
 === 0.U, "Unexpected 'EXCEPTION' hart")

1025 
	gù¾S‹Nxt
 :ğ
CŒlS‹
(
Wa™šg
)

1026 
”rÜExû±iÚ
 :ğ
Œue
.
B


1028 }.
–£wh’
 (
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Cu¡om
)) {

1029 
as£¹
(
ÃedCu¡om
.
B
, "Should‚ot be in custom state unless we‚eed it.")

1030 
goCu¡om
 :ğ
Œue
.
B


1031 
v®
 (
cu¡om
, 
cu¡omP
èğ
cu¡omNode
.
š
.
h—d


1032 
wh’
 (
cu¡om
.
»ady
 && cu¡om.
v®id
) {

1033 
ù¾S‹Nxt
 :ğ
CŒlS‹
(
Wa™šg
)

1037 
wh’
 (~
io
.
dmaùive
) {

1038 
ù¾S‹Reg
 :ğ
CŒlS‹
(
Wa™šg
)

1039 }.
Ùh”wi£
 {

1040 
ù¾S‹Reg
 :ğ
ù¾S‹Nxt


1042 
as£¹
 ((!
h¬tExû±iÚWrEn
 || 
ù¾S‹Reg
 ==ğ
CŒlS‹
(
Exec
)),

1051 
şass
 
TLDebugModuËIÂ”Async
(
deviû
: 
Deviû
, 
g‘NCompÚ’ts
: (è=> 
IÁ
, 
b—tBy‹s
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
{

1053 
v®
 
dmIÂ”
 = 
LazyModuË
(
Ãw
 
TLDebugModuËIÂ”
(
deviû
, 
g‘NCompÚ’ts
, 
b—tBy‹s
))

1054 
v®
 
	gdmiXšg
 = 
LazyModuË
(
Ãw
 
TLAsyncCrossšgSšk
(
AsyncQueueP¬ams
.
sšgËtÚ
()))

1055 
v®
 
dmiNode
 = 
dmiXšg
.
node


1056 
v®
 
Node
 = 
dmIÂ”
.tlNode

1058 
dmIÂ”
.
dmiNode
 :ğ
dmiXšg
.
node


1060 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

1062 
v®
 
io
 = 
IO
(
Ãw
 
BundË
 {

1064 
v®
 
dmaùive
 = 
BoŞ
(
INPUT
)

1065 
v®
 
šÃrCŒl
 = 
Ãw
 
AsyncBundË
Òew 
DebugIÁ”ÇlBundË
(), 
AsyncQueueP¬ams
.
sšgËtÚ
()).
æ


1067 
v®
 
debugUÇva
 = 
Vec
(
g‘NCompÚ’ts
(), 
BoŞ
()).
asIÅut


1068 
v®
 
psd
 = 
Ãw
 
PSDTe¡Mode
().
asIÅut


1071 
	gdmIÂ”
.
	gmoduË
.
	gio
.
	gšÃrCŒl
 :ğ
FromAsyncBundË
(
io
.
šÃrCŒl
)

1072 
dmIÂ”
.
moduË
.
io
.
dmaùive
 :ğ~
Re£tC©chAndSync
(
şock
, ~io.dmaùive, "dmaùiveSync", io.
psd
)

1073 
	gdmIÂ”
.
	gmoduË
.
	gio
.
	gdebugUÇva
 :ğ
io
.
debugUÇva


1082 şas 
	cTLDebugModuË
(
b—tBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

1084 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("debug-cÚŒŞËr", 
	`Seq
("sifive,debug-013","riscv,debug-013")){

1085 
ov”ride
 
v®
 
®waysEx‹nded
 = 
Œue


1088 
v®
 
dmOu‹r
 = 
	`LazyModuË
(
Ãw
 
	$TLDebugModuËOu‹rAsync
(
deviû
)(
p
))

1089 
v®
 
dmIÂ”
 = 
	`LazyModuË
(
Ãw
 
	`TLDebugModuËIÂ”Async
(
deviû
, (è=> {
dmOu‹r
.dmOu‹r.
šŠode
.
edges
.
out
.
size
}, b—tBy‹s)Õ))

1091 
v®
 
	gnode
 = 
dmIÂ”
.
Node


1092 
v®
 
šŠode
 = 
dmOu‹r
.intnode

1094 
dmIÂ”
.
dmiNode
 :ğ
dmOu‹r
.
dmiIÂ”Node


1096 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

1097 
v®
 
nCompÚ’ts
 = 
dmOu‹r
.dmOu‹r.
šŠode
.
edges
.
out
.
size


1099 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

1100 
v®
 
ù¾
 = 
Ãw
 
	`DebugCŒlBundË
(
nCompÚ’ts
)

1101 
v®
 
dmi
 = 
Ãw
 
	`ClockedDMIIO
().
æ


1102 
v®
 
psd
 = 
Ãw
 
	`PSDTe¡Mode
().
asIÅut


1105 
dmOu‹r
.
moduË
.
io
.
dmi
 <> io.dmi.dmi

1106 
dmOu‹r
.
moduË
.
»£t
 :ğ
io
.
dmi
.
dmiRe£t


1107 
dmOu‹r
.
moduË
.
şock
 :ğ
io
.
dmi
.
dmiClock


1109 
dmIÂ”
.
moduË
.
io
.
šÃrCŒl
 :ğ
dmOu‹r
.module.io.innerCtrl

1110 
dmIÂ”
.
moduË
.
io
.
dmaùive
 :ğ
dmOu‹r
.moduË.io.
ù¾
.dmactive

1111 
dmIÂ”
.
moduË
.
io
.
debugUÇva
 :ğio.
ù¾
.debugUnavail

1113 
dmIÂ”
.
moduË
.
io
.
psd
 <> io.psd

1115 
io
.
ù¾
 <> 
dmOu‹r
.
moduË
.io.ctrl

1117 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugRomContents.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


5 
objeù
 
	gDebugRomCÚ‹Ás
 {

7 
def
 
­¶y
(è: 
A¼ay
[
By‹
] = { Array (

15 ).
m­
(
_
.
toBy‹
) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugTransport.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gjg
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


12 
şass
 
	$JgDTMCÚfig
 (

13 
idcodeV”siÚ
 : 
IÁ
,

14 
idcodeP¬tNum
 : 
IÁ
,

15 
idcodeMªufId
 : 
IÁ
,

21 
debugIdËCyşes
 : 
IÁ
)

23 
objeù
 
JgDTMKey
 
ex‹nds
 
F›ld
[
JgDTMCÚfig
](
Ãw
 
	$JgDTMKeyDeçuÉ
())

25 
şass
 
JgDTMKeyDeçuÉ
 
ex‹nds
 
	$JgDTMCÚfig
(

26 
idcodeV”siÚ
 = 0,

27 
idcodeP¬tNum
 = 0,

28 
idcodeMªufId
 = 0,

29 
debugIdËCyşes
 = 5)

31 
objeù
 
dtmJTAGAddrs
 {

32 
def
 
IDCODE
 = 0x1

33 
def
 
DTM_INFO
 = 0x10

34 
def
 
DMI_ACCESS
 = 0x11

35 
	}
}

37 şas 
	cDMIAcûssUpd©e
(
addrB™s
: 
IÁ
è
ex‹nds
 
BundË
 {

38 
v®
 
addr
 = 
	$UIÁ
(
width
 = 
addrB™s
)

39 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
DMICÚ¡s
.
dmiD©aSize
)

40 
v®
 
İ
 = 
	$UIÁ
(
width
 = 
DMICÚ¡s
.
dmiOpSize
)

42 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`DMIAcûssUpd©e
(
addrB™s
).
asIn¡ªûOf
[
this
.
ty³
]

45 şas 
	cDMIAcûssC­tu»
(
addrB™s
: 
IÁ
è
ex‹nds
 
BundË
 {

46 
v®
 
addr
 = 
	$UIÁ
(
width
 = 
addrB™s
)

47 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
DMICÚ¡s
.
dmiD©aSize
)

48 
v®
 
»¥
 = 
	$UIÁ
(
width
 = 
DMICÚ¡s
.
dmiRe¥Size
)

50 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`DMIAcûssC­tu»
(
addrB™s
).
asIn¡ªûOf
[
this
.
ty³
]

54 şas 
	cDTMInfo
 
ex‹nds
 
BundË
 {

55 
v®
 
»£rved1
 = 
	$UIÁ
(15.
W
)

56 
v®
 
dmœe£t
 = 
	$BoŞ
()

57 
v®
 
»£rved0
 = 
	$UIÁ
(1.
W
)

58 
v®
 
dmiIdËCyşes
 = 
	$UIÁ
(3.
W
)

59 
v®
 
dmiStus
 = 
	$UIÁ
(2.
W
)

60 
v®
 
debugAddrB™s
 = 
	$UIÁ
(6.
W
)

61 
v®
 
debugV”siÚ
 = 
	`UIÁ
(4.
W
)

65 şas 
	cSy¡emJTAGIO
 
ex‹nds
 
BundË
 {

66 
v®
 
jg
 = 
Ãw
 
	`JTAGIO
(
hasTRSTn
 = 
çl£
).
æ


67 
v®
 
»£t
 = 
	$BoŞ
(
INPUT
)

68 
v®
 
mä_id
 = 
	`UIÁ
(
INPUT
, 11)

71 
şass
 
	$DebugT¿n¥ÜtModuËJTAG
(
debugAddrB™s
: 
IÁ
, 
c
: 
JgDTMCÚfig
)

72 (
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

74 
v®
 
io
 = 
Ãw
 
BundË
 {

75 
v®
 
dmi
 = 
Ãw
 
	`DMIIO
()(
p
)

76 
v®
 
jg
 = 
	`Fl³d
(
Ãw
 
	`JTAGIO
(
hasTRSTn
 = 
çl£
))

77 
v®
 
jg_»£t
 = 
	`BoŞ
(
INPUT
)

78 
v®
 
jg_mä_id
 = 
	`UIÁ
(
INPUT
, 11)

79 
v®
 
fsmRe£t
 = 
	`BoŞ
(
OUTPUT
)

85 
v®
 
dtmInfo
 = 
	`Wœe
(
Ãw
 
DTMInfo
)

87 
v®
 
busyReg
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

88 
v®
 
¡ickyBusyReg
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

89 
v®
 
¡ickyNÚz”oRe¥Reg
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

91 
v®
 
skOpReg
 = 
	`Reg
(
š™
 = 
	`BoŞ
(
çl£
))

92 
v®
 
downg¿deOpReg
 = 
	`Reg
(
š™
 = 
	`BoŞ
(
çl£
))

94 
v®
 
busy
 = 
	`Wœe
(
	`BoŞ
())

95 
v®
 
nÚz”oRe¥
 = 
	`Wœe
(
	`BoŞ
())

97 
v®
 
busyRe¥
 = 
	`Wœe
(
Ãw
 
	`DMIAcûssC­tu»
(
debugAddrB™s
))

98 
v®
 
nÚbusyRe¥
 = 
	`Wœe
(
Ãw
 
	`DMIAcûssC­tu»
(
debugAddrB™s
))

99 
v®
 
dmiRe¥
 = 
	`Wœe
(
Ãw
 
	`DMIAcûssC­tu»
(
debugAddrB™s
))

100 
v®
 
nİRe¥
 = 
	`Wœe
(
Ãw
 
	`DMIAcûssC­tu»
(
debugAddrB™s
))

103 
v®
 
dmiReqReg
 = 
	`Reg
(
Ãw
 
	`DMIReq
(
debugAddrB™s
))

104 
v®
 
dmiReqV®idReg
 = 
	`Reg
(
š™
 = 
	`BoŞ
(
çl£
));

106 
v®
 
dmiStus
 = 
	`Wœe
(
	`UIÁ
(
width
 = 2))

111 
dmiStus
 :ğ
	`C©
(
¡ickyNÚz”oRe¥Reg
, stickyNÚz”oRe¥Reg | 
¡ickyBusyReg
)

113 
dtmInfo
.
debugV”siÚ
 := 1.U

114 
dtmInfo
.
debugAddrB™s
 :ğ
	`UIÁ
(debugAddrBits)

115 
dtmInfo
.
dmiStus
 := dmiStatus

116 
dtmInfo
.
dmiIdËCyşes
 :ğ
	`UIÁ
(
c
.
debugIdËCyşes
)

117 
dtmInfo
.
»£rved0
 := 0.U

118 
dtmInfo
.
dmœe£t
 :ğ
çl£
.
B


119 
dtmInfo
.
»£rved1
 := 0.U

121 
v®
 
dtmInfoChaš
 = 
	`ModuË
 (
	`C­tu»Upd©eChaš
(
g’
 = 
Ãw
 
	`DTMInfo
()))

122 
dtmInfoChaš
.
io
.
ÿ±u»
.
b™s
 :ğ
dtmInfo


127 
v®
 
dmiAcûssChaš
 = 
	`ModuË
(
	`C­tu»Upd©eChaš
(
g’C­tu»
 = 
Ãw
 
	`DMIAcûssC­tu»
(
debugAddrB™s
),

128 
g’Upd©e
 = 
Ãw
 
	`DMIAcûssUpd©e
(
debugAddrB™s
)))

136 
	`wh’
 (
io
.
dmi
.
»q
.
v®id
) {

137 
busyReg
 :ğ
	`BoŞ
(
Œue
)

139 
	`wh’
 (
io
.
dmi
.
»¥
.
	`fœe
()) {

140 
busyReg
 :ğ
	`BoŞ
(
çl£
)

148 
busy
 :ğ(
busyReg
 & !
io
.
dmi
.
»¥
.
v®id
è| 
¡ickyBusyReg
;

153 
	`wh’
 (
dmiAcûssChaš
.
io
.
upd©e
.
v®id
) {

154 
skOpReg
 :ğ
	`BoŞ
(
çl£
)

155 
downg¿deOpReg
 :ğ
	`BoŞ
(
çl£
)

157 
	`wh’
 (
dmiAcûssChaš
.
io
.
ÿ±u»
.capture) {

158 
skOpReg
 :ğ
busy


159 
downg¿deOpReg
 :ğ(!
busy
 & 
nÚz”oRe¥
)

160 
¡ickyBusyReg
 :ğ
busy


161 
¡ickyNÚz”oRe¥Reg
 :ğ
nÚz”oRe¥


163 
	`wh’
 (
dtmInfoChaš
.
io
.
upd©e
.
v®id
) {

164 
	`wh’
 (
dtmInfoChaš
.
io
.
upd©e
.
b™s
.
dmœe£t
) {

165 
¡ickyNÚz”oRe¥Reg
 :ğ
	`BoŞ
(
çl£
)

166 
¡ickyBusyReg
 :ğ
	`BoŞ
(
çl£
)

176 
nÚz”oRe¥
 :ğ
¡ickyNÚz”oRe¥Reg
 | (
io
.
dmi
.
»¥
.
v®id
 & (io.dmi.»¥.
b™s
.»¥ =/ğ
	`UIÁ
(0)))

177 
	`as£¹
(!
nÚz”oRe¥
, "There is‚o„easono get‡‚on zero„esponse inhe current system.");

178 
	`as£¹
(!
¡ickyNÚz”oRe¥Reg
, "There is‚o„easono have‡ sticky‚on zero„esponse inhe current system.");

180 
busyRe¥
.
addr
 :ğ
	`UIÁ
(0)

181 
busyRe¥
.
»¥
 :ğ
	`Fl
(
DMICÚ¡s
.
dmiRe¥Size
, 1.U)

182 
busyRe¥
.
d©a
 :ğ
	`UIÁ
(0)

184 
dmiRe¥
.
addr
 :ğ
dmiReqReg
.addr

185 
dmiRe¥
.
»¥
 :ğ
io
.
dmi
.»¥.
b™s
.resp

186 
dmiRe¥
.
d©a
 :ğ
io
.
dmi
.
»¥
.
b™s
.data

188 
nİRe¥
.
addr
 :ğ
	`UIÁ
(0)

189 
nİRe¥
.
»¥
 :ğ
	`UIÁ
(0)

190 
nİRe¥
.
d©a
 :ğ
	`UIÁ
(0)

195 
dmiAcûssChaš
.
io
.
ÿ±u»
.
b™s
 :ğ
	`Mux
(
busy
, 
busyRe¥
, Mux(io.
dmi
.
»¥
.
v®id
, 
dmiRe¥
, 
nİRe¥
))

196 
	`wh’
 (
dmiAcûssChaš
.
io
.
upd©e
.
v®id
) {

197 
skOpReg
 :ğ
	`BoŞ
(
çl£
)

198 
downg¿deOpReg
 :ğ
	`BoŞ
(
çl£
)

200 
	`wh’
 (
dmiAcûssChaš
.
io
.
ÿ±u»
.capture) {

201 
skOpReg
 :ğ
busy


202 
downg¿deOpReg
 :ğ(!
busy
 & 
nÚz”oRe¥
)

203 
¡ickyBusyReg
 :ğ
busy


204 
¡ickyNÚz”oRe¥Reg
 :ğ
nÚz”oRe¥


210 
v®
 
dmiReqV®idCheck
 = 
	`Wœe
(
š™
 = 
	`BoŞ
(
çl£
))

211 
	`as£¹
(!(
dmiReqV®idCheck
 && 
io
.
dmi
.
»q
.
	`fœe
()), "Conflicting updates for dmiReqValidReg, should‚ot happen.");

213 
	`wh’
 (
dmiAcûssChaš
.
io
.
upd©e
.
v®id
) {

214 
	`wh’
 (
skOpReg
) {

216 }.
	`–£wh’
 (
downg¿deOpReg
 || (
dmiAcûssChaš
.
io
.
upd©e
.
b™s
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_NONE
)) {

218 
dmiReqReg
.
addr
 :ğ
	`UIÁ
(0)

219 
dmiReqReg
.
d©a
 :ğ
	`UIÁ
(0)

220 
dmiReqReg
.
İ
 :ğ
	`UIÁ
(0)

221 }.
Ùh”wi£
 {

222 
dmiReqReg
 :ğ
dmiAcûssChaš
.
io
.
upd©e
.
b™s


223 
dmiReqV®idReg
 :ğ
	`BoŞ
(
Œue
)

224 
dmiReqV®idCheck
 :ğ
	`BoŞ
(
Œue
)

228 
	`wh’
 (
io
.
dmi
.
»q
.
	`fœe
()) {

229 
dmiReqV®idReg
 :ğ
	`BoŞ
(
çl£
)

232 
io
.
dmi
.
»¥
.
»ady
 :ğ
	`Mux
(

233 
dmiReqReg
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_WRITE
,

235 
io
.
dmi
.
»¥
.
v®id
,

237 
dmiAcûssChaš
.
io
.
ÿ±u»
.capture)

240 
	`cov”
(
dmiReqReg
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_WRITE
 & 
dmiAcûssChaš
.
io
.
ÿ±u»
.ÿ±u» & 
busy
, "Notƒnough Idle‡fter DMI Write");

242 
	`cov”
(
dmiReqReg
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_WRITE
 & 
dmiAcûssChaš
.
io
.
ÿ±u»
.ÿ±u» & !
busy
, "Enough Idle‡fter DMI Write");

245 
	`cov”
(
dmiReqReg
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_READ
 & 
dmiAcûssChaš
.
io
.
ÿ±u»
.ÿ±u» & 
busy
, "Notƒnough Idle‡fter DMI Read");

247 
	`cov”
(
dmiReqReg
.
İ
 ==ğ
DMICÚ¡s
.
dmi_OP_READ
 & 
dmiAcûssChaš
.
io
.
ÿ±u»
.ÿ±u» & !
busy
, "Enough Idle‡fter DMI Read");

249 
io
.
dmi
.
»q
.
v®id
 :ğ
dmiReqV®idReg


252 
io
.
dmi
.
»q
.
b™s
 :ğ
dmiReqReg


256 
v®
 
idcode
 = 
	`Wœe
(
š™
 = 
Ãw
 
	`JTAGIdcodeBundË
().
	`äomB™s
(0.U))

257 
idcode
.
®ways1
 := 1.U

258 
idcode
.
v”siÚ
 :ğ
c
.
idcodeV”siÚ
.
U


259 
idcode
.
·¹Numb”
 :ğ
c
.
idcodeP¬tNum
.
U


260 
idcode
.
mäId
 :ğ
io
.
jg_mä_id


262 
v®
 
pIO
 = 
	`JgT­G’”©Ü
(
œL’gth
 = 5,

263 
š¡ruùiÚs
 = 
	`M­
(

264 
dtmJTAGAddrs
.
DMI_ACCESS
 -> 
dmiAcûssChaš
,

265 
dtmJTAGAddrs
.
DTM_INFO
 -> 
dtmInfoChaš
),

266 
icode
 = 
	`Some
(
dtmJTAGAddrs
.
IDCODE
)

269 
pIO
.
idcode
.
g‘
 := idcode

270 
pIO
.
jg
 <> 
io
.jtag

272 
pIO
.
cÚŒŞ
.
jg_»£t
 :ğ
io
.jtag_reset

278 
io
.
fsmRe£t
 :ğ
pIO
.
ouut
.
»£t


280 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Periphery.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gcÜe
.{
	gIÁP¬am
, 
	gIÅut
, 
	gOuut
}

7 
impÜt
 
	gchi£l3
.
	gut
.
HasBÏckBoxResourû


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gjg
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


17 
objeù
 
InşudeJgDTM
 
ex‹nds
 
	gF›ld
[
BoŞ—n
](
	gçl£
)

21 şas 
	cDebugIO
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
è
w™h
 
CªHavePSDTe¡ModeIO
 {

22 
v®
 
şockeddmi
 = (!
	`p
(
InşudeJgDTM
)).
	`İtiÚ
(
Ãw
 
	`ClockedDMIIO
().
æ
)

23 
v®
 
sy¡emjg
 = (
	`p
(
InşudeJgDTM
)).
	$İtiÚ
(
Ãw
 
Sy¡emJTAGIO
)

24 
v®
 
nd»£t
 = 
	$BoŞ
(
OUTPUT
)

25 
v®
 
dmaùive
 = 
	`BoŞ
(
OUTPUT
)

31 
Œa™
 
HasP”h”yDebug
 { 
this
: 
Ba£Subsy¡em
 =>

32 
v®
 
debug
 = 
	`LazyModuË
(
Ãw
 
	`TLDebugModuË
(
sbus
.
cÚŒŞ_bus
.
b—tBy‹s
))

33 
sbus
.
cÚŒŞ_bus
.
	`toV¬ŸbËWidthSÏve
(
	`Some
("debug")){ 
debug
.
node
 }

34 
v®
 
debugCu¡omXb¬
 = 
	`LazyModuË
Ğ
Ãw
 
	`DebugCu¡omXb¬
(
ouutRequœesIÅut
 = 
çl£
))

35 
debug
.
dmIÂ”
.dmIÂ”.
cu¡omNode
 :ğ
debugCu¡omXb¬
.
node


37 
debug
.
dmIÂ”
.dmIÂ”.
sb2O±
.
fÜ—ch
 { 
sb2
 =>

38 
fbus
.
	`äomPÜt
(
	`Some
("debug_sb")){ 
FlR’d”šg
 { 
im¶ic™
 
p
 => 
	`TLWidthWidg‘
(1è:ğ
sb2
.
node
 } }

40 
	}
}

42 
Œa™
 
HasP”h”yDebugModuËImp
 
ex‹nds
 
LazyModuËImp
 {

43 
v®
 
ou‹r
: 
HasP”h”yDebug


45 
v®
 
debug
 = 
IO
(
Ãw
 
DebugIO
)

47 
debug
.
şockeddmi
.
fÜ—ch
 { 
dbg
 => 
ou‹r
.debug.
moduË
.
io
.
dmi
 <> dbg }

49 
v®
 
dtm
 = 
debug
.
sy¡emjg
.
m­
 { 
sj
 =>

51 
v®
 
dtm
 = 
ModuË
(
Ãw
 
DebugT¿n¥ÜtModuËJTAG
(
p
(
DebugModuËP¬ams
).
nDMIAddrSize
,…(
JgDTMKey
)))

52 
	gdtm
.
	gio
.
	gjg
 <> 
	gsj
.
jg


54 
	gdtm
.
	gşock
 :ğ
sj
.
jg
.
TCK


55 
dtm
.
io
.
jg_»£t
 :ğ
sj
.
»£t


56 
dtm
.
io
.
jg_mä_id
 :ğ
sj
.
mä_id


57 
dtm
.
»£t
 :ğdtm.
io
.
fsmRe£t


59 
ou‹r
.
debug
.
moduË
.
io
.
dmi
.dm˜<> 
dtm
.io.dmi

60 
ou‹r
.
debug
.
moduË
.
io
.
dmi
.
dmiClock
 :ğ
sj
.
jg
.
TCK


62 
v®
 
psd
 = 
debug
.psd.
g‘OrEl£
(
Wœe
(
Ãw
 
PSDTe¡Mode
).
äomB™s
(0.U))

63 
ou‹r
.
debug
.
moduË
.
io
.
psd
 <>…sd

64 
ou‹r
.
debug
.
moduË
.
io
.
dmi
.
dmiRe£t
 :ğ
Re£tC©chAndSync
(
sj
.
jg
.
TCK
, sj.
»£t
, "dmiRe£tC©ch", 
psd
)

65 
	gdtm


68 
	gdebug
.
	gnd»£t
 :ğ
ou‹r
.
debug
.
moduË
.
io
.
ù¾
.
nd»£t


69 
debug
.
dmaùive
 :ğ
ou‹r
.debug.
moduË
.
io
.
ù¾
.dmactive

72 
ou‹r
.
debug
.
moduË
.
io
.
ù¾
.
debugUÇva
.
fÜ—ch
 { 
_
 :ğ
BoŞ
(
çl£
) }

75 şas 
	cSimDTM
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
BÏckBox
 
w™h
 
HasBÏckBoxResourû
 {

76 
v®
 
io
 = 
Ãw
 
BundË
 {

77 
v®
 
şk
 = 
	`Clock
(
INPUT
)

78 
v®
 
»£t
 = 
	`BoŞ
(
INPUT
)

79 
v®
 
debug
 = 
Ãw
 
DMIIO


80 
v®
 
ex™
 = 
	`UIÁ
(
OUTPUT
, 32)

83 
def
 
	`cÚÃù
(
tbşk
: 
Clock
, 
tb»£t
: 
BoŞ
, 
dutio
: 
ClockedDMIIO
, 
tbsucûss
: Bool) = {

84 
io
.
şk
 :ğ
tbşk


85 
io
.
»£t
 :ğ
tb»£t


86 
dutio
.
dmi
 <> 
io
.
debug


87 
dutio
.
dmiClock
 :ğ
tbşk


88 
dutio
.
dmiRe£t
 :ğ
tb»£t


90 
tbsucûss
 :ğ
io
.
ex™
 ==ğ
	`UIÁ
(1)

91 
	`wh’
 (
io
.
ex™
 >ğ
	`UIÁ
(2)) {

92 
	`´štf
("*** FAILED *** (ex™ codğ%d)\n", 
io
.
ex™
 >> 
	`UIÁ
(1))

93 
	`¡İ
(1)

95 
	}
}

97 
£tResourû
("/vsrc/SimDTM.v")

98 
£tResourû
("/csrc/SimDTM.cc")

101 
şass
 
	$SimJTAG
(
tickD–ay
: 
IÁ
 = 50è
ex‹nds
 
	`BÏckBox
(
	`M­
("TICK_DELAY" -> 
	$IÁP¬am
(
tickD–ay
)))

102 
w™h
 
HasBÏckBoxResourû
 {

103 
v®
 
io
 = 
Ãw
 
BundË
 {

104 
v®
 
şock
 = 
	`Clock
(
INPUT
)

105 
v®
 
»£t
 = 
	`BoŞ
(
INPUT
)

106 
v®
 
jg
 = 
Ãw
 
	`JTAGIO
(
hasTRSTn
 = 
Œue
)

107 
v®
 
’abË
 = 
	`BoŞ
(
INPUT
)

108 
v®
 
š™_dÚe
 = 
	`BoŞ
(
INPUT
)

109 
v®
 
ex™
 = 
	`UIÁ
(
OUTPUT
, 32)

112 
def
 
	`cÚÃù
(
dutio
: 
JTAGIO
, 
tbşock
: 
Clock
, 
tb»£t
: 
BoŞ
, 
š™_dÚe
: BoŞ, 
tbsucûss
: Bool) = {

113 
dutio
 <> 
io
.
jg


115 
io
.
şock
 :ğ
tbşock


116 
io
.
»£t
 :ğ
tb»£t


118 
io
.
’abË
 :ğ
	`PlusArg
("jtag_rbb_enable", 0, "Enable SimJTAG for JTAG Connections. Simulation will…ause until connection is made.")

119 
io
.
š™_dÚe
 := init_done

123 
tbsucûss
 :ğ
io
.
ex™
 ==ğ
	`UIÁ
(1)

124 
	`wh’
 (
io
.
ex™
 >ğ
	`UIÁ
(2)) {

125 
	`´štf
("*** FAILED *** (ex™ codğ%d)\n", 
io
.
ex™
 >> 
	`UIÁ
(1))

126 
	`¡İ
(1)

130 
	`£tResourû
("/vsrc/SimJTAG.v")

131 
	`£tResourû
("/csrc/SimJTAG.cc")

132 
	`£tResourû
("/csrc/remote_bitbang.h")

133 
	`£tResourû
("/csrc/remote_bitbang.cc")

134 
	}
}

136 
objeù
 
	gDebug
 {

137 
def
 
cÚÃùDebug
(

138 
debug
: 
DebugIO
,

139 
c
: 
Clock
,

140 
r
: 
BoŞ
,

141 
out
: 
BoŞ
,

142 
tckH®fP”iod
: 
IÁ
 = 2,

143 
cmdD–ay
: 
IÁ
 = 2,

144 
psd
: 
PSDTe¡Mode
 = 
Ãw
 PSDTe¡Mode().
äomB™s
(0.U))

145 (
im¶ic™
 
p
: 
P¬am‘”s
): 
Un™
 = {

146 
debug
.
şockeddmi
.
fÜ—ch
 { 
d
 =>

147 
v®
 
dtm
 = 
ModuË
(
Ãw
 
SimDTM
).
cÚÃù
(
c
, 
r
, 
d
, 
out
)

149 
	gdebug
.
	gsy¡emjg
.
	gfÜ—ch
 { 
	gsj
 =>

150 
v®
 
jg
 = 
ModuË
(
Ãw
 
SimJTAG
(
tickD–ay
=3)).
cÚÃù
(
sj
.jg, 
c
, 
r
, ~r, 
out
)

151 
	gsj
.
	g»£t
 :ğ
r


152 
sj
.
mä_id
 :ğ
p
(
JgDTMKey
).
idcodeMªufId
.
U
(11.
W
)

154 
debug
.
psd
.
fÜ—ch
 { 
_
 <>…sd }

157 
def
 
t›offDebug
(
debug
: 
DebugIO
): 
BoŞ
 = {

158 
debug
.
sy¡emjg
.
fÜ—ch
 { 
sj
 =>

159 
sj
.
jg
.
TCK
 :ğ
BoŞ
(
Œue
).
asClock


160 
sj
.
jg
.
TMS
 :ğ
BoŞ
(
Œue
)

161 
sj
.
jg
.
TDI
 :ğ
BoŞ
(
Œue
)

162 
sj
.
jg
.
TRSTn
.
fÜ—ch
 { 
r
 =>„ :ğ
BoŞ
(
Œue
) }

163 
sj
.
»£t
 :ğ
BoŞ
(
Œue
)

164 
sj
.
mä_id
 := 0.U

167 
debug
.
şockeddmi
.
fÜ—ch
 { 
d
 =>

168 
d
.
dmi
.
»q
.
v®id
 :ğ
BoŞ
(
çl£
)

169 
d
.
dmi
.
»¥
.
»ady
 :ğ
BoŞ
(
Œue
)

170 
d
.
dmiClock
 :ğ
BoŞ
(
çl£
).
asClock


171 
d
.
dmiRe£t
 :ğ
BoŞ
(
Œue
)

173 
debug
.
psd
.
fÜ—ch
 { 
_
 <> 
Ãw
 
PSDTe¡Mode
().
äomB™s
(0.U)}

174 
debug
.
nd»£t


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/SBA.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.
sy¡embu§cûss


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.
_


14 
objeù
 
Sy¡emBusAcûssS‹
 
ex‹nds
 
	gsÿÏ
.
	gEnum”©iÚ
 {

15 
ty³
 
	gSy¡emBusAcûssS‹
 = 
V®ue


16 
v®
 
IdË
, 
	gSBR—dReque¡
, 
	gSBWr™eReque¡
, 
	gSBR—dRe¥Ú£
, 
	gSBWr™eRe¥Ú£
 = 
V®ue


18 
impÜt
 
	gSy¡emBusAcûssS‹
.
_


20 
objeù
 
SBE¼ÜCode
 
ex‹nds
 
	gsÿÏ
.
	gEnum”©iÚ
 {

21 
ty³
 
	gSBE¼ÜCode
 = 
V®ue


22 
v®
 
NoE¼Ü
 = 
V®ue
(0)

23 
v®
 
Timeout
 = 
V®ue
(1)

24 
v®
 
BadAddr
 = 
V®ue
(2)

25 
v®
 
AlgnE¼Ü
 = 
V®ue
(3)

26 
v®
 
BadAcûss
 = 
V®ue
(4)

27 
v®
 
Oth”E¼Ü
 = 
V®ue
(7)

29 
impÜt
 
	gSBE¼ÜCode
.
_


31 
objeù
 
	gSy¡emBusAcûssModuË


33 
def
 
­¶y
(
sb2
: 
SBToTL
, 
dmaùive
: 
BoŞ
)(
im¶ic™
 
p
: 
P¬am‘”s
):

34 (
Seq
[
RegF›ld
], 
	gSeq
[Seq[RegField]], Seq[Seq[RegField]]) =

36 
impÜt
 
SBE¼ÜCode
.
_


37 
impÜt
 
DMI_RegAddrs
.
_


39 
v®
 
cfg
 = 
p
(
DebugModuËP¬ams
)

41 
v®
 
ªyAdd»ssWrEn
 = 
Wœe
(
š™
 = 
çl£
.
B
).
sugge¡Name
("anyAddressWrEn")

42 
v®
 
ªyD©aRdEn
 = 
Wœe
(
š™
 = 
çl£
.
B
).
sugge¡Name
("anyDataRdEn")

43 
v®
 
ªyD©aWrEn
 = 
Wœe
(
š™
 = 
çl£
.
B
).
sugge¡Name
("anyDataWrEn")

46 
v®
 
SBCSF›ldsReg
 = 
Reg
(
Ãw
 
SBCSF›lds
()).
sugge¡Name
("SBCSFieldsReg")

48 
v®
 
SBCSF›ldsRegRe£t
 = 
Wœe
(
š™
 = (
Ãw
 
SBCSF›lds
()).
äomB™s
(0.U))

49 
SBCSF›ldsRegRe£t
.
sbv”siÚ
 :ğ1.U(1.
W
)

50 
SBCSF›ldsRegRe£t
.
sbbusy
 :ğ(
sb2
.
moduË
.
io
.
sbS‹Out
 =/ğ
Sy¡emBusAcûssS‹
.
IdË
.
id
.
U
)

51 
SBCSF›ldsRegRe£t
.
sbasize
 :ğ
sb2
.
moduË
.
edge
.
bundË
.
add»ssB™s
.
U


52 
SBCSF›ldsRegRe£t
.
sbacûss128
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 =ğ128).
B


53 
SBCSF›ldsRegRe£t
.
sbacûss64
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ64).
B


54 
SBCSF›ldsRegRe£t
.
sbacûss32
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ32).
B


55 
SBCSF›ldsRegRe£t
.
sbacûss16
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ16).
B


56 
SBCSF›ldsRegRe£t
.
sbacûss8
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ8).
B


58 
v®
 
SBCSRdD©a
 = 
Wœe
(
š™
 = 
Ãw
 
SBCSF›lds
().
äomB™s
(0.U)).
sugge¡Name
("SBCSRdData")

60 
v®
 
SBCSWrD©aV®
 = 
Wœe
(
š™
 = 0.U(32.
W
))

61 
v®
 
SBCSWrD©a
 = 
Wœe
(
š™
 = 
Ãw
 
SBCSF›lds
().
äomB™s
(
SBCSWrD©aV®
))

63 
v®
 
SBCSRdEn
, 
	gSBCSWrEn
 = 
Wœe
(
š™
 = 
çl£
.
B
)

64 
SBCSWrEn
.
sugge¡Name
("SBCSWrEn")

65 
SBCSRdEn
.
sugge¡Name
("SBCSRdEn")

67 
v®
 
sbcsf›lds
 = 
Seq
(
RWNÙify
(32, 
SBCSRdD©a
.
asUIÁ
(), 
SBCSWrD©aV®
, 
SBCSRdEn
, 
SBCSWrEn
,

68 
Some
(
RegF›ldDesc
("dmi_sbcs", ""))))

73 
v®
 
	ghasSBAddr1
 = (
sb2
.
moduË
.
edge
.
bundË
.
add»ssB™s
 >= 33)

74 
v®
 
hasSBAddr2
 = (
sb2
.
moduË
.
edge
.
bundË
.
add»ssB™s
 >= 65)

75 
v®
 
hasSBAddr3
 = (
sb2
.
moduË
.
edge
.
bundË
.
add»ssB™s
 >= 97)

76 
v®
 
hasAddr
 = 
Seq
(
Œue
, 
hasSBAddr1
, 
hasSBAddr2
, 
hasSBAddr3
)

78 
v®
 
	gSBADDRESSF›ldsReg
 = 
Seq
.
fl
(4)(
Reg
 (
UIÁ
(32.
W
)))

79 
SBADDRESSF›ldsReg
.
zW™hIndex
.
fÜ—ch
 { (
a
,
i
è=>‡.
sugge¡Name
("SBADDRESS"+i+"FieldsReg")}

80 
v®
 
	gSBADDRESSWrD©a
 = 
Seq
.
fl
(4)(
Wœe
(
UIÁ
(32.
W
)))

81 
v®
 
SBADDRESSRdEn
 = 
Seq
.
fl
(4)(
Wœe
(
BoŞ
()))

82 
v®
 
SBADDRESSWrEn
 = 
Seq
.
fl
(4)(
Wœe
(
BoŞ
()))

84 
v®
 
autoInüem’‹dAddr
 = 
Wœe
(
š™
 = 0.U(128.
W
))

85 
autoInüem’‹dAddr
 :ğ
C©
(
SBADDRESSF›ldsReg
.
»v”£
è+ (1.U << 
SBCSF›ldsReg
.
sbacûss
)

86 
autoInüem’‹dAddr
.
sugge¡Name
("autoIncrementedAddr")

88 
v®
 
sbaddrf›lds
: 
Seq
[Seq[
RegF›ld
]] = 
SBADDRESSF›ldsReg
.
zW™hIndex
.
m­
 { (
a
,
i
) =>

89 if(
hasAddr
(
i
)) {

90 
wh’
 (~
dmaùive
) {

91 
a
 :ğ0.U(32.
W
)

92 }.
Ùh”wi£
 {

93 
a
 :ğ
Mux
(
SBADDRESSWrEn
(
i
è&& !
SBCSRdD©a
.
sb”rÜ
 && !
SBCSF›ldsReg
.
sbbusy
, 
SBADDRESSWrD©a
(i),

94 
Mux
((
sb2
.
moduË
.
io
.
rdDÚe
 || sb2.moduË.io.
wrDÚe
è&& 
SBCSF›ldsReg
.
sbautošüem’t
, 
autoInüem’‹dAddr
(32*
i
+31,32*i), 
a
))

97 
Seq
(
RWNÙify
(32, 
a
, 
SBADDRESSWrD©a
(
i
), 
SBADDRESSRdEn
(i), 
SBADDRESSWrEn
(i),

98 
Some
(
RegF›ldDesc
("dmi_sbaddr"+
i
, "", 
»£t
=Some(0)))))

100 
	gSeq
.
	gem±y
[
RegF›ld
]

104 
	gsb2
.
	gmoduË
.
	gio
.
	gaddrIn
 :ğ
Mux
(
sb2
.
moduË
.
io
.
rdEn
,
C©
(
SBADDRESSWrD©a
.
»v”£
),C©(
SBADDRESSF›ldsReg
.reverse))

105 
	gªyAdd»ssWrEn
 :ğ
SBADDRESSWrEn
.
»duû
(
_
 || _)

110 
v®
 
hasSBD©a1
 = (
cfg
.
maxSuµÜ‹dSBAcûss
 > 32)

111 
v®
 
hasSBD©a2And3
 = (
cfg
.
maxSuµÜ‹dSBAcûss
 == 128)

112 
v®
 
hasD©a
 = 
Seq
(
Œue
, 
hasSBD©a1
, 
hasSBD©a2And3
, hasSBData2And3)

114 
v®
 
	gSBDATAF›ldsReg
 = 
Seq
.
fl
(4)(Seq.fl(4)(
Reg
 (
UIÁ
(8.
W
))))

115 
SBDATAF›ldsReg
.
zW™hIndex
.
fÜ—ch
 { (
d
,
i
è=> d.zW™hIndex.fÜ—ch { (d,
j
è=> d.
sugge¡Name
("SBDATA"+i+"BYTE"+j) }}

116 
v®
 
	gSBDATARdD©a
 = 
Seq
.
fl
(4)(
Wœe
(
UIÁ
(32.
W
)))

117 
SBDATARdD©a
.
zW™hIndex
.
fÜ—ch
 { (
d
,
i
è=> d.
sugge¡Name
("SBDATARdData"+i) }

118 
v®
 
	gSBDATAWrD©a
 = 
Seq
.
fl
(4)(
Wœe
(
UIÁ
(32.
W
)))

119 
SBDATAWrD©a
.
zW™hIndex
.
fÜ—ch
 { (
d
,
i
è=> d.
sugge¡Name
("SBDATAWrData"+i) }

120 
v®
 
	gSBDATARdEn
 = 
Seq
.
fl
(4)(
Wœe
(
BoŞ
()))

121 
v®
 
SBDATAWrEn
 = 
Seq
.
fl
(4)(
Wœe
(
BoŞ
()))

122 
SBDATAWrEn
.
zW™hIndex
.
fÜ—ch
 { (
d
,
i
è=> d.
sugge¡Name
("SBDATAWrEn"+i) }

124 
v®
 
	gsbd©af›lds
: 
Seq
[Seq[
RegF›ld
]] = 
SBDATAF›ldsReg
.
zW™hIndex
.
m­
 { (
d
,
i
) =>

125 if(
hasD©a
(
i
)) {

127 
j
 <- 0 
to
 3) {

128 
wh’
 (~
dmaùive
) {

129 
d
(
j
è:ğ0.U(8.
W
)

130 }.
Ùh”wi£
 {

131 
d
(
j
è:ğ
Mux
(
SBDATAWrEn
(
i
è&& !
SBCSF›ldsReg
.
sbbusy
 && !
SBCSRdD©a
.
sb”rÜ
, 
SBDATAWrD©a
(i)(8*j+7,8*j),

132 
Mux
(
sb2
.
moduË
.
io
.
rdLßd
(4*
i
+
j
), sb2.moduË.io.
d©aOut
, 
d
(j)))

136 
SBDATARdD©a
(
i
è:ğ
C©
(
d
.
»v”£
)

138 
Seq
(
RWNÙify
(32, 
SBDATARdD©a
(
i
), 
SBDATAWrD©a
(i), 
SBDATARdEn
(i), 
SBDATAWrEn
(i),

139 
Some
(
RegF›ldDesc
("dmi_sbd©a"+
i
, "", 
»£t
=Some(0)))))

141 
	gSeq
.
	gem±y
[
RegF›ld
]

145 
	gsb2
.
	gmoduË
.
	gio
.
	gd©aIn
 :ğ
Mux
(
sb2
.
moduË
.
io
.
wrEn
,
C©
(
SBDATAWrD©a
.
»v”£
),C©(
SBDATAF›ldsReg
.
æ©‹n
.reverse))

146 
	gªyD©aRdEn
 :ğ
SBDATARdEn
.
»duû
(
_
 || _)

147 
ªyD©aWrEn
 :ğ
SBDATAWrEn
.
»duû
(
_
 || _)

149 
v®
 
ŒyWrEn
 = 
SBDATAWrEn
(0)

150 
v®
 
ŒyRdEn
 = (
SBADDRESSWrEn
(0è&& 
SBCSF›ldsReg
.
sb»adÚaddr
è|| (
SBDATARdEn
(0è&& SBCSF›ldsReg.
sb»adÚd©a
)

152 
v®
 
sbAcûssE¼Ü
 = (
SBCSF›ldsReg
.
sbacûss
 ==ğ0.Uè&& (SBCSF›ldsReg.
sbacûss8
 =/= 1.U) ||

153 (
SBCSF›ldsReg
.
sbacûss
 ==ğ1.Uè&& (SBCSF›ldsReg.
sbacûss16
 =/= 1.U) ||

154 (
SBCSF›ldsReg
.
sbacûss
 ==ğ2.Uè&& (SBCSF›ldsReg.
sbacûss32
 =/= 1.U) ||

155 (
SBCSF›ldsReg
.
sbacûss
 ==ğ3.Uè&& (SBCSF›ldsReg.
sbacûss64
 =/= 1.U) ||

156 (
SBCSF›ldsReg
.
sbacûss
 ==ğ4.Uè&& (SBCSF›ldsReg.
sbacûss128
 =/= 1.U)

158 
v®
 
com·»Addr
 = 
Wœe
(
UIÁ
(32.
W
))

159 
com·»Addr
 :ğ
Mux
(
SBADDRESSWrEn
(0),
SBADDRESSWrD©a
(0),
SBADDRESSF›ldsReg
(0))

161 
v®
 
	gsbAlignm’tE¼Ü
 = (
SBCSF›ldsReg
.
sbacûss
 ==ğ1.Uè&& (
com·»Addr
(0) =/= 0.U) ||

162 (
SBCSF›ldsReg
.
sbacûss
 ==ğ2.Uè&& (
com·»Addr
(1,0) =/= 0.U) ||

163 (
SBCSF›ldsReg
.
sbacûss
 ==ğ3.Uè&& (
com·»Addr
(2,0) =/= 0.U) ||

164 (
SBCSF›ldsReg
.
sbacûss
 ==ğ4.Uè&& (
com·»Addr
(3,0) =/= 0.U)

166 
sbAcûssE¼Ü
.
sugge¡Name
("sbAccessError")

167 
sbAlignm’tE¼Ü
.
sugge¡Name
("sbAlignmentError")

169 
sb2
.
moduË
.
io
.
wrEn
 :ğ
ŒyWrEn
 && !
SBCSF›ldsReg
.
sbbusy
 && !
SBCSRdD©a
.
sb”rÜ
 && !
sbAcûssE¼Ü
 && !
sbAlignm’tE¼Ü


170 
sb2
.
moduË
.
io
.
rdEn
 :ğ
ŒyRdEn
 && !
SBCSF›ldsReg
.
sbbusy
 && !
SBCSRdD©a
.
sb”rÜ
 && !
sbAcûssE¼Ü
 && !
sbAlignm’tE¼Ü


171 
sb2
.
moduË
.
io
.
sizeIn
 :ğ
SBCSF›ldsReg
.
sbacûss


172 
sb2
.
moduË
.
io
.
dmaùive
 := dmactive

174 
v®
 
sbBusy
 = (
sb2
.
moduË
.
io
.
sbS‹Out
 =/ğ
Sy¡emBusAcûssS‹
.
IdË
.
id
.
U
)

176 
wh’
 (~
dmaùive
) {

177 
SBCSF›ldsReg
 :ğ
SBCSF›ldsRegRe£t


178 }.
Ùh”wi£
 {

179 
SBCSF›ldsReg
.
sbbusy”rÜ
 :ğ
Mux
(
SBCSWrEn
 && 
SBCSWrD©a
.sbbusy”rÜ, 
çl£
.
B
,

180 
Mux
(
ªyAdd»ssWrEn
 && 
sbBusy
, 
Œue
.
B
,

181 
Mux
((
ªyD©aRdEn
 || 
ªyD©aWrEn
è&& 
sbBusy
, 
Œue
.
B
, 
SBCSF›ldsReg
.
sbbusy”rÜ
)))

182 
	gSBCSF›ldsReg
.
	gsb»adÚaddr
 :ğ
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sb»adÚaddr
 , 
SBCSF›ldsReg
.sbreadonaddr)

183 
	gSBCSF›ldsReg
.
	gsbautošüem’t
 :ğ
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sbautošüem’t
, 
SBCSF›ldsReg
.sbautoincrement)

184 
	gSBCSF›ldsReg
.
	gsb»adÚd©a
 :ğ
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sb»adÚd©a
 , 
SBCSF›ldsReg
.sbreadondata)

185 
	gSBCSF›ldsReg
.
	gsbacûss
 :ğ
Mux
(
SBCSWrEn
, 
SBCSWrD©a
.
sbacûss
, 
SBCSF›ldsReg
.sbaccess)

186 
	gSBCSF›ldsReg
.
	gsbv”siÚ
 :ğ1.U(1.
W
)

190 
v®
 
sbE¼ÜReg
 = 
Reg
(
Vec
(4, 
UIÁ
(1.
W
)))

191 
wh’
(~
dmaùive
) {

192 
	gi
 <- 0 
	guÁ
 3)

193 
sbE¼ÜReg
(
i
) := 0.U

194 }.
Ùh”wi£
 {

195 
i
 <- 0 
uÁ
 3)

196 
sbE¼ÜReg
(
i
è:ğ
Mux
(
SBCSWrEn
 && 
SBCSWrD©a
.
sb”rÜ
(iè==ğ1.U, 
NoE¼Ü
.
id
.
U
(i),

197 
Mux
((
sb2
.
moduË
.
io
.
wrEn
 && !sb2.moduË.io.
wrLeg®
è|| (sb2.moduË.io.
rdEn
 && !sb2.moduË.io.
rdLeg®
), 
BadAddr
.
id
.
U
(
i
),

198 
Mux
((
ŒyWrEn
 || 
ŒyRdEn
è&& 
sbAlignm’tE¼Ü
, 
AlgnE¼Ü
.
id
.
U
(
i
),

199 
Mux
((
ŒyWrEn
 || 
ŒyRdEn
è&& 
sbAcûssE¼Ü
, 
BadAcûss
.
id
.
U
(
i
),

200 
Mux
((
sb2
.
moduË
.
io
.
rdDÚe
 || sb2.moduË.io.
wrDÚe
è&& sb2.moduË.io.
»¥E¼Ü
, 
Oth”E¼Ü
.
id
.
U
(
i
), 
sbE¼ÜReg
(i))))))

203 
	gSBCSRdD©a
 :ğ
SBCSF›ldsReg


204 
SBCSRdD©a
.
sbasize
 :ğ
sb2
.
moduË
.
edge
.
bundË
.
add»ssB™s
.
U


205 
SBCSRdD©a
.
sbacûss128
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 =ğ128).
B


206 
SBCSRdD©a
.
sbacûss64
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ64).
B


207 
SBCSRdD©a
.
sbacûss32
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ32).
B


208 
SBCSRdD©a
.
sbacûss16
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ16).
B


209 
SBCSRdD©a
.
sbacûss8
 :ğ(
cfg
.
maxSuµÜ‹dSBAcûss
 >ğ8).
B


210 
SBCSRdD©a
.
sbbusy
 :ğ
sbBusy


211 
SBCSRdD©a
.
sb”rÜ
 :ğ
sbE¼ÜReg
.
asUIÁ


213 
cov”
(
SBCSF›ldsReg
.
sbbusy”rÜ
, "SBCS Cover", "sberror set")

214 
cov”
(
SBCSF›ldsReg
.
sbbusy
 === 3.U, "SBCS Cover", "sbbusyerror‡lignmentƒrror")

216 
cov”
((
sb2
.
moduË
.
io
.
wrEn
 || sb2.moduË.io.
rdEn
è&& 
SBCSF›ldsReg
.
sbacûss
 ==ğ0.U && !
sbAcûssE¼Ü
 && !
sbAlignm’tE¼Ü
, "SBCS Cover", "8-bit‡ccess")

217 
cov”
((
sb2
.
moduË
.
io
.
wrEn
 || sb2.moduË.io.
rdEn
è&& 
SBCSF›ldsReg
.
sbacûss
 ==ğ1.U && !
sbAcûssE¼Ü
 && !
sbAlignm’tE¼Ü
, "SBCS Cover", "16-bit‡ccess")

218 
cov”
((
sb2
.
moduË
.
io
.
wrEn
 || sb2.moduË.io.
rdEn
è&& 
SBCSF›ldsReg
.
sbacûss
 ==ğ2.U && !
sbAcûssE¼Ü
 && !
sbAlignm’tE¼Ü
, "SBCS Cover", "32-bit‡ccess")

219 
cov”
((
sb2
.
moduË
.
io
.
wrEn
 || sb2.moduË.io.
rdEn
è&& 
SBCSF›ldsReg
.
sbacûss
 ==ğ3.U && !
sbAcûssE¼Ü
 && !
sbAlignm’tE¼Ü
, "SBCS Cover", "64-bit‡ccess")

220 
cov”
((
sb2
.
moduË
.
io
.
wrEn
 || sb2.moduË.io.
rdEn
è&& 
SBCSF›ldsReg
.
sbacûss
 ==ğ4.U && !
sbAcûssE¼Ü
 && !
sbAlignm’tE¼Ü
, "SBCS Cover", "128-bit‡ccess")

222 
cov”
(
SBCSF›ldsReg
.
sbautošüem’t
 && SBCSF›ldsReg.
sbbusy
, "SBCS Cover", "Access with‡utoincrement set")

223 
cov”
(!
SBCSF›ldsReg
.
sbautošüem’t
 && SBCSF›ldsReg.
sbbusy
, "SBCS Cover", "Access without‡utoincrement set")

225 (
	gsbcsf›lds
, 
	gsbaddrf›lds
, 
	gsbd©af›lds
)

229 şas 
	cSBToTL
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

231 
v®
 
cfg
 = 
	$p
(
DebugModuËP¬ams
)

233 
v®
 
node
 = 
	`TLCl›ÁNode
(
	`Seq
(
	`TLCl›ÁPÜtP¬am‘”s
(Seq(
	`TLCl›ÁP¬am‘”s
("debug")))))

235 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

236 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

237 
v®
 
rdEn
 = 
	`BoŞ
(
INPUT
)

238 
v®
 
wrEn
 = 
	`BoŞ
(
INPUT
)

239 
v®
 
addrIn
 = 
	`UIÁ
(
INPUT
, 128)

240 
v®
 
d©aIn
 = 
	`UIÁ
(
INPUT
, 128)

241 
v®
 
sizeIn
 = 
	`UIÁ
(
INPUT
, 3)

242 
v®
 
dmaùive
 = 
	`BoŞ
(
INPUT
)

243 
v®
 
rdLeg®
 = 
	`BoŞ
(
OUTPUT
)

244 
v®
 
wrLeg®
 = 
	`BoŞ
(
OUTPUT
)

245 
v®
 
rdDÚe
 = 
	`BoŞ
(
OUTPUT
)

246 
v®
 
wrDÚe
 = 
	`BoŞ
(
OUTPUT
)

247 
v®
 
»¥E¼Ü
 = 
	`BoŞ
(
OUTPUT
)

248 
v®
 
d©aOut
 = 
	`UIÁ
(
OUTPUT
, 8)

249 
v®
 
rdLßd
 = 
	`Vec
(
cfg
.
maxSuµÜ‹dSBAcûss
/8, 
	`BoŞ
()).
asOuut


250 
v®
 
sbS‹Out
 = 
	`UIÁ
(
OUTPUT
, 
	`log2Ce
(
Sy¡emBusAcûssS‹
.
maxId
))

253 
impÜt
 
Sy¡emBusAcûssS‹
.
_


255 
	`v®
 (

, 
edge
èğ
node
.
	`out
(0)

257 
v®
 
sbS‹
 = 
	`Reg
(
š™
 = 0.U)

260 
v®
 
d
 = 
	`Queue
(

.d, 2)

261 
d
.
»ady
 :ğ(
sbS‹
 ==ğ
SBR—dRe¥Ú£
.
id
.
U
è|| (sbS‹ ==ğ
SBWr™eRe¥Ú£
.id.U)

263 
v®
 
muxedD©a
 = 
	`Wœe
(
š™
 = 0.U(8.
W
))

264 
v®
 
»que¡V®id
 = 

.
a
.
v®id


265 
v®
 
»que¡R—dy
 = 

.
a
.
»ady


266 
v®
 
»¥Ú£V®id
 = 
d
.
v®id


267 
v®
 
»¥Ú£R—dy
 = 
d
.
»ady


269 
v®
 
couÁ”
 = 
	`Reg
(
š™
 = 0.U((
	`log2Ce
(
cfg
.
maxSuµÜ‹dSBAcûss
/8)+1).
W
))

270 
v®
 
vecD©a
 = 
	`Wœe
(
	`Vec
(
cfg
.
maxSuµÜ‹dSBAcûss
/8, 
	`UIÁ
(8.
W
)))

271 
vecD©a
 :ğ
Vec
.
	`buÏ‹
(16è{ 
i
 => 
io
.
	`d©aIn
(8*i+7,8*i) }

272 
muxedD©a
 :ğ
	`vecD©a
(
couÁ”
)

274 
	`v®
 (
rdLeg®
, 
gb™s
èğ
edge
.
	`G‘
(0.U, 
io
.
addrIn
, io.
sizeIn
)

275 
	`v®
 (
wrLeg®
, 
pfb™s
èğ
edge
.
	`Put
(0.U, 
io
.
addrIn
, io.
sizeIn
, 
muxedD©a
)

277 
io
.
rdLeg®
 :=„dLegal

278 
io
.
wrLeg®
 := wrLegal

280 
io
.
sbS‹Out
 :ğ
sbS‹


281 
	`wh’
(
sbS‹
 ==ğ
SBR—dReque¡
.
id
.
U
è{ 

.
a
.
b™s
 :ğ
gb™s
 }

282 .
Ùh”wi£
 { 

.
a
.
b™s
 :ğ
pfb™s
 }

284 
v®
 
»¥E¼Ü
 = 
d
.
b™s
.
d’›d
 || d.b™s.
cÜru±


285 
io
.
»¥E¼Ü
 :=„espError

287 
v®
 
wrTxV®id
 = 
sbS‹
 ==ğ
SBWr™eReque¡
.
id
.
U
 && 
»que¡V®id
 && 
»que¡R—dy


288 
v®
 
rdTxV®id
 = 
sbS‹
 ==ğ
SBR—dRe¥Ú£
.
id
.
U
 && 
»¥Ú£V®id
 && 
»¥Ú£R—dy


289 
v®
 
txLa¡
 = 
couÁ”
 ==ğ((1.U << 
io
.
sizeIn
) - 1.U)

290 
couÁ”
 :ğ
	`Mux
((
wrTxV®id
 || 
rdTxV®id
è&& 
txLa¡
, 0.U,

291 
	`Mux
((
wrTxV®id
 || 
rdTxV®id
è, 
couÁ”
+1.U, counter))

293 
i
 <- 0 
	`uÁ
 (
cfg
.
maxSuµÜ‹dSBAcûss
/8)) {

294 
io
.
	`rdLßd
(
i
è:ğ
rdTxV®id
 && (
couÁ”
 ==ği.
U
)

298 
	`wh’
(~
io
.
dmaùive
){

299 
sbS‹
 :ğ
IdË
.
id
.
U


300 }.
	`–£wh’
 (
sbS‹
 ==ğ
IdË
.
id
.
U
){

301 
sbS‹
 :ğ
	`Mux
(
io
.
rdEn
 && 
rdLeg®
, 
SBR—dReque¡
.
id
.
U
,

302 
	`Mux
(
io
.
wrEn
 && 
wrLeg®
, 
SBWr™eReque¡
.
id
.
U
, 
sbS‹
))

303 }.
	`–£wh’
 (
sbS‹
 ==ğ
SBR—dReque¡
.
id
.
U
){

304 
sbS‹
 :ğ
	`Mux
(
»que¡V®id
 && 
»que¡R—dy
, 
SBR—dRe¥Ú£
.
id
.
U
, sbState)

305 }.
	`–£wh’
 (
sbS‹
 ==ğ
SBWr™eReque¡
.
id
.
U
){

306 
sbS‹
 :ğ
	`Mux
(
wrTxV®id
 && 
txLa¡
, 
SBWr™eRe¥Ú£
.
id
.
U
, sbState)

307 }.
	`–£wh’
 (
sbS‹
 ==ğ
SBR—dRe¥Ú£
.
id
.
U
){

308 
sbS‹
 :ğ
	`Mux
(
rdTxV®id
 && 
txLa¡
, 
IdË
.
id
.
U
, sbState)

309 }.
	`–£wh’
 (
sbS‹
 ==ğ
SBWr™eRe¥Ú£
.
id
.
U
){

310 
sbS‹
 :ğ
	`Mux
(
»¥Ú£V®id
 && 
»¥Ú£R—dy
, 
IdË
.
id
.
U
, sbState)

313 
io
.
rdDÚe
 :ğ
rdTxV®id
 && 
txLa¡


314 
io
.
wrDÚe
 :ğ(
sbS‹
 ==ğ
SBWr™eRe¥Ú£
.
id
.
U
è&& 
»¥Ú£V®id
 && 
»¥Ú£R—dy


315 
io
.
d©aOut
 :ğ
d
.
b™s
.
d©a


317 

.
a
.
v®id
 :ğ(
sbS‹
 ==ğ
SBR—dReque¡
.
id
.
U
è|| (sbS‹ ==ğ
SBWr™eReque¡
.id.U)

320 

.
b
.
»ady
 :ğ
çl£
.
B


321 

.
c
.
v®id
 :ğ
çl£
.
B


322 

.
e
.
v®id
 :ğ
çl£
.
B


324 
	`as£¹
 (!

.
d
.
v®id
 ||l.d.
»ady
, "Debug module‚ot„eadyo‡ccept TL„esponse")

325 
	`as£¹
 (
sbS‹
 ==ğ
IdË
.
id
.
U
 ||

326 
sbS‹
 ==ğ
SBR—dReque¡
.
id
.
U
 ||

327 
sbS‹
 ==ğ
SBWr™eReque¡
.
id
.
U
 ||

328 
sbS‹
 ==ğ
SBR—dRe¥Ú£
.
id
.
U
 ||

329 
sbS‹
 ==ğ
SBWr™eRe¥Ú£
.
id
.
U
, "SBA state machine in undefined state")

331 
	`cov”
 (
sbS‹
 ==ğ
IdË
.
id
.
U
, "SBA State Cover", "SBA Access Idle")

332 
	`cov”
 (
sbS‹
 ==ğ
SBR—dReque¡
.
id
.
U
, "SBA State Cover", "SBA Access Read Req")

333 
	`cov”
 (
sbS‹
 ==ğ
SBWr™eReque¡
.
id
.
U
, "SBA State Cover", "SBA Access Write Req")

334 
	`cov”
 (
sbS‹
 ==ğ
SBR—dRe¥Ú£
.
id
.
U
, "SBA State Cover", "SBA Access Read Resp")

335 
	`cov”
 (
sbS‹
 ==ğ
SBWr™eRe¥Ú£
.
id
.
U
, "SBA State Cover", "SBA Access Write Resp")

337 
	`cov”
 (
io
.
rdEn
 && !io.
rdLeg®
, "SB Legality Cover", "SBA Rd Address Illegal")

338 
	`cov”
 (
io
.
wrEn
 && !io.
wrLeg®
, "SB Legality Cover", "SBA Wr Address Illegal")

341 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/abstract_commands.scala

1 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


3 
impÜt
 
	gChi£l
.
_


8 
objeù
 
	gAC_RegAddrs
 {

11 şas 
	cACCESS_REGISTERF›lds
 
ex‹nds
 
	mBundË
 {

15 
v®
 
	mcmdty³
 = 
	$UIÁ
(8.
W
)

17 
v®
 
»£rved0
 = 
	$UIÁ
(1.
W
)

32 
v®
 
size
 = 
	$UIÁ
(3.
W
)

34 
v®
 
»£rved1
 = 
	$UIÁ
(1.
W
)

39 
v®
 
po¡exec
 = 
	$BoŞ
()

48 
v®
 
Œªsãr
 = 
	$BoŞ
()

57 
v®
 
wr™e
 = 
	$BoŞ
()

64 
v®
 
»gno
 = 
	`UIÁ
(16.
W
)

68 şas 
	cQUICK_ACCESSF›lds
 
ex‹nds
 
BundË
 {

72 
v®
 
cmdty³
 = 
	$UIÁ
(8.
W
)

74 
v®
 
»£rved0
 = 
	`UIÁ
(24.
W
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/dm_registers.scala

1 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
debug


3 
impÜt
 
	gChi£l
.
_


8 
objeù
 
	gDMI_RegAddrs
 {

30 
def
 
	gDMI_DMSTATUS
 = 0x11

45 
def
 
DMI_DMCONTROL
 = 0x10

58 
def
 
DMI_HARTINFO
 = 0x12

63 
def
 
DMI_HAWINDOWSEL
 = 0x14

75 
def
 
DMI_HAWINDOW
 = 0x15

77 
def
 
DMI_ABSTRACTCS
 = 0x16

95 
def
 
DMI_COMMAND
 = 0x17

100 
def
 
DMI_ABSTRACTAUTO
 = 0x18

118 
def
 
DMI_DEVTREEADDR0
 = 0x19

120 
def
 
DMI_DEVTREEADDR1
 = 0x1a

122 
def
 
DMI_DEVTREEADDR2
 = 0x1b

124 
def
 
DMI_DEVTREEADDR3
 = 0x1c

130 
def
 
DMI_NEXTDM
 = 0x1d

148 
def
 
DMI_DATA0
 = 0x04

150 
def
 
DMI_DATA11
 = 0x0f

161 
def
 
DMI_PROGBUF0
 = 0x20

163 
def
 
DMI_PROGBUF15
 = 0x2f

172 
def
 
DMI_AUTHDATA
 = 0x30

181 
def
 
DMI_HALTSUM0
 = 0x40

195 
def
 
DMI_HALTSUM1
 = 0x13

209 
def
 
DMI_HALTSUM2
 = 0x34

221 
def
 
DMI_HALTSUM3
 = 0x35

228 
def
 
DMI_SBADDRESS3
 = 0x37

230 
def
 
DMI_SBCS
 = 0x38

246 
def
 
DMI_SBADDRESS0
 = 0x39

253 
def
 
DMI_SBADDRESS1
 = 0x3a

260 
def
 
DMI_SBADDRESS2
 = 0x3b

295 
def
 
DMI_SBDATA0
 = 0x3c

303 
def
 
DMI_SBDATA1
 = 0x3d

310 
def
 
DMI_SBDATA2
 = 0x3e

317 
def
 
DMI_SBDATA3
 = 0x3f

321 şas 
	cDMSTATUSF›lds
 
ex‹nds
 
	mBundË
 {

323 
v®
 
	m»£rved0
 = 
	$UIÁ
(9.
W
)

332 
v®
 
im³b»ak
 = 
	$BoŞ
()

334 
v®
 
»£rved1
 = 
	$UIÁ
(2.
W
)

338 
v®
 
®lhav”e£t
 = 
	$BoŞ
()

342 
v®
 
ªyhav”e£t
 = 
	$BoŞ
()

347 
v®
 
®Ìesum—ck
 = 
	$BoŞ
()

352 
v®
 
ªy»sum—ck
 = 
	$BoŞ
()

356 
v®
 
®ÊÚexi¡’t
 = 
	$BoŞ
()

360 
v®
 
ªynÚexi¡’t
 = 
	$BoŞ
()

364 
v®
 
®luÇva
 = 
	$BoŞ
()

368 
v®
 
ªyuÇva
 = 
	$BoŞ
()

372 
v®
 
®ÌuÂšg
 = 
	$BoŞ
()

376 
v®
 
ªyruÂšg
 = 
	$BoŞ
()

380 
v®
 
®lh®‹d
 = 
	$BoŞ
()

384 
v®
 
ªyh®‹d
 = 
	$BoŞ
()

390 
v®
 
auth’tiÿ‹d
 = 
	$BoŞ
()

401 
v®
 
authbusy
 = 
	$BoŞ
()

403 
v®
 
»£rved2
 = 
	$UIÁ
(1.
W
)

411 
v®
 
devŒ“v®id
 = 
	$BoŞ
()

424 
v®
 
v”siÚ
 = 
	`UIÁ
(4.
W
)

428 şas 
	cDMCONTROLF›lds
 
ex‹nds
 
BundË
 {

439 
v®
 
h®Œeq
 = 
	$BoŞ
()

450 
v®
 
»sum”eq
 = 
	$BoŞ
()

462 
v®
 
h¬Œe£t
 = 
	$BoŞ
()

469 
v®
 
ackhav”e£t
 = 
	$BoŞ
()

471 
v®
 
»£rved0
 = 
	$UIÁ
(1.
W
)

485 
v®
 
ha£l
 = 
	$BoŞ
()

490 
v®
 
h¬t£Îo
 = 
	$UIÁ
(10.
W
)

495 
v®
 
h¬t£lhi
 = 
	$UIÁ
(10.
W
)

497 
v®
 
»£rved1
 = 
	$UIÁ
(4.
W
)

507 
v®
 
ndm»£t
 = 
	$BoŞ
()

528 
v®
 
dmaùive
 = 
	`BoŞ
()

532 şas 
	cHARTINFOF›lds
 
ex‹nds
 
BundË
 {

534 
v®
 
»£rved0
 = 
	$UIÁ
(8.
W
)

541 
v®
 
nsü©ch
 = 
	$UIÁ
(4.
W
)

543 
v®
 
»£rved1
 = 
	$UIÁ
(3.
W
)

552 
v®
 
d©¯cûss
 = 
	$BoŞ
()

563 
v®
 
d©asize
 = 
	$UIÁ
(4.
W
)

571 
v®
 
d©¯ddr
 = 
	`UIÁ
(12.
W
)

575 şas 
	cHAWINDOWSELF›lds
 
ex‹nds
 
BundË
 {

577 
v®
 
»£rved0
 = 
	$UIÁ
(17.
W
)

583 
v®
 
hawšdow£l
 = 
	`UIÁ
(15.
W
)

587 şas 
	cHAWINDOWF›lds
 
ex‹nds
 
BundË
 {

589 
v®
 
maskd©a
 = 
	`UIÁ
(32.
W
)

593 şas 
	cABSTRACTCSF›lds
 
ex‹nds
 
BundË
 {

595 
v®
 
»£rved0
 = 
	$UIÁ
(3.
W
)

599 
v®
 
´ogbufsize
 = 
	$UIÁ
(5.
W
)

601 
v®
 
»£rved1
 = 
	$UIÁ
(11.
W
)

608 
v®
 
busy
 = 
	$BoŞ
()

610 
v®
 
»£rved2
 = 
	$UIÁ
(1.
W
)

633 
v®
 
cmd”r
 = 
	$UIÁ
(3.
W
)

635 
v®
 
»£rved3
 = 
	$UIÁ
(4.
W
)

640 
v®
 
d©acouÁ
 = 
	`UIÁ
(4.
W
)

644 şas 
	cCOMMANDF›lds
 
ex‹nds
 
BundË
 {

649 
v®
 
cmdty³
 = 
	$UIÁ
(8.
W
)

654 
v®
 
cÚŒŞ
 = 
	`UIÁ
(24.
W
)

658 şas 
	cABSTRACTAUTOF›lds
 
ex‹nds
 
BundË
 {

663 
v®
 
autÛxeırogbuf
 = 
	$UIÁ
(16.
W
)

665 
v®
 
»£rved0
 = 
	$UIÁ
(4.
W
)

670 
v®
 
autÛxecd©a
 = 
	`UIÁ
(12.
W
)

674 şas 
	cDEVTREEADDR0F›lds
 
ex‹nds
 
BundË
 {

676 
v®
 
addr
 = 
	`UIÁ
(32.
W
)

680 şas 
	cNEXTDMF›lds
 
ex‹nds
 
BundË
 {

682 
v®
 
addr
 = 
	`UIÁ
(32.
W
)

686 şas 
	cDATA0F›lds
 
ex‹nds
 
BundË
 {

688 
v®
 
d©a
 = 
	`UIÁ
(32.
W
)

692 şas 
	cPROGBUF0F›lds
 
ex‹nds
 
BundË
 {

694 
v®
 
d©a
 = 
	`UIÁ
(32.
W
)

698 şas 
	cAUTHDATAF›lds
 
ex‹nds
 
BundË
 {

700 
v®
 
d©a
 = 
	`UIÁ
(32.
W
)

704 şas 
	cHALTSUM0F›lds
 
ex‹nds
 
BundË
 {

706 
v®
 
h®tsum0
 = 
	`UIÁ
(32.
W
)

710 şas 
	cHALTSUM1F›lds
 
ex‹nds
 
BundË
 {

712 
v®
 
h®tsum1
 = 
	`UIÁ
(32.
W
)

716 şas 
	cHALTSUM2F›lds
 
ex‹nds
 
BundË
 {

718 
v®
 
h®tsum2
 = 
	`UIÁ
(32.
W
)

722 şas 
	cHALTSUM3F›lds
 
ex‹nds
 
BundË
 {

724 
v®
 
h®tsum3
 = 
	`UIÁ
(32.
W
)

728 şas 
	cSBADDRESS3F›lds
 
ex‹nds
 
BundË
 {

733 
v®
 
add»ss
 = 
	`UIÁ
(32.
W
)

737 şas 
	cSBCSF›lds
 
ex‹nds
 
BundË
 {

746 
v®
 
sbv”siÚ
 = 
	$UIÁ
(3.
W
)

748 
v®
 
»£rved0
 = 
	$UIÁ
(6.
W
)

758 
v®
 
sbbusy”rÜ
 = 
	$BoŞ
()

768 
v®
 
sbbusy
 = 
	$BoŞ
()

773 
v®
 
sb»adÚaddr
 = 
	$BoŞ
()

790 
v®
 
sbacûss
 = 
	$UIÁ
(3.
W
)

795 
v®
 
sbautošüem’t
 = 
	$BoŞ
()

800 
v®
 
sb»adÚd©a
 = 
	$BoŞ
()

822 
v®
 
sb”rÜ
 = 
	$UIÁ
(3.
W
)

827 
v®
 
sbasize
 = 
	$UIÁ
(7.
W
)

831 
v®
 
sbacûss128
 = 
	$BoŞ
()

835 
v®
 
sbacûss64
 = 
	$BoŞ
()

839 
v®
 
sbacûss32
 = 
	$BoŞ
()

843 
v®
 
sbacûss16
 = 
	$BoŞ
()

847 
v®
 
sbacûss8
 = 
	`BoŞ
()

851 şas 
	cSBADDRESS0F›lds
 
ex‹nds
 
BundË
 {

855 
v®
 
add»ss
 = 
	`UIÁ
(32.
W
)

859 şas 
	cSBADDRESS1F›lds
 
ex‹nds
 
BundË
 {

864 
v®
 
add»ss
 = 
	`UIÁ
(32.
W
)

868 şas 
	cSBADDRESS2F›lds
 
ex‹nds
 
BundË
 {

873 
v®
 
add»ss
 = 
	`UIÁ
(32.
W
)

877 şas 
	cSBDATA0F›lds
 
ex‹nds
 
BundË
 {

881 
v®
 
d©a
 = 
	`UIÁ
(32.
W
)

885 şas 
	cSBDATA1F›lds
 
ex‹nds
 
BundË
 {

890 
v®
 
d©a
 = 
	`UIÁ
(32.
W
)

894 şas 
	cSBDATA2F›lds
 
ex‹nds
 
BundË
 {

899 
v®
 
d©a
 = 
	`UIÁ
(32.
W
)

903 şas 
	cSBDATA3F›lds
 
ex‹nds
 
BundË
 {

908 
v®
 
d©a
 = 
	`UIÁ
(32.
W
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BootROM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.{
	gBa£Subsy¡em
, 
	gHasRe£tVeùÜWœe
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
impÜt
 
	gjava
.
	gnio
.{
	gBy‹Bufãr
, 
	gBy‹Ord”
}

13 
impÜt
 
	gjava
.
	gnio
.
	gfe
.{
	gFes
, 
	gP©hs
}

16 
şass
 
	$BoÙROMP¬ams
(

17 
add»ss
: 
BigIÁ
 = 0x10000,

18 
size
: 
IÁ
 = 0x10000,

19 
hªg
: 
BigIÁ
 = 0x10040,

20 
cÚ‹ÁFeName
: 
SŒšg
)

21 
objeù
 
BoÙROMP¬ams
 
ex‹nds
 
F›ld
[BootROMParams]

23 
şass
 
	`TLROM
(
v®
 
ba£
: 
BigIÁ
, v® 
size
: 
IÁ
, 
cÚ‹ÁsD–ayed
: => 
Seq
[
By‹
], 
execubË
: 
BoŞ—n
 = 
Œue
, 
b—tBy‹s
: Int = 4,

24 
»sourûs
: 
Seq
[
Resourû
] = 
Ãw
 
	`Sim¶eDeviû
("rom", 
	`Seq
("sifive,rom0")).
	`»g
("mem"))(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


26 
v®
 
node
 = 
	`TLMªag”Node
(
	`Seq
(
	`TLMªag”PÜtP¬am‘”s
(

27 
	`Seq
(
	`TLMªag”P¬am‘”s
(

28 
add»ss
 = 
	`Li¡
(
	`Add»ssS‘
(
ba£
, 
size
-1)),

29 
»sourûs
 =„esources,

30 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

31 
execubË
 =ƒxecutable,

32 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

33 
fifoId
 = 
	`Some
(0))),

34 
b—tBy‹s
 = beatBytes)))

36 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

37 
v®
 
cÚ‹Ás
 = 
cÚ‹ÁsD–ayed


38 
v®
 
w¿pSize
 = 1 << 
	`log2Ce
(
cÚ‹Ás
.
size
)

39 
	`»quœe
 (
w¿pSize
 <ğ
size
)

41 
	`v®
 (
š
, 
edge
èğ
node
.
	`š
(0)

43 
v®
 
wÜds
 = (
cÚ‹Ás
 ++ 
Seq
.
	`fl
(
w¿pSize
-cÚ‹Ás.
size
)(0.
toBy‹
)).
	`grou³d
(
b—tBy‹s
).
toSeq


44 
v®
 
bigs
 = 
wÜds
.
	`m­
(
_
.
	`fŞdRight
(
	`BigIÁ
(0)){ (
x
,
y
è=> (x.
toIÁ
 & 0xff) | y << 8})

45 
v®
 
rom
 = 
	`Vec
(
bigs
.
	`m­
(
x
 => 
	`UIÁ
(x, 
width
 = 8*
b—tBy‹s
)))

47 
š
.
d
.
v®id
 :ğš.
a
.valid

48 
š
.
a
.
»ady
 :ğš.
d
.ready

50 
v®
 
šdex
 = 
š
.
a
.
b™s
.
	`add»ss
(
	`log2Ce
(
w¿pSize
)-1,log2Ce(
b—tBy‹s
))

51 
v®
 
high
 = ià(
w¿pSize
 =ğ
size
è
	`UIÁ
(0è
š
.
a
.
b™s
.
	`add»ss
(
	`log2Ce
(size)-1,†og2Ceil(wrapSize))

52 
š
.
d
.
b™s
 :ğ
edge
.
	`AcûssAck
(š.
a
.b™s, 
	`Mux
(
high
.
ÜR
, 
	`UIÁ
(0), 
	`rom
(
šdex
)))

55 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

56 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

57 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

59 
	}
}

62 
Œa™
 
HasP”h”yBoÙROM
 { 
this
: 
Ba£Subsy¡em
 =>

63 
v®
 
dtb
: 
DTB


64 
´iv©e
 
v®
 
·¿ms
 = 
p
(
BoÙROMP¬ams
)

65 
´iv©e
 
Ïzy
 
v®
 
cÚ‹Ás
 = {

66 
v®
 
romd©a
 = 
Fes
.
»adAÎBy‹s
(
P©hs
.
g‘
(
·¿ms
.
cÚ‹ÁFeName
))

67 
v®
 
rom
 = 
By‹Bufãr
.
w¿p
(
romd©a
)

68 
rom
.
¬¿y
(è++ 
dtb
.
cÚ‹Ás


70 
def
 
»£tVeùÜ
: 
BigIÁ
 = 
·¿ms
.
hªg


72 
v®
 
boÙrom
 = 
LazyModuË
(
Ãw
 
TLROM
(
·¿ms
.
add»ss
,…¬ams.
size
, 
cÚ‹Ás
, 
Œue
, 
sbus
.
cÚŒŞ_bus
.
b—tBy‹s
))

74 
	gsbus
.
	gcÚŒŞ_bus
.
toV¬ŸbËWidthSÏve
(
Some
("boÙrom")){ 
	gboÙrom
.
	gnode
 }

78 
Œa™
 
HasP”h”yBoÙROMModuËImp
 
ex‹nds
 
LazyModuËImp


79 
w™h
 
	gHasRe£tVeùÜWœe
 {

80 
v®
 
	gou‹r
: 
HasP”h”yBoÙROM


81 
glob®_»£t_veùÜ
 :ğ
ou‹r
.
»£tVeùÜ
.
U


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBlocker.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


18 
şass
 
	$BasicBusBlock”P¬ams
(

19 
cÚŒŞAdd»ss
: 
BigIÁ
,

20 
cÚŒŞB—tBy‹s
: 
IÁ
,

21 
deviûB—tBy‹s
: 
IÁ
,

22 
d—dlock
: 
BoŞ—n
 = 
çl£
)

24 
şass
 
	$BasicBusBlock”
(
·¿ms
: 
BasicBusBlock”P¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
)

25 
ex‹nds
 
	$TLBusBy·ssBa£
(
·¿ms
.
deviûB—tBy‹s
,…¬ams.
d—dlock
)

27 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("basic-bus-block”", 
	`Seq
("sifive,basic-bus-blocker0"))

29 
v®
 
cÚŒŞNode
 = 
	`TLRegi¡”Node
(

30 
add»ss
 = 
	`Seq
(
	`Add»ssS‘
(
·¿ms
.
cÚŒŞAdd»ss
, 0xFFF)),

31 
deviû
 = device,

32 
b—tBy‹s
 = 
·¿ms
.
cÚŒŞB—tBy‹s
)

34 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

35 
v®
 
®low
 = 
	`RegIn™
(
Œue
.
B
)

36 
v®
 
³ndšg
 = 
	`RegNext
(
b¬
.
moduË
.
io
.pending)

38 
cÚŒŞNode
.
	`»gm­
(

39 0 -> 
	`Seq
(
	`RegF›ld
 (32, 
®low
)),

40 4 -> 
	`Seq
(
RegF›ld
.
	`r
(32, 
³ndšg
)))

42 
b¬
.
moduË
.
io
.
by·ss
 :ğ!
®low


44 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBypass.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
impÜt
 
	gsÿÏ
.
	gm©h
.
mš


12 
ab¡¿ù
 
şass
 
	$TLBusBy·ssBa£
(
b—tBy‹s
: 
IÁ
, 
d—dlock
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
´Ùeùed
 
v®
 
nodeIn
 = 
	`TLId’t™yNode
()

15 
´Ùeùed
 
v®
 
nodeOut
 = 
	`TLId’t™yNode
()

16 
v®
 
node
 = 
	`NodeHªdË
(
nodeIn
, 
nodeOut
)

18 
´Ùeùed
 
v®
 
b¬
 = 
	`LazyModuË
(
Ãw
 
	`TLBusBy·ssB¬
(
dFn
 = { 
mp
 =>

19 
mp
.
	`cİy
(
mªag”s
 = mp.mªag”s.
m­
 { 
m
 =>

20 
m
.
	`cİy
(

21 
mayD’yPut
 = 
m
.mayD’yPuˆ|| !
d—dlock
,

22 
mayD’yG‘
 = 
m
.mayD’yG‘ || !
d—dlock
)

25 
´Ùeùed
 
v®
 
ev”ythšg
 = 
	`Seq
(
	`Add»ssS‘
(0, 
	`BigIÁ
("ffffffffffffffffffffffffffffffff", 16)))

26 
´Ùeùed
 
v®
 
·¿ms
 = 
	`DevNuÎP¬ams
(
ev”ythšg
, 
maxAtomic
=16, 
maxT¿nsãr
=4096, 
»giÚ
=
RegiÚTy³
.
TRACKED
)

27 
´Ùeùed
 
v®
 
”rÜ
 = ià(
d—dlock
è
	`LazyModuË
(
Ãw
 
	`TLD—dlock
(
·¿ms
, 
b—tBy‹s
))

28 
	`LazyModuË
(
Ãw
 
	`TLE¼Ü
(
·¿ms
, 
b—tBy‹s
))

31 
b¬
.
node
 :ğ
nodeIn


32 
”rÜ
.
node
 :ğ
b¬
.node

33 
nodeOut
 :ğ
b¬
.
node


34 
	}
}

36 şas 
	cTLBusBy·ss
(
b—tBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$TLBusBy·ssBa£
(
b—tBy‹s
)

38 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

39 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

40 
v®
 
by·ss
 = 
	`BoŞ
(
INPUT
)

42 
b¬
.
moduË
.
io
.
by·ss
 := io.bypass

44 
	}
}

46 
şass
 
TLBy·ssNode
(
dFn
: 
TLMªag”PÜtP¬am‘”s
 => TLMªag”PÜtP¬am‘”s)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
TLCu¡omNode


48 
def
 
»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

49 
»quœe
 (
iSrs
 =ğ0 && 
oSrs
 == 0, "TLBypass‚ode does‚ot support :=* or :*=")

50 
»quœe
 (
iKnown
 == 1, "TLBypass‚odeƒxpectsƒxactly one input")

51 
»quœe
 (
oKnown
 == 2, "TLBypass‚odeƒxpectsƒxactlywo outputs")

54 
def
 
m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
]): Seq[TLClientPortParameters] = {… ++… }

55 
def
 
m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
TLMªag”PÜtP¬am‘”s
]): Seq[TLMªag”PÜtP¬am‘”s] = { Seq(
dFn
Õ.
Ï¡
)) }

58 
şass
 
TLBusBy·ssB¬
(
dFn
: 
TLMªag”PÜtP¬am‘”s
 => TLMªag”PÜtP¬am‘”s)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


60 
v®
 
node
 = 
Ãw
 
TLBy·ssNode
(
dFn
)

62 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

63 
v®
 
io
 = 
IO
(
Ãw
 
BundË
 {

64 
v®
 
by·ss
 = 
BoŞ
(
INPUT
)

65 
v®
 
³ndšg
 = 
BoŞ
(
OUTPUT
)

68 
v®
 (
š
, 
edgeIn
èğ
node
.in(0)

69 
v®
 
Seq
((
out0
, 
edgeOut0
), (
out1
, 
edgeOut1
)èğ
node
.
out


71 
»quœe
 (
edgeOut0
.
mªag”
.
b—tBy‹s
 =ğ
edgeOut1
.manager.beatBytes,

72 
s
"BusBypass slave device widths mismatch (${edgeOut0.manager.managers.map(_.name)} has ${edgeOut0.manager.beatBytes}B vs ${edgeOut1.manager.managers.map(_.name)} has ${edgeOut1.manager.beatBytes}B)")

75 
v®
 
	gby·ss
 = 
RegIn™
(
io
.
by·ss
)

76 
v®
 (
æight
, 
Ãxt_æight
èğ
edgeIn
.
šFlight
(
š
)

78 
io
.
³ndšg
 :ğ(
æight
 > 0.U)

79 
wh’
 (
Ãxt_æight
 ==ğ
UIÁ
(0)è{ 
by·ss
 :ğ
io
.bypass }

80 
v®
 
¡®l
 = (
by·ss
 =/ğ
io
.by·ssè&& 
edgeIn
.
fœ¡
(
š
.
a
)

82 
out0
.
a
.
v®id
 :ğ!
¡®l
 && 
š
.a.v®id && 
by·ss


83 
out1
.
a
.
v®id
 :ğ!
¡®l
 && 
š
.a.v®id && !
by·ss


84 
š
.
a
.
»ady
 :ğ!
¡®l
 && 
Mux
(
by·ss
, 
out0
.a.»ady, 
out1
.a.ready)

85 
	gout0
.
	ga
.
	gb™s
 :ğ
š
.
a
.
b™s


86 
out1
.
a
.
b™s
 :ğ
š
.a.bits

88 
out0
.
d
.
»ady
 :ğ
š
.d.»ady && 
by·ss


89 
out1
.
d
.
»ady
 :ğ
š
.d.»ady && !
by·ss


90 
š
.
d
.
v®id
 :ğ
Mux
(
by·ss
, 
out0
.d.v®id, 
out1
.d.valid)

91 
def
 
ÿ¡
(
x
: 
TLBundËD
èğ{ 
v®
 
out
 = 
Wœe
(
š
.
d
.
b™s
); 
	gout
 <> 
	gx
; out }

92 
	gš
.
	gd
.
	gb™s
 :ğ
Mux
(
by·ss
, 
ÿ¡
(
out0
.
d
.
b™s
), ca¡(
out1
.d.bits))

94 ià(
	gedgeIn
.
	gmªag”
.
	gªySuµÜtAcquœeB
 &&ƒdgeIn.
	gş›Á
.
	gªySuµÜtProbe
) {

95 
	gout0
.
	gb
.
	g»ady
 :ğ
š
.
b
.
»ady
 && 
by·ss


96 
out1
.
b
.
»ady
 :ğ
š
.b.»ady && !
by·ss


97 
š
.
b
.
v®id
 :ğ
Mux
(
by·ss
, 
out0
.b.v®id, 
out1
.b.valid)

98 
def
 
ÿ¡
(
x
: 
TLBundËB
èğ{ 
v®
 
out
 = 
Wœe
(
š
.
b
.
b™s
); 
	gout
 <> 
	gx
; out }

99 
	gš
.
	gb
.
	gb™s
 :ğ
Mux
(
by·ss
, 
ÿ¡
(
out0
.
b
.
b™s
), ca¡(
out1
.b.bits))

101 
	gout0
.
	gc
.
	gv®id
 :ğ
š
.
c
.
v®id
 && 
by·ss


102 
out1
.
c
.
v®id
 :ğ
š
.c.v®id && !
by·ss


103 
š
.
c
.
»ady
 :ğ
Mux
(
by·ss
, 
out0
.c.»ady, 
out1
.c.ready)

104 
	gout0
.
	gc
.
	gb™s
 :ğ
š
.
c
.
b™s


105 
out1
.
c
.
b™s
 :ğ
š
.c.bits

107 
out0
.
e
.
v®id
 :ğ
š
.e.v®id && 
by·ss


108 
out1
.
e
.
v®id
 :ğ
š
.e.v®id && !
by·ss


109 
š
.
e
.
»ady
 :ğ
Mux
(
by·ss
, 
out0
.e.»ady, 
out1
.e.ready)

110 
	gout0
.
	ge
.
	gb™s
 :ğ
š
.
e
.
b™s


111 
out1
.
e
.
b™s
 :ğ
š
.e.bits

113 
š
.
b
.
v®id
 :ğ
BoŞ
(
çl£
)

114 
š
.
c
.
»ady
 :ğ
BoŞ
(
Œue
)

115 
š
.
e
.
»ady
 :ğ
BoŞ
(
Œue
)

117 
out0
.
b
.
»ady
 :ğ
BoŞ
(
Œue
)

118 
out0
.
c
.
v®id
 :ğ
BoŞ
(
çl£
)

119 
out0
.
e
.
v®id
 :ğ
BoŞ
(
çl£
)

121 
out1
.
b
.
»ady
 :ğ
BoŞ
(
Œue
)

122 
out1
.
c
.
v®id
 :ğ
BoŞ
(
çl£
)

123 
out1
.
e
.
v®id
 :ğ
BoŞ
(
çl£
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/CLINT.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
Ba£Subsy¡em


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


13 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

15 
objeù
 
	gCLINTCÚ¡s


17 
def
 
msOff£t
(
h¬t
: 
IÁ
èğh¬ˆ* 
msBy‹s


18 
def
 
timecmpOff£t
(
h¬t
: 
IÁ
èğ0x4000 + h¬ˆ* 
timecmpBy‹s


19 
def
 
timeOff£t
 = 0xbff8

20 
def
 
msBy‹s
 = 4

21 
def
 
timecmpBy‹s
 = 8

22 
def
 
size
 = 0x10000

23 
def
 
timeWidth
 = 64

24 
def
 
iWidth
 = 32

25 
def
 
šts
 = 2

28 
şass
 
	$CLINTP¬ams
(
ba£Add»ss
: 
BigIÁ
 = 0x02000000, 
štSges
: 
IÁ
 = 0)

30 
def
 
add»ss
 = 
	`Add»ssS‘
(
ba£Add»ss
, 
CLINTCÚ¡s
.
size
-1)

31 
	}
}

33 
objeù
 
CLINTKey
 
ex‹nds
 
	gF›ld
[
O±iÚ
[
CLINTP¬ams
]](
	gNÚe
)

35 
şass
 
	$CLINT
(
·¿ms
: 
CLINTP¬ams
, 
b—tBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


37 
impÜt
 
CLINTCÚ¡s
.
_


40 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("şšt", 
	`Seq
("riscv,clint0")) {

41 
ov”ride
 
v®
 
®waysEx‹nded
 = 
Œue


44 
v®
 
node
 = 
	`TLRegi¡”Node
(

45 
add»ss
 = 
	`Seq
(
·¿ms
.address),

46 
deviû
 = device,

47 
b—tBy‹s
 = beatBytes)

49 
v®
 
šŠode
 = 
	`IÁNexusNode
(

50 
sourûFn
 = { 
_
 => 
	`IÁSourûPÜtP¬am‘”s
(
	`Seq
(
	`IÁSourûP¬am‘”s
(
šts
, Seq(
	`Resourû
(
deviû
, "int"))))) },

51 
sškFn
 = { 
_
 => 
	`IÁSškPÜtP¬am‘”s
(
	`Seq
(
	`IÁSškP¬am‘”s
())) },

52 
ouutRequœesIÅut
 = 
çl£
)

54 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

55 
AÂÙ©ed
.
	`·¿ms
(
this
, 
·¿ms
)

56 
	`»quœe
 (
šŠode
.
edges
.
š
.
size
 == 0, "CLINT only…roduces interrupts; it does‚ot‡ccepthem")

58 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

59 
v®
 
¹cTick
 = 
	`BoŞ
(
INPUT
)

62 
v®
 
time
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
timeWidth
))

63 
	`wh’
 (
io
.
¹cTick
è{ 
time
 :ğtim+ 
	`UIÁ
(1) }

65 
v®
 
nTes
 = 
šŠode
.
out
.
size


66 
v®
 
timecmp
 = 
Seq
.
	`fl
(
nTes
è{ 
	`Reg
(
	`UIÁ
(
width
 = 
timeWidth
)) }

67 
v®
 
i
 = 
Seq
.
	`fl
(
nTes
è{ 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 1)) }

69 
	`v®
 (
šŠode_out
, 
_
èğ
šŠode
.
out
.
unz


70 
šŠode_out
.
zW™hIndex
.
fÜ—ch
 { (, 
i
) =>

71 (0è:ğ
	`ShiáRegi¡”
(
	`i
(
i
)(0), 
·¿ms
.
štSges
)

72 (1è:ğ
	`ShiáRegi¡”
(
time
.
asUIÁ
 >ğ
	`timecmp
(
i
).asUIÁ, 
·¿ms
.
štSges
)

85 
node
.
	`»gm­
(

86 0 -> 
	`RegF›ldGroup
 ("ms", 
	`Some
("MSIP B™s"), 
i
.
zW™hIndex
.
æ©M­
{ (
r
, 
i
) =>

87 
	`RegF›ld
(1, 
r
, 
	`RegF›ldDesc
(
s
"ms_$i", s"MSIP b™ fÜ H¬ˆ$i", 
»£t
=
	`Some
(0))è:: RegF›ld(
iWidth
 - 1è:: 
N
 }),

88 
	`timecmpOff£t
(0è-> 
timecmp
.
zW™hIndex
.
æ©M­
{ (
t
, 
i
è=> 
	`RegF›ldGroup
(
s
"mtimecmp_$i", 
	`Some
(s"MTIMECMP for hart $i"),

89 
RegF›ld
.
	`by‹s
(
t
, 
	`Some
(
	`RegF›ldDesc
(
s
"mtimecmp_$i", "", 
»£t
=
NÚe
))))},

90 
timeOff£t
 -> 
	`RegF›ldGroup
("mtime", 
	`Some
("Timer Register"),

91 
RegF›ld
.
	`by‹s
(
time
, 
	`Some
(
	`RegF›ldDesc
("mtime", "", 
»£t
=Some(0), vŞ©e=
Œue
))))

94 
	}
}

97 
Œa™
 
	gCªHaveP”h”yCLINT
 { 
	gthis
: 
Ba£Subsy¡em
 =>

98 
v®
 
şštO±
 = 
p
(
CLINTKey
).
m­
 { 
·¿ms
 =>

99 
v®
 
şšt
 = 
LazyModuË
(
Ãw
 
CLINT
(
·¿ms
, 
sbus
.
cÚŒŞ_bus
.
b—tBy‹s
))

100 
	gsbus
.
	gcÚŒŞ_bus
.
toV¬ŸbËWidthSÏve
(
Some
("şšt")è{ 
	gşšt
.
	gnode
 }

101 
	gşšt


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Deadlock.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


13 
şass
 
	$TLD—dlock
(
·¿ms
: 
DevNuÎP¬ams
, 
b—tBy‹s
: 
IÁ
 = 4)(
im¶ic™
 
p
: 
P¬am‘”s
)

14 
ex‹nds
 
	`DevNuÎDeviû
(
·¿ms
, 
b—tBy‹s
, 
Ãw
 
	`Sim¶eDeviû
("d—dlock-deviû", 
	`Seq
("sifive,deadlock0")))

16 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

17 
	`v®
 (
š
, 
_
èğ
node
.
	`š
(0)

18 
š
.
a
.
»ady
 :ğ
	`BoŞ
(
çl£
)

19 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

20 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
çl£
)

21 
š
.
d
.
v®id
 :ğ
	`BoŞ
(
çl£
)

22 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
çl£
)

24 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/DevNull.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
şass
 
	$DevNuÎP¬ams
(

10 
add»ss
: 
Seq
[
Add»ssS‘
],

11 
maxAtomic
: 
IÁ
,

12 
maxT¿nsãr
: 
IÁ
,

13 
»giÚ
: 
RegiÚTy³
.
T
 = RegiÚTy³.
UNCACHEABLE
,

14 
execubË
: 
BoŞ—n
 = 
Œue
,

15 
mayD’yG‘
: 
BoŞ—n
 = 
Œue
,

16 
mayD’yPut
: 
BoŞ—n
 = 
Œue
,

18 
	`»quœe
 (1 <ğ
maxAtomic
, 
s
"Atomicransfer size must be > 1 (was $maxAtomic)")

19 
	`»quœe
 (
maxAtomic
 <ğ
maxT¿nsãr
, 
s
"Atomicransfer size must be <= maxransfer (but $maxAtomic > $maxTransfer)")

20 
	`»quœe
 (
maxT¿nsãr
 <ğ4096, 
s
"Maxransfer size must be <= 4096 (was $maxTransfer)")

21 
def
 
acquœe
: 
BoŞ—n
 = 
»giÚ
 =ğ
RegiÚTy³
.
TRACKED


22 
	}
}

28 
ab¡¿ù
 
şass
 
	$DevNuÎDeviû
(
·¿ms
: 
DevNuÎP¬ams
, 
b—tBy‹s
: 
IÁ
, 
deviû
: 
Sim¶eDeviû
)

29 (
im¶ic™
 
p
: 
P¬am‘”s
)

30 
ex‹nds
 
LazyModuË
 
w™h
 
HasClockDomašCrossšg
 {

31 
v®
 
xãr
 = 
	`T¿nsãrSizes
(1, 
·¿ms
.
maxT¿nsãr
)

32 
v®
 
©om
 = 
	`T¿nsãrSizes
(1, 
·¿ms
.
maxAtomic
)

33 
v®
 
node
 = 
	`TLMªag”Node
(
	`Seq
(
	`TLMªag”PÜtP¬am‘”s
(

34 
	`Seq
(
	`TLMªag”P¬am‘”s
(

35 
add»ss
 = 
·¿ms
.address,

36 
»sourûs
 = 
deviû
.
»g
,

37 
»giÚTy³
 = 
·¿ms
.
»giÚ
,

38 
execubË
 = 
·¿ms
.executable,

39 
suµÜtsAcquœeT
 = ià(
·¿ms
.
acquœe
è
xãr
 
T¿nsãrSizes
.
nÚe
,

40 
suµÜtsAcquœeB
 = ià(
·¿ms
.
acquœe
è
xãr
 
T¿nsãrSizes
.
nÚe
,

41 
suµÜtsG‘
 = 
xãr
,

42 
suµÜtsPutP¬tŸl
 = 
xãr
,

43 
suµÜtsPutFuÎ
 = 
xãr
,

44 
suµÜtsAr™hm‘ic
 = 
©om
,

45 
suµÜtsLogiÿl
 = 
©om
,

46 
suµÜtsHšt
 = 
xãr
,

47 
fifoId
 = 
	`Some
(0),

48 
mayD’yG‘
 = 
·¿ms
.mayDenyGet,

49 
mayD’yPut
 = 
·¿ms
.mayDenyPut,

50 
®waysG¿ÁsT
 = 
·¿ms
.
acquœe
)),

51 
b—tBy‹s
 = beatBytes,

52 
’dSškId
 = ià(
·¿ms
.
acquœe
) 1 0,

53 
mšL©’cy
 = 1)))

54 
v®
 
_xšg
 = 
this
.
	`üossIn
(
node
)

55 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Error.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
impÜt
 
	gsÿÏ
.
	gm©h
.
mš


13 
şass
 
	$TLE¼Ü
(
·¿ms
: 
DevNuÎP¬ams
, 
b—tBy‹s
: 
IÁ
 = 4)(
im¶ic™
 
p
: 
P¬am‘”s
)

14 
ex‹nds
 
	`DevNuÎDeviû
(
·¿ms
, 
b—tBy‹s
, 
Ãw
 
	`Sim¶eDeviû
("”rÜ-deviû", 
	`Seq
("sifive,error0")))

16 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

17 
impÜt
 
TLMes§ges
.
_


18 
impÜt
 
TLP”missiÚs
.
_


20 
	`v®
 (
š
, 
edge
èğ
node
.
	`š
(0)

21 
v®
 
a
 = 
	`Queue
(
š
.a, 1)

22 
v®
 
da
 = 
	`Wœe
(
š
.
d
)

23 
v®
 
idË
 = 
	`RegIn™
(
	`BoŞ
(
Œue
))

25 
v®
 
a_Ï¡
 = 
edge
.
	`Ï¡
(
a
)

26 
	`v®
 (
da_fœ¡
, 
da_Ï¡
, 
_
èğ
edge
.
	`fœ¡Ï¡
(
da
)

28 
	`as£¹
 (
idË
 || 
da_fœ¡
)

29 
a
.
»ady
 :ğ(
da
.»ady && 
da_Ï¡
 && 
idË
è|| !
a_Ï¡


30 
da
.
v®id
 :ğ
a
.v®id && 
a_Ï¡
 && 
idË


32 
da
.
b™s
.
İcode
 :ğ
TLMes§ges
.
	`adRe¥Ú£
(
a
.bits.opcode)

33 
da
.
b™s
.
·¿m
 :ğ
	`UIÁ
(0)

34 
da
.
b™s
.
size
 :ğ
a
.bits.size

35 
da
.
b™s
.
sourû
 :ğ
a
.bits.source

36 
da
.
b™s
.
sšk
 :ğ
	`UIÁ
(0)

37 
da
.
b™s
.
d’›d
 :ğ
	`BoŞ
(
Œue
)

38 
da
.
b™s
.
d©a
 :ğ
	`UIÁ
(0)

39 
da
.
b™s
.
cÜru±
 :ğ
edge
.
	`hasD©a
(da.bits)

41 ià(
·¿ms
.
acquœe
) {

42 
v®
 
c
 = 
	`Queue
(
š
.c, 1)

43 
v®
 
dc
 = 
	`Wœe
(
š
.
d
)

45 
v®
 
c_Ï¡
 = 
edge
.
	`Ï¡
(
c
)

46 
v®
 
dc_Ï¡
 = 
edge
.
	`Ï¡
(
dc
)

49 
	`wh’
 (
da
.
	`fœe
(è&& da.
b™s
.
İcode
 ==ğ
G¿Á
è{ 
idË
 :ğ
	`BoŞ
(
çl£
) }

50 
	`wh’
 (
š
.
e
.
	`fœe
()è{ 
idË
 :ğ
	`BoŞ
(
Œue
) }

52 
c
.
»ady
 :ğ(
dc
.»ady && 
dc_Ï¡
è|| !
c_Ï¡


53 
dc
.
v®id
 :ğ
c
.v®id && 
c_Ï¡


56 
dc
.
b™s
.
İcode
 :ğ
R–—£Ack


57 
dc
.
b™s
.
·¿m
 :ğ
	`Vec
(
toB
, 
toN
,oN)(
c
.bits.param)

58 
dc
.
b™s
.
size
 :ğ
c
.bits.size

59 
dc
.
b™s
.
sourû
 :ğ
c
.bits.source

60 
dc
.
b™s
.
sšk
 :ğ
	`UIÁ
(0)

61 
dc
.
b™s
.
d’›d
 :ğ
	`BoŞ
(
çl£
)

62 
dc
.
b™s
.
d©a
 :ğ
	`UIÁ
(0)

63 
dc
.
b™s
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

66 
TLArb™”
.
	`lowe¡
(
edge
, 
š
.
d
, 
dc
, 
da
)

68 
š
.
d
 <> 
da


72 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

75 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

77 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MaskROM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
Ba£Subsy¡em


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
şass
 
	$MaskROMP¬ams
(
add»ss
: 
BigIÁ
, 
Çme
: 
SŒšg
, 
d•th
: 
IÁ
 = 2048, 
width
: Int = 32)

14 
objeù
 
P”h”yMaskROMKey
 
ex‹nds
 
F›ld
[
Seq
[
MaskROMP¬ams
]]

16 
Œa™
 
HasP”h”yMaskROMSÏve
 { 
this
: 
Ba£Subsy¡em
 =>

17 
v®
 
maskROMP¬ams
 = 
	`p
(
P”h”yMaskROMKey
)

18 
v®
 
maskROMs
 = 
maskROMP¬ams
 
m­
 { 
·¿ms
 =>

19 
v®
 
maskROM
 = 
	`LazyModuË
(
Ãw
 
	`TLMaskROM
(
·¿ms
))

20 
sbus
.
cÚŒŞ_bus
.
	`toFixedWidthSšgËB—tSÏve
(
maskROM
.
b—tBy‹s
, 
	`Some
("MaskROM")è{ maskROM.
node
 }

21 
maskROM


23 
	}
}

25 şas 
	cTLMaskROM
(
c
: 
MaskROMP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

26 
v®
 
b—tBy‹s
 = 
c
.
width
/8

27 
v®
 
node
 = 
	`TLMªag”Node
(
	`Seq
(
	`TLMªag”PÜtP¬am‘”s
(

28 
	`Seq
(
	`TLMªag”P¬am‘”s
(

29 
add»ss
 = 
Add»ssS‘
.
	`mi§ligÃd
(
c
.add»ss, c.
d•th
*
b—tBy‹s
),

30 
»sourûs
 = 
Ãw
 
	`Sim¶eDeviû
("rom", 
	`Seq
("sifive,maskrom0")).
	`»g
("mem"),

31 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

32 
execubË
 = 
Œue
,

33 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

34 
fifoId
 = 
	`Some
(0))),

35 
b—tBy‹s
 = beatBytes)))

37 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

38 
	`v®
 (
š
, 
edge
)ğ
node
.
	`š
(0)

40 
v®
 
rom
 = 
	`ROMG’”©Ü
(
	`ROMCÚfig
(
c
.
Çme
, c.
d•th
, c.
width
))

41 
rom
.
io
.
şock
 := clock

42 
rom
.
io
.
add»ss
 :ğ
edge
.
	`addr_hi
(
š
.
a
.
b™s
.add»s - 
	`UIÁ
(
c
.add»ss))(
	`log2Ce
(c.
d•th
)-1, 0)

43 
rom
.
io
.
Û
 :ğ
	`BoŞ
(
Œue
)

44 
rom
.
io
.
me
 :ğ
š
.
a
.
	`fœe
()

46 
v®
 
d_fuÎ
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

47 
v®
 
d_size
 = 
	`Reg
(
	`UIÁ
())

48 
v®
 
d_sourû
 = 
	`Reg
(
	`UIÁ
())

49 
v®
 
d_d©a
 = 
rom
.
io
.
q
 
hŞdUÆess
 
	`RegNext
(
š
.
a
.
	`fœe
())

52 
	`wh’
 (
š
.
d
.
	`fœe
()è{ 
d_fuÎ
 :ğ
	`BoŞ
(
çl£
) }

53 
	`wh’
 (
š
.
a
.
	`fœe
()è{ 
d_fuÎ
 :ğ
	`BoŞ
(
Œue
) }

54 
š
.
d
.
v®id
 :ğ
d_fuÎ


55 
š
.
a
.
»ady
 :ğš.
d
.»ady || !
d_fuÎ


57 
	`wh’
 (
š
.
a
.
	`fœe
()) {

58 
d_size
 :ğ
š
.
a
.
b™s
.
size


59 
d_sourû
 :ğ
š
.
a
.
b™s
.
sourû


62 
š
.
d
.
b™s
 :ğ
edge
.
	`AcûssAck
(
d_sourû
, 
d_size
, 
d_d©a
)

65 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

66 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

67 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

69 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MasterMux.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
şass
 
Ma¡”MuxNode
(
uFn
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
] => TLCl›ÁPÜtP¬am‘”s)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
TLCu¡omNode


13 
def
 
»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

14 
»quœe
 (
iSrs
 =ğ0 && 
oSrs
 == 0, "MasterMux‚ode does‚ot support :=* or :*=")

15 
»quœe
 (
iKnown
 == 2, "MasterMux‚odeƒxpectsƒxactlywo inputs")

16 
»quœe
 (
oKnown
 == 1, "MasterMux‚odeƒxpectsƒxactly one output")

19 
def
 
m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
]): Seq[TLCl›ÁPÜtP¬am‘”s] = { Seq(
uFn
(p)) }

20 
def
 
m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
TLMªag”PÜtP¬am‘”s
]): Seq[TLManagerPortParameters] = {… ++… }

23 
şass
 
Mu‹Ma¡”
(
Çme
: 
SŒšg
 = "Mu‹Ma¡”", 
maxProbe
: 
IÁ
 = 0)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


25 
v®
 
node
 = 
TLCl›ÁNode
(
Seq
(
TLCl›ÁPÜtP¬am‘”s
(
ş›Ás
 = Seq(
TLCl›ÁP¬am‘”s
(

26 
Çme
 =‚ame,

27 
suµÜtsProbe
 = ià(
maxProbe
 > 0è
T¿nsãrSizes
(1, maxProbeèT¿nsãrSizes.
nÚe
)))))

29 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

30 
v®
 
Seq
((
out
, 
edgeOut
)èğ
node
.out

31 
out
.
a
.
v®id
 :ğ
BoŞ
(
çl£
)

32 
out
.
b
.
»ady
 :ğout.
c
.ready

33 
out
.
c
.
v®id
 :ğout.
b
.valid

34 
out
.
d
.
»ady
 :ğ
BoŞ
(
Œue
)

35 
out
.
e
.
v®id
 :ğ
BoŞ
(
çl£
)

37 
out
.
c
.
b™s
 :ğ
edgeOut
.
ProbeAck
(out.
b
.b™s, 
TLP”missiÚs
.
NtoN
)

41 
şass
 
Ma¡”Mux
(
uFn
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
] => TLCl›ÁPÜtP¬am‘”s)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


43 
v®
 
node
 = 
Ãw
 
Ma¡”MuxNode
(
uFn
)

45 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

46 
v®
 
io
 = 
IO
(
Ãw
 
BundË
 {

47 
v®
 
by·ss
 = 
BoŞ
(
INPUT
)

48 
v®
 
³ndšg
 = 
BoŞ
(
OUTPUT
)

51 
v®
 
Seq
((
š0
, 
edgeIn0
), (
š1
, 
edgeIn1
)èğ
node
.
š


52 
v®
 
Seq
((
out
, 
edgeOut
)èğ
node
.out

55 
v®
 
by·ss
 = 
RegIn™
(
io
.bypass)

56 
v®
 (
æight
, 
Ãxt_æight
èğ
edgeOut
.
šFlight
(
out
)

58 
io
.
³ndšg
 :ğ(
æight
 > 0.U)

59 
wh’
 (
Ãxt_æight
 ==ğ
UIÁ
(0)è{ 
by·ss
 :ğ
io
.bypass }

60 
v®
 
¡®l
 = (
by·ss
 =/ğ
io
.by·ssè&& 
edgeOut
.
fœ¡
(
out
.
a
)

62 
š0
.
a
.
»ady
 :ğ!
¡®l
 && 
out
.a.»ady && 
by·ss


63 
š1
.
a
.
»ady
 :ğ!
¡®l
 && 
out
.a.»ady && !
by·ss


64 
out
.
a
.
v®id
 :ğ!
¡®l
 && 
Mux
(
by·ss
, 
š0
.a.v®id, 
š1
.a.valid)

65 
def
 
ÿ¡A
(
x
: 
TLBundËA
èğ{ 
v®
 
»t
 = 
Wœe
(
out
.
a
.
b™s
); 
	g»t
 <> 
	gx
;„et }

66 
	gout
.
	ga
.
	gb™s
 :ğ
Mux
(
by·ss
, 
ÿ¡A
(
š0
.
a
.
b™s
), ca¡A(
š1
.a.bits))

68 
	gout
.
	gd
.
	g»ady
 :ğ
Mux
(
by·ss
, 
š0
.
d
.
»ady
, 
š1
.d.ready)

69 
	gš0
.
	gd
.
	gv®id
 :ğ
out
.
d
.
v®id
 && 
by·ss


70 
š1
.
d
.
v®id
 :ğ
out
.d.v®id && !
by·ss


71 
š0
.
d
.
b™s
 :ğ
out
.d.bits

72 
š1
.
d
.
b™s
 :ğ
out
.d.bits

74 ià(
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeOut.
ş›Á
.
ªySuµÜtProbe
) {

75 
out
.
b
.
»ady
 :ğ
Mux
(
by·ss
, 
š0
.b.»ady, 
š1
.b.ready)

76 
	gš0
.
	gb
.
	gv®id
 :ğ
out
.
b
.
v®id
 && 
by·ss


77 
š1
.
b
.
v®id
 :ğ
out
.b.v®id && !
by·ss


78 
š0
.
b
.
b™s
 :ğ
out
.b.bits

79 
š1
.
b
.
b™s
 :ğ
out
.b.bits

81 
š0
.
c
.
»ady
 :ğ
out
.c.»ady && 
by·ss


82 
š1
.
c
.
»ady
 :ğ
out
.c.»ady && !
by·ss


83 
out
.
c
.
v®id
 :ğ
Mux
(
by·ss
, 
š0
.c.v®id, 
š1
.c.valid)

84 
def
 
ÿ¡C
(
x
: 
TLBundËC
èğ{ 
v®
 
»t
 = 
Wœe
(
out
.
c
.
b™s
); 
	g»t
 <> 
	gx
;„et }

85 
	gout
.
	gc
.
	gb™s
 :ğ
Mux
(
by·ss
, 
ÿ¡C
(
š0
.
c
.
b™s
), ca¡C(
š1
.c.bits))

87 
	gš0
.
	ge
.
	g»ady
 :ğ
out
.
e
.
»ady
 && 
by·ss


88 
š1
.
e
.
»ady
 :ğ
out
.e.»ady && !
by·ss


89 
out
.
e
.
v®id
 :ğ
Mux
(
by·ss
, 
š0
.e.v®id, 
š1
.e.valid)

90 
def
 
ÿ¡E
(
x
: 
TLBundËE
èğ{ 
v®
 
»t
 = 
Wœe
(
out
.
e
.
b™s
); 
	g»t
 <> 
	gx
;„et }

91 
	gout
.
	ge
.
	gb™s
 :ğ
Mux
(
by·ss
, 
ÿ¡E
(
š0
.
e
.
b™s
), ca¡E(
š1
.e.bits))

93 
	gš0
.
	gb
.
	gv®id
 :ğ
BoŞ
(
çl£
)

94 
š0
.
c
.
»ady
 :ğ
BoŞ
(
Œue
)

95 
š0
.
e
.
»ady
 :ğ
BoŞ
(
Œue
)

97 
š1
.
b
.
v®id
 :ğ
BoŞ
(
çl£
)

98 
š1
.
c
.
»ady
 :ğ
BoŞ
(
Œue
)

99 
š1
.
e
.
»ady
 :ğ
BoŞ
(
Œue
)

101 
out
.
b
.
»ady
 :ğ
BoŞ
(
Œue
)

102 
out
.
c
.
v®id
 :ğ
BoŞ
(
çl£
)

103 
out
.
e
.
v®id
 :ğ
BoŞ
(
çl£
)

109 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


111 şas 
	cTLMa¡”MuxTe¡”
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

112 
v®
 
fuzz1
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

113 
v®
 
fuzz2
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

114 
v®
 
mod–1
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("MasterMux1"))

115 
v®
 
mod–2
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("MasterMux2"))

116 
v®
 
mux
 = 
	`LazyModuË
(
Ãw
 
	$Ma¡”Mux
(
uFn
 = 
_
.
h—d
))

117 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0, 0x3ff), 
b—tBy‹s
 = 4))

118 
mux
.
node
 :ğ
	`TLF‹r
(
TLF‹r
.
	`mS–eùIÁ”£ù
(
	`Add»ssS‘
Ğ0, ~16))è:ğ
mod–1
.nod:ğ
fuzz1
.node

119 
mux
.
node
 :ğ
	`TLF‹r
(
TLF‹r
.
	`mS–eùIÁ”£ù
(
	`Add»ssS‘
(16, ~16))è:ğ
mod–2
.nod:ğ
fuzz2
.node

120 
¿m
.
node
 :ğ
	$TLF¿gm’‹r
(4, 16è:ğ
mux
.
node


123 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

124 
io
.
fšished
 :ğ
fuzz1
.
moduË
.io.fšished && 
fuzz2
.module.io.finished

125 
mux
.
moduË
.
io
.
by·ss
 :ğ
	`LFSR64
(
	`BoŞ
(
Œue
))(0)

127 
	}
}

129 
şass
 
	$TLMa¡”MuxTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

130 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLMa¡”MuxTe¡”
(
txns
)).
moduË
)

131 
io
 <> 
dut
.io

132 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/PhysicalFilter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
şass
 
	$DeviûPMPP¬ams
(
add»ssB™s
: 
IÁ
, 
·geB™s
: Int)

13 şas 
	cDeviûPMP
(
·¿ms
: 
DeviûPMPP¬ams
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

15 
	`»quœe
 (
·¿ms
.
add»ssB™s
 >…¬ams.
·geB™s
)

17 
v®
 
l
 = 
	$UIÁ
(
width
 = 1)

18 
v®
 
a
 = 
	$UIÁ
(
width
 = 1)

19 
v®
 
r
 = 
	$UIÁ
(
width
 = 1)

20 
v®
 
w
 = 
	$UIÁ
(
width
 = 1)

22 
v®
 
addr_hi
 = 
	`UIÁ
(
width
 = 
·¿ms
.
add»ssB™s
-·¿ms.
·geB™s
)

23 
def
 
add»ss
 = 
	`C©
(
addr_hi
, 
	$UIÁ
(0, 
width
=
·¿ms
.
·geB™s
))

24 
def
 
blockPriÜAdd»ss
 = 
	`l
(0è&& 
	$a
(0)

26 
def
 
	$f›lds
(
blockAdd»ss
: 
BoŞ
): 
Seq
[
RegF›ld
] = {

27 
def
 
	`f›ld
(
b™s
: 
IÁ
, 
»g
: 
UIÁ
, 
lock
: 
BoŞ
 = 
	`l
(0)) =

28 
	`RegF›ld
(
b™s
, 
	`RegR—dFn
(
»g
), 
	`RegWr™eFn
((
w’
, 
d©a
) => {

29 
	`wh’
 (
w’
 && !
lock
è{ 
»g
 :ğ
d©a
 }

30 
	`BoŞ
(
Œue
)

32 
	`Seq
(

33 
	`RegF›ld
(
·¿ms
.
·geB™s
-2),

34 
	`f›ld
(
·¿ms
.
add»ssB™s
-·¿ms.
·geB™s
, 
addr_hi
, 
	`l
(0è|| 
blockAdd»ss
),

35 
	`RegF›ld
(56 - (
·¿ms
.
add»ssB™s
-2)),

36 
	`f›ld
(1, 
r
),

37 
	`f›ld
(1, 
w
),

38 
	`RegF›ld
(1),

39 
	`f›ld
(1, 
a
),

40 
	`RegF›ld
(3),

41 
	`f›ld
(1, 
l
))

43 
	}
}

45 
şass
 
	$PMPIn™ŸlV®ue
(
add»ss
: 
BigIÁ
 = 0, 
l
: 
BoŞ—n
 = 
çl£
, 
a
: BoŞ—Àğçl£, 
r
: BoŞ—Àğçl£, 
w
: Boolean = false)

47 
objeù
 
DeviûPMP


49 
def
 
	`­¶y
(
add»ssB™s
: 
IÁ
, 
·geB™s
: IÁ, 
š™Ÿl
: 
O±iÚ
[
PMPIn™ŸlV®ue
] = 
NÚe
) = {

50 
v®
 
out
 = 
	`Wœe
(
Ãw
 
	`DeviûPMP
(
	`DeviûPMPP¬ams
(
add»ssB™s
, 
·geB™s
)))

52 
š™Ÿl
.
fÜ—ch
 { 
i
 =>

53 
	`»quœe
 ((
i
.
add»ss
 >> 
add»ssB™s
) == 0)

54 
	`»quœe
 ((
i
.
add»ss
 >> 
·geB™s
) <<…ageBits == i.address)

55 
out
.
addr_hi
 :ğ
	`UIÁ
(
i
.
add»ss
 >> 
·geB™s
)

58 
def
 
	`g‘
(
f
: 
PMPIn™ŸlV®ue
 => 
BoŞ—n
èğ
š™Ÿl
.
	`m­
(
x
 => 
	`BoŞ
(
	`f
(x)).
asUIÁ
).
	`g‘OrEl£
(
	`UIÁ
(0))

59 
out
.
l
 :ğ
	`g‘
(
_
.l)

60 
out
.
a
 :ğ
	`g‘
(
_
.a)

61 
out
.
r
 :ğ
	`g‘
(
_
.r)

62 
out
.
w
 :ğ
	`g‘
(
_
.w)

63 
out


65 
	}
}

74 
şass
 
PhysiÿlF‹rP¬ams
(

75 
cÚŒŞAdd»ss
: 
BigIÁ
,

76 
cÚŒŞB—tBy‹s
: 
IÁ
,

77 
pmpRegi¡”s
: 
Seq
[
PMPIn™ŸlV®ue
] = Seq.
	$fl
(4è{ 
	`PMPIn™ŸlV®ue
(è
	}
} )

79 
v®
 
·ge
 = 4096

80 
v®
 
·geB™s
 = 
log2Ce
(
·ge
)

81 
v®
 
size
 = (((
pmpRegi¡”s
.siz* 8è+ 
·ge
 - 1) /…age) *…age

83 
»quœe
 (!
pmpRegi¡”s
.
isEm±y
)

84 
»quœe
 (
cÚŒŞAdd»ss
 > 0)

85 
»quœe
 (
cÚŒŞAdd»ss
 % 
size
 == 0)

86 
»quœe
 (
cÚŒŞB—tBy‹s
 > 0 && 
isPow2
(controlBeatBytes))

89 şas 
	cPhysiÿlF‹r
(
·¿ms
: 
PhysiÿlF‹rP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


91 
v®
 
node
 = 
	`TLAd­‹rNode
(
mªag”Fn
 = { 
mp
 => mp.
	`cİy
(

92 
mªag”s
 = 
mp
.mªag”s.
	`m­
(
_
.
	`cİy
(
®waysG¿ÁsT
 = 
çl£
)),

93 
’dSškId
 = ià(
mp
.endSinkId == 0) { 0 } { mp.endSinkId+1 },

94 
mšL©’cy
 = 1 
mš
 
mp
.minLatency)})

96 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("physiÿl-f‹r", 
	`Seq
("sifive,physical-filter-v0"))

97 
v®
 
cÚŒŞNode
 = 
	`TLRegi¡”Node
(

98 
add»ss
 = 
	`Seq
(
	`Add»ssS‘
(
·¿ms
.
cÚŒŞAdd»ss
,…¬ams.
size
-1)),

99 
deviû
 = device,

100 
b—tBy‹s
 = 
·¿ms
.
cÚŒŞB—tBy‹s
)

102 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

104 
v®
 
add»ssB™s
 = 
	`log2Ce
(
node
.
edges
.
out
.
	`m­
(
_
.
mªag”
.
maxAdd»ss
).
max
+1+1)

105 
v®
 
pmps
 = 
	`RegIn™
(
	`Vec
(
·¿ms
.
pmpRegi¡”s
.
m­
 { 
iv®
 => 
	`DeviûPMP
(
add»ssB™s
,…¬ams.
·geB™s
, 
	`Some
(ival)) }))

106 
v®
 
blocks
 = 
pmps
.

.
	`m­
(
_
.
blockPriÜAdd»ss
è:+ 
	`BoŞ
(
çl£
)

107 
cÚŒŞNode
.
	`»gm­
(0 -> (
pmps
 
z
 
blocks
).
m­
 { (
p
, 
b
è=>….
	`f›lds
(bè}.
toLi¡
.
æ©‹n
)

109 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

110 
out
 <> 
š


113 
v®
 
mySškId
 = 
	`UIÁ
(
edgeOut
.
mªag”
.
’dSškId
)

114 
v®
 
a_fœ¡
 = 
edgeIn
.
	`fœ¡
(
š
.
a
)

115 
	`v®
 (
d_fœ¡
, 
d_Ï¡
, 
_
èğ
edgeIn
.
	`fœ¡Ï¡
(
š
.
d
)

118 
v®
 
ÃedW
 = 
š
.
a
.
b™s
.
İcode
 =/ğ
TLMes§ges
.
G‘
 &&

119 (
š
.
a
.
b™s
.
İcode
 =/ğ
TLMes§ges
.
AcquœeBlock
 ||

120 
š
.
a
.
b™s
.
·¿m
 =/ğ
TLP”missiÚs
.
NtoB
 ||

121 
	`BoŞ
(!
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
))

122 
v®
 
ÃedR
 = 
š
.
a
.
b™s
.
İcode
 =/ğ
TLMes§ges
.
PutFuÎD©a
 &&

123 
š
.
a
.
b™s
.
İcode
 =/ğ
TLMes§ges
.
PutP¬tŸlD©a


124 
v®
 
É
 = 
	`BoŞ
(
çl£
è+: 
pmps
.
	`m­
(
š
.
a
.
b™s
.
add»ss
 < 
_
.address)

125 
v®
 
£l
 = (
pmps
.
	`m­
(
_
.
a
è
	`z
 (
É
.
š™
 
z
†t.

)è
m­
 { ×, (
l
, 
r
)è=> 
	`a
(0) && !l &&„ }

126 
v®
 
ok
 = 
pmps
.
	`m­
(
p
 => (p.
	`r
(0è|| !
ÃedR
è&& (p.
	`w
(0è|| !
ÃedW
))

127 
v®
 
®lowFœ¡
 = 
	`PriÜ™yMux
(
£l
 :+ 
	`BoŞ
(
Œue
), 
ok
 :+ BoŞ(
çl£
))

128 
v®
 
®low
 = 
®lowFœ¡
 
hŞdUÆess
 
a_fœ¡


131 
v®
 
d_¿ck
 = 
	`BoŞ
(
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
è&& 
š
.
d
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
R–—£Ack


132 
v®
 
æight
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
	`log2Ce
(
edgeIn
.
ş›Á
.
’dSourûId
+1+1)))

133 
v®
 
d’yWa™
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

134 
æight
 :ğæighˆ+ (
a_fœ¡
 && 
š
.
a
.
	`fœe
()è- (
d_Ï¡
 && !
d_¿ck
 && in.
d
.fire())

137 
v®
 
d’y_»ady
 = !
d’yWa™
 && 
æight
 ==ğ
	`UIÁ
(0)

138 
š
.
a
.
»ady
 :ğ
	`Mux
(
®low
, 
out
.a.»ady, !
a_fœ¡
 || 
d’y_»ady
)

139 
out
.
a
.
v®id
 :ğ
š
.a.v®id && 
®low


142 
v®
 
d’yV®id
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

143 
v®
 
d’y
 = 
	`Reg
(
š
.
d
.
b™s
)

144 
v®
 
d_İcode
 = 
TLMes§ges
.
	`adRe¥Ú£
(
š
.
a
.
b™s
.
İcode
)

145 
v®
 
d_g¿Á
 = 
	`BoŞ
(
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
è&& 
d’y
.
İcode
 ==ğ
TLMes§ges
.
G¿Á


146 
	`wh’
 (
š
.
a
.
v®id
 && !
®low
 && 
d’y_»ady
 && 
a_fœ¡
) {

147 
d’yV®id
 :ğ
	`BoŞ
(
Œue
)

148 
d’yWa™
 :ğ
	`BoŞ
(
Œue
)

149 
d’y
.
İcode
 :ğ
d_İcode


150 
d’y
.
·¿m
 :ğ
	`UIÁ
(0)

151 
d’y
.
size
 :ğ
š
.
a
.
b™s
.size

152 
d’y
.
sourû
 :ğ
š
.
a
.
b™s
.source

153 
d’y
.
sšk
 :ğ
mySškId


154 
d’y
.
d’›d
 :ğ
	`BoŞ
(
Œue
)

155 
d’y
.
d©a
 :ğ
	`UIÁ
(0)

156 
d’y
.
cÜru±
 :ğ
	`d_İcode
(0)

158 
	`wh’
 (
d’yV®id
 && 
š
.
d
.
»ady
 && 
d_Ï¡
) {

159 
d’yV®id
 :ğ
	`BoŞ
(
çl£
)

160 
	`wh’
 (!
d_g¿Á
) {

161 
d’yWa™
 :ğ
	`BoŞ
(
çl£
)

165 
v®
 
out_d
 = 
	`Wœe
(
š
.
d
.
b™s
)

166 
out_d
 :ğ
out
.
d
.
b™s


171 
š
.
d
.
v®id
 :ğ
out
.d.v®id || 
d’yV®id


172 
out
.
d
.
»ady
 :ğ!
d’yV®id
 && 
š
.d.ready

173 
š
.
d
.
b™s
 :ğ
	`Mux
(
d’yV®id
, 
d’y
, 
out_d
)

176 ià(
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
) {

177 
v®
 
wSourûVec
 = 
	`Reg
(
	`Vec
(
edgeIn
.
ş›Á
.
’dSourûId
, 
	`BoŞ
()))

178 
v®
 
aWOk
 = 
	`PriÜ™yMux
(
£l
, 
pmps
.
	`m­
(
_
.
	`w
(0)))

179 
v®
 
dWOk
 = 
	`wSourûVec
(
š
.
d
.
b™s
.
sourû
)

180 
v®
 
by·ss
 = 
	`BoŞ
(
edgeIn
.
mªag”
.
mšL©’cy
 =ğ0è&& 
š
.
a
.
v®id
 && in.a.
b™s
.
sourû
 ==ğš.
d
.bits.source

181 
v®
 
d_g¿Á
 = 
š
.
d
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
G¿Á
 || in.d.b™s.İcod==ğTLMes§ges.
G¿ÁD©a


182 
v®
 
dWH–d
 = 
	`Mux
(
by·ss
, 
aWOk
, 
dWOk
è
hŞdUÆess
 
d_fœ¡


184 
	`wh’
 (
d_g¿Á
 && !
dWH–d
) {

185 
š
.
d
.
b™s
.
·¿m
 :ğ
TLP”missiÚs
.
toB


188 
	`wh’
 (
š
.
a
.
	`fœe
(è&& 
a_fœ¡
) {

189 
	`wSourûVec
(
š
.
a
.
b™s
.
sourû
è:ğ
aWOk


192 
edgeIn
.
ş›Á
.
unu£dSourûs
.
fÜ—ch
 { 
id
 =>

193 
	`wSourûVec
(
id
è:ğ
	`BoŞ
(
Œue
)

197 
v®
 
isMyId
 = 
mySškId
 ==ğ
š
.
e
.
b™s
.
sšk


198 
out
.
e
.
v®id
 :ğ
š
.e.v®id && !
isMyId


199 
š
.
e
.
»ady
 :ğ
out
.e.»ady || 
isMyId


201 
	`wh’
 (
š
.
e
.
	`fœe
(è&& 
isMyId
) {

202 
d’yWa™
 :ğ
	`BoŞ
(
çl£
)

206 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Plic.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
Ba£Subsy¡em


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


15 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


16 
impÜt
 
	gsÿÏ
.
	gm©h
.
mš


18 şas 
	cG©ewayPLICIO
 
ex‹nds
 
	mBundË
 {

19 
v®
 
	mv®id
 = 
	$BoŞ
(
OUTPUT
)

20 
v®
 
»ady
 = 
	$BoŞ
(
INPUT
)

21 
v®
 
com¶‘e
 = 
	`BoŞ
(
INPUT
)

24 şas 
	cLev–G©eway
 
ex‹nds
 
ModuË
 {

25 
v®
 
io
 = 
Ãw
 
BundË
 {

26 
v®
 
š‹¼u±
 = 
	`BoŞ
(
INPUT
)

27 
v®
 
¶ic
 = 
Ãw
 
G©ewayPLICIO


30 
v®
 
šFlight
 = 
	`Reg
(
š™
=
	$BoŞ
(
çl£
))

31 
	$wh’
 (
io
.
š‹¼u±
 && io.
¶ic
.
»ady
è{ 
šFlight
 :ğ
Œue
 
	}
}

32 
	$wh’
 (
io
.
¶ic
.
com¶‘e
è{ 
šFlight
 :ğ
çl£
 
	}
}

33 
io
.
¶ic
.
v®id
 :ğio.
š‹¼u±
 && !
šFlight


36 
objeù
 
PLICCÚ¡s


38 
def
 
maxDeviûs
 = 1023

39 
def
 
maxH¬ts
 = 15872

40 
def
 
´iÜ™yBa£
 = 0x0

41 
def
 
³ndšgBa£
 = 0x1000

42 
def
 
’abËBa£
 = 0x2000

43 
def
 
h¬tBa£
 = 0x200000

45 
def
 
şaimOff£t
 = 4

46 
def
 
´iÜ™yBy‹s
 = 4

48 
def
 
’abËOff£t
(
i
: 
IÁ
èğ˜* ((
maxDeviûs
+7)/8)

49 
def
 
h¬tOff£t
(
i
: 
IÁ
) = i * 0x1000

50 
def
 
’abËBa£
(
i
: 
IÁ
):IÁ = 
’abËOff£t
(i) +ƒnableBase

51 
def
 
h¬tBa£
(
i
: 
IÁ
):IÁ = 
h¬tOff£t
(i) + hartBase

53 
def
 
size
 = 
h¬tBa£
(
maxH¬ts
)

54 
»quœe
(
h¬tBa£
 >ğ
’abËBa£
(
maxH¬ts
))

57 
şass
 
	$PLICP¬ams
(
ba£Add»ss
: 
BigIÁ
 = 0xC000000, 
maxPriÜ™›s
: 
IÁ
 = 7, 
štSges
: Int = 0)

59 
	`»quœe
 (
maxPriÜ™›s
 >= 0)

60 
def
 
add»ss
 = 
	`Add»ssS‘
(
ba£Add»ss
, 
PLICCÚ¡s
.
size
-1)

61 
	}
}

63 
objeù
 
PLICKey
 
ex‹nds
 
	gF›ld
[
O±iÚ
[
PLICP¬ams
]](
	gNÚe
)

66 
şass
 
	$TLPLIC
(
·¿ms
: 
PLICP¬ams
, 
b—tBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


69 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("š‹¼u±-cÚŒŞËr", 
	`Seq
("riscv,plic0")) {

70 
ov”ride
 
v®
 
®waysEx‹nded
 = 
Œue


71 
ov”ride
 
def
 
	`desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

72 
v®
 
	`DesütiÚ
(
Çme
, 
m­pšg
èğ
su³r
.
	`desüibe
(
»sourûs
)

73 
v®
 
exŒa
 = 
	`M­
(

74 "š‹¼u±-cÚŒŞËr" -> 
N
,

75 "riscv,ndev" -> 
	`Seq
(
	`ResourûIÁ
(
nDeviûs
)),

76 "riscv,max-´iÜ™y" -> 
	`Seq
(
	`ResourûIÁ
(
nPriÜ™›s
)),

77 "#š‹¼u±-ûÎs" -> 
	`Seq
(
	`ResourûIÁ
(1)))

78 
	`DesütiÚ
(
Çme
, 
m­pšg
 ++ 
exŒa
)

82 
v®
 
node
 = 
	`TLRegi¡”Node
(

83 
add»ss
 = 
	`Seq
(
·¿ms
.address),

84 
deviû
 = device,

85 
b—tBy‹s
 = beatBytes,

86 
undefZ”o
 = 
Œue
,

87 
cÚcu¼’cy
 = 1)

89 
v®
 
šŠode
 = 
	`IÁNexusNode
(

90 
sourûFn
 = { 
_
 => 
	`IÁSourûPÜtP¬am‘”s
(
	`Seq
(
	`IÁSourûP¬am‘”s
(1, Seq(
	`Resourû
(
deviû
, "int"))))) },

91 
sškFn
 = { 
_
 => 
	`IÁSškPÜtP¬am‘”s
(
	`Seq
(
	`IÁSškP¬am‘”s
())) },

92 
ouutRequœesIÅut
 = 
çl£
,

93 
šputRequœesOuut
 = 
çl£
)

96 
def
 
nDeviûs
: 
IÁ
 = 
šŠode
.
edges
.
š
.
	`m­
(
_
.
sourû
.
num
).
sum


97 
def
 
mšPriÜ™›s
 = 
	`mš
(
·¿ms
.
maxPriÜ™›s
, 
nDeviûs
)

98 
def
 
nPriÜ™›s
 = (1 << 
	`log2Ce
(
mšPriÜ™›s
+1)) - 1

99 
def
 
nH¬ts
 = 
šŠode
.
edges
.
out
.
	`m­
(
_
.
sourû
.
num
).
sum


102 
Ïzy
 
v®
 
sourûs
 = 
šŠode
.
edges
.
š
.
	`m­
(
_
.
sourû
)

103 
Ïzy
 
v®
 
æ©Sourûs
 = (
sourûs
 
z
 sourûs.
	`m­
(
_
.
num
).
	`sÿnLeá
(0)(_+_).
š™
).
m­
 {

104 (
s
, 
o
è=> s.
sourûs
.
	`m­
(
z
 => z.
	`cİy
(
¿nge
 = z.¿nge.
	`off£t
(o)))

105 }.
æ©‹n


107 
ResourûBšdšg
 {

108 
æ©Sourûs
.
fÜ—ch
 { 
s
 => s.
»sourûs
.fÜ—ch { 
r
 =>

110 (
s
.
¿nge
.
¡¬t
 
uÁ
 s.¿nge.
’d
).
fÜ—ch
 { 
i
 => 
r
.
	`bšd
(
deviû
, 
	`ResourûIÁ
(i+1)) }

114 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

115 
AÂÙ©ed
.
	`·¿ms
(
this
, 
·¿ms
)

117 
	`v®
 (
io_deviûs
, 
edgesIn
èğ
šŠode
.
š
.
unz


118 
	`v®
 (
io_h¬ts
, 
_
èğ
šŠode
.
out
.
unz


121 
v®
 
š‹¼u±s
 = 
šŠode
.
š
.
m­
 { (
i
, 
e
è=> i.
	`ke
Ó.
sourû
.
num
è}.
æ©‹n


123 
v®
 
h¬ts
 = 
io_h¬ts
.
æ©‹n


125 
	`´šn
(
s
"Interrupt map (${nHarts} harts ${nDevices} interrupts):")

126 
æ©Sourûs
.
fÜ—ch
 { 
s
 =>

128 
	`´šn
(
s
" [${s.range.start+1}, ${s.range.end}] => ${s.name}")

130 
	`´šn
("")

132 
	`»quœe
 (
nDeviûs
 =ğ
š‹¼u±s
.
size
, 
s
"Must be:‚Devices=$nDevices == interrupts.size=${interrupts.size}")

133 
	`»quœe
 (
nH¬ts
 =ğ
h¬ts
.
size
, 
s
"Must be:‚Harts=$nHarts == harts.size=${harts.size}")

135 
	`»quœe
(
nDeviûs
 <ğ
PLICCÚ¡s
.
maxDeviûs
, 
s
"Must be:‚Devices=$nDevices <= PLICConsts.maxDevices=${PLICConsts.maxDevices}")

136 
	`»quœe
(
nH¬ts
 > 0 &&‚H¬t <ğ
PLICCÚ¡s
.
maxH¬ts
, 
s
"Must be:‚Harts=$nHarts > 0 &&‚Harts <= PLICConsts.maxHarts=${PLICConsts.maxHarts}")

139 
v®
 
g©eways
 = 
š‹¼u±s
.
m­
 { 
i
 =>

140 
v®
 
g©eway
 = 
	`ModuË
(
Ãw
 
Lev–G©eway
)

141 
g©eway
.
io
.
š‹¼u±
 :ğ
i


142 
g©eway
.
io
.
¶ic


145 
v®
 
´ioB™s
 = 
	`log2Ce
(
nPriÜ™›s
+1)

146 
v®
 
´iÜ™y
 =

147 ià(
nPriÜ™›s
 > 0è
	`Reg
(
	`Vec
(
nDeviûs
, 
	`UIÁ
(
width
=
´ioB™s
)))

148 
	`Wœe
(
š™
=
Vec
.
	`fl
(
nDeviûs
)(
	`UIÁ
(1)))

149 
v®
 
th»shŞd
 =

150 ià(
nPriÜ™›s
 > 0è
	`Reg
(
	`Vec
(
nH¬ts
, 
	`UIÁ
(
width
=
´ioB™s
)))

151 
	`Wœe
(
š™
=
Vec
.
	`fl
(
nH¬ts
)(
	`UIÁ
(0)))

152 
v®
 
³ndšg
 = 
	`Reg
(
š™
=
Vec
.
	`fl
(
nDeviûs
){
	`BoŞ
(
çl£
)})

155 
v®
 
fœ¡EÇbË
 = 
nDeviûs
 
mš
 7

156 
v®
 
fuÎEÇbËs
 = (
nDeviûs
 - 
fœ¡EÇbË
) / 8

157 
v®
 
EÇbË
 = 
nDeviûs
 - 
fœ¡EÇbË
 - 8*
fuÎEÇbËs


158 
def
 
’abËRegs
 = (
	`Reg
(
	`UIÁ
(
width
 = 
fœ¡EÇbË
)) +:

159 
Seq
.
	`fl
(
fuÎEÇbËs
è{ 
	`Reg
(
	`UIÁ
(
width
 = 8)) }) ++

160 (ià(
EÇbË
 > 0è
	`Some
(
	`Reg
(
	`UIÁ
(
width
 =aEÇbË))è
NÚe
)

161 
v®
 
’abËs
 = 
Seq
.
	`fl
(
nH¬ts
è{ 
’abËRegs
 }

162 
v®
 
’abËVec
 = 
	`Vec
(
’abËs
.
	`m­
(
x
 => 
	`C©
(x.
»v”£
)))

163 
v®
 
’abËVec0
 = 
	`Vec
(
’abËVec
.
	`m­
(
x
 => 
	`C©
(x, 
	`UIÁ
(0, 
width
=1))))

165 
v®
 
maxDevs
 = 
	`Reg
(
	`Vec
(
nH¬ts
, 
	`UIÁ
(
width
 = 
	`log2Ce
(
nDeviûs
+1))))

166 
v®
 
³ndšgUIÁ
 = 
	`C©
(
³ndšg
.
»v”£
)

167 
h¬t
 <- 0 
uÁ
 
nH¬ts
) {

168 
v®
 
çnš
 = 
	`ModuË
(
Ãw
 
	`PLICFªIn
(
nDeviûs
, 
´ioB™s
))

169 
çnš
.
io
.
´io
 :ğ
´iÜ™y


170 
çnš
.
io
.

 :ğ
	`’abËVec
(
h¬t
è& 
³ndšgUIÁ


171 
	`maxDevs
(
h¬t
è:ğ
çnš
.
io
.
dev


172 
	`h¬ts
(
h¬t
è:ğ
	`ShiáRegi¡”
(
	`Reg
(
Ãxt
 = 
çnš
.
io
.
max
è> 
	`th»shŞd
(h¬t), 
·¿ms
.
štSges
)

175 
def
 
	`´iÜ™yRegDesc
(
i
: 
IÁ
) =

176 
	`RegF›ldDesc
(

177 
Çme
 = 
s
"priority_$i",

178 
desc
 = 
s
"Acting…riority of interrupt source $i",

179 
group
 = 
	`Some
("priority"),

180 
groupDesc
 = 
	`Some
("Acting…riorities ofƒach interrupt source."),

181 
»£t
 = ià(
nPriÜ™›s
 > 0è
NÚe
 
	`Some
(1))

183 
def
 
	`³ndšgRegDesc
(
i
: 
IÁ
) =

184 
	`RegF›ldDesc
(

185 
Çme
 = 
s
"pending_$i",

186 
desc
 = 
s
"Seto 1 if interrupt source $i is…ending,„egardless of itsƒnable or…riority setting.",

187 
group
 = 
	`Some
("pending"),

188 
groupDesc
 = 
	`Some
("Pending Bit Array. 1 Bit forƒach interrupt source."),

189 vŞ©ğ
Œue
)

191 
def
 
	`’abËRegDesc
(
i
: 
IÁ
, 
j
: IÁ, 
wide
: Int) = {

192 
v®
 
low
 = ià(
j
 == 0) 1 j*8

193 
v®
 
high
 = 
low
 + 
wide
 - 1

194 
	`RegF›ldDesc
(

195 
Çme
 = 
s
"enables_${j}",

196 
desc
 = 
s
"Targets ${low}-${high}. Set bitso 1 if interrupt should beƒnabled.",

197 
group
 = 
	`Some
(
s
"enables_${i}"),

198 
groupDesc
 = 
	`Some
(
s
"Enable bits forƒach interrupt source forarget $i. 1 bit forƒach interrupt source."))

201 
def
 
	`´iÜ™yRegF›ld
(
x
: 
UIÁ
, 
i
: 
IÁ
) =

202 ià(
nPriÜ™›s
 > 0) {

203 
	`RegF›ld
(
´ioB™s
, 
x
, 
	`´iÜ™yRegDesc
(
i
))

205 
RegF›ld
.
	`r
(
´ioB™s
, 
x
, 
	`´iÜ™yRegDesc
(
i
))

208 
v®
 
´iÜ™yRegF›lds
 = 
´iÜ™y
.
zW™hIndex
.
m­
 { (
p
, 
i
) =>

209 
PLICCÚ¡s
.
´iÜ™yBa£
+4*(
i
+1è-> 
	`Seq
(
	`´iÜ™yRegF›ld
(
p
, i+1)) }

210 
v®
 
³ndšgRegF›lds
 = 
	`Seq
(
PLICCÚ¡s
.
³ndšgBa£
 ->

211 (
	`RegF›ld
(1è+: 
³ndšg
.
zW™hIndex
.
m­
 { (
b
, 
i
è=> 
RegF›ld
.
	`r
(1, b, 
	`³ndšgRegDesc
(i+1))}))

212 
v®
 
’abËRegF›lds
 = 
’abËs
.
zW™hIndex
.
m­
 { (
e
, 
i
) =>

213 
PLICCÚ¡s
.
	`’abËBa£
(
i
è-> (
	`RegF›ld
(1è+: 
e
.
zW™hIndex
.
m­
 { (
x
, 
j
) =>

214 
	`RegF›ld
(
x
.
g‘Width
, x, 
	`’abËRegDesc
(
i
, 
j
, x.getWidth)) }) }

222 
v®
 
şaim”
 = 
	`Wœe
(
	`Vec
(
nH¬ts
, 
	`BoŞ
()))

223 
	`as£¹
((
şaim”
.
asUIÁ
 & (şaim”.asUIÁ - 
	`UIÁ
(1))) === UInt(0))

224 
v®
 
şaimšg
 = 
Seq
.
	`buÏ‹
(
nH¬ts
){
i
 => 
	`Mux
(
	`şaim”
(i), 
	`maxDevs
(i), 
	`UIÁ
(0))}.
	`»duûLeá
(
_
|_)

225 
v®
 
şaimedDevs
 = 
	`Vec
(
	`UIÁToOH
(
şaimšg
, 
nDeviûs
+1).
toBoŞs
)

227 ((
³ndšg
 
z
 
g©eways
èz 
şaimedDevs
.

è
fÜ—ch
 { ((
p
, 
g
), 
c
) =>

228 
g
.
»ady
 :ğ!
p


229 
	`wh’
 (
c
 || 
g
.
v®id
è{ 
p
 := !c }

239 
v®
 
com¶‘”
 = 
	`Wœe
(
	`Vec
(
nH¬ts
, 
	`BoŞ
()))

240 
	`as£¹
((
com¶‘”
.
asUIÁ
 & (com¶‘”.asUIÁ - 
	`UIÁ
(1))) === UInt(0))

241 
v®
 
com¶‘”Dev
 = 
	`Wœe
(
	`UIÁ
(
width
 = 
	`log2Up
(
nDeviûs
 + 1)))

242 
v®
 
com¶‘edDevs
 = 
	`Mux
(
com¶‘”
.
	`»duû
(
_
 || _), 
	`UIÁToOH
(
com¶‘”Dev
, 
nDeviûs
+1), 
	`UIÁ
(0))

243 (
g©eways
 
z
 
com¶‘edDevs
.
toBoŞs
.

è
fÜ—ch
 { (
g
, 
c
) =>

244 
g
.
com¶‘e
 :ğ
c


247 
def
 
	`th»shŞdRegDesc
(
i
: 
IÁ
) =

248 
	`RegF›ldDesc
(

249 
Çme
 = 
s
"threshold_$i",

250 
desc
 = 
s
"Interrupt & claimhreshold forarget $i. Maximum value is ${nPriorities}.",

251 
»£t
 = ià(
nPriÜ™›s
 > 0è
NÚe
 
	`Some
(1))

253 
def
 
	`th»shŞdRegF›ld
(
x
: 
UIÁ
, 
i
: 
IÁ
) =

254 ià(
nPriÜ™›s
 > 0) {

255 
	`RegF›ld
(
´ioB™s
, 
x
, 
	`th»shŞdRegDesc
(
i
))

257 
RegF›ld
.
	`r
(
´ioB™s
, 
x
, 
	`th»shŞdRegDesc
(
i
))

260 
v®
 
h¬tRegF›lds
 = 
Seq
.
	`buÏ‹
(
nH¬ts
è{ 
i
 =>

261 
PLICCÚ¡s
.
	`h¬tBa£
(
i
è-> 
	`Seq
(

262 
	`th»shŞdRegF›ld
(
	`th»shŞd
(
i
), i),

263 
	`RegF›ld
(32-
´ioB™s
),

264 
	`RegF›ld
(32,

265 
RegR—dFn
 { 
v®id
 =>

266 
	`şaim”
(
i
è:ğ
v®id


267 (
	`BoŞ
(
Œue
), 
	`maxDevs
(
i
))

269 
RegWr™eFn
 { (
v®id
, 
d©a
) =>

270 
	`as£¹
(
com¶‘”Dev
 ==ğ
d©a
.
	`exŒaù
(
	`log2Ce
(
nDeviûs
+1)-1, 0),

272 
com¶‘”Dev
 :ğ
d©a
.
	`exŒaù
(
	`log2Ce
(
nDeviûs
+1)-1, 0)

273 
	`com¶‘”
(
i
è:ğ
v®id
 && 
	`’abËVec0
(i)(
com¶‘”Dev
)

274 
	`BoŞ
(
Œue
)

276 
	`Some
(
	`RegF›ldDesc
(
s
"claim_complete_$i",

277 
s
"Claim/Complete„egister for Target $i. Readinghis„egister„eturnshe claimed interrupt‚umber‡nd makes it‚o†onger…ending." +

278 
s
"Writinghe interrupt‚umber back completeshe interrupt.",

279 
»£t
 = 
NÚe
,

280 
wrTy³
 = 
	`Some
(
RegF›ldWrTy³
.
MODIFY
),

281 
rdAùiÚ
 = 
	`Some
(
RegF›ldRdAùiÚ
.
MODIFY
),

282 vŞ©ğ
Œue
))

287 
node
.
	`»gm­
((
´iÜ™yRegF›lds
 ++ 
³ndšgRegF›lds
 ++ 
’abËRegF›lds
 ++ 
h¬tRegF›lds
):
_
*)

289 ià(
nDeviûs
 >= 2) {

290 
v®
 
şaimed
 = 
	`şaim”
(0è&& 
	`maxDevs
(0) > 0

291 
v®
 
com¶‘ed
 = 
	`com¶‘”
(0)

292 
	`cov”
(
şaimed
 && 
	`RegEÇbË
(şaimed, 
çl£
.
B
, cÏimed || 
com¶‘ed
), "TWO_CLAIMS", "two claims with‚o intervening complete")

293 
	`cov”
(
com¶‘ed
 && 
	`RegEÇbË
(com¶‘ed, 
çl£
.
B
, 
şaimed
 || completed), "TWO_COMPLETES", "two completes with‚o intervening claim")

295 
v®
 
•
 = 
	`’abËs
(0).
asUIÁ
 & 
³ndšg
.asUInt

296 
v®
 
•2
 = 
	`RegNext
(
•
)

297 
v®
 
diff
 = 
•
 & ~
•2


298 
	`cov”
((
diff
 & (diff - 1)) =/= 0, "TWO_INTS_PENDING", "twoƒnabled interrupts became…ending on same cycle")

300 ià(
nPriÜ™›s
 > 0)

301 
	`ccov”
(
	`maxDevs
(0è> (
	`UIÁ
(1è<< 
	`´iÜ™y
(0).
g‘Width
è&& maxDevs(0è<ğ
	`C©
(UIÁ(1), 
	`th»shŞd
(0)),

305 
def
 
	`ccov”
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

306 
	`cov”
(
cÚd
, 
s
"PLIC_$Ïb–", "IÁ”ru±s;;" + 
desc
)

308 
	}
}

310 
şass
 
	$PLICFªIn
(
nDeviûs
: 
IÁ
, 
´ioB™s
: IÁè
ex‹nds
 
ModuË
 {

311 
v®
 
io
 = 
Ãw
 
BundË
 {

312 
v®
 
´io
 = 
	`Vec
(
nDeviûs
, 
	`UIÁ
(
width
 = 
´ioB™s
)).
æ


313 
v®
 

 = 
	`UIÁ
(
width
 = 
nDeviûs
).
æ


314 
v®
 
dev
 = 
	`UIÁ
(
width
 = 
	`log2Ce
(
nDeviûs
+1))

315 
v®
 
max
 = 
	`UIÁ
(
width
 = 
´ioB™s
)

318 
def
 
	`fšdMax
(
x
: 
Seq
[
UIÁ
]): (UInt, UInt) = {

319 ià(
x
.
Ëngth
 > 1) {

320 
v®
 
h®f
 = 1 << (
	`log2Ce
(
x
.
Ëngth
) - 1)

321 
v®
 
Ëá
 = 
	`fšdMax
(
x
 
ke
 
h®f
)

322 
v®
 
right
 = 
	`fšdMax
(
x
 
drİ
 
h®f
)

323 
	`MuxT
(
Ëá
.
_1
 >ğ
right
._1,†eá, (right._1, 
	`UIÁ
(
h®f
è|„ight.
_2
))

324 } (
x
.
h—d
, 
	`UIÁ
(0))

327 
v®
 
efãùivePriÜ™y
 = (
	`UIÁ
(1è<< 
´ioB™s
è+: (
io
.

.
toBoŞs
 
z
 io.
´io
).
m­
 { (
p
, 
x
è=> 
	`C©
(p, x) }

328 
	`v®
 (
maxPri
, 
maxDev
èğ
	`fšdMax
(
efãùivePriÜ™y
)

329 
io
.
max
 :ğ
maxPri


330 
io
.
dev
 :ğ
maxDev


331 
	}
}

334 
Œa™
 
CªHaveP”h”yPLIC
 { 
this
: 
Ba£Subsy¡em
 =>

335 
v®
 
¶icO±
 = 
p
(
PLICKey
).
m­
 { 
·¿ms
 =>

336 
v®
 
¶ic
 = 
LazyModuË
(
Ãw
 
TLPLIC
(
·¿ms
, 
sbus
.
cÚŒŞ_bus
.
b—tBy‹s
))

337 
	gsbus
.
	gcÚŒŞ_bus
.
toV¬ŸbËWidthSÏve
(
Some
("¶ic")è{ 
	g¶ic
.
	gnode
 }

338 
	g¶ic
.
	gšŠode
 :=* 
ibus
.
toPLIC


339 
¶ic


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/TestRAM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
şass
 
	$TLTe¡RAM
(
add»ss
: 
Add»ssS‘
, 
execubË
: 
BoŞ—n
 = 
Œue
, 
b—tBy‹s
: 
IÁ
 = 4, 
ŒackCÜru±iÚ
: BoŞ—ÀğŒue)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
deviû
 = 
Ãw
 
MemÜyDeviû


16 
v®
 
node
 = 
	`TLMªag”Node
(
	`Seq
(
	`TLMªag”PÜtP¬am‘”s
(

17 
	`Seq
(
	`TLMªag”P¬am‘”s
(

18 
add»ss
 = 
	`Li¡
(address),

19 
»sourûs
 = 
deviû
.
»g
,

20 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

21 
execubË
 =ƒxecutable,

22 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

23 
suµÜtsPutP¬tŸl
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

24 
suµÜtsPutFuÎ
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

25 
fifoId
 = 
	`Some
(0))),

26 
b—tBy‹s
 = beatBytes)))

29 
	`»quœe
 ((
add»ss
.
mask
 & (
b—tBy‹s
-1)) == beatBytes-1)

31 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

32 
def
 
	`bigB™s
(
x
: 
BigIÁ
, 

: 
Li¡
[
BoŞ—n
] = Li¡.
em±y
[Boolean]): List[Boolean] =

33 ià(
x
 =ğ0è

.
»v”£
 
	`bigB™s
(x >> 1, ((x & 1) == 1) ::ail)

34 
v®
 
mask
 = 
	`bigB™s
(
add»ss
.mask >> 
	`log2Ce
(
b—tBy‹s
))

36 
	`v®
 (
š
, 
edge
èğ
node
.
	`š
(0)

38 
v®
 
addrB™s
 = (
mask
 
z
 
edge
.
	`addr_hi
(
š
.
a
.
b™s
).
toBoŞs
).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
)

39 
v®
 
memAdd»ss
 = 
	`C©
(
addrB™s
.
»v”£
)

40 
v®
 
mem
 = 
	`Mem
(1 << 
addrB™s
.
size
, 
	`Vec
(
b—tBy‹s
, 
	`B™s
(
width
 = 8)))

41 
v®
 
bad
 = 
	`Mem
(1 << 
addrB™s
.
size
, 
	`BoŞ
())

44 
š
.
a
.
»ady
 :ğš.
d
.ready

45 
š
.
d
.
v®id
 :ğš.
a
.valid

47 
v®
 
hasD©a
 = 
edge
.
	`hasD©a
(
š
.
a
.
b™s
)

48 
v®
 
wd©a
 = 
Vec
.
	`buÏ‹
(
b—tBy‹s
è{ 
i
 => 
š
.
a
.
b™s
.
	`d©a
(8*(i+1)-1, 8*i) }

50 
š
.
d
.
b™s
 :ğ
edge
.
	`AcûssAck
(š.
a
.bits)

51 
š
.
d
.
b™s
.
d©a
 :ğ
	`C©
(
	`mem
(
memAdd»ss
).
»v”£
)

52 
š
.
d
.
b™s
.
cÜru±
 :ğ!
hasD©a
 && 
	`bad
(
memAdd»ss
è&& 
	`BoŞ
(
ŒackCÜru±iÚ
)

53 
š
.
d
.
b™s
.
İcode
 :ğ
	`Mux
(
hasD©a
, 
TLMes§ges
.
AcûssAck
, TLMes§ges.
AcûssAckD©a
)

54 
	`wh’
 (
š
.
a
.
	`fœe
(è&& 
hasD©a
) {

55 
mem
.
	`wr™e
(
memAdd»ss
, 
wd©a
, 
š
.
a
.
b™s
.
mask
.
toBoŞs
)

56 
bad
.
	`wr™e
(
memAdd»ss
, 
š
.
a
.
b™s
.
cÜru±
)

60 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

61 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

62 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

64 
	}
}

67 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


69 
şass
 
	$TLRAMZ”oD–ay
(
¿mB—tBy‹s
: 
IÁ
, 
txns
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

70 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

71 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("ZeroDelay"))

72 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLTe¡RAM
(
	`Add»ssS‘
(0x0, 0x3ff), 
b—tBy‹s
 = 
¿mB—tBy‹s
))

74 
¿m
.
node
 :ğ
	`TLD–ay”
(0.25è:ğ
mod–
.nod:ğ
fuzz
.node

76 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

77 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

79 
	}
}

81 
şass
 
	$TLRAMZ”oD–ayTe¡
(
¿mB—tBy‹s
: 
IÁ
, 
txns
: IÁ = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

82 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMZ”oD–ay
(
¿mB—tBy‹s
, 
txns
)).
moduË
)

83 
io
.
fšished
 :ğ
dut
.io.finished

84 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Zero.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
TLMes§ges


13 
şass
 
	$TLZ”o
(
add»ss
: 
Add»ssS‘
, 
b—tBy‹s
: 
IÁ
 = 4)(
im¶ic™
 
p
: 
P¬am‘”s
)

14 
ex‹nds
 
	`DevNuÎDeviû
(

15 
·¿ms
 = 
	`DevNuÎP¬ams
(

16 
add»ss
 = 
	`Li¡
(address),

17 
maxAtomic
 = 
b—tBy‹s
,

18 
maxT¿nsãr
 = 
b—tBy‹s
,

19 
»giÚ
 = 
RegiÚTy³
.
UNCACHED
,

20 
execubË
 = 
Œue
,

21 
mayD’yG‘
 = 
çl£
,

22 
mayD’yPut
 = 
çl£
),

23 
b—tBy‹s
 = beatBytes,

24 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("rom", 
	`Seq
("ucbbar,cacheable-zero0"))) {

25 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

26 
	`v®
 (
š
, 
edge
èğ
node
.
	`š
(0)

28 
v®
 
a
 = 
	`Queue
(
š
.a, 2)

30 
a
.
»ady
 :ğ
š
.
d
.ready

31 
š
.
d
.
v®id
 :ğ
a
.valid

32 
š
.
d
.
b™s
 :ğ
edge
.
	`AcûssAck
(
a
.bits)

33 
š
.
d
.
b™s
.
İcode
 :ğ
TLMes§ges
.
	`adRe¥Ú£
(
edge
.
	`İcode
(
a
.bits))

36 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

37 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

38 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

40 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressDecoder.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
log2Ce


6 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmax
,
	gmš
}

8 
objeù
 
	gAdd»ssDecod”


10 
ty³
 
	gPÜt
 = 
Seq
[
Add»ssS‘
]

11 
ty³
 
PÜts
 = 
Seq
[
PÜt
]

12 
ty³
 
P¬t™iÚ
 = 
PÜts


13 
ty³
 
P¬t™iÚs
 = 
Seq
[
P¬t™iÚ
]

15 
v®
 
add»ssOrd”
 = 
Ord”šg
.
Üd”ed
[
Add»ssS‘
]

16 
v®
 
pÜtOrd”
 = 
Ord”šg
.
I‹¿bË
(
add»ssOrd”
)

17 
v®
 
·¹™iÚOrd”
 = 
Ord”šg
.
I‹¿bË
(
pÜtOrd”
)

22 
def
 
­¶y
(
pÜts
: 
PÜts
, 
giv’B™s
: 
BigIÁ
 = BigInt(0)): BigInt = {

23 
v®
 
nÚEm±yPÜts
 = 
pÜts
.
f‹r
(
_
.
nÚEm±y
)

24 ià(
nÚEm±yPÜts
.
size
 <= 1) {

25 
giv’B™s


28 
nÚEm±yPÜts
.
combš©iÚs
(2).
fÜ—ch
 { 
Seq
(
x
, 
y
) =>

29 
x
.
fÜ—ch
 { 
a
 => 
y
.fÜ—ch { 
b
 =>

30 
»quœe
 (!
a
.
ov”Ïps
(
b
), 
s
"Ports cannot overlap: $a $b")

34 
v®
 
	gmaxB™s
 = 
log2Ce
(1 + 
nÚEm±yPÜts
.
m­
(
_
.m­(_.
ba£
).
max
).max)

35 
v®
 (
b™sToTry
, 
b™sToTake
èğ(0 
uÁ
 
maxB™s
).
m­
(
BigIÁ
(1è<< 
_
).
·¹™iÚ
(
b
 => (
giv’B™s
 & b) == 0)

36 
v®
 
·¹™iÚs
 = 
Seq
(
nÚEm±yPÜts
.
m­
(
_
.
sÜ‹d
).sÜ‹d(
pÜtOrd”
))

37 
v®
 
giv’P¬t™iÚs
 = 
b™sToTake
.
fŞdLeá
(
·¹™iÚs
è{ (
p
, 
b
è=> 
·¹™iÚP¬t™iÚs
(p, b) }

38 
v®
 
	g£Ëùed
 = 
»cur£
(
giv’P¬t™iÚs
, 
b™sToTry
.
»v”£
.
toSeq
)

39 
v®
 
	gouut
 = 
£Ëùed
.
»duûLeá
(
_
 | _è| 
giv’B™s


42 
v®
 
widePÜts
 = 
nÚEm±yPÜts
.
m­
 { 
_
.m­ { _.
wid’
(~
ouut
) } }

44 
widePÜts
.
combš©iÚs
(2).
fÜ—ch
 { 
Seq
(
x
, 
y
) =>

45 
x
.
fÜ—ch
 { 
a
 => 
y
.fÜ—ch { 
b
 =>

46 
»quœe
 (!
a
.
ov”Ïps
(
b
), 
s
"Ports cannot overlap: $a $b")

50 
	gouut


55 
def
 
­¶y
(
keys
: 
Seq
[
IÁ
]): Int = {

56 
v®
 
pÜts
 = 
keys
.
m­
(
b
 => 
Seq
(
Add»ssS‘
(b, 0)))

57 
­¶y
(
pÜts
).
	gtoIÁ


71 
def
 
b™ScÜe
(
·¹™iÚs
: 
P¬t™iÚs
): 
Seq
[
IÁ
] = {

72 
v®
 
maxPÜtsP”P¬t™iÚ
 = 
·¹™iÚs
.
m­
(
_
.
size
).
max


73 
v®
 
maxS‘sP”P¬t™iÚ
 = 
·¹™iÚs
.
m­
(
_
.m­(_.
size
).
sum
).
max


74 
v®
 
sumSqu¬ePÜtsP”P¬t™iÚ
 = 
·¹™iÚs
.
m­
(
p
 =>….
size
 *….size).
sum


75 
v®
 
sumSqu¬eS‘sP”P¬t™iÚ
 = 
·¹™iÚs
.
m­
(
_
.m­(
p
 =>….
size
 *….size).
sum
).
max


76 
Seq
(
maxPÜtsP”P¬t™iÚ
, 
maxS‘sP”P¬t™iÚ
, 
sumSqu¬ePÜtsP”P¬t™iÚ
, 
sumSqu¬eS‘sP”P¬t™iÚ
)

79 
def
 
·¹™iÚPÜt
(
pÜt
: 
PÜt
, 
b™
: 
BigIÁ
): (PÜt, 
	gPÜt
) = {

80 
v®
 
addr_a
 = 
Add»ssS‘
(0, ~
b™
)

81 
v®
 
	gaddr_b
 = 
Add»ssS‘
(
b™
, ~bit)

83 
v®
 
	gsub£t_a
 = 
pÜt
.
f‹r
(
_
.
ov”Ïps
(
addr_a
))

84 
v®
 
sub£t_b
 = 
pÜt
.
f‹r
(
_
.
ov”Ïps
(
addr_b
))

85 (
sub£t_a
, 
	gsub£t_b
)

88 
def
 
·¹™iÚPÜts
(
pÜts
: 
PÜts
, 
b™
: 
BigIÁ
): (PÜts, 
	gPÜts
) = {

89 
v®
 
·¹™iÚed_pÜts
 = 
pÜts
.
m­
(
p
 => 
·¹™iÚPÜt
Õ, 
b™
))

91 
v®
 
	gÿ£_a_pÜts
 = 
·¹™iÚed_pÜts
.
m­
(
_
.
_1
).
f‹r
(!_.
isEm±y
).
sÜ‹d
(
pÜtOrd”
)

92 
v®
 
ÿ£_b_pÜts
 = 
·¹™iÚed_pÜts
.
m­
(
_
.
_2
).
f‹r
(!_.
isEm±y
).
sÜ‹d
(
pÜtOrd”
)

93 (
ÿ£_a_pÜts
, 
	gÿ£_b_pÜts
)

96 
def
 
·¹™iÚP¬t™iÚs
(
·¹™iÚs
: 
P¬t™iÚs
, 
b™
: 
BigIÁ
): Partitions = {

97 
v®
 
·¹™iÚed_·¹™iÚs
 = 
·¹™iÚs
.
m­
(
p
 => 
·¹™iÚPÜts
Õ, 
b™
))

98 
v®
 
	gÿ£_a_·¹™iÚs
 = 
·¹™iÚed_·¹™iÚs
.
m­
(
_
.
_1
).
f‹r
(!_.
isEm±y
)

99 
v®
 
ÿ£_b_·¹™iÚs
 = 
·¹™iÚed_·¹™iÚs
.
m­
(
_
.
_2
).
f‹r
(!_.
isEm±y
)

100 
v®
 
Ãw_·¹™iÚs
 = (
ÿ£_a_·¹™iÚs
 ++ 
ÿ£_b_·¹™iÚs
).
sÜ‹d
(
·¹™iÚOrd”
)

104 
v®
 
k“p
 = (
Ãw_·¹™iÚs
.
š™
 
z
‚ew_·¹™iÚs.

è
f‹r
 { (
a
,
b
è=> 
·¹™iÚOrd”
.
com·»
×,bè!ğ0 } 
	gm­
 { 
	g_
.
	g_2
 }

105 
	gÃw_·¹™iÚs
.
	gh—d
 +: 
k“p


109 
v®
 
debug
 = 
çl£


110 
def
 
»cur£
(
·¹™iÚs
: 
P¬t™iÚs
, 
b™s
: 
Seq
[
BigIÁ
]): Seq[BigInt] = {

111 ià(
·¹™iÚs
.
m­
(
_
.
size
 <ğ1).
»duû
(_ && _)è
Seq
() {

112 ià(
debug
) {

113 
´šn
("Partitioning:")

114 
·¹™iÚs
.
fÜ—ch
 { 
·¹™iÚ
 =>

115 
´šn
(" Partition:")

116 
·¹™iÚ
.
fÜ—ch
 { 
pÜt
 =>

117 
´št
(" ")

118 
pÜt
.
fÜ—ch
 { 
a
 => 
´št
(
s
" ${a}") }

119 
´šn
("")

123 
v®
 
ÿndid©es
 = 
b™s
.
m­
 { 
b™
 =>

124 
v®
 
»suÉ
 = 
·¹™iÚP¬t™iÚs
(
·¹™iÚs
, 
b™
)

125 
v®
 
	gscÜe
 = 
b™ScÜe
(
»suÉ
)

126 ià(
debug
)

127 
´šn
(" FÜ b™ %x, %s".
fÜm©
(
b™
, 
scÜe
.
toSŒšg
))

128 (
	gscÜe
, 
	gb™
, 
	g»suÉ
)

130 
v®
 (
be¡ScÜe
, 
be¡B™
, 
be¡P¬t™iÚs
èğ
ÿndid©es
.
mš
(
Ord”šg
.
by
[(
Seq
[
IÁ
], 
BigIÁ
, 
P¬t™iÚs
), 
I‹¿bË
[IÁ]](
_
.
_1
.
toI‹¿bË
))

131 ià(
	gdebug
è
´šn
("=> S–eùed b™ 0x%x".
fÜm©
(
be¡B™
))

132 
	gbe¡B™
 +: 
»cur£
(
be¡P¬t™iÚs
, 
b™s
.
f‹r
(
_
 !ğ
be¡B™
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressRange.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
_


8 
şass
 
	$Add»ssRªge
(
ba£
: 
BigIÁ
, 
size
: BigIÁè
ex‹nds
 
Ord”ed
[
Add»ssRªge
]

10 
v®
 
’d
 = 
ba£
 + 
size


12 
	`»quœe
 (
ba£
 >ğ0, 
s
"AddressRange base must be…ositive, got: $base")

13 
	`»quœe
 (
size
 > 0, 
s
"AddressRange size must be > 0, got: $size")

15 
def
 
	`com·»
(
x
: 
Add»ssRªge
) = {

16 
v®
 
´im¬y
 = (
this
.
ba£
 - 
x
.ba£).
signum


17 
v®
 
£cÚd¬y
 = (
x
.
size
 - 
this
.size).
signum


18 ià(
´im¬y
 !ğ0è´im¬y 
£cÚd¬y


21 
def
 
	`cÚšs
(
x
: 
Add»ssRªge
èğ
ba£
 <ğx.ba£ && x.
’d
 <=ƒnd

22 
def
 (
x
: 
Add»ssRªge
): 
O±iÚ
[AddressRange] = {

23 ià(
ba£
 > 
x
.
’d
 || x.base >ƒnd) {

24 
NÚe


26 
v®
 
oba£
 = ià(
ba£
 < 
x
.base) base x.base

27 
v®
 
Ûnd
 = ià(
’d
 > 
x
.end)ƒnd x.end

28 
	`Some
(
	`Add»ssRªge
(
oba£
, 
Ûnd
-obase))

32 
´iv©e
 
def
 
	`h–³r
(
ba£
: 
BigIÁ
, 
’d
: BigInt) =

33 ià(
ba£
 < 
’d
è
	`Seq
(
	`Add»ssRªge
(ba£,ƒnd-ba£)è
N


34 
def
 
	`subŒaù
(
x
: 
Add»ssRªge
) =

35 
	`h–³r
(
ba£
, 
’d
 
mš
 
x
.ba£è++ h–³r(ba£ 
max
 x.end,ƒnd)

38 
ov”ride
 
def
 
	`toSŒšg
(èğ"Add»ssRªge(0x%x, 0x%x)".
	`fÜm©
(
ba£
, 
size
)

41 
def
 
toUVM
: 
SŒšg
 = 
f
" set_addr_range(1, 32'h${base}%08x, 32'h${end}%08x);"

42 
def
 
toJSON
: 
SŒšg
 = 
s
"""{"
ba£
": ${ba£}, "
max
": ${end}}"""

43 
	}
}

45 
objeù
 
Add»ssRªge


47 
def
 
äomS‘s
(
£q
: 
Seq
[
Add»ssS‘
]): Seq[
Add»ssRªge
] = 
unify
(£q.
æ©M­
(
_
.
toRªges
))

48 
def
 
unify
(
£q
: 
Seq
[
Add»ssRªge
]): Seq[AddressRange] = {

49 ià(
£q
.
isEm±y
è 
N


50 
v®
 
¿nges
 = 
£q
.
sÜ‹d


51 
¿nges
.

.
fŞdLeá
(
Seq
Ôªges.
h—d
)è{ (h—d ::a, 
x
) =>

52 
h—d
.(
x
è
m©ch
 {

53 
Some
(
z
è=> z :: 



54 
NÚe
 => 
x
 :: 
h—d
 :: 



56 }.
»v”£


59 
def
 
subŒaù
(
äom
: 
Seq
[
Add»ssRªge
], 
ke
: Seq[AddressRange]): Seq[AddressRange] =

60 
ke
.
fŞdLeá
(
äom
è{ (
Ëá
, 
r
è=>†eá.
æ©M­
 { 
_
.
subŒaù
(r) } }

63 
şass
 
	$Add»ssM­EÁry
(
¿nge
: 
Add»ssRªge
, 
³rmissiÚs
: 
ResourûP”missiÚs
, 
Çmes
: 
Seq
[
SŒšg
]) {

64 
v®
 
	`ResourûP”missiÚs
(
r
, 
w
, 
x
, 
c
, 
a
èğ
³rmissiÚs


66 
def
 
	`toSŒšg
(
aw
: 
IÁ
èğ
s
"\t%${aw}x - %${aw}x %c%c%c%c%ø%s".
	`fÜm©
(

67 
¿nge
.
ba£
,

68 
¿nge
.
ba£
+¿nge.
size
,

69 ià(
a
) 'A' ' ',

70 ià(
r
) 'R' ' ',

71 ià(
w
) 'W' ' ',

72 ià(
x
) 'X' ' ',

73 ià(
c
) 'C' ' ',

74 
Çmes
.
	`mkSŒšg
(", "))

76 
def
 
toJSON
 = 
s
"""{"
ba£
":[${¿nge.ba£}],"
size
":[${range.size}],""" +

77 
s
""""
r
":[$r],"
w
":[$w],"
x
":[$x],"
c
":[$c],"
a
":[$a],""" +

78 
s
""""
Çmes
":[${names.map('"'+_+'"').mkString(",")}]}"""

79 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/BundleBridge.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
IO


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gP¬am‘”s
,
	gF›ld
}

10 
şass
 
	gBundËBridgeP¬ams
[
T
 <: 
D©a
](
g’
: () => T)

11 
şass
 
	$BundËBridgeNuÎ
()

13 
şass
 
BundËBridgeImp
[
T
 <: 
D©a
](è
ex‹nds
 
Sim¶eNodeImp
[
BundËBridgeP¬ams
[T], 
BundËBridgeNuÎ
, BundleBridgeParams[T], T]

15 
def
 
	`edge
(
pd
: 
BundËBridgeP¬ams
[
T
], 
pu
: 
BundËBridgeNuÎ
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
) =…d

16 
def
 
	`bundË
(
e
: 
BundËBridgeP¬ams
[
T
]èğe.
	`g’
()

17 
def
 
	`»nd”
(
e
: 
BundËBridgeP¬ams
[
T
]èğ
	`R’d”edEdge
(
cŞour
 = "#cccc00" )

18 
	}
}

20 
şass
 
BundËBridgeSšk
[
T
 <: 
D©a
]()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SškNode
(
Ãw
 
BundËBridgeImp
[
T
])(
	`Seq
(
	$BundËBridgeNuÎ
()))

22 
def
 
bundË
: 
T
 = 
	`š
(0).
_1


24 
def
 
	`makeIO
()(
im¶ic™
 
v®Name
: 
V®Name
): 
T
 = {

25 
v®
 
io
 = 
	`IO
(
bundË
.
şÚeTy³
)

26 
io
.
	`sugge¡Name
(
v®Name
.
Çme
)

27 
io
 <> 
bundË


28 
io


30 
	}
}

32 
şass
 
BundËBridgeSourû
[
T
 <: 
D©a
](
g’
: (è=> T)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SourûNode
(
Ãw
 
BundËBridgeImp
[
T
])(
	`Seq
(
	$BundËBridgeP¬ams
(
g’
)))

34 
def
 
bundË
: 
T
 = 
	`out
(0).
_1


36 
def
 
	`makeIO
()(
im¶ic™
 
v®Name
: 
V®Name
): 
T
 = {

37 
v®
 
io
 = 
	`IO
(
	`Fl³d
(
bundË
.
şÚeTy³
))

38 
io
.
	`sugge¡Name
(
v®Name
.
Çme
)

39 
bundË
 <> 
io


40 
io


43 
´iv©e
 
v¬
 
dÚeSšk
 = 
çl£


44 
def
 
	`makeSšk
()(
im¶ic™
 
p
: 
P¬am‘”s
) = {

45 
	`»quœe
 (!
dÚeSšk
, "Can only call makeSink() once")

46 
dÚeSšk
 = 
Œue


47 
v®
 
sšk
 = 
BundËBridgeSšk
[
T
]()

48 
sšk
 :ğ
this


49 
sšk


51 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ClockDomain.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
Œa™
 
HasClockDomašCrossšg
 
ex‹nds
 
	gLazyScİe
 { 
	gthis
: 
LazyModuË
 => }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Clone.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gshim
.
ClÚeModuË


8 
fš®
 cÏs 
	cClÚeLazyModuË
 
	$´iv©e
 (
v®
 
ba£
: 
LazyModuË
)

12 
def
 
şÚe
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: D©a](
node
: 
NodeHªdË
[DI, UI, EI, BI, DO, UO, EO, BO])(
im¶ic™
 
v®Name
: 
V®Name
) =

13 
Ãw
 
	$MixedTe¡Node
(
node
, 
this
)

15 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
io
 = 
	`ClÚeModuË
(
ba£
.
moduË
)

18 
objeù
 
ClÚeLazyModuË


20 
def
 
	`­¶y
(
ba£
: 
LazyModuË
èğ
Ãw
 
	`ClÚeLazyModuË
(base)

21 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/CloneModule.scala

6 
·ckage
 
	gchi£l3
.
shim


8 
impÜt
 
	gChi£l
.
_


9 
impÜt
 
	gchi£l3
.
	gex³rim’l
.{
	gRawModuË
, 
	gMuÉiIOModuË
, 
	gBa£ModuË
}

10 
impÜt
 
	gchi£l3
.
	gš‹º®
.
Bud”


11 
impÜt
 
	gchi£l3
.
	gcÜe
.
U£rModuË


12 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gfœ¹l
.{
	gCommªd
, 
	gDefIn¡ªû
}

13 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gimmubË
.
Li¡M­


14 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
A¼ayBufãr


16 
şass
 
ClÚePÜts
 
	g´Ùeùed
[
shim
](
	g–ts
: 
D©a
*è
ex‹nds
 
RecÜd


18 
v®
 
–em’ts
 = 
Li¡M­
(
–ts
.
m­
(
d
 => d.
š¡ªûName
 -> d.
chi£lClÚeTy³
): 
_
*)

19 
def
 
­¶y
(
f›ld
: 
SŒšg
èğ
–em’ts
(field)

20 
ov”ride
 
def
 
şÚeTy³
 = (
Ãw
 
ClÚePÜts
(
–ts
: 
_
*)).
asIn¡ªûOf
[
this
.
ty³
]

23 şas 
	cClÚeModuË
 
	$´iv©e
 (
mod–
: 
RawModuË
è
ex‹nds
 
BÏckBox


25 
impÜt
 
ClÚeModuË
.
_


26 
ov”ride
 
def
 
desœedName
 = 
mod–
.
Çme


27 
v®
 
io
 = 
	`IO
(
Ãw
 
	`ClÚePÜts
(
mod–
.
g‘PÜts
.
	$m­
(
_
.
id
): _*))

30 
objeù
 
ClÚeModuË


32 
def
 
	`­¶y
(
mod–
: 
Ba£ModuË
): 
ClÚePÜts
 = {

34 
v®
 
mod
 = 
	`ModuË
(
Ãw
 
	`ClÚeModuË
(
mod–
.
asIn¡ªûOf
[
RawModuË
]))

37 
v®
 
m‘hod
 = 
şassOf
[
U£rModuË
].
	`g‘Deş¬edM‘hod
("_commands")

38 
m‘hod
.
	`£tAcûssibË
(
Œue
)

39 
v®
 
commªds
 = 
m‘hod
.
	`švoke
(
Bud”
.
fÜûdU£rModuË
).
asIn¡ªûOf
[
A¼ayBufãr
[
Commªd
]]

40 
v®
 
viùimIdx
 = 
commªds
.
Ï¡IndexWh”e
 {

41 
	`DefIn¡ªû
(
_
, 
kl
, _è=> 
mod
 
eq
 kill

42 
_
 => 
çl£


44 
v®
 
viùim
 = 
	`commªds
(
viùimIdx
).
asIn¡ªûOf
[
DefIn¡ªû
]

45 
v®
 
¡ªdš
 = 
Ãw
 
	`DefIn¡ªû
(
viùim
.
sourûInfo
, 
mod–
, viùim.
pÜts
) {

46 
ov”ride
 
def
 
Çme
 = 
viùim
.name

48 
commªds
.
	`upd©e
(
viùimIdx
, 
¡ªdš
)

50 
mod–
 
m©ch
 {

51 
_
: 
MuÉiIOModuË
 =>

52 
mod
.
	`io
("şock"è:ğ
ModuË
.
şock


53 
mod
.
	`io
("»£t"è:ğ
ModuË
.
»£t


54 
_
: 
RawModuË
 =>

56 
mod
.
io


58 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/DeviceTree.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
F›ld


6 
impÜt
 
	gsys
.
	g´oûss
.
_


7 
impÜt
 
	gjava
.
	gio
.{
	gBy‹A¼ayIÅutSŒ—m
, 
	gBy‹A¼ayOuutSŒ—m
}

9 
objeù
 
DTSMod–
 
ex‹nds
 
	gF›ld
[
SŒšg
]

10 
objeù
 
DTSCom·t
 
ex‹nds
 
	gF›ld
[
Seq
[
SŒšg
]]

11 
objeù
 
DTSTimeba£
 
ex‹nds
 
	gF›ld
[
BigIÁ
](0)

13 
objeù
 
	gDTS


15 
def
 
­¶y
(
»s
: 
ResourûV®ue
): 
SŒšg
 = "/dts-v1/;\n\n" + 
h–³r
Ôes, "", 
deçuÉC–ls
).
mkSŒšg
("")

17 
´iv©e
 
v®
 
	gnodeS¹Ch¬s
 = (('a' 
to
 'z'è++ ('A'Ø'Z')).
toS‘


18 
´iv©e
 
v®
 
nodeCh¬s
 = (('a' 
to
 'z'è++ ('A'Ø'Z'è++ ('0'Ø'9'è++ 
Seq
(',', '.', '_', '+', '-', '@')).
toS‘


19 
def
 
Ëg®Node
(
x
: 
SŒšg
): 
BoŞ—n
 =

20 
x
 =ğ"/" || (!x.
isEm±y
 && x.
size
 < 32 && 
nodeS¹Ch¬s
.
cÚšs
(x(0)è&& x.
fÜ®l
(
nodeCh¬s
.cÚšs(
_
)))

23 
´iv©e
 
v®
 
´İCh¬s
 = (('a' 
to
 'z'è++ ('A'Ø'Z'è++ ('0'Ø'9'è++ 
Seq
(',', '.', '_', '+', '?', '#', '-')).
toS‘


24 
def
 
Ëg®Prİ”ty
(
x
: 
SŒšg
): 
BoŞ—n
 =

25 
x
 =ğ"/" || (!x.
isEm±y
 && x.
size
 < 32 && x.
fÜ®l
(
´İCh¬s
.
cÚšs
(
_
)))

28 
´iv©e
 
v®
 
¡rCh¬s
 = (('#' 
to
 '['è++ (']'Ø'~'è++ 
Seq
(' ', '!')).
toS‘


29 
def
 
Ëg®SŒšg
(
x
: 
SŒšg
): 
BoŞ—n
 = x.
fÜ®l
(
¡rCh¬s
.
cÚšs
(
_
))

31 
´iv©e
 
şass
 
C–ls
(

32 
·»ÁAdd»ss
: 
IÁ
,

33 
·»ÁSize
: 
IÁ
,

34 
£lfAdd»ss
: 
IÁ
,

35 
£lfSize
: 
IÁ
)

36 
´iv©e
 
v®
 
deçuÉC–ls
 = 
C–ls
(2, 1, 2, 1)

38 
´iv©e
 
def
 
fmtC–l
(
x
: 
BigIÁ
, 
ûÎs
: 
IÁ
): 
Seq
[
SŒšg
] = {

39 
v®
 
ûÎb™s
 = 32

40 
v®
 
mask
 = (
BigIÁ
(1è<< 
ûÎb™s
) - 1

41 (0 
uÁ
 
ûÎs
).
»v”£
 
m­
 { 
i
 => "0x%x".
fÜm©
((
x
 >> (i*
ûÎb™s
)è& 
mask
) }

44 
´iv©e
 
def
 
fmtAdd»ss
(
x
: 
ResourûAdd»ss
, 
ûÎs
: 
C–ls
): 
Seq
[
SŒšg
] = {

45 
v®
 
¿nges
 = 
Add»ssRªge
.
äomS‘s
(
x
.
add»ss
)

46 
¿nges
.
æ©M­
 { 
Add»ssRªge
(
ba£
, 
size
) =>

47 
fmtC–l
(
ba£
, 
ûÎs
.
·»ÁAdd»ss
è++ fmtC–l(
size
, c–ls.
·»ÁSize
)

51 
´iv©e
 
def
 
fmtM­pšg
(
x
: 
ResourûM­pšg
, 
ûÎs
: 
C–ls
): 
Seq
[
SŒšg
] = {

52 
v®
 
¿nges
 = 
Add»ssRªge
.
äomS‘s
(
x
.
add»ss
)

53 
¿nges
.
æ©M­
 { 
Add»ssRªge
(
ba£
, 
size
) =>

54 
fmtC–l
(
ba£
+
x
.
off£t
, 
ûÎs
.
£lfAdd»ss
è++ fmtC–l(ba£, c–ls.
·»ÁAdd»ss
è++ fmtC–l(
size
, c–ls.
£lfSize
)

58 
´iv©e
 
def
 
fmtSŒšg
(
x
: 
ResourûSŒšg
): 
Seq
[
SŒšg
] = {

59 
»quœe
 (
Ëg®SŒšg
(
x
.
v®ue
), 
s
"The string '${x.value}' contains chars…robably unwise for use in‡ DTS string")

60 
Seq
("\"" + 
x
.
v®ue
 + "\"")

63 
´iv©e
 
def
 
fmtM­
(
x
: 
ResourûM­
, 
šd’t
: 
SŒšg
, 
ûÎs
: 
C–ls
): 
Seq
[String] = {

64 
v®
 (
nodes
, 
´İs
èğ
x
.
v®ue
.
·¹™iÚ
(
_
 
m©ch
 {

65 (
_
, 
Seq
(
ResourûM­
(_, _))è=> 
Œue


66 
_
 => 
çl£


69 
def
 
g‘IÁ
(
x
: 
ResourûV®ue
èğx 
m©ch
 {

70 
ResourûIÁ
(
v®ue
è=> 
Some
(v®ue.
toIÁ
)

71 
_
 => 
NÚe


73 
v®
 
£lfAdd»ss
 = 
x
.
v®ue
.
g‘OrEl£
("#add»ss-ûÎs", 
N
).
	gh—dO±iÚ
.
æ©M­
(
g‘IÁ
)

74 
v®
 
	g£lfSize
 = 
x
.
v®ue
.
g‘OrEl£
("#size-ûÎs", 
N
).
	gh—dO±iÚ
.
æ©M­
(
g‘IÁ
)

76 
v®
 
	gmyC–ls
 = 
C–ls
(

77 
·»ÁAdd»ss
 = 
ûÎs
.
£lfAdd»ss
,

78 
·»ÁSize
 = 
ûÎs
.
£lfSize
,

79 
£lfAdd»ss
 = s–fAdd»ss.
g‘OrEl£
(
deçuÉC–ls
.selfAddress),

80 
£lfSize
 = s–fSiz.
g‘OrEl£
(
deçuÉC–ls
.selfSize))

82 
´İs
.
æ©M­
 { (
k
, 
£q
) =>

83 
»quœe
 (
Ëg®Prİ”ty
(
k
), 
s
"The string '${k}' is‚ot‡†egal DTS…roperty‚ame")

84 
	g£q
.
h—dO±iÚ
 
	gm©ch
 {

85 
	gNÚe
 => 
Seq
(
šd’t
, 
k
, ";\n")

86 
Some
(
ResourûSŒšg
(
_
)) => {

87 
£q
.
fÜ—ch
 { 
r
 =>„ 
m©ch
 {

88 
ResourûSŒšg
(
_
è=> 
Un™


89 
_
 => 
»quœe
(
çl£
, 
s
"The…roperty '${k}' has values of conflictingype: ${seq}")

91 
Seq
(
šd’t
, 
k
, " = ", 
£q
.
æ©M­
(
z
 => 
h–³r
(z, "", 
myC–ls
)).
mkSŒšg
(", "), ";\n")

93 
Some
(
ResourûAlŸs
(
_
)) => {

94 
£q
.
fÜ—ch
 { 
r
 =>„ 
m©ch
 {

95 
ResourûAlŸs
(
_
è=> 
Un™


96 
_
 => 
»quœe
(
çl£
, 
s
"The…roperty '${k}' has values of conflictingype: ${seq}")

98 
Seq
(
šd’t
, 
k
, " = ", 
£q
.
æ©M­
(
z
 => 
h–³r
(z, "", 
myC–ls
)).
mkSŒšg
(", "), ";\n")

100 
Some
(
_
) => {

101 
£q
.
fÜ—ch
 { 
r
 =>„ 
m©ch
 {

102 
ResourûM­
(
_
, _è=> 
»quœe
(
çl£
, 
s
"The…roperty '${k}' has values of conflictingype: ${seq}")

103 
ResourûSŒšg
(
_
è=> 
»quœe
(
çl£
, 
s
"The…roperty '${k}' has values of conflictingype: ${seq}")

104 
ResourûAlŸs
(
_
è=> 
»quœe
(
çl£
, 
s
"The…roperty '${k}' has values of conflictingype: ${seq}")

105 
	g_
 => 
Un™


107 
Seq
(
šd’t
, 
k
, " = <", 
£q
.
æ©M­
(
z
 => 
h–³r
(z, "", 
myC–ls
)).
mkSŒšg
(" "), ">;\n")

110 }.
	gtoLi¡
 ++

111 
	gnodes
.
	gæ©M­
 { (
	gk
, 
Seq
(
s
: 
ResourûM­
)) =>

112 
»quœe
 (
Ëg®Node
(
k
), 
s
"The string '${k}' is‚ot‡†egal DTS‚ode‚ame")

113 
Seq
(
šd’t
è++ 
	gs
.
	gÏb–s
.
m­
(
_
 + ": ").
f‹r
(_ => !šd’t.
isEm±y
) ++

114 
Seq
(
k
, " {\n"è++ 
h–³r
(
s
, 
šd’t
 + "\t", 
myC–ls
) ++ Seq(indent, "};\n")

118 
´iv©e
 
def
 
h–³r
(
»s
: 
ResourûV®ue
, 
šd’t
: 
SŒšg
, 
ûÎs
: 
C–ls
): 
Seq
[SŒšg] =„e 
m©ch
 {

119 
x
: 
ResourûAdd»ss
 => 
fmtAdd»ss
(x, 
ûÎs
)

120 
	gx
: 
ResourûM­pšg
 => 
fmtM­pšg
(
x
, 
ûÎs
)

121 
	gx
: 
ResourûIÁ
 => 
Seq
(
x
.
v®ue
.
toSŒšg
)

122 
x
: 
ResourûSŒšg
 => 
fmtSŒšg
(x)

123 
x
: 
ResourûReã»nû
 => 
Seq
("&" + x.
v®ue
)

124 
x
: 
ResourûAlŸs
 => 
Seq
("&" + x.
v®ue
)

125 
x
: 
ResourûM­
 => 
fmtM­
(x, 
šd’t
, 
ûÎs
)

129 
şass
 
	$DTB
(
cÚ‹Ás
: 
Seq
[
By‹
])

130 
objeù
 
DTB


132 
def
 
	`­¶y
(
dts
: 
SŒšg
): 
DTB
 = {

133 
v®
 
š¡»am
 = 
Ãw
 
	`By‹A¼ayIÅutSŒ—m
(
dts
.
	`g‘By‹s
("UTF-8"))

134 
v®
 
out¡»am
 = 
Ãw
 
By‹A¼ayOuutSŒ—m


135 
v®
 
´oc
 = "dtø-O dtb" #< 
š¡»am
 #> 
out¡»am


136 
	`»quœe
 (
´oc
.! == 0, "Failedo„un dtc; is it in your…ath?")

137 
š¡»am
.
şo£


138 
out¡»am
.
şo£


139 
	`DTB
(
out¡»am
.
toBy‹A¼ay
)

141 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/FixedClockResource.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
şass
 
FixedClockResourû
(
v®
 
Çme
: 
SŒšg
, v® 
äeqMHz
: 
DoubË
, v® 
´efix
: String = "soc/")

7 
v®
 
deviû
 = 
Ãw
 
DeviûSn³t
 {

8 
def
 
desüibe
() =

9 
DesütiÚ
(
´efix
 + 
Çme
, 
M­
(

10 "#şock-ûÎs" -> 
Seq
(
ResourûIÁ
(0)),

11 "şock-äequ’cy" -> 
Seq
(
ResourûIÁ
(
äeqMHz
 * 1000000)),

12 "şock-ouut-Çmes" -> 
Seq
(
ResourûSŒšg
(
Çme
)),

13 "com·tibË" -> 
Seq
(
ResourûSŒšg
("fixed-clock"))))

16 
def
 
bšd
(
dev
: 
Deviû
) {

17 
ResourûBšdšg
 { 
Resourû
(
dev
, "şocks").
bšd
(
ResourûReã»nû
(
deviû
.
Ïb–
)) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/JSON.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gimmubË
.
SÜ‹dM­


7 
objeù
 
	gJSON


9 
def
 
­¶y
(
»s
: 
ResourûV®ue
): 
SŒšg
 = {

10 
v®
 
roÙ
 = 
»s
 
m©ch
 {

11 
ResourûM­
(
v®ue
, 
_
è=> v®ue.
toLi¡
 
m©ch
 {

12 
Seq
(("/", Seq(
subŒ“
))) => subtree

13 
_
 => 
»s


15 
	g_
 => 
»s


17 
h–³r
(
roÙ
)(
SÜ‹dM­
(
m­
ÔoÙ):
_
*)).
mkSŒšg


20 
´iv©e
 
def
 
m­
(
»s
: 
ResourûV®ue
, 
·th
: 
SŒšg
 = ""): 
Seq
[(SŒšg, SŒšg)] =„e 
m©ch
 {

21 
ResourûM­
(
v®ue
, 
Ïb–s
) => {

22 
Ïb–s
.
m­
(
_
 -> 
·th
) ++

23 
v®ue
.
æ©M­
 { (
key
, 
£q
è=> seq.æ©M­(
m­
(
_
, 
·th
 + "/" + key)) }

25 
	g_
 => 
N


28 
´iv©e
 
def
 
h–³r
(
»s
: 
ResourûV®ue
)(
im¶ic™
 
·th
: 
M­
[
SŒšg
, SŒšg]): 
Seq
[SŒšg] =„e 
m©ch
 {

29 
ResourûAdd»ss
(
add»ss
, 
ResourûP”missiÚs
(
r
, 
w
, 
x
, 
c
, 
a
)) =>

30 
Add»ssRªge
.
äomS‘s
(
add»ss
).
m­
 { Add»ssRªge(
ba£
, 
size
) =>

31 
s
"""{"
ba£
":${ba£},"
size
":${size},"
r
":${r},"
w
":${w},"
x
":${x},"
c
":${c},"
a
":${a}}"""}

32 
ResourûM­pšg
(
add»ss
, 
off£t
, 
ResourûP”missiÚs
(
r
, 
w
, 
x
, 
c
, 
a
)) =>

33 
Add»ssRªge
.
äomS‘s
(
add»ss
).
m­
 { Add»ssRªge(
ba£
, 
size
) =>

34 
s
"""{"
ba£
":${ba£},"
size
":${size},"
off£t
":${off£t},"
r
":${r},"
w
":${w},"
x
":${x},"
c
":${c},"
a
":${a}}"""}

35 
ResourûIÁ
(
v®ue
è=> 
Seq
(v®ue.
toSŒšg
)

36 
ResourûSŒšg
(
v®ue
è=> 
Seq
("\"" + value + "\"")

37 
ResourûReã»nû
(
v®ue
è=> 
Seq
("\"&" + 
·th
(value) + "\"")

38 
ResourûAlŸs
(
v®ue
è=> 
Seq
("\"&" + 
·th
(value) + "\"")

39 
ResourûM­
(
v®ue
, 
_
) => {

40 
Seq
(
v®ue
.
m­
 {

41 (
key
, 
Seq
(
v
: 
ResourûM­
)è=> 
s
""""
$
{key}":${helper(v).mkString}"""

42 (
key
, 
£q
è=> 
s
""""
$
{key}":[${seq.flatMap(helper).mkString(",")}]"""

43 }.
mkSŒšg
("{", ",", "}"))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/LazyModule.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.{
	gBa£ModuË
, 
	gRawModuË
, 
	gMuÉiIOModuË
, 
	gw™hClockAndRe£t
}

7 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.{
	gSourûInfo
, 
	gSourûLše
, 
	gUÆoÿbËSourûInfo
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gimmubË
.{
	gSÜ‹dM­
,
	gLi¡M­
}

10 
impÜt
 
	gsÿÏ
.
	gut
.
	gm©chšg
.
_


12 
ab¡¿ù
 cÏs 
	cLazyModuË
()(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
)

14 
´Ùeùed
[
dlomacy
] 
v¬
 
chd»n
 = 
Li¡
[
LazyModuË
]()

15 
´Ùeùed
[
dlomacy
] 
v¬
 
nodes
 = 
Li¡
[
Ba£Node
]()

16 
´Ùeùed
[
dlomacy
] 
v¬
 
šfo
: 
SourûInfo
 = 
UÆoÿbËSourûInfo


17 
´Ùeùed
[
dlomacy
] 
v®
 
·»Á
 = 
LazyModuË
.
scİe


20 
´Ùeùed
[
dlomacy
] 
v¬
 
šModuËBody
 = 
Li¡
[(è=> 
Un™
]()

22 
def
 
·»Ás
: 
Seq
[
LazyModuË
] = 
·»Á
 
m©ch
 {

23 
NÚe
 => 
N


24 
	`Some
(
x
è=> x +: x.
·»Ás


27 
LazyModuË
.
scİe
 = 
	$Some
(
this
)

28 
·»Á
.
	`fÜ—ch
(
p
 =>….
chd»n
 = 
this
 ::….children)

31 
´iv©e
 
v¬
 
sugge¡edNameV¬
: 
O±iÚ
[
SŒšg
] = 
NÚe


32 
def
 
	$sugge¡Name
(
x
: 
SŒšg
): 
this
.
ty³
 = 
	`sugge¡Name
(
	$Some
(
x
))

33 
def
 
	$sugge¡Name
(
x
: 
O±iÚ
[
SŒšg
]): 
this
.
ty³
 = {

34 
x
.
fÜ—ch
 { 
n
 => 
sugge¡edNameV¬
 = 
	`Some
(n) }

35 
this


36 
	}
}

38 
´iv©e
 
def
 
	$fšdCÏssName
(
c
: 
CÏss
[
_
]): 
SŒšg
 = {

39 
v®
 
n
 = 
c
.
g‘Name
.
	`¥l™
('.').
Ï¡


40 ià(
n
.
	`cÚšs
('$')è
	`fšdCÏssName
(
c
.
g‘Su³rşass
) n

41 
	}
}

43 
Ïzy
 
v®
 
şassName
 = 
	$fšdCÏssName
(
g‘CÏss
)

44 
Ïzy
 
v®
 
sugge¡edName
 = 
sugge¡edNameV¬
.
	$g‘OrEl£
(
şassName
)

45 
Ïzy
 
v®
 
desœedName
 = 
şassName


47 
def
 
Çme
 = 
sugge¡edName


48 
def
 
lše
 = 
	$sourûLše
(
šfo
)

51 
Ïzy
 
v®
 
moduËName
 = 
moduË
.
Çme


52 
Ïzy
 
v®
 
·thName
 = 
moduË
.pathName

53 
Ïzy
 
v®
 
š¡ªûName
 = 
·thName
.
	`¥l™
('.').
Ï¡


55 
def
 
moduË
: 
LazyModuËImpLike


57 
def
 
om™G¿phML
: 
BoŞ—n
 = !
nodes
.
	`exi¡s
(!
_
.om™G¿phMLè&& !
chd»n
.exists(!_.omitGraphML)

58 
Ïzy
 
v®
 
g¿phML
: 
SŒšg
 = 
·»Á
.
	`m­
(
_
.g¿phML).
g‘OrEl£
 {

59 
v®
 
buf
 = 
Ãw
 
SŒšgBud”


60 
buf
 ++= "<?xml version=\"1.0\"ƒncoding=\"UTF-8\"?>\n"

61 
buf
 ++= "<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:y=\"http://www.yworks.com/xml/graphml\">\n"

62 
buf
 ++= " <key for=\"node\" id=\"n\" yfiles.type=\"nodegraphics\"/>\n"

63 
buf
 ++= " <key for=\"edge\" id=\"e\" yfiles.type=\"edgegraphics\"/>\n"

64 
buf
 ++= " <key for=\"node\" id=\"d\"‡ttr.name=\"Description\"‡ttr.type=\"string\"/>\n"

65 
buf
 ++= " <graph id=\"G\"ƒdgedefault=\"directed\">\n"

66 
	`nodesG¿phML
(
buf
, " ")

67 
	`edgesG¿phML
(
buf
, " ")

68 
buf
 ++= " </graph>\n"

69 
buf
 ++= "</graphml>\n"

70 
buf
.
toSŒšg


71 
	}
}

73 
´iv©e
 
v®
 
	gšdex
 = { 
LazyModuË
.
šdex
 = LazyModuË.šdex + 1; 
	gLazyModuË
.index }

75 
´iv©e
 
def
 
	$nodesG¿phML
(
buf
: 
SŒšgBud”
, 
·d
: 
SŒšg
) {

76 
buf
 ++ğ
s
"""${pad}<node id=\"${index}\">\n"""

77 
buf
 ++ğ
s
"""${pad} <data key=\"n\"><y:ShapeNode><y:NodeLabel modelName=\"sides\" modelPosition=\"w\"„otationAngle=\"270.0\">${instanceName}</y:NodeLabel></y:ShapeNode></data>\n"""

78 
buf
 ++ğ
s
"""${pad} <data key=\"d\">${moduleName} (${pathName})</data>\n"""

79 
buf
 ++ğ
s
"""${pad} <graph id=\"${index}::\"ƒdgedefault=\"directed\">\n"""

80 
nodes
.
	`f‹r
(!
_
.
om™G¿phML
).
fÜ—ch
 { 
n
 =>

81 
buf
 ++ğ
s
"""${pad} <node id=\"${index}::${n.index}\">\n"""

82 
buf
 ++ğ
s
"""${·d} <d©¨key=\"e\"><y:Sh­eNode><y:Sh­ty³="
EÎ£
"/></y:ShapeNode></data>\n"""

83 
buf
 ++ğ
s
"""${pad} <data key=\"d\">${n.nodedebugstring}</data>\n"""

84 
buf
 ++ğ
s
"""${pad} </node>\n"""

86 
chd»n
.
	`f‹r
(!
_
.
om™G¿phML
).
fÜ—ch
 { _.
	`nodesG¿phML
(
buf
, 
·d
 + " ") }

87 
buf
 ++ğ
s
"""${pad} </graph>\n"""

88 
buf
 ++ğ
s
"""${pad}</node>\n"""

89 
	}
}

90 
´iv©e
 
def
 
	$edgesG¿phML
(
buf
: 
SŒšgBud”
, 
·d
: 
SŒšg
) {

91 
nodes
.
	`f‹r
(!
_
.
om™G¿phML
è
fÜ—ch
 { 
n
 =>‚.
ouuts
.f‹r(!_.
_1
.om™G¿phML).fÜ—ch { (
o
, 
edge
) =>

92 
v®
 
	`R’d”edEdge
(
cŞour
, 
Ïb–
, 
æ³d
èğ
edge


93 
buf
 ++ğ
·d


94 
buf
 ++= "<edge"

95 ià(
æ³d
) {

96 
buf
 ++ğ
s
"""arget=\"${index}::${n.index}\""""

97 
buf
 ++ğ
s
""" source=\"${o.lazyModule.index}::${o.index}\">"""

99 
buf
 ++ğ
s
""" source=\"${index}::${n.index}\""""

100 
buf
 ++ğ
s
"""arget=\"${o.lazyModule.index}::${o.index}\">"""

102 
buf
 ++ğ
s
"""<data key=\"e\"><y:PolyLineEdge>"""

103 ià(
æ³d
) {

104 
buf
 ++ğ
s
"""<y:Arrows source=\"standard\"arget=\"none\"/>"""

106 
buf
 ++ğ
s
"""<y:Arrows source=\"none\"arget=\"standard\"/>"""

108 
buf
 ++ğ
s
"""<y:LineStyle color=\"${colour}\"ype=\"line\" width=\"1.0\"/>"""

109 
buf
 ++ğ
s
"""<y:EdgeLabel modelName=\"centered\"„otationAngle=\"270.0\">${label}</y:EdgeLabel>"""

110 
buf
 ++ğ
s
"""</y:PolyLineEdge></data></edge>\n"""

112 
chd»n
.
	`f‹r
(!
_
.
om™G¿phML
).
fÜ—ch
 { 
c
 => c.
	`edgesG¿phML
(
buf
, 
·d
) }

113 
	}
}

115 
def
 
nodeI‹¿tÜ
(
™”func
: (
LazyModuË
è=> 
Un™
): Unit = {

116 
™”func
(
this
)

117 
chd»n
.
fÜ—ch
Ğ
_
.
nodeI‹¿tÜ
(
™”func
) )

120 
def
 
g‘Chd»n
 = 
chd»n


123 
objeù
 
LazyModuË


125 
´Ùeùed
[
dlomacy
] 
v¬
 
scİe
: 
O±iÚ
[
LazyModuË
] = 
NÚe


126 
´iv©e
 
v¬
 
šdex
 = 0

128 
def
 
­¶y
[
T
 <: 
LazyModuË
](
bc
: T)(
im¶ic™
 
v®Name
: 
V®Name
, 
	gsourûInfo
: 
SourûInfo
): T = {

132 
»quœe
 (
scİe
.
isDefšed
, 
s
"LazyModule()‡ppliedo ${bc.name}wice ${sourceLine(sourceInfo)}")

133 
»quœe
 (
scİe
.
g‘
 
eq
 
bc
, 
s
"LazyModule()‡ppliedo ${bc.name} before ${scope.get.name} ${sourceLine(sourceInfo)}")

134 
scİe
 = 
bc
.
·»Á


135 
bc
.
šfo
 = 
sourûInfo


136 ià(!
bc
.
sugge¡edNameV¬
.
isDefšed
èbc.
sugge¡Name
(
v®Name
.
Çme
)

137 
bc


141 
£®ed
 
Œa™
 
LazyModuËImpLike
 
ex‹nds
 
	gRawModuË


143 
v®
 
	gw¿µ”
: 
LazyModuË


144 
v®
‡uto: 
AutoBundË


145 
´Ùeùed
[
dlomacy
] 
v®
 
dªgËs
: 
Seq
[
DªgË
]

148 
»quœe
 (!
LazyModuË
.
scİe
.
isDefšed
, 
s
"${wrapper.name}.module was constructed before LazyModule() was„un on ${LazyModule.scope.get.name}")

150 
ov”ride
 
def
 
	gdesœedName
 = 
w¿µ”
.
desœedName


151 
sugge¡Name
(
w¿µ”
.
sugge¡edName
)

153 
im¶ic™
 
v®
 
p
 = 
w¿µ”
.p

155 
´Ùeùed
[
dlomacy
] 
def
 
š¡ªtŸ‹
() = {

156 
v®
 
chdDªgËs
 = 
w¿µ”
.
chd»n
.
»v”£
.
æ©M­
 { 
c
 =>

157 
im¶ic™
 
v®
 
sourûInfo
 = 
c
.
šfo


158 
v®
 
mod
 = 
ModuË
(
c
.
moduË
)

159 
mod
.
fšishIn¡ªtŸ‹
()

160 
mod
.
dªgËs


162 
v®
 
	gnodeDªgËs
 = 
w¿µ”
.
nodes
.
»v”£
.
æ©M­
(
_
.
š¡ªtŸ‹
())

163 
v®
 
®lDªgËs
 = 
nodeDªgËs
 ++ 
chdDªgËs


164 
v®
 
·œšg
 = 
SÜ‹dM­
(
®lDªgËs
.
groupBy
(
_
.
sourû
).
toSeq
:_*)

165 
v®
 
dÚe
 = 
S‘
(è++ 
·œšg
.
v®ues
.
f‹r
(
_
.
size
 =ğ2).
m­
 { 
Seq
(
a
, 
b
) =>

166 
»quœe
 (
a
.
æ³d
 !ğ
b
.flipped)

167 ià(
a
.
æ³d
è{‡.
d©a
 <> 
b
.data } { b.data <>‡.data }

168 
a
.
sourû


170 
v®
 
	gfÜw¬d
 = 
®lDªgËs
.
f‹r
(
d
 => !
dÚe
(d.
sourû
))

171 
v®
‡utØğ
IO
(
Ãw
 
AutoBundË
(
fÜw¬d
.
m­
 { 
d
 => (d.
Çme
, d.
d©a
, d.
æ³d
è}:
_
*))

172 
v®
 
dªgËs
 = (
fÜw¬d
 
z
‡uto.
–em’ts
è
m­
 { (
d
, (
_
, 
io
)) =>

173 ià(
d
.
æ³d
è{ d.
d©a
 <> 
io
 } { io <> d.data }

174 
d
.
cİy
(
d©a
 = 
io
, 
Çme
 = 
w¿µ”
.
sugge¡edName
 + "_" + d.name)

176 
	gw¿µ”
.
	gšModuËBody
.
	g»v”£
.
	gfÜ—ch
 { 
_
() }

177 ×uto, 
	gdªgËs
)

180 
	g´Ùeùed
[
dlomacy
] 
def
 
fšishIn¡ªtŸ‹
() {

181 
	gw¿µ”
.
	gnodes
.
	g»v”£
.
	gfÜ—ch
 { 
	g_
.
fšishIn¡ªtŸ‹
() }

185 şas 
	cLazyModuËImp
(
v®
 
w¿µ”
: 
LazyModuË
è
ex‹nds
 
MuÉiIOModuË
 
w™h
 
LazyModuËImpLike
 {

186 
	`v®
 (auto, 
dªgËs
èğ
	`š¡ªtŸ‹
()

189 şas 
	cLazyRawModuËImp
(
v®
 
w¿µ”
: 
LazyModuË
è
ex‹nds
 
RawModuË
 
w™h
 
LazyModuËImpLike
 {

193 
v®
 
chdClock
 = 
	`Wœe
(
	$Clock
())

194 
v®
 
chdRe£t
 = 
	`Wœe
(
	$BoŞ
())

195 
chdClock
 :ğ
	`BoŞ
(
çl£
).
asClock


196 
chdRe£t
 :ğ
	$BoŞ
(
Œue
)

197 
	`v®
 (auto, 
dªgËs
èğ
	$w™hClockAndRe£t
(
chdClock
, 
chdRe£t
) {

198 
	`š¡ªtŸ‹
()

200 
	}
}

202 şas 
	cSim¶eLazyModuË
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


204 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
)

207 
Œa™
 
LazyScİe


209 
this
: 
LazyModuË
 =>

210 
ov”ride
 
def
 
toSŒšg
: 
SŒšg
 = 
s
"LazyScope‚amed $name"

211 
def
 
­¶y
[
T
](
body
: => T) = {

212 
v®
 
§ved
 = 
LazyModuË
.
scİe


213 
LazyModuË
.
scİe
 = 
	`Some
(
this
)

214 
v®
 
out
 = 
body


215 
	`»quœe
 (
LazyModuË
.
scİe
.
isDefšed
, 
s
"LazyScope ${name}riedoƒxit, but scope wasƒmpty!")

216 
	`»quœe
 (
LazyModuË
.
scİe
.
g‘
 
eq
 
this
, 
s
"LazyScope ${name}ƒxited before LazyModule ${LazyModule.scope.get.name} was closed")

217 
LazyModuË
.
scİe
 = 
§ved


218 
out


220 
	}
}

222 
objeù
 
	gLazyScİe


224 
def
 
	g­¶y
[
T
](
	gbody
: => T)(
im¶ic™
 
v®Name
: 
V®Name
, 
	gp
: 
P¬am‘”s
): T = {

225 
v®
 
scİe
 = 
LazyModuË
(
Ãw
 
Sim¶eLazyModuË
 
w™h
 
LazyScİe
)

226 
scİe
 { 
body
 }

228 
def
 
­¶y
[
T
](
Çme
: 
SŒšg
)(
body
: => T)(
im¶ic™
 
p
: 
P¬am‘”s
): T = {

229 
­¶y
(
body
)(
V®Name
(
Çme
), 
p
)

233 
şass
 
	$H®fEdge
(
£rŸl
: 
IÁ
, 
šdex
: IÁè
ex‹nds
 
Ord”ed
[
H®fEdge
] {

234 
impÜt
 
sÿÏ
.
m©h
.
Ord”ed
.
Üd”šgToOrd”ed


235 
def
 
	`com·»
(
th©
: 
H®fEdge
èğH®fEdge.
	`uÇµly
(
this
è
com·»
 HalfEdge.unapply(that)

236 
	}
}

237 
şass
 
	$DªgË
(
sourû
: 
H®fEdge
, 
sšk
: H®fEdge, 
æ³d
: 
BoŞ—n
, 
Çme
: 
SŒšg
, 
d©a
: 
D©a
)

239 
fš®
 
şass
 
	`AutoBundË
(
–ts
: (
SŒšg
, 
D©a
, 
BoŞ—n
)*è
ex‹nds
 
RecÜd
 {

241 
v®
 
–em’ts
 = 
	`Li¡M­
(è++ 
–ts
.
zW™hIndex
.
	`m­
(
makeEËm’ts
).
	`groupBy
(
_
.
_1
).
v®ues
.
æ©M­
 {

242 
	`Seq
((
key
, 
–em’t
, 
i
)) => Seq(i -> (key ->ƒlement))

243 
£q
 => seq.
zW™hIndex
.
m­
 { ((
key
, 
–em’t
, 
i
), 
j
) => i -> (key + "_" + j ->ƒlement) }

244 }.
toLi¡
.
	`sÜtBy
(
_
.
_1
).
	`m­
(_.
_2
)

245 
	`»quœe
 (
–em’ts
.
size
 =ğ
–ts
.size)

247 
´iv©e
 
def
 
	`makeEËm’ts
(
tu¶e
: ((
SŒšg
, 
D©a
, 
BoŞ—n
), 
IÁ
)) = {

248 
	`v®
 ((
key
, 
d©a
, 
æ
), 
i
èğ
tu¶e


250 
v®
 
»gex
 = 
Ãw
 
	`Regex
("(_[0-9]+)*$")

251 
v®
 
–em’t
 = ià(
æ
è
d©a
.
şÚeTy³
.flip data.cloneType

252 (
»gex
.
	`»¶aûAÎIn
(
key
, ""), 
–em’t
, 
i
)

255 
ov”ride
 
def
 
şÚeTy³
 = (
Ãw
 
	`AutoBundË
(
–ts
:
_
*)).
asIn¡ªûOf
[
this
.
ty³
]

256 
	}
}

258 
Œa™
 
ModuËV®ue
[
T
]

260 
def
 
g‘W¿µedV®ue
: 
T


263 
objeù
 
InModuËBody


265 
def
 
­¶y
[
T
](
body
: => T): 
ModuËV®ue
[T] = {

266 
»quœe
 (
LazyModuË
.
scİe
.
isDefšed
, 
s
"InModuleBody invoked outside‡ LazyModule")

267 
v®
 
scİe
 = 
LazyModuË
.scİe.
g‘


268 
v®
 
out
 = 
Ãw
 
ModuËV®ue
[
T
] {

269 
v¬
 
»suÉ
: 
O±iÚ
[
T
] = 
NÚe


270 
def
 
execu‹
(è{ 
»suÉ
 = 
Some
(
body
) }

271 
def
 
g‘W¿µedV®ue
 = {

272 
»quœe
 (
»suÉ
.
isDefšed
, 
s
"InModuleBody contents were„equested before module wasƒvaluated!")

273 
»suÉ
.
g‘


276 
	gscİe
.
	gšModuËBody
 = (
out
.
execu‹
 
_
è+: 
scİe
.
šModuËBody


277 
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Nodes.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gP¬am‘”s
,
	gF›ld
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
H‘”og’eousBag


9 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
Li¡Bufãr


10 
impÜt
 
	gsÿÏ
.
	gut
.
	gm©chšg
.
_


12 
objeù
 
MÚ™ÜsEÇbËd
 
ex‹nds
 
	gF›ld
[
BoŞ—n
](
	gŒue
)

13 
objeù
 
R’d”Fl³d
 
ex‹nds
 
	gF›ld
[
BoŞ—n
](
	gçl£
)

15 
şass
 
R’d”edEdge
(

16 
cŞour
: 
SŒšg
,

17 
Ïb–
: 
SŒšg
 = "",

18 
æ³d
: 
BoŞ—n
 = 
çl£
)

24 
Œa™
 
Inw¬dNodeImp
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
]

26 
def
 
edgeI
(
pd
: 
DI
, 
pu
: 
UI
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
): 
EI


27 
def
 
bundËI
(
ei
: 
EI
): 
BI


30 
def
 
mÚ™Ü
(
bundË
: 
BI
, 
edge
: 
EI
) {}

31 
def
 
»nd”
(
e
: 
EI
): 
R’d”edEdge


34 
def
 
mixI
(
pu
: 
UI
, 
node
: 
Inw¬dNode
[
DI
, UI, 
BI
]): UI =…u

41 
Œa™
 
Outw¬dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
 <: 
D©a
]

43 
def
 
edgeO
(
pd
: 
DO
, 
pu
: 
UO
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
): 
EO


44 
def
 
bundËO
(
eo
: 
EO
): 
BO


47 
def
 
mixO
(
pd
: 
DO
, 
node
: 
Outw¬dNode
[DO, 
UO
, 
BO
]): DO =…d

48 
def
 
g‘I
(
pd
: 
DO
): 
O±iÚ
[
Ba£Node
] = 
NÚe


51 
ab¡¿ù
 
şass
 
NodeImp
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
]

52 
ex‹nds
 
Objeù
 
w™h
 
Inw¬dNodeImp
[
D
, 
U
, 
EI
, 
B
] w™h 
	gOutw¬dNodeImp
[D, U, 
EO
, B]

55 
ab¡¿ù
 
şass
 
	gSim¶eNodeImp
[
D
, 
U
, 
E
, 
B
 <: 
D©a
]

56 
ex‹nds
 
NodeImp
[
D
, 
U
, 
E
, E, 
B
]

58 
def
 
edge
(
pd
: 
D
, 
pu
: 
U
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
): 
E


59 
def
 
edgeO
(
pd
: 
D
, 
pu
: 
U
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
edge
(pd,…u,…, sourceInfo)

60 
def
 
edgeI
(
pd
: 
D
, 
pu
: 
U
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
edge
(pd,…u,…, sourceInfo)

61 
def
 
bundË
(
e
: 
E
): 
B


62 
def
 
bundËO
(
e
: 
E
èğ
bundË
(e)

63 
def
 
bundËI
(
e
: 
E
èğ
bundË
(e)

66 
ab¡¿ù
 cÏs 
	cBa£Node
(
im¶ic™
 
v®
 
v®Name
: 
V®Name
)

68 
	`»quœe
 (
LazyModuË
.
scİe
.
isDefšed
, "You cannot create‡‚ode outside‡ LazyModule!")

70 
v®
 
ÏzyModuË
 = 
LazyModuË
.
scİe
.
g‘


71 
v®
 
šdex
 = 
ÏzyModuË
.
nodes
.
size


72 
ÏzyModuË
.
nodes
 = 
this
 ::†azyModule.nodes

74 
v®
 
£rŸl
 = 
Ba£Node
.serial

75 
Ba£Node
.
£rŸl
 = BaseNode.serial + 1

76 
´Ùeùed
[
dlomacy
] 
def
 
	$š¡ªtŸ‹
(): 
Seq
[
DªgË
]

77 
´Ùeùed
[
dlomacy
] 
def
 
	$fšishIn¡ªtŸ‹
(): 
Un™


79 
def
 
Çme
 = 
ÏzyModuË
.Çm+ "." + 
v®Name
.name

80 
def
 
om™G¿phML
 = 
ouuts
.
isEm±y
 && 
šputs
.isEmpty

81 
Ïzy
 
v®
 
nodedebug¡ršg
: 
SŒšg
 = ""

83 
def
 
·»Ás
: 
Seq
[
LazyModuË
] = 
ÏzyModuË
 +:†azyModule.parents

84 
def
 
desütiÚ
: 
SŒšg
 = ""

85 
def
 
loÿtiÚ
: 
SŒšg
 = 
s
"(A $desütiÚ‚odw™h…¬’ˆ${ÏzyModuË.Çme}" + 
·»Ás
.

.
h—dO±iÚ
.
	`m­
(" insid" + 
_
.
Çme
).
	`g‘OrEl£
("") + ")"

87 
def
 
wœeP»fix
 = {

88 
v®
 
ÿm–Ca£
 = "([a-z])([A-Z])".
r


89 
v®
 
deÿm–
 = 
ÿm–Ca£
.
	`»¶aûAÎIn
(
v®Name
.
Çme
, 
_
 
m©ch
 { 
	`ÿm–Ca£
(
l
, 
h
) =>† + "_" + h })

90 
v®
 
ŒimNode
 = "_?node$".
r


91 
v®
 
Çme
 = 
ŒimNode
.
	`»¶aûFœ¡In
(
deÿm–
.
toLow”Ca£
, "")

92 ià(
Çme
.
isEm±y
) "" name + "_"

95 
def
 
šputs
: 
Seq
[(
Ba£Node
, 
R’d”edEdge
)]

96 
def
 
ouuts
: 
Seq
[(
Ba£Node
, 
R’d”edEdge
)]

98 
´Ùeùed
[
dlomacy
] 
v®
 
sškC¬d
: 
IÁ


99 
´Ùeùed
[
dlomacy
] 
v®
 
sourûC¬d
: 
IÁ


100 
´Ùeùed
[
dlomacy
] 
v®
 
æexes
: 
Seq
[
Ba£Node
]

101 
	}
}

103 
objeù
 
Ba£Node


105 
´Ùeùed
[
dlomacy
] 
v¬
 
£rŸl
 = 0

108 
Œa™
 
NoHªdË


109 
objeù
 
NoHªdËObjeù
 
ex‹nds
 
NoHªdË


111 
Œa™
 
NodeHªdË
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data]

112 
ex‹nds
 
Inw¬dNodeHªdË
[
DI
, 
UI
, 
EI
, 
BI
] 
w™h
 
	gOutw¬dNodeHªdË
[
DO
, 
UO
, 
EO
, 
BO
]

115 
ov”ride
 
	gdef
 :ğ[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): NodeHªdË[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(
h
, 
BIND_ONCE
); NodeHªdË(h, 
this
) }

116 
ov”ride
 
	gdef
 :*ğ[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): NodeHªdË[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(
h
, 
BIND_STAR
); NodeHªdË(h, 
this
) }

117 
ov”ride
 
	gdef
 :=* [
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): NodeHªdË[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(
h
, 
BIND_QUERY
); NodeHªdË(h, 
this
) }

118 
ov”ride
 
	gdef
 :*=*[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): NodeHªdË[DX, UX, EX, BX, 
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(
h
, 
BIND_FLEX
); NodeHªdË(h, 
this
) }

120 
ov”ride
 
	gdef
 :ğ[
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): Outw¬dNodeHªdË[
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(h, 
BIND_ONCE
); 
	gthis
 }

121 
ov”ride
 
	gdef
 :*ğ[
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): Outw¬dNodeHªdË[
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(h, 
BIND_STAR
); 
	gthis
 }

122 
ov”ride
 
	gdef
 :=* [
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): Outw¬dNodeHªdË[
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(h, 
BIND_QUERY
); 
	gthis
 }

123 
ov”ride
 
	gdef
 :*=*[
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): Outw¬dNodeHªdË[
DO
, 
UO
, 
EO
, 
BO
] = { 
bšd
(h, 
BIND_FLEX
); 
	gthis
 }

126 
objeù
 
	gNodeHªdË


128 
def
 
	g­¶y
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: D©a](
i
: 
Inw¬dNodeHªdË
[DI, UI, EI, BI], 
	go
: 
Outw¬dNodeHªdË
[DO, UO, EO, BO]èğ
Ãw
 
NodeHªdËPaœ
(i, 
o
)

131 
şass
 
	gNodeHªdËPaœ
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data]

132 (
šw¬dHªdË
: 
Inw¬dNodeHªdË
[
DI
, 
UI
, 
EI
, 
BI
], 
	goutw¬dHªdË
: 
Outw¬dNodeHªdË
[
DO
, 
UO
, 
EO
, 
BO
])

133 
ex‹nds
 
	gNodeHªdË
[
DI
, 
UI
, 
EI
, 
BI
, 
DO
, 
UO
, 
EO
, 
BO
]

135 
v®
 
	gšw¬d
 = 
šw¬dHªdË
.
šw¬d


136 
v®
 
outw¬d
 = 
outw¬dHªdË
.outward

137 
def
 
šÃr
 = 
šw¬dHªdË
.inner

138 
def
 
ou‹r
 = 
outw¬dHªdË
.outer

141 
Œa™
 
	gInw¬dNodeHªdË
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
] 
ex‹nds
 
NoHªdË


143 
def
 
šw¬d
: 
Inw¬dNode
[
DI
, 
UI
, 
BI
]

144 
def
 
	gšÃr
: 
Inw¬dNodeImp
[
DI
, 
UI
, 
EI
, 
BI
]

146 
´Ùeùed
 
def
 
	gbšd
[
EY
](
	gh
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
], 
	gbšdšg
: 
NodeBšdšg
)(
im¶ic™
 
p
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
Un™
 = 
šw¬d
.
bšd
(
h
.
outw¬d
, 
bšdšg
)

149 
	gdef
 :ğ[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
Inw¬dNodeHªdË
[DX, UX, EX, BX] = { 
bšd
(
h
, 
BIND_ONCE
); h }

150 
	gdef
 :*ğ[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
Inw¬dNodeHªdË
[DX, UX, EX, BX] = { 
bšd
(
h
, 
BIND_STAR
); h }

151 
	gdef
 :=* [
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
Inw¬dNodeHªdË
[DX, UX, EX, BX] = { 
bšd
(
h
, 
BIND_QUERY
); h }

152 
	gdef
 :*=*[
DX
, 
UX
, 
EX
, 
BX
 <: 
D©a
, 
EY
](
	gh
: 
NodeHªdË
[DX, UX, EX, BX, 
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
Inw¬dNodeHªdË
[DX, UX, EX, BX] = { 
bšd
(
h
, 
BIND_FLEX
); h }

154 
	gdef
 :ğ[
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
NoHªdË
 = { 
bšd
(h, 
BIND_ONCE
); 
	gNoHªdËObjeù
 }

155 
	gdef
 :*ğ[
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
NoHªdË
 = { 
bšd
(h, 
BIND_STAR
); 
	gNoHªdËObjeù
 }

156 
	gdef
 :=* [
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
NoHªdË
 = { 
bšd
(h, 
BIND_QUERY
); 
	gNoHªdËObjeù
 }

157 
	gdef
 :*=*[
EY
](
h
: 
Outw¬dNodeHªdË
[
DI
, 
UI
, EY, 
BI
])(
im¶ic™
 
	gp
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
NoHªdË
 = { 
bšd
(h, 
BIND_FLEX
); 
	gNoHªdËObjeù
 }

160 
£®ed
 
Œa™
 
NodeBšdšg


161 
objeù
 
BIND_ONCE
 
ex‹nds
 
NodeBšdšg


162 
objeù
 
BIND_QUERY
 
ex‹nds
 
NodeBšdšg


163 
objeù
 
BIND_STAR
 
ex‹nds
 
NodeBšdšg


164 
objeù
 
BIND_FLEX
 
ex‹nds
 
NodeBšdšg


166 
Œa™
 
	gInw¬dNode
[
DI
, 
UI
, 
BI
 <: 
D©a
] 
ex‹nds
 
Ba£Node


168 
´iv©e
 
v®
 
accPI
 = 
Li¡Bufãr
[(
IÁ
, 
Outw¬dNode
[
DI
, 
UI
, 
BI
], 
	gNodeBšdšg
, 
	gP¬am‘”s
, 
	gSourûInfo
)]()

169 
´iv©e
 
v¬
 
	giR—lized
 = 
çl£


171 
´Ùeùed
[
dlomacy
] 
def
 
iPushed
 = 
accPI
.
size


172 
´Ùeùed
[
dlomacy
] 
def
 
iPush
(
šdex
: 
IÁ
, 
node
: 
Outw¬dNode
[
DI
, 
UI
, 
BI
], 
bšdšg
: 
NodeBšdšg
)(
im¶ic™
 
p
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
) {

173 
v®
 
šfo
 = 
sourûLše
(
sourûInfo
, "‡t ", "")

174 
»quœe
 (!
iR—lized
, 
s
"${Çme}${ÏzyModuË.lše} wa šcÜ»ùly cÚÃùed‡ ¨sšk‡á” it .moduË wa u£d" + 
šfo
)

175 
	gaccPI
 +ğ((
šdex
, 
	gnode
, 
	gbšdšg
, 
	gp
, 
	gsourûInfo
))

178 
	g´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
	giBšdšgs
 = { 
iR—lized
 = 
Œue
; 
	gaccPI
.
»suÉ
() }

180 
	g´Ùeùed
[
dlomacy
] 
v®
 
	giSr
: 
IÁ


181 
´Ùeùed
[
dlomacy
] 
v®
 
iPÜtM­pšg
: 
Seq
[(
IÁ
, Int)]

182 
	g´Ùeùed
[
dlomacy
] 
v®
 
	gdiP¬ams
: 
Seq
[
DI
]

183 
´Ùeùed
[
dlomacy
] 
v®
 
uiP¬ams
: 
Seq
[
UI
]

185 
´Ùeùed
[
dlomacy
] 
def
 
bšd
(
h
: 
Outw¬dNode
[
DI
, 
UI
, 
BI
], 
bšdšg
: 
NodeBšdšg
)(
im¶ic™
 
p
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
): 
Un™


188 
Œa™
 
Outw¬dNodeHªdË
[
DO
, 
UO
, 
EO
, 
BO
 <: 
D©a
] 
ex‹nds
 
NoHªdË


190 
def
 
outw¬d
: 
Outw¬dNode
[
DO
, 
UO
, 
BO
]

191 
def
 
	gou‹r
: 
Outw¬dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
]

194 
Œa™
 
	gOutw¬dNode
[
DO
, 
UO
, 
BO
 <: 
D©a
] 
ex‹nds
 
Ba£Node


196 
´iv©e
 
v®
 
accPO
 = 
Li¡Bufãr
[(
IÁ
, 
Inw¬dNode
 [
DO
, 
UO
, 
BO
], 
	gNodeBšdšg
, 
	gP¬am‘”s
, 
	gSourûInfo
)]()

197 
´iv©e
 
v¬
 
	goR—lized
 = 
çl£


199 
´Ùeùed
[
dlomacy
] 
def
 
oPushed
 = 
accPO
.
size


200 
´Ùeùed
[
dlomacy
] 
def
 
oPush
(
šdex
: 
IÁ
, 
node
: 
Inw¬dNode
 [
DO
, 
UO
, 
BO
], 
bšdšg
: 
NodeBšdšg
)(
im¶ic™
 
p
: 
P¬am‘”s
, 
	gsourûInfo
: 
SourûInfo
) {

201 
v®
 
šfo
 = 
sourûLše
(
sourûInfo
, "‡t ", "")

202 
»quœe
 (!
oR—lized
, 
s
"${Çme}${ÏzyModuË.lše} wa šcÜ»ùly cÚÃùed‡ ¨sourû‡á” it .moduË wa u£d" + 
šfo
)

203 
	gaccPO
 +ğ((
šdex
, 
	gnode
, 
	gbšdšg
, 
	gp
, 
	gsourûInfo
))

206 
	g´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
	goBšdšgs
 = { 
oR—lized
 = 
Œue
; 
	gaccPO
.
»suÉ
() }

208 
	g´Ùeùed
[
dlomacy
] 
v®
 
	goSr
: 
IÁ


209 
´Ùeùed
[
dlomacy
] 
v®
 
oPÜtM­pšg
: 
Seq
[(
IÁ
, Int)]

210 
	g´Ùeùed
[
dlomacy
] 
v®
 
	guoP¬ams
: 
Seq
[
UO
]

211 
´Ùeùed
[
dlomacy
] 
v®
 
doP¬ams
: 
Seq
[
DO
]

214 
ab¡¿ù
 
şass
 
	$CyşeExû±iÚ
(
kšd
: 
SŒšg
, 
loİ
: 
Seq
[SŒšg]è
ex‹nds
 
	`Exû±iÚ
(
s
"Diplomatic ${kind} cycle detected involving ${loop}")

215 
şass
 
	$SrCyşeExû±iÚ
(
loİ
: 
Seq
[
SŒšg
] = 
N
è
ex‹nds
 
	`CyşeExû±iÚ
("star",†oop)

216 
şass
 
	$Downw¬dCyşeExû±iÚ
(
loİ
: 
Seq
[
SŒšg
] = 
N
è
ex‹nds
 
	`CyşeExû±iÚ
("downward",†oop)

217 
şass
 
	$Upw¬dCyşeExû±iÚ
(
loİ
: 
Seq
[
SŒšg
] = 
N
è
ex‹nds
 
	`CyşeExû±iÚ
("upward",†oop)

219 
şass
 
Edges
[
EI
, 
EO
](
š
: EI, 
out
: EO)

220 
£®ed
 
ab¡¿ù
 
şass
 
MixedNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

221 
v®
 
šÃr
: 
Inw¬dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

222 
v®
 
ou‹r
: 
Outw¬dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

223 
im¶ic™
 
v®Name
: 
V®Name
)

224 
ex‹nds
 
Ba£Node
 
w™h
 
NodeHªdË
[
DI
, 
UI
, 
EI
, 
BI
, 
DO
, 
UO
, 
EO
, 
BO
] w™h 
Inw¬dNode
[DI, UI, BI] w™h 
Outw¬dNode
[DO, UO, BO]

226 
v®
 
šw¬d
 = 
this


227 
v®
 
outw¬d
 = 
this


229 
´Ùeùed
[
dlomacy
] 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSr
: IÁ, 
oSr
: Int): (Int, Int)

230 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
DI
]): Seq[
DO
]

231 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
UO
]): Seq[
UI
]

233 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
sškC¬d
 = 
oBšdšgs
.
	`couÁ
(
_
.
_3
 =ğ
BIND_QUERY
è+ 
iBšdšgs
.couÁ(_._3 =ğ
BIND_STAR
)

234 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
sourûC¬d
 = 
iBšdšgs
.
	`couÁ
(
_
.
_3
 =ğ
BIND_QUERY
è+ 
oBšdšgs
.couÁ(_._3 =ğ
BIND_STAR
)

235 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
æexes
 = 
oBšdšgs
.
	`f‹r
(
_
.
_3
 =ğ
BIND_FLEX
).
	`m­
(_.
_2
) ++

236 
iBšdšgs
.
	`f‹r
(
_
.
_3
 =ğ
BIND_FLEX
).
	`m­
(_.
_2
)

237 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
æexOff£t
 = {

238 
def
 
	`DFS
(
v
: 
Ba£Node
, 
vis™ed
: 
M­
[
IÁ
, BaseNode]): Map[Int, BaseNode] = {

239 ià(
vis™ed
.
	`cÚšs
(
v
.
£rŸl
)) {

240 
vis™ed


242 
v
.
æexes
.
	`fŞdLeá
(
vis™ed
 + (v.
£rŸl
 -> v))((
sum
, 
n
è=> 
	`DFS
(n, sum))

245 
v®
 
æexS‘
 = 
	`DFS
(
this
, 
	`M­
()).
v®ues


246 
v®
 
®lSšk
 = 
æexS‘
.
	`m­
(
_
.
sškC¬d
).
sum


247 
v®
 
®lSourû
 = 
æexS‘
.
	`m­
(
_
.
sourûC¬d
).
sum


248 
	`»quœe
 (
æexS‘
.
size
 =ğ1 || 
®lSšk
 =ğ0 || 
®lSourû
 == 0,

249 
s
"The‚odes ${flexSet.map(_.name)} which‡re inter-connected by :*=* have ${allSink} :*= operators‡nd ${allSource} :=* operators connectedohem, making it impossibleo determine cardinality inference direction.")

250 
®lSšk
 - 
®lSourû


253 
´iv©e
 
v¬
 
¡¬CyşeGu¬d
 = 
çl£


254 
´Ùeùed
[
dlomacy
] 
Ïzy
 
	`v®
 (
oPÜtM­pšg
, 
iPÜtM­pšg
, 
oSr
, 
iSr
) = {

255 
Œy
 {

256 ià(
¡¬CyşeGu¬d
è
throw
 
	`SrCyşeExû±iÚ
()

257 
¡¬CyşeGu¬d
 = 
Œue


258 
v®
 
oSrs
 = 
oBšdšgs
.
couÁ
 { (
_
,_,
b
,_,_è=> b =ğ
BIND_STAR
 || (b =ğ
BIND_FLEX
 && 
æexOff£t
 < 0) }

259 
v®
 
iSrs
 = 
iBšdšgs
.
couÁ
 { (
_
,_,
b
,_,_è=> b =ğ
BIND_STAR
 || (b =ğ
BIND_FLEX
 && 
æexOff£t
 >= 0) }

260 
v®
 
oKnown
 = 
oBšdšgs
.
m­
 { (
_
, 
n
, 
b
, _, _è=> b 
m©ch
 {

261 
BIND_ONCE
 => 1

262 
BIND_FLEX
 => { ià(
æexOff£t
 < 0è0 
n
.
iSr
 }

263 
BIND_QUERY
 => 
n
.
iSr


264 
BIND_STAR
 => 0 }}.
	`fŞdLeá
(0)(
_
+_)

265 
v®
 
iKnown
 = 
iBšdšgs
.
m­
 { (
_
, 
n
, 
b
, _, _è=> b 
m©ch
 {

266 
BIND_ONCE
 => 1

267 
BIND_FLEX
 => { ià(
æexOff£t
 >ğ0è0 
n
.
oSr
 }

268 
BIND_QUERY
 => 
n
.
oSr


269 
BIND_STAR
 => 0 }}.
	`fŞdLeá
(0)(
_
+_)

270 
	`v®
 (
iSr
, 
oSr
èğ
	`»sŞveSr
(
iKnown
, 
oKnown
, 
iSrs
, 
oSrs
)

271 
v®
 
oSum
 = 
oBšdšgs
.
m­
 { (
_
, 
n
, 
b
, _, _è=> b 
m©ch
 {

272 
BIND_ONCE
 => 1

273 
BIND_FLEX
 => { ià(
æexOff£t
 < 0è
oSr
 
n
.
iSr
 }

274 
BIND_QUERY
 => 
n
.
iSr


275 
BIND_STAR
 => 
oSr
 }}.
	`sÿnLeá
(0)(
_
+_)

276 
v®
 
iSum
 = 
iBšdšgs
.
m­
 { (
_
, 
n
, 
b
, _, _è=> b 
m©ch
 {

277 
BIND_ONCE
 => 1

278 
BIND_FLEX
 => { ià(
æexOff£t
 >ğ0è
iSr
 
n
.
oSr
 }

279 
BIND_QUERY
 => 
n
.
oSr


280 
BIND_STAR
 => 
iSr
 }}.
	`sÿnLeá
(0)(
_
+_)

281 
v®
 
oTÙ®
 = 
oSum
.
Ï¡O±iÚ
.
	`g‘OrEl£
(0)

282 
v®
 
iTÙ®
 = 
iSum
.
Ï¡O±iÚ
.
	`g‘OrEl£
(0)

283 (
oSum
.
š™
 
z
 oSum.

, 
iSum
.š™ z iSum., 
oSr
, 
iSr
)

284 } 
ÿtch
 {

285 
c
: 
SrCyşeExû±iÚ
 => 
throw
 c.
	`cİy
(
loİ
 = 
s
"${name}${lazyModule.line}" +: c.loop)

289 
Ïzy
 
v®
 
oPÜts
 = 
oBšdšgs
.
æ©M­
 { (
i
, 
n
, 
_
, 
p
, 
s
) =>

290 
	`v®
 (
¡¬t
, 
’d
èğ
n
.
	`iPÜtM­pšg
(
i
)

291 (
¡¬t
 
uÁ
 
’d
è
m­
 { 
j
 => (j, 
n
, 
p
, 
s
) }

293 
Ïzy
 
v®
 
iPÜts
 = 
iBšdšgs
.
æ©M­
 { (
i
, 
n
, 
_
, 
p
, 
s
) =>

294 
	`v®
 (
¡¬t
, 
’d
èğ
n
.
	`oPÜtM­pšg
(
i
)

295 (
¡¬t
 
uÁ
 
’d
è
m­
 { 
j
 => (j, 
n
, 
p
, 
s
) }

298 
´iv©e
 
v¬
 
oP¬amsCyşeGu¬d
 = 
çl£


299 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
diP¬ams
: 
Seq
[
DI
] = 
iPÜts
.
m­
 { (
i
, 
n
, 
_
, _è=>‚.
	`doP¬ams
(i) }

300 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
doP¬ams
: 
Seq
[
DO
] = {

301 
Œy
 {

302 ià(
oP¬amsCyşeGu¬d
è
throw
 
	`Downw¬dCyşeExû±iÚ
()

303 
oP¬amsCyşeGu¬d
 = 
Œue


304 
v®
 
o
 = 
	`m­P¬amsD
(
oPÜts
.
size
, 
diP¬ams
)

305 
	`»quœe
 (
o
.
size
 =ğ
oPÜts
.size, 
s
"Diplomacyƒrror: $name $location has ${o.size} != ${oPorts.size} down/up outer…arameters${lazyModule.line}")

306 
o
.
	`m­
(
ou‹r
.
	`mixO
(
_
, 
this
))

307 } 
ÿtch
 {

308 
c
: 
Downw¬dCyşeExû±iÚ
 => 
throw
 c.
	`cİy
(
loİ
 = 
s
"${name}${lazyModule.line}" +: c.loop)

312 
´iv©e
 
v¬
 
iP¬amsCyşeGu¬d
 = 
çl£


313 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
uoP¬ams
: 
Seq
[
UO
] = 
oPÜts
.
m­
 { (
o
, 
n
, 
_
, _è=>‚.
	`uiP¬ams
(o) }

314 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
uiP¬ams
: 
Seq
[
UI
] = {

315 
Œy
 {

316 ià(
iP¬amsCyşeGu¬d
è
throw
 
	`Upw¬dCyşeExû±iÚ
()

317 
iP¬amsCyşeGu¬d
 = 
Œue


318 
v®
 
i
 = 
	`m­P¬amsU
(
iPÜts
.
size
, 
uoP¬ams
)

319 
	`»quœe
 (
i
.
size
 =ğ
iPÜts
.size, 
s
"Diplomacyƒrror: $name $location has ${i.size} != ${iPorts.size} up/down inner…arameters${lazyModule.line}")

320 
i
.
	`m­
(
šÃr
.
	`mixI
(
_
, 
this
))

321 } 
ÿtch
 {

322 
c
: 
Upw¬dCyşeExû±iÚ
 => 
throw
 c.
	`cİy
(
loİ
 = 
s
"${name}${lazyModule.line}" +: c.loop)

326 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
edgesOut
 = (
oPÜts
 
z
 
doP¬ams
).
m­
 { ((
i
, 
n
, 
p
, 
s
), 
o
è=> 
ou‹r
.
	`edgeO
(o,‚.
	`uiP¬ams
(i),…, s) }

327 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
edgesIn
 = (
iPÜts
 
z
 
uiP¬ams
).
m­
 { ((
o
, 
n
, 
p
, 
s
), 
i
è=> 
šÃr
.
	`edgeI
Ò.
	`doP¬ams
(o), i,…, s) }

330 
Ïzy
 
v®
 
edges
 = 
	`Edges
(
edgesIn
, 
edgesOut
)

332 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
bundËOut
: 
Seq
[
BO
] = 
edgesOut
.
	`m­
(
e
 => 
	`Wœe
(
ou‹r
.
	`bundËO
(e)))

333 
´Ùeùed
[
dlomacy
] 
Ïzy
 
v®
 
bundËIn
: 
Seq
[
BI
] = 
edgesIn
 .
	`m­
(
e
 => 
	`Wœe
(
šÃr
.
	`bundËI
(e)))

335 
´Ùeùed
[
dlomacy
] 
def
 
dªgËsOut
: 
Seq
[
DªgË
] = 
oPÜts
.
zW™hIndex
.
m­
 { ((
j
, 
n
, 
_
, _), 
i
) =>

336 
	`DªgË
(

337 
sourû
 = 
	`H®fEdge
(
£rŸl
, 
i
),

338 
sšk
 = 
	`H®fEdge
(
n
.
£rŸl
, 
j
),

339 
æ³d
ğ
çl£
,

340 
Çme
 = 
wœeP»fix
 + "out",

341 
d©a
 = 
	`bundËOut
(
i
))

343 
´Ùeùed
[
dlomacy
] 
def
 
dªgËsIn
: 
Seq
[
DªgË
] = 
iPÜts
.
zW™hIndex
.
m­
 { ((
j
, 
n
, 
_
, _), 
i
) =>

344 
	`DªgË
(

345 
sourû
 = 
	`H®fEdge
(
n
.
£rŸl
, 
j
),

346 
sšk
 = 
	`H®fEdge
(
£rŸl
, 
i
),

347 
æ³d
ğ
Œue
,

348 
Çme
 = 
wœeP»fix
 + "in",

349 
d©a
 = 
	`bundËIn
(
i
))

352 
´iv©e
 
v¬
 
bundËsSaãNow
 = 
çl£


354 
def
 
out
: 
Seq
[(
BO
, 
EO
)] = {

355 
	`»quœe
(
bundËsSaãNow
, 
s
"${name}.out should only be called fromhe context of its module implementation")

356 
bundËOut
 
z
 
edgesOut


358 
def
 
š
: 
Seq
[(
BI
, 
EI
)] = {

359 
	`»quœe
(
bundËsSaãNow
, 
s
"${name}.in should only be called fromhe context of its module implementation")

360 
bundËIn
 
z
 
edgesIn


364 
´Ùeùed
 
v®
 
id’t™y
 = 
çl£


365 
´Ùeùed
[
dlomacy
] 
def
 
	`š¡ªtŸ‹
() = {

366 
bundËsSaãNow
 = 
Œue


367 ià(!
id’t™y
) {

368 (
iPÜts
 
z
 
š
è
fÜ—ch
 {

369 ((
_
, _, 
p
, _), (
b
, 
e
)è=> ià(
	`p
(
MÚ™ÜsEÇbËd
)è
šÃr
.
	`mÚ™Ü
(b,ƒ)

371 
dªgËsOut
 ++ 
dªgËsIn


374 
´Ùeùed
[
dlomacy
] 
def
 
	`fšishIn¡ªtŸ‹
() = {

375 
bundËsSaãNow
 = 
çl£


379 
´Ùeùed
[
dlomacy
] 
def
 
	`bšd
(
h
: 
Outw¬dNode
[
DI
, 
UI
, 
BI
], 
bšdšg
: 
NodeBšdšg
)(
im¶ic™
 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
) {

380 
v®
 
x
 = 
this


381 
v®
 
y
 = 
h


382 
v®
 
šfo
 = 
	`sourûLše
(
sourûInfo
, "‡t ", "")

383 
v®
 
i
 = 
x
.
iPushed


384 
v®
 
o
 = 
y
.
oPushed


385 
y
.
	`oPush
(
i
, 
x
, 
bšdšg
 
m©ch
 {

386 
BIND_ONCE
 => BIND_ONCE

387 
BIND_FLEX
 => BIND_FLEX

388 
BIND_STAR
 => 
BIND_QUERY


389 
BIND_QUERY
 => 
BIND_STAR
 })

390 
x
.
	`iPush
(
o
, 
y
, 
bšdšg
)

394 
def
 
šputs
 = (
iPÜts
 
z
 
edgesIn
è
m­
 { ((
_
, 
n
, 
p
, _), 
e
) =>

395 
v®
 
»
 = 
šÃr
.
	`»nd”
(
e
)

396 (
n
, 
»
.
	`cİy
(
æ³d
 =„e.æ³d !ğ
	`p
(
R’d”Fl³d
)))

398 
def
 
ouuts
 = 
oPÜts
 
m­
 { (
i
, 
n
, 
_
, _è=> (n,‚.
	`šputs
(i).
_2
) }

399 
	}
}

401 
ab¡¿ù
 
şass
 
	gMixedCu¡omNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

402 
šÃr
: 
Inw¬dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

403 
	gou‹r
: 
Outw¬dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

404 
im¶ic™
 
	gv®Name
: 
V®Name
)

405 
ex‹nds
 
	$MixedNode
(
šÃr
, 
ou‹r
)

407 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int)

408 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
DI
]): Seq[
DO
]

409 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
UO
]): Seq[
UI
]

410 
	}
}

412 
ab¡¿ù
 
şass
 
Cu¡omNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(

413 
im¶ic™
 
	gv®Name
: 
V®Name
)

414 
ex‹nds
 
	$MixedCu¡omNode
(
imp
, imp)

416 
şass
 
MixedAd­‹rNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

417 
šÃr
: 
Inw¬dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

418 
ou‹r
: 
Outw¬dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

419 
dFn
: 
DI
 => 
DO
,

420 
uFn
: 
UO
 => 
UI
)(

421 
im¶ic™
 
v®Name
: 
V®Name
)

422 
ex‹nds
 
	$MixedNode
(
šÃr
, 
ou‹r
)

424 
ov”ride
 
def
 
desütiÚ
 = "adapter"

425 
´Ùeùed
[
dlomacy
] 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

426 
	`»quœe
 (
oSrs
 + 
iSrs
 <ğ1, 
s
"$name $location‡ppears†eft of‡ :*= $iStarsimes‡nd„ight of‡ :=* $oStarsimes;‡t most once is‡llowed${lazyModule.line}")

427 ià(
oSrs
 > 0) {

428 
	`»quœe
 (
iKnown
 >ğ
oKnown
, 
s
"$name $location has $oKnown outputs‡nd $iKnown inputs; cannot‡ssign ${iKnown-oKnown}ƒdgeso„esolve :=*${lazyModule.line}")

429 (0, 
iKnown
 - 
oKnown
)

430 } ià(
iSrs
 > 0) {

431 
	`»quœe
 (
oKnown
 >ğ
iKnown
, 
s
"$name $location has $oKnown outputs‡nd $iKnown inputs; cannot‡ssign ${oKnown-iKnown}ƒdgeso„esolve :*=${lazyModule.line}")

432 (
oKnown
 - 
iKnown
, 0)

434 
	`»quœe
 (
oKnown
 =ğ
iKnown
, 
s
"$name $location has $oKnown outputs‡nd $iKnown inputs;hese do‚ot match")

438 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
DI
]): Seq[
DO
] = {

439 
	`»quœe
(
n
 =ğ
p
.
size
, 
s
"$name $location has ${p.size} inputs‡nd ${n} outputs;hey must match${lazyModule.line}")

440 
p
.
	`m­
(
dFn
)

442 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
UO
]): Seq[
UI
] = {

443 
	`»quœe
(
n
 =ğ
p
.
size
, 
s
"$name $location has ${n} inputs‡nd ${p.size} outputs;hey must match${lazyModule.line}")

444 
p
.
	`m­
(
uFn
)

446 
	}
}

448 
şass
 
	gAd­‹rNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(

449 
	gdFn
: 
D
 => D,

450 
	guFn
: 
U
 => U)(

451 
im¶ic™
 
v®Name
: 
V®Name
)

452 
ex‹nds
 
MixedAd­‹rNode
[
D
, 
U
, 
EI
, 
B
, D, U, 
EO
, B](
	gimp
, imp)(
	gdFn
, 
	guFn
)

455 
şass
 
	gId’t™yNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])()(
im¶ic™
 
	gv®Name
: 
V®Name
)

456 
ex‹nds
 
	$Ad­‹rNode
(
imp
)({ 
s
 => s 
	}
}, { 
	gs
 => s })

458 
´Ùeùed
 
ov”ride
 
v®
 
	gid’t™y
 = 
Œue


459 
ov”ride
 
´Ùeùed
[
dlomacy
] 
def
 
š¡ªtŸ‹
() = {

460 
v®
 
dªgËs
 = 
su³r
.
š¡ªtŸ‹
()

461 (
out
 
z
 
š
è
m­
 { ((
o
, 
_
), (
i
, _)) => o <> i }

462 
	gdªgËs


466 
şass
 
	gMixedNexusNode
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: Data](

467 
šÃr
: 
Inw¬dNodeImp
 [
DI
, 
UI
, 
EI
, 
BI
],

468 
	gou‹r
: 
Outw¬dNodeImp
[
DO
, 
UO
, 
EO
, 
BO
])(

469 
	gdFn
: 
Seq
[
DI
] => 
DO
,

470 
	guFn
: 
Seq
[
UO
] => 
UI
,

472 
	gšputRequœesOuut
: 
BoŞ—n
 = 
Œue
,

473 
	gouutRequœesIÅut
: 
BoŞ—n
 = 
Œue
)(

474 
im¶ic™
 
v®Name
: 
V®Name
)

475 
ex‹nds
 
	$MixedNode
(
šÃr
, 
ou‹r
)

477 
ov”ride
 
def
 
desütiÚ
 = "nexus"

478 
´Ùeùed
[
dlomacy
] 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

480 
	`»quœe
 (!
ouutRequœesIÅut
 || 
oKnown
 =ğ0 || 
iSrs
 + 
iKnown
 !ğ0, 
s
"$name $location has $oKnown„equired outputs‡nd‚o…ossible inputs")

481 
	`»quœe
 (!
šputRequœesOuut
 || 
iKnown
 =ğ0 || 
oSrs
 + 
oKnown
 !ğ0, 
s
"$name $location has $iKnown„equired inputs‡nd‚o…ossible outputs")

482 ià(
iKnown
 =ğ0 && 
oKnown
 == 0) (0, 0) (1, 1)

484 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
DI
]): Seq[
DO
] = { iàÒ > 0è{ 
v®
 
a
 = 
	`dFn
Õ); Seq.
	`fl
Ò)×è} 
N
 }

485 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
UO
]): Seq[
UI
] = { iàÒ > 0è{ 
v®
 
a
 = 
	`uFn
Õ); Seq.
	`fl
Ò)×è} 
N
 }

486 
	}
}

488 
şass
 
	gNexusNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(

489 
	gdFn
: 
Seq
[
D
] => D,

490 
	guFn
: 
Seq
[
U
] => U,

491 
	gšputRequœesOuut
: 
BoŞ—n
 = 
Œue
,

492 
	gouutRequœesIÅut
: 
BoŞ—n
 = 
Œue
)(

493 
im¶ic™
 
v®Name
: 
V®Name
)

494 
ex‹nds
 
MixedNexusNode
[
D
, 
U
, 
EI
, 
B
, D, U, 
EO
, B](
	gimp
, imp)(
	gdFn
, 
	guFn
, 
	gšputRequœesOuut
, 
	gouutRequœesIÅut
)

497 
şass
 
	gSourûNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(
	gpo
: 
Seq
[D])(
im¶ic™
 
v®Name
: 
V®Name
)

498 
ex‹nds
 
	$MixedNode
(
imp
, imp)

500 
ov”ride
 
def
 
desütiÚ
 = "source"

501 
´Ùeùed
[
dlomacy
] 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

502 
	`»quœe
 (
oSrs
 <ğ1, 
s
"$name $location‡ppears„ight of‡ :=* ${oStars}imes;‡t most once is‡llowed${lazyModule.line}")

503 
	`»quœe
 (
iSrs
 =ğ0, 
s
"$name $location cannot‡ppear†eft of‡ :*=${lazyModule.line}")

504 
	`»quœe
 (
iKnown
 =ğ0, 
s
"$name $location cannot‡ppear†eft of‡ :=${lazyModule.line}")

505 
	`»quœe
 (
po
.
size
 =ğ
oKnown
 || 
oSrs
 =ğ1, 
s
"$name $location has only ${oKnown} outputs connected out of ${po.size}")

506 
	`»quœe
 (
po
.
size
 >ğ
oKnown
, 
s
"$name $location has ${oKnown} outputs out of ${po.size}; cannot‡ssign ${po.size - oKnown}ƒdgeso„esolve :=*${lazyModule.line}")

507 (0, 
po
.
size
 - 
oKnown
)

509 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
D
]): Seq[D] = 
po


510 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
U
]): Seq[U] = 
	`Seq
()

511 
	}
}

514 
şass
 
SškNode
[
D
, 
U
, 
EO
, 
EI
, 
B
 <: 
D©a
](
imp
: 
NodeImp
[D, U, EO, EI, B])(
	gpi
: 
Seq
[U])(
im¶ic™
 
v®Name
: 
V®Name
)

515 
ex‹nds
 
	$MixedNode
(
imp
, imp)

517 
ov”ride
 
def
 
desütiÚ
 = "sink"

518 
´Ùeùed
[
dlomacy
] 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

519 
	`»quœe
 (
iSrs
 <ğ1, 
s
"$name $location‡ppears†eft of‡ :*= ${iStars}imes;‡t most once is‡llowed${lazyModule.line}")

520 
	`»quœe
 (
oSrs
 =ğ0, 
s
"$name $location cannot‡ppear„ight of‡ :=*${lazyModule.line}")

521 
	`»quœe
 (
oKnown
 =ğ0, 
s
"$name $location cannot‡ppear„ight of‡ :=${lazyModule.line}")

522 
	`»quœe
 (
pi
.
size
 =ğ
iKnown
 || 
iSrs
 =ğ1, 
s
"$name $location has only ${iKnown} inputs connected out of ${pi.size}")

523 
	`»quœe
 (
pi
.
size
 >ğ
iKnown
, 
s
"$name $location has ${iKnown} inputs out of ${pi.size}; cannot‡ssign ${pi.size - iKnown}ƒdgeso„esolve :*=${lazyModule.line}")

524 (
pi
.
size
 - 
iKnown
, 0)

526 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
D
]): Seq[D] = 
	`Seq
()

527 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
U
]): Seq[U] = 
pi


528 
	}
}

530 
şass
 
MixedTe¡Node
[
DI
, 
UI
, 
EI
, 
BI
 <: 
D©a
, 
DO
, 
UO
, 
EO
, 
BO
 <: D©a] 
´Ùeùed
[
dlomacy
](

531 
node
: 
NodeHªdË
 [
DI
, 
UI
, 
EI
, 
BI
, 
DO
, 
UO
, 
EO
, 
BO
], 
	gşÚe
: 
ClÚeLazyModuË
)(

532 
im¶ic™
 
v®Name
: 
V®Name
)

533 
ex‹nds
 
	$MixedNode
(
node
.
šÃr
,‚ode.
ou‹r
)

536 
def
 
iP¬ams
: 
Seq
[
DI
] = 
node
.
šw¬d
 .
diP¬ams


537 
def
 
oP¬ams
: 
Seq
[
UO
] = 
node
.
outw¬d
.
uoP¬ams


539 
ov”ride
 
def
 
desütiÚ
 = "test"

540 
´Ùeùed
[
dlomacy
] 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

541 
	`»quœe
 (
oSrs
 <ğ1, 
s
"$name $location‡ppears„ight of‡ :=* $oStarsimes;‡t most once is‡llowed${lazyModule.line}")

542 
	`»quœe
 (
iSrs
 <ğ1, 
s
"$name $location‡ppears†eft of‡ :*= $iStarsimes;‡t most once is‡llowed${lazyModule.line}")

543 
	`»quœe
 (
node
.
šw¬d
 .
uiP¬ams
.
size
 =ğ
iKnown
 || 
iSrs
 =ğ1, 
s
"$name $location has only $iKnown inputs connected out of ${node.inward.uiParams.size}")

544 
	`»quœe
 (
node
.
outw¬d
.
doP¬ams
.
size
 =ğ
oKnown
 || 
oSrs
 =ğ1, 
s
"$name $location has only $oKnown outputs connected out of ${node.outward.doParams.size}")

545 (
node
.
šw¬d
.
uiP¬ams
.
size
 - 
iKnown
,‚ode.
outw¬d
.
doP¬ams
.siz- 
oKnown
)

548 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
UO
]): Seq[
UI
] = 
node
.
šw¬d
 .
uiP¬ams


549 
´Ùeùed
[
dlomacy
] 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
DI
]): Seq[
DO
] = 
node
.
outw¬d
.
doP¬ams


551 
ov”ride
 
´Ùeùed
[
dlomacy
] 
def
 
	`š¡ªtŸ‹
() = {

552 
v®
 
dªgËs
 = 
su³r
.
	`š¡ªtŸ‹
()

553 
v®
 
Üig_moduË
 = 
şÚe
.
ba£
.
moduË


554 
v®
 
şÚe_auto
 = 
şÚe
.
	`io
("auto").
asIn¡ªûOf
[
AutoBundË
]

556 
dªgËsOut
.
zW™hIndex
.
fÜ—ch
 { (
d
, 
i
) =>

557 
v®
 
Üig
 = 
Üig_moduË
.
dªgËs
.
	`fšd
(
_
.
sourû
 =ğ
	`H®fEdge
(
node
.
outw¬d
.
£rŸl
, 
i
))

558 
	`»quœe
 (
Üig
.
isDefšed
, 
s
"Cloned‚ode ${node.outward.name} must be connectedƒxternally out ${orig_module.name}")

559 
v®
 
io_Çme
 = 
Üig_moduË
.auto.
–em’ts
.
	`fšd
(
_
.
_2
 
eq
 
Üig
.
g‘
.
d©a
).g‘.
_1


560 
d
.
d©a
 <> 
şÚe_auto
.
	`–em’ts
(
io_Çme
)

562 
dªgËsIn
.
zW™hIndex
.
fÜ—ch
 { (
d
, 
i
) =>

563 
v®
 
Üig
 = 
Üig_moduË
.
dªgËs
.
	`fšd
(
_
.
sšk
 =ğ
	`H®fEdge
(
node
.
šw¬d
.
£rŸl
, 
i
))

564 
	`»quœe
 (
Üig
.
isDefšed
, 
s
"Cloned‚ode ${node.inward.name} must be connectedƒxternally in ${orig_module.name}")

565 
v®
 
io_Çme
 = 
Üig_moduË
.auto.
–em’ts
.
	`fšd
(
_
.
_2
 
eq
 
Üig
.
g‘
.
d©a
).g‘.
_1


566 
şÚe_auto
.
	`–em’ts
(
io_Çme
è<> 
d
.
d©a


569 
dªgËs


571 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Parameters.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gShiáQueue
, 
	gR©iÚ®DœeùiÚ
, 
	gFa¡ToSlow
, 
	gAsyncQueueP¬ams
}

9 
objeù
 
	gRegiÚTy³
 {

11 
v®
 
	gÿ£s
 = 
Seq
(
CACHED
, 
TRACKED
, 
UNCACHED
, 
UNCACHEABLE
, 
PUT_EFFECTS
, 
GET_EFFECTS
)

12 
£®ed
 
Œa™
 
T
 
ex‹nds
 
	gOrd”ed
[T] {

13 
def
 
com·»
(
th©
: 
T
): 
IÁ
 = 
ÿ£s
.
šdexOf
Ñh©ècom·» ca£s.šdexOf(
this
)

16 
objeù
 
CACHED
 
ex‹nds
 
T


17 
objeù
 
TRACKED
 
ex‹nds
 
T


18 
objeù
 
UNCACHED
 
ex‹nds
 
T


19 
objeù
 
UNCACHEABLE
 
ex‹nds
 
T


20 
objeù
 
PUT_EFFECTS
 
ex‹nds
 
T


21 
objeù
 
GET_EFFECTS
 
ex‹nds
 
T


25 
şass
 
	$IdRªge
(
¡¬t
: 
IÁ
, 
’d
: IÁè
ex‹nds
 
Ord”ed
[
IdRªge
]

27 
	`»quœe
 (
¡¬t
 >ğ0, 
s
"Ids cannot be‚egative, but got: $start.")

28 
	`»quœe
 (
¡¬t
 <ğ
’d
, "Id„anges cannot be‚egative.")

30 
def
 
	`com·»
(
x
: 
IdRªge
) = {

31 
v®
 
´im¬y
 = (
this
.
¡¬t
 - 
x
.¡¬t).
signum


32 
v®
 
£cÚd¬y
 = (
x
.
’d
 - 
this
.’d).
signum


33 ià(
´im¬y
 !ğ0è´im¬y 
£cÚd¬y


36 
def
 
	`ov”Ïps
(
x
: 
IdRªge
èğ
¡¬t
 < x.
’d
 && x.start <ƒnd

37 
def
 
	`cÚšs
(
x
: 
IdRªge
èğ
¡¬t
 <ğx.¡¬ˆ&& x.
’d
 <=ƒnd

39 
def
 
	`cÚšs
(
x
: 
IÁ
èğ
¡¬t
 <ğx && x < 
’d


40 
def
 
	`cÚšs
(
x
: 
UIÁ
) =

41 ià(
size
 == 0) {

42 
	`BoŞ
(
çl£
)

43 } ià(
size
 == 1) {

44 
x
 ==ğ
	`UIÁ
(
¡¬t
)

47 
v®
 
Ïrge¡D–B™
 = 
	`log2FloÜ
(
¡¬t
 ^ (
’d
-1))

48 
v®
 
sm®Ë¡CommÚB™
 = 
Ïrge¡D–B™
 + 1

49 
v®
 
uncommÚMask
 = (1 << 
sm®Ë¡CommÚB™
) - 1

50 
v®
 
uncommÚB™s
 = (
x
 | 
	`UIÁ
(0, 
width
=
sm®Ë¡CommÚB™
))(
Ïrge¡D–B™
, 0)

52 (
x
 >> 
sm®Ë¡CommÚB™
è==ğ
	`UIÁ
(
¡¬t
 >> smallestCommonBit) &&

54 
	`UIÁ
(
¡¬t
 & 
uncommÚMask
è<ğ
uncommÚB™s
 &&

55 
uncommÚB™s
 <ğ
	`UIÁ
((
’d
-1è& 
uncommÚMask
)

58 
def
 
	`shiá
(
x
: 
IÁ
èğ
	`IdRªge
(
¡¬t
+x, 
’d
+x)

59 
def
 
size
 = 
’d
 - 
¡¬t


60 
def
 
isEm±y
 = 
’d
 =ğ
¡¬t


62 
def
 
¿nge
 = 
¡¬t
 
uÁ
 
’d


63 
	}
}

65 
objeù
 
	gIdRªge


67 
def
 
ov”Ïps
(
s
: 
Seq
[
IdRªge
]èğià(s.
isEm±y
è
NÚe
 {

68 
v®
 
¿nges
 = 
s
.
sÜ‹d


69 (
¿nges
.

 
z
„ªges.
š™
è
fšd
 { (
a
, 
b
è=>‡ 
ov”Ïps
 b }

74 
şass
 
	$T¿nsãrSizes
(
mš
: 
IÁ
, 
max
: Int)

76 
def
 
	`this
(
x
: 
IÁ
) =his(x, x)

78 
	`»quœe
 (
mš
 <ğ
max
, 
s
"Minransfer $min > maxransfer $max")

79 
	`»quœe
 (
mš
 >ğ0 && 
max
 >ğ0, 
s
"TransferSizes must be…ositive, got: ($min, $max)")

80 
	`»quœe
 (
max
 =ğ0 || 
	`isPow2
(max), 
s
"TransferSizes must be‡…ower of 2, got: $max")

81 
	`»quœe
 (
mš
 =ğ0 || 
	`isPow2
(mš), 
s
"TransferSizes must be‡…ower of 2, got: $min")

82 
	`»quœe
 (
max
 =ğ0 || 
mš
 !ğ0, 
s
"TransferSize 0 is forbidden unless (0,0), got: ($min, $max)")

84 
def
 
nÚe
 = 
mš
 == 0

85 
def
 
	`cÚšs
(
x
: 
IÁ
èğ
	`isPow2
(xè&& 
mš
 <ğx && x <ğ
max


86 
def
 
	`cÚšsLg
(
x
: 
IÁ
èğ
	`cÚšs
(1 << x)

87 
def
 
	`cÚšsLg
(
x
: 
UIÁ
) =

88 ià(
nÚe
è
	`BoŞ
(
çl£
)

89 ià(
mš
 =ğ
max
è{ 
	`UIÁ
(
	`log2Ce
(mš)è==ğ
x
 }

90 { 
	`UIÁ
(
	`log2Ce
(
mš
)è<ğ
x
 && x <ğUIÁÖog2Ce(
max
)) }

92 
def
 
	`cÚšs
(
x
: 
T¿nsãrSizes
èğx.
nÚe
 || (
mš
 <ğx.mš && x.
max
 <= max)

94 
def
 
	`š‹r£ù
(
x
: 
T¿nsãrSizes
) =

95 ià(
x
.
max
 < 
mš
 || max < x.mšè
T¿nsãrSizes
.
nÚe


96 
	`T¿nsãrSizes
(
sÿÏ
.
m©h
.
	`max
(
mš
, 
x
.mš), sÿÏ.m©h.
	`mš
(
max
, x.max))

98 
ov”ride
 
def
 
	`toSŒšg
(èğ"T¿nsãrSizes[%d, %d]".
	`fÜm©
(
mš
, 
max
)

100 
	}
}

102 
objeù
 
	gT¿nsãrSizes
 {

103 
def
 
­¶y
(
x
: 
IÁ
èğ
Ãw
 
T¿nsãrSizes
(x)

104 
v®
 
nÚe
 = 
Ãw
 
T¿nsãrSizes
(0)

106 
im¶ic™
 
def
 
asBoŞ
(
x
: 
T¿nsãrSizes
èğ!x.
nÚe


113 
şass
 
	$Add»ssS‘
(
ba£
: 
BigIÁ
, 
mask
: BigIÁè
ex‹nds
 
Ord”ed
[
Add»ssS‘
]

116 
	`»quœe
 ((
ba£
 & 
mask
è=ğ0, 
s
"Mis-aligned AddressSets‡re forbidden, got: ($base, $mask)")

117 
	`»quœe
 (
ba£
 >ğ0, 
s
"AddressSet‚egative base is‡mbiguous: $base")

120 
def
 
	`cÚšs
(
x
: 
BigIÁ
èğ((x ^ 
ba£
è& ~
mask
) == 0

121 
def
 
	`cÚšs
(
x
: 
UIÁ
èğ((x ^ 
	`UIÁ
(
ba£
)).
	`zext
(è& 
	`SIÁ
(~
mask
)) === SInt(0)

124 
def
 
	`Ëg®ize
(
x
: 
UIÁ
): UIÁ = 
ba£
.
U
 | (
mask
.U & x)

127 
def
 
	`ov”Ïps
(
x
: 
Add»ssS‘
èğ(~(
mask
 | x.maskè& (
ba£
 ^ x.base)) == 0

129 
def
 
	`cÚšs
(
x
: 
Add»ssS‘
èğ((x.
mask
 | (
ba£
 ^ x.base)) & ~mask) == 0

132 
def
 
®ignm’t
 = ((
mask
 + 1) & ~mask)

134 
def
 
cÚtiguous
 = 
®ignm’t
 =ğ
mask
+1

136 
def
 
fš™e
 = 
mask
 >= 0

137 
def
 
max
 = { 
	`»quœe
 (
fš™e
, "Max cªnÙ bÿlcuÏ‹d oÀšfš™mask"); 
ba£
 | 
mask
 }

140 
def
 
	`wid’
(
imask
: 
BigIÁ
èğ
	`Add»ssS‘
(
ba£
 & ~imask, 
mask
 | imask)

143 
def
 
	`š‹r£ù
(
x
: 
Add»ssS‘
): 
O±iÚ
[AddressSet] = {

144 ià(!
	`ov”Ïps
(
x
)) {

145 
NÚe


147 
v®
 
r_mask
 = 
mask
 & 
x
.mask

148 
v®
 
r_ba£
 = 
ba£
 | 
x
.base

149 
	`Some
(
	`Add»ssS‘
(
r_ba£
, 
r_mask
))

153 
def
 
	`subŒaù
(
x
: 
Add»ssS‘
): 
Seq
[AddressSet] = {

154 ià(!
	`ov”Ïps
(
x
)) {

155 
	`Seq
(
this
)

157 
v®
 
Ãw_šæex
 = ~
x
.
mask
 & mask

158 
v®
 
äaùu»
 = 
Add»ssS‘
.
	`’um”©eMask
(
Ãw_šæex
).
	`æ©M­
(
m
 => 
	`š‹r£ù
(
	`Add»ssS‘
(m, ~new_inflex)))

159 
äaùu»
.
	`f‹r
(!
_
.
	`ov”Ïps
(
x
))

164 
def
 
	`com·»
(
x
: 
Add»ssS‘
) = {

165 
v®
 
´im¬y
 = (
this
.
ba£
 - 
x
.ba£).
signum


166 
v®
 
£cÚd¬y
 = (
x
.
mask
 - 
this
.mask).
signum


167 ià(
´im¬y
 !ğ0è´im¬y 
£cÚd¬y


171 
ov”ride
 
def
 
	`toSŒšg
() = {

172 ià(
mask
 >= 0) {

173 "Add»ssS‘(0x%x, 0x%x)".
	`fÜm©
(
ba£
, 
mask
)

175 "Add»ssS‘(0x%x, ~0x%x)".
	`fÜm©
(
ba£
, ~
mask
)

179 
def
 
toRªges
 = {

180 
	`»quœe
 (
fš™e
, "Ranges cannot be calculated on infinite mask")

181 
v®
 
size
 = 
®ignm’t


182 
v®
 
äagm’ts
 = 
mask
 & ~(
size
-1)

183 
v®
 
b™s
 = 
	`b™Indexes
(
äagm’ts
)

184 (
	`BigIÁ
(0è
	`uÁ
 (BigIÁ(1è<< 
b™s
.
size
)).
m­
 { 
i
 =>

185 
v®
 
off
 = 
	`b™Indexes
(
i
).
	`fŞdLeá
(
ba£
è{ (
a
, 
b
è=>‡.
	`£tB™
(
	`b™s
(b)) }

186 
	`Add»ssRªge
(
off
, 
size
)

189 
	}
}

191 
objeù
 
	gAdd»ssS‘


193 
v®
 
	gev”ythšg
 = 
Add»ssS‘
(0, -1)

194 
def
 
mi§ligÃd
(
ba£
: 
BigIÁ
, 
size
: BigIÁ, 

: 
Seq
[
Add»ssS‘
] = Seq()): Seq[AddressSet] = {

195 ià(
size
 =ğ0è

.
»v”£
 {

196 
v®
 
maxBa£Alignm’t
 = 
ba£
 & (-base)

197 
v®
 
maxSizeAlignm’t
 = 
BigIÁ
(1è<< 
log2FloÜ
(
size
)

198 
v®
 
¡•
 =

199 ià(
maxBa£Alignm’t
 =ğ0 || maxBa£Alignm’ˆ> 
maxSizeAlignm’t
)

200 
maxSizeAlignm’t
 
maxBa£Alignm’t


201 
mi§ligÃd
(
ba£
+
¡•
, 
size
-¡•, 
Add»ssS‘
(ba£, s‹p-1è+: 

)

205 
def
 
unify
(
£q
: 
Seq
[
Add»ssS‘
]): Seq[AddressSet] = {

206 
v®
 
n
 = 
£q
.
size


207 
v®
 
¬¿y
 = 
A¼ay
(
£q
:
_
*)

208 
v¬
 
f‹r
 = 
A¼ay
.
fl
(
n
è{ 
çl£
 }

209 
i
 <- 0 
uÁ
 
n
-1è{ ià(!
f‹r
(i)) {

210 
j
 <- 
i
+1 
uÁ
 
n
è{ ià(!
f‹r
(j)) {

211 
v®
 
a
 = 
¬¿y
(
i
)

212 
v®
 
b
 = 
¬¿y
(
j
)

213 ià(
a
.
mask
 =ğ
b
.mask && 
isPow2
×.
ba£
 ^ b.base)) {

214 
v®
 
c_ba£
 = 
a
.
ba£
 & ~×.ba£ ^ 
b
.base)

215 
v®
 
c_mask
 = 
a
.
mask
 | (a.
ba£
 ^ 
b
.base)

216 
f‹r
.
upd©e
(
j
, 
Œue
)

217 
	g¬¿y
.
upd©e
(
i
, 
Add»ssS‘
(
c_ba£
, 
c_mask
))

221 
v®
 
	gout
 = (
¬¿y
 
z
 
f‹r
è
æ©M­
 { (
a
, 
f
è=> ià(fè
NÚe
 
Some
(a) }

222 ià(
	gout
.
	gsize
 !ğ
n
è
unify
(
out
èout.
toLi¡


225 
def
 
’um”©eMask
(
mask
: 
BigIÁ
): 
Seq
[BigInt] = {

226 
def
 
h–³r
(
id
: 
BigIÁ
): 
Seq
[BigInt] =

227 ià(
id
 =ğ
mask
è
Seq
(idèid +: 
h–³r
(((~mask | id) + 1) & mask)

228 
h–³r
(0)

231 
def
 
’um”©eB™s
(
mask
: 
BigIÁ
): 
Seq
[BigInt] = {

232 
def
 
h–³r
(
x
: 
BigIÁ
): 
Seq
[BigInt] = {

233 ià(
x
 == 0) {

234 
N


236 
v®
 
b™
 = 
x
 & (-x)

237 
b™
 +: 
h–³r
(
x
 & ~bit)

240 
h–³r
(
mask
)

244 
şass
 
	$BufãrP¬ams
(
d•th
: 
IÁ
, 
æow
: 
BoŞ—n
, 
pe
: Boolean)

246 
	`»quœe
 (
d•th
 >= 0, "Buffer depth must be >= 0")

247 
def
 
isDefšed
 = 
d•th
 > 0

248 
def
 
Ï‹ncy
 = ià(
isDefšed
 && !
æow
) 1 0

250 
def
 
­¶y
[
T
 <: 
D©a
](
x
: 
Decou¶edIO
[T]) =

251 ià(
isDefšed
è
	`Queue
(
x
, 
d•th
, 
æow
=æow, 
pe
=pipe)

252 
x


254 
def
 
sq
[
T
 <: 
D©a
](
x
: 
Decou¶edIO
[T]) =

255 ià(!
isDefšed
è
x
 {

256 
v®
 
sq
 = 
	`ModuË
(
Ãw
 
	`ShiáQueue
(
x
.
b™s
, 
d•th
, 
æow
=æow, 
pe
=pipe))

257 
sq
.
io
.
’q
 <> 
x


258 
sq
.
io
.
deq


261 
ov”ride
 
def
 
	`toSŒšg
(èğ"BufãrP¬ams:%d%s%s".
	`fÜm©
(
d•th
, ià(
æow
è"F" "", ià(
pe
) "P" "")

263 
	}
}

265 
objeù
 
	gBufãrP¬ams


267 
im¶ic™
 
def
 
­¶y
(
d•th
: 
IÁ
): 
BufãrP¬ams
 = BufãrP¬ams(d•th, 
çl£
, false)

269 
v®
  = 
BufãrP¬ams
(2)

270 
v®
 
nÚe
 = 
BufãrP¬ams
(0)

271 
v®
 
æow
 = 
BufãrP¬ams
(1, 
Œue
, 
çl£
)

272 
v®
 
	gpe
 = 
BufãrP¬ams
(1, 
çl£
, 
Œue
)

275 
şass
 
	$TriS‹V®ue
(
v®ue
: 
BoŞ—n
, 
£t
: Boolean)

277 
def
 
	`upd©e
(
Üig
: 
BoŞ—n
èğià(
£t
è
v®ue
 orig

278 
	}
}

280 
objeù
 
TriS‹V®ue


282 
im¶ic™
 
def
 
­¶y
(
v®ue
: 
BoŞ—n
): 
TriS‹V®ue
 = TriS‹V®ue(v®ue, 
Œue
)

283 
def
 
	gun£t
 = 
TriS‹V®ue
(
çl£
, false)

287 
£®ed
 
Œa™
 
	gClockCrossšgTy³


289 
def
 
	g§meClock
 = 
this
 
m©ch
 {

290 
_
: 
SynchrÚousCrossšg
 => 
Œue


291 
_
 => 
çl£


295 
objeù
 
NoCrossšg


296 
şass
 
	$SynchrÚousCrossšg
(
·¿ms
: 
BufãrP¬ams
 = BufãrP¬ams.è
ex‹nds
 
ClockCrossšgTy³


297 
şass
 
	$R©iÚ®Crossšg
(
dœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Fa¡ToSlow
è
ex‹nds
 
ClockCrossšgTy³


298 
şass
 
	$AsynchrÚousCrossšg
(
d•th
: 
IÁ
 = 8, 
sourûSync
: IÁ = 3, 
sškSync
: IÁ = 3, 
§ã
: 
BoŞ—n
 = 
Œue
, 
Ç¼ow
: BoŞ—Àğ
çl£
è
ex‹nds
 
ClockCrossšgTy³


300 
def
 
asSškP¬ams
 = 
	`AsyncQueueP¬ams
(
d•th
, 
sškSync
, 
§ã
, 
Ç¼ow
)

301 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Resources.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
log2Ce


6 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gimmubË
.{
	gLi¡M­
,
	gSÜ‹dM­
}

7 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
HashM­


9 
£®ed
 
Œa™
 
ResourûV®ue


18 
şass
 
	$ResourûP”missiÚs
(
r
: 
BoŞ—n
, 
w
: BoŞ—n, 
x
: BoŞ—n, 
c
: BoŞ—n, 
a
: Boolean)

24 
fš®
 
şass
 
	$ResourûAdd»ss
(
add»ss
: 
Seq
[
Add»ssS‘
], 
³rmissiÚs
: 
ResourûP”missiÚs
è
ex‹nds
 
ResourûV®ue


27 
def
 
	`this
(
x
: 
IÁ
èğthis(
	`Seq
(
	`Add»ssS‘
(x, 0)), 
	`ResourûP”missiÚs
(
çl£
, false, false, false, false))

28 
	}
}

29 
objeù
 
	gResourûAdd»ss
 {

30 
def
 
­¶y
(
x
: 
IÁ
èğ
Ãw
 
ResourûAdd»ss
(x)

38 
fš®
 
şass
 
	$ResourûM­pšg
(
add»ss
: 
Seq
[
Add»ssS‘
], 
off£t
: 
BigIÁ
, 
³rmissiÚs
: 
ResourûP”missiÚs
è
ex‹nds
 
ResourûV®ue


39 
fš®
 şas 
	cResourûSŒšg
(
v®ue
: 
SŒšg
è
ex‹nds
 
ResourûV®ue


40 
fš®
 şas 
	cResourûIÁ
(
v®ue
: 
BigIÁ
è
ex‹nds
 
ResourûV®ue
 {

41 
def
 
	`this
(
x
: 
DoubË
èğthis(
	`BigDecim®
(x).
	`£tSÿË
(0, 
BigDecim®
.
RoundšgMode
.
HALF_UP
).
toBigIÁ
)

43 
objeù
 
ResourûIÁ
 {

44 
def
 
	`­¶y
(
x
: 
DoubË
èğ
Ãw
 
	`ResourûIÁ
(x)

45 
	}
}

50 
fš®
 
şass
 
	$ResourûReã»nû
(
v®ue
: 
SŒšg
è
ex‹nds
 
ResourûV®ue


51 
fš®
 
şass
 
	$ResourûAlŸs
(
v®ue
: 
SŒšg
è
ex‹nds
 
ResourûV®ue


52 
fš®
 
şass
 
	$ResourûM­
(
v®ue
: 
M­
[
SŒšg
, 
Seq
[
ResourûV®ue
]], 
Ïb–s
: Seq[SŒšg] = 
N
è
ex‹nds
 ResourceValue

55 
şass
 
	$Bšdšg
(
deviû
: 
O±iÚ
[
Deviû
], 
v®ue
: 
ResourûV®ue
)

56 
şass
 
	$ResourûBšdšgs
(
m­
: 
M­
[
SŒšg
, 
Seq
[
Bšdšg
]] = M­.
em±y
)

58 
def
 
	`­¶y
(
key
: 
SŒšg
): 
Seq
[
Bšdšg
] = 
m­
.
	`g‘OrEl£
(key, 
N
)

59 
	}
}

65 
şass
 
	$DesütiÚ
(
Çme
: 
SŒšg
, 
m­pšg
: 
M­
[SŒšg, 
Seq
[
ResourûV®ue
]])

67 
ab¡¿ù
 cÏs 
	cDeviû


69 
def
 
	$desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ


71 
def
 
·»Á
: 
O±iÚ
[
Deviû
] = 
NÚe


74 
v®
 
Ïb–
 = "L" + 
Deviû
.
šdex
.
toSŒšg


75 
Deviû
.
šdex
 = Device.index + 1

78 
ab¡¿ù
 cÏs 
	cDeviûSn³t
 
ex‹nds
 
Deviû


80 
fš®
 
def
 
	`desüibe
(
»sourûs
: 
ResourûBšdšgs
èğ
	$desüibe
()

81 
def
 
	$desüibe
(): 
DesütiÚ


83 
ResourûBšdšg
 { 
	`Resourû
(
this
, "exi¡s").
	`bšd
(
	`ResourûSŒšg
("yes")) }

84 
	}
}

86 
objeù
 
	gDeviû


88 
´iv©e
 
v¬
 
	gšdex
: 
IÁ
 = 0

89 
def
 
skIndexes
(
x
: 
IÁ
è{ 
šdex
 += x }

93 
Œa™
 
DeviûIÁ”ru±s


95 
this
: 
Deviû
 =>

98 
v®
 
®waysEx‹nded
 = 
çl£


99 
def
 
desüibeIÁ”ru±s
(
»sourûs
: 
ResourûBšdšgs
): 
M­
[
SŒšg
, 
Seq
[
ResourûV®ue
]] = {

100 
v®
 ğ
»sourûs
("int")

102 .
fÜ—ch
 { 
b
 => 
»quœe
 (b.
deviû
.
isDefšed
, "Device ${devname}…roperty 'int' is missing user device") }

103 
v®
 
	g·»Ás
 = .
m­
(
_
.
deviû
.
g‘
).
di¡šù


104 
v®
 
sim¶e
 = 
·»Ás
.
size
 =ğ1 && !
®waysEx‹nded


106 
v®
 
·»Á
 =

107 ià(!
sim¶e
è
NÚe
 

108 
Some
("š‹¼u±-·»Á" -> 
Seq
(
ResourûReã»nû
(
·»Ás
.
h—d
.
Ïb–
)))

109 
v®
 
š‹¼u±s
 =

110 ià(!
sim¶e
è
NÚe
 

111 
Some
("š‹¼u±s" -> .
m­
(
_
.
v®ue
))

113 
v®
 
š‹¼u±s_ex‹nded
 =

114 ià(
sim¶e
 || 
·»Ás
.
isEm±y
è
NÚe
 

115 
Some
("š‹¼u±s-ex‹nded" -> .
æ©M­
(
b
 => 
Seq
(
ResourûReã»nû
(b.
deviû
.
g‘
.
Ïb–
), b.
v®ue
)))

117 
Li¡M­
(è++ 
	g·»Á
 ++ 
	gš‹¼u±s
 ++ 
	gš‹¼u±s_ex‹nded


120 
def
 ğ
Seq
(
Resourû
(
this
, "int"))

124 
Œa™
 
	gDeviûClocks


126 
	gthis
: 
Deviû
 =>

129 
v®
 
»quœedClocks
 = 0 
to
 1

130 
def
 
desüibeClocks
(
»sourûs
: 
ResourûBšdšgs
): 
M­
[
SŒšg
, 
Seq
[
ResourûV®ue
]] = {

131 
v®
 
şocks
 = 
»sourûs
("şocks").
m­
(
_
.
v®ue
)

132 
»quœe
 (
»quœedClocks
.
cÚšs
(
şocks
.
size
))

133 ià(!
şocks
.
isEm±y
è
M­
("clocks" -> clocks) Map()

138 
Œa™
 
	gDeviûRegName


140 
	gthis
: 
Deviû
 =>

141 
def
 
desüibeName
(
devÇme
: 
SŒšg
, 
»sourûs
: 
ResourûBšdšgs
): String = {

142 
v®
 
»g
 = 
»sourûs
.
m­
.
f‹rKeys
(
»gF‹r
)

143 ià(
»g
.
isEm±y
) {

144 
devÇme


146 
v®
 (
Çmed
, 
bulk
èğ
»g
.
·¹™iÚ
 { (
k
, 
v
è=> 
»gName
(k).
isDefšed
 }

147 
v®
 
	gmaš»g
 = 
»g
.
fšd
(
x
 => 
»gName
(x.
_1
è=ğ"cÚŒŞ").
g‘OrEl£
Ôeg.
h—d
).
_2


148 
»quœe
 (!
maš»g
.
isEm±y
, 
s
"reg binding for $devname isƒmpty!")

149 
	gmaš»g
.
	gh—d
.
v®ue
 
	gm©ch
 {

150 
	gx
: 
ResourûAdd»ss
 => 
s
"${devname}@${x.address.head.base.toString(16)}"

151 
_
 => 
»quœe
(
çl£
, 
s
"Device hashe wrongype of 'reg'…roperty (${reg.head})"); ""

156 
def
 
»g
(
Çme
: 
SŒšg
): 
Seq
[
Resourû
] = Seq(Resourû(
this
, "reg/" +‚ame))

157 
def
 
	g»g
: 
Seq
[
Resourû
] = Seq(Resourû(
this
, "reg"))

159 
def
 
»gF‹r
(
Çme
: 
SŒšg
): 
BoŞ—n
 =‚am=ğ"»g" ||‚ame.
ke
(4) == "reg/"

160 
def
 
»gName
(
Çme
: 
SŒšg
): 
O±iÚ
[String] = {

161 
v®
 
keys
 = 
Çme
.
¥l™
("/")

162 
»quœe
 (
keys
.
size
 >ğ1 && keys.siz<ğ2 && keys(0è=ğ"»g", 
s
"Invalid„eg‚ame '${name}'")

163 ià(
	gkeys
.
	gsize
 =ğ1è
NÚe
 
Some
(
keys
(1))

171 
şass
 
	$Sim¶eDeviû
(
devÇme
: 
SŒšg
, 
devcom·t
: 
Seq
[SŒšg]è
ex‹nds
 
Deviû


172 
w™h
 
DeviûIÁ”ru±s


173 
w™h
 
DeviûClocks


174 
w™h
 
DeviûRegName


176 
ov”ride
 
def
 
·»Á
 = 
	`Some
(
ResourûAnchÜs
.
soc
)

177 
def
 
	`desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

178 
v®
 
Çme
 = 
	`desüibeName
(
devÇme
, 
»sourûs
)

179 
v®
 ğ
	`desüibeIÁ”ru±s
(
»sourûs
)

180 
v®
 
şocks
 = 
	`desüibeClocks
(
»sourûs
)

182 
def
 
	`İtDef
(
x
: 
SŒšg
, 
£q
: 
Seq
[
ResourûV®ue
]èğià(£q.
isEm±y
è
NÚe
 
	`Some
(x -> seq)

183 
v®
 
com·t
 = 
	`İtDef
("com·tibË", 
devcom·t
.
	`m­
(
	`ResourûSŒšg
(
_
)))

185 
v®
 
»g
 = 
»sourûs
.
m­
.
	`f‹rKeys
(
»gF‹r
)

186 
	`v®
 (
Çmed
, 
bulk
èğ
»g
.
·¹™iÚ
 { (
k
, 
v
è=> 
	`»gName
(k).
isDefšed
 }

188 
Çmed
.
fÜ—ch
 {

189 (
k
, 
	`Seq
(
	`Bšdšg
(
_
, 
v®ue
: 
ResourûAdd»ss
))) =>

190 
v®
 
¿nges
 = 
Add»ssRªge
.
	`äomS‘s
(
v®ue
.
add»ss
)

191 
	`»quœe
 (
¿nges
.
size
 =ğ1, 
s
"DTS device $name has $k = $ranges, must be‡ single„ange!")

192 (
k
, 
£q
) =>

193 
	`»quœe
 (
çl£
, 
s
"DTS device $name has $k = $seq, must be‡ single ResourceAddress!")

196 
v®
 
Çmes
 = 
	`İtDef
("»g-Çmes", 
Çmed
.
	`m­
(
x
 => 
	`ResourûSŒšg
(
	`»gName
(x.
_1
).
g‘
)).
toLi¡
)

197 
v®
 
»gs
 = 
	`İtDef
("»g", (
Çmed
 ++ 
bulk
).
	`æ©M­
(
_
.
_2
.
	`m­
(_.
v®ue
)).
toLi¡
)

199 
	`DesütiÚ
(
Çme
, 
	`Li¡M­
(è++ 
com·t
 ++ ++ 
şocks
 ++ 
Çmes
 ++ 
»gs
)

201 
	}
}

208 
şass
 
	$Sim¶eBus
(
devÇme
: 
SŒšg
, 
devcom·t
: 
Seq
[SŒšg], 
off£t
: 
BigIÁ
 = 0è
ex‹nds
 
	`Sim¶eDeviû
(devÇme, devcom·ˆ++ 
	`Seq
("simple-bus"))

210 
ov”ride
 
def
 
	`desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

211 
v®
 
¿nges
 = 
	`»sourûs
("¿nges").
cŞËù
 {

212 
	`Bšdšg
(
_
, 
a
: 
ResourûAdd»ss
è=> 
	`ResourûM­pšg
×.
add»ss
, 
off£t
,‡.
³rmissiÚs
)

214 
	`»quœe
 (!
¿nges
.
isEm±y
, 
s
"SimpleBus $devname must set„anges")

216 
v®
 
m­
 = 
Add»ssRªge
.
	`äomS‘s
(
¿nges
.
	`æ©M­
(
_
.
add»ss
))

217 
v®
 
mšBa£
 = 
m­
.
	`m­
(
_
.
ba£
).
mš


218 
v®
 
maxBa£
 = 
m­
.
	`m­
(
_
.
’d
).
max


219 
v®
 
maxSize
 = 
m­
.
	`m­
(
_
.
size
).
max


221 
def
 
	`ofIÁ
(
x
: 
IÁ
èğ
	`Seq
(
	`ResourûIÁ
(
	`BigIÁ
(x)))

222 
v®
 
exŒa
 = 
	`M­
(

223 "#add»ss-ûÎs" -> 
	`ofIÁ
((
	`log2Ce
(
maxBa£
) + 31) / 32),

224 "#size-ûÎs" -> 
	`ofIÁ
((
	`log2Ce
(
maxSize
) + 31) / 32),

225 "¿nges" -> 
¿nges
)

227 
v®
 
	`DesütiÚ
(
_
, 
m­pšg
èğ
su³r
.
	`desüibe
(
»sourûs
)

228 
	`DesütiÚ
(
s
"${devÇme}@${mšBa£.toSŒšg(16)}", 
m­pšg
 ++ 
exŒa
)

231 
def
 
¿nges
 = 
	`Seq
(
	`Resourû
(
this
, "ranges"))

232 
	}
}

235 şas 
	cMemÜyDeviû
 
ex‹nds
 
Deviû
 
w™h
 
	mDeviûRegName


237 
def
 
	$desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

238 
	`DesütiÚ
(
	`desüibeName
("memÜy", 
»sourûs
), 
	`Li¡M­
(

239 "»g" -> 
»sourûs
.
m­
.
	`f‹rKeys
(
»gF‹r
).
	`æ©M­
(
_
.
_2
).
	`m­
(_.
v®ue
).
toLi¡
,

240 "deviû_ty³" -> 
	`Seq
(
	`ResourûSŒšg
("memory"))))

242 
	}
}

244 
şass
 
	$Resourû
(
owÃr
: 
Deviû
, 
key
: 
SŒšg
)

246 
def
 
	`bšd
(
u£r
: 
Deviû
, 
v®ue
: 
ResourûV®ue
) {

247 
v®
 
scİe
 = 
BšdšgScİe
.
aùive
.
g‘


248 
scİe
.
»sourûBšdšgs
 = (
this
, 
	`Some
(
u£r
), 
v®ue
) +: scope.resourceBindings

250 
def
 
	`bšd
(
v®ue
: 
ResourûV®ue
) {

251 
v®
 
scİe
 = 
BšdšgScİe
.
aùive
.
g‘


252 
scİe
.
»sourûBšdšgs
 = (
this
, 
NÚe
, 
v®ue
) +: scope.resourceBindings

254 
	}
}

257 
Œa™
 
BšdšgScİe


259 
this
: 
LazyModuË
 =>

261 
´iv©e
 
v®
 
·»ÁScİe
 = 
BšdšgScİe
.
fšd
(
·»Á
)

262 
´Ùeùed
[
dlomacy
] 
v¬
 
»sourûBšdšgFns
: 
Seq
[(è=> 
Un™
] = 
N


263 
´Ùeùed
[
dlomacy
] 
v¬
 
»sourûBšdšgs
: 
Seq
[(
Resourû
, 
O±iÚ
[
Deviû
], 
	gResourûV®ue
)] = 
N


265 
´iv©e
 
şass
 
Ex·ndedV®ue
(
·th
: 
Seq
[
SŒšg
], 
Ïb–s
: Seq[SŒšg], 
v®ue
: Seq[
ResourûV®ue
])

266 
´iv©e
 
Ïzy
 
v®
 
ev®
: 
Un™
 = {

267 
»quœe
 (!
LazyModuË
.
scİe
.
isDefšed
, "May‚otƒvaluate binding while still constructing LazyModules")

268 
·»ÁScİe
.
fÜ—ch
 { 
_
.
ev®
 }

269 
»sourûBšdšgs
 = 
·»ÁScİe
.
m­
(
_
.»sourûBšdšgs).
g‘OrEl£
(
N
)

270 
BšdšgScİe
.
aùive
 = 
Some
(
this
)

271 
»sourûBšdšgFns
.
»v”£
.
fÜ—ch
 { 
_
() }

272 
BšdšgScİe
.
aùive
 = 
NÚe


273 
»sourûBšdšgFns
 = 
N


276 
´iv©e
 
def
 
makeT»e
(
li¡
: 
Seq
[
Ex·ndedV®ue
]): Seq[
ResourûV®ue
] = {

277 
v®
 (
v®ues_p
, 
keys_p
èğ
li¡
.
·¹™iÚ
(
_
.
·th
.
isEm±y
)

278 
v®
 
v®ues
 = 
v®ues_p
.
æ©M­
(
_
.
v®ue
)

279 
v®
 
Ïb–s
 = 
v®ues_p
.
æ©M­
(
_
.labels)

280 
v®
 
keys
 = 
keys_p
.
groupBy
(
_
.
·th
.
h—d
).
toLi¡
.
m­
 { (
key
, 
£q
) =>

281 (
key
 -> 
makeT»e
(
£q
.
m­
 { 
x
 => x.
cİy
(
·th
 = x.·th.

) }))

283 ià(
	gÏb–s
.
	gisEm±y
 && 
	gkeys
.isEm±yè
v®ues
 
ResourûM­
(
SÜ‹dM­
(
keys
:
_
*), 
Ïb–s
) +: values

286 
´iv©e
 
def
 
ex·nd
(
·th
: 
Seq
[
SŒšg
], 
v®ues
: Seq[
ResourûV®ue
]): Seq[
Ex·ndedV®ue
] = {

287 
Ex·ndedV®ue
(
·th
, 
N
, Nil) +:

288 
v®ues
.
æ©M­
 {

289 
ResourûM­
(
m­
, 
Ïb–s
) =>

290 
Ex·ndedV®ue
(
·th
, 
Ïb–s
, 
N
) +:

291 
m­
.
toLi¡
.
æ©M­
 { (
key
, 
	gv®ues
è=> 
ex·nd
(
·th
 :+ key, 
v®ues
) }

292 
	gz
 => 
Seq
(
Ex·ndedV®ue
(
·th
, 
N
, Seq(
z
)))

296 
´iv©e
 
def
 
cŞËù
(
skRoÙ
: 
IÁ
, 
·th
: 
Li¡
[
SŒšg
], 
off£t
: 
BigIÁ
, 
m­
: 
ResourûM­
): Li¡[(SŒšg, 
ResourûAdd»ss
)] = {

298 
v®
 
Çme
 = 
·th
.
h—dO±iÚ
.
g‘OrEl£
("/")

299 
def
 
shiá
(
x
: 
Seq
[
Add»ssS‘
]èğx.
m­
(
a
 =>‡.
cİy
(
ba£
 =‡.ba£ + 
off£t
))

300 
v®
 
add»s£s
: 
Li¡
[(
SŒšg
, 
ResourûAdd»ss
)] = 
m­
.
v®ue
.
toLi¡
.
æ©M­
 { (
_
, 
£q
è=> seq.
cŞËù
 {

301 
y
: 
ResourûAdd»ss
 => (
Çme
 -> y.
cİy
(
add»ss
 = 
shiá
(y.address)))

304 
v®
 
haveChdAdd»s£s
 = 
m­
.
v®ue
.
v®ues
.
exi¡s
(
_
.exists {

305 
x
: 
ResourûM­
 => x.
v®ue
.
cÚšs
("reg") || x.value.contains("ranges")

306 
_
 => 
çl£


308 
def
 
m­Chd»n
(
off£t
: 
BigIÁ
èğ
m­
.
v®ue
.
toLi¡
.
æ©M­
 { (
key
, 
£q
è=> seq.
cŞËù
 {

309 
m­
: 
ResourûM­
 => 
cŞËù
(
skRoÙ
, 
key
 :: 
·th
, 
off£t
, map)

310 }.
	gæ©‹n
 }

312 
v®
 
	gchdAdd»s£s
 = 
m­
.
v®ue
.
liá
("¿nges"è
m©ch
 {

314 
NÚe
 
·th
.
size
 < 
skRoÙ
 => 
m­Chd»n
(
off£t
)

316 
NÚe
 => 
N


318 
Some
(
N
è=> 
m­Chd»n
(
off£t
)

320 
Some
(
£q
è!
haveChdAdd»s£s
 => seq.
cŞËù
 {

321 
ResourûM­pšg
(
addr
, 
_
, 
³rm
è=> (
Çme
 -> 
ResourûAdd»ss
(
shiá
(addr),…erm))

324 
Some
(
Seq
(
ResourûM­pšg
(
addr
, 
d–
, 
³rm
))è=> 
m­Chd»n
(
off£t
+delta)

326 
x
 => { 
»quœe
(
çl£
, 
s
"UÃx³ùed v®uš„ªge key: ${x}"); 
	gN
 }

328 
	gadd»s£s
 ++ 
	gchdAdd»s£s


332 
def
 
	gbšdšgT»e
: 
ResourûM­
 = {

333 
ev®


334 
v®
 
m­
: 
M­
[
Deviû
, 
ResourûBšdšgs
] =

335 
»sourûBšdšgs
.
»v”£
.
groupBy
(
_
.
_1
.
owÃr
).
m­V®ues
(
£q
 => 
ResourûBšdšgs
(

336 
£q
.
groupBy
(
_
.
_1
.
key
).
m­V®ues
(_.
m­
(
z
 => 
Bšdšg
(z.
_2
, z.
_3
)).
di¡šù
)))

337 
v®
 
	gdescs
: 
HashM­
[
Deviû
, 
DesütiÚ
] = HashM­.
em±y


338 
def
 
g‘Desc
(
dev
: 
Deviû
): 
DesütiÚ
 = {

339 ià(
descs
.
cÚšs
(
dev
)) {

340 
descs
(
dev
)

342 
v®
 
bšdšgs
 = 
m­
.
liá
(
dev
).
g‘OrEl£
(
ResourûBšdšgs
())

343 
v®
 
DesütiÚ
(
Çme
, 
m­pšg
èğ
dev
.
desüibe
(
bšdšgs
)

344 
v®
 
fuÎName
 = 
dev
.
·»Á
 
m©ch
 {

345 
NÚe
 => 
Çme


346 
Some
(
·»Á
è=> 
g‘Desc
Õ¬’t).
Çme
 + "/" +‚ame

348 
v®
 
	gdesc
 = 
DesütiÚ
(
fuÎName
, 
m­pšg
)

349 
	gdescs
 +ğ((
dev
, 
	gdesc
))

350 
	gdesc


353 
	gm­
.
	gkeys
.
fÜ—ch
(
g‘Desc
)

354 
v®
 
	gŒ“
 = 
makeT»e
(
descs
.
toLi¡
.
æ©M­
 { (
d
, 
DesütiÚ
(
Çme
, 
m­pšg
)) =>

355 
v®
 
tok’s
 = 
Çme
.
¥l™
("/").
toLi¡


356 
ex·nd
(
tok’s
, 
Seq
(
ResourûM­
(
m­pšg
, Seq(
d
.
Ïb–
)))) })

357 
ResourûM­
(
SÜ‹dM­
("/" -> 
Œ“
))

361 
def
 
	gcŞËùResourûAdd»s£s
 = 
cŞËù
(2, 
N
, 0, 
bšdšgT»e
)

364 
objeù
 
	gBšdšgScİe


366 
	g´Ùeùed
[
dlomacy
] 
v¬
 
	gaùive
: 
O±iÚ
[
BšdšgScİe
] = 
NÚe


367 
´Ùeùed
[
dlomacy
] 
def
 
fšd
(
m
: 
O±iÚ
[
LazyModuË
] = LazyModuË.
scİe
): O±iÚ[
BšdšgScİe
] = m.
æ©M­
 {

368 
x
: 
BšdšgScİe
 => 
fšd
(x.
·»Á
).
ÜEl£
(
Some
(x))

369 
x
 => 
fšd
(x.
·»Á
)

373 
objeù
 
ResourûBšdšg


378 
def
 
­¶y
(
block
: => 
Un™
) {

379 
v®
 
scİe
 = 
BšdšgScİe
.
fšd
()

380 
»quœe
 (
scİe
.
isDefšed
, "ResourceBinding must be called from within‡ BindingScope")

381 
	gscİe
.
	gg‘
.
	g»sourûBšdšgFns
 = { (è=> 
block
 } +: 
scİe
.
g‘
.
»sourûBšdšgFns


385 
objeù
 
ResourûAnchÜs


387 
v®
 
roÙ
 = 
Ãw
 
Deviû
 {

388 
def
 
desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

389 
v®
 
width
 = 
»sourûs
("width").
m­
(
_
.
v®ue
)

390 
v®
 
mod–
 = 
»sourûs
("mod–").
m­
(
_
.
v®ue
)

391 
v®
 
com·t
 = 
»sourûs
("com·t").
m­
(
_
.
v®ue
)

392 
DesütiÚ
("/", 
M­
(

393 "#add»ss-ûÎs" -> 
width
,

394 "#size-ûÎs" -> 
width
,

395 "mod–" -> 
mod–
,

396 "com·tibË" -> 
com·t
))

400 
v®
 
	gsoc
 = 
Ãw
 
Deviû
 {

401 
def
 
desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

402 
v®
 
width
 = 
»sourûs
("width").
m­
(
_
.
v®ue
)

403 
v®
 
com·t
 = 
»sourûs
("com·t").
m­
(
_
.
v®ue
è:+ 
ResourûSŒšg
("simple-bus")

404 
DesütiÚ
("soc", 
M­
(

405 "#add»ss-ûÎs" -> 
width
,

406 "#size-ûÎs" -> 
width
,

407 "com·tibË" -> 
com·t
,

408 "¿nges" -> 
N
))

412 
v®
 
	gıus
 = 
Ãw
 
Deviû
 {

413 
def
 
desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

414 
v®
 
width
 = 
»sourûs
("width").
m­
(
_
.
v®ue
)

415 
DesütiÚ
("ıus", 
M­
(

416 "#add»ss-ûÎs" -> 
width
,

417 "#size-ûÎs" -> 
Seq
(
ResourûIÁ
(0))))

421 
v®
 
	g®Ÿ£s
 = 
Ãw
 
Deviû
 {

422 
def
 
desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 =

423 
DesütiÚ
("®Ÿ£s", 
M­
() ++

424 
»sourûs
("u¬t").
zW™hIndex
.
m­
 { (
Bšdšg
(
_
, 
v®ue
), 
i
) =>

425 (
s
"£rŸl${i}" -> 
Seq
(
v®ue
))})

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/SRAM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
DesüibedSRAM


9 
ab¡¿ù
 
şass
 
	$Dlom©icSRAM
(

10 
add»ss
: 
Add»ssS‘
,

11 
b—tBy‹s
: 
IÁ
,

12 
devName
: 
O±iÚ
[
SŒšg
])(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
deviû
 = 
devName


15 .
	`m­
(
Ãw
 
	`Sim¶eDeviû
(
_
, 
	`Seq
("sifive,sram0")))

16 .
	`g‘OrEl£
(
Ãw
 
	`MemÜyDeviû
())

18 
v®
 
»sourûs
 = 
deviû
.
	`»g
("mem")

20 
def
 
	`bigB™s
(
x
: 
BigIÁ
, 

: 
Li¡
[
BoŞ—n
] = 
N
): List[Boolean] =

21 ià(
x
 =ğ0è

.
»v”£
 
	`bigB™s
(x >> 1, ((x & 1) == 1) ::ail)

23 
def
 
mask
: 
Li¡
[
BoŞ—n
] = 
	`bigB™s
(
add»ss
.mask >> 
	`log2Ce
(
b—tBy‹s
))

26 
def
 
	`makeSšgËPÜ‹dBy‹Wr™eSeqMem
(
size
: 
IÁ
, 
ÏÃs
: IÁ = 
b—tBy‹s
, 
b™s
: Int = 8) = {

28 
v®
 
mem
 = 
	`DesüibedSRAM
(

29 
Çme
 = 
devName
.
	`g‘OrEl£
("mem"),

30 
desc
 = 
devName
.
	`g‘OrEl£
("mem"),

31 
size
 = size,

32 
d©a
 = 
	`Vec
(
ÏÃs
, 
	`UIÁ
(
width
 = 
b™s
))

34 
devName
.
	`fÜ—ch
(
n
 => 
mem
.
	`sugge¡Name
Ò.
	`¥l™
("-").
Ï¡
))

35 
mem


37 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ValName.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
dlomacy


5 
impÜt
 
	gsÿÏ
.
	gÏnguage
.
	gex³rim’l
.
maüos


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gmaüos
.
V®NameIm¶


8 şas 
	cV®Name
(
Çme
: 
SŒšg
)

10 
objeù
 
V®Name


12 
im¶ic™
 
def
 
	$m©”Ÿlize
(
im¶ic™
 
x
: 
V®NameIm¶
): 
V®Name
 = 
	`V®Name
(x.
Çme
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.{
	gSourûInfo
, 
	gSourûLše
, 
	gUÆoÿbËSourûInfo
}

6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gsÿÏ
.
	gÏnguage
.
im¶ic™CÚv”siÚs


9 
·ckage
 
objeù
 
	gdlomacy


11 
ty³
 
	gSim¶eNodeHªdË
[
D
, 
U
, 
E
, 
B
 <: 
Chi£l
.
D©a
] = 
NodeHªdË
[D, U, E, B, D, U, E, B]

13 
def
 
sourûLše
(
sourûInfo
: 
SourûInfo
, 
´efix
: 
SŒšg
 = " (", 
suffix
: SŒšg = ")"èğsourûInfØ
m©ch
 {

14 
SourûLše
(
f’ame
, 
lše
, 
cŞ
è=> 
s
"$prefix$filename:$line:$col$suffix"

15 
_
 => ""

18 
def
 
b™Indexes
(
x
: 
BigIÁ
, 

: 
Seq
[
IÁ
] = 
N
): Seq[Int] = {

19 
»quœe
 (
x
 >= 0)

20 ià(
x
 == 0) {

21 

.
»v”£


23 
v®
 
lowe¡
 = 
x
.
lowe¡S‘B™


24 
b™Indexes
(
x
.
ş—rB™
(
lowe¡
),†owe¡ +: 

)

28 
im¶ic™
 cÏs 
	cBigIÁHexCÚ‹xt
(
v®
 
sc
: 
SŒšgCÚ‹xt
è
ex‹nds
 
AnyV®
 {

29 
def
 
	`x
(
¬gs
: 
Any
*): 
BigIÁ
 = {

30 
v®
 
Üig
 = 
sc
.
	`s
(
¬gs
: 
_
*)

31 
	`BigIÁ
(
Üig
.
	`»¶aû
("_", ""), 16)

33 
	}
}

35 
ty³
 
	gPrİ”tyO±iÚ
 = 
O±iÚ
[(
SŒšg
, 
Seq
[
ResourûV®ue
])]

36 
ty³
 
	gPrİ”tyM­
 = 
I‹¿bË
[(
SŒšg
, 
Seq
[
ResourûV®ue
])]

38 
im¶ic™
 cÏs 
	cIÁToPrİ”ty
(
x
: 
IÁ
) {

39 
def
 
asPrİ”ty
: 
Seq
[
ResourûV®ue
] = 
	`Seq
(
	`ResourûIÁ
(
	`BigIÁ
(
x
)))

40 
	}
}

42 
im¶ic™
 cÏs 
	cBigIÁToPrİ”ty
(
x
: 
BigIÁ
) {

43 
def
 
asPrİ”ty
: 
Seq
[
ResourûV®ue
] = 
	`Seq
(
	`ResourûIÁ
(
x
))

44 
	}
}

46 
im¶ic™
 cÏs 
	cSŒšgToPrİ”ty
(
x
: 
SŒšg
) {

47 
def
 
asPrİ”ty
: 
Seq
[
ResourûV®ue
] = 
	`Seq
(
	`ResourûSŒšg
(
x
))

48 
	}
}

50 
im¶ic™
 cÏs 
	cDeviûToPrİ”ty
(
x
: 
Deviû
) {

51 
def
 
asPrİ”ty
: 
Seq
[
ResourûV®ue
] = 
	`Seq
(
	`ResourûReã»nû
(
x
.
Ïb–
))

52 
	}
}

54 
def
 
EÇbËMÚ™Üs
[
T
](
body
: 
P¬am‘”s
 => T)(
im¶ic™
 
p
: P¬am‘”sèğbodyÕ.
®‹rP¬tŸl
 {

55 
MÚ™ÜsEÇbËd
 => 
Œue


57 
def
 
Di§bËMÚ™Üs
[
T
](
body
: 
P¬am‘”s
 => T)(
im¶ic™
 
p
: P¬am‘”sèğbodyÕ.
®‹rP¬tŸl
 {

58 
MÚ™ÜsEÇbËd
 => 
çl£


60 
def
 
FlR’d”šg
[
T
](
body
: 
P¬am‘”s
 => T)(
im¶ic™
 
p
: P¬am‘”sèğbodyÕ.
®‹rP¬tŸl
 {

61 
R’d”Fl³d
 => !
p
(RenderFlipped)

64 
im¶ic™
 
def
 
moduËV®ue
[
T
](
v®ue
: 
ModuËV®ue
[T]): T = v®ue.
g‘W¿µedV®ue


66 
im¶ic™
 
def
 
	$noCrossšg
(
v®ue
: 
NoCrossšg
.
ty³
): 
ClockCrossšgTy³
 = 
	`SynchrÚousCrossšg
(
BufãrP¬ams
.
nÚe
)

67 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Configs.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
CÚfig


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.{
	gDCacheP¬ams
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.{
	gMaxH¬tIdB™s
, 
	gXL’
}

14 
şass
 
T¿ûG’CÚfig
 
ex‹nds
 
CÚfig
(
Ãw
 
W™hT¿ûG’
(
Li¡
.
	$fl
(2){ 
	`DCacheP¬ams
(
nS‘s
 = 16, 
nWays
 = 1è
	}
}è++ 
Ãw
 
Ba£Subsy¡emCÚfig
)

16 
şass
 
T¿ûG’Bufã¾essCÚfig
 
ex‹nds
 
CÚfig
(
Ãw
 
W™hBufã¾essBrßdÿ¡Hub
 ++‚ew 
T¿ûG’CÚfig
)

20 
şass
 
	$W™hT¿ûG’
(
·¿ms
: 
Seq
[
DCacheP¬ams
], 
nReqs
: 
IÁ
 = 8192è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

21 
GroundTe¡TesKey
 => 
·¿ms
.
m­
 { 
dı
 => 
	`T¿ûG’P¬ams
(

22 
dÿche
 = 
	`Some
(
dı
),

23 
wÜdB™s
 = 
	`s™e
(
XL’
),

24 
addrB™s
 = 32,

25 
addrBag
 = {

26 
v®
 
nS‘s
 = 2

27 
v®
 
nWays
 = 1

28 
v®
 
blockOff£t
 = 
	`s™e
(
Sy¡emBusKey
).blockOffset

29 
v®
 
nB—ts
 = 
	`s™e
(
Sy¡emBusKey
).
blockB—ts


30 
Li¡
.
	`buÏ‹
(4 * 
nWays
è{ 
i
 =>

31 
Seq
.
	`buÏ‹
(
nB—ts
è{ 
j
 => 
	`BigIÁ
((j * 8è+ ((
i
 * 
nS‘s
è<< 
blockOff£t
)) }

32 }.
æ©‹n


34 
maxReque¡s
 = 
nReqs
,

35 
memS¹
 = 
	`s™e
(
ExtMem
).
g‘
.
ma¡”
.
ba£
,

36 
numG’s
 = 
·¿ms
.
size
)

38 
MaxH¬tIdB™s
 => 
	`log2Up
(
·¿ms
.
size
)

39 
	}
})

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/DummyPTW.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


6 
impÜt
 
	gChi£l
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
CÜeModuË


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
P¬am‘”izedBundË


13 şas 
	cDummyPTW
(
n
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
) {

14 
v®
 
io
 = 
Ãw
 
BundË
 {

15 
v®
 
»que¡Üs
 = 
	`Vec
(
n
, 
Ãw
 
TLBPTWIO
).
æ


18 
v®
 
»q_¬b
 = 
	`ModuË
(
Ãw
 
	`RRArb™”
(
	`V®id
Òew 
PTWReq
), 
n
))

19 
»q_¬b
.
io
.
š
 <> io.
»que¡Üs
.
	$m­
(
_
.
»q
)

20 
»q_¬b
.
io
.
out
.
»ady
 :ğ
	$BoŞ
(
Œue
)

22 
def
 
	$v²_to_µn
(
v²
: 
UIÁ
): UIÁ = 
	`v²
(
µnB™s
 - 1, 0)

24 şas 
	cQueueChªÃl
 
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
) {

25 
v®
 
µn
 = 
	`UIÁ
(
width
 = 
µnB™s
)

26 
v®
 
cho£n
 = 
	`UIÁ
(
width
 = 
	`log2Up
(
n
))

27 
	}
}

29 
v®
 
	gs1_µn
 = 
	$v²_to_µn
(
»q_¬b
.
io
.
out
.
b™s
.b™s.
addr
)

30 
v®
 
s2_µn
 = 
	$RegEÇbË
(
s1_µn
, 
»q_¬b
.
io
.
out
.
v®id
)

31 
v®
 
s2_cho£n
 = 
	$RegEÇbË
(
»q_¬b
.
io
.
cho£n
,„eq_¬b.io.
out
.
v®id
)

32 
v®
 
s2_v®id
 = 
	$Reg
(
Ãxt
 = 
»q_¬b
.
io
.
out
.
v®id
 &&„eq_¬b.io.out.
b™s
.valid)

34 
v®
 
s2_»¥
 = 
	`Wœe
(
š™
 = 0.U.a
	$sTy³Of
(
Ãw
 
PTWRe¥
))

35 
s2_»¥
.
±e
.
µn
 :ğ
s2_µn


36 
s2_»¥
.
±e
.
»£rved_fÜ_soáw¬e
 :ğ
	$UIÁ
(0)

37 
s2_»¥
.
Ëv–
 :ğ
	`UIÁ
(
pgLev–s
-1)

38 
s2_»¥
.
±e
.
d
 :ğ
	$BoŞ
(
Œue
)

39 
s2_»¥
.
±e
.
a
 :ğ
	$BoŞ
(
Œue
)

40 
s2_»¥
.
±e
.
g
 :ğ
	$BoŞ
(
çl£
)

41 
s2_»¥
.
±e
.
u
 :ğ
	$BoŞ
(
Œue
)

42 
s2_»¥
.
±e
.
r
 :ğ
	$BoŞ
(
Œue
)

43 
s2_»¥
.
±e
.
w
 :ğ
	$BoŞ
(
Œue
)

44 
s2_»¥
.
±e
.
x
 :ğ
	$BoŞ
(
çl£
)

45 
s2_»¥
.
±e
.
v
 :ğ
	$BoŞ
(
Œue
)

47 
io
.
»que¡Üs
.
zW™hIndex
.
fÜ—ch
 { (
»que¡Ü
, 
i
) =>

48 
»que¡Ü
.
»¥
.
v®id
 :ğ
s2_v®id
 && 
s2_cho£n
 ==ğ
	`UIÁ
(
i
)

49 
»que¡Ü
.
»¥
.
b™s
 :ğ
s2_»¥


50 
»que¡Ü
.
¡©us
 :ğ0.U.a
	`sTy³Of
(requestor.status)

51 
»que¡Ü
.
±br
.
mode
 :ğ»que¡Ü.±br.
	`pgLev–sToMode
(
pgLev–s
).
U


52 
»que¡Ü
.
±br
.
asid
 :ğ
	`UIÁ
(0)

53 
»que¡Ü
.
±br
.
µn
 :ğ
	`UIÁ
(0)

54 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Generator.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
G’”©ÜAµ


7 
objeù
 
G’”©Ü
 
ex‹nds
 
	gG’”©ÜAµ
 {

8 
v®
 
	glÚgName
 = 
Çmes
.
tİModuËProjeù
 + "." +‚ames.
cÚfigs


9 
g’”©eFœ¹l


10 
g’”©eAÂo


11 
g’”©eTe¡Su™eMakeäags


12 
g’”©eA¹eçùs


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/GroundTestSubsystem.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


14 
impÜt
 
	gsÿÏ
.
	gm©h
.
max


16 
objeù
 
TeId
 
ex‹nds
 
	gF›ld
[
IÁ
]

18 şas 
	cGroundTe¡Subsy¡em
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
Ba£Subsy¡em


19 
w™h
 
CªHaveMa¡”AXI4MemPÜt


20 
w™h
 
HasP”h”yTe¡RAMSÏve
 {

21 
v®
 
teP¬ams
 = 
	$p
(
GroundTe¡TesKey
)

22 
v®
 
tes
 = 
teP¬ams
.
zW™hIndex
.
m­
 { (
c
, 
i
è=> 
	`LazyModuË
(

23 
c
.
	`bud
(
i
, 
p
.
®‹rP¬tŸl
 {

24 
TeKey
 => 
c


25 
Sh¬edMemÜyTLEdge
 => 
sbus
.
busV›w


29 
tes
.
	`æ©M­
(
_
.
dÿcheO±
).
fÜ—ch
 { 
dc
 =>

30 
sbus
.
	`äomTe
(
NÚe
, 
bufãr
 = 
BufãrP¬ams
.){ 
dc
.
node
 }

31 
	}
}

34 
IÁSškNode
(
	$IÁSškPÜtSim¶e
()è:ğ
ibus
.
toPLIC


36 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`GroundTe¡Subsy¡emModuËImp
(
this
)

37 
	}
}

39 
şass
 
GroundTe¡Subsy¡emModuËImp
[+
L
 <: 
GroundTe¡Subsy¡em
](
_ou‹r
: Lè
ex‹nds
 
	$Ba£Subsy¡emModuËImp
(
_ou‹r
)

40 
w™h
 
CªHaveMa¡”AXI4MemPÜtModuËImp
 {

41 
v®
 
sucûss
 = 
	`IO
(
	`BoŞ
(
OUTPUT
))

43 
ou‹r
.
tes
.
zW™hIndex
.
m­
 { (
t
, 
i
è=>.
moduË
.
cÚ¡ªts
.
h¬tid
 :ğ
	`UIÁ
(i) }

45 
v®
 
¡©us
 = 
	`DebugCombš”
(
ou‹r
.
tes
.
	`m­
(
_
.
moduË
.status))

46 
sucûss
 :ğ
¡©us
.
fšished


47 
	}
}

50 
Œa™
 
HasP”h”yTe¡RAMSÏve
 { 
this
: 
Ba£Subsy¡em
 =>

51 
v®
 
‹¡¿m
 = 
LazyModuË
(
Ãw
 
TLRAM
(
Add»ssS‘
(0x52000000, 0xfff), 
Œue
,rue, 
pbus
.
b—tBy‹s
))

52 
	gpbus
.
toV¬ŸbËWidthSÏve
(
Some
("Te¡RAM")è{ 
	g‹¡¿m
.
	gnode
 }

56 
Œa™
 
	gHasP”h”yTe¡FuzzMa¡”
 { 
	gthis
: 
Ba£Subsy¡em
 =>

57 
v®
 
fuzz”
 = 
LazyModuË
(
Ãw
 
TLFuzz”
(5000))

58 
pbus
.
äomOth”Ma¡”
(
Some
("Fuzz”")è{ 
fuzz”
.
node
 }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
·ckage
 
objeù
 
	gground‹¡
 {

6 
v®
 
	g‹¡RamAddr
 = 0x10000

7 
v®
 
timeoutCodeB™s
 = 4

8 
v®
 
”rÜCodeB™s
 = 4

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Status.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
V®idMux


8 şas 
	cGroundTe¡Stus
 
ex‹nds
 
	mBundË
 {

9 
v®
 
	mfšished
 = 
	$BoŞ
(
OUTPUT
)

10 
v®
 
timeout
 = 
	`V®id
(
	$UIÁ
(
width
 = 4))

11 
v®
 
”rÜ
 = 
	`V®id
(
	`UIÁ
(
width
 = 4))

14 
objeù
 
DebugCombš”
 {

15 
def
 
	`­¶y
(
debugs
: 
Seq
[
GroundTe¡Stus
]): GroundTestStatus = {

16 
v®
 
out
 = 
	`Wœe
(
Ãw
 
GroundTe¡Stus
)

17 
out
.
fšished
 :ğ
debugs
.
	`m­
(
_
.fšished).
	`»duû
(_ && _)

18 
out
.
timeout
 :ğ
	`V®idMux
(
debugs
.
	`m­
(
_
.timeout))

19 
out
.
”rÜ
 :ğ
	`V®idMux
(
debugs
.
	`m­
(
_
.error))

20 
out


22 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TestHarness.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
LazyModuË


10 şas 
	cTe¡H¬Ãss
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

11 
v®
 
io
 = 
Ãw
 
BundË
 { v® 
sucûss
 = 
	`BoŞ
(
OUTPUT
) }

12 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
GroundTe¡Subsy¡em
).
moduË
)

13 
io
.
sucûss
 :ğ
dut
.success

14 
dut
.
	`cÚÃùSimAXIMem
()

15 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Tile.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.{
	gDCache
, 
	gRock‘CÜeP¬ams
}

12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


14 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
Li¡Bufãr


16 
Œa™
 
GroundTe¡TeP¬ams
 
ex‹nds
 
	gTeP¬ams
 {

17 
v®
 
	gmemS¹
: 
BigIÁ


18 
v®
 
maxReque¡s
: 
IÁ


19 
v®
 
numG’s
: 
IÁ


21 
def
 
bud
(
i
: 
IÁ
, 
p
: 
P¬am‘”s
): 
GroundTe¡Te


23 
v®
 
iÿche
 = 
NÚe


24 
v®
 
btb
 = 
NÚe


25 
v®
 
rocc
 = 
N


26 
v®
 
cÜe
 = 
Rock‘CÜeP¬ams
(
nPMPs
 = 0)

27 
v®
 
ÿched
 = if(
dÿche
.
isDefšed
) 1 0

28 
v®
 
d©aSü©ch·dBy‹s
 = 0

31 
objeù
 
GroundTe¡TesKey
 
ex‹nds
 
F›ld
[
Seq
[
GroundTe¡TeP¬ams
]]

33 
ab¡¿ù
 
şass
 
	$GroundTe¡Te
(
·¿ms
: 
GroundTe¡TeP¬ams
)

34 (
im¶ic™
 
p
: 
P¬am‘”s
)

35 
ex‹nds
 
	`Ba£Te
(
·¿ms
, 
üossšg
 = 
	$SynchrÚousCrossšg
())(
p
) {

36 
v®
 
štInw¬dNode
: 
IÁInw¬dNode
 = 
	`IÁId’t™yNode
()

37 
v®
 
štOutw¬dNode
: 
IÁOutw¬dNode
 = 
	`IÁId’t™yNode
()

38 
v®
 
¦aveNode
: 
TLInw¬dNode
 = 
	`TLId’t™yNode
()

40 
v®
 
dÿcheO±
 = 
·¿ms
.
dÿche
.
m­
 { 
dc
 => 
	`LazyModuË
(
Ãw
 
	`DCache
(0)) }

42 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`GroundTe¡TeModuËImp
(
this
)

43 
	}
}

45 şas 
	cGroundTe¡TeModuËImp
(
ou‹r
: 
GroundTe¡Te
è
ex‹nds
 
	$Ba£TeModuËImp
(
ou‹r
) {

46 
v®
 
¡©us
 = 
	$IO
(
Ãw
 
GroundTe¡Stus
)

47 
v®
 
h®t_ªd_ÿtch_fœe
 = 
NÚe


49 
ou‹r
.
dÿcheO±
 
fÜ—ch
 { 
dÿche
 =>

50 
v®
 
±w
 = 
	`ModuË
(
Ãw
 
	`DummyPTW
(1))

51 
±w
.
io
.
»que¡Üs
.
h—d
 <> 
dÿche
.
moduË
.io.ptw

53 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TraceGen.scala

20 
·ckage
 
	gä“chs
.
	grock‘ch
.
ground‹¡


22 
impÜt
 
	gChi£l
.
_


23 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

24 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


25 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


26 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


27 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


59 
şass
 
T¿ûG’P¬ams
(

60 
dÿche
: 
O±iÚ
[
DCacheP¬ams
] = 
Some
(DCacheParams()),

61 
wÜdB™s
: 
IÁ
,

62 
addrB™s
: 
IÁ
,

63 
addrBag
: 
Li¡
[
BigIÁ
],

64 
maxReque¡s
: 
IÁ
,

65 
memS¹
: 
BigIÁ
,

66 
numG’s
: 
IÁ
è
ex‹nds
 
GroundTe¡TeP¬ams
 {

67 
def
 
bud
(
i
: 
IÁ
, 
p
: 
P¬am‘”s
): 
GroundTe¡Te
 = 
Ãw
 
T¿ûG’Te
(i, 
this
)(
	gp
)

68 
v®
 
	gh¬tId
 = 0

69 
v®
 
Œaû
 = 
çl£


70 
v®
 
block”CŒlAddr
 = 
NÚe


71 
v®
 
Çme
 = 
NÚe


74 
Œa™
 
	gHasT¿ûG’P¬ams
 {

75 
im¶ic™
 
v®
 
	gp
: 
P¬am‘”s


76 
v®
 
·¿ms
: 
T¿ûG’P¬ams


77 
v®
 
pAddrB™s
 = 
·¿ms
.
addrB™s


78 
v®
 
numG’s
 = 
·¿ms
.numGens

79 
v®
 
numReqsP”G’
 = 
·¿ms
.
maxReque¡s


80 
v®
 
memS¹
 = 
·¿ms
.memStart

81 
v®
 
memRe¥Timeout
 = 8192

82 
v®
 
numB™sInWÜd
 = 
·¿ms
.
wÜdB™s


83 
v®
 
numBy‹sInWÜd
 = 
numB™sInWÜd
 / 8

84 
v®
 
numB™sInWÜdOff£t
 = 
log2Up
(
numBy‹sInWÜd
)

85 
v®
 
add»ssBag
 = 
·¿ms
.
addrBag


86 
v®
 
add»ssBagL’
 = 
add»ssBag
.
Ëngth


87 
v®
 
logAdd»ssBagL’
 = 
log2Up
(
add»ssBagL’
)

88 
v®
 
g’ExŒaAddrs
 = 
çl£


89 
v®
 
logNumExŒaAddrs
 = 1

90 
v®
 
numExŒaAddrs
 = 1 << 
logNumExŒaAddrs


91 
v®
 
maxTags
 = 8

93 
»quœe
(
numBy‹sInWÜd
 * 8 =ğ
numB™sInWÜd
)

94 
»quœe
((1 << 
logAdd»ssBagL’
è=ğ
add»ssBagL’
)

143 şas 
	cTagMª
(
v®
 
logNumTags
 : 
IÁ
è
ex‹nds
 
ModuË
 {

144 
v®
 
io
 = 
Ãw
 
BundË
 {

146 
v®
 
avaabË
 = 
	`BoŞ
(
OUTPUT
)

148 
v®
 
gOut
 = 
	`UIÁ
(
OUTPUT
, 
logNumTags
)

150 
v®
 
ke
 = 
	`BoŞ
(
INPUT
)

152 
v®
 
put
 = 
	`BoŞ
(
INPUT
)

154 
v®
 
gIn
 = 
	`UIÁ
(
INPUT
, 
logNumTags
)

158 
v®
 
numTags
 = 1 << 
logNumTags


161 
v®
 
šU£
 = 
Li¡
.
	$fl
(
numTags
)(
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
)))

164 
v®
 
šU£M­
 = (0 
to
 
numTags
-1).
	`m­
(
i
 => 
	`UIÁ
(i)).
	$z
(
šU£
)

167 
v®
 
ÃxtTag
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 
logNumTags
))

168 
io
.
gOut
 :ğ
ÃxtTag


171 
io
.
avaabË
 :ğ~
	`MuxLookup
(
ÃxtTag
, 
	`BoŞ
(
Œue
), 
šU£M­
)

174 
	$wh’
 (
io
.
ke
) {

175 (
i
, 
b
è<- 
šU£M­
) {

176 
	`wh’
 (
i
 ==ğ
ÃxtTag
è{ 
b
 :ğ
	`BoŞ
(
Œue
) }

178 
ÃxtTag
 :ğÃxtTag + 
	`UIÁ
(1)

179 
	}
}

182 
	$wh’
 (
io
.
put
) {

183 (
i
, 
b
è<- 
šU£M­
) {

184 
	`wh’
 (
i
 ==ğ
io
.
gIn
è{ 
b
 :ğ
	`BoŞ
(
çl£
) }

186 
	}
}

193 şas 
	cT¿ûG’”©Ü
(
v®
 
·¿ms
: 
T¿ûG’P¬ams
)(
im¶ic™
 v® 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË


194 
w™h
 
HasT¿ûG’P¬ams
 {

195 
v®
 
io
 = 
Ãw
 
BundË
 {

196 
v®
 
fšished
 = 
	`BoŞ
(
OUTPUT
)

197 
v®
 
timeout
 = 
	`BoŞ
(
OUTPUT
)

198 
v®
 
mem
 = 
Ãw
 
H–ÏCacheIO


199 
v®
 
h¬tid
 = 
	`UIÁ
(
INPUT
, 
	`log2Up
(
numG’s
))

202 
v®
 
tÙ®NumAddrs
 = 
add»ssBag
.
size
 + 
numExŒaAddrs


203 
v®
 
š™CouÁ
 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
	$log2Up
(
tÙ®NumAddrs
)))

204 
v®
 
š™DÚe
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

206 
v®
 
»qTim”
 = 
	`ModuË
(
Ãw
 
	$Tim”
(8192, 
maxTags
))

207 
»qTim”
.
io
.
¡¬t
.
v®id
 :ğio.
mem
.
»q
.
	$fœe
()

208 
»qTim”
.
io
.
¡¬t
.
b™s
 :ğio.
mem
.
»q
.b™s.
g


209 
»qTim”
.
io
.
¡İ
.
v®id
 :ğio.
mem
.
»¥
.valid

210 
»qTim”
.
io
.
¡İ
.
b™s
 :ğio.
mem
.
»¥
.b™s.
g


218 
v®
 
bagOfAddrs
 = 
add»ssBag
.
	`m­
(
x
 => 
	`UIÁ
(
memS¹
 + x, 
pAddrB™s
))

220 
v®
 
exŒaAddrs
 = 
Seq
.
	$fl
(
numExŒaAddrs
) {

221 
	`UIÁ
(
memS¹
 + 
S“dedRªdom
.
äomS“d
.
	`ÃxtIÁ
(1 << 16è* 
numBy‹sInWÜd
, 
pAddrB™s
)

222 
	}
}

226 
v®
 
¿ndAddrBagIndex
 = 
	$LCG
(
logAdd»ssBagL’
)

230 
v®
 
addrBagIndiûs
 = (0 
to
 
add»ssBagL’
-1).

231 
	`m­
(
i
 => 
	$UIÁ
(
i
, 
logAdd»ssBagL’
))

233 
v®
 
¿ndAddrFromBag
 = 
	`MuxLookup
(
¿ndAddrBagIndex
, 
	`UIÁ
(0),

234 
addrBagIndiûs
.
	$z
(
bagOfAddrs
))

238 
v®
 
exŒaAddrIndiûs
 = (0 
to
 
numExŒaAddrs
-1)

239 .
	`m­
(
i
 => 
	$UIÁ
(
i
, 
logNumExŒaAddrs
))

241 
v®
 
¿ndAddr
 =

242 ià(! 
g’ExŒaAddrs
) {

243 
¿ndAddrFromBag


244 
	}
}

248 
v®
 
¿ndExŒaAddrIndex
 = 
LCG
(
logNumExŒaAddrs
)

251 
v®
 
¿ndAddrFromExŒa
 = 
C©
(
UIÁ
(0),

252 
MuxLookup
(
¿ndExŒaAddrIndex
, 
UIÁ
(0),

253 
exŒaAddrIndiûs
.
z
(
exŒaAddrs
)), 
UIÁ
(0, 3))

255 
F»qu’cy
(
Li¡
(

256 (1, 
¿ndAddrFromBag
),

257 (1, 
¿ndAddrFromExŒa
)))

260 
v®
 
	g®lAddrs
 = 
exŒaAddrs
 ++ 
bagOfAddrs


261 
v®
 
®lAddrIndiûs
 = (0 
uÁ
 
tÙ®NumAddrs
)

262 .
m­
(
i
 => 
UIÁ
(i, 
	$log2Ce
(
tÙ®NumAddrs
)))

263 
v®
 
š™Addr
 = 
	`MuxLookup
(
š™CouÁ
, 
	`UIÁ
(0),

264 
®lAddrIndiûs
.
	$z
(
®lAddrs
))

273 
	`v®
 (
İNİ
 :: 
İLßd
 :: 
İStÜe
 ::

274 
İF’û
 :: 
İLRSC
 :: 
İSw­
 ::

275 
İD–ay
 :: 
N
èğ
	`Enum
(
	`B™s
(), 7)

280 
v®
 
¿ndOp
 = 
	`F»qu’cy
(
	`Li¡
(

281 (10, 
İLßd
),

282 (10, 
İStÜe
),

283 (4, 
İF’û
),

284 (3, 
İLRSC
),

285 (3, 
İSw­
),

286 (2, 
İD–ay
)))

296 
v®
 
gMª
 = 
	`ModuË
(
Ãw
 
	`TagMª
(
	$log2Ce
(
maxTags
)))

299 
gMª
.
io
.
ke
 :ğ
	`BoŞ
(
çl£
);

300 
gMª
.
io
.
put
 :ğ
	`BoŞ
(
çl£
);

301 
gMª
.
io
.
gIn
 :ğ
	`UIÁ
(0);

309 
v®
 
cyşeCouÁ
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 32))

310 
cyşeCouÁ
 :ğcyşeCouÁ + 
	`UIÁ
(1);

319 
v®
 
d–ayTim”
 = 
	`ModuË
(
Ãw
 
	$DyÇmicTim”
(16))

322 
v®
 
¿ndD–ayBa£
 = 
	$LCG16
()

325 
v®
 
¿ndD–ay
 = 
	`F»qu’cy
(
	`Li¡
(

326 (14, 
	$UIÁ
(0, 13è## 
	`¿ndD–ayBa£
(2, 0)),

327 (2, 
	$UIÁ
(0, 11è## 
	$¿ndD–ayBa£
(5, 0))))

330 
d–ayTim”
.
io
.
¡¬t
 :ğ
	$BoŞ
(
çl£
)

331 
d–ayTim”
.
io
.
³riod
 :ğ
¿ndD–ay


332 
d–ayTim”
.
io
.
¡İ
 :ğ
	$BoŞ
(
çl£
)

338 
v®
 
tid
 = 
io
.
h¬tid


341 
v®
 
»qCouÁ
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 32))

342 
v®
 
»¥CouÁ
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 32))

345 
v®
 
cu¼’tOp
 = 
	$Reg
(
š™
 = 
İNİ
)

349 
v®
 
İInProg»ss
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 2))

352 
v®
 
£ndF»shReq
 = 
	`Wœe
(
	$BoŞ
())

353 
£ndF»shReq
 :ğ
	$BoŞ
(
çl£
)

356 
v®
 
ÃxtD©a
 = 
	`Reg
(
š™
 = 
	`UIÁ
(1, 
numB™sInWÜd
-
tid
.
g‘Width
))

359 
v®
 
»qV®id
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

360 
v®
 
»qAddr
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 
numB™sInWÜd
))

361 
v®
 
»qD©a
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 
numB™sInWÜd
))

362 
v®
 
»qCmd
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 5))

363 
v®
 
»qTag
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 7))

366 
v®
 
ÿnS’dF»shReq
 = (!
»qV®id
 || 
io
.
mem
.
»q
.
	`fœe
()) &&

367 
gMª
.
io
.
avaabË


370 
	`wh’
 (
»qCouÁ
 < 
	$UIÁ
(
numReqsP”G’
)) {

373 
	`wh’
 (
cu¼’tOp
 ==ğ
İNİ
) {

375 
cu¼’tOp
 :ğ
	`Mux
(
š™DÚe
, 
¿ndOp
, 
İStÜe
)

379 
	`wh’
 (
cu¼’tOp
 ==ğ
İF’û
) {

380 
	`wh’
 (
İInProg»ss
 ==ğ
	`UIÁ
(0è&& !
»qV®id
) {

382 
	`´štf
("%d: f’û-»q @%d\n", 
tid
, 
cyşeCouÁ
)

384 
İInProg»ss
 :ğ
	`UIÁ
(1)

387 .
	`–£wh’
 (
»qCouÁ
 ==ğ
»¥CouÁ
) {

389 
	`´štf
("%d: f’û-»¥ @%d\n", 
tid
, 
cyşeCouÁ
)

391 
cu¼’tOp
 :ğ
¿ndOp


393 
İInProg»ss
 :ğ
	`UIÁ
(0)

398 
	`wh’
 (
cu¼’tOp
 ==ğ
İD–ay
) {

399 
	`wh’
 (
İInProg»ss
 ==ğ
	`UIÁ
(0)) {

401 
d–ayTim”
.
io
.
¡¬t
 :ğ
	`BoŞ
(
Œue
)

403 
İInProg»ss
 :ğ
	`UIÁ
(1)

405 .
	`–£wh’
 (
d–ayTim”
.
io
.
timeout
) {

407 
cu¼’tOp
 :ğ
¿ndOp


409 
İInProg»ss
 :ğ
	`UIÁ
(0)

414 
	`wh’
 (
cu¼’tOp
 ==ğ
İLßd
 ||

415 
cu¼’tOp
 ==ğ
İStÜe
 ||

416 
cu¼’tOp
 ==ğ
İSw­
) {

417 
	`wh’
 (
ÿnS’dF»shReq
) {

419 
»qAddr
 :ğ
	`Mux
(
š™DÚe
, 
¿ndAddr
, 
š™Addr
)

421 
	`wh’
 (
cu¼’tOp
 ==ğ
İLßd
) {

422 
»qCmd
 :ğ
M_XRD


423 } .
	`–£wh’
 (
cu¼’tOp
 ==ğ
İStÜe
) {

424 
»qCmd
 :ğ
M_XWR


425 } .
	`–£wh’
 (
cu¼’tOp
 ==ğ
İSw­
) {

426 
»qCmd
 :ğ
M_XA_SWAP


429 
£ndF»shReq
 :ğ
	`BoŞ
(
Œue
)

431 
	`wh’
 (!
š™DÚe
 && 
š™CouÁ
 =/ğ
	`UIÁ
(
tÙ®NumAddrs
 - 1)) {

432 
š™CouÁ
 :ğš™CouÁ + 
	`UIÁ
(1)

433 
cu¼’tOp
 :ğ
İStÜe


434 } .
Ùh”wi£
 {

435 
cu¼’tOp
 :ğ
¿ndOp


436 
š™DÚe
 :ğ
	`BoŞ
(
Œue
)

443 
	`wh’
 (
cu¼’tOp
 ==ğ
İLRSC
) {

445 
	`wh’
 (
İInProg»ss
 ==ğ
	`UIÁ
(0)) {

446 
	`wh’
 (
ÿnS’dF»shReq
) {

448 
»qAddr
 :ğ
¿ndAddr


449 
»qCmd
 :ğ
M_XLR


451 
£ndF»shReq
 :ğ
	`BoŞ
(
Œue
)

453 
İInProg»ss
 :ğ
	`UIÁ
(1)

457 
	`wh’
 (
İInProg»ss
 ==ğ
	`UIÁ
(1)) {

459 
d–ayTim”
.
io
.
¡¬t
 :ğ
	`BoŞ
(
Œue
)

461 
İInProg»ss
 :ğ
	`UIÁ
(2)

464 
	`wh’
 (
İInProg»ss
 ==ğ
	`UIÁ
(2)) {

465 
	`wh’
 (
d–ayTim”
.
io
.
timeout
) {

467 
İInProg»ss
 :ğ
	`UIÁ
(3)

471 
	`wh’
 (
İInProg»ss
 ==ğ
	`UIÁ
(3)) {

472 
	`wh’
 (
ÿnS’dF»shReq
) {

475 
»qCmd
 :ğ
M_XSC


477 
£ndF»shReq
 :ğ
	`BoŞ
(
Œue
)

479 
İInProg»ss
 :ğ
	`UIÁ
(0)

481 
cu¼’tOp
 :ğ
¿ndOp


485 
	}
}

490 
	$wh’
 (
£ndF»shReq
) {

492 
»qTag
 :ğ
gMª
.
io
.
gOut


493 
gMª
.
io
.
ke
 :ğ
	`BoŞ
(
Œue
)

495 
»qD©a
 :ğ
	`C©
(
ÃxtD©a
, 
tid
)

496 
ÃxtD©a
 :ğÃxtD©¨+ 
	`UIÁ
(1)

498 
»qV®id
 :ğ
	`BoŞ
(
Œue
)

500 
»qCouÁ
 :ğ»qCouÁ + 
	`UIÁ
(1)

501 
	}
}

502 .
–£wh’
 (
io
.
mem
.
»q
.
	$fœe
()) {

504 
»qV®id
 :ğ
	`BoŞ
(
çl£
)

505 
	}
}

508 
io
.
mem
.
»q
.
v®id
 :ğ
»qV®id


509 
io
.
mem
.
»q
.
b™s
.
addr
 :ğ
»qAddr


510 
io
.
mem
.
»q
.
b™s
.
d©a
 :ğ
»qD©a


511 
io
.
mem
.
»q
.
b™s
.
typ
 :ğ
UIÁ
(
	$log2Ce
(
numBy‹sInWÜd
))

512 
io
.
mem
.
»q
.
b™s
.
cmd
 :ğ
»qCmd


513 
io
.
mem
.
»q
.
b™s
.
g
 :ğ
»qTag


516 
	`wh’
 (
io
.
mem
.
»q
.
	$fœe
()) {

518 
v®
 
addr
 = 
io
.
mem
.
»q
.
b™s
.addr

520 
	`´štf
("%d:", 
tid
)

522 
	`wh’
 (
»qCmd
 ==ğ
M_XRD
) {

523 
	`´štf
("†ßd-»q 0x%x", 
addr
)

525 
	`wh’
 (
»qCmd
 ==ğ
M_XLR
) {

526 
	`´štf
("†ßd-»£rve-»q 0x%x", 
addr
)

528 
	`wh’
 (
»qCmd
 ==ğ
M_XWR
) {

529 
	`´štf
(" stÜe-»q %d 0x%x", 
»qD©a
, 
addr
)

531 
	`wh’
 (
»qCmd
 ==ğ
M_XSC
) {

532 
	`´štf
(" stÜe-cÚd-»q %d 0x%x", 
»qD©a
, 
addr
)

534 
	`wh’
 (
»qCmd
 ==ğ
M_XA_SWAP
) {

535 
	`´štf
(" sw­-»q %d 0x%x", 
»qD©a
, 
addr
)

538 
	`´štf
(" #%d", 
»qTag
)

540 
	`´štf
(" @%d\n", 
cyşeCouÁ
)

541 
	}
}

547 
	$wh’
 (
io
.
mem
.
»¥
.
v®id
) {

549 
gMª
.
io
.
gIn
 :ğio.
mem
.
»¥
.
b™s
.
g


550 
gMª
.
io
.
put
 :ğ
	`BoŞ
(
Œue
)

552 
	`´štf
("%d:„e¥ %d #%d @%d\n", 
tid
,

553 
io
.
mem
.
»¥
.
b™s
.
d©a
, io.mem.»¥.b™s.
g
, 
cyşeCouÁ
)

555 
»¥CouÁ
 :ğ»¥CouÁ + 
	`UIÁ
(1)

556 
	}
}

561 
v®
 
dÚe
 = 
»qCouÁ
 ==ğ
UIÁ
(
numReqsP”G’
) &&

562 
»¥CouÁ
 ==ğ
	$UIÁ
(
numReqsP”G’
)

564 
v®
 
dÚePul£
 = 
dÚe
 && !
	`Reg
(
š™
 = 
	`BoŞ
(
çl£
), 
Ãxt
 = done)

567 
	$wh’
 (
dÚePul£
) {

568 
	`´štf
(
s
"FINISHED ${numGens}\n")

569 
	}
}

571 
io
.
fšished
 :ğ
dÚe


572 
io
.
timeout
 :ğ
»qTim”
.io.timeout.
v®id


580 
şass
 
	$T¿ûG’Te
(
v®
 
id
: 
IÁ
, v® 
·¿ms
: 
T¿ûG’P¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$GroundTe¡Te
(
·¿ms
) {

581 
v®
 
ma¡”Node
: 
TLOutw¬dNode
 = 
dÿcheO±
.
	`m­
(
_
.
node
).
	`g‘OrEl£
(
	`TLId’t™yNode
())

582 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`T¿ûG’TeModuËImp
(
this
)

583 
	}
}

585 şas 
	cT¿ûG’TeModuËImp
(
ou‹r
: 
T¿ûG’Te
è
ex‹nds
 
	$GroundTe¡TeModuËImp
(
ou‹r
) {

587 
v®
 
Œaûg’
 = 
	`ModuË
(
Ãw
 
	$T¿ûG’”©Ü
(
ou‹r
.
·¿ms
))

588 
Œaûg’
.
io
.
h¬tid
 :ğ
cÚ¡ªts
.hartid

590 
ou‹r
.
dÿcheO±
 
fÜ—ch
 { 
dÿche
 =>

591 
v®
 
dÿcheIF
 = 
	`ModuË
(
Ãw
 
	`Sim¶eH–ÏCacheIF
())

592 
dÿcheIF
.
io
.
»que¡Ü
 <> 
Œaûg’
.io.
mem


593 
dÿche
.
moduË
.
io
.
ıu
 <> 
dÿcheIF
.io.
ÿche


596 
¡©us
.
fšished
 :ğ
Œaûg’
.
io
.finished

597 
¡©us
.
timeout
.
v®id
 :ğ
Œaûg’
.
io
.timeout

598 
¡©us
.
timeout
.
b™s
 :ğ
	$UIÁ
(0)

599 
¡©us
.
”rÜ
.
v®id
 :ğ
	$BoŞ
(
çl£
)

601 
	`as£¹
(!
Œaûg’
.
io
.
timeout
, 
s
"TraceGenile ${outer.id}:„equestimed out")

602 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Bundles.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 şas 
	cSyncIÁ”ru±s
(
·¿ms
: 
IÁEdge
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

11 
v®
 
sync
 = 
	`Vec
(
·¿ms
.
sourû
.
num
, 
	`BoŞ
())

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Crossing.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gSynchrÚiz”ShiáReg
, 
	gAsyncRe£tReg
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
	g_


10 @
d•»ÿ‹d
("IntXing does‚otƒnsure interrupt source is glitch free. Use IntSyncSource‡nd IntSyncSink", "rocket-chip 1.2")

11 
şass
 
	$IÁXšg
(
sync
: 
IÁ
 = 3)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


13 
v®
 
šŠode
 = 
	`IÁAd­‹rNode
()

15 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

16 (
šŠode
.
š
 
z
 iÁnode.
out
è
fÜ—ch
 { ((š, 
_
), (out, _)) =>

17 
out
 :ğ
	`SynchrÚiz”ShiáReg
(
š
, 
sync
)

20 
	}
}

22 
objeù
 
	gIÁSyncCrossšgSourû


24 
def
 
­¶y
(
®»adyRegi¡”ed
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
) =

26 
v®
 
štsourû
 = 
LazyModuË
(
Ãw
 
IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
))

27 
štsourû
.
node


32 
şass
 
	$IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


34 
v®
 
node
 = 
	`IÁSyncSourûNode
(
®»adyRegi¡”ed
)

36 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

37 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

38 ià(
®»adyRegi¡”ed
) {

39 
out
.
sync
 :ğ
š


41 
out
.
sync
 :ğ
	`AsyncRe£tReg
(
	`C©
(
š
.
»v”£
)).
toBoŞs


45 
	}
}

48 
şass
 
	$IÁSyncCrossšgSšk
(
sync
: 
IÁ
 = 3)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


50 
v®
 
node
 = 
	`IÁSyncSškNode
(
sync
)

52 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

53 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

54 
out
 :ğ
	`SynchrÚiz”ShiáReg
(
š
.
sync
, sync)

57 
	}
}

59 
objeù
 
	gIÁSyncCrossšgSšk


61 
def
 
­¶y
(
sync
: 
IÁ
 = 3)(
im¶ic™
 
p
: 
P¬am‘”s
) =

63 
v®
 
štsšk
 = 
LazyModuË
(
Ãw
 
IÁSyncCrossšgSšk
(
sync
))

64 
štsšk
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/CrossingHelper.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
şass
 
	$IÁInw¬dCrossšgH–³r
(
Çme
: 
SŒšg
, 
scİe
: 
LazyScİe
, 
node
: 
IÁInw¬dNode
) {

9 
def
 
	`­¶y
(
xšg
: 
ClockCrossšgTy³
 = 
NoCrossšg
, 
®»adyRegi¡”ed
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
IÁInw¬dNode
 = {

10 
xšg
 
m©ch
 {

11 
x
: 
AsynchrÚousCrossšg
 =>

12 
node
 :*=* 
scİe
 { 
	`IÁSyncCrossšgSšk
(
x
.
sškSync
è:*=* 
	`IÁSyncNameNode
(
Çme
è} :*=* IÁSyncNameNodeÒameè:*=* 
	`IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
)

13 
	`R©iÚ®Crossšg
(
_
) =>

14 
node
 :*=* 
scİe
 { 
	`IÁSyncCrossšgSšk
(1è:*=* 
	`IÁSyncNameNode
(
Çme
è} :*=* IÁSyncNameNodeÒameè:*=* 
	`IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
)

15 
	`SynchrÚousCrossšg
(
_
) =>

16 
node
 :*=* 
scİe
 { 
	`IÁSyncCrossšgSšk
(0è:*=* 
	`IÁSyncNameNode
(
Çme
è} :*=* IÁSyncNameNodeÒameè:*=* 
	`IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
)

19 
	}
}

21 
şass
 
	$IÁOutw¬dCrossšgH–³r
(
Çme
: 
SŒšg
, 
scİe
: 
LazyScİe
, 
node
: 
IÁOutw¬dNode
) {

22 
def
 
	`­¶y
(
xšg
: 
ClockCrossšgTy³
 = 
NoCrossšg
, 
®»adyRegi¡”ed
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
IÁOutw¬dNode
 = {

23 
xšg
 
m©ch
 {

24 
x
: 
AsynchrÚousCrossšg
 =>

25 
	`IÁSyncCrossšgSšk
(
x
.
sškSync
è:*=* 
	`IÁSyncNameNode
(
Çme
è:*=* 
scİe
 { IÁSyncNameNodeÒameè:*=* 
	`IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
è} :*=* 
node


26 
	`R©iÚ®Crossšg
(
_
) =>

27 
	`IÁSyncCrossšgSšk
(1è:*=* 
	`IÁSyncNameNode
(
Çme
è:*=* 
scİe
 { IÁSyncNameNodeÒameè:*=* 
	`IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
è} :*=* 
node


28 
	`SynchrÚousCrossšg
(
bufãr
) =>

29 
	`IÁSyncCrossšgSšk
(0è:*=* 
	`IÁSyncNameNode
(
Çme
è:*=* 
scİe
 { IÁSyncNameNodeÒameè:*=* 
	`IÁSyncCrossšgSourû
(
®»adyRegi¡”ed
è} :*=* 
node


32 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Nodes.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
objeù
 
IÁImp
 
ex‹nds
 
	gSim¶eNodeImp
[
IÁSourûPÜtP¬am‘”s
, 
IÁSškPÜtP¬am‘”s
, 
IÁEdge
, 
Vec
[
BoŞ
]]

12 
def
 
edge
(
pd
: 
IÁSourûPÜtP¬am‘”s
, 
pu
: 
IÁSškPÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
IÁEdge
(pd,…u,…, sourceInfo)

13 
def
 
bundË
(
e
: 
IÁEdge
èğ
Vec
Ó.
sourû
.
num
, 
BoŞ
())

14 
def
 
»nd”
(
e
: 
IÁEdge
èğ
R’d”edEdge
(
cŞour
 = "#0000ff" , 
Ïb–
 =ƒ.
sourû
.
sourûs
.
m­
(
_
.
¿nge
.
size
).
sum
.
toSŒšg
, 
æ³d
 = 
Œue
)

16 
ov”ride
 
def
 
mixO
(
pd
: 
IÁSourûPÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[IÁSourûPÜtP¬am‘”s, 
IÁSškPÜtP¬am‘”s
, 
Vec
[
BoŞ
]]): IntSourcePortParameters =

17 
pd
.
cİy
(
sourûs
 =…d.sourûs.
m­
 { 
s
 => s.cİy (
nodeP©h
 = 
node
 +: s.nodePath) })

18 
ov”ride
 
def
 
mixI
(
pu
: 
IÁSškPÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
IÁSourûPÜtP¬am‘”s
, IÁSškPÜtP¬am‘”s, 
Vec
[
BoŞ
]]): IntSinkPortParameters =

19 
pu
.
cİy
(
sšks
 =…u.sšks.
m­
 { 
s
 => s.cİy (
nodeP©h
 = 
node
 +: s.nodePath) })

22 
şass
 
	$IÁSourûNode
(
pÜtP¬ams
: 
Seq
[
IÁSourûPÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SourûNode
(
IÁImp
)(
pÜtP¬ams
)

23 
şass
 
	$IÁSškNode
(
pÜtP¬ams
: 
Seq
[
IÁSškPÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SškNode
(
IÁImp
)(
pÜtP¬ams
)

24 
şass
 
	`IÁAd­‹rNode
(

25 
sourûFn
: 
IÁSourûPÜtP¬am‘”s
 => IÁSourûPÜtP¬am‘” ğ{ 
s
 => s 
	}
},

26 
	gsškFn
: 
IÁSškPÜtP¬am‘”s
 => IÁSškPÜtP¬am‘” ğ{ 
s
 => s })(

27 
im¶ic™
 
v®Name
: 
V®Name
)

28 
ex‹nds
 
	$Ad­‹rNode
(
IÁImp
)(
sourûFn
, 
sškFn
)

29 şas 
	cIÁId’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$Id’t™yNode
(
IÁImp
)()

31 
objeù
 
IÁNameNode
 {

32 
def
 
	`­¶y
(
Çme
: 
V®Name
èğ
	$IÁId’t™yNode
()(
Çme
)

33 
def
 
	$­¶y
(
Çme
: 
O±iÚ
[
SŒšg
]): 
IÁId’t™yNode
 = 
	`­¶y
((
	`V®Name
Òame.
	`g‘OrEl£
("with_no_name"))))

34 
def
 
	$­¶y
(
Çme
: 
SŒšg
): 
IÁId’t™yNode
 = 
	`­¶y
(
	`Some
(name))

37 
şass
 
	`IÁNexusNode
(

38 
sourûFn
: 
Seq
[
IÁSourûPÜtP¬am‘”s
] => IntSourcePortParameters,

39 
sškFn
: 
Seq
[
IÁSškPÜtP¬am‘”s
] => IntSinkPortParameters,

40 
šputRequœesOuut
: 
BoŞ—n
 = 
Œue
,

41 
ouutRequœesIÅut
: 
BoŞ—n
 = 
Œue
)(

42 
im¶ic™
 
v®Name
: 
V®Name
)

43 
ex‹nds
 
	$NexusNode
(
IÁImp
)(
sourûFn
, 
sškFn
, 
šputRequœesOuut
, 
ouutRequœesIÅut
)

45 
objeù
 
IÁSyncImp
 
ex‹nds
 
Sim¶eNodeImp
[
IÁSourûPÜtP¬am‘”s
, 
IÁSškPÜtP¬am‘”s
, 
IÁEdge
, 
SyncIÁ”ru±s
]

47 
def
 
	`edge
(
pd
: 
IÁSourûPÜtP¬am‘”s
, 
pu
: 
IÁSškPÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
	`IÁEdge
(pd,…u,…, sourceInfo)

48 
def
 
	`bundË
(
e
: 
IÁEdge
èğ
Ãw
 
	`SyncIÁ”ru±s
(e)

49 
def
 
	`»nd”
(
e
: 
IÁEdge
èğ
	`R’d”edEdge
(
cŞour
 = "#ff00ff" , 
Ïb–
 =ƒ.
sourû
.
sourûs
.
	`m­
(
_
.
¿nge
.
size
).
sum
.
toSŒšg
, 
æ³d
 = 
Œue
)

51 
ov”ride
 
def
 
	`mixO
(
pd
: 
IÁSourûPÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[IÁSourûPÜtP¬am‘”s, 
IÁSškPÜtP¬am‘”s
, 
SyncIÁ”ru±s
]): IntSourcePortParameters =

52 
pd
.
	`cİy
(
sourûs
 =…d.sourûs.
m­
 { 
s
 => s.cİy (
nodeP©h
 = 
node
 +: s.nodePath) })

53 
ov”ride
 
def
 
	`mixI
(
pu
: 
IÁSškPÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
IÁSourûPÜtP¬am‘”s
, IÁSškPÜtP¬am‘”s, 
SyncIÁ”ru±s
]): IntSinkPortParameters =

54 
pu
.
	`cİy
(
sšks
 =…u.sšks.
m­
 { 
s
 => s.cİy (
nodeP©h
 = 
node
 +: s.nodePath) })

55 
	}
}

57 şas 
	cIÁSyncId’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$Id’t™yNode
(
IÁSyncImp
)()

59 
objeù
 
IÁSyncNameNode
 {

60 
def
 
	`­¶y
(
Çme
: 
V®Name
èğ
	$IÁSyncId’t™yNode
()(
Çme
)

61 
def
 
	$­¶y
(
Çme
: 
O±iÚ
[
SŒšg
]): 
IÁSyncId’t™yNode
 = 
	`­¶y
((
	`V®Name
Òame.
	`g‘OrEl£
("with_no_name"))))

62 
def
 
	$­¶y
(
Çme
: 
SŒšg
): 
IÁSyncId’t™yNode
 = 
	`­¶y
(
	`Some
(name))

65 
şass
 
	$IÁSyncSourûNode
(
®»adyRegi¡”ed
: 
BoŞ—n
)(
im¶ic™
 
v®Name
: 
V®Name
)

66 
ex‹nds
 
	$MixedAd­‹rNode
(
IÁImp
, 
IÁSyncImp
)(

67 
dFn
 = { 
p
 =>… 
	}
},

68 
	guFn
 = { 
p
 =>… })

70 
ov”ride
 
Ïzy
 
v®
 
	gnodedebug¡ršg
 = 
s
"alreadyRegistered:${alreadyRegistered}"

73 
şass
 
	$IÁSyncSškNode
(
sync
: 
IÁ
)(
im¶ic™
 
v®Name
: 
V®Name
)

74 
ex‹nds
 
	$MixedAd­‹rNode
(
IÁSyncImp
, 
IÁImp
)(

75 
dFn
 = { 
p
 =>… 
	}
},

76 
	guFn
 = { 
p
 =>… })

78 
ov”ride
 
Ïzy
 
v®
 
	gnodedebug¡ršg
 = 
s
"sync:${sync}"

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/NullIntSource.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
şass
 
	$NuÎIÁSourû
(
num
: 
IÁ
 = 1, 
pÜts
: IÁ = 1, 
sourûs
: IÁ = 1)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


12 
v®
 
šŠode
 = 
	`IÁSourûNode
(
	`IÁSourûPÜtSim¶e
(
num
, 
pÜts
, 
sourûs
))

14 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

15 
šŠode
.
out
.
fÜ—ch
 { (
o
, 
_
è=> o.fÜ—ch { _ :ğ
çl£
.
B
 } }

17 
	}
}

19 
objeù
 
NuÎIÁSourû
 {

20 
def
 
­¶y
(
num
: 
IÁ
 = 1, 
pÜts
: IÁ = 1, 
sourûs
: IÁ = 1)(
im¶ic™
 
p
: 
P¬am‘”s
): 
IÁNode
 = {

21 
v®
 
nuÎ_št_sourû
 = 
LazyModuË
(
Ãw
 
NuÎIÁSourû
(
num
, 
pÜts
, 
sourûs
))

22 
	gnuÎ_št_sourû
.
	gšŠode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Parameters.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
şass
 
	$IÁRªge
(
¡¬t
: 
IÁ
, 
’d
: Int)

13 
	`»quœe
 (
¡¬t
 >= 0)

14 
	`»quœe
 (
¡¬t
 <ğ
’d
)

15 
def
 
size
 = 
’d
 - 
¡¬t


16 
def
 
	`ov”Ïps
(
x
: 
IÁRªge
èğ
¡¬t
 < x.
’d
 && x.start <ƒnd

17 
def
 
	`off£t
(
x
: 
IÁ
èğ
	`IÁRªge
(x+
¡¬t
, x+
’d
)

18 
	}
}

20 
objeù
 
	gIÁRªge


22 
im¶ic™
 
def
 
­¶y
(
’d
: 
IÁ
): 
IÁRªge
 =‡pply(0,ƒnd)

25 
şass
 
IÁSourûP¬am‘”s
(

26 
¿nge
: 
IÁRªge
,

27 
»sourûs
: 
Seq
[
Resourû
] = Seq(),

28 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

30 
v®
 
Çme
 = 
nodeP©h
.
Ï¡O±iÚ
.
	`m­
(
_
.
ÏzyModuË
.Çme).
	`g‘OrEl£
("disconnected")

31 
	}
}

33 
şass
 
IÁSškP¬am‘”s
(

34 
nodeP©h
: 
Seq
[
Ba£Node
] = 
	$Seq
())

36 
v®
 
Çme
 = 
nodeP©h
.
Ï¡O±iÚ
.
	`m­
(
_
.
ÏzyModuË
.Çme).
	`g‘OrEl£
("disconnected")

37 
	}
}

39 
şass
 
	$IÁSourûPÜtP¬am‘”s
(
sourûs
: 
Seq
[
IÁSourûP¬am‘”s
])

41 
v®
 
num
 = 
sourûs
.
	`m­
(
_
.
¿nge
.
size
).
sum


43 
sourûs
.
	`m­
(
_
.
¿nge
).
	`combš©iÚs
(2).
fÜ—ch
 { 
	`Seq
(
a
, 
b
è=> 
	`»quœe
 (!a.
	`ov”Ïps
(b)) }

45 
	`»quœe
 (
sourûs
.
isEm±y
 || sourûs.
	`m­
(
_
.
¿nge
.
’d
).
max
 =ğ
num
)

46 
	}
}

47 
objeù
 
	gIÁSourûPÜtSim¶e


49 
def
 
­¶y
(
num
: 
IÁ
 = 1, 
pÜts
: IÁ = 1, 
sourûs
: IÁ = 1, 
»sourûs
: 
Seq
[
Resourû
] = 
N
) =

50 ià(
num
 =ğ0è
N
 

51 
Seq
.
fl
(
pÜts
)(
IÁSourûPÜtP¬am‘”s
(Seq.fl(
sourûs
)(
IÁSourûP¬am‘”s
(
¿nge
 = 
IÁRªge
(0, 
num
), 
»sourûs
 =„esources))))

54 
şass
 
	$IÁSškPÜtP¬am‘”s
(
sšks
: 
Seq
[
IÁSškP¬am‘”s
])

55 
objeù
 
IÁSškPÜtSim¶e


57 
def
 
	`­¶y
(
pÜts
: 
IÁ
 = 1, 
sšks
: Int = 1) =

58 
Seq
.
	`fl
(
pÜts
)(
	`IÁSškPÜtP¬am‘”s
(Seq.fl(
sšks
)(
	`IÁSškP¬am‘”s
())))

59 
	}
}

61 
şass
 
IÁEdge
(
sourû
: 
IÁSourûPÜtP¬am‘”s
, 
sšk
: 
IÁSškPÜtP¬am‘”s
, 
·¿ms
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/RegisterRouter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


10 
Œa™
 
	gHasIÁ”ru±Sourûs
 { 
	gthis
: 
Regi¡”Rou‹r
[
_
] =>

11 
def
 
nIÁ”ru±s
: 
IÁ


12 
´Ùeùed
 
v®
 
šŠode
 = 
IÁSourûNode
(
IÁSourûPÜtSim¶e
(
num
 = 
nIÁ”ru±s
, 
»sourûs
 = 
Seq
(
Resourû
(
deviû
, "int"))))

15 
v®
 
	gštXšg
: 
IÁOutw¬dCrossšgH–³r
 = 
this
.
üossOut
(
šŠode
)

18 
v®
 
š‹¼u±s
: 
ModuËV®ue
[
Vec
[
BoŞ
]] = 
InModuËBody
 { ià(
šŠode
.
out
.
isEm±y
èVec(0, BoŞ()èšŠode.out(0).
_1
 }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Xbar.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
š‹¼u±s


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 şas 
	cIÁXb¬
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


11 
v®
 
šŠode
 = 
	`IÁNexusNode
(

12 
sškFn
 = { 
_
 => 
	`IÁSškPÜtP¬am‘”s
(
	`Seq
(
	`IÁSškP¬am‘”s
())) },

13 
sourûFn
 = { 
£q
 =>

14 
	`IÁSourûPÜtP¬am‘”s
((
£q
 
z
 seq.
	`m­
(
_
.
num
).
	`sÿnLeá
(0)(_+_).
š™
).
m­
 {

15 (
s
, 
o
è=> s.
sourûs
.
	`m­
(
z
 => z.
	`cİy
(
¿nge
 = z.¿nge.
	`off£t
(o)))

16 }.
æ©‹n
)

17 
	}
})

19 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

20 
v®
 
ÿt
 = 
šŠode
.
š
.
m­
 { (
i
, 
e
è=> i.
	`ke
Ó.
sourû
.
num
è}.
æ©‹n


21 
šŠode
.
out
.
fÜ—ch
 { (
o
, 
_
è=> o :ğ
ÿt
 }

22 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
·ckage
 
objeù
 
	gš‹¼u±s


10 
ty³
 
	gIÁInw¬dNode
 = 
Inw¬dNodeHªdË
[
IÁSourûPÜtP¬am‘”s
, 
IÁSškPÜtP¬am‘”s
, 
IÁEdge
, 
Vec
[
BoŞ
]]

11 
ty³
 
	gIÁOutw¬dNode
 = 
Outw¬dNodeHªdË
[
IÁSourûPÜtP¬am‘”s
, 
IÁSškPÜtP¬am‘”s
, 
IÁEdge
, 
Vec
[
BoŞ
]]

12 
ty³
 
	gIÁNode
 = 
Sim¶eNodeHªdË
[
IÁSourûPÜtP¬am‘”s
, 
IÁSškPÜtP¬am‘”s
, 
IÁEdge
, 
Vec
[
BoŞ
]]

14 
im¶ic™
 cÏs 
	cIÁClockDomašCrossšg
(
v®
 
x
: 
HasClockDomašCrossšg
è
ex‹nds
 
AnyV®
 {

15 
def
 
	`üossIn
 (
n
: 
IÁInw¬dNode
è(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`IÁInw¬dCrossšgH–³r
(v®Name.
Çme
, 
x
,‚)

16 
def
 
	`üossOut
(
n
: 
IÁOutw¬dNode
)(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`IÁOutw¬dCrossšgH–³r
(v®Name.
Çme
, 
x
,‚)

17 
def
 
	`üoss
(
n
: 
IÁInw¬dNode
è(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`üossIn
(n)

18 
def
 
	`üoss
(
n
: 
IÁOutw¬dNode
)(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`üossOut
(n)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagShifter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
jg


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gchi£l3
.
	gcÜe
.{
	gIÅut
, 
	gOuut
}

8 
impÜt
 
	gchi£l3
.
	gcÜe
.
D©aMœrÜ


9 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gfœ¹l
.
KnownWidth


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


17 şas 
	cShiá”IO
 
ex‹nds
 
	mBundË
 {

18 
v®
 
	mshiá
 = 
	$BoŞ
()

19 
v®
 
d©a
 = 
	$BoŞ
()

20 
v®
 
ÿ±u»
 = 
	$BoŞ
()

21 
v®
 
upd©e
 = 
	$BoŞ
()

25 
def
 
	$chašCÚŒŞFrom
(
š
: 
Shiá”IO
) {

26 
shiá
 :ğ
š
.shift

27 
ÿ±u»
 :ğ
š
.capture

28 
upd©e
 :ğ
š
.update

30 
	}
}

32 
Œa™
 
ChašIO
 
ex‹nds
 
BundË
 {

33 
v®
 
chašIn
 = 
IÅut
(
Ãw
 
Shiá”IO
)

34 
v®
 
chašOut
 = 
Ouut
(
Ãw
 
Shiá”IO
)

37 
şass
 
C­tu»
[+
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË
 {

38 
v®
 
b™s
 = 
IÅut
(
g’
)

39 
v®
 
ÿ±u»
 = 
Ouut
(
BoŞ
())

40 
ov”ride
 
def
 
şÚeTy³
 = 
C­tu»
(
g’
).
asIn¡ªûOf
[
this
.
ty³
]

43 
objeù
 
C­tu»
 {

44 
def
 
­¶y
[
T
 <: 
D©a
](
g’
: T): 
C­tu»
[T] = 
Ãw
 Capture(gen)

50 
Œa™
 
Chaš
 
ex‹nds
 
ModuË
 {

51 
v®
 
io
: 
ChašIO


58 şas 
	cJgBy·ssChaš
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
Chaš
 {

59 
şass
 
ModIO
 
ex‹nds
 
ChašIO


60 
v®
 
io
 = 
	$IO
(
Ãw
 
ModIO
)

61 
io
.
chašOut
 
chašCÚŒŞFrom
 io.
chašIn


63 
v®
 
»g
 = 
	`Reg
(
	$BoŞ
())

65 
io
.
chašOut
.
d©a
 :ğ
»g


67 
	`cov”
(
io
.
chašIn
.
ÿ±u»
, "bypass_chain_capture", "JTAG; bypass_chain_capture; This Bypass Chain captured data")

69 
	$wh’
 (
io
.
chašIn
.
ÿ±u»
) {

70 
»g
 :ğ
çl£
.
B


71 } .
	$–£wh’
 (
io
.
chašIn
.
shiá
) {

72 
»g
 :ğ
io
.
chašIn
.
d©a


73 
	}
}

74 
as£¹
(!(
io
.
chašIn
.
ÿ±u»
 && io.chašIn.
upd©e
)

75 && !(
io
.
chašIn
.
ÿ±u»
 && io.chašIn.
shiá
)

76 && !(
io
.
chašIn
.
upd©e
 && io.chašIn.
shiá
))

79 
objeù
 
JgBy·ssChaš
 {

80 
def
 
­¶y
()(
im¶ic™
 
p
: 
P¬am‘”s
èğ
Ãw
 
JgBy·ssChaš


91 
şass
 
C­tu»Chaš
[+
T
 <: 
D©a
](
g’
: T)(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
Chaš
 {

92 şas 
	cModIO
 
ex‹nds
 
ChašIO
 {

93 
v®
 
ÿ±u»
 = 
C­tu»
(
g’
)

95 
v®
 
io
 = 
	$IO
(
Ãw
 
ModIO
)

96 
io
.
chašOut
 
chašCÚŒŞFrom
 io.
chašIn


98 
v®
 
n
 = 
D©aMœrÜ
.
	$widthOf
(
g’
è
m©ch
 {

99 
	`KnownWidth
(
x
) => x

100 
_
 => 
	`»quœe
(
çl£
, 
s
"can't generate chain for unknown width dataype $gen"); -1

101 
	}
}

103 
v®
 
	g»gs
 = (0 
uÁ
 
n
è
m­
 (
x
 => 
Reg
(
	$BoŞ
()))

105 
io
.
chašOut
.
d©a
 :ğ
	$»gs
(0)

107 
	`cov”
(
io
.
chašIn
.
ÿ±u»
, "chain_capture", "JTAG; chain_capture; This Chain captured data")

109 
	$wh’
 (
io
.
chašIn
.
ÿ±u»
) {

110 (0 
uÁ
 
n
è
	`m­
 (
x
 => 
	`»gs
(xè:ğ
io
.
ÿ±u»
.
b™s
.
	`asUIÁ
()(x))

111 
io
.
ÿ±u»
.ÿ±u» :ğ
Œue
.
B


112 
	}
} .
	$–£wh’
 (
io
.
chašIn
.
shiá
) {

113 
	`»gs
(
n
-1è:ğ
io
.
chašIn
.
d©a


114 (0 
uÁ
 
n
-1è
	`m­
 (
x
 => 
	`»gs
(x) :=„egs(x+1))

115 
io
.
ÿ±u»
.ÿ±u» :ğ
çl£
.
B


116 
	}
} .
Ùh”wi£
 {

117 
io
.
ÿ±u»
.ÿ±u» :ğ
çl£
.
B


119 
as£¹
(!(
io
.
chašIn
.
ÿ±u»
 && io.chašIn.
upd©e
)

120 && !(
io
.
chašIn
.
ÿ±u»
 && io.chašIn.
shiá
)

121 && !(
io
.
chašIn
.
upd©e
 && io.chašIn.
shiá
))

124 
objeù
 
C­tu»Chaš
 {

125 
def
 
­¶y
[
T
 <: 
D©a
](
g’
: T)(
im¶ic™
 
p
: 
P¬am‘”s
èğ
Ãw
 
C­tu»Chaš
(gen)

138 
şass
 
C­tu»Upd©eChaš
[+
T
 <: 
D©a
, +
V
 <: D©a](
g’C­tu»
: T, 
	gg’Upd©e
: V)(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
Chaš
 {

139 şas 
	cModIO
 
ex‹nds
 
ChašIO
 {

140 
v®
 
ÿ±u»
 = 
C­tu»
(
g’C­tu»
)

141 
v®
 
upd©e
 = 
V®id
(
g’Upd©e
)

143 
v®
 
io
 = 
	$IO
(
Ãw
 
ModIO
)

144 
io
.
chašOut
 
chašCÚŒŞFrom
 io.
chašIn


146 
v®
 
ÿ±u»Width
 = 
D©aMœrÜ
.
	$widthOf
(
g’C­tu»
è
m©ch
 {

147 
	`KnownWidth
(
x
) => x

148 
_
 => 
	`»quœe
(
çl£
, 
s
"can't generate chain for unknown width dataype $genCapture"); -1

149 
	}
}

150 
v®
 
	gupd©eWidth
 = 
D©aMœrÜ
.
	$widthOf
(
g’Upd©e
è
m©ch
 {

151 
	`KnownWidth
(
x
) => x

152 
_
 => 
	`»quœe
(
çl£
, 
s
"can't generate chain for unknown width dataype $genUpdate"); -1

153 
	}
}

154 
v®
 
	gn
 = 
m©h
.
	$max
(
ÿ±u»Width
, 
upd©eWidth
)

156 
v®
 
»gs
 = (0 
uÁ
 
n
è
	`m­
 (
x
 => 
	`Reg
(
	$BoŞ
()))

158 
io
.
chašOut
.
d©a
 :ğ
	$»gs
(0)

160 
v®
 
upd©eB™s
 = 
	$C©
(
»gs
.
»v”£
)(
upd©eWidth
-1, 0)

161 
io
.
upd©e
.
b™s
 :ğ
upd©eB™s
.
	$asTy³Of
(
io
.
upd©e
.
b™s
)

163 
v®
 
ÿ±u»B™s
 = 
io
.
ÿ±u»
.
b™s
.
	$asUIÁ
()

165 
	`cov”
(
io
.
chašIn
.
ÿ±u»
, "chain_capture", "JTAG;chain_capture; This Chain captured data")

166 
	`cov”
(
io
.
chašIn
.
ÿ±u»
, "chain_update", "JTAG;chain_update; This Chain updated data")

168 
	$wh’
 (
io
.
chašIn
.
ÿ±u»
) {

169 (0 
uÁ
 
m©h
.
	`mš
(
n
, 
ÿ±u»Width
)è
	`m­
 (
x
 => 
	`»gs
(xè:ğ
	`ÿ±u»B™s
(x))

170 (
ÿ±u»Width
 
uÁ
 
n
è
	`m­
 (
x
 => 
	`»gs
(x) := 0.U)

171 
io
.
ÿ±u»
.ÿ±u» :ğ
Œue
.
B


172 
io
.
upd©e
.
v®id
 :ğ
çl£
.
B


173 
	}
} .
	$–£wh’
 (
io
.
chašIn
.
upd©e
) {

174 
io
.
ÿ±u»
.ÿ±u» :ğ
çl£
.
B


175 
io
.
upd©e
.
v®id
 :ğ
Œue
.
B


176 
	}
} .
	$–£wh’
 (
io
.
chašIn
.
shiá
) {

177 
	`»gs
(
n
-1è:ğ
io
.
chašIn
.
d©a


178 (0 
uÁ
 
n
-1è
	`m­
 (
x
 => 
	`»gs
(x) :=„egs(x+1))

179 
io
.
ÿ±u»
.ÿ±u» :ğ
çl£
.
B


180 
io
.
upd©e
.
v®id
 :ğ
çl£
.
B


181 
	}
} .
Ùh”wi£
 {

182 
io
.
ÿ±u»
.ÿ±u» :ğ
çl£
.
B


183 
io
.
upd©e
.
v®id
 :ğ
çl£
.
B


185 
as£¹
(!(
io
.
chašIn
.
ÿ±u»
 && io.chašIn.
upd©e
)

186 && !(
io
.
chašIn
.
ÿ±u»
 && io.chašIn.
shiá
)

187 && !(
io
.
chašIn
.
upd©e
 && io.chašIn.
shiá
))

190 
objeù
 
C­tu»Upd©eChaš
 {

193 
def
 
­¶y
[
T
 <: 
D©a
](
g’
: T)(
im¶ic™
 
p
: 
P¬am‘”s
èğ
Ãw
 
C­tu»Upd©eChaš
(gen, gen)

194 
def
 
	g­¶y
[
T
 <: 
D©a
, 
V
 <: D©a](
g’C­tu»
: T, 
	gg’Upd©e
: V)(
im¶ic™
 
p
: 
P¬am‘”s
) =

195 
Ãw
 
C­tu»Upd©eChaš
(
g’C­tu»
, 
g’Upd©e
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagStateMachine.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
jg


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.{
	gIÅut
, 
	gOuut
}

7 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
w™hRe£t


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gP¬am‘”s
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gAsyncRe£tRegVec
}

11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


13 
objeù
 
	gJgS‹
 {

14 
£®ed
 
ab¡¿ù
 cÏs 
	cS‹
(
v®
 
id
: 
IÁ
) {

15 
def
 
U
: 
UIÁ
 = 
id
.
	`U
(
S‹
.
width
.
W
)

16 
	}
}

18 
objeù
 
S‹
 {

19 
impÜt
 
sÿÏ
.
Ïnguage
.
im¶ic™CÚv”siÚs


21 
im¶ic™
 
def
 
toIÁ
(
x
: 
S‹
èğx.
id


22 
im¶ic™
 
def
 
toBigIÁ
(
x
: 
S‹
):
BigIÁ
 = x.
id


25 
v®
 
®l
: 
S‘
[
S‹
] = Set(

26 
Te¡LogicRe£t
,

27 
RunTe¡IdË
,

28 
S–eùDRSÿn
,

29 
C­tu»DR
,

30 
ShiáDR
,

31 
Ex™1DR
,

32 
Pau£DR
,

33 
Ex™2DR
,

34 
Upd©eDR
,

35 
S–eùIRSÿn
,

36 
C­tu»IR
,

37 
ShiáIR
,

38 
Ex™1IR
,

39 
Pau£IR
,

40 
Ex™2IR
,

41 
Upd©eIR


43 
v®
 
	gwidth
 = 
log2Ce
(
®l
.
size
)

44 
def
 
chi£lTy³
(èğ
UIÁ
(
width
.
W
)

48 
objeù
 
Te¡LogicRe£t
 
ex‹nds
 
	$S‹
(15)

49 
objeù
 
RunTe¡IdË
 
ex‹nds
 
	$S‹
(12)

50 
objeù
 
S–eùDRSÿn
 
ex‹nds
 
	$S‹
(7)

51 
objeù
 
C­tu»DR
 
ex‹nds
 
	$S‹
(6)

52 
objeù
 
ShiáDR
 
ex‹nds
 
	$S‹
(2)

53 
objeù
 
Ex™1DR
 
ex‹nds
 
	$S‹
(1)

54 
objeù
 
Pau£DR
 
ex‹nds
 
	$S‹
(3)

55 
objeù
 
Ex™2DR
 
ex‹nds
 
	$S‹
(0)

56 
objeù
 
Upd©eDR
 
ex‹nds
 
	$S‹
(5)

57 
objeù
 
S–eùIRSÿn
 
ex‹nds
 
	$S‹
(4)

58 
objeù
 
C­tu»IR
 
ex‹nds
 
	$S‹
(14)

59 
objeù
 
ShiáIR
 
ex‹nds
 
	$S‹
(10)

60 
objeù
 
Ex™1IR
 
ex‹nds
 
	$S‹
(9)

61 
objeù
 
Pau£IR
 
ex‹nds
 
	$S‹
(11)

62 
objeù
 
Ex™2IR
 
ex‹nds
 
	$S‹
(8)

63 
objeù
 
Upd©eIR
 
ex‹nds
 
	`S‹
(13)

64 
	}
}

74 şas 
	cJgS‹Machše
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$ModuË
() {

75 şas 
	cS‹MachšeIO
 
ex‹nds
 
BundË
 {

76 
v®
 
tms
 = 
	`IÅut
(
	`BoŞ
())

77 
v®
 
cu¼S‹
 = 
	`Ouut
(
JgS‹
.
S‹
.
chi£lTy³
)

79 
v®
 
io
 = 
	$IO
(
Ãw
 
S‹MachšeIO
)

81 
v®
 
ÃxtS‹
 = 
	`Wœe
(
JgS‹
.
S‹
.
	$chi£lTy³
())

82 
v®
 
cu¼S‹Reg
 = 
	`ModuË
 (
Ãw
 
	`AsyncRe£tRegVec
(
w
 = 
JgS‹
.
S‹
.
width
,

83 
š™
 = 
JgS‹
.
S‹
.
	$toIÁ
(
JgS‹
.
Te¡LogicRe£t
)))

84 
cu¼S‹Reg
.
io
.
’
 :ğ
Œue
.
B


85 
cu¼S‹Reg
.
io
.
d
 :ğ
ÃxtS‹


86 
v®
 
cu¼S‹
 = 
cu¼S‹Reg
.
io
.
q


88 
cu¼S‹
) {

89 
	`is
 (
JgS‹
.
Te¡LogicRe£t
.
U
) {

90 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Te¡LogicRe£t
.
U
, JgS‹.
RunTe¡IdË
.U)

92 
	`is
 (
JgS‹
.
RunTe¡IdË
.
U
) {

93 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
S–eùDRSÿn
.
U
, JgS‹.
RunTe¡IdË
.U)

95 
	`is
 (
JgS‹
.
S–eùDRSÿn
.
U
) {

96 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
S–eùIRSÿn
.
U
, JgS‹.
C­tu»DR
.U)

98 
	`is
 (
JgS‹
.
C­tu»DR
.
U
) {

99 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Ex™1DR
.
U
, JgS‹.
ShiáDR
.U)

101 
	`is
 (
JgS‹
.
ShiáDR
.
U
) {

102 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Ex™1DR
.
U
, JgS‹.
ShiáDR
.U)

104 
	`is
 (
JgS‹
.
Ex™1DR
.
U
) {

105 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Upd©eDR
.
U
, JgS‹.
Pau£DR
.U)

107 
	`is
 (
JgS‹
.
Pau£DR
.
U
) {

108 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Ex™2DR
.
U
, JgS‹.
Pau£DR
.U)

110 
	`is
 (
JgS‹
.
Ex™2DR
.
U
) {

111 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Upd©eDR
.
U
, JgS‹.
ShiáDR
.U)

113 
	`is
 (
JgS‹
.
Upd©eDR
.
U
) {

114 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
S–eùDRSÿn
.
U
, JgS‹.
RunTe¡IdË
.U)

116 
	`is
 (
JgS‹
.
S–eùIRSÿn
.
U
) {

117 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Te¡LogicRe£t
.
U
, JgS‹.
C­tu»IR
.U)

119 
	`is
 (
JgS‹
.
C­tu»IR
.
U
) {

120 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Ex™1IR
.
U
, JgS‹.
ShiáIR
.U)

122 
	`is
 (
JgS‹
.
ShiáIR
.
U
) {

123 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Ex™1IR
.
U
, JgS‹.
ShiáIR
.U)

125 
	`is
 (
JgS‹
.
Ex™1IR
.
U
) {

126 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Upd©eIR
.
U
, JgS‹.
Pau£IR
.U)

128 
	`is
 (
JgS‹
.
Pau£IR
.
U
) {

129 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Ex™2IR
.
U
, JgS‹.
Pau£IR
.U)

131 
	`is
 (
JgS‹
.
Ex™2IR
.
U
) {

132 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
Upd©eIR
.
U
, JgS‹.
ShiáIR
.U)

134 
	`is
 (
JgS‹
.
Upd©eIR
.
U
) {

135 
ÃxtS‹
 :ğ
	`Mux
(
io
.
tms
, 
JgS‹
.
S–eùDRSÿn
.
U
, JgS‹.
RunTe¡IdË
.U)

137 
	}
}

139 
	gio
.
	gcu¼S‹
 :ğ
cu¼S‹


142 
JgS‹
.
S‹
.
®l
.
fÜ—ch
 { 
s
 =>

143 
cov”
 (
cu¼S‹
 ==ğ
s
.
U
 && 
io
.
tms
 ==ğ
Œue
.
B
, s"${s.toString}_tms_1", s"JTAG; ${s.toString} with TMS = 1; State Transition from ${s.toString} with TMS = 1")

144 
cov”
 (
cu¼S‹
 ==ğ
s
.
U
 && 
io
.
tms
 ==ğ
çl£
.
B
, s"${s.toString}_tms_0", s"JTAG; ${s.toString} with TMS = 0; State Transition from ${s.toString} with TMS = 0")

145 
cov”
 (
cu¼S‹
 ==ğ
s
.
U
 && 
»£t
.
toBoŞ
 ==ğ
Œue
.
B
, s"${s.toString}_reset", s"JTAG; ${s.toString} with„eset; JTAG Reset‡sserted during ${s.toString}")

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagTap.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
jg


5 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
SÜ‹dM­


9 
impÜt
 
	gChi£l
.
_


10 
impÜt
 
	gchi£l3
.
	gcÜe
.{
	gIÅut
, 
	gOuut
}

11 
impÜt
 
	gchi£l3
.
	gut
.
_


12 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
w™hRe£t


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


18 
şass
 
	$JTAGIO
(
hasTRSTn
: 
BoŞ—n
 = 
çl£
è
ex‹nds
 
BundË
 {

19 
v®
 
TRSTn
 = ià(
hasTRSTn
è
	`Some
(
	`Ouut
(
	`BoŞ
())è
NÚe


20 
v®
 
TCK
 = 
	`Ouut
(
	`Clock
())

21 
v®
 
TMS
 = 
	`Ouut
(
	`BoŞ
())

22 
v®
 
TDI
 = 
	`Ouut
(
	`BoŞ
())

23 
v®
 
TDO
 = 
	`IÅut
(
Ãw
 
	`Tri¡©e
())

25 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`JTAGIO
(
hasTRSTn
).
asIn¡ªûOf
[
this
.
ty³
]

26 
	}
}

30 şas 
	cJgOuut
(
œL’gth
: 
IÁ
è
ex‹nds
 
BundË
 {

31 
v®
 
¡©e
 = 
	`Ouut
(
JgS‹
.
S‹
.
	$chi£lTy³
())

32 
v®
 
š¡ruùiÚ
 = 
	`Ouut
(
	$UIÁ
(
œL’gth
.
W
))

33 
v®
 
»£t
 = 
	`Ouut
(
	$BoŞ
())

35 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`JgOuut
(
œL’gth
).
asIn¡ªûOf
[
this
.
ty³
]

38 şas 
	cJgCÚŒŞ
 
ex‹nds
 
BundË
 {

39 
v®
 
jg_»£t
 = 
	`IÅut
(
	`BoŞ
())

44 
şass
 
	$JgBlockIO
(
œL’gth
: 
IÁ
, 
hasIdcode
:
BoŞ—n
 = 
Œue
è
ex‹nds
 
BundË
 {

46 
v®
 
jg
 = 
	`Fl³d
(
Ãw
 
	`JTAGIO
())

47 
v®
 
cÚŒŞ
 = 
Ãw
 
JgCÚŒŞ


48 
v®
 
ouut
 = 
Ãw
 
	`JgOuut
(
œL’gth
)

49 
v®
 
idcode
 = ià(
hasIdcode
è
	`Some
(
	`IÅut
(
Ãw
 
	`JTAGIdcodeBundË
())è
NÚe


51 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`JgBlockIO
(
œL’gth
, 
hasIdcode
).
asIn¡ªûOf
[
this
.
ty³
]

52 
	}
}

56 
şass
 
	$JgCÚŒŞËrIO
(
œL’gth
: 
IÁ
è
ex‹nds
 
	$JgBlockIO
(
œL’gth
, 
çl£
) {

57 
v®
 
d©aChašOut
 = 
	`Ouut
(
Ãw
 
Shiá”IO
)

58 
v®
 
d©aChašIn
 = 
	`IÅut
(
Ãw
 
Shiá”IO
)

60 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`JgCÚŒŞËrIO
(
œL’gth
).
asIn¡ªûOf
[
this
.
ty³
]

61 
	}
}

69 
şass
 
	$JgT­CÚŒŞËr
(
œL’gth
: 
IÁ
, 
š™ŸlIn¡ruùiÚ
: 
BigIÁ
)(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

70 
	`»quœe
(
œL’gth
 >= 2)

72 
v®
 
io
 = 
	`IO
(
Ãw
 
	`JgCÚŒŞËrIO
(
œL’gth
))

74 
v®
 
tdo
 = 
	`Wœe
(
	`BoŞ
())

75 
v®
 
tdo_driv’
 = 
	`Wœe
(
	`BoŞ
())

76 
io
.
jg
.
TDO
.
d©a
 :ğ
	`NegEdgeReg
(
şock
, 
tdo
, 
Çme
 = 
	`Some
("tdoReg"))

77 
io
.
jg
.
TDO
.
driv’
 :ğ
	`NegEdgeReg
(
şock
, 
tdo_driv’
, 
Çme
 = 
	`Some
("tdoeReg"))

83 
v®
 
cu¼S‹
 = 
	`Wœe
(
JgS‹
.
S‹
.
chi£lTy³
)

88 
	`»quœe
(!
io
.
jg
.
TRSTn
.
isDefšed
, "TRSTn should be‡bsorbed into jtckPOReset outside of JtagTapController.")

89 
	`w™hRe£t
(
io
.
cÚŒŞ
.
jg_»£t
) {

90 
v®
 
¡©eMachše
 = 
	`ModuË
(
Ãw
 
JgS‹Machše
)

91 
¡©eMachše
.
	`sugge¡Name
("stateMachine")

92 
¡©eMachše
.
io
.
tms
 :ğio.
jg
.
TMS


93 
cu¼S‹
 :ğ
¡©eMachše
.
io
.currState

94 
io
.
ouut
.
¡©e
 :ğ
¡©eMachše
.io.
cu¼S‹


103 
v®
 
œChaš
 = 
	`ModuË
(
	`C­tu»Upd©eChaš
(
	`UIÁ
(
œL’gth
.
W
)))

104 
œChaš
.
	`sugge¡Name
("irChain")

105 
œChaš
.
io
.
chašIn
.
shiá
 :ğ
cu¼S‹
 ==ğ
JgS‹
.
ShiáIR
.
U


106 
œChaš
.
io
.
chašIn
.
d©a
 :ğio.
jg
.
TDI


107 
œChaš
.
io
.
chašIn
.
ÿ±u»
 :ğ
cu¼S‹
 ==ğ
JgS‹
.
C­tu»IR
.
U


108 
œChaš
.
io
.
chašIn
.
upd©e
 :ğ
cu¼S‹
 ==ğ
JgS‹
.
Upd©eIR
.
U


109 
œChaš
.
io
.
ÿ±u»
.
b™s
 :ğ"b01".
U


111 
v®
 
upd©eIn¡ruùiÚ
 = 
	`Wœe
(
	`BoŞ
())

113 
v®
 
ÃxtAùiveIn¡ruùiÚ
 = 
	`Wœe
(
	`UIÁ
(
œL’gth
.
W
))

114 
v®
 
aùiveIn¡ruùiÚ
 = 
	`NegEdgeReg
(
şock
, 
ÃxtAùiveIn¡ruùiÚ
, 
upd©eIn¡ruùiÚ
, 
Çme
 = 
	`Some
("irReg"))

116 
	`wh’
 (
»£t
.
toBoŞ
) {

117 
ÃxtAùiveIn¡ruùiÚ
 :ğ
š™ŸlIn¡ruùiÚ
.
	`U
(
œL’gth
.
W
)

118 
upd©eIn¡ruùiÚ
 :ğ
Œue
.
B


119 } .
	`–£wh’
 (
cu¼S‹
 ==ğ
JgS‹
.
Upd©eIR
.
U
) {

120 
ÃxtAùiveIn¡ruùiÚ
 :ğ
œChaš
.
io
.
upd©e
.
b™s


121 
upd©eIn¡ruùiÚ
 :ğ
Œue
.
B


122 } .
Ùh”wi£
 {

125 
upd©eIn¡ruùiÚ
 :ğ
çl£
.
B


127 
io
.
ouut
.
š¡ruùiÚ
 :ğ
aùiveIn¡ruùiÚ


129 
io
.
ouut
.
»£t
 :ğ
cu¼S‹
 ==ğ
JgS‹
.
Te¡LogicRe£t
.
U


134 
io
.
d©aChašOut
.
shiá
 :ğ
cu¼S‹
 ==ğ
JgS‹
.
ShiáDR
.
U


135 
io
.
d©aChašOut
.
d©a
 :ğio.
jg
.
TDI


136 
io
.
d©aChašOut
.
ÿ±u»
 :ğ
cu¼S‹
 ==ğ
JgS‹
.
C­tu»DR
.
U


137 
io
.
d©aChašOut
.
upd©e
 :ğ
cu¼S‹
 ==ğ
JgS‹
.
Upd©eDR
.
U


142 
	`wh’
 (
cu¼S‹
 ==ğ
JgS‹
.
ShiáDR
.
U
) {

143 
tdo
 :ğ
io
.
d©aChašIn
.
d©a


144 
tdo_driv’
 :ğ
Œue
.
B


145 } .
	`–£wh’
 (
cu¼S‹
 ==ğ
JgS‹
.
ShiáIR
.
U
) {

146 
tdo
 :ğ
œChaš
.
io
.
chašOut
.
d©a


147 
tdo_driv’
 :ğ
Œue
.
B


148 } .
Ùh”wi£
 {

151 
tdo_driv’
 :ğ
çl£
.
B


153 
	}
}

155 
objeù
 
JgT­G’”©Ü
 {

180 
def
 
­¶y
(
œL’gth
: 
IÁ
, 
š¡ruùiÚs
: 
M­
[
BigIÁ
, 
Chaš
], 
icode
: 
O±iÚ
[BigIÁ] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
JgBlockIO
 = {

182 
v®
 
š‹º®Io
 = 
Wœe
(
Ãw
 
JgBlockIO
(
œL’gth
, 
icode
.
isDefšed
))

186 
v®
 
	g®lIn¡ruùiÚs
 = 
icode
 
m©ch
 {

187 (
Some
(
icode
)) => {

188 
»quœe
(!(
š¡ruùiÚs
 
cÚšs
 
icode
), "instructions may‚ot contain IDCODE")

189 
v®
 
idcodeChaš
 = 
ModuË
(
C­tu»Chaš
(
Ãw
 
JTAGIdcodeBundË
()))

190 
idcodeChaš
.
sugge¡Name
("idcodeChain")

191 
v®
 
i
 = 
š‹º®Io
.
idcode
.
g‘
.
asUIÁ
()

192 
as£¹
(
i
 % 2.U === 1.U, "LSB must be set in IDCODE, see 12.1.1d")

193 
as£¹
(((
i
 >> 1è& ((1.U << 11è- 1.U)è=/ğ
JgIdcode
.
dummyMäId
.
U
,

195 
	gidcodeChaš
.
	gio
.
	gÿ±u»
.
	gb™s
 :ğ
š‹º®Io
.
idcode
.
g‘


196 
š¡ruùiÚs
 + (
icode
 -> 
idcodeChaš
)

199 
NÚe
 => 
š¡ruùiÚs


202 
v®
 
by·ssIcode
 = (
BigIÁ
(1è<< 
œL’gth
) - 1

203 
v®
 
š™ŸlIn¡ruùiÚ
 = 
icode
.
g‘OrEl£
(
by·ssIcode
)

205 
»quœe
(!(
®lIn¡ruùiÚs
 
cÚšs
 
by·ssIcode
), "instructions may‚ot contain BYPASS code")

207 
v®
 
	gcÚŒŞËrIÁ”Çl
 = 
ModuË
(
Ãw
 
JgT­CÚŒŞËr
(
œL’gth
, 
š™ŸlIn¡ruùiÚ
))

209 
v®
 
	gunu£dChašOut
 = 
Wœe
(
Ãw
 
Shiá”IO
)

210 
unu£dChašOut
.
shiá
 :ğ
çl£
.
B


211 
unu£dChašOut
.
d©a
 :ğ
çl£
.
B


212 
unu£dChašOut
.
ÿ±u»
 :ğ
çl£
.
B


213 
unu£dChašOut
.
upd©e
 :ğ
çl£
.
B


215 
v®
 
by·ssChaš
 = 
ModuË
(
JgBy·ssChaš
())

218 
by·ssChaš
.
io
.
chašIn
 :ğ
cÚŒŞËrIÁ”Çl
.io.
d©aChašOut


219 
»quœe
(
®lIn¡ruùiÚs
.
size
 > 0, "Seriously? JTAG TAP with‚o instructions?")

224 
v®
 
	gchašToIcode
 = (
SÜ‹dM­
(
®lIn¡ruùiÚs
.
toLi¡
:
_
*).
groupBy
 { (
icode
, 
chaš
è=> chaš } 
	gm­
 {

225 (
	gchaš
, 
	gicodeToChaš
è=> 
chaš
 -> 
icodeToChaš
.
keys


226 }).
	gtoLi¡
.
sÜtBy
(
_
.
_2
.
h—d
)

228 
v®
 
	gchašToS–eù
 = 
chašToIcode
 
m­
 {

229 (
chaš
, 
icodes
) => {

230 
assume
(
icodes
.
size
 > 0)

231 
v®
 
icodeS–eùs
 = 
icodes
 
m­
 { 
cÚŒŞËrIÁ”Çl
.
io
.
ouut
.
š¡ruùiÚ
 ==ğ
_
.
asUIÁ
(
œL’gth
.
W
) }

232 
	gchaš
 -> 
	gicodeS–eùs
.
»duûLeá
(
_
||_)

236 
def
 
fŞdOutS–eù
(
»s
: 
Wh’CÚ‹xt
, 
x
: (
Chaš
, 
BoŞ
)): WhenContext = {

237 
v®
 (
chaš
, 
£Ëù
èğ
x


239 
»s
.
–£wh’
(
£Ëù
) {

240 
cÚŒŞËrIÁ”Çl
.
io
.
d©aChašIn
 :ğ
chaš
.io.
chašOut


244 
v®
 
em±yWh’
 = 
wh’
 (
çl£
.
B
) { }

245 
chašToS–eù
.
toSeq
.
fŞdLeá
(
em±yWh’
)(
fŞdOutS–eù
).
Ùh”wi£
 {

246 
cÚŒŞËrIÁ”Çl
.
io
.
d©aChašIn
 :ğ
by·ssChaš
.io.
chašOut


249 
def
 
m­InS–eù
(
x
: (
Chaš
, 
BoŞ
)) {

250 
v®
 (
chaš
, 
£Ëù
èğ
x


251 
wh’
 (
£Ëù
) {

252 
chaš
.
io
.
chašIn
 :ğ
cÚŒŞËrIÁ”Çl
.io.
d©aChašOut


253 } .
Ùh”wi£
 {

254 
chaš
.
io
.
chašIn
 :ğ
unu£dChašOut


258 
chašToS–eù
.
m­
(
m­InS–eù
)

260 
cÚŒŞËrIÁ”Çl
.
io
.
jg
 <> 
š‹º®Io
.jtag

261 
š‹º®Io
.
cÚŒŞ
 <> 
cÚŒŞËrIÁ”Çl
.
io
.control

262 
š‹º®Io
.
ouut
 <> 
cÚŒŞËrIÁ”Çl
.
io
.output

264 
š‹º®Io


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagUtils.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
jg


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gchi£l3
.
	gut
.
_


9 şas 
	cJTAGIdcodeBundË
 
ex‹nds
 
	mBundË
 {

10 
v®
 
	mv”siÚ
 = 
	$UIÁ
(4.
W
)

11 
v®
 
·¹Numb”
 = 
	$UIÁ
(16.
W
)

12 
v®
 
mäId
 = 
	$UIÁ
(11.
W
)

13 
v®
 
®ways1
 = 
	`UIÁ
(1.
W
)

16 
objeù
 
JgIdcode
 {

19 
def
 
	`­¶y
(
v”siÚ
: 
IÁ
, 
·¹Numb”
: IÁ, 
mäId
: IÁ): 
BigIÁ
 = {

20 
	`»quœe
(
v”siÚ
 < (1 << 4), "version field must be 4 bits‡t most")

21 
	`»quœe
(
·¹Numb”
 < (1 << 16), "part‚umber must be 16 bits‡t most")

22 
	`»quœe
(
mäId
 < (1 << 11), "manufacturer identity must be 11 bits‡t most")

23 
	`BigIÁ
(
v”siÚ
è<< 28 | BigIÁ(
·¹Numb”
è<< 12 | BigIÁ(
mäId
) << 1 | 1

29 
def
 
dummyMäId
: 
IÁ
 = 0x7f

30 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/Utils.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
jg


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gcÜe
.{
	gIÅut
, 
	gOuut
}

7 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
w™hClock


11 şas 
	cTri¡©e
 
ex‹nds
 
	mBundË
 {

12 
v®
 
	md©a
 = 
	$BoŞ
()

13 
v®
 
driv’
 = 
	`BoŞ
()

18 
objeù
 
NegEdgeReg
 {

19 
def
 
­¶y
[
T
 <: 
D©a
](
şock
: 
Clock
, 
Ãxt
: T, 
’abË
: 
BoŞ
=
Œue
.
B
, 
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): T = {

21 
	`w™hClock
((!
şock
.
asUIÁ
).
asClock
) {

22 
v®
 
»g
 = 
	`RegEÇbË
(
Ãxt
 =‚ext, 
’abË
 =ƒnable)

23 
Çme
.
fÜ—ch
{
»g
.
	`sugge¡Name
(
_
)}

24 
»g


27 
	}
}

32 
şass
 
	$ClockedCouÁ”
(
couÁs
: 
BigIÁ
, 
š™
: 
O±iÚ
[BigIÁ]è
ex‹nds
 
ModuË
 {

33 
	`»quœe
(
couÁs
 > 0, "really?")

35 
v®
 
width
 = 
	`log2Ce
(
couÁs
)

36 şas 
	cCouÁIO
 
ex‹nds
 
BundË
 {

37 
v®
 
couÁ
 = 
	`Ouut
(
	`UIÁ
(
width
.
W
))

38 
	}
}

39 
v®
 
	gio
 = 
	$IO
(
Ãw
 
CouÁIO
)

41 
v®
 
couÁ
 = 
š™
 
m©ch
 {

42 
	`Some
(
š™
è=> 
	`RegIn™
(š™.
	`U
(
width
.
W
))

43 
NÚe
 => 
	`Reg
(
	`UIÁ
(
width
.
W
))

44 
	}
}

46 
wh’
 (
couÁ
 ==ğ(
couÁs
 - 1).
asUIÁ
) {

47 
couÁ
 := 0.U

48 } .
Ùh”wi£
 {

49 
couÁ
 := count + 1.U

51 
io
.
couÁ
 := count

56 
objeù
 
ClockedCouÁ”
 {

57 
def
 
­¶y
 (
d©a
: 
BoŞ
, 
couÁs
: 
BigIÁ
, 
š™
: BigIÁ): 
UIÁ
 = {

58 
w™hClock
(
d©a
.
asClock
) {

59 
v®
 
couÁ”
 = 
ModuË
(
Ãw
 
ClockedCouÁ”
(
couÁs
, 
Some
(
š™
)))

60 
	gcouÁ”
.
	gio
.
	gcouÁ


64 
def
 
­¶y
 (
d©a
: 
BoŞ
, 
couÁs
: 
BigIÁ
): 
UIÁ
 = {

65 
w™hClock
(
d©a
.
asClock
) {

66 
v®
 
couÁ”
 = 
ModuË
(
Ãw
 
ClockedCouÁ”
(
couÁs
, 
NÚe
))

67 
	gcouÁ”
.
	gio
.
	gcouÁ


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
impÜt
 
	gsÿÏ
.
	gÏnguage
.
im¶ic™CÚv”siÚs


7 
·ckage
 
objeù
 
	gjg
 {

14 
im¶ic™
 
def
 
	gš¡ruùiÚIÁKeyToBigIÁ
[
V
 <: 
Chaš
](
x
: (
IÁ
, 
	gV
)èğ(
BigIÁ
(x.
_1
), 
	gx
.
	g_2
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/Annotation.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
»gm­³r


5 
impÜt
 
	gchi£l3
.
	gex³rim’l
.{
	gChi£lAÂÙ©iÚ
, 
	gRawModuË
, 
	gRunFœ¹lT¿nsfÜm
}

6 
impÜt
 
	gfœ¹l
.
	gªnÙ©iÚs
.
_


7 
impÜt
 
	gfœ¹l
.{
	gCœcu™FÜm
, 
	gCœcu™S‹
, 
	gLowFÜm
, 
	gT¿nsfÜm
}

9 
şass
 
RegF›ldDescS”
(

10 
by‹Off£t
: 
SŒšg
,

11 
b™Off£t
: 
IÁ
,

12 
b™Width
: 
IÁ
,

13 
Çme
: 
SŒšg
,

14 
»£tV®ue
: 
BigIÁ
,

15 
acûssTy³
: 
SŒšg
,

16 
wrTy³
: 
SŒšg
,

17 
rdAùiÚ
: 
SŒšg
,

18 
desc
: 
SŒšg
,

19 
group
: 
SŒšg
,

20 
groupDesc
: 
SŒšg
,

21 vŞ©e: 
BoŞ—n
 = 
çl£
,

22 
hasRe£t
: 
BoŞ—n
 = 
çl£
,

23 
’um”©iÚs
: 
M­
[
BigIÁ
, (
SŒšg
, SŒšg)] = 
	$M­
()

26 
şass
 
	`Regi¡”sS”
(

27 
di¥ÏyName
: 
SŒšg
,

28 
deviûName
: 
SŒšg
,

29 
ba£Add»ss
: 
BigIÁ
,

30 
»gF›lds
: 
Seq
[
RegF›ldDescS”
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/DescribedReg.scala

2 
·ckage
 
	gä“chs
.
	grock‘ch
.
»gm­³r


4 
impÜt
 
	gChi£l
.
_


5 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
_


6 
impÜt
 
	gchi£l3
.{
	gIÅut
, 
	gOuut
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gAsyncRe£tRegVec
, 
	gSim¶eRegIO
}

9 
objeù
 
	gDesüibedReg
 {

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
	gRegF›ldAcûssTy³
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
	gRegF›ldWrTy³
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
	gRegF›ldRdAùiÚ
.
_


14 
def
 
	g­¶y
[
T
 <: 
D©a
](

15 
g’
: => 
T
,

16 
	gÇme
: 
SŒšg
,

17 
	gdesc
: 
SŒšg
,

18 
	g»£t
: 
O±iÚ
[
T
],

19 
	gacûss
: 
RegF›ldAcûssTy³
 = 
RW
,

20 
	gwrTy³
: 
O±iÚ
[
RegF›ldWrTy³
] = 
NÚe
,

21 
	grdAùiÚ
: 
O±iÚ
[
RegF›ldRdAùiÚ
] = 
NÚe
,

22 vŞ©e: 
BoŞ—n
 = 
çl£
,

23 
	g’um”©iÚs
: 
M­
[
BigIÁ
, (
SŒšg
, SŒšg)] = M­()): (
T
, 
	gRegF›ldDesc
) = {

24 
v®
 
rdesc
 = 
RegF›ldDesc
(
Çme
, 
desc
, 
NÚe
, None,

25 
acûss
, 
wrTy³
, 
rdAùiÚ
, vŞ©e, 
»£t
.
m­
{
_
.
l™V®ue
}, 
’um”©iÚs
)

26 
v®
 
	g»g
 = 
»£t
.
m­
{
i
 => 
RegIn™
(i)}.
g‘OrEl£
(
Reg
(
g’
))

27 
	g»g
.
sugge¡Name
(
Çme
 + "_reg")

28 (
	g»g
, 
	grdesc
)

31 
def
 
async
(

32 
width
: 
IÁ
,

33 
Çme
: 
SŒšg
,

34 
desc
: 
SŒšg
,

35 
»£t
: 
IÁ
,

36 
acûss
: 
RegF›ldAcûssTy³
 = 
RW
,

37 
wrTy³
: 
O±iÚ
[
RegF›ldWrTy³
] = 
NÚe
,

38 
rdAùiÚ
: 
O±iÚ
[
RegF›ldRdAùiÚ
] = 
NÚe
,

39 vŞ©e: 
BoŞ—n
 = 
çl£
,

40 
’um”©iÚs
: 
M­
[
BigIÁ
, (
SŒšg
, SŒšg)] = M­()): (
Sim¶eRegIO
, 
	gRegF›ldDesc
) = {

41 
v®
 
rdesc
 = 
RegF›ldDesc
(
Çme
, 
desc
, 
NÚe
, None,

42 
acûss
, 
wrTy³
, 
rdAùiÚ
, vŞ©e, 
Some
(
»£t
), 
’um”©iÚs
)

43 
v®
 
	g»g
 = 
ModuË
(
Ãw
 
AsyncRe£tRegVec
(
w
 = 
width
, 
š™
 = 
»£t
))

44 
»g
.
sugge¡Name
(
Çme
 + "_reg")

45 (
»g
.
io
, 
	grdesc
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegField.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
»gm­³r


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.{
	gR—dyV®idIO
}

8 
impÜt
 
	gÜg
.
	gjsÚ4s
.
	gJsÚDSL
.
_


9 
impÜt
 
	gÜg
.
	gjsÚ4s
.
	gJsÚAST
.
JV®ue


10 
impÜt
 
	gÜg
.
	gjsÚ4s
.
	gjacksÚ
.
	gJsÚM‘hods
.{
	g´‘ty
, 
	g»nd”
}

12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gSim¶eRegIO
}

19 
objeù
 
RegF›ldAcûssTy³
 
ex‹nds
 
	gsÿÏ
.
	gEnum”©iÚ
 {

20 
ty³
 
	gRegF›ldAcûssTy³
 = 
V®ue


21 
v®
 
R
, 
	gW
, 
	gRW
 = 
V®ue


23 
impÜt
 
	gRegF›ldAcûssTy³
.
_


25 
objeù
 
RegF›ldWrTy³
 
ex‹nds
 
	gsÿÏ
.
	gEnum”©iÚ
 {

26 
ty³
 
	gRegF›ldWrTy³
 = 
V®ue


27 
v®
 
ONE_TO_CLEAR
, 
	gONE_TO_SET
, 
	gONE_TO_TOGGLE
, 
	gZERO_TO_CLEAR
,

28 
	gZERO_TO_SET
, 
	gZERO_TO_TOGGLE
, 
	gCLEAR
, 
	gSET
, 
	gMODIFY
 = 
V®ue


30 
impÜt
 
	gRegF›ldWrTy³
.
_


32 
objeù
 
RegF›ldRdAùiÚ
 
ex‹nds
 
	gsÿÏ
.
	gEnum”©iÚ
 {

33 
ty³
 
	gRegF›ldRdAùiÚ
 = 
V®ue


34 
v®
 
CLEAR
, 
	gSET
, 
	gMODIFY
 = 
V®ue


36 
impÜt
 
	gRegF›ldRdAùiÚ
.
_


38 
şass
 
RegF›ldDesc
 (

39 
Çme
: 
SŒšg
,

40 
desc
: 
SŒšg
,

41 
group
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

42 
groupDesc
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

43 
acûss
: 
RegF›ldAcûssTy³
 = RegF›ldAcûssTy³.
RW
,

44 
wrTy³
: 
O±iÚ
[
RegF›ldWrTy³
] = 
NÚe
,

45 
rdAùiÚ
: 
O±iÚ
[
RegF›ldRdAùiÚ
] = 
NÚe
,

46 vŞ©e: 
BoŞ—n
 = 
çl£
,

48 
»£t
: 
O±iÚ
[
BigIÁ
] = 
NÚe
,

49 
’um”©iÚs
: 
M­
[
BigIÁ
, (
SŒšg
, SŒšg)] = 
	$M­
()

52 
objeù
 
RegF›ldDesc
 {

53 
def
 
»£rved
: 
RegF›ldDesc
 = 
	`RegF›ldDesc
("»£rved", "", 
acûss
=
RegF›ldAcûssTy³
.
R
, 
»£t
=
	`Some
(0))

54 
	}
}

62 
objeù
 
	gRegF›ldGroup
 {

63 
def
 
­¶y
 (
Çme
: 
SŒšg
, 
desc
: 
O±iÚ
[SŒšg], 
»gs
: 
Seq
[
RegF›ld
], 
descFœ¡OÆy
: 
BoŞ—n
 = 
Œue
): Seq[RegField] = {

64 
»gs
.
zW™hIndex
.
m­
 {(
r
, 
i
) =>

65 
v®
 
gDesc
 = ià((
i
 > 0è& 
descFœ¡OÆy
è
NÚe
 
desc


66 
r
.
desc
.
m­
 { 
d
 =>

67 
r
.
cİy
(
desc
 = 
Some
(
d
.cİy(
group
 = Some(
Çme
), 
groupDesc
 = 
gDesc
)) )

68 }.
g‘OrEl£
(
r
)

73 
şass
 
RegR—dFn
 
´iv©e
(
combš©iÚ®
: 
BoŞ—n
, 
â
: (
BoŞ
, BoŞè=> (BoŞ, BoŞ, 
UIÁ
))

74 
objeù
 
	gRegR—dFn


81 
im¶ic™
 
def
 
­¶y
(
x
: (
BoŞ
, BoŞè=> (BoŞ, BoŞ, 
UIÁ
)) =

82 
Ãw
 
RegR—dFn
(
çl£
, 
x
)

83 
im¶ic™
 
def
 
­¶y
(
x
: 
Regi¡”R—dIO
[
UIÁ
]): 
RegR—dFn
 =

84 
RegR—dFn
((
iv®id
, 
Ü—dy
) => {

85 
x
.
»que¡
.
v®id
 :ğ
iv®id


86 
x
.
»¥Ú£
.
»ady
 :ğ
Ü—dy


87 (
x
.
»que¡
.
»ady
, x.
»¥Ú£
.
v®id
, x.»¥Ú£.
b™s
)

92 
im¶ic™
 
def
 
­¶y
(
x
: 
BoŞ
 => (BoŞ, 
UIÁ
)) =

93 
Ãw
 
RegR—dFn
(
Œue
, { (
_
, 
Ü—dy
) =>

94 
v®
 (
ov®id
, 
d©a
èğ
x
(
Ü—dy
)

95 (
BoŞ
(
Œue
), 
ov®id
, 
d©a
)

98 
im¶ic™
 
def
 
­¶y
(
x
: 
R—dyV®idIO
[
UIÁ
]):
RegR—dFn
 = RegR—dFn(
»ady
 => { x.»ady :ğ»ady; (x.
v®id
, x.
b™s
) })

100 
im¶ic™
 
def
 
­¶y
(
x
: 
UIÁ
):
RegR—dFn
 = RegR—dFn(
»ady
 => (
BoŞ
(
Œue
), x))

102 
im¶ic™
 
def
 
­¶y
(
x
: 
Un™
):
RegR—dFn
 = RegR—dFn(
UIÁ
(0))

105 
şass
 
RegWr™eFn
 
´iv©e
(
combš©iÚ®
: 
BoŞ—n
, 
â
: (
BoŞ
, BoŞ, 
UIÁ
) => (Bool, Bool))

106 
objeù
 
	gRegWr™eFn


113 
im¶ic™
 
def
 
­¶y
(
x
: (
BoŞ
, BoŞ, 
UIÁ
) => (Bool, Bool)) =

114 
Ãw
 
RegWr™eFn
(
çl£
, 
x
)

115 
im¶ic™
 
def
 
­¶y
(
x
: 
Regi¡”Wr™eIO
[
UIÁ
]): 
RegWr™eFn
 =

116 
RegWr™eFn
((
iv®id
, 
Ü—dy
, 
d©a
) => {

117 
x
.
»que¡
.
v®id
 :ğ
iv®id


118 
x
.
»que¡
.
b™s
 :ğ
d©a


119 
x
.
»¥Ú£
.
»ady
 :ğ
Ü—dy


120 (
x
.
»que¡
.
»ady
, x.
»¥Ú£
.
v®id
)

125 
im¶ic™
 
def
 
­¶y
(
x
: (
BoŞ
, 
UIÁ
) => Bool) =

127 
Ãw
 
RegWr™eFn
(
Œue
, { (
_
, 
Ü—dy
, 
d©a
) =>

128 (
BoŞ
(
Œue
), 
x
(
Ü—dy
, 
d©a
))

132 
im¶ic™
 
def
 
­¶y
(
x
: 
Decou¶edIO
[
UIÁ
]): 
RegWr™eFn
 = RegWr™eFn((
v®id
, 
d©a
è=> { x.v®id :ğv®id; x.
b™s
 :ğd©a; x.
»ady
 })

134 
im¶ic™
 
def
 
­¶y
(
x
: 
UIÁ
): 
RegWr™eFn
 = RegWr™eFn((
v®id
, 
d©a
è=> { 
wh’
 (v®idè{ x :ğd©¨}; 
BoŞ
(
Œue
) })

136 
im¶ic™
 
def
 
­¶y
(
x
: 
Un™
): 
RegWr™eFn
 = RegWr™eFn((
v®id
, 
d©a
è=> { 
BoŞ
(
Œue
) })

139 
şass
 
	$RegF›ld
(
width
: 
IÁ
, 
»ad
: 
RegR—dFn
, 
wr™e
: 
RegWr™eFn
, 
desc
: 
O±iÚ
[
RegF›ldDesc
])

141 
	`»quœe
 (
width
 >ğ0, 
s
"RegField width must be >= 0,‚ot $width")

143 
def
 
p–šed
 = !
»ad
.
combš©iÚ®
 || !
wr™e
.combinational

145 
def
 
»adOÆy
 = 
this
.
	`cİy
(
wr™e
 = (), 
desc
 =his.desc.
	`m­
(
_
.cİy(
acûss
 = 
RegF›ldAcûssTy³
.
R
)))

147 
def
 
	`toJsÚ
(
by‹Off£t
: 
IÁ
, 
b™Off£t
: IÁ): 
JV®ue
 = {

148 Ğ("by‹Off£t" -> 
s
"0x${byteOffset.toHexString}") ~

149 ("b™Off£t" -> 
b™Off£t
) ~

150 ("b™Width" -> 
width
) ~

151 ("Çme" -> 
desc
.
	`m­
(
_
.
Çme
)) ~

152 ("desütiÚ" -> 
desc
.
m­
{ 
d
=> ià(d.desø=ğ""è
NÚe
 
	`Some
(d.desc)}) ~

153 ("»£tV®ue" -> 
desc
.
m­
{
_
.
»£t
}) ~

154 ("group" -> 
desc
.
m­
{
_
.
group
}) ~

155 ("groupDesc" -> 
desc
.
m­
{
_
.
groupDesc
}) ~

156 ("acûssTy³" -> 
desc
.
m­
 {
d
 => d.
acûss
.
toSŒšg
}) ~

157 ("wr™eTy³" -> 
desc
.
m­
 {
d
 => d.
wrTy³
.
	`m­
(
_
.
toSŒšg
)}) ~

158 ("»adAùiÚ" -> 
desc
.
m­
 {
d
 => d.
rdAùiÚ
.
	`m­
(
_
.
toSŒšg
)}) ~

159 ("vŞ©e" -> 
desc
.
m­
 {
d
 => ià(d.vŞ©eè
	`Some
(
Œue
è
NÚe
}) ~

160 ("’um”©iÚs" -> 
desc
.
m­
 {
d
 =>

161 
	`O±iÚ
(
d
.
’um”©iÚs
.
m­
 { (
key
, (
Çme
, 
edesc
)) =>

162 (("v®ue" -> 
key
è~ ("Çme" -> 
Çme
è~ ("desütiÚ" -> 
edesc
))

163 }).
	`f‹r
(
_
.
nÚEm±y
)}) )

165 
	}
}

167 
objeù
 
	gRegF›ld


170 
ty³
 
	gM­
 = (
IÁ
, 
	gSeq
[
RegF›ld
])

172 
def
 
­¶y
(
n
: 
IÁ
è: 
RegF›ld
 =‡µlyÒ, (), (), 
Some
(
RegF›ldDesc
.
»£rved
))

174 
def
 
­¶y
(
n
: 
IÁ
, 
r
: 
RegR—dFn
, 
w
: 
RegWr™eFn
è: 
RegF›ld
 =‡µlyÒ,„, w, 
NÚe
)

175 
def
 
­¶y
(
n
: 
IÁ
, 
r
: 
RegR—dFn
, 
w
: 
RegWr™eFn
, 
desc
: 
RegF›ldDesc
è: 
RegF›ld
 =‡µlyÒ,„, w, 
Some
(desc))

176 
def
 
­¶y
(
n
: 
IÁ
, 
rw
: 
UIÁ
è: 
RegF›ld
 =‡µlyÒ,„w,„w, 
NÚe
)

177 
def
 
­¶y
(
n
: 
IÁ
, 
rw
: 
UIÁ
, 
desc
: 
RegF›ldDesc
è: 
RegF›ld
 =‡µlyÒ,„w,„w, 
Some
(desc))

178 
def
 
r
(
n
: 
IÁ
,„: 
RegR—dFn
è: 
RegF›ld
 = 
­¶y
Ò,„, (), 
NÚe
)

179 
def
 
r
(
n
: 
IÁ
,„: 
RegR—dFn
, 
desc
: 
RegF›ldDesc
è: 
RegF›ld
 = 
­¶y
Ò,„, (), 
Some
(desc.
cİy
(
acûss
 = 
RegF›ldAcûssTy³
.
R
)))

180 
def
 
w
(
n
: 
IÁ
, w: 
RegWr™eFn
è: 
RegF›ld
 = 
­¶y
Ò, (), w, 
NÚe
)

181 
def
 
w
(
n
: 
IÁ
, w: 
RegWr™eFn
, 
desc
: 
RegF›ldDesc
è: 
RegF›ld
 = 
­¶y
Ò, (), w, 
Some
(desc.
cİy
(
acûss
 = 
RegF›ldAcûssTy³
.
W
)))

186 
def
 
w1ToCË¬
(
n
: 
IÁ
, 
»g
: 
UIÁ
, 
£t
: UIÁ, 
desc
: 
O±iÚ
[
RegF›ldDesc
] = 
NÚe
): 
RegF›ld
 =

187 
RegF›ld
(
n
, 
»g
, 
RegWr™eFn
((
v®id
, 
d©a
è=> {„eg :ğ~(~»g | 
Mux
(v®id, d©a, 
UIÁ
(0))è| 
£t
; 
BoŞ
(
Œue
) }),

188 
desc
.
m­
{
_
.
cİy
(
acûss
 = 
RegF›ldAcûssTy³
.
RW
, 
wrTy³
=
Some
(
RegF›ldWrTy³
.
ONE_TO_CLEAR
), vŞ©ğ
Œue
)})

192 
def
 
rwReg
(
n
: 
IÁ
, 
bb
: 
Sim¶eRegIO
, 
desc
: 
O±iÚ
[
RegF›ldDesc
] = 
NÚe
è: 
RegF›ld
 =

193 
RegF›ld
(
n
, 
bb
.
q
, 
RegWr™eFn
((
v®id
, 
d©a
) => {

194 
bb
.
’
 :ğ
v®id


195 
bb
.
d
 :ğ
d©a


196 
BoŞ
(
Œue
)

197 }), 
desc
)

204 
def
 
by‹s
(
»g
: 
UIÁ
, 
numBy‹s
: 
IÁ
, 
desc
: 
O±iÚ
[
RegF›ldDesc
]): 
Seq
[
RegF›ld
] = {

205 
»quœe
(
»g
.
g‘Width
 * 8 >ğ
numBy‹s
, "Can't break‡ ${reg.getWidth}-bit-wide„egister into only ${numBytes} bytes.")

206 
v®
 
	gnumFuÎBy‹s
 = 
»g
.
g‘Width
/8

207 
v®
 
numP¬tŸlBy‹s
 = ià((
»g
.
g‘Width
 % 8) > 0) 1 0

208 
v®
 
numPadBy‹s
 = 
numBy‹s
 - 
numFuÎBy‹s
 - 
numP¬tŸlBy‹s


209 
v®
 
·d
 = 
»g
 | 
UIÁ
(0, 
width
 = 8*
numBy‹s
)

210 
v®
 
ŞdBy‹s
 = 
Vec
.
buÏ‹
(
numBy‹s
è{ 
i
 => 
·d
(8*(i+1)-1, 8*i) }

211 
v®
 
	gÃwBy‹s
 = 
Wœe
(
š™
 = 
ŞdBy‹s
)

212 
v®
 
v®ids
 = 
Wœe
(
š™
 = 
Vec
.
fl
(
numBy‹s
è{ 
BoŞ
(
çl£
) })

213 
wh’
 (
v®ids
.
»duû
(
_
 || _)è{ 
»g
 :ğ
ÃwBy‹s
.
asUIÁ
 }

215 
def
 
wrFn
(
i
: 
IÁ
): 
RegWr™eFn
 = RegWr™eFn((
v®id
, 
d©a
) => {

216 
v®ids
(
i
è:ğ
v®id


217 
wh’
 (
v®id
è{
ÃwBy‹s
(
i
è:ğ
d©a
}

218 
BoŞ
(
Œue
)

221 
v®
 
fuÎBy‹s
 = 
Seq
.
buÏ‹
(
numFuÎBy‹s
è{ 
i
 =>

222 
v®
 
ÃwDesc
 = 
desc
.
m­
 {
d
 => d.
cİy
(
Çme
 = d.Çm+ 
s
"_$i")}

223 
RegF›ld
(8, 
ŞdBy‹s
(
i
), 
wrFn
(i), 
ÃwDesc
)}

224 
v®
 
	g·¹ŸlBy‹s
 = ià(
numP¬tŸlBy‹s
 > 0) {

225 
v®
 
ÃwDesc
 = 
desc
.
m­
 {
d
 => d.
cİy
(
Çme
 = d.Çm+ 
s
"_$numFullBytes")}

226 
Seq
(
RegF›ld
(
»g
.
g‘Width
 % 8, 
ŞdBy‹s
(
numFuÎBy‹s
), 
wrFn
ÒumFuÎBy‹s), 
ÃwDesc
),

227 
RegF›ld
(8 - (
»g
.
g‘Width
 % 8)))

228 } 
N


229 
v®
 
	g·dBy‹s
 = 
Seq
.
fl
(
numPadBy‹s
){
RegF›ld
(8)}

230 
fuÎBy‹s
 ++ 
·¹ŸlBy‹s
 ++ 
·dBy‹s


233 
def
 
by‹s
(
»g
: 
UIÁ
, 
desc
: 
O±iÚ
[
RegF›ldDesc
]): 
Seq
[
RegF›ld
] = {

234 
v®
 
width
 = 
»g
.
g‘Width


235 
»quœe
 (
width
 % 8 =ğ0, 
s
"RegField.bytes must be called on byte-sized„eg,‚ot ${width} bits")

236 
by‹s
(
»g
, 
width
/8, 
desc
)

239 
def
 
by‹s
(
»g
: 
UIÁ
, 
numBy‹s
: 
IÁ
): 
Seq
[
RegF›ld
] = by‹sÔeg,‚umBy‹s, 
NÚe
)

240 
def
 
by‹s
(
»g
: 
UIÁ
): 
Seq
[
RegF›ld
] = by‹sÔeg, 
NÚe
)

244 
Œa™
 
	gHasRegM­


246 
def
 
»gm­
(
m­pšg
: 
RegF›ld
.
M­
*): 
Un™


247 
v®
 
š‹¼u±s
: 
Vec
[
BoŞ
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegMapper.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
»gm­³r


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gG’”icP¬am‘”izedBundË
, 
	gReduûOth”s
, 
	gMuxSeq
}

9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


10 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.{
	gSourûInfo
, 
	gSourûLše
}

14 
şass
 
	$RegM­³rP¬ams
(
šdexB™s
: 
IÁ
, 
maskB™s
: IÁ, 
exŒaB™s
: Int)

16 şas 
	cRegM­³rIÅut
(
·¿ms
: 
RegM­³rP¬ams
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

18 
v®
 
»ad
 = 
	$BoŞ
()

19 
v®
 
šdex
 = 
	$UIÁ
(
width
 = 
·¿ms
.
šdexB™s
)

20 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
maskB™s
*8)

21 
v®
 
mask
 = 
	$UIÁ
(
width
 = 
·¿ms
.
maskB™s
)

22 
v®
 
exŒa
 = 
	`UIÁ
(
width
 = 
·¿ms
.
exŒaB™s
)

25 şas 
	cRegM­³rOuut
(
·¿ms
: 
RegM­³rP¬ams
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

27 
v®
 
»ad
 = 
	$BoŞ
()

28 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
maskB™s
*8)

29 
v®
 
exŒa
 = 
	`UIÁ
(
width
 = 
·¿ms
.
exŒaB™s
)

32 
objeù
 
RegM­³r


35 
def
 
	`­¶y
(
by‹s
: 
IÁ
, 
cÚcu¼’cy
: IÁ, 
undefZ”o
: 
BoŞ—n
, 
š
: 
Decou¶edIO
[
RegM­³rIÅut
], 
m­pšg
: 
RegF›ld
.
M­
*)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) = {

37 
v®
 
by‹m­
 = 
m­pšg
.
toLi¡
.
m­
 { (
off£t
, 
f›lds
è=> (off£t, f›lds.
	`f‹r
(
_
.
width
 != 0)) }

40 
by‹m­
.
fÜ—ch
 { 
by‹
 => 
	`»quœe
 (by‹.
_1
 >= 0) }

43 
v®
 
b™m­
 = 
by‹m­
.
m­
 { (
by‹
, 
f›lds
) =>

44 
v®
 
b™s
 = 
f›lds
.
	`sÿnLeá
(
by‹
 * 8)(
_
 + _.
width
).
š™


45 
b™s
 
z
 
f›lds


46 }.
æ©‹n
.
	`sÜtBy
(
_
.
_1
)

49 (
b™m­
.
š™
 
z
 b™m­.

è
fÜ—ch
 { ((
lb™
, 
lf›ld
), (
rb™
, 
rf›ld
)) =>

50 
	`»quœe
 (
lb™
 + 
lf›ld
.
width
 <ğ
rb™
, 
s
"Register map overlaps‡t bit ${rbit}.")

54 
v®
 
wÜdm­
 = 
b™m­
.
	`groupBy
(
_
.
_1
 / (8*
by‹s
))

57 
v®
 
šP¬ams
 = 
š
.
b™s
.
·¿ms


58 
v®
 
šB™s
 = 
šP¬ams
.
šdexB™s


59 
	`as£¹
 (
wÜdm­
.
keyS‘
.
max
 < (1 << 
šB™s
), "Register map does‚ot fit in device")

61 
v®
 
out
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`RegM­³rOuut
(
šP¬ams
)))

62 
v®
 
äÚt
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`RegM­³rIÅut
(
šP¬ams
)))

63 
äÚt
.
b™s
 :ğ
š
.bits

66 
v®
 
p–šed
 = 
wÜdm­
.
v®ues
.
	`m­
(
_
.m­(_.
_2
.p–šed)).
æ©‹n
.
	`»duû
(_ || _)

67 
v®
 
d•th
 = 
cÚcu¼’cy


68 
	`»quœe
 (
d•th
 >= 0)

69 
	`»quœe
 (!
p–šed
 || 
d•th
 > 0, "Register-based device with„equest/response handshaking‚eeds concurrency > 0")

70 
v®
 
back
 = ià(
d•th
 > 0è
	`Queue
(
äÚt
, depth) front

73 
def
 
	`toB™s
(
x
: 
IÁ
, 

: 
Li¡
[
BoŞ—n
] = Li¡.
em±y
): List[Boolean] =

74 ià(
x
 =ğ0è

.
»v”£
 
	`toB™s
(x >> 1, ((x & 1) == 1) ::ail)

75 
def
 
	`ofB™s
(
b™s
: 
Li¡
[
BoŞ—n
]èğb™s.
	`fŞdRight
(0){ (
x
,
y
) => (if (x) 1 0) | y << 1 }

78 
v®
 
mask
 = 
	`Add»ssDecod”
(
wÜdm­
.
keyS‘
.
toLi¡
)

79 
v®
 
maskM©ch
 = ~
	`UIÁ
(
mask
, 
width
 = 
šB™s
)

80 
v®
 
maskF‹r
 = 
	`toB™s
(
mask
)

81 
v®
 
maskB™s
 = 
maskF‹r
.
	`f‹r
(
x
 => x).
size


84 
v®
 
»gSize
 = 1 << 
maskB™s


85 
def
 
	`»gIndexI
(
x
: 
IÁ
èğ
	`ofB™s
((
maskF‹r
 
z
 
	`toB™s
(x)).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
))

86 
def
 
	`»gIndexU
(
x
: 
UIÁ
èğià(
maskB™s
 =ğ0è
	`UIÁ
(0) 

87 
	`C©
((
maskF‹r
 
z
 
x
.
toBoŞs
).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
).
»v”£
)

89 
v®
 
fšdex
 = 
äÚt
.
b™s
.
šdex
 & 
maskM©ch


90 
v®
 
bšdex
 = 
back
 .
b™s
.
šdex
 & 
maskM©ch


93 
v®
 
iRightReg
 = 
A¼ay
.
	`fl
(
»gSize
è{ 
	`BoŞ
(
Œue
) }

94 
v®
 
oRightReg
 = 
A¼ay
.
	`fl
(
»gSize
è{ 
	`BoŞ
(
Œue
) }

97 
v®
 
æ©
 = 
wÜdm­
.
toLi¡
.
m­
 { (
wÜd
, 
f›lds
) =>

98 
v®
 
šdex
 = 
	`»gIndexI
(
wÜd
)

99 ià(
undefZ”o
) {

100 
v®
 
ušt
 = 
	`UIÁ
(
wÜd
 & ~
mask
, 
width
 = 
šB™s
)

101 
	`iRightReg
(
šdex
èğ
fšdex
 ==ğ
ušt


102 
	`oRightReg
(
šdex
èğ
bšdex
 ==ğ
ušt


105 
f›lds
 
fÜ—ch
 { (
b™
, 
f›ld
) =>

106 
v®
 
off
 = 
b™
 - 8*
by‹s
*
wÜd


108 
	`»quœe
 (
off
 + 
f›ld
.
width
 <ğ
by‹s
 * 8, 
s
"Field‡t word ${word}*(${bytes}B) has bits [${off}, ${off+field.width}), whichƒxceeds word†imit.")

111 
f›lds
.
m­
 { (
b™
, 
f›ld
è=> (
šdex
, b™-8*
by‹s
*
wÜd
, field) }

112 }.
æ©‹n


115 
v®
 
riv®id
 = 
	`Wœe
(
	`Vec
(
æ©
.
size
, 
	`BoŞ
()))

116 
v®
 
wiv®id
 = 
	`Wœe
(
	`Vec
(
æ©
.
size
, 
	`BoŞ
()))

117 
v®
 
rÜ—dy
 = 
	`Wœe
(
	`Vec
(
æ©
.
size
, 
	`BoŞ
()))

118 
v®
 
wÜ—dy
 = 
	`Wœe
(
	`Vec
(
æ©
.
size
, 
	`BoŞ
()))

121 
v®
 
rifœe
 = 
A¼ay
.
	`fl
(
»gSize
è{ 
N
:
Li¡
[(
BoŞ
, Bool)] }

122 
v®
 
wifœe
 = 
A¼ay
.
	`fl
(
»gSize
è{ 
N
:
Li¡
[(
BoŞ
, Bool)] }

123 
v®
 
rofœe
 = 
A¼ay
.
	`fl
(
»gSize
è{ 
N
:
Li¡
[(
BoŞ
, Bool)] }

124 
v®
 
wofœe
 = 
A¼ay
.
	`fl
(
»gSize
è{ 
N
:
Li¡
[(
BoŞ
, Bool)] }

127 
v®
 
d©aOut
 = 
A¼ay
.
	`fl
(
»gSize
è{ 
	`UIÁ
(0) }

130 
v®
 
äÚtMask
 = 
	`FlIÁ”Ëaved
(8, 
äÚt
.
b™s
.
mask
)

131 
v®
 
backMask
 = 
	`FlIÁ”Ëaved
(8, 
back
 .
b™s
.
mask
)

134 
i
 <- 0 
uÁ
 
æ©
.
size
) {

135 
	`v®
 (
»g
, 
low
, 
f›ld
èğ
	`æ©
(
i
)

136 
v®
 
high
 = 
low
 + 
f›ld
.
width
 - 1

138 
	`»quœe
 (
high
 < 8*
by‹s
)

139 
v®
 
rimask
 = 
	`äÚtMask
(
high
, 
low
).
	`ÜR
()

140 
v®
 
wimask
 = 
	`äÚtMask
(
high
, 
low
).
	`ªdR
()

141 
v®
 
romask
 = 
	`backMask
(
high
, 
low
).
	`ÜR
()

142 
v®
 
womask
 = 
	`backMask
(
high
, 
low
).
	`ªdR
()

143 
v®
 
d©a
 = ià(
f›ld
.
wr™e
.
combš©iÚ®
è
back
.
b™s
.d©¨
äÚt
.bits.data

144 
v®
 
f_riv®id
 = 
	`riv®id
(
i
è&& 
rimask


145 
v®
 
f_rÜ—dy
 = 
	`rÜ—dy
(
i
è&& 
romask


146 
v®
 
f_wiv®id
 = 
	`wiv®id
(
i
è&& 
wimask


147 
v®
 
f_wÜ—dy
 = 
	`wÜ—dy
(
i
è&& 
womask


148 
	`v®
 (
f_rœ—dy
, 
f_rov®id
, 
f_d©a
èğ
f›ld
.
»ad
.
	`â
(
f_riv®id
, 
f_rÜ—dy
)

149 
	`v®
 (
f_wœ—dy
, 
f_wov®id
èğ
f›ld
.
wr™e
.
	`â
(
f_wiv®id
, 
f_wÜ—dy
, 
	`d©a
(
high
, 
low
))

152 
v®
 
âame
 = 
f›ld
.
desc
.
m­
{
_
.
Çme
}.
	`g‘OrEl£
("")

153 
v®
 
fdesc
 = 
f›ld
.
desc
.
m­
{
_
.desø+ ":"}.
	`g‘OrEl£
("")

155 
	`cov”
(
f_riv®id
 && 
f_rœ—dy
, 
âame
 + "_Reg_»ad_¡¬t", 
fdesc
 + " RegField Read Request Initiate")

156 
	`cov”
(
f_rov®id
 && 
f_rÜ—dy
, 
âame
 + "_Reg_»ad_out", 
fdesc
 + " RegField Read Request Complete")

157 
	`cov”
(
f_wiv®id
 && 
f_wœ—dy
, 
âame
 + "_Reg_wr™e_¡¬t", 
fdesc
 + " RegField Write Request Initiate")

158 
	`cov”
(
f_wov®id
 && 
f_wÜ—dy
, 
âame
 + "_Reg_wr™e_out", 
fdesc
 + " RegField Write Request Complete")

160 
def
 
	`l™OR
(
x
: 
BoŞ
, 
y
: BoŞèğià(x.
isL™
 && x.
l™V®ue
 =ğ1è
	`BoŞ
(
Œue
) x || y

162 
	`rifœe
(
»g
èğ(
	`riv®id
(
i
), 
	`l™OR
(
f_rœ—dy
, !
rimask
)) +:„ifire(reg)

163 
	`wifœe
(
»g
èğ(
	`wiv®id
(
i
), 
	`l™OR
(
f_wœ—dy
, !
wimask
)) +: wifire(reg)

164 
	`rofœe
(
»g
èğ(
	`rÜ—dy
(
i
), 
	`l™OR
(
f_rov®id
, !
romask
)) +:„ofire(reg)

165 
	`wofœe
(
»g
èğ(
	`wÜ—dy
(
i
), 
	`l™OR
(
f_wov®id
, !
womask
)) +: wofire(reg)

168 
v®
 
´•’d
 = ià(
low
 =ğ0è{ 
f_d©a
 } { 
	`C©
(f_d©a, 
	`d©aOut
(
»g
è| 
	`UIÁ
(0, 
width
=low)) }

169 
	`d©aOut
(
»g
èğ(
´•’d
 | 
	`UIÁ
(0, 
width
=
high
+1))(high, 0)

173 
v®
 
išdex
 = 
	`»gIndexU
(
äÚt
.
b™s
.
šdex
)

174 
v®
 
ošdex
 = 
	`»gIndexU
(
back
 .
b™s
.
šdex
)

175 
v®
 
äÚtS–
 = 
	`UIÁToOH
(
išdex
).
toBoŞs


176 
v®
 
backS–
 = 
	`UIÁToOH
(
ošdex
).
toBoŞs


179 
def
 
	`mux
(
šdex
: 
UIÁ
, 
v®id
: 
BoŞ
, 
£Ëù
: 
Seq
[BoŞ], 
gu¬d
: Seq[BoŞ], 
æow
: Seq[Seq[(Bool, Bool)]]): Bool =

180 
	`MuxSeq
(
šdex
, 
	`BoŞ
(
Œue
), ((
£Ëù
 
z
 
gu¬d
èz 
æow
).
m­
 { ((
s
, 
g
), 
f
) =>

181 
v®
 
out
 = 
	`Wœe
(
	`BoŞ
())

182 
	`ReduûOth”s
((
out
, 
v®id
 && 
s
 && 
g
è+: 
f
)

183 
out
 || !
g


187 
v®
 
rifœeMux
 = 
	`mux
(
išdex
, 
š
.
v®id
 && 
äÚt
.
»ady
 && frÚt.
b™s
.
»ad
, 
äÚtS–
, 
iRightReg
, 
rifœe
)

188 
v®
 
wifœeMux
 = 
	`mux
(
išdex
, 
š
.
v®id
 && 
äÚt
.
»ady
 && !äÚt.
b™s
.
»ad
, 
äÚtS–
, 
iRightReg
, 
wifœe
)

189 
v®
 
rofœeMux
 = 
	`mux
(
ošdex
, 
back
.
v®id
 && 
out
.
»ady
 && back .
b™s
.
»ad
, 
backS–
, 
oRightReg
, 
rofœe
)

190 
v®
 
wofœeMux
 = 
	`mux
(
ošdex
, 
back
.
v®id
 && 
out
.
»ady
 && !back .
b™s
.
»ad
, 
backS–
, 
oRightReg
, 
wofœe
)

192 
v®
 
œ—dy
 = 
	`Mux
(
äÚt
.
b™s
.
»ad
, 
rifœeMux
, 
wifœeMux
)

193 
v®
 
Ü—dy
 = 
	`Mux
(
back
 .
b™s
.
»ad
, 
rofœeMux
, 
wofœeMux
)

196 
š
.
»ady
 :ğ
äÚt
.»ady && 
œ—dy


197 
äÚt
.
v®id
 :ğ
š
.v®id && 
œ—dy


198 
back
.
»ady
 :ğ
out
.»ady && 
Ü—dy


199 
out
.
v®id
 :ğ
back
.v®id && 
Ü—dy


201 
out
.
b™s
.
»ad
 :ğ
back
.bits.read

202 
out
.
b™s
.
d©a
 :ğ
	`Mux
(
	`MuxSeq
(
ošdex
, 
	`BoŞ
(
Œue
), 
oRightReg
),

203 
	`MuxSeq
(
ošdex
, 
	`UIÁ
(0), 
d©aOut
),

204 
	`UIÁ
(0))

205 
out
.
b™s
.
exŒa
 :ğ
back
.bits.extra

207 
out


209 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterCrossing.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
»gm­³r


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.{
	gI¼evoÿbË
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gAsyncQueue
,
	gAsyncQueueP¬ams
,
	gAsyncRe£tRegVec
}

11 şas 
	cBusyRegi¡”Crossšg
 
ex‹nds
 
	mModuË
 {

12 
v®
 
	mio
 = 
Ãw
 
BundË
 {

13 
v®
 
by·ss
 = 
BoŞ
(
INPUT
)

14 
v®
 
ma¡”_»que¡_v®id
 = 
BoŞ
(
INPUT
)

15 
v®
 
ma¡”_»que¡_»ady
 = 
BoŞ
(
OUTPUT
)

16 
v®
 
ma¡”_»¥Ú£_v®id
 = 
BoŞ
(
OUTPUT
)

17 
v®
 
ma¡”_»¥Ú£_»ady
 = 
BoŞ
(
INPUT
)

18 
v®
 
üossšg_»que¡_v®id
 = 
BoŞ
(
OUTPUT
)

19 
v®
 
üossšg_»que¡_»ady
 = 
BoŞ
(
INPUT
)

23 
v®
 
	gbusy
 = 
RegIn™
(
	$BoŞ
(
çl£
))

24 
v®
 
by·ss
 = 
	`Reg
(
	$BoŞ
())

26 
	`wh’
 (
io
.
üossšg_»que¡_»ady
 || 
	$Mux
(
busy
, 
by·ss
, 
io
.bypass)) {

27 
busy
 :ğ
	`Mux
(busy, !
io
.
ma¡”_»¥Ú£_»ady
, io.
ma¡”_»que¡_v®id
)

28 
	}
}

30 
	$wh’
 (
io
.
ma¡”_»que¡_v®id
 && io.
ma¡”_»que¡_»ady
) {

31 
by·ss
 :ğ
io
.bypass

32 
	}
}

34 
io
.
üossšg_»que¡_v®id
 :ğio.
ma¡”_»que¡_v®id
 && !io.
by·ss
 && !
busy


35 
io
.
ma¡”_»que¡_»ady
 :ğ(io.
by·ss
 || io.
üossšg_»que¡_»ady
è&& !
busy


36 
io
.
ma¡”_»¥Ú£_v®id
 :ğ(
by·ss
 || io.
üossšg_»que¡_»ady
è&& 
busy


39 şas 
	cRegi¡”CrossšgAs£¹iÚ
 
ex‹nds
 
ModuË
 {

40 
v®
 
io
 = 
Ãw
 
BundË
 {

41 
v®
 
ma¡”_by·ss
 = 
BoŞ
(
INPUT
)

42 
v®
 
¦ave_»£t
 = 
BoŞ
(
INPUT
)

45 
v®
 
up
 = 
RegIn™
(
	$BoŞ
(
çl£
))

46 
up
 :ğ!
io
.
¦ave_»£t


48 
	`as£¹
 (
io
.
ma¡”_by·ss
 || !
up
 || !io.
¦ave_»£t
)

49 
	}
}

52 
şass
 
Regi¡”Wr™eIO
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË
 {

53 
v®
 
»que¡
 = 
Decou¶ed
(
g’
).
æ


54 
v®
 
»¥Ú£
 = 
I¼evoÿbË
(
BoŞ
())

56 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
Regi¡”Wr™eIO
(
g’
).
asIn¡ªûOf
[
this
.
ty³
]

79 
şass
 
Regi¡”Wr™eCrossšgIO
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË
 {

81 
v®
 
ma¡”_şock
 = 
Clock
(
INPUT
)

82 
v®
 
ma¡”_»£t
 = 
BoŞ
(
INPUT
)

83 
v®
 
ma¡”_pÜt
 = 
Ãw
 
Regi¡”Wr™eIO
(
g’
)

85 
v®
 
ma¡”_by·ss
 = 
BoŞ
(
INPUT
)

87 
v®
 
¦ave_şock
 = 
Clock
(
INPUT
)

88 
v®
 
¦ave_»£t
 = 
BoŞ
(
INPUT
)

89 
v®
 
¦ave_»gi¡”
 = 
g’
.
asOuut


90 
v®
 
¦ave_v®id
 = 
BoŞ
(
OUTPUT
)

93 
şass
 
Regi¡”Wr™eCrossšg
[
T
 <: 
D©a
](
g’
: T, 
	gsync
: 
IÁ
 = 3è
ex‹nds
 
ModuË
 {

94 
v®
 
io
 = 
Ãw
 
Regi¡”Wr™eCrossšgIO
(
g’
)

96 
v®
 
cÚŒŞ
 = 
ModuË
(
Ãw
 
BusyRegi¡”Crossšg
)

97 
v®
 
üossšg
 = 
ModuË
(
Ãw
 
AsyncQueue
(
g’
, 
AsyncQueueP¬ams
.
sšgËtÚ
(
sync
)))

99 
	gcÚŒŞ
.
	gşock
 :ğ
io
.
ma¡”_şock


100 
cÚŒŞ
.
»£t
 :ğ
io
.
ma¡”_»£t


101 
üossšg
.
io
.
’q_şock
 :ğio.
ma¡”_şock


102 
üossšg
.
io
.
’q_»£t
 :ğio.
ma¡”_»£t


103 
üossšg
.
io
.
deq_şock
 :ğio.
¦ave_şock


104 
üossšg
.
io
.
deq_»£t
 :ğio.
¦ave_»£t


106 
cÚŒŞ
.
io
.
by·ss
 :ğio.
ma¡”_by·ss


107 
cÚŒŞ
.
io
.
ma¡”_»que¡_v®id
 :ğio.
ma¡”_pÜt
.
»que¡
.
v®id


108 
cÚŒŞ
.
io
.
ma¡”_»¥Ú£_»ady
 :ğio.
ma¡”_pÜt
.
»¥Ú£
.
»ady


109 
io
.
ma¡”_pÜt
.
»que¡
.
»ady
 :ğ
cÚŒŞ
.io.
ma¡”_»que¡_»ady


110 
io
.
ma¡”_pÜt
.
»¥Ú£
.
v®id
 :ğ
cÚŒŞ
.io.
ma¡”_»¥Ú£_v®id


112 
cÚŒŞ
.
io
.
üossšg_»que¡_»ady
 :ğ
üossšg
.io.
’q
.
»ady


113 
üossšg
.
io
.
’q
.
v®id
 :ğ
cÚŒŞ
.io.
üossšg_»que¡_v®id


114 
üossšg
.
io
.
’q
.
b™s
 :ğio.
ma¡”_pÜt
.
»que¡
.bits

116 
üossšg
.
io
.
deq
.
»ady
 :ğ
BoŞ
(
Œue
)

117 
io
.
¦ave_v®id
 :ğ
üossšg
.io.
deq
.
v®id


118 
io
.
¦ave_»gi¡”
 :ğ
üossšg
.io.
deq
.
b™s


120 
v®
 
as£¹iÚ
 = 
ModuË
(
Ãw
 
Regi¡”CrossšgAs£¹iÚ
)

121 
as£¹iÚ
.
şock
 :ğ
io
.
ma¡”_şock


122 
as£¹iÚ
.
»£t
 :ğ
io
.
ma¡”_»£t


123 
as£¹iÚ
.
io
.
ma¡”_by·ss
 := io.master_bypass

124 
as£¹iÚ
.
io
.
¦ave_»£t
 := io.slave_reset

128 
şass
 
Regi¡”R—dIO
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË
 {

129 
v®
 
»que¡
 = 
Decou¶ed
(
BoŞ
()).
æ


130 
v®
 
»¥Ú£
 = 
I¼evoÿbË
(
g’
)

132 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
Regi¡”R—dIO
(
g’
).
asIn¡ªûOf
[
this
.
ty³
]

135 
şass
 
Regi¡”R—dCrossšgIO
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË
 {

137 
v®
 
ma¡”_şock
 = 
Clock
(
INPUT
)

138 
v®
 
ma¡”_»£t
 = 
BoŞ
(
INPUT
)

139 
v®
 
ma¡”_pÜt
 = 
Ãw
 
Regi¡”R—dIO
(
g’
)

141 
v®
 
ma¡”_by·ss
 = 
BoŞ
(
INPUT
)

143 
v®
 
¦ave_şock
 = 
Clock
(
INPUT
)

144 
v®
 
¦ave_»£t
 = 
BoŞ
(
INPUT
)

145 
v®
 
¦ave_»gi¡”
 = 
g’
.
asIÅut


148 
şass
 
Regi¡”R—dCrossšg
[
T
 <: 
D©a
](
g’
: T, 
	gsync
: 
IÁ
 = 3è
ex‹nds
 
ModuË
 {

149 
v®
 
io
 = 
Ãw
 
Regi¡”R—dCrossšgIO
(
g’
)

151 
v®
 
cÚŒŞ
 = 
ModuË
(
Ãw
 
BusyRegi¡”Crossšg
)

152 
v®
 
üossšg
 = 
ModuË
(
Ãw
 
AsyncQueue
(
g’
, 
AsyncQueueP¬ams
.
sšgËtÚ
(
sync
)))

154 
	gcÚŒŞ
.
	gşock
 :ğ
io
.
ma¡”_şock


155 
cÚŒŞ
.
»£t
 :ğ
io
.
ma¡”_»£t


156 
üossšg
.
io
.
deq_şock
 :ğio.
ma¡”_şock


157 
üossšg
.
io
.
deq_»£t
 :ğio.
ma¡”_»£t


158 
üossšg
.
io
.
’q_şock
 :ğio.
¦ave_şock


159 
üossšg
.
io
.
’q_»£t
 :ğio.
¦ave_»£t


161 
cÚŒŞ
.
io
.
by·ss
 :ğio.
ma¡”_by·ss


162 
cÚŒŞ
.
io
.
ma¡”_»que¡_v®id
 :ğio.
ma¡”_pÜt
.
»que¡
.
v®id


163 
cÚŒŞ
.
io
.
ma¡”_»¥Ú£_»ady
 :ğio.
ma¡”_pÜt
.
»¥Ú£
.
»ady


164 
io
.
ma¡”_pÜt
.
»que¡
.
»ady
 :ğ
cÚŒŞ
.io.
ma¡”_»que¡_»ady


165 
io
.
ma¡”_pÜt
.
»¥Ú£
.
v®id
 :ğ
cÚŒŞ
.io.
ma¡”_»¥Ú£_v®id


167 
cÚŒŞ
.
io
.
üossšg_»que¡_»ady
 :ğ
üossšg
.io.
deq
.
v®id


168 
üossšg
.
io
.
deq
.
»ady
 :ğ
cÚŒŞ
.io.
üossšg_»que¡_v®id


169 
io
.
ma¡”_pÜt
.
»¥Ú£
.
b™s
 :ğ
üossšg
.io.
deq
.bits

171 
üossšg
.
io
.
’q
.
v®id
 :ğ
BoŞ
(
Œue
)

172 
üossšg
.
io
.
’q
.
b™s
 :ğio.
¦ave_»gi¡”


174 
v®
 
as£¹iÚ
 = 
ModuË
(
Ãw
 
Regi¡”CrossšgAs£¹iÚ
)

175 
as£¹iÚ
.
şock
 :ğ
io
.
ma¡”_şock


176 
as£¹iÚ
.
»£t
 :ğ
io
.
ma¡”_»£t


177 
as£¹iÚ
.
io
.
ma¡”_by·ss
 := io.master_bypass

178 
as£¹iÚ
.
io
.
¦ave_»£t
 := io.slave_reset

190 
objeù
 
AsyncRWSÏveRegF›ld
 {

192 
def
 
­¶y
(

193 
ma¡”_şock
: 
Clock
,

194 
ma¡”_»£t
: 
BoŞ
,

195 
¦ave_şock
: 
Clock
,

196 
¦ave_»£t
: 
BoŞ
,

197 
width
: 
IÁ
,

198 
š™
: 
IÁ
,

199 
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

200 
ma¡”_by·ss
: 
BoŞ
 = BoŞ(
Œue
),

201 
desc
: 
O±iÚ
[
RegF›ldDesc
] = 
NÚe


202 ): (
UIÁ
, 
	gRegF›ld
) = {

204 
v®
 
async_¦ave_»g
 = 
ModuË
(
Ãw
 
AsyncRe£tRegVec
(
width
, 
š™
))

205 
	gÇme
.
fÜ—ch
(
async_¦ave_»g
.
sugge¡Name
(
_
))

206 
	gasync_¦ave_»g
.
	g»£t
 :ğ
¦ave_»£t


207 
async_¦ave_»g
.
şock
 :ğ
¦ave_şock


209 
v®
 
wr_üossšg
 = 
ModuË
 (
Ãw
 
Regi¡”Wr™eCrossšg
(
UIÁ
(
width
 = width)))

210 
Çme
.
fÜ—ch
(
n
 => 
wr_üossšg
.
sugge¡Name
(
s
"${n}_wcrossing"))

212 
wr_üossšg
.
io
.
ma¡”_şock
 := master_clock

213 
wr_üossšg
.
io
.
ma¡”_»£t
 := master_reset

214 
wr_üossšg
.
io
.
ma¡”_by·ss
 := master_bypass

215 
wr_üossšg
.
io
.
¦ave_şock
 := slave_clock

216 
wr_üossšg
.
io
.
¦ave_»£t
 := slave_reset

218 
async_¦ave_»g
.
io
.
’
 :ğ
wr_üossšg
.io.
¦ave_v®id


219 
async_¦ave_»g
.
io
.
d
 :ğ
wr_üossšg
.io.
¦ave_»gi¡”


221 
v®
 
rd_üossšg
 = 
ModuË
 (
Ãw
 
Regi¡”R—dCrossšg
(
UIÁ
(
width
 = width )))

222 
Çme
.
fÜ—ch
(
n
 => 
rd_üossšg
.
sugge¡Name
(
s
"${n}_rcrossing"))

224 
rd_üossšg
.
io
.
ma¡”_şock
 := master_clock

225 
rd_üossšg
.
io
.
ma¡”_»£t
 := master_reset

226 
rd_üossšg
.
io
.
ma¡”_by·ss
 := master_bypass

227 
rd_üossšg
.
io
.
¦ave_şock
 := slave_clock

228 
rd_üossšg
.
io
.
¦ave_»£t
 := slave_reset

230 
rd_üossšg
.
io
.
¦ave_»gi¡”
 :ğ
async_¦ave_»g
.io.
q


232 (
async_¦ave_»g
.
io
.
q
, 
RegF›ld
(
width
, 
rd_üossšg
.io.
ma¡”_pÜt
, 
wr_üossšg
.io.ma¡”_pÜt, 
desc
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterRouter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
»gm­³r


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


11 
şass
 
	$Regi¡”Rou‹rP¬ams
(

12 
Çme
: 
SŒšg
,

13 
com·t
: 
Seq
[
SŒšg
],

14 
ba£
: 
BigIÁ
,

15 
size
: 
BigIÁ
 = 4096,

16 
cÚcu¼’cy
: 
IÁ
 = 0,

17 
b—tBy‹s
: 
IÁ
 = 4,

18 
undefZ”o
: 
BoŞ—n
 = 
Œue
,

19 
execubË
: 
BoŞ—n
 = 
çl£
)

21 
ab¡¿ù
 
şass
 
Regi¡”Rou‹r
[
T
 <: 
D©a
](
devP¬ams
: 
Regi¡”Rou‹rP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
)

22 
ex‹nds
 
LazyModuË


23 
w™h
 
HasClockDomašCrossšg
 {

25 
	`»quœe
 (
	`isPow2
(
devP¬ams
.
size
))

26 
v®
 
add»ss
 = 
	`Seq
(
	`Add»ssS‘
(
devP¬ams
.
ba£
, devP¬ams.
size
-1))

27 
v®
 
cÚcu¼’cy
 = 
devP¬ams
.concurrency

28 
v®
 
b—tBy‹s
 = 
devP¬ams
.beatBytes

29 
v®
 
undefZ”o
 = 
devP¬ams
.undefZero

30 
v®
 
execubË
 = 
devP¬ams
.executable

31 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
(
devP¬ams
.
Çme
, devP¬ams.
com·t
) {

32 
ov”ride
 
def
 
	`desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

33 
v®
 
	`DesütiÚ
(
Çme
, 
m­pšg
èğ
su³r
.
	`desüibe
(
»sourûs
)

34 
	`DesütiÚ
(
Çme
, 
m­pšg
 ++ 
	`exŒaResourûs
(
»sourûs
))

38 
def
 
	`exŒaResourûs
(
»sourûs
: 
ResourûBšdšgs
èğ
M­
[
SŒšg
, 
Seq
[
ResourûV®ue
]]()

40 
´Ùeùed
 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*): 
Un™


41 
	}
}

43 
ab¡¿ù
 
şass
 
IORegi¡”Rou‹r
[
T
 <: 
D©a
](
devP¬ams
: 
Regi¡”Rou‹rP¬ams
, 
	gpÜtBundË
: => T)(
im¶ic™
 
p
: 
P¬am‘”s
)

44 
ex‹nds
 
	$Regi¡”Rou‹r
(
devP¬ams
) {

45 
v®
 
ioNode
 = 
	`BundËBridgeSourû
((è=> 
pÜtBundË
.
şÚeTy³
)

46 
v®
 
pÜt
 = 
InModuËBody
 { 
ioNode
.
bundË
 }

47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ALU.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
CÜeModuË


10 
objeù
 
	gALU


12 
v®
 
	gSZ_ALU_FN
 = 4

13 
def
 
FN_X
 = 
B™P©
("b????")

14 
def
 
FN_ADD
 = 
UIÁ
(0)

15 
def
 
FN_SL
 = 
UIÁ
(1)

16 
def
 
FN_SEQ
 = 
UIÁ
(2)

17 
def
 
FN_SNE
 = 
UIÁ
(3)

18 
def
 
FN_XOR
 = 
UIÁ
(4)

19 
def
 
FN_SR
 = 
UIÁ
(5)

20 
def
 
FN_OR
 = 
UIÁ
(6)

21 
def
 
FN_AND
 = 
UIÁ
(7)

22 
def
 
FN_SUB
 = 
UIÁ
(10)

23 
def
 
FN_SRA
 = 
UIÁ
(11)

24 
def
 
FN_SLT
 = 
UIÁ
(12)

25 
def
 
FN_SGE
 = 
UIÁ
(13)

26 
def
 
FN_SLTU
 = 
UIÁ
(14)

27 
def
 
FN_SGEU
 = 
UIÁ
(15)

29 
def
 
FN_DIV
 = 
FN_XOR


30 
def
 
FN_DIVU
 = 
FN_SR


31 
def
 
FN_REM
 = 
FN_OR


32 
def
 
FN_REMU
 = 
FN_AND


34 
def
 
FN_MUL
 = 
FN_ADD


35 
def
 
FN_MULH
 = 
FN_SL


36 
def
 
FN_MULHSU
 = 
FN_SEQ


37 
def
 
FN_MULHU
 = 
FN_SNE


39 
def
 
isMulFN
(
â
: 
UIÁ
, 
cmp
: UInt) = fn(1,0) === cmp(1,0)

40 
def
 
isSub
(
cmd
: 
UIÁ
) = cmd(3)

41 
def
 
isCmp
(
cmd
: 
UIÁ
èğcmd >ğ
FN_SLT


42 
def
 
cmpUnsigÃd
(
cmd
: 
UIÁ
) = cmd(1)

43 
def
 
cmpInv”‹d
(
cmd
: 
UIÁ
) = cmd(0)

44 
def
 
cmpEq
(
cmd
: 
UIÁ
) = !cmd(3)

47 
impÜt
 
ALU
.
_


48 
impÜt
 
In¡ruùiÚs
.
_


50 şas 
	cALU
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
) {

51 
v®
 
io
 = 
Ãw
 
BundË
 {

52 
v®
 
dw
 = 
	`B™s
(
INPUT
, 
SZ_DW
)

53 
v®
 
â
 = 
	`B™s
(
INPUT
, 
SZ_ALU_FN
)

54 
v®
 
š2
 = 
	`UIÁ
(
INPUT
, 
xL’
)

55 
v®
 
š1
 = 
	`UIÁ
(
INPUT
, 
xL’
)

56 
v®
 
out
 = 
	`UIÁ
(
OUTPUT
, 
xL’
)

57 
v®
 
add”_out
 = 
	`UIÁ
(
OUTPUT
, 
xL’
)

58 
v®
 
cmp_out
 = 
	`BoŞ
(
OUTPUT
)

62 
v®
 
š2_šv
 = 
	`Mux
(
	`isSub
(
io
.
â
), ~io.
š2
, io.in2)

63 
v®
 
š1_xÜ_š2
 = 
io
.
š1
 ^ 
š2_šv


64 
io
.
add”_out
 :ğio.
š1
 + 
š2_šv
 + 
	$isSub
(
io
.
â
)

67 
v®
 
¦t
 =

68 
	`Mux
(
io
.
	`š1
(
xL’
-1è==ğio.
	`š2
(xL’-1), io.
	`add”_out
(xLen-1),

69 
	`Mux
(
	`cmpUnsigÃd
(
io
.
â
), io.
	`š2
(
xL’
-1), io.
	`š1
(xLen-1)))

70 
io
.
cmp_out
 :ğ
	`cmpInv”‹d
(io.
â
è^ 
	`Mux
(
	`cmpEq
(io.â), 
š1_xÜ_š2
 ==ğ
	`UIÁ
(0), 
¦t
)

73 
	`v®
 (
shamt
, 
shš_r
) =

74 ià(
xL’
 =ğ32è(
io
.
	`š2
(4,0), io.
š1
)

76 
	`»quœe
(
xL’
 == 64)

77 
v®
 
shš_hi_32
 = 
	`Fl
(32, 
	`isSub
(
io
.
â
è&& io.
	`š1
(31))

78 
v®
 
shš_hi
 = 
	`Mux
(
io
.
dw
 ==ğ
DW_64
, io.
	`š1
(63,32), 
shš_hi_32
)

79 
v®
 
shamt
 = 
	`C©
(
io
.
	`š2
(5è& (io.
dw
 ==ğ
DW_64
), io.in2(4,0))

80 (
shamt
, 
	`C©
(
shš_hi
, 
io
.
	`š1
(31,0)))

81 
	}
}

82 
v®
 
	gshš
 = 
Mux
(
io
.
â
 ==ğ
FN_SR
 || io.â ==ğ
FN_SRA
, 
shš_r
, 
	$Rev”£
(
shš_r
))

83 
v®
 
shout_r
 = (
	`C©
(
	`isSub
(
io
.
â
è& 
	`shš
(
xL’
-1), 
shš
).
asSIÁ
 >> 
shamt
)(xLen-1,0)

84 
v®
 
shout_l
 = 
	$Rev”£
(
shout_r
)

85 
v®
 
shout
 = 
	`Mux
(
io
.
â
 ==ğ
FN_SR
 || io.â ==ğ
FN_SRA
, 
shout_r
, 
	`UIÁ
(0)) |

86 
	`Mux
(
io
.
â
 ==ğ
FN_SL
, 
shout_l
, 
	$UIÁ
(0))

89 
v®
 
logic
 = 
	`Mux
(
io
.
â
 ==ğ
FN_XOR
 || io.â ==ğ
FN_OR
, 
š1_xÜ_š2
, 
	`UIÁ
(0)) |

90 
	`Mux
(
io
.
â
 ==ğ
FN_OR
 || io.â ==ğ
FN_AND
, io.
š1
 & io.
š2
, 
	$UIÁ
(0))

91 
v®
 
shiá_logic
 = (
	`isCmp
(
io
.
â
è&& 
¦t
è| 
logic
 | 
shout


92 
v®
 
out
 = 
	`Mux
(
io
.
â
 ==ğ
FN_ADD
 || io.â ==ğ
FN_SUB
, io.
add”_out
, 
shiá_logic
)

94 
io
.
out
 := out

95 ià(
xL’
 > 32) {

96 
	`»quœe
(
xL’
 == 64)

97 
	`wh’
 (
io
.
dw
 ==ğ
DW_32
è{ io.
out
 :ğ
	`C©
(
	`Fl
(32, 
	`out
(31)), out(31,0)) }

98 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/AMOALU.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
şass
 
	$StÜeG’
(
typ
: 
UIÁ
, 
addr
: UIÁ, 
d©
: UIÁ, 
maxSize
: 
IÁ
) {

10 
v®
 
size
 = 
	`typ
(
	`log2Up
Öog2Up(
maxSize
)+1)-1,0)

11 
def
 
mi§ligÃd
 =

12 (
addr
 & ((
	`UIÁ
(1è<< 
size
è- UIÁ(1))(
	`log2Up
(
maxSize
)-1,0)).
ÜR


14 
def
 
mask
 = {

15 
v¬
 
»s
 = 
	`UIÁ
(1)

16 
i
 <- 0 
uÁ
 
	`log2Up
(
maxSize
)) {

17 
v®
 
uµ”
 = 
	`Mux
(
	`addr
(
i
), 
»s
, 
	`UIÁ
(0)è| Mux(
size
 >ğUIÁ(i+1), UIÁ((
	`BigIÁ
(1) << (1 << i))-1), UInt(0))

18 
v®
 
low”
 = 
	`Mux
(
	`addr
(
i
), 
	`UIÁ
(0), 
»s
)

19 
»s
 = 
	`C©
(
uµ”
, 
low”
)

21 
»s


24 
´Ùeùed
 
def
 
	`g’D©a
(
i
: 
IÁ
): 
UIÁ
 =

25 ià(
i
 >ğ
	`log2Up
(
maxSize
)è
d©


26 
	`Mux
(
size
 ==ğ
	`UIÁ
(
i
), 
	`Fl
(1 << (
	`log2Up
(
maxSize
)-i), 
	`d©
((8 << i)-1,0)), 
	`g’D©a
(i+1))

28 
def
 
d©a
 = 
	`g’D©a
(0)

29 
def
 
wÜdD©a
 = 
	`g’D©a
(2)

30 
	}
}

32 
şass
 
	$LßdG’
(
typ
: 
UIÁ
, sigÃd: 
BoŞ
, 
addr
: UIÁ, 
d©
: UIÁ, 
z”o
: BoŞ, 
maxSize
: 
IÁ
) {

33 
´iv©e
 
v®
 
size
 = 
Ãw
 
	`StÜeG’
(
typ
, 
addr
, 
d©
, 
maxSize
).size

35 
´iv©e
 
def
 
	`g’D©a
(
logMšSize
: 
IÁ
): 
UIÁ
 = {

36 
v¬
 
»s
 = 
d©


37 
i
 <- 
	`log2Up
(
maxSize
)-1 
to
 
logMšSize
 
by
 -1) {

38 
v®
 
pos
 = 8 << 
i


39 
v®
 
shiáed
 = 
	`Mux
(
	`addr
(
i
), 
	`»s
(2*
pos
-1,pos),„es(pos-1,0))

40 
v®
 
doZ”o
 = 
	`BoŞ
(
i
 =ğ0è&& 
z”o


41 
v®
 
z”Ûd
 = 
	`Mux
(
doZ”o
, 
	`UIÁ
(0), 
shiáed
)

42 
»s
 = 
	`C©
(
	`Mux
(
size
 ==ğ
	`UIÁ
(
i
è|| 
doZ”o
, 
	`Fl
(8*
maxSize
-
pos
, sigÃd && 
	`z”Ûd
Õos-1)), 
	`»s
(8*maxSize-1,pos)), 
z”Ûd
)

44 
»s


47 
def
 
wÜdD©a
 = 
	`g’D©a
(2)

48 
def
 
d©a
 = 
	`g’D©a
(0)

49 
	}
}

51 şas 
	cAMOALU
(
İ”ªdB™s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

52 
v®
 
mšXL’
 = 32

53 
v®
 
widths
 = (0 
to
 
	`log2Ce
(
İ”ªdB™s
 / 
mšXL’
)).
	`m­
(mšXL’ << 
_
)

55 
v®
 
io
 = 
Ãw
 
BundË
 {

56 
v®
 
mask
 = 
	`UIÁ
(
INPUT
, 
İ”ªdB™s
/8)

57 
v®
 
cmd
 = 
	`B™s
(
INPUT
, 
M_SZ
)

58 
v®
 
lhs
 = 
	`B™s
(
INPUT
, 
İ”ªdB™s
)

59 
v®
 
rhs
 = 
	`B™s
(
INPUT
, 
İ”ªdB™s
)

60 
v®
 
out
 = 
	`B™s
(
OUTPUT
, 
İ”ªdB™s
)

61 
v®
 
out_unmasked
 = 
	`B™s
(
OUTPUT
, 
İ”ªdB™s
)

64 
v®
 
max
 = 
io
.
cmd
 ==ğ
M_XA_MAX
 || io.cmd ==ğ
M_XA_MAXU


65 
v®
 
mš
 = 
io
.
cmd
 ==ğ
M_XA_MIN
 || io.cmd ==ğ
M_XA_MINU


66 
v®
 
add
 = 
io
.
cmd
 ==ğ
M_XA_ADD


67 
v®
 
logic_ªd
 = 
io
.
cmd
 ==ğ
M_XA_OR
 || io.cmd ==ğ
M_XA_AND


68 
v®
 
logic_xÜ
 = 
io
.
cmd
 ==ğ
M_XA_XOR
 || io.cmd ==ğ
M_XA_OR


70 
v®
 
add”_out
 = {

72 
v®
 
mask
 = ~(
	`UIÁ
(0, 
İ”ªdB™s
è+: 
widths
.
š™
.
	`m­
(
w
 => !
io
.
	`mask
(w/8-1è<< (w-1))).
	`»duû
(
_
|_)

73 (
io
.
lhs
 & 
mask
è+ (io.
rhs
 & mask)

74 
	}
}

76 
v®
 
Ëss
 = {

78 
def
 
isLessUnsigÃd
(
x
: 
UIÁ
, 
y
: UIÁ, 
n
: 
IÁ
): 
BoŞ
 = {

79 ià(
n
 =ğ
mšXL’
è
x
Ò-1, 0è< 
y
(n-1, 0)

80 
x
(
n
-1,‚/2è< 
y
Ò-1,‚/2è|| xÒ-1,‚/2è==ğyÒ-1,‚/2è&& 
isLessUnsigÃd
(x, y,‚/2)

83 
def
 
isLess
(
x
: 
UIÁ
, 
y
: UIÁ, 
n
: 
IÁ
): 
BoŞ
 = {

84 
v®
 signed = {

85 
v®
 
mask
 = 
M_XA_MIN
 ^ 
M_XA_MINU


86 (
io
.
cmd
 & 
mask
è==ğ(
M_XA_MIN
 & mask)

88 
Mux
(
x
(
n
-1è==ğ
y
Ò-1), 
isLessUnsigÃd
(x, y,‚), Mux(signed, x(n-1), y(n-1)))

91 
PriÜ™yMux
(
widths
.
»v”£
.
m­
(
w
 => (
io
.
mask
(w/8/2), 
isLess
(io.
lhs
, io.
rhs
, w))))

94 
v®
 
	gmšmax
 = 
Mux
(Mux(
Ëss
, 
mš
, 
max
), 
io
.
lhs
, io.
rhs
)

95 
v®
 
	glogic
 =

96 
Mux
(
logic_ªd
, 
io
.
lhs
 & io.
rhs
, 0.U) |

97 
Mux
(
logic_xÜ
, 
io
.
lhs
 ^ io.
rhs
, 0.U)

98 
v®
 
	gout
 =

99 
Mux
(
add
, 
add”_out
,

100 
Mux
(
logic_ªd
 || 
logic_xÜ
, 
logic
,

101 
mšmax
))

103 
v®
 
	gwmask
 = 
	$FlIÁ”Ëaved
(8, 
io
.
mask
)

104 
io
.
out
 :ğ
wmask
 & ouˆ| ~wmask & io.
lhs


105 
io
.
out_unmasked
 :ğ
out


106 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BTB.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gchi£l3
.
	gš‹º®
.
In¡ªûId


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
CacheBlockBy‹s


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
HasCÜeP¬am‘”s


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


14 
şass
 
	$BHTP¬ams
(

15 
nEÁr›s
: 
IÁ
 = 512,

16 
couÁ”L’gth
: 
IÁ
 = 1,

17 
hi¡ÜyL’gth
: 
IÁ
 = 8,

18 
hi¡ÜyB™s
: 
IÁ
 = 3)

20 
şass
 
	`BTBP¬ams
(

21 
nEÁr›s
: 
IÁ
 = 28,

22 
nM©chB™s
: 
IÁ
 = 14,

23 
nPages
: 
IÁ
 = 6,

24 
nRAS
: 
IÁ
 = 6,

25 
bhtP¬ams
: 
O±iÚ
[
BHTP¬ams
] = 
	`Some
(
	`BHTP¬ams
()),

26 
upd©esOutOfOrd”
: 
BoŞ—n
 = 
çl£
)

28 
Œa™
 
HasBtbP¬am‘”s
 
ex‹nds
 
HasCÜeP¬am‘”s
 { 
this
: 
In¡ªûId
 =>

29 
v®
 
btbP¬ams
 = 
teP¬ams
.
btb
.
	`g‘OrEl£
(
	`BTBP¬ams
(
nEÁr›s
 = 0))

30 
v®
 
m©chB™s
 = 
btbP¬ams
.
nM©chB™s
 
max
 
	`log2Ce
(
	`p
(
CacheBlockBy‹s
è* 
teP¬ams
.
iÿche
.
g‘
.
nS‘s
)

31 
v®
 
’Œ›s
 = 
btbP¬ams
.
nEÁr›s


32 
v®
 
upd©esOutOfOrd”
 = 
btbP¬ams
.updatesOutOfOrder

33 
v®
 
nPages
 = (
btbP¬ams
.nPages + 1) / 2 * 2

34 
	}
}

36 
ab¡¿ù
 cÏs 
	cBtbModuË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 
w™h
 
HasBtbP¬am‘”s
 {

37 
AÂÙ©ed
.
	`·¿ms
(
this
, 
btbP¬ams
)

40 
ab¡¿ù
 cÏs 
	cBtbBundË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
BundË
 
w™h
 
HasBtbP¬am‘”s


42 şas 
	cRAS
(
Äas
: 
IÁ
) {

43 
def
 
	$push
(
addr
: 
UIÁ
): 
Un™
 = {

44 
	`wh’
 (
couÁ
 < 
Äas
) { count := count + 1 }

45 
v®
 
ÃxtPos
 = 
	`Mux
(
	`BoŞ
(
	`isPow2
(
Äas
)è|| 
pos
 <‚¿s-1,…os+1, 
	`UIÁ
(0))

46 
	`¡ack
(
ÃxtPos
è:ğ
addr


47 
pos
 :ğ
ÃxtPos


49 
def
 
³ek
: 
UIÁ
 = 
	$¡ack
(
pos
)

50 
def
 
	$pİ
(): 
Un™
 = 
	`wh’
 (!
isEm±y
) {

51 
couÁ
 := count - 1

52 
pos
 :ğ
	`Mux
(
	`BoŞ
(
	`isPow2
(
Äas
)è||…o > 0,…os-1, 
	`UIÁ
(nras-1))

53 
	}
}

54 
def
 
	$ş—r
(): 
Un™
 = 
couÁ
 :ğ
	$UIÁ
(0)

55 
def
 
isEm±y
: 
BoŞ
 = 
couÁ
 ==ğ
	$UIÁ
(0)

57 
´iv©e
 
v®
 
couÁ
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Up
(
Äas
+1)))

58 
´iv©e
 
v®
 
pos
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	$log2Up
(
Äas
)))

59 
´iv©e
 
v®
 
¡ack
 = 
	`Reg
(
	`Vec
(
Äas
, 
	`UIÁ
()))

60 
	}
}

62 şas 
	cBHTRe¥
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$BtbBundË
()(
p
) {

63 
v®
 
hi¡Üy
 = 
	`UIÁ
(
width
 = 
btbP¬ams
.
bhtP¬ams
.
	`m­
(
_
.
hi¡ÜyL’gth
).
	$g‘OrEl£
(1))

64 
v®
 
v®ue
 = 
	`UIÁ
(
width
 = 
btbP¬ams
.
bhtP¬ams
.
	`m­
(
_
.
couÁ”L’gth
).
	$g‘OrEl£
(1))

65 
def
 
k’
 = 
	$v®ue
(0)

66 
def
 
¡rÚgly_k’
 = 
v®ue
 === 1

78 şas 
	cBHT
(
·¿ms
: 
BHTP¬ams
)(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
HasCÜeP¬am‘”s
 {

79 
def
 
	`šdex
(
addr
: 
UIÁ
, 
hi¡Üy
: UInt) = {

80 
def
 
	`hashHi¡Üy
(
hi¡
: 
UIÁ
èğià(
·¿ms
.
hi¡ÜyL’gth
 =ğ·¿ms.
hi¡ÜyB™s
) hist {

81 
v®
 
k
 = 
m©h
.
	`sq¹
(3)/2

82 
v®
 
i
 = 
	`BigDecim®
(
k
 * 
m©h
.
	`pow
(2, 
·¿ms
.
hi¡ÜyL’gth
)).
toBigIÁ


83 (
i
.
U
 * 
hi¡
)(
·¿ms
.
hi¡ÜyL’gth
-1,…¬ams.hi¡ÜyL’gth-·¿ms.
hi¡ÜyB™s
)

85 
def
 
	`hashAddr
(
addr
: 
UIÁ
) = {

86 
v®
 
hi
 = 
addr
 >> 
	`log2Ce
(
ãtchBy‹s
)

87 
	`hi
(
	`log2Ce
(
·¿ms
.
nEÁr›s
)-1, 0è^ (
hi
 >>†og2Ceil(params.nEntries))(1, 0)

89 
	`hashAddr
(
addr
è^ (
	`hashHi¡Üy
(
hi¡Üy
è<< (
	`log2Up
(
·¿ms
.
nEÁr›s
è-…¬ams.
hi¡ÜyB™s
))

91 
def
 
	$g‘
(
addr
: 
UIÁ
): 
BHTRe¥
 = {

92 
v®
 
»s
 = 
	`Wœe
(
Ãw
 
BHTRe¥
)

93 
»s
.
v®ue
 :ğ
	`bË
(
	`šdex
(
addr
, 
hi¡Üy
))

94 
»s
.
hi¡Üy
 := history

95 
»s


96 
	}
}

97 
def
 
	$upd©eTabË
(
addr
: 
UIÁ
, 
d
: 
BHTRe¥
, 
k’
: 
BoŞ
): 
Un™
 = {

98 
	`bË
(
	`šdex
(
addr
, 
d
.
hi¡Üy
)è:ğ(
·¿ms
.
couÁ”L’gth
 
m©ch
 {

99 1 => 
k’


100 2 => 
	`C©
(
k’
 ^ 
d
.
	`v®ue
(0), d.
v®ue
 === 1 || d.value(1) &&aken)

102 
	}
}

103 
def
 
	$»£tHi¡Üy
(
d
: 
BHTRe¥
): 
Un™
 = {

104 
hi¡Üy
 :ğ
d
.history

105 
	}
}

106 
def
 
	$upd©eHi¡Üy
(
addr
: 
UIÁ
, 
d
: 
BHTRe¥
, 
k’
: 
BoŞ
): 
Un™
 = {

107 
hi¡Üy
 :ğ
	`C©
(
k’
, 
d
.history >> 1)

108 
	}
}

109 
def
 
	$advªûHi¡Üy
(
k’
: 
BoŞ
): 
Un™
 = {

110 
hi¡Üy
 :ğ
	`C©
(
k’
, history >> 1)

111 
	}
}

113 
´iv©e
 
v®
 
	gbË
 = 
Mem
(
·¿ms
.
nEÁr›s
, 
	$UIÁ
(
width
 = 
·¿ms
.
couÁ”L’gth
))

114 
v®
 
hi¡Üy
 = 
	`Reg
(
	`UIÁ
(
width
 = 
·¿ms
.
hi¡ÜyL’gth
))

115 
	}
}

117 
objeù
 
	gCFITy³
 {

118 
def
 
	gSZ
 = 2

119 
def
 
­¶y
(èğ
UIÁ
(
width
 = 
SZ
)

120 
def
 
b¿nch
 = 0.U

121 
def
 
jump
 = 1.U

122 
def
 
ÿÎ
 = 2.U

123 
def
 
»t
 = 3.U

129 şas 
	cBTBUpd©e
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$BtbBundË
()(
p
) {

130 
v®
 
´ediùiÚ
 = 
Ãw
 
BTBRe¥


131 
v®
 
pc
 = 
	$UIÁ
(
width
 = 
vaddrB™s
)

132 
v®
 
rg‘
 = 
	$UIÁ
(
width
 = 
vaddrB™s
)

133 
v®
 
k’
 = 
	$BoŞ
()

134 
v®
 
isV®id
 = 
	$BoŞ
()

135 
v®
 
br_pc
 = 
	$UIÁ
(
width
 = 
vaddrB™s
)

136 
v®
 
cfiTy³
 = 
	`CFITy³
()

141 şas 
	cBHTUpd©e
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$BtbBundË
()(
p
) {

142 
v®
 
´ediùiÚ
 = 
Ãw
 
BHTRe¥


143 
v®
 
pc
 = 
	$UIÁ
(
width
 = 
vaddrB™s
)

144 
v®
 
b¿nch
 = 
	$BoŞ
()

145 
v®
 
k’
 = 
	$BoŞ
()

146 
v®
 
mi¥»diù
 = 
	`BoŞ
()

149 şas 
	cRASUpd©e
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$BtbBundË
()(
p
) {

150 
v®
 
cfiTy³
 = 
	$CFITy³
()

151 
v®
 
»tuºAddr
 = 
	`UIÁ
(
width
 = 
vaddrB™s
)

158 şas 
	cBTBRe¥
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$BtbBundË
()(
p
) {

159 
v®
 
cfiTy³
 = 
	$CFITy³
()

160 
v®
 
k’
 = 
	$BoŞ
()

161 
v®
 
mask
 = 
	$B™s
(
width
 = 
ãtchWidth
)

162 
v®
 
bridx
 = 
	`B™s
(
width
 = 
	$log2Up
(
ãtchWidth
))

163 
v®
 
rg‘
 = 
	$UIÁ
(
width
 = 
vaddrB™s
)

164 
v®
 
’Œy
 = 
	`UIÁ
(
width
 = 
	`log2Up
(
’Œ›s
 + 1))

165 
v®
 
bht
 = 
Ãw
 
BHTRe¥


168 şas 
	cBTBReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$BtbBundË
()(
p
) {

169 
v®
 
addr
 = 
	`UIÁ
(
width
 = 
vaddrB™s
)

176 şas 
	cBTB
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
BtbModuË
 {

177 
v®
 
io
 = 
Ãw
 
BundË
 {

178 
v®
 
»q
 = 
	`V®id
(
Ãw
 
BTBReq
).
æ


179 
v®
 
»¥
 = 
	`V®id
(
Ãw
 
BTBRe¥
)

180 
v®
 
btb_upd©e
 = 
	`V®id
(
Ãw
 
BTBUpd©e
).
æ


181 
v®
 
bht_upd©e
 = 
	`V®id
(
Ãw
 
BHTUpd©e
).
æ


182 
v®
 
bht_advªû
 = 
	`V®id
(
Ãw
 
BTBRe¥
).
æ


183 
v®
 
¿s_upd©e
 = 
	`V®id
(
Ãw
 
RASUpd©e
).
æ


184 
v®
 
¿s_h—d
 = 
	`V®id
(
	`UIÁ
(
width
 = 
vaddrB™s
))

185 
v®
 
æush
 = 
	`BoŞ
().
asIÅut


188 
v®
 
idxs
 = 
	`Reg
(
	`Vec
(
’Œ›s
, 
	`UIÁ
(
width
=
m©chB™s
 - 
	$log2Up
(
cÜeIn¡By‹s
))))

189 
v®
 
idxPages
 = 
	`Reg
(
	`Vec
(
’Œ›s
, 
	`UIÁ
(
width
=
	$log2Up
(
nPages
))))

190 
v®
 
tgts
 = 
	`Reg
(
	`Vec
(
’Œ›s
, 
	`UIÁ
(
width
=
m©chB™s
 - 
	$log2Up
(
cÜeIn¡By‹s
))))

191 
v®
 
tgtPages
 = 
	`Reg
(
	`Vec
(
’Œ›s
, 
	`UIÁ
(
width
=
	$log2Up
(
nPages
))))

192 
v®
 
·ges
 = 
	`Reg
(
	`Vec
(
nPages
, 
	`UIÁ
(
width
=
vaddrB™s
 - 
m©chB™s
)))

193 
v®
 
·geV®id
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 
nPages
))

195 
v®
 
isV®id
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 
’Œ›s
))

196 
v®
 
cfiTy³
 = 
	`Reg
(
	`Vec
(
’Œ›s
, 
	$CFITy³
()))

197 
v®
 
brIdx
 = 
	`Reg
(
	`Vec
(
’Œ›s
, 
	`UIÁ
(
width
=
	$log2Up
(
ãtchWidth
))))

199 
´iv©e
 
def
 
	`·ge
(
addr
: 
UIÁ
èğadd¸>> 
m©chB™s


200 
´iv©e
 
def
 
	`·geM©ch
(
addr
: 
UIÁ
) = {

201 
v®
 
p
 = 
	`·ge
(
addr
)

202 
·geV®id
 & 
·ges
.
	`m­
(
_
 ==ğ
p
).
asUIÁ


203 
	}
}

204 
´iv©e
 
def
 
idxM©ch
(
addr
: 
UIÁ
) = {

205 
v®
 
idx
 = 
addr
(
m©chB™s
-1, 
log2Up
(
cÜeIn¡By‹s
))

206 
	gidxs
.
m­
(
_
 ==ğ
idx
).
asUIÁ
 & 
isV®id


209 
v®
 
	gr_btb_upd©e
 = 
	$Pe
(
io
.
btb_upd©e
)

210 
v®
 
upd©e_rg‘
 = 
io
.
»q
.
b™s
.
addr


212 
v®
 
·geH™
 = 
	$·geM©ch
(
io
.
»q
.
b™s
.
addr
)

213 
v®
 
idxH™
 = 
	$idxM©ch
(
io
.
»q
.
b™s
.
addr
)

215 
v®
 
upd©ePageH™
 = 
	$·geM©ch
(
r_btb_upd©e
.
b™s
.
pc
)

216 
	`v®
 (
upd©eH™
, 
upd©eH™Addr
) =

217 ià(
upd©esOutOfOrd”
) {

218 
v®
 
upd©eH™s
 = (
·geH™
 << 1)(
	`Mux1H
(
	`idxM©ch
(
r_btb_upd©e
.
b™s
.
pc
), 
idxPages
))

219 (
upd©eH™s
.
ÜR
, 
	`OHToUIÁ
(updateHits))

220 
	}
} (
	gr_btb_upd©e
.
	gb™s
.
	g´ediùiÚ
.
	g’Œy
 < 
	g’Œ›s
,„_btb_update.bits.prediction.entry)

222 
v®
 
	gu£Upd©ePageH™
 = 
upd©ePageH™
.
ÜR


223 
v®
 
u£PageH™
 = 
·geH™
.
ÜR


224 
v®
 
doIdxPageR•l
 = !
u£Upd©ePageH™


225 
v®
 
ÃxtPageR•l
 = 
Reg
(
UIÁ
(
width
 = 
	$log2Ce
(
nPages
)))

226 
v®
 
idxPageR•l
 = 
	`C©
(
	`·geH™
(
nPages
-2,0),…ageH™ÒPages-1)è| 
	`Mux
(
u£PageH™
, 
	`UIÁ
(0), 
	$UIÁToOH
(
ÃxtPageR•l
))

227 
v®
 
idxPageUpd©eOH
 = 
	$Mux
(
u£Upd©ePageH™
, 
upd©ePageH™
, 
idxPageR•l
)

228 
v®
 
idxPageUpd©e
 = 
	$OHToUIÁ
(
idxPageUpd©eOH
)

229 
v®
 
idxPageR•lEn
 = 
	`Mux
(
doIdxPageR•l
, 
idxPageR•l
, 
	$UIÁ
(0))

231 
v®
 
§mePage
 = 
	`·ge
(
r_btb_upd©e
.
b™s
.
pc
è==ğ
	$·ge
(
upd©e_rg‘
)

232 
v®
 
doTgtPageR•l
 = !
§mePage
 && !
u£PageH™


233 
v®
 
tgtPageR•l
 = 
	`Mux
(
§mePage
, 
idxPageUpd©eOH
, 
	`C©
(
	`idxPageUpd©eOH
(
nPages
-2,0), idxPageUpdateOH(nPages-1)))

234 
v®
 
tgtPageUpd©e
 = 
	`OHToUIÁ
(
·geH™
 | 
	`Mux
(
u£PageH™
, 
	`UIÁ
(0), 
tgtPageR•l
))

235 
v®
 
tgtPageR•lEn
 = 
	`Mux
(
doTgtPageR•l
, 
tgtPageR•l
, 
	$UIÁ
(0))

237 
	`wh’
 (
r_btb_upd©e
.
v®id
 && (
doIdxPageR•l
 || 
doTgtPageR•l
)) {

238 
v®
 
bÙh
 = 
doIdxPageR•l
 && 
doTgtPageR•l


239 
v®
 
Ãxt
 = 
ÃxtPageR•l
 + 
Mux
[
UIÁ
](
bÙh
, 2, 1)

240 
ÃxtPageR•l
 :ğ
	`Mux
(
Ãxt
 >ğ
nPages
, 
	`Ãxt
(0),‚ext)

241 
	}
}

243 
v®
 
	g»¶
 = 
Ãw
 
	$P£udoLRU
(
’Œ›s
)

244 
v®
 
waddr
 = 
	$Mux
(
upd©eH™
, 
upd©eH™Addr
, 
»¶
.
»¶aû
)

245 
v®
 
r_»¥
 = 
	$Pe
(
io
.
»¥
)

246 
	`wh’
 (
r_»¥
.
v®id
 &&„_»¥.
b™s
.
k’
 || 
r_btb_upd©e
.valid) {

247 
»¶
.
	`acûss
(
	`Mux
(
r_btb_upd©e
.
v®id
, 
waddr
, 
r_»¥
.
b™s
.
’Œy
))

248 
	}
}

250 
	$wh’
 (
r_btb_upd©e
.
v®id
) {

251 
v®
 
mask
 = 
	`UIÁToOH
(
waddr
)

252 
	`idxs
(
waddr
è:ğ
r_btb_upd©e
.
b™s
.
	`pc
(
m©chB™s
-1, 
	`log2Up
(
cÜeIn¡By‹s
))

253 
	`tgts
(
waddr
è:ğ
	`upd©e_rg‘
(
m©chB™s
-1, 
	`log2Up
(
cÜeIn¡By‹s
))

254 
	`idxPages
(
waddr
è:ğ
idxPageUpd©e
 +& 1

255 
	`tgtPages
(
waddr
è:ğ
tgtPageUpd©e


256 
	`cfiTy³
(
waddr
è:ğ
r_btb_upd©e
.
b™s
.
cfiTy³


257 
isV®id
 :ğ
	`Mux
(
r_btb_upd©e
.
b™s
.isV®id, isV®id | 
mask
, isValid & ~mask)

258 ià(
ãtchWidth
 > 1)

259 
	`brIdx
(
waddr
è:ğ
r_btb_upd©e
.
b™s
.
br_pc
 >> 
	`log2Up
(
cÜeIn¡By‹s
)

261 
	`»quœe
(
nPages
 % 2 == 0)

262 
v®
 
idxWr™esEv’
 = !
	`idxPageUpd©e
(0)

264 
def
 
	`wr™eBªk
(
i
: 
IÁ
, 
mod
: IÁ, 
’
: 
UIÁ
, 
d©a
: UInt) =

265 
i
 <- i 
uÁ
 
nPages
 
by
 
mod
)

266 
	`wh’
 (
	`’
(
i
)è{ 
	`·ges
(iè:ğ
d©a
 }

268 
	`wr™eBªk
(0, 2, 
	`Mux
(
idxWr™esEv’
, 
idxPageR•lEn
, 
tgtPageR•lEn
),

269 
	`Mux
(
idxWr™esEv’
, 
	`·ge
(
r_btb_upd©e
.
b™s
.
pc
),…age(
upd©e_rg‘
)))

270 
	`wr™eBªk
(1, 2, 
	`Mux
(
idxWr™esEv’
, 
tgtPageR•lEn
, 
idxPageR•lEn
),

271 
	`Mux
(
idxWr™esEv’
, 
	`·ge
(
upd©e_rg‘
),…age(
r_btb_upd©e
.
b™s
.
pc
)))

272 
·geV®id
 :ğ·geV®id | 
tgtPageR•lEn
 | 
idxPageR•lEn


273 
	}
}

275 
io
.
»¥
.
v®id
 :ğ(
·geH™
 << 1)(
	$Mux1H
(
idxH™
, 
idxPages
))

276 
io
.
»¥
.
b™s
.
k’
 :ğ
Œue


277 
io
.
»¥
.
b™s
.
rg‘
 :ğ
	`C©
(
	`·ges
(
	`Mux1H
(
idxH™
, 
tgtPages
)), Mux1H(idxH™, 
tgts
è<< 
	$log2Up
(
cÜeIn¡By‹s
))

278 
io
.
»¥
.
b™s
.
’Œy
 :ğ
	$OHToUIÁ
(
idxH™
)

279 
io
.
»¥
.
b™s
.
bridx
 :ğ(ià(
ãtchWidth
 > 1è
	$Mux1H
(
idxH™
, 
brIdx
è
	$UIÁ
(0))

280 
io
.
»¥
.
b™s
.
mask
 :ğ
	`C©
((
	`UIÁ
(1è<< ~
	`Mux
(io.»¥.b™s.
k’
, ~io.»¥.b™s.
bridx
, UIÁ(0)))-1, 
	$UIÁ
(1))

281 
io
.
»¥
.
b™s
.
cfiTy³
 :ğ
	$Mux1H
(
idxH™
, 
cfiTy³
)

284 
	`wh’
 (
	$PİCouÁAtL—¡
(
idxH™
, 2)) {

285 
isV®id
 :ğisV®id & ~
idxH™


286 
	}
}

287 
	$wh’
 (
io
.
æush
) {

288 
isV®id
 := 0

289 
	}
}

291 ià(
btbP¬ams
.
bhtP¬ams
.
nÚEm±y
) {

292 
v®
 
bht
 = 
Ãw
 
BHT
(
AÂÙ©ed
.
·¿ms
(
this
, 
btbP¬ams
.
bhtP¬ams
.
g‘
))

293 
v®
 
	gisB¿nch
 = (
idxH™
 & 
cfiTy³
.
m­
(
_
 ==ğ
CFITy³
.
b¿nch
).
asUIÁ
).
ÜR


294 
v®
 
»s
 = 
bht
.
g‘
(
io
.
»q
.
b™s
.
addr
)

295 
wh’
 (
io
.
bht_advªû
.
v®id
) {

296 
bht
.
advªûHi¡Üy
(
io
.
bht_advªû
.
b™s
.bht.
k’
)

298 
wh’
 (
io
.
bht_upd©e
.
v®id
) {

299 
wh’
 (
io
.
bht_upd©e
.
b™s
.
b¿nch
) {

300 
bht
.
upd©eTabË
(
io
.
bht_upd©e
.
b™s
.
pc
, io.bht_upd©e.b™s.
´ediùiÚ
, io.bht_upd©e.b™s.
k’
)

301 
wh’
 (
io
.
bht_upd©e
.
b™s
.
mi¥»diù
) {

302 
bht
.
upd©eHi¡Üy
(
io
.
bht_upd©e
.
b™s
.
pc
, io.bht_upd©e.b™s.
´ediùiÚ
, io.bht_upd©e.b™s.
k’
)

304 }.
–£wh’
 (
io
.
bht_upd©e
.
b™s
.
mi¥»diù
) {

305 
bht
.
»£tHi¡Üy
(
io
.
bht_upd©e
.
b™s
.
´ediùiÚ
)

308 
wh’
 (!
»s
.
k’
 && 
isB¿nch
è{ 
io
.
»¥
.
b™s
.k’ :ğ
çl£
 }

309 
io
.
»¥
.
b™s
.
bht
 :ğ
»s


312 ià(
btbP¬ams
.
nRAS
 > 0) {

313 
v®
 
¿s
 = 
Ãw
 
RAS
(
btbP¬ams
.
nRAS
)

314 
v®
 
doP“k
 = (
idxH™
 & 
cfiTy³
.
m­
(
_
 ==ğ
CFITy³
.
»t
).
asUIÁ
).
ÜR


315 
io
.
¿s_h—d
.
v®id
 :ğ!
¿s
.
isEm±y


316 
io
.
¿s_h—d
.
b™s
 :ğ
¿s
.
³ek


317 
wh’
 (!
¿s
.
isEm±y
 && 
doP“k
) {

318 
io
.
»¥
.
b™s
.
rg‘
 :ğ
¿s
.
³ek


320 
wh’
 (
io
.
¿s_upd©e
.
v®id
) {

321 
wh’
 (
io
.
¿s_upd©e
.
b™s
.
cfiTy³
 ==ğ
CFITy³
.
ÿÎ
) {

322 
¿s
.
push
(
io
.
¿s_upd©e
.
b™s
.
»tuºAddr
)

323 }.
–£wh’
 (
io
.
¿s_upd©e
.
b™s
.
cfiTy³
 ==ğ
CFITy³
.
»t
) {

324 
¿s
.
pİ
()

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Breakpoint.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.{
	gCÜeModuË
, 
	gCÜeBundË
}

9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 şas 
	cBPCÚŒŞ
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

12 
v®
 
‰y³
 = 
	$UIÁ
(
width
 = 4)

13 
v®
 
dmode
 = 
	$BoŞ
()

14 
v®
 
maskmax
 = 
	$UIÁ
(
width
 = 6)

15 
v®
 
»£rved
 = 
	`UIÁ
(
width
 = 
xL’
-24)

16 
v®
 
aùiÚ
 = 
	$BoŞ
()

17 
v®
 
chaš
 = 
	$BoŞ
()

18 
v®
 
z”o
 = 
	$UIÁ
(
width
 = 2)

19 
v®
 
tm©ch
 = 
	$UIÁ
(
width
 = 2)

20 
v®
 
m
 = 
	$BoŞ
()

21 
v®
 
h
 = 
	$BoŞ
()

22 
v®
 
s
 = 
	$BoŞ
()

23 
v®
 
u
 = 
	$BoŞ
()

24 
v®
 
x
 = 
	$BoŞ
()

25 
v®
 
w
 = 
	$BoŞ
()

26 
v®
 
r
 = 
	$BoŞ
()

28 
def
 
tTy³
 = 2

29 
def
 
maskMax
 = 4

30 
def
 
	`’abËd
(
m¡©us
: 
MStus
èğ!m¡©us.
debug
 && 
	$C©
(
m
, 
h
, 
s
, 
u
)(
m¡©us
.
´v
)

33 şas 
	cBP
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

34 
v®
 
cÚŒŞ
 = 
Ãw
 
BPCÚŒŞ


35 
v®
 
add»ss
 = 
	$UIÁ
(
width
 = 
vaddrB™s
)

37 
def
 
	`mask
(
dummy
: 
IÁ
 = 0) =

38 (0 
uÁ
 
cÚŒŞ
.
maskMax
-1).
	`sÿnLeá
(cÚŒŞ.
	$tm©ch
(0))((
m
, 
i
è=> m && 
	`add»ss
(i)).
asUIÁ


40 
def
 
	`pow2Add»ssM©ch
(
x
: 
UIÁ
) =

41 (~
x
 | 
	`mask
()è==ğ(~
add»ss
 | 
	$mask
())

43 
def
 
	`¿ngeAdd»ssM©ch
(
x
: 
UIÁ
) =

44 (
x
 >ğ
add»ss
è^ 
cÚŒŞ
.
	$tm©ch
(0)

46 
def
 
	`add»ssM©ch
(
x
: 
UIÁ
) =

47 
	`Mux
(
cÚŒŞ
.
	`tm©ch
(1), 
	`¿ngeAdd»ssM©ch
(
x
), 
	`pow2Add»ssM©ch
(x))

50 şas 
	cB»akpoštUn™
(
n
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
) {

51 
v®
 
io
 = 
Ãw
 
BundË
 {

52 
v®
 
¡©us
 = 
Ãw
 
	`MStus
().
asIÅut


53 
v®
 
bp
 = 
	`Vec
(
n
, 
Ãw
 
BP
).
asIÅut


54 
v®
 
pc
 = 
	`UIÁ
(
INPUT
, 
vaddrB™s
)

55 
v®
 
—
 = 
	`UIÁ
(
INPUT
, 
vaddrB™s
)

56 
v®
 
xıt_if
 = 
	`BoŞ
(
OUTPUT
)

57 
v®
 
xıt_ld
 = 
	`BoŞ
(
OUTPUT
)

58 
v®
 
xıt_¡
 = 
	`BoŞ
(
OUTPUT
)

59 
v®
 
debug_if
 = 
	`BoŞ
(
OUTPUT
)

60 
v®
 
debug_ld
 = 
	`BoŞ
(
OUTPUT
)

61 
v®
 
debug_¡
 = 
	`BoŞ
(
OUTPUT
)

64 
io
.
xıt_if
 :ğ
çl£


65 
io
.
xıt_ld
 :ğ
çl£


66 
io
.
xıt_¡
 :ğ
çl£


67 
io
.
debug_if
 :ğ
çl£


68 
io
.
debug_ld
 :ğ
çl£


69 
io
.
debug_¡
 :ğ
çl£


71 
io
.
bp
.
	`fŞdLeá
((
	`BoŞ
(
Œue
), BoŞÑrue), 
	$BoŞ
(
Œue
))è{ ((
ri
, 
wi
, 
xi
), 
bp
) =>

72 
v®
 
’
 = 
bp
.
cÚŒŞ
.
	`’abËd
(
io
.
¡©us
)

73 
v®
 
r
 = 
’
 && 
ri
 && 
bp
.
cÚŒŞ
.¸&& bp.
	`add»ssM©ch
(
io
.
—
)

74 
v®
 
w
 = 
’
 && 
wi
 && 
bp
.
cÚŒŞ
.w && bp.
	`add»ssM©ch
(
io
.
—
)

75 
v®
 
x
 = 
’
 && 
xi
 && 
bp
.
cÚŒŞ
.x && bp.
	`add»ssM©ch
(
io
.
pc
)

76 
v®
 
’d
 = !
bp
.
cÚŒŞ
.
chaš


78 
	`wh’
 (
’d
 && 
r
è{ 
io
.
xıt_ld
 :ğ!
bp
.
cÚŒŞ
.
aùiÚ
; io.
debug_ld
 := bp.control.action }

79 
	`wh’
 (
’d
 && 
w
è{ 
io
.
xıt_¡
 :ğ!
bp
.
cÚŒŞ
.
aùiÚ
; io.
debug_¡
 := bp.control.action }

80 
	`wh’
 (
’d
 && 
x
è{ 
io
.
xıt_if
 :ğ!
bp
.
cÚŒŞ
.
aùiÚ
; io.
debug_if
 := bp.control.action }

82 (
’d
 || 
r
,ƒnd || 
w
,ƒnd || 
x
)

83 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BusErrorUnit.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


7 
impÜt
 
	gchi£l3
.
	gut
.
V®id


8 
impÜt
 
	gchi£l3
.
	gcÜe
.
DÚtC¬e


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


15 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


16 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


18 
Œa™
 
BusE¼Üs
 
ex‹nds
 
	gBundË
 {

19 
def
 
	gtoE¼ÜLi¡
: 
Li¡
[
O±iÚ
[(
V®id
[
UIÁ
], 
	gSŒšg
, String)]]

22 şas 
	cL1BusE¼Üs
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
è
w™h
 
BusE¼Üs
 {

23 
v®
 
iÿche
 = 
Ãw
 
ICacheE¼Üs


24 
v®
 
dÿche
 = 
Ãw
 
DCacheE¼Üs


26 
def
 
toE¼ÜLi¡
 = 
	`Li¡
(
NÚe
, None,

27 
iÿche
.
cÜ»ùabË
.
	`m­
((
_
, "I_CORRECTABLE", "Instruction cache or ITIM correctable ECCƒrror ")),

28 
iÿche
.
uncÜ»ùabË
.
	`m­
((
_
, "I_UNCORRECTABLE", "ITIM uncorrectable ECCƒrror")),

29 
NÚe
,

30 
	`Some
((
dÿche
.
bus
, "DBUS", "Load or store TileLink busƒrror")),

31 
dÿche
.
cÜ»ùabË
.
	`m­
((
_
, "D_CORRECTABLE", "Data cache correctable ECCƒrror")),

32 
dÿche
.
uncÜ»ùabË
.
	`m­
((
_
, "D_UNCORRECTABLE", "Data cache uncorrectable ECCƒrror")))

35 
şass
 
	$BusE¼ÜUn™P¬ams
(
addr
: 
BigIÁ
, 
size
: 
IÁ
 = 4096)

37 
şass
 
BusE¼ÜUn™
[
T
 <: 
BusE¼Üs
](
t
: => T, 
·¿ms
: 
BusE¼ÜUn™P¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

38 
v®
 
»gWidth
 = 64

39 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("bus-”rÜ-un™", 
	`Seq
("sifive,buserror0"))

40 
v®
 
štNode
 = 
	`IÁSourûNode
(
	`IÁSourûPÜtSim¶e
(
»sourûs
 = 
deviû
.))

41 
v®
 
node
 = 
	`TLRegi¡”Node
(

42 
add»ss
 = 
	`Seq
(
	`Add»ssS‘
(
·¿ms
.
addr
,…¬ams.
size
-1)),

43 
deviû
 = device,

44 
b—tBy‹s
 = 
	`p
(
XL’
)/8)

46 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

47 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

48 
v®
 
”rÜs
 = 
t
.
æ


49 
v®
 
š‹¼u±
 = 
	`BoŞ
().
asOuut


52 
v®
 
sourûs_ªd_desc
 = 
io
.
”rÜs
.
toE¼ÜLi¡


53 
v®
 
sourûs
 = 
sourûs_ªd_desc
.
	`m­
(
_
.m­(_.
_1
))

54 
v®
 
sourûs_’ums
 = 
sourûs_ªd_desc
.
zW™hIndex
.
æ©M­
{(
s
, 
i
è=> s.
m­
 {
e
 => (
	`BigIÁ
(iè-> (e.
_2
,ƒ.
_3
))}}

56 
v®
 
ÿu£Width
 = 
	`log2Ce
(
sourûs
.
	`Ï¡IndexWh”e
(
_
.
nÚEm±y
) + 1)

57 
	`v®
 (
ÿu£
, 
ÿu£_desc
èğ
	`DesüibedReg
(
	`UIÁ
(
ÿu£Width
.
W
),

58 "ÿu£", "Cau£ oà”rÜƒv’t", 
»£t
=
	`Some
(0.U(
ÿu£Width
.
W
)), vŞ©e=
Œue
, 
’um”©iÚs
=
sourûs_’ums
.
toM­
)

60 
	`v®
 (
v®ue
, 
v®ue_desc
èğ
	`DesüibedReg
(
	`UIÁ
(
width
 = 
sourûs
.
æ©‹n
.
	`m­
(
_
.
b™s
.
g‘Width
).
max
),

61 "v®ue", "PhysiÿÈadd»s oà”rÜƒv’t", 
»£t
=
NÚe
, vŞ©e=
Œue
)

62 
	`»quœe
(
v®ue
.
g‘Width
 <ğ
»gWidth
)

64 
v®
 
’abË
 = 
	`Reg
(
š™
 = 
	`Vec
(
sourûs
.
	`m­
(
_
.
nÚEm±y
.
B
)))

65 
v®
 
’abË_desc
 = 
sourûs
.
zW™hIndex
.
m­
 { (
s
, 
i
) =>

66 ià(
s
.
nÚEm±y
è
	`RegF›ldDesc
(s"’abË_$i", "", 
»£t
=
	`Some
(1))

67 
RegF›ldDesc
.
»£rved


70 
v®
 
glob®_š‹¼u±
 = 
	`Reg
(
š™
 = 
Vec
.
	`fl
(
sourûs
.
size
)(
çl£
.
B
))

71 
v®
 
glob®_š‹¼u±_desc
 = 
sourûs
.
zW™hIndex
.
m­
 { (
s
, 
i
) =>

72 ià(
s
.
nÚEm±y
è
	`RegF›ldDesc
(s"¶ic_š‹¼u±_$i", "", 
»£t
=
	`Some
(0))

73 
RegF›ldDesc
.
»£rved


76 
v®
 
acüued
 = 
	`Reg
(
š™
 = 
Vec
.
	`fl
(
sourûs
.
size
)(
çl£
.
B
))

77 
v®
 
acüued_desc
 = 
sourûs
.
zW™hIndex
.
m­
 { (
s
, 
i
) =>

78 ià(
s
.
nÚEm±y
è
	`RegF›ldDesc
(s"acüued_$i", "", 
»£t
=
	`Some
(0), vŞ©ğ
Œue
)

79 
RegF›ldDesc
.
»£rved


82 
v®
 
loÿl_š‹¼u±
 = 
	`Reg
(
š™
 = 
Vec
.
	`fl
(
sourûs
.
size
)(
çl£
.
B
))

83 
v®
 
loÿl_š‹¼u±_desc
 = 
sourûs
.
zW™hIndex
.
m­
 { (
s
, 
i
) =>

84 ià(
s
.
nÚEm±y
è
	`RegF›ldDesc
(s"loÿl_š‹¼u±_$i", "", 
»£t
=
	`Some
(0))

85 
RegF›ldDesc
.
»£rved


88 
v®
 
ÿu£_w’
 = 
	`Wœe
(
š™
 = 
çl£
.
B
)

89 
v®
 
Ãw_ÿu£
 = 
	`Wœe
(
	`UIÁ
(
ÿu£Width
.
W
), 
DÚtC¬e
)

90 
v®
 
Ãw_v®ue
 = 
	`Wœe
(
	`UIÁ
(
v®ue
.
g‘Width
.
W
), 
DÚtC¬e
)

91 (((
s
, 
’
), 
acc
), 
i
è<- (
sourûs
 
z
 
’abË
 z 
acüued
).
zW™hIndex
; s.
nÚEm±y
) {

92 
	`wh’
 (
s
.
g‘
.
v®id
) {

93 
acc
 :ğ
Œue


94 
	`wh’
 (
’
) {

95 
ÿu£_w’
 :ğ
Œue


96 
Ãw_ÿu£
 :ğ
i


97 
Ãw_v®ue
 :ğ
s
.
g‘
.
b™s


99 
	`cov”
(
’
, 
s
"BusErrorCause_$i", s"Core;;BusErrorCause $i covered")

103 
	`wh’
 (
ÿu£
 ==ğ0 && 
ÿu£_w’
) {

104 
ÿu£
 :ğ
	`O±imiz©iÚB¬r›r
(
Ãw_ÿu£
)

105 
v®ue
 :ğ
	`O±imiz©iÚB¬r›r
(
Ãw_v®ue
)

108 
	`v®
 (
št_out
, 
_
èğ
štNode
.
	`out
(0)

109 
io
.
š‹¼u±
 :ğ(
acüued
.
asUIÁ
 & 
loÿl_š‹¼u±
.asUIÁ).
ÜR


110 
	`št_out
(0è:ğ(
acüued
.
asUIÁ
 & 
glob®_š‹¼u±
.asUIÁ).
ÜR


112 
def
 
	`»g
(
r
: 
UIÁ
, 
gn
: 
SŒšg
, 
d
: 
RegF›ldDesc
èğ
	`RegF›ldGroup
(gn, 
NÚe
, 
RegF›ld
.
	`by‹s
Ô, (r.
g‘Width
 + 7)/8, 
	`Some
(d)))

113 
def
 
	`»g
(
v
: 
Vec
[
BoŞ
], 
gn
: 
SŒšg
, 
gd
: SŒšg, 
d
: 
Seq
[
RegF›ldDesc
]) =

114 
	`RegF›ldGroup
(
gn
, 
	`Some
(
gd
), (
v
 
z
 
d
).
m­
 {(
r
, 
rd
è=> 
	`RegF›ld
(1,„,„d)})

115 
def
 
	`numb”Regs
(
x
: 
Seq
[Seq[
RegF›ld
]]èğx.
zW™hIndex
.
m­
 {(
f
, 
i
è=> (˜* 
»gWidth
 / 8) -> f }

117 
node
.
	`»gm­
(
	`numb”Regs
(
	`Seq
(

118 
	`»g
(
ÿu£
, "ÿu£", 
ÿu£_desc
),

119 
	`»g
(
v®ue
, "v®ue", 
v®ue_desc
),

120 
	`»g
(
’abË
, "’abË", "Ev’ˆ’abË mask", 
’abË_desc
),

121 
	`»g
(
glob®_š‹¼u±
, "¶ic_š‹¼u±", "PÏtfÜm-Ëv– iÁ”ru±ƒÇbË mask", 
glob®_š‹¼u±_desc
),

122 
	`»g
(
acüued
, "acüued", "Acüuedƒv’ˆmask" ,
acüued_desc
),

123 
	`»g
(
loÿl_š‹¼u±
, "loÿl_š‹¼u±", "H¬t-loÿÈš‹¼u±-’abË mask", 
loÿl_š‹¼u±_desc
))):
_
*)

126 (
s
, 
i
è<- 
sourûs
.
zW™hIndex
; s.
isEm±y
) {

127 
	`’abË
(
i
è:ğ
çl£


128 
	`glob®_š‹¼u±
(
i
è:ğ
çl£


129 
	`acüued
(
i
è:ğ
çl£


130 
	`loÿl_š‹¼u±
(
i
è:ğ
çl£


133 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/CSR.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


13 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
LškedHashM­


14 
impÜt
 
	gIn¡ruùiÚs
.
_


16 şas 
	cMStus
 
ex‹nds
 
	mBundË
 {

18 
v®
 
	mdebug
 = 
	$BoŞ
()

19 
v®
 
i§
 = 
	$UIÁ
(
width
 = 32)

21 
v®
 
d´v
 = 
	$UIÁ
(
width
 = 
PRV
.
SZ
)

22 
v®
 
´v
 = 
	$UIÁ
(
width
 = 
PRV
.
SZ
)

23 
v®
 
sd
 = 
	$BoŞ
()

24 
v®
 
z”o2
 = 
	$UIÁ
(
width
 = 27)

25 
v®
 
sxl
 = 
	$UIÁ
(
width
 = 2)

26 
v®
 
uxl
 = 
	$UIÁ
(
width
 = 2)

27 
v®
 
sd_rv32
 = 
	$BoŞ
()

28 
v®
 
z”o1
 = 
	$UIÁ
(
width
 = 8)

29 
v®
 
t¤
 = 
	$BoŞ
()

30 
v®
 
tw
 = 
	$BoŞ
()

31 
v®
 
tvm
 = 
	$BoŞ
()

32 
v®
 
mxr
 = 
	$BoŞ
()

33 
v®
 
sum
 = 
	$BoŞ
()

34 
v®
 
m´v
 = 
	$BoŞ
()

35 
v®
 
xs
 = 
	$UIÁ
(
width
 = 2)

36 
v®
 
fs
 = 
	$UIÁ
(
width
 = 2)

37 
v®
 
mµ
 = 
	$UIÁ
(
width
 = 2)

38 
v®
 
hµ
 = 
	$UIÁ
(
width
 = 2)

39 
v®
 
¥p
 = 
	$UIÁ
(
width
 = 1)

40 
v®
 
mp›
 = 
	$BoŞ
()

41 
v®
 
hp›
 = 
	$BoŞ
()

42 
v®
 
¥›
 = 
	$BoŞ
()

43 
v®
 
up›
 = 
	$BoŞ
()

44 
v®
 
m›
 = 
	$BoŞ
()

45 
v®
 
h›
 = 
	$BoŞ
()

46 
v®
 
s›
 = 
	$BoŞ
()

47 
v®
 
u›
 = 
	`BoŞ
()

50 şas 
	cDCSR
 
ex‹nds
 
BundË
 {

51 
v®
 
xdebugv”
 = 
	$UIÁ
(
width
 = 2)

52 
v®
 
z”o4
 = 
	$UIÁ
(
width
=2)

53 
v®
 
z”o3
 = 
	$UIÁ
(
width
 = 12)

54 
v®
 
eb»akm
 = 
	$BoŞ
()

55 
v®
 
eb»akh
 = 
	$BoŞ
()

56 
v®
 
eb»aks
 = 
	$BoŞ
()

57 
v®
 
eb»aku
 = 
	$BoŞ
()

58 
v®
 
z”o2
 = 
	$BoŞ
()

59 
v®
 
¡İcyşe
 = 
	$BoŞ
()

60 
v®
 
¡İtime
 = 
	$BoŞ
()

61 
v®
 
ÿu£
 = 
	$UIÁ
(
width
 = 3)

62 
v®
 
z”o1
 = 
	$UIÁ
(
width
=3)

63 
v®
 
¡•
 = 
	$BoŞ
()

64 
v®
 
´v
 = 
	`UIÁ
(
width
 = 
PRV
.
SZ
)

67 şas 
	cMIP
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
)

68 
w™h
 
HasCÜeP¬am‘”s
 {

69 
v®
 
l
 = 
	`Vec
(
cÜeP¬ams
.
nLoÿlIÁ”ru±s
, 
	$BoŞ
())

70 
v®
 
z”o2
 = 
	$BoŞ
()

71 
v®
 
debug
 = 
	$BoŞ
()

72 
v®
 
z”o1
 = 
	$BoŞ
()

73 
v®
 
rocc
 = 
	$BoŞ
()

74 
v®
 
me
 = 
	$BoŞ
()

75 
v®
 
he
 = 
	$BoŞ
()

76 
v®
 
£
 = 
	$BoŞ
()

77 
v®
 
ue
 = 
	$BoŞ
()

78 
v®
 
mt
 = 
	$BoŞ
()

79 
v®
 
ht
 = 
	$BoŞ
()

80 
v®
 
¡
 = 
	$BoŞ
()

81 
v®
 
ut
 = 
	$BoŞ
()

82 
v®
 
ms
 = 
	$BoŞ
()

83 
v®
 
hs
 = 
	$BoŞ
()

84 
v®
 
ss
 = 
	$BoŞ
()

85 
v®
 
us
 = 
	`BoŞ
()

88 şas 
	cPTBR
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

89 
def
 
	`pgLev–sToMode
(
i
: 
IÁ
èğ(
xL’
, iè
m©ch
 {

91 (64, 
x
) x >= 3 && x <= 6 => x + 5

93 
	`v®
 (
modeB™s
, 
maxASIdB™s
èğ
xL’
 
m©ch
 {

96 
	}
}

97 
»quœe
(
modeB™s
 + 
maxASIdB™s
 + 
maxPAddrB™s
 - 
pgIdxB™s
 =ğ
xL’
)

99 
v®
 
mode
 = 
	$UIÁ
(
width
 = 
modeB™s
)

100 
v®
 
asid
 = 
	$UIÁ
(
width
 = 
maxASIdB™s
)

101 
v®
 
µn
 = 
	`UIÁ
(
width
 = 
maxPAddrB™s
 - 
pgIdxB™s
)

102 
	}
}

104 
objeù
 
	gPRV


106 
v®
 
	gSZ
 = 2

107 
v®
 
U
 = 0

108 
v®
 
S
 = 1

109 
v®
 
H
 = 2

110 
v®
 
M
 = 3

113 
objeù
 
	gCSR


116 
v®
 
	gSZ
 = 3

117 
def
 
X
 = 
B™P©
.
dÚtC¬e
(
SZ
)

118 
def
 
N
 = 
UIÁ
(0,
SZ
)

119 
def
 
	gR
 = 
UIÁ
(2,
SZ
)

120 
def
 
	gI
 = 
UIÁ
(4,
SZ
)

121 
def
 
	gW
 = 
UIÁ
(5,
SZ
)

122 
def
 
	gS
 = 
UIÁ
(6,
SZ
)

123 
def
 
	gC
 = 
UIÁ
(7,
SZ
)

126 
def
 
maskCmd
(
v®id
: 
BoŞ
, 
cmd
: 
UIÁ
): UInt = {

128 
cmd
 & ~
Mux
(
v®id
, 0.U, 
CSR
.
I
)

131 
v®
 
ADDRSZ
 = 12

132 
def
 
busE¼ÜIÁCau£
 = 128

133 
def
 
debugIÁCau£
 = 14

134 
def
 
debugTrigg”Cau£
 = {

135 
v®
 
»s
 = 
debugIÁCau£


136 
»quœe
(!(
Cau£s
.
®l
 
cÚšs
 
»s
))

137 
»s


140 
v®
 
	gfœ¡CŒ
 = 
CSRs
.
cyşe


141 
v®
 
fœ¡CŒH
 = 
CSRs
.
cyşeh


142 
v®
 
fœ¡HPC
 = 
CSRs
.
hpmcouÁ”3


143 
v®
 
fœ¡HPCH
 = 
CSRs
.
hpmcouÁ”3h


144 
v®
 
fœ¡HPE
 = 
CSRs
.
mhpmev’t3


145 
v®
 
fœ¡MHPC
 = 
CSRs
.
mhpmcouÁ”3


146 
v®
 
fœ¡MHPCH
 = 
CSRs
.
mhpmcouÁ”3h


147 
v®
 
fœ¡HPM
 = 3

148 
v®
 
nCŒ
 = 32

149 
v®
 
nHPM
 = 
nCŒ
 - 
fœ¡HPM


150 
v®
 
hpmWidth
 = 40

152 
v®
 
maxPMPs
 = 16

155 şas 
	cP”fCouÁ”IO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
CÜeBundË


156 
w™h
 
HasCÜeP¬am‘”s
 {

157 
v®
 
ev’tS–
 = 
	$UIÁ
(
OUTPUT
, 
xL’
)

158 
v®
 
šc
 = 
	`UIÁ
(
INPUT
, 
	`log2Ce
(1+
»tœeWidth
))

161 şas 
	cT¿ûdIn¡ruùiÚ
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
CÜeBundË
 {

162 
v®
 
v®id
 = 
	$BoŞ
()

163 
v®
 
Ÿddr
 = 
	$UIÁ
(
width
 = 
cÜeMaxAddrB™s
)

164 
v®
 
š¢
 = 
	$UIÁ
(
width
 = 
iL’
)

165 
v®
 
´iv
 = 
	$UIÁ
(
width
 = 3)

166 
v®
 
exû±iÚ
 = 
	$BoŞ
()

167 
v®
 
š‹¼u±
 = 
	$BoŞ
()

168 
v®
 
ÿu£
 = 
	`UIÁ
(
width
 = 
	`log2Ce
(1 + 
CSR
.
busE¼ÜIÁCau£
))

169 
v®
 
tv®
 = 
	`UIÁ
(
width
 = 
cÜeMaxAddrB™s
 
max
 
iL’
)

172 şas 
	cCSRDecodeIO
 
ex‹nds
 
BundË
 {

173 
v®
 
c¤
 = 
	$UIÁ
(
INPUT
, 
CSR
.
ADDRSZ
)

174 
v®
 
å_Ëg®
 = 
	$BoŞ
(
OUTPUT
)

175 
v®
 
å_c¤
 = 
	$BoŞ
(
OUTPUT
)

176 
v®
 
rocc_Ëg®
 = 
	$BoŞ
(
OUTPUT
)

177 
v®
 
»ad_Ëg®
 = 
	$BoŞ
(
OUTPUT
)

178 
v®
 
wr™e_Ëg®
 = 
	$BoŞ
(
OUTPUT
)

179 
v®
 
wr™e_æush
 = 
	$BoŞ
(
OUTPUT
)

180 
v®
 
sy¡em_Ëg®
 = 
	`BoŞ
(
OUTPUT
)

189 şas 
	cPCodeCSR
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

190 
	`»quœe
(
·ddrB™s
 > 12)

191 
v®
 
ba£
 = 
	`UIÁ
(
width
 = 
·ddrB™s
 - 12)

192 
v®
 
mask
 = 
	$UIÁ
(
width
 = 10)

193 
v®
 
v®id
 = 
	`BoŞ
()

197 şas 
	cPCodeUpd©e
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
CÜeBundË


198 
w™h
 
HasCÜeP¬am‘”s
 {

199 
v®
 
id
 = 
	`UIÁ
(
OUTPUT
, 
	$log2Ce
(
numPCodeRªges
))

200 
v®
 
v®ue
 = 
Ãw
 
	`PCodeCSR
().
asOuut


203 şas 
	cCSRFeIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
CÜeBundË


204 
w™h
 
HasCÜeP¬am‘”s
 {

205 
v®
 
ung©ed_şock
 = 
	`Clock
().
asIÅut


206 
v®
 
š‹¼u±s
 = 
Ãw
 
	`CÜeIÁ”ru±s
().
asIÅut


207 
v®
 
h¬tid
 = 
	$UIÁ
(
INPUT
, 
h¬tIdL’
)

208 
v®
 
rw
 = 
Ãw
 
BundË
 {

209 
v®
 
addr
 = 
	`UIÁ
(
INPUT
, 
CSR
.
ADDRSZ
)

210 
v®
 
cmd
 = 
	`B™s
(
INPUT
, 
CSR
.
SZ
)

211 
v®
 
rd©a
 = 
	`B™s
(
OUTPUT
, 
xL’
)

212 
v®
 
wd©a
 = 
	`B™s
(
INPUT
, 
xL’
)

217 
v®
 
pcode_»q
 = 
	$V®id
(
Ãw
 
PCodeUpd©e
)

218 
v®
 
pcode_»¥
 = 
	`V®id
(
Ãw
 
PCodeUpd©e
).
æ


221 
v®
 
decode
 = 
	$Vec
(
decodeWidth
, 
Ãw
 
CSRDecodeIO
)

223 
v®
 
c¤_¡®l
 = 
	$BoŞ
(
OUTPUT
)

224 
v®
 
”‘
 = 
	$BoŞ
(
OUTPUT
)

225 
v®
 
sšgËS‹p
 = 
	$BoŞ
(
OUTPUT
)

227 
v®
 
¡©us
 = 
Ãw
 
	`MStus
().
asOuut


228 
v®
 
±br
 = 
Ãw
 
	`PTBR
().
asOuut


229 
v®
 
evec
 = 
	$UIÁ
(
OUTPUT
, 
vaddrB™sEx‹nded
)

230 
v®
 
exû±iÚ
 = 
	$BoŞ
(
INPUT
)

231 
v®
 
»tœe
 = 
	`UIÁ
(
INPUT
, 
	`log2Up
(1+
»tœeWidth
))

232 
v®
 
ÿu£
 = 
	$UIÁ
(
INPUT
, 
xL’
)

233 
v®
 
pc
 = 
	$UIÁ
(
INPUT
, 
vaddrB™sEx‹nded
)

234 
v®
 
tv®
 = 
	$UIÁ
(
INPUT
, 
vaddrB™sEx‹nded
)

235 
v®
 
time
 = 
	$UIÁ
(
OUTPUT
, 
xL’
)

236 
v®
 
fc¤_rm
 = 
	$B™s
(
OUTPUT
, 
FPCÚ¡ªts
.
RM_SZ
)

237 
v®
 
fc¤_æags
 = 
	`V®id
(
	`B™s
(
width
 = 
FPCÚ¡ªts
.
FLAGS_SZ
)).
æ


238 
v®
 
£t_fs_dœty
 = 
cÜeP¬ams
.
haveFSDœty
.
	`İtiÚ
(
	$BoŞ
(
INPUT
))

239 
v®
 
rocc_š‹¼u±
 = 
	$BoŞ
(
INPUT
)

240 
v®
 
š‹¼u±
 = 
	$BoŞ
(
OUTPUT
)

241 
v®
 
š‹¼u±_ÿu£
 = 
	$UIÁ
(
OUTPUT
, 
xL’
)

242 
v®
 
bp
 = 
	`Vec
(
nB»akpošts
, 
Ãw
 
BP
).
asOuut


243 
v®
 
pmp
 = 
	`Vec
(
nPMPs
, 
Ãw
 
PMP
).
asOuut


244 
v®
 
couÁ”s
 = 
	$Vec
(
nP”fCouÁ”s
, 
Ãw
 
P”fCouÁ”IO
)

245 
v®
 
c¤w_couÁ”
 = 
	$UIÁ
(
OUTPUT
, 
CSR
.
nCŒ
)

246 
v®
 
š¡
 = 
	`Vec
(
»tœeWidth
, 
	`UIÁ
(
width
 = 
iL’
)).
asIÅut


247 
v®
 
Œaû
 = 
	`Vec
(
»tœeWidth
, 
Ãw
 
T¿ûdIn¡ruùiÚ
).
asOuut


248 
	}
}

250 
şass
 
CSRFe
(

251 
³rfEv’tS‘s
: 
Ev’tS‘s
 = 
Ãw
 Ev’tS‘s(
Seq
()),

252 
cu¡omCSRs
: 
Seq
[
Cu¡omCSR
] = 
N
)(
im¶ic™
 
p
: 
P¬am‘”s
)

253 
ex‹nds
 
	$CÜeModuË
()(
p
)

254 
w™h
 
HasCÜeP¬am‘”s
 {

255 
v®
 
io
 = 
Ãw
 
CSRFeIO
 {

256 
v®
 
cu¡omCSRs
 = 
	`Vec
(
CSRFe
.
this
.cu¡omCSRs.
size
, 
Ãw
 
Cu¡omCSRIO
).
asOuut


259 
v®
 
»£t_m¡©us
 = 
	`Wœe
(
š™
=
Ãw
 
	`MStus
().
	`äomB™s
(0))

260 
»£t_m¡©us
.
mµ
 :ğ
PRV
.
M


261 
»£t_m¡©us
.
´v
 :ğ
PRV
.
M


262 
v®
 
»g_m¡©us
 = 
	`Reg
(
š™
=
»£t_m¡©us
)

264 
v®
 
Ãw_´v
 = 
	`Wœe
(
š™
 = 
»g_m¡©us
.
´v
)

265 
»g_m¡©us
.
´v
 :ğ
	`Ëg®izePrivege
(
Ãw_´v
)

267 
v®
 
»£t_dc¤
 = 
	`Wœe
(
š™
=
Ãw
 
	`DCSR
().
	`äomB™s
(0))

268 
»£t_dc¤
.
xdebugv”
 := 1

269 
»£t_dc¤
.
´v
 :ğ
PRV
.
M


270 
v®
 
»g_dc¤
 = 
	`Reg
(
š™
=
»£t_dc¤
)

272 
	`v®
 (
suµÜ‹d_š‹¼u±s
, 
d–egabË_š‹¼u±s
) = {

273 
v®
 
sup
 = 
	`Wœe
(
Ãw
 
MIP
)

274 
sup
.
us
 :ğ
çl£


275 
sup
.
ss
 :ğ
	`BoŞ
(
usšgVM
)

276 
sup
.
hs
 :ğ
çl£


277 
sup
.
ms
 :ğ
Œue


278 
sup
.
ut
 :ğ
çl£


279 
sup
.
¡
 :ğ
	`BoŞ
(
usšgVM
)

280 
sup
.
ht
 :ğ
çl£


281 
sup
.
mt
 :ğ
Œue


282 
sup
.
ue
 :ğ
çl£


283 
sup
.
£
 :ğ
	`BoŞ
(
usšgVM
)

284 
sup
.
he
 :ğ
çl£


285 
sup
.
me
 :ğ
Œue


286 
sup
.
rocc
 :ğ
usšgRoCC


287 
sup
.
z”o1
 :ğ
çl£


288 
sup
.
debug
 :ğ
çl£


289 
sup
.
z”o2
 :ğ
çl£


290 
sup
.
l
 
fÜ—ch
 { 
_
 :ğ
Œue
 }

291 
v®
 
suµÜ‹d_high_š‹¼u±s
 = ià(
io
.
š‹¼u±s
.
bu£¼Ü
.
nÚEm±y
è
	`UIÁ
(
	`BigIÁ
(1è<< 
CSR
.
busE¼ÜIÁCau£
) 0.U

293 
v®
 
d–
 = 
	`Wœe
(
š™
=
sup
)

294 
d–
.
ms
 :ğ
çl£


295 
d–
.
mt
 :ğ
çl£


296 
d–
.
me
 :ğ
çl£


298 (
sup
.
asUIÁ
 | 
suµÜ‹d_high_š‹¼u±s
, 
d–
.asUInt)

300 
v®
 
d–egabË_exû±iÚs
 = 
	`UIÁ
(
	`Seq
(

301 
Cau£s
.
mi§ligÃd_ãtch
,

302 
Cau£s
.
ãtch_·ge_çuÉ
,

303 
Cau£s
.
b»akpošt
,

304 
Cau£s
.
lßd_·ge_çuÉ
,

305 
Cau£s
.
¡Üe_·ge_çuÉ
,

309 
Cau£s
.
u£r_eÿÎ
).
	`m­
(1 << 
_
).
sum
)

311 
v®
 
»g_debug
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

312 
v®
 
»g_dpc
 = 
	`Reg
(
	`UIÁ
(
width
 = 
vaddrB™sEx‹nded
))

313 
v®
 
»g_dsü©ch
 = 
	`Reg
(
	`UIÁ
(
width
 = 
xL’
))

314 
v®
 
»g_sšgËS‹µed
 = 
	`Reg
(
	`BoŞ
())

316 
v®
 
»g_t£Ëù
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Up
(
nB»akpošts
)))

317 
v®
 
»g_bp
 = 
	`Reg
(
	`Vec
(1 << 
	`log2Up
(
nB»akpošts
), 
Ãw
 
BP
))

318 
v®
 
»g_pmp
 = 
	`Reg
(
	`Vec
(
nPMPs
, 
Ãw
 
PMPReg
))

320 
v®
 
»g_m›
 = 
	`Reg
(
	`UIÁ
(
width
 = 
xL’
))

321 
v®
 
»g_mid–eg
 = 
	`Reg
(
	`UIÁ
(
width
 = 
xL’
))

322 
v®
 
»g_med–eg
 = 
	`Reg
(
	`UIÁ
(
width
 = 
xL’
))

323 
v®
 
»g_m
 = 
	`Reg
(
Ãw
 
MIP
)

324 
v®
 
»g_m•c
 = 
	`Reg
(
	`UIÁ
(
width
 = 
vaddrB™sEx‹nded
))

325 
v®
 
»g_mÿu£
 = 
	`Reg
(
	`B™s
(
width
 = 
xL’
))

326 
v®
 
»g_mbadaddr
 = 
	`Reg
(
	`UIÁ
(
width
 = 
vaddrB™sEx‹nded
))

327 
v®
 
»g_msü©ch
 = 
	`Reg
(
	`B™s
(
width
 = 
xL’
))

328 
v®
 
mtvecWidth
 = 
·ddrB™s
 
mš
 
xL’


329 
v®
 
»g_mtvec
 = 
mtvecIn™
 
m©ch
 {

330 
	`Some
(
addr
è=> 
	`Reg
(
š™
=
	`UIÁ
×ddr, 
mtvecWidth
))

331 
NÚe
 => 
	`Reg
(
	`UIÁ
(
width
 = 
mtvecWidth
))

333 
v®
 
»g_mcouÁ”’
 = 
	`Reg
(
	`UIÁ
(
width
 = 32))

334 
v®
 
»g_scouÁ”’
 = 
	`Reg
(
	`UIÁ
(
width
 = 32))

335 
v®
 
d–egabË_couÁ”s
 = (
	`BigIÁ
(1è<< (
nP”fCouÁ”s
 + 
CSR
.
fœ¡HPM
)) - 1

337 
v®
 
»g_£pc
 = 
	`Reg
(
	`UIÁ
(
width
 = 
vaddrB™sEx‹nded
))

338 
v®
 
»g_sÿu£
 = 
	`Reg
(
	`B™s
(
width
 = 
xL’
))

339 
v®
 
»g_sbadaddr
 = 
	`Reg
(
	`UIÁ
(
width
 = 
vaddrB™sEx‹nded
))

340 
v®
 
»g_ssü©ch
 = 
	`Reg
(
	`B™s
(
width
 = 
xL’
))

341 
v®
 
»g_¡vec
 = 
	`Reg
(
	`UIÁ
(
width
 = 
vaddrB™s
))

342 
v®
 
»g_¥tbr
 = 
	`Reg
(
Ãw
 
PTBR
)

343 
v®
 
»g_wfi
 = 
	`w™hClock
(
io
.
ung©ed_şock
è{ 
	`Reg
(
š™
=
	`BoŞ
(
çl£
)) }

345 
v®
 
»g_fæags
 = 
	`Reg
(
	`UIÁ
(
width
 = 5))

346 
v®
 
»g_äm
 = 
	`Reg
(
	`UIÁ
(
width
 = 3))

348 
v®
 
»g_š¡»t
 = 
	`WideCouÁ”
(64, 
io
.
»tœe
)

349 
v®
 
»g_cyşe
 = ià(
’abËComm™Log
è
»g_š¡»t
 
	`w™hClock
(
io
.
ung©ed_şock
è{ 
	`WideCouÁ”
(64, !
»g_wfi
) }

350 
v®
 
»g_hpmev’t
 = 
io
.
couÁ”s
.
	`m­
(
c
 => 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
xL’
)))

351 (
io
.
couÁ”s
 
z
 
»g_hpmev’t
è
fÜ—ch
 { (
c
, 
e
è=> c.
ev’tS–
 :=ƒ }

352 
v®
 
»g_hpmcouÁ”
 = 
io
.
couÁ”s
.
	`m­
(
c
 => 
	`WideCouÁ”
(
CSR
.
hpmWidth
, c.
šc
, 
»£t
 = 
çl£
))

354 
v®
 
m
 = 
	`Wœe
(
š™
=
»g_m
)

355 
m
.
l
 :ğ(
io
.
š‹¼u±s
.l: 
Seq
[
BoŞ
])

356 
m
.
mt
 :ğ
io
.
š‹¼u±s
.mtip

357 
m
.
ms
 :ğ
io
.
š‹¼u±s
.msip

358 
m
.
me
 :ğ
io
.
š‹¼u±s
.meip

360 
io
.
š‹¼u±s
.
£
.
fÜ—ch
 { 
m
.£ :ğ
»g_m
.£ || 
	`RegNext
(
_
) }

361 
m
.
rocc
 :ğ
io
.
rocc_š‹¼u±


362 
v®
 
»ad_m
 = 
m
.
asUIÁ
 & 
suµÜ‹d_š‹¼u±s


363 
v®
 
high_š‹¼u±s
 = 
io
.
š‹¼u±s
.
bu£¼Ü
.
	`m­
(
_
 << 
CSR
.
busE¼ÜIÁCau£
).
	`g‘OrEl£
(0.U)

365 
v®
 
³ndšg_š‹¼u±s
 = 
high_š‹¼u±s
 | (
»ad_m
 & 
»g_m›
)

366 
v®
 
d_š‹¼u±s
 = 
io
.
š‹¼u±s
.
debug
 << 
CSR
.
debugIÁCau£


367 
v®
 
m_š‹¼u±s
 = 
	`Mux
(
»g_m¡©us
.
´v
 <ğ
PRV
.
S
 ||„eg_m¡©us.
m›
, ~(~
³ndšg_š‹¼u±s
 | 
»g_mid–eg
), 
	`UIÁ
(0))

368 
v®
 
s_š‹¼u±s
 = 
	`Mux
(
»g_m¡©us
.
´v
 < 
PRV
.
S
 || (»g_m¡©us.´v ==ğPRV.S &&„eg_m¡©us.
s›
), 
³ndšg_š‹¼u±s
 & 
»g_mid–eg
, 
	`UIÁ
(0))

369 
	`v®
 (
ªyIÁ”ru±
, 
whichIÁ”ru±
èğ
	`choo£IÁ”ru±
(
	`Seq
(
s_š‹¼u±s
, 
m_š‹¼u±s
, 
d_š‹¼u±s
))

370 
v®
 
š‹¼u±MSB
 = 
	`BigIÁ
(1è<< (
xL’
-1)

371 
v®
 
š‹¼u±Cau£
 = 
	`UIÁ
(
š‹¼u±MSB
è+ 
whichIÁ”ru±


372 
io
.
š‹¼u±
 :ğ(
ªyIÁ”ru±
 && !io.
sšgËS‹p
 || 
»g_sšgËS‹µed
è&& !
»g_debug


373 
io
.
š‹¼u±_ÿu£
 :ğ
š‹¼u±Cau£


374 
io
.
bp
 :ğ
»g_bp
 
ke
 
nB»akpošts


375 
io
.
pmp
 :ğ
»g_pmp
.
	`m­
(
	`PMP
(
_
))

377 
v®
 
i§MaskSŒšg
 =

378 (ià(
usšgMulDiv
) "M" "") +

379 (ià(
usšgAtomics
) "A" "") +

380 (ià(
fL’
 >= 32) "F" "") +

381 (ià(
fL’
 >= 64) "D" "") +

382 (ià(
usšgCom´es£d
) "C" "") +

383 (ià(
usšgRoCC
) "X" "")

384 
v®
 
i§SŒšg
 = "I" + 
i§MaskSŒšg
 +

385 (ià(
usšgVM
) "S" "") +

386 (ià(
usšgU£r
) "U" "")

387 
v®
 
i§Max
 = (
	`BigIÁ
(
	`log2Ce
(
xL’
è- 4è<< (xL’-2)è| 
	`i§SŒšgToMask
(
i§SŒšg
)

388 
v®
 
»g_mi§
 = 
	`Reg
(
š™
=
	`UIÁ
(
i§Max
))

389 
v®
 
»ad_m¡©us
 = 
io
.
¡©us
.
	`asUIÁ
()(
xL’
-1,0)

391 
v®
 
»ad_m­pšg
 = 
LškedHashM­
[
IÁ
,
B™s
](

392 
CSRs
.
t£Ëù
 -> 
»g_t£Ëù
,

393 
CSRs
.
td©a1
 -> 
	`»g_bp
(
»g_t£Ëù
).
cÚŒŞ
.
asUIÁ
,

394 
CSRs
.
td©a2
 -> 
	`»g_bp
(
»g_t£Ëù
).
add»ss
.
	`£xtTo
(
xL’
),

395 
CSRs
.
mi§
 -> 
»g_mi§
,

396 
CSRs
.
m¡©us
 -> 
»ad_m¡©us
,

397 
CSRs
.
mtvec
 -> 
»g_mtvec
,

398 
CSRs
.
m
 -> 
»ad_m
,

399 
CSRs
.
m›
 -> 
»g_m›
,

400 
CSRs
.
msü©ch
 -> 
»g_msü©ch
,

401 
CSRs
.
m•c
 -> 
	`»adEPC
(
»g_m•c
).
	`£xtTo
(
xL’
),

402 
CSRs
.
mbadaddr
 -> 
»g_mbadaddr
.
	`£xtTo
(
xL’
),

403 
CSRs
.
mÿu£
 -> 
»g_mÿu£
,

404 
CSRs
.
mh¬tid
 -> 
io
.
h¬tid
)

406 
v®
 
debug_c¤s
 = 
LškedHashM­
[
IÁ
,
B™s
](

407 
CSRs
.
dc¤
 -> 
»g_dc¤
.
asUIÁ
,

408 
CSRs
.
dpc
 -> 
	`»adEPC
(
»g_dpc
).
	`£xtTo
(
xL’
),

409 
CSRs
.
dsü©ch
 -> 
»g_dsü©ch
.
asUIÁ
)

411 
v®
 
å_c¤s
 = 
LškedHashM­
[
IÁ
,
B™s
](

412 
CSRs
.
fæags
 -> 
»g_fæags
,

413 
CSRs
.
äm
 -> 
»g_äm
,

414 
CSRs
.
fc¤
 -> 
	`C©
(
»g_äm
, 
»g_fæags
))

416 ià(
usšgDebug
)

417 
»ad_m­pšg
 ++ğ
debug_c¤s


419 ià(
usšgFPU
)

420 
»ad_m­pšg
 ++ğ
å_c¤s


422 ià(
cÜeP¬ams
.
haveBasicCouÁ”s
) {

423 
»ad_m­pšg
 +ğ
CSRs
.
mcyşe
 -> 
»g_cyşe


424 
»ad_m­pšg
 +ğ
CSRs
.
mš¡»t
 -> 
»g_š¡»t


426 ((
e
, 
c
), 
i
è<- (
»g_hpmev’t
.
	`·dTo
(
CSR
.
nHPM
, 
	`UIÁ
(0))

427 
z
 
»g_hpmcouÁ”
.
	`m­
(
x
 => x: 
UIÁ
).
	`·dTo
(
CSR
.
nHPM
, 
	`UIÁ
(0))è
zW™hIndex
) {

428 
»ad_m­pšg
 +ğ(
i
 + 
CSR
.
fœ¡HPE
è-> 
e


429 
»ad_m­pšg
 +ğ(
i
 + 
CSR
.
fœ¡MHPC
è-> 
c


430 ià(
usšgU£r
è
»ad_m­pšg
 +ğ(
i
 + 
CSR
.
fœ¡HPC
è-> 
c


431 ià(
xL’
 == 32) {

432 
»ad_m­pšg
 +ğ(
i
 + 
CSR
.
fœ¡MHPCH
è-> 
c


433 ià(
usšgU£r
è
»ad_m­pšg
 +ğ(
i
 + 
CSR
.
fœ¡HPCH
è-> 
c


437 ià(
usšgU£r
) {

438 
»ad_m­pšg
 +ğ
CSRs
.
mcouÁ”’
 -> 
»g_mcouÁ”’


439 
»ad_m­pšg
 +ğ
CSRs
.
cyşe
 -> 
»g_cyşe


440 
»ad_m­pšg
 +ğ
CSRs
.
š¡»t
 -> 
»g_š¡»t


443 ià(
xL’
 == 32) {

444 
»ad_m­pšg
 +ğ
CSRs
.
mcyşeh
 -> (
»g_cyşe
 >> 32)

445 
»ad_m­pšg
 +ğ
CSRs
.
mš¡»th
 -> (
»g_š¡»t
 >> 32)

446 ià(
usšgU£r
) {

447 
»ad_m­pšg
 +ğ
CSRs
.
cyşeh
 -> (
»g_cyşe
 >> 32)

448 
»ad_m­pšg
 +ğ
CSRs
.
š¡»th
 -> (
»g_š¡»t
 >> 32)

462 
v®
 
pcode_»gs
 = 
	`Reg
(
š™
=
Vec
.
	`fl
(
numPCodeRªges
){
Ãw
 
	`PCodeCSR
().
	`äomB™s
(0)})

463 
def
 
pcode_c¤s
 = 
	`Seq
(

464 
CSRs
.
¥cod”ªge0


465 ,
CSRs
.
¥cod”ªge1


466 ,
CSRs
.
¥cod”ªge2


467 ,
CSRs
.
¥cod”ªge3


470 
v®
 
pcode_upd©e
 = 
	`Reg
(
	`V®id
(
Ãw
 
PCodeUpd©e
))

471 
v®
 
pcode_upd©e_»¥
 = 
	`Wœe
(
	`V®id
(
Ãw
 
PCodeUpd©e
))

473 
	`´šn
(
s
"hasPrivCodeLock: ${hasPrivCodeLock}")

474 ià(
hasPrivCodeLock
) {

476 
	`»quœe
(
numPCodeRªges
 <ğ4 &&‚umPCodeRªge <ğ
pcode_c¤s
.
Ëngth
)

478 
pcode_upd©e_»¥
 :ğ
io
.
pcode_»¥


479 
io
.
pcode_»q
 :ğ
pcode_upd©e


481 
	`wh’
(
pcode_upd©e_»¥
.
v®id
) {

482 
	`pcode_»gs
(
pcode_upd©e_»¥
.
b™s
.
id
è:ğpcode_upd©e_»¥.b™s.
v®ue


486 
c¤_id
 <- 
pcode_c¤s
) {

487 
»ad_m­pšg
 +ğ
c¤_id
 -> (

489 
v®
 
r
 = 
	`pcode_»gs
(
c¤_id
 & 3)

490 
	`C©
(
r
.
ba£
,„.
mask
,„.
v®id
,„.
locked
)

501 ià(
usšgVM
) {

502 
v®
 
»ad_s›
 = 
»g_m›
 & 
»g_mid–eg


503 
v®
 
»ad_s
 = 
»ad_m
 & 
»g_mid–eg


504 
v®
 
»ad_s¡©us
 = 
	`Wœe
(
š™
 = 0.U.a
	`sTy³Of
(
Ãw
 
MStus
))

505 
»ad_s¡©us
.
sd
 :ğ
io
.
¡©us
.sd

506 
»ad_s¡©us
.
uxl
 :ğ
io
.
¡©us
.uxl

507 
»ad_s¡©us
.
sd_rv32
 :ğ
io
.
¡©us
.sd_rv32

508 
»ad_s¡©us
.
mxr
 :ğ
io
.
¡©us
.mxr

509 
»ad_s¡©us
.
sum
 :ğ
io
.
¡©us
.sum

510 
»ad_s¡©us
.
xs
 :ğ
io
.
¡©us
.xs

511 
»ad_s¡©us
.
fs
 :ğ
io
.
¡©us
.fs

512 
»ad_s¡©us
.
¥p
 :ğ
io
.
¡©us
.spp

513 
»ad_s¡©us
.
¥›
 :ğ
io
.
¡©us
.spie

514 
»ad_s¡©us
.
s›
 :ğ
io
.
¡©us
.sie

516 
»ad_m­pšg
 +ğ
CSRs
.
s¡©us
 -> (
»ad_s¡©us
.
	`asUIÁ
())(
xL’
-1,0)

517 
»ad_m­pšg
 +ğ
CSRs
.
s
 -> 
»ad_s
.
asUIÁ


518 
»ad_m­pšg
 +ğ
CSRs
.
s›
 -> 
»ad_s›
.
asUIÁ


519 
»ad_m­pšg
 +ğ
CSRs
.
ssü©ch
 -> 
»g_ssü©ch


520 
»ad_m­pšg
 +ğ
CSRs
.
sÿu£
 -> 
»g_sÿu£


521 
»ad_m­pšg
 +ğ
CSRs
.
sbadaddr
 -> 
»g_sbadaddr
.
	`£xtTo
(
xL’
)

522 
»ad_m­pšg
 +ğ
CSRs
.
¥tbr
 -> 
»g_¥tbr
.
asUIÁ


523 
»ad_m­pšg
 +ğ
CSRs
.
£pc
 -> 
	`»adEPC
(
»g_£pc
).
	`£xtTo
(
xL’
)

524 
»ad_m­pšg
 +ğ
CSRs
.
¡vec
 -> 
»g_¡vec
.
	`£xtTo
(
xL’
)

525 
»ad_m­pšg
 +ğ
CSRs
.
scouÁ”’
 -> 
»g_scouÁ”’


526 
»ad_m­pšg
 +ğ
CSRs
.
mid–eg
 -> 
»g_mid–eg


527 
»ad_m­pšg
 +ğ
CSRs
.
med–eg
 -> 
»g_med–eg


530 
v®
 
pmpCfgP”CSR
 = 
xL’
 / 
Ãw
 
	`PMPCÚfig
().
g‘Width


531 
def
 
	`pmpCfgIndex
(
i
: 
IÁ
èğ(
xL’
 / 32è* (˜/ 
pmpCfgP”CSR
)

532 ià(
»g_pmp
.
nÚEm±y
) {

533 
	`»quœe
(
»g_pmp
.
size
 <ğ
CSR
.
maxPMPs
)

534 
v®
 
»ad_pmp
 = 
»g_pmp
.
	`·dTo
(
CSR
.
maxPMPs
, 0.U.a
	`sTy³Of
(
Ãw
 
PMP
))

535 
i
 <- 0 
uÁ
 
»ad_pmp
.
size
 
by
 
pmpCfgP”CSR
)

536 
»ad_m­pšg
 +ğ(
CSRs
.
pmpcfg0
 + 
	`pmpCfgIndex
(
i
)è-> 
»ad_pmp
.
	`m­
(
_
.
cfg
).
	`¦iû
(i, i + 
pmpCfgP”CSR
).
asUIÁ


537 (
pmp
, 
i
è<- 
»ad_pmp
 
zW™hIndex
)

538 
»ad_m­pšg
 +ğ(
CSRs
.
pm·ddr0
 + 
i
è-> 
pmp
.
»adAddr


542 
v®
 
»g_cu¡om
 = 
cu¡omCSRs
.
m­
 { 
c¤
 =>

543 
	`»quœe
(
c¤
.
mask
 >ğ0 && c¤.mask.
b™L’gth
 <ğ
xL’
)

544 
	`»quœe
(!
»ad_m­pšg
.
	`cÚšs
(
c¤
.
id
))

545 
v®
 
»g
 = 
c¤
.
š™
.
	`m­
(š™ => 
	`RegIn™
(š™.
	`U
(
xL’
.
W
))).
	`g‘OrEl£
(
	`Reg
(
	`UIÁ
(xLen.W)))

546 
»ad_m­pšg
 +ğ
c¤
.
id
 -> 
»g


547 
»g


551 
	`Seq
(
CSRs
.
mimpid
, CSRs.
m¬chid
, CSRs.
mv’dÜid
).
	`fÜ—ch
(
id
 => 
»ad_m­pšg
.
	`g‘OrEl£Upd©e
(id, 0.U))

553 
v®
 
decoded_addr
 = 
»ad_m­pšg
 
m­
 { (
k
, 
v
è=> k -> (
io
.
rw
.
addr
 === k) }

554 
v®
 
wd©a
 = 
	`»adModifyWr™eCSR
(
io
.
rw
.
cmd
, io.rw.
rd©a
, io.rw.wdata)

556 
v®
 
sy¡em_š¢
 = 
io
.
rw
.
cmd
 ==ğ
CSR
.
I


557 
v®
 
decode_bË
 = 
	`Seq
(

558 
SCALL
-> 
	`Li¡
(
Y
,
N
,N,N,N),

559 
SBREAK
-> 
	`Li¡
(
N
,
Y
,N,N,N),

560 
MRET
-> 
	`Li¡
(
N
,N,
Y
,N,N),

561 
WFI
-> 
	`Li¡
(
N
,N,N,
Y
,N)è++ (ià(
usšgDebug
è
	`Seq
(

562 
DRET
-> 
	`Li¡
(
N
,N,
Y
,N,N)è
	`Seq
()è++ (ià(
usšgVM
) Seq(

563 
SRET
-> 
	`Li¡
(
N
,N,
Y
,N,N),

564 
SFENCE_VMA
->
	`Li¡
(
N
,N,N,N,
Y
)è
	`Seq
())

565 
v®
 
š¢_ÿÎ
::
š¢_b»ak
::
š¢_»t
::
š¢_wfi
::
š¢_sãnû
::
N
 = 
	`DecodeLogic
(
io
.
rw
.
addr
 << 20, 
	`decode_bË
(0).
_2
.
	`m­
(
x
=>
X
), 
decode_bË
).m­(
sy¡em_š¢
 && 
_
.
toBoŞ
)

567 
io_dec
 <- 
io
.
decode
) {

568 
v®
 
is_ÿÎ
::
is_b»ak
::
is_»t
::
is_wfi
::
is_sãnû
::
N
 = 
	`DecodeLogic
(
io_dec
.
c¤
 << 20, 
	`decode_bË
(0).
_2
.
	`m­
(
x
=>
X
), 
decode_bË
).m­(
_
.
toBoŞ
)

569 
def
 
	`decodeAny
(
m
: 
LškedHashM­
[
IÁ
,
B™s
]): 
BoŞ
 = m.
m­
 { (
k
: IÁ, 
_
: B™sè=> 
io_dec
.
c¤
 ==ğk }.
	`»duû
(_||_)

570 
v®
 
®low_wfi
 = 
	`BoŞ
(!
usšgVM
è|| 
»g_m¡©us
.
´v
 > 
PRV
.
S
 || !»g_m¡©us.
tw


571 
v®
 
®low_sãnû_vma
 = 
	`BoŞ
(!
usšgVM
è|| 
»g_m¡©us
.
´v
 > 
PRV
.
S
 || !»g_m¡©us.
tvm


572 
v®
 
®low_¤‘
 = 
	`BoŞ
(!
usšgVM
è|| 
»g_m¡©us
.
´v
 > 
PRV
.
S
 || !»g_m¡©us.
t¤


573 
v®
 
couÁ”_addr
 = 
io_dec
.
	`c¤
(
	`log2Ce
(
»g_mcouÁ”’
.
g‘Width
)-1, 0)

574 
v®
 
®low_couÁ”
 = (
»g_m¡©us
.
´v
 > 
PRV
.
S
 || 
	`»g_mcouÁ”’
(
couÁ”_addr
)) &&

575 (!
usšgVM
 || 
»g_m¡©us
.
´v
 >ğ
PRV
.
S
 || 
	`»g_scouÁ”’
(
couÁ”_addr
))

576 
io_dec
.
å_Ëg®
 :ğ
io
.
¡©us
.
fs
 ==ğ0 || !
	`»g_mi§
('f'-'a')

577 
io_dec
.
å_c¤
 :ğ
	`BoŞ
(
usšgFPU
è&& 
	`DecodeLogic
(io_dec.
c¤
, 
å_c¤s
.
keys
.
toLi¡
.
	`m­
(
_
.
U
), (
»ad_m­pšg
 -- fp_csrs.keys.toList).keys.toList.map(_.U))

578 
io_dec
.
rocc_Ëg®
 :ğ
io
.
¡©us
.
xs
 ==ğ0 || !
	`»g_mi§
('x'-'a')

579 
io_dec
.
»ad_Ëg®
 :ğ
»g_m¡©us
.
´v
 < io_dec.
	`c¤
(9,8) ||

580 !
	`decodeAny
(
»ad_m­pšg
) ||

581 
io_dec
.
c¤
 ==ğ
CSRs
.
¥tbr
 && !
®low_sãnû_vma
 ||

582 (
io_dec
.
c¤
.
	`šRªge
(
CSR
.
fœ¡CŒ
, CSR.fœ¡CŒ + CSR.
nCŒ
è|| io_dec.c¤.šRªge(CSR.
fœ¡CŒH
, CSR.fœ¡CŒH + CSR.nCŒ)è&& !
®low_couÁ”
 ||

583 
	`BoŞ
(
usšgDebug
è&& 
	`decodeAny
(
debug_c¤s
è&& !
»g_debug
 ||

584 
io_dec
.
å_c¤
 && io_dec.
å_Ëg®


585 
io_dec
.
wr™e_Ëg®
 :ğio_dec.
	`c¤
(11,10).
ªdR


586 
io_dec
.
wr™e_æush
 :ğ!(io_dec.
c¤
 >ğ
CSRs
.
msü©ch
 && io_dec.c¤ <ğCSRs.
mbadaddr
 || io_dec.c¤ >ğCSRs.
ssü©ch
 && io_dec.c¤ <ğCSRs.
sbadaddr
)

587 
io_dec
.
sy¡em_Ëg®
 :ğ
»g_m¡©us
.
´v
 < io_dec.
	`c¤
(9,8) ||

588 
is_wfi
 && !
®low_wfi
 ||

589 
is_»t
 && !
®low_¤‘
 ||

590 
is_sãnû
 && !
®low_sãnû_vma


593 
v®
 
ÿu£
 =

594 
	`Mux
(
š¢_ÿÎ
, 
»g_m¡©us
.
´v
 + 
Cau£s
.
u£r_eÿÎ
,

595 
Mux
[
UIÁ
](
š¢_b»ak
, 
Cau£s
.
b»akpošt
, 
io
.
ÿu£
))

596 
v®
 
ÿu£_lsbs
 = 
	`ÿu£
(
io
.
Œaû
.
h—d
.
ÿu£
.
g‘Width
-1, 0)

597 
v®
 
ÿu£IsDebugIÁ
 = 
	`ÿu£
(
xL’
-1è&& 
ÿu£_lsbs
 ==ğ
CSR
.
debugIÁCau£


598 
v®
 
ÿu£IsDebugTrigg”
 = !
	`ÿu£
(
xL’
-1è&& 
ÿu£_lsbs
 ==ğ
CSR
.
debugTrigg”Cau£


599 
v®
 
ÿu£IsDebugB»ak
 = !
	`ÿu£
(
xL’
-1è&& 
š¢_b»ak
 && 
	`C©
(
»g_dc¤
.
eb»akm
,„eg_dc¤.
eb»akh
,„eg_dc¤.
eb»aks
,„eg_dc¤.
eb»aku
)(
»g_m¡©us
.
´v
)

600 
v®
 
Œ­ToDebug
 = 
	`BoŞ
(
usšgDebug
è&& (
»g_sšgËS‹µed
 || 
ÿu£IsDebugIÁ
 || 
ÿu£IsDebugTrigg”
 || 
ÿu£IsDebugB»ak
 || 
»g_debug
)

601 
v®
 
debugTVec
 = 
	`Mux
(
»g_debug
, Mux(
š¢_b»ak
, 
	`UIÁ
(0x800), UInt(0x808)), UInt(0x800))

602 
v®
 
d–eg©e
 = 
	`BoŞ
(
usšgVM
è&& 
»g_m¡©us
.
´v
 <ğ
PRV
.
S
 && 
	`Mux
(
	`ÿu£
(
xL’
-1), 
	`»g_mid–eg
(
ÿu£_lsbs
), 
	`»g_med–eg
(cause_lsbs))

603 
v®
 
mtvecBa£Align
 = 2

604 
v®
 
mtvecIÁ”ru±Align
 = {

605 
	`»quœe
(
»g_m
.
g‘Width
 <ğ
xL’
)

606 
	`log2Ce
(
xL’
)

608 
v®
 
nÙDebugTVec
 = {

609 
v®
 
ba£
 = 
	`Mux
(
d–eg©e
, 
»g_¡vec
.
	`£xtTo
(
vaddrB™sEx‹nded
), 
»g_mtvec
)

610 
v®
 
š‹¼u±Off£t
 = 
	`ÿu£
(
mtvecIÁ”ru±Align
-1, 0è<< 
mtvecBa£Align


611 
v®
 
š‹¼u±Vec
 = 
	`C©
(
ba£
 >> (
mtvecIÁ”ru±Align
 + 
mtvecBa£Align
), 
š‹¼u±Off£t
)

612 
v®
 
doVeùÜ
 = 
	`ba£
(0è&& 
	`ÿu£
(
ÿu£
.
g‘Width
-1è&& (
ÿu£_lsbs
 >> 
mtvecIÁ”ru±Align
) === 0

613 
	`Mux
(
doVeùÜ
, 
š‹¼u±Vec
, 
ba£
)

615 
v®
 
tvec
 = 
	`Mux
(
Œ­ToDebug
, 
debugTVec
, 
nÙDebugTVec
)

616 
io
.
evec
 :ğ
tvec


617 
io
.
±br
 :ğ
»g_¥tbr


618 
io
.
”‘
 :ğ
š¢_ÿÎ
 || 
š¢_b»ak
 || 
š¢_»t


619 
io
.
sšgËS‹p
 :ğ
»g_dc¤
.
¡•
 && !
»g_debug


620 
io
.
¡©us
 :ğ
»g_m¡©us


621 
io
.
¡©us
.
sd
 :ğio.¡©us.
fs
.
ªdR
 || io.¡©us.
xs
.andR

622 
io
.
¡©us
.
debug
 :ğ
»g_debug


623 
io
.
¡©us
.
i§
 :ğ
»g_mi§


624 
io
.
¡©us
.
uxl
 :ğ(ià(
usšgU£r
è
	`log2Ce
(
xL’
) - 4 0)

625 
io
.
¡©us
.
sxl
 :ğ(ià(
usšgVM
è
	`log2Ce
(
xL’
) - 4 0)

626 
io
.
¡©us
.
d´v
 :ğ
	`Reg
(
Ãxt
 = 
	`Mux
(
»g_m¡©us
.
m´v
 && !
»g_debug
,„eg_m¡©us.
mµ
,„eg_m¡©us.
´v
))

627 ià(
xL’
 == 32)

628 
io
.
¡©us
.
sd_rv32
 :ğio.¡©us.
sd


630 
v®
 
exû±iÚ
 = 
š¢_ÿÎ
 || 
š¢_b»ak
 || 
io
.exception

631 
	`as£¹
(
	`PİCouÁ
(
š¢_»t
 :: 
š¢_ÿÎ
 :: 
š¢_b»ak
 :: 
io
.
exû±iÚ
 :: 
N
) <= 1, "these conditions must be mutuallyƒxclusive")

633 
	`wh’
 (
š¢_wfi
 && !
io
.
sšgËS‹p
 && !
»g_debug
è{ 
»g_wfi
 :ğ
Œue
 }

634 
	`wh’
 (
³ndšg_š‹¼u±s
.
ÜR
 || 
io
.
š‹¼u±s
.
debug
 || 
exû±iÚ
è{ 
»g_wfi
 :ğ
çl£
 }

636 
	`wh’
 (
io
.
	`»tœe
(0è|| 
exû±iÚ
è{ 
»g_sšgËS‹µed
 :ğ
Œue
 }

637 
	`wh’
 (!
io
.
sšgËS‹p
è{ 
»g_sšgËS‹µed
 :ğ
çl£
 }

638 
	`as£¹
(!
io
.
sšgËS‹p
 || io.
»tœe
 <ğ
	`UIÁ
(1))

639 
	`as£¹
(!
»g_sšgËS‹µed
 || 
io
.
»tœe
 ==ğ
	`UIÁ
(0))

641 
v®
 
•c
 = 
	`fÜmEPC
(
io
.
pc
)

642 
v®
 
noCau£
 :: 
mCau£
 :: 
hCau£
 :: 
sCau£
 :: 
uCau£
 :: 
N
 = 
	`Enum
(5)

643 
v®
 
xÿu£_de¡
 = 
	`Wœe
(
š™
 = 
noCau£
)

645 
	`wh’
 (
exû±iÚ
) {

646 
	`wh’
 (
Œ­ToDebug
) {

647 
	`wh’
 (!
»g_debug
) {

648 
»g_debug
 :ğ
Œue


649 
»g_dpc
 :ğ
•c


650 
»g_dc¤
.
ÿu£
 :ğ
	`Mux
(
»g_sšgËS‹µed
, 4, Mux(
ÿu£IsDebugIÁ
, 3, 
Mux
[
UIÁ
](
ÿu£IsDebugTrigg”
, 2, 1)))

651 
»g_dc¤
.
´v
 :ğ
	`ŒimPrivege
(
»g_m¡©us
.prv)

652 
Ãw_´v
 :ğ
PRV
.
M


654 }.
	`–£wh’
 (
d–eg©e
) {

655 
»g_£pc
 :ğ
•c


656 
»g_sÿu£
 :ğ
ÿu£


657 
xÿu£_de¡
 :ğ
sCau£


658 
»g_sbadaddr
 :ğ
io
.
tv®


659 
»g_m¡©us
.
¥›
 :ğ»g_m¡©us.
s›


660 
»g_m¡©us
.
¥p
 :ğ»g_m¡©us.
´v


661 
»g_m¡©us
.
s›
 :ğ
çl£


662 
Ãw_´v
 :ğ
PRV
.
S


663 }.
Ùh”wi£
 {

664 
»g_m•c
 :ğ
•c


665 
»g_mÿu£
 :ğ
ÿu£


666 
xÿu£_de¡
 :ğ
mCau£


667 
»g_mbadaddr
 :ğ
io
.
tv®


668 
»g_m¡©us
.
mp›
 :ğ»g_m¡©us.
m›


669 
»g_m¡©us
.
mµ
 :ğ
	`ŒimPrivege
Ôeg_m¡©us.
´v
)

670 
»g_m¡©us
.
m›
 :ğ
çl£


671 
Ãw_´v
 :ğ
PRV
.
M


675 
i
 <- 0 
uÁ
 
suµÜ‹d_š‹¼u±s
.
g‘Width
) {

676 
v®
 
’
 = 
exû±iÚ
 && (
suµÜ‹d_š‹¼u±s
 & (
	`BigIÁ
(1è<< 
i
).
U
è=/ğ0 && 
ÿu£
 ==ğ(BigIÁ(1è<< (
xL’
 - 1)).U + i

677 
v®
 
d–egabË
 = (
d–egabË_š‹¼u±s
 & (
	`BigIÁ
(1è<< 
i
).
U
) =/= 0

678 
	`cov”
(
’
, 
s
"INTERRUPT_M_$i")

679 
	`cov”
(
’
 && 
d–egabË
 && 
d–eg©e
, 
s
"INTERRUPT_S_$i")

681 
i
 <- 0 
uÁ
 
xL’
) {

682 
v®
 
suµÜ‹d_exû±iÚs
 = 0x87e |

683 (ià(
usšgCom´es£d
 && !
cÜeP¬ams
.
mi§Wr™abË
) 0 1) |

684 (ià(
usšgU£r
) 0x100 0) |

685 (ià(
usšgVM
) 0xb200 0)

686 ià(((
suµÜ‹d_exû±iÚs
 >> 
i
) & 1) != 0) {

687 
v®
 
’
 = 
exû±iÚ
 && 
ÿu£
 ==ğ
i


688 
	`cov”
(
’
, 
s
"EXCEPTION_M_$i")

689 
	`cov”
(
’
 && 
d–eg©e
, 
s
"EXCEPTION_S_$i")

693 
	`wh’
 (
š¢_»t
) {

694 
	`wh’
 (
	`BoŞ
(
usšgVM
è&& !
io
.
rw
.
	`addr
(9)) {

695 
»g_m¡©us
.
s›
 :ğ»g_m¡©us.
¥›


696 
»g_m¡©us
.
¥›
 :ğ
Œue


697 
»g_m¡©us
.
¥p
 :ğ
PRV
.
U


698 
Ãw_´v
 :ğ
»g_m¡©us
.
¥p


699 
io
.
evec
 :ğ
	`»adEPC
(
»g_£pc
)

700 }.
	`–£wh’
 (
	`BoŞ
(
usšgDebug
è&& 
io
.
rw
.
	`addr
(10)) {

701 
Ãw_´v
 :ğ
»g_dc¤
.
´v


702 
»g_debug
 :ğ
çl£


703 
io
.
evec
 :ğ
	`»adEPC
(
»g_dpc
)

704 }.
Ùh”wi£
 {

705 
»g_m¡©us
.
m›
 :ğ»g_m¡©us.
mp›


706 
»g_m¡©us
.
mp›
 :ğ
Œue


707 
»g_m¡©us
.
mµ
 :ğ
	`Ëg®izePrivege
(
PRV
.
U
)

708 
Ãw_´v
 :ğ
»g_m¡©us
.
mµ


709 
io
.
evec
 :ğ
	`»adEPC
(
»g_m•c
)

713 
io
.
time
 :ğ
»g_cyşe


714 
io
.
c¤_¡®l
 :ğ
»g_wfi


716 (
io
, 
»g
è<- io.
cu¡omCSRs
 
z
 
»g_cu¡om
) {

717 
io
.
w’
 :ğ
çl£


718 
io
.
wd©a
 := wdata

719 
io
.
v®ue
 :ğ
»g


722 
io
.
rw
.
rd©a
 :ğ
	`Mux1H
((
k
, 
v
è<- 
»ad_m­pšg
è
y›ld
 
	`decoded_addr
(k) -> v)

725 
»ad_m­pšg
.
	`fÜ—ch
Ğ{(
k
, 
v
) => {

726 
	`cov”
(
io
.
rw
.
cmd
.
	`isOÃOf
(
CSR
.
W
, CSR.
S
, CSR.
C
, CSR.
R
è&& io.rw.
addr
===
k
, "CSR_acûss_"+k.
toSŒšg
, "Cover Accessing Core CSR field")

729 
v®
 
£t_fs_dœty
 = 
	`Wœe
(
š™
 = 
io
.£t_fs_dœty.
	`g‘OrEl£
(
çl£
.
B
))

730 ià(
cÜeP¬ams
.
haveFSDœty
) {

731 
	`wh’
 (
£t_fs_dœty
) {

732 
	`as£¹
(
»g_m¡©us
.
fs
 > 0)

733 
»g_m¡©us
.
fs
 := 3

737 
io
.
fc¤_rm
 :ğ
»g_äm


738 
	`wh’
 (
io
.
fc¤_æags
.
v®id
) {

739 
»g_fæags
 :ğ»g_fæag | 
io
.
fc¤_æags
.
b™s


740 
£t_fs_dœty
 :ğ
Œue


743 
v®
 
c¤_w’
 = 
io
.
rw
.
cmd
.
	`isOÃOf
(
CSR
.
S
, CSR.
C
, CSR.
W
)

744 
io
.
c¤w_couÁ”
 :ğ
	`Mux
(
cÜeP¬ams
.
haveBasicCouÁ”s
 && 
c¤_w’
 && (io.
rw
.
addr
.
	`šRªge
(
CSRs
.
mcyşe
, CSRs.mcyş+ 
CSR
.
nCŒ
è|| io.rw.addr.šRªge(CSRs.
mcyşeh
, CSRs.mcyşeh + CSR.nCŒ)), 
	`UIÁToOH
(io.rw.
	`addr
(
	`log2Ce
(CSR.nCŒ+
nP”fCouÁ”s
)-1, 0)), 0.U)

746 if(
hasPrivCodeLock
) {

747 
pcode_upd©e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

756 
	`wh’
 (
c¤_w’
) {

757 if(
hasPrivCodeLock
) {

758 
pcode_c¤
 <- 
pcode_c¤s
) {

760 
	`wh’
 (
	`decoded_addr
(
pcode_c¤
)) {

761 
v®
 
id
 = 
pcode_c¤
 & 
	`UIÁ
(3, 
width
=2)

762 
v®
 
lock
 = 
	`pcode_»gs
(
id
).
locked


764 
	`wh’
(
lock
 ==ğ
	`UIÁ
(0)) {

765 
pcode_upd©e
.
v®id
 :ğ
	`BoŞ
(
Œue
)

766 
pcode_upd©e
.
b™s
.
id
 := id

767 
pcode_upd©e
.
b™s
.
v®ue
.
ba£
 :ğ
	`wd©a
(
·ddrB™s
-1, 12)

768 
pcode_upd©e
.
b™s
.
v®ue
.
mask
 :ğ
	`wd©a
(11,2)

769 
pcode_upd©e
.
b™s
.
v®ue
.
v®id
 :ğ
	`wd©a
(1)

770 
pcode_upd©e
.
b™s
.
v®ue
.
locked
 :ğ
	`wd©a
(0)

774 
	`pcode_»gs
(
id
).
locked
 :ğ
	`wd©a
(0)

779 
	`wh’
 (
	`decoded_addr
(
CSRs
.
m¡©us
)) {

780 
v®
 
Ãw_m¡©us
 = 
Ãw
 
	`MStus
().
	`äomB™s
(
wd©a
)

781 
»g_m¡©us
.
m›
 :ğ
Ãw_m¡©us
.mie

782 
»g_m¡©us
.
mp›
 :ğ
Ãw_m¡©us
.mpie

784 ià(
usšgU£r
) {

785 
»g_m¡©us
.
m´v
 :ğ
Ãw_m¡©us
.mprv

786 
»g_m¡©us
.
mµ
 :ğ
	`Ëg®izePrivege
(
Ãw_m¡©us
.mpp)

787 ià(
usšgVM
) {

788 
»g_m¡©us
.
mxr
 :ğ
Ãw_m¡©us
.mxr

789 
»g_m¡©us
.
sum
 :ğ
Ãw_m¡©us
.sum

790 
»g_m¡©us
.
¥p
 :ğ
Ãw_m¡©us
.spp

791 
»g_m¡©us
.
¥›
 :ğ
Ãw_m¡©us
.spie

792 
»g_m¡©us
.
s›
 :ğ
Ãw_m¡©us
.sie

793 
»g_m¡©us
.
tw
 :ğ
Ãw_m¡©us
.tw

794 
»g_m¡©us
.
tvm
 :ğ
Ãw_m¡©us
.tvm

795 
»g_m¡©us
.
t¤
 :ğ
Ãw_m¡©us
.tsr

799 ià(
usšgVM
 || 
usšgFPU
è
»g_m¡©us
.
fs
 :ğ
	`fÜmFS
(
Ãw_m¡©us
.fs)

800 ià(
usšgRoCC
è
»g_m¡©us
.
xs
 :ğ
	`Fl
(2, 
Ãw_m¡©us
.xs.
ÜR
)

802 
	`wh’
 (
	`decoded_addr
(
CSRs
.
mi§
)) {

803 
v®
 
mask
 = 
	`UIÁ
(
	`i§SŒšgToMask
(
i§MaskSŒšg
), 
xL’
)

804 
v®
 
f
 = 
	`wd©a
('f' - 'a')

806 
	`wh’
 (!
usšgCom´es£d
 || !
io
.
	`pc
(1è|| 
	`wd©a
('c' - 'a')) {

807 ià(
cÜeP¬ams
.
mi§Wr™abË
)

808 
»g_mi§
 :ğ~(~
wd©a
 | (!
f
 << ('d' - 'a'))è& 
mask
 |„eg_misa & ~mask

811 
	`wh’
 (
	`decoded_addr
(
CSRs
.
m
)) {

816 
v®
 
Ãw_m
 = 
	`»adModifyWr™eCSR
(
io
.
rw
.
cmd
, 
»g_m
.
asUIÁ
, io.rw.
wd©a
).
	`asTy³Of
(
Ãw
 
MIP
)

817 ià(
usšgVM
) {

818 
»g_m
.
ss
 :ğ
Ãw_m
.ssip

819 
»g_m
.
¡
 :ğ
Ãw_m
.stip

820 
»g_m
.
£
 :ğ
Ãw_m
.seip

823 
	`wh’
 (
	`decoded_addr
(
CSRs
.
m›
)è{ 
»g_m›
 :ğ
wd©a
 & 
suµÜ‹d_š‹¼u±s
 }

824 
	`wh’
 (
	`decoded_addr
(
CSRs
.
m•c
)è{ 
»g_m•c
 :ğ
	`fÜmEPC
(
wd©a
) }

825 
	`wh’
 (
	`decoded_addr
(
CSRs
.
msü©ch
)è{ 
»g_msü©ch
 :ğ
wd©a
 }

826 ià(
mtvecWr™abË
)

827 
	`wh’
 (
	`decoded_addr
(
CSRs
.
mtvec
)è{ 
»g_mtvec
 :ğ~(~
wd©a
 | 2.U | 
	`Mux
(
	`wd©a
(0), 
	`UIÁ
(((
	`BigIÁ
(1è<< 
mtvecIÁ”ru±Align
è- 1è<< 
mtvecBa£Align
), 0.U)) }

828 
	`wh’
 (
	`decoded_addr
(
CSRs
.
mÿu£
)è{ 
»g_mÿu£
 :ğ
wd©a
 & 
	`UIÁ
((
	`BigIÁ
(1è<< (
xL’
-1)è+ (BigIÁ(1è<< 
whichIÁ”ru±
.
g‘Width
) - 1) }

829 
	`wh’
 (
	`decoded_addr
(
CSRs
.
mbadaddr
)è{ 
»g_mbadaddr
 :ğ
	`wd©a
(
vaddrB™sEx‹nded
-1,0) }

831 ((
e
, 
c
), 
i
è<- (
»g_hpmev’t
 
z
 
»g_hpmcouÁ”
è
zW™hIndex
) {

832 
	`wr™eCouÁ”
(
i
 + 
CSR
.
fœ¡MHPC
, 
c
, 
wd©a
)

833 
	`wh’
 (
	`decoded_addr
(
i
 + 
CSR
.
fœ¡HPE
)è{ 
e
 :ğ
³rfEv’tS‘s
.
	`maskEv’tS–eùÜ
(
wd©a
) }

835 ià(
cÜeP¬ams
.
haveBasicCouÁ”s
) {

836 
	`wr™eCouÁ”
(
CSRs
.
mcyşe
, 
»g_cyşe
, 
wd©a
)

837 
	`wr™eCouÁ”
(
CSRs
.
mš¡»t
, 
»g_š¡»t
, 
wd©a
)

840 ià(
usšgFPU
) {

841 
	`wh’
 (
	`decoded_addr
(
CSRs
.
fæags
)è{ 
£t_fs_dœty
 :ğ
Œue
; 
»g_fæags
 :ğ
wd©a
 }

842 
	`wh’
 (
	`decoded_addr
(
CSRs
.
äm
)è{ 
£t_fs_dœty
 :ğ
Œue
; 
»g_äm
 :ğ
wd©a
 }

843 
	`wh’
 (
	`decoded_addr
(
CSRs
.
fc¤
)è{ 
£t_fs_dœty
 :ğ
Œue
; 
»g_fæags
 :ğ
wd©a
; 
»g_äm
 :ğwd©¨>>„eg_fæags.
g‘Width
 }

845 ià(
usšgDebug
) {

846 
	`wh’
 (
	`decoded_addr
(
CSRs
.
dc¤
)) {

847 
v®
 
Ãw_dc¤
 = 
Ãw
 
	`DCSR
().
	`äomB™s
(
wd©a
)

848 
»g_dc¤
.
¡•
 :ğ
Ãw_dc¤
.step

849 
»g_dc¤
.
eb»akm
 :ğ
Ãw_dc¤
.ebreakm

850 ià(
usšgVM
è
»g_dc¤
.
eb»aks
 :ğ
Ãw_dc¤
.ebreaks

851 ià(
usšgU£r
è
»g_dc¤
.
eb»aku
 :ğ
Ãw_dc¤
.ebreaku

852 ià(
usšgU£r
è
»g_dc¤
.
´v
 :ğ
	`Ëg®izePrivege
(
Ãw_dc¤
.prv)

854 
	`wh’
 (
	`decoded_addr
(
CSRs
.
dpc
)è{ 
»g_dpc
 :ğ
	`fÜmEPC
(
wd©a
) }

855 
	`wh’
 (
	`decoded_addr
(
CSRs
.
dsü©ch
)è{ 
»g_dsü©ch
 :ğ
wd©a
 }

857 ià(
usšgVM
) {

858 
	`wh’
 (
	`decoded_addr
(
CSRs
.
s¡©us
)) {

859 
v®
 
Ãw_s¡©us
 = 
Ãw
 
	`MStus
().
	`äomB™s
(
wd©a
)

860 
»g_m¡©us
.
s›
 :ğ
Ãw_s¡©us
.sie

861 
»g_m¡©us
.
¥›
 :ğ
Ãw_s¡©us
.spie

862 
»g_m¡©us
.
¥p
 :ğ
Ãw_s¡©us
.spp

863 
»g_m¡©us
.
mxr
 :ğ
Ãw_s¡©us
.mxr

864 
»g_m¡©us
.
sum
 :ğ
Ãw_s¡©us
.sum

865 
»g_m¡©us
.
fs
 :ğ
	`fÜmFS
(
Ãw_s¡©us
.fs)

866 ià(
usšgRoCC
è
»g_m¡©us
.
xs
 :ğ
	`Fl
(2, 
Ãw_s¡©us
.xs.
ÜR
)

868 
	`wh’
 (
	`decoded_addr
(
CSRs
.
s
)) {

869 
v®
 
Ãw_s
 = 
Ãw
 
	`MIP
().
	`äomB™s
((
»ad_m
 & ~
»g_mid–eg
è| (
wd©a
 &„eg_mideleg))

870 
»g_m
.
ss
 :ğ
Ãw_s
.ssip

872 
	`wh’
 (
	`decoded_addr
(
CSRs
.
¥tbr
)) {

873 
v®
 
Ãw_¥tbr
 = 
Ãw
 
	`PTBR
().
	`äomB™s
(
wd©a
)

874 
v®
 
v®id_mode
 = 
Ãw_¥tbr
.
	`pgLev–sToMode
(
pgLev–s
)

875 
	`wh’
 (
Ãw_¥tbr
.
mode
 ==ğ0è{ 
»g_¥tbr
.mode := 0 }

876 
	`wh’
 (
Ãw_¥tbr
.
mode
 ==ğ
v®id_mode
è{ 
»g_¥tbr
.mode := valid_mode }

877 
	`wh’
 (
Ãw_¥tbr
.
mode
 ==ğ0 ||‚ew_¥tbr.mod==ğ
v®id_mode
) {

878 
»g_¥tbr
.
µn
 :ğ
Ãw_¥tbr
.
	`µn
(
µnB™s
-1,0)

879 ià(
asIdB™s
 > 0è
»g_¥tbr
.
asid
 :ğ
Ãw_¥tbr
.
	`asid
(asIdBits-1,0)

882 
	`wh’
 (
	`decoded_addr
(
CSRs
.
s›
)è{ 
»g_m›
 :ğÔeg_m› & ~
»g_mid–eg
è| (
wd©a
 &„eg_mideleg) }

883 
	`wh’
 (
	`decoded_addr
(
CSRs
.
ssü©ch
)è{ 
»g_ssü©ch
 :ğ
wd©a
 }

884 
	`wh’
 (
	`decoded_addr
(
CSRs
.
£pc
)è{ 
»g_£pc
 :ğ
	`fÜmEPC
(
wd©a
) }

885 
	`wh’
 (
	`decoded_addr
(
CSRs
.
¡vec
)è{ 
»g_¡vec
 :ğ~(~
wd©a
 | 2.U | 
	`Mux
(
	`wd©a
(0), 
	`UIÁ
(((
	`BigIÁ
(1è<< 
mtvecIÁ”ru±Align
è- 1è<< 
mtvecBa£Align
), 0.U)) }

886 
	`wh’
 (
	`decoded_addr
(
CSRs
.
sÿu£
)è{ 
»g_sÿu£
 :ğ
wd©a
 & 
	`UIÁ
((
	`BigIÁ
(1è<< (
xL’
-1)) + 31) }

887 
	`wh’
 (
	`decoded_addr
(
CSRs
.
sbadaddr
)è{ 
»g_sbadaddr
 :ğ
	`wd©a
(
vaddrB™sEx‹nded
-1,0) }

888 
	`wh’
 (
	`decoded_addr
(
CSRs
.
mid–eg
)è{ 
»g_mid–eg
 :ğ
wd©a
 & 
d–egabË_š‹¼u±s
 }

889 
	`wh’
 (
	`decoded_addr
(
CSRs
.
med–eg
)è{ 
»g_med–eg
 :ğ
wd©a
 & 
d–egabË_exû±iÚs
 }

890 
	`wh’
 (
	`decoded_addr
(
CSRs
.
scouÁ”’
)è{ 
»g_scouÁ”’
 :ğ
wd©a
 & 
	`UIÁ
(
d–egabË_couÁ”s
) }

892 ià(
usšgU£r
) {

893 
	`wh’
 (
	`decoded_addr
(
CSRs
.
mcouÁ”’
)è{ 
»g_mcouÁ”’
 :ğ
wd©a
 & 
	`UIÁ
(
d–egabË_couÁ”s
) }

895 ià(
nB»akpošts
 > 0) {

896 
	`wh’
 (
	`decoded_addr
(
CSRs
.
t£Ëù
)è{ 
»g_t£Ëù
 :ğ
wd©a
 }

898 
v®
 
bp
 = 
	`»g_bp
(
»g_t£Ëù
)

899 
	`wh’
 (!
bp
.
cÚŒŞ
.
dmode
 || 
»g_debug
) {

900 
	`wh’
 (
	`decoded_addr
(
CSRs
.
td©a1
)) {

901 
v®
 
ÃwBPC
 = 
Ãw
 
	`BPCÚŒŞ
().
	`äomB™s
(
wd©a
)

902 
v®
 
dMode
 = 
ÃwBPC
.
dmode
 && 
»g_debug


903 
bp
.
cÚŒŞ
 :ğ
ÃwBPC


904 
bp
.
cÚŒŞ
.
dmode
 :ğ
dMode


905 
bp
.
cÚŒŞ
.
aùiÚ
 :ğ
dMode
 && 
ÃwBPC
.action

907 
	`wh’
 (
	`decoded_addr
(
CSRs
.
td©a2
)è{ 
bp
.
add»ss
 :ğ
wd©a
 }

910 ià(
»g_pmp
.
nÚEm±y
è((
pmp
, 
Ãxt
), 
i
è<- (»g_pm°
	`z
 (»g_pmp.

 :+„eg_pmp.
Ï¡
)è
zW™hIndex
) {

911 
	`»quœe
(
xL’
 % 
pmp
.
cfg
.
g‘Width
 == 0)

912 
	`wh’
 (
	`decoded_addr
(
CSRs
.
pmpcfg0
 + 
	`pmpCfgIndex
(
i
)è&& !
pmp
.
cfgLocked
) {

913 
v®
 
ÃwCfg
 = 
Ãw
 
	`PMPCÚfig
().
	`äomB™s
(
wd©a
 >> ((
i
 * 
pmp
.
cfg
.
g‘Width
è% 
xL’
))

914 
pmp
.
cfg
 :ğ
ÃwCfg


916 ià(
pmpG¿nuÏr™y
.
log2
 > 
PMP
.
lgAlign
)

917 
pmp
.
cfg
.
a
 :ğ
	`C©
(
ÃwCfg
.
	`a
(1),‚ewCfg.a.
ÜR
)

919 
	`wh’
 (
	`decoded_addr
(
CSRs
.
pm·ddr0
 + 
i
è&& !
pmp
.
	`addrLocked
(
Ãxt
)) {

920 
pmp
.
addr
 :ğ
wd©a


923 (
io
, 
c¤
, 
»g
è<- (io.
cu¡omCSRs
, cu¡omCSRs, 
»g_cu¡om
).
z³d
) {

924 
v®
 
mask
 = 
c¤
.mask.
	`U
(
xL’
.
W
)

925 
	`wh’
 (
	`decoded_addr
(
c¤
.
id
)) {

926 
»g
 :ğ(
wd©a
 & 
mask
) | (reg & ~mask)

927 
io
.
w’
 :ğ
Œue


932 ià(!
usšgVM
) {

933 
»g_mid–eg
 := 0

934 
»g_med–eg
 := 0

935 
»g_scouÁ”’
 := 0

938 ià(!
usšgU£r
) {

939 
»g_mcouÁ”’
 := 0

942 
»g_¥tbr
.
asid
 := 0

943 ià(
nB»akpošts
 <ğ1è
»g_t£Ëù
 := 0

944 ià(
nB»akpošts
 >= 1)

945 
	`»g_bp
(
nB»akpošts
-1).
cÚŒŞ
.
chaš
 :ğ
çl£


946 
bpc
 <- 
»g_bp
 
m­
 {
_
.
cÚŒŞ
}) {

947 
bpc
.
‰y³
 :ğbpc.
tTy³


948 
bpc
.
maskmax
 :ğbpc.
maskMax


949 
bpc
.
»£rved
 := 0

950 
bpc
.
z”o
 := 0

951 
bpc
.
h
 :ğ
çl£


952 ià(!
usšgVM
è
bpc
.
s
 :ğ
çl£


953 ià(!
usšgU£r
è
bpc
.
u
 :ğ
çl£


954 ià(!
usšgVM
 && !
usšgU£r
è
bpc
.
m
 :ğ
Œue


955 
	`wh’
 (
»£t
) {

956 
bpc
.
aùiÚ
 :ğ
çl£


957 
bpc
.
dmode
 :ğ
çl£


958 
bpc
.
r
 :ğ
çl£


959 
bpc
.
w
 :ğ
çl£


960 
bpc
.
x
 :ğ
çl£


963 
bp
 <- 
»g_bp
 
drİ
 
nB»akpošts
)

964 
bp
 :ğ
Ãw
 
	`BP
().
	`äomB™s
(0)

965 
pmp
 <- 
»g_pmp
) {

966 
pmp
.
cfg
.
»s
 := 0

967 
	`wh’
 (
»£t
) {

968 
pmp
.
cfg
.
a
 := 0

969 
pmp
.
cfg
.
l
 := 0

973 ((
t
, 
š¢
), 
i
è<- (
io
.
Œaû
 
z
 io.
š¡
).
zW™hIndex
) {

974 
t
.
exû±iÚ
 :ğ
io
.
»tœe
 >ğ
i
 &&ƒxception

975 
t
.
v®id
 :ğ
io
.
»tœe
 > 
i
 ||.
exû±iÚ


976 
t
.
š¢
 := insn

977 
t
.
Ÿddr
 :ğ
io
.
pc


978 
t
.
´iv
 :ğ
	`C©
(
»g_debug
, 
»g_m¡©us
.
´v
)

979 
t
.
ÿu£
 := cause

980 
t
.
š‹¼u±
 :ğ
	`ÿu£
(
xL’
-1)

981 
t
.
tv®
 :ğ
io
.tval

984 
def
 
	`choo£IÁ”ru±
(
masksIn
: 
Seq
[
UIÁ
]): (
BoŞ
, UInt) = {

985 
v®
 
nÚ¡ªd¬d
 = 
suµÜ‹d_š‹¼u±s
.
g‘Width
-1 
to
 12 
by
 -1

987 
v®
 
¡ªd¬d
 = 
	`Seq
(11, 3, 7, 9, 1, 5, 8, 0, 4)

988 
v®
 
´iÜ™y
 = 
nÚ¡ªd¬d
 ++ 
¡ªd¬d


989 
v®
 
masks
 = 
masksIn
.
»v”£


990 
v®
 
ªy
 = 
masks
.
	`æ©M­
(
m
 => 
´iÜ™y
.
	`f‹r
(
_
 < m.
g‘Width
).
	`m­
(
i
 => 
	`m
(i))).
	`»duû
(_||_)

991 
v®
 
which
 = 
	`PriÜ™yMux
(
masks
.
	`æ©M­
(
m
 => 
´iÜ™y
.
	`f‹r
(
_
 < m.
g‘Width
).
	`m­
(
i
 => (
	`m
(i), i.
U
))))

992 (
ªy
, 
which
)

995 
def
 
	`»adModifyWr™eCSR
(
cmd
: 
UIÁ
, 
rd©a
: UIÁ, 
wd©a
: UInt) = {

996 (
	`Mux
(
	`cmd
(1), 
rd©a
, 
	`UIÁ
(0)è| 
wd©a
è& ~Mux(cmd(1,0).
ªdR
, wdata, UInt(0))

999 
def
 
	`Ëg®izePrivege
(
´iv
: 
UIÁ
): UInt =

1000 ià(
usšgVM
è
	`Mux
(
´iv
 ==ğ
PRV
.
H
, PRV.
U
,…riv)

1001 ià(
usšgU£r
è
	`Fl
(2, 
	`´iv
(0))

1002 
PRV
.
M


1004 
def
 
	`ŒimPrivege
(
´iv
: 
UIÁ
): UInt =

1005 ià(
usšgVM
è
´iv


1006 
	`Ëg®izePrivege
(
´iv
)

1008 
def
 
	`wr™eCouÁ”
(
lo
: 
IÁ
, 
ùr
: 
WideCouÁ”
, 
wd©a
: 
UIÁ
) = {

1009 ià(
xL’
 == 32) {

1010 
v®
 
hi
 = 
lo
 + 
CSRs
.
mcyşeh
 - CSRs.
mcyşe


1011 
	`wh’
 (
	`decoded_addr
(
lo
)è{ 
ùr
 :ğ
	`C©
(
	`ùr
(ùr.
g‘Width
-1, 32), 
wd©a
) }

1012 
	`wh’
 (
	`decoded_addr
(
hi
)è{ 
ùr
 :ğ
	`C©
(
	`wd©a
(ùr.
g‘Width
-33, 0), 
	`ùr
(31, 0)) }

1014 
	`wh’
 (
	`decoded_addr
(
lo
)è{ 
ùr
 :ğ
	`wd©a
(ùr.
g‘Width
-1, 0) }

1017 
def
 
	`fÜmEPC
(
x
: 
UIÁ
èğ~(~x | (ià(
usšgCom´es£d
) 1.U 3.U))

1018 
def
 
	`»adEPC
(
x
: 
UIÁ
èğ~(~x | 
	`Mux
(
	`»g_mi§
('c' - 'a'), 1.U, 3.U))

1019 
def
 
	`i§SŒšgToMask
(
s
: 
SŒšg
èğs.
	`m­
(
x
 => 1 << (x - 'A')).
	`fŞdLeá
(0)(
_
|_)

1020 
def
 
	`fÜmFS
(
fs
: 
UIÁ
èğià(
cÜeP¬ams
.
haveFSDœty
èf 
	`Fl
(2, fs.
ÜR
)

1021 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Consts.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
cÚ¡ªts


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


7 
impÜt
 
	gsÿÏ
.
	gm©h
.
_


9 
Œa™
 
	gSÿÏrOpCÚ¡ªts
 {

10 
v®
 
	gMT_SZ
 = 3

11 
def
 
MT_X
 = 
B™P©
("b???")

12 
def
 
MT_B
 = 
UIÁ
("b000")

13 
def
 
MT_H
 = 
UIÁ
("b001")

14 
def
 
MT_W
 = 
UIÁ
("b010")

15 
def
 
MT_D
 = 
UIÁ
("b011")

16 
def
 
MT_BU
 = 
UIÁ
("b100")

17 
def
 
MT_HU
 = 
UIÁ
("b101")

18 
def
 
MT_WU
 = 
UIÁ
("b110")

19 
def
 
mtSize
(
mt
: 
UIÁ
èğmt(
MT_SZ
-2, 0)

20 
def
 
mtSigÃd
(
mt
: 
UIÁ
èğ!mt(
MT_SZ
-1)

22 
v®
 
SZ_BR
 = 3

23 
def
 
BR_X
 = 
B™P©
("b???")

24 
def
 
BR_EQ
 = 
UIÁ
(0, 3)

25 
def
 
	gBR_NE
 = 
UIÁ
(1, 3)

26 
def
 
	gBR_J
 = 
UIÁ
(2, 3)

27 
def
 
	gBR_N
 = 
UIÁ
(3, 3)

28 
def
 
	gBR_LT
 = 
UIÁ
(4, 3)

29 
def
 
	gBR_GE
 = 
UIÁ
(5, 3)

30 
def
 
	gBR_LTU
 = 
UIÁ
(6, 3)

31 
def
 
	gBR_GEU
 = 
UIÁ
(7, 3)

33 
def
 
	gA1_X
 = 
B™P©
("b??")

34 
def
 
A1_ZERO
 = 
UIÁ
(0, 2)

35 
def
 
	gA1_RS1
 = 
UIÁ
(1, 2)

36 
def
 
	gA1_PC
 = 
UIÁ
(2, 2)

38 
def
 
	gIMM_X
 = 
B™P©
("b???")

39 
def
 
IMM_S
 = 
UIÁ
(0, 3)

40 
def
 
	gIMM_SB
 = 
UIÁ
(1, 3)

41 
def
 
	gIMM_U
 = 
UIÁ
(2, 3)

42 
def
 
	gIMM_UJ
 = 
UIÁ
(3, 3)

43 
def
 
	gIMM_I
 = 
UIÁ
(4, 3)

44 
def
 
	gIMM_Z
 = 
UIÁ
(5, 3)

46 
def
 
	gA2_X
 = 
B™P©
("b??")

47 
def
 
A2_ZERO
 = 
UIÁ
(0, 2)

48 
def
 
	gA2_SIZE
 = 
UIÁ
(1, 2)

49 
def
 
	gA2_RS2
 = 
UIÁ
(2, 2)

50 
def
 
	gA2_IMM
 = 
UIÁ
(3, 2)

52 
def
 
	gX
 = 
B™P©
("b?")

53 
def
 
N
 = 
B™P©
("b0")

54 
def
 
Y
 = 
B™P©
("b1")

56 
v®
 
SZ_DW
 = 1

57 
def
 
DW_X
 = 
X


58 
def
 
DW_32
 = 
BoŞ
(
çl£
)

59 
def
 
DW_64
 = 
BoŞ
(
Œue
)

60 
def
 
DW_XPR
 = 
DW_64


63 
Œa™
 
	gMemÜyOpCÚ¡ªts
 {

64 
v®
 
	gNUM_XA_OPS
 = 9

65 
v®
 
M_SZ
 = 5

66 
def
 
M_X
 = 
B™P©
("b?????");

67 
def
 
	gM_XRD
 = 
UIÁ
("b00000");

68 
def
 
	gM_XWR
 = 
UIÁ
("b00001");

69 
def
 
	gM_PFR
 = 
UIÁ
("b00010");

70 
def
 
	gM_PFW
 = 
UIÁ
("b00011");

71 
def
 
	gM_XA_SWAP
 = 
UIÁ
("b00100");

72 
def
 
	gM_FLUSH_ALL
 = 
UIÁ
("b00101")

73 
def
 
M_XLR
 = 
UIÁ
("b00110");

74 
def
 
	gM_XSC
 = 
UIÁ
("b00111");

75 
def
 
	gM_XA_ADD
 = 
UIÁ
("b01000");

76 
def
 
	gM_XA_XOR
 = 
UIÁ
("b01001");

77 
def
 
	gM_XA_OR
 = 
UIÁ
("b01010");

78 
def
 
	gM_XA_AND
 = 
UIÁ
("b01011");

79 
def
 
	gM_XA_MIN
 = 
UIÁ
("b01100");

80 
def
 
	gM_XA_MAX
 = 
UIÁ
("b01101");

81 
def
 
	gM_XA_MINU
 = 
UIÁ
("b01110");

82 
def
 
	gM_XA_MAXU
 = 
UIÁ
("b01111");

83 
def
 
	gM_FLUSH
 = 
UIÁ
("b10000")

84 
def
 
M_PWR
 = 
UIÁ
("b10001")

85 
def
 
M_PRODUCE
 = 
UIÁ
("b10010")

86 
def
 
M_CLEAN
 = 
UIÁ
("b10011")

87 
def
 
M_SFENCE
 = 
UIÁ
("b10100")

89 
def
 
isAMOLogiÿl
(
cmd
: 
UIÁ
èğcmd.
isOÃOf
(
M_XA_SWAP
, 
M_XA_XOR
, 
M_XA_OR
, 
M_XA_AND
)

90 
def
 
isAMOAr™hm‘ic
(
cmd
: 
UIÁ
èğcmd.
isOÃOf
(
M_XA_ADD
, 
M_XA_MIN
, 
M_XA_MAX
, 
M_XA_MINU
, 
M_XA_MAXU
)

91 
def
 
isAMO
(
cmd
: 
UIÁ
èğ
isAMOLogiÿl
(cmdè|| 
isAMOAr™hm‘ic
(cmd)

92 
def
 
isP»ãtch
(
cmd
: 
UIÁ
èğcmd ==ğ
M_PFR
 || cmd ==ğ
M_PFW


93 
def
 
isR—d
(
cmd
: 
UIÁ
èğcmd ==ğ
M_XRD
 || cmd ==ğ
M_XLR
 || cmd ==ğ
M_XSC
 || 
isAMO
(cmd)

94 
def
 
isWr™e
(
cmd
: 
UIÁ
èğcmd ==ğ
M_XWR
 || cmd ==ğ
M_PWR
 || cmd ==ğ
M_XSC
 || 
isAMO
(cmd)

95 
def
 
isWr™eIÁ’t
(
cmd
: 
UIÁ
èğ
isWr™e
(cmdè|| cmd ==ğ
M_PFW
 || cmd ==ğ
M_XLR


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/DCache.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.{
	gAdd»ssS‘
, 
	gRegiÚTy³
}

9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
LookupByH¬tId


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


13 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


14 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
_


15 
impÜt
 
	gTLMes§ges
.
_


17 şas 
	cDCacheE¼Üs
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheBundË
()(
p
)

18 
w™h
 
CªHaveE¼Üs
 {

19 
v®
 
cÜ»ùabË
 = (
ÿcheP¬ams
.
gCode
.
ÿnCÜ»ù
 || cacheP¬ams.
d©aCode
.ÿnCÜ»ù).
	`İtiÚ
(
	`V®id
(
	$UIÁ
(
width
 = 
·ddrB™s
)))

20 
v®
 
uncÜ»ùabË
 = (
ÿcheP¬ams
.
gCode
.
ÿnD‘eù
 || cacheP¬ams.
d©aCode
.ÿnD‘eù).
	`İtiÚ
(
	`V®id
(
	$UIÁ
(
width
 = 
·ddrB™s
)))

21 
v®
 
bus
 = 
	`V®id
(
	`UIÁ
(
width
 = 
·ddrB™s
))

24 şas 
	cDCacheD©aReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheBundË
()(
p
) {

25 
v®
 
addr
 = 
	$B™s
(
width
 = 
uÁagB™s
)

26 
v®
 
wr™e
 = 
	$BoŞ
()

27 
v®
 
wd©a
 = 
	`UIÁ
(
width
 = 
’cB™s
 * 
rowBy‹s
 / 
eccBy‹s
)

28 
v®
 
poisÚ
 = 
	$BoŞ
()

29 
v®
 
wÜdMask
 = 
	`UIÁ
(
width
 = 
rowBy‹s
 / 
wÜdBy‹s
)

30 
v®
 
eccMask
 = 
	`UIÁ
(
width
 = 
wÜdBy‹s
 / 
eccBy‹s
)

31 
v®
 
way_’
 = 
	`B™s
(
width
 = 
nWays
)

34 şas 
	cDCacheD©aA¼ay
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

35 
v®
 
io
 = 
Ãw
 
BundË
 {

36 
v®
 
»q
 = 
	`V®id
(
Ãw
 
DCacheD©aReq
).
æ


37 
v®
 
»¥
 = 
	`Vec
(
nWays
, 
	`UIÁ
(
width
 = 
»q
.
b™s
.
wd©a
.
g‘Width
)).
asOuut


40 
	`»quœe
(
rowBy‹s
 % 
wÜdBy‹s
 == 0)

41 
v®
 
eccMask
 = ià(
eccB™s
 =ğ
wÜdB™s
è
	$Seq
(
Œue
.
B
è
io
.
»q
.
b™s
.
eccMask
.
toBoŞs


42 
v®
 
wMask
 = ià(
nWays
 =ğ1è
eccMask
 (0 
uÁ
‚Ways).
	`æ©M­
(
i
 =>ƒccMask.
	`m­
(
_
 && 
io
.
»q
.
b™s
.
	$way_’
(
i
)))

43 
v®
 
wWÜds
 = 
io
.
»q
.
b™s
.
wd©a
.
	`grou³d
(
’cB™s
 * (
wÜdB™s
 / 
eccB™s
))

44 
v®
 
addr
 = 
io
.
»q
.
b™s
.add¸>> 
rowOffB™s


45 
v®
 
d©a_¬¿ys
 = 
Seq
.
	`buÏ‹
(
rowBy‹s
 / 
wÜdBy‹s
) {

46 
i
 =>

47 
	`DesüibedSRAM
(

48 
Çme
 = 
s
"data_arrays_${i}",

49 
desc
 = "DCache Data Array",

50 
size
 = 
nS‘s
 * 
ÿcheBlockBy‹s
 / 
rowBy‹s
,

51 
d©a
 = 
	`Vec
(
nWays
 * (
wÜdB™s
 / 
eccB™s
), 
	`UIÁ
(
width
 = 
’cB™s
))

53 
	}
}

55 
v®
 
	grd©a
 = (
¬¿y
, 
	gi
è<- 
d©a_¬¿ys
 
	gzW™hIndex
è
	gy›ld
 {

56 
v®
 
	gv®id
 = 
io
.
»q
.
v®id
 && (
BoŞ
(
d©a_¬¿ys
.
size
 =ğ1è|| io.»q.
b™s
.
wÜdMask
(
i
))

57 
wh’
 (
v®id
 && 
io
.
»q
.
b™s
.
wr™e
) {

58 
v®
 
wD©a
 = 
wWÜds
(
i
).
grou³d
(
’cB™s
)

59 
¬¿y
.
wr™e
(
addr
, 
Vec
((0 
uÁ
 
nWays
).
æ©M­
(
i
 => 
wD©a
)), 
wMask
)

61 
v®
 
	gd©a
 = 
¬¿y
.
»ad
(
addr
, 
v®id
 && !
io
.
»q
.
b™s
.
wr™e
)

62 
	gd©a
.
grou³d
(
wÜdB™s
 / 
eccB™s
).
m­
(
_
.
asUIÁ
).
	gtoSeq


64 (
	gio
.
»¥
 
z
 
	grd©a
.
	gŒª¥o£
).
	gfÜ—ch
 { (
	g»¥
, 
	gd©a
è=>„e¥ :ğ
d©a
.
asUIÁ
 }

67 şas 
	cDCacheM‘ad©aReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheBundË
()(
p
) {

68 
v®
 
wr™e
 = 
	$BoŞ
()

69 
v®
 
addr
 = 
	$UIÁ
(
width
 = 
vaddrB™sEx‹nded
)

70 
v®
 
idx
 = 
	$UIÁ
(
width
 = 
idxB™s
)

71 
v®
 
way_’
 = 
	$UIÁ
(
width
 = 
nWays
)

72 
v®
 
d©a
 = 
	`UIÁ
(
width
 = 
ÿcheP¬ams
.
gCode
.
	`width
(
Ãw
 
	`L1M‘ad©a
().
g‘Width
))

75 
şass
 
	`DCache
(
h¬tid
: 
IÁ
, 
v®
 
sü©ch
: (è=> 
O±iÚ
[
Add»ssS‘
] = (è=> 
NÚe
, v® 
bufãrUnÿchedReque¡s
: O±iÚ[IÁ] = NÚe)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$H–ÏCache
(
h¬tid
)(
p
) {

76 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`DCacheModuË
(
this
)

77 
	}
}

79 @
chi£lName


80 şas 
	cDCacheModuË
(
ou‹r
: 
DCache
è
ex‹nds
 
	$H–ÏCacheModuË
(
ou‹r
) {

81 
v®
 
tECC
 = 
ÿcheP¬ams
.
gCode


82 
v®
 
dECC
 = 
ÿcheP¬ams
.
d©aCode


83 
	`»quœe
(
	`isPow2
(
eccBy‹s
è&&ƒccBy‹ <ğ
wÜdBy‹s
)

84 
	`»quœe
(
eccBy‹s
 =ğ1 || !
dECC
.
isIn¡ªûOf
[
Id’t™yCode
])

85 
v®
 
usšgRMW
 = 
eccBy‹s
 > 1 || 
usšgAtomicsInCache


86 
v®
 
mmioOff£t
 = 
ou‹r
.
fœ¡MMIO


88 
v®
 
şock_’_»g
 = 
	`Reg
(
	$BoŞ
())

89 
io
.
ıu
.
şock_’abËd
 :ğ
şock_’_»g


91 
v®
 
g©ed_şock
 =

92 ià(!
ÿcheP¬ams
.
şockG©e
è
şock


93 
	`ClockG©e
(
şock
, 
şock_’_»g
, "dcache_clock_gate")

94 
	$w™hClock
 (
g©ed_şock
) {

97 
v®
 
»¶aûr
 = 
ÿcheP¬ams
.
»¶aûm’t


98 
v®
 
m‘aArb
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
DCacheM‘ad©aReq
, 8))

100 
v®
 
g_¬¿y
 = 
	`DesüibedSRAM
(

101 
Çme
 = "tag_array",

102 
desc
 = "DCache Tag Array",

103 
size
 = 
nS‘s
,

104 
d©a
 = 
	`Vec
(
nWays
, 
m‘aArb
.
io
.
out
.
b™s
.data)

108 
v®
 
d©a
 = 
	`ModuË
(
Ãw
 
DCacheD©aA¼ay
)

109 
v®
 
d©aArb
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
DCacheD©aReq
, 4))

110 
d©aArb
.
io
.
š
.

.
	`fÜ—ch
(
_
.
b™s
.
wd©a
 :ğd©aArb.io.š.
h—d
.bits.wdata)

111 
d©a
.
io
.
»q
 <> 
d©aArb
.io.
out


112 
d©a
.
io
.
»q
.
b™s
.
wd©a
 :ğ
	`’codeD©a
(
d©aArb
.io.
out
.b™s.
	`wd©a
(
rowB™s
-1, 0), d©aArb.io.out.b™s.
poisÚ
)

113 
d©aArb
.
io
.
out
.
»ady
 :ğ
Œue


114 
m‘aArb
.
io
.
out
.
»ady
 :ğ
şock_’_»g


116 
v®
 
_out_a
 = 
	`Wœe
(
_out
.
a
)

117 
_out
.
a
 <> 
ou‹r
.
bufãrUnÿchedReque¡s


118 .
	`m­
(
_
 
mš
 
maxUnÿchedInFlight
-1)

119 .
	`m­
(
	`Queue
(
_out_a
, 
_
, 
æow
 = 
Œue
))

120 .
	`g‘OrEl£
(
_out_a
)

122 
	`v®
 (
_out_c
, 
»Ëa£_queue_em±y
) =

123 ià(
ÿcheP¬ams
.
acquœeBefÜeR–—£
) {

124 
v®
 
q
 = 
	`ModuË
(
Ãw
 
	`Queue
(
_out
.
c
.
b™s
.
şÚeTy³
, 
ÿcheD©aB—ts
, 
æow
 = 
Œue
))

125 
_out
.
c
 <> 
q
.
io
.
deq


126 (
q
.
io
.
’q
, q.io.
couÁ
 === 0)

128 (
_out
.
c
, 
Œue
.
B
)

131 
v®
 
s1_v®id
 = 
	`Reg
(
Ãxt
=
io
.
ıu
.
»q
.
	`fœe
(), 
š™
=
	`BoŞ
(
çl£
))

132 
v®
 
s1_´obe
 = 
	`Reg
(
Ãxt
=
_out
.
b
.
	`fœe
(), 
š™
=
	`BoŞ
(
çl£
))

133 
v®
 
´obe_b™s
 = 
	`RegEÇbË
(
_out
.
b
.
b™s
,l_out.b.
	`fœe
())

134 
v®
 
s1_Çck
 = 
	`Wœe
(
š™
=
	`BoŞ
(
çl£
))

135 
v®
 
s1_v®id_masked
 = 
s1_v®id
 && !
io
.
ıu
.
s1_kl


136 
v®
 
s1_v®id_nÙ_Çcked
 = 
s1_v®id
 && !
s1_Çck


137 
v®
 
s1_»q
 = 
	`Reg
(
io
.
ıu
.
»q
.
b™s
)

138 
v®
 
s0_şk_’
 = 
m‘aArb
.
io
.
out
.
v®id
 && !m‘aArb.io.out.
b™s
.
wr™e


139 
	`wh’
 (
s0_şk_’
) {

140 
s1_»q
 :ğ
io
.
ıu
.
»q
.
b™s


141 
s1_»q
.
addr
 :ğ
	`C©
(
m‘aArb
.
io
.
out
.
b™s
.add¸>> 
blockOffB™s
, io.
ıu
.
»q
.b™s.
	`addr
(blockOffBits-1,0))

142 
	`wh’
 (!
m‘aArb
.
io
.
	`š
(7).
»ady
è{ 
s1_»q
.
phys
 :ğ
Œue
 }

144 
v®
 
s1_»ad
 = 
	`isR—d
(
s1_»q
.
cmd
)

145 
v®
 
s1_wr™e
 = 
	`isWr™e
(
s1_»q
.
cmd
)

146 
v®
 
s1_»adwr™e
 = 
s1_»ad
 || 
s1_wr™e


147 
v®
 
s1_sãnû
 = 
s1_»q
.
cmd
 ==ğ
M_SFENCE


148 
v®
 
s1_æush_v®id
 = 
	`Reg
(
	`BoŞ
())

149 
v®
 
s1_waw_haz¬d
 = 
	`Wœe
(
	`BoŞ
())

151 
v®
 
s_»ady
 :: 
s_vŞuÁ¬y_wr™eback
 :: 
s_´obe_»p_dœty
 :: 
s_´obe_»p_ş—n
 :: 
s_´obe_»Œy
 :: 
s_´obe_»p_miss
 :: 
s_vŞuÁ¬y_wr™e_m‘a
 :: 
s_´obe_wr™e_m‘a
 :: 
N
 = 
	`Enum
(
	`UIÁ
(), 8)

152 
v®
 
ÿched_g¿Á_wa™
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

153 
v®
 
»Ëa£_ack_wa™
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

154 
v®
 
ÿn_acquœe_befÜe_»Ëa£
 = !
»Ëa£_ack_wa™
 && 
»Ëa£_queue_em±y


155 
v®
 
»Ëa£_¡©e
 = 
	`Reg
(
š™
=
s_»ady
)

156 
v®
 
ªy_p¡Üe_v®id
 = 
	`Wœe
(
	`BoŞ
())

157 
v®
 
šWr™eback
 = 
»Ëa£_¡©e
.
	`isOÃOf
(
s_vŞuÁ¬y_wr™eback
, 
s_´obe_»p_dœty
)

158 
v®
 
»Ëa£Way
 = 
	`Wœe
(
	`UIÁ
())

159 
io
.
ıu
.
»q
.
»ady
 :ğ(
»Ëa£_¡©e
 ==ğ
s_»ady
è&& !
ÿched_g¿Á_wa™
 && !
s1_Çck


162 
v®
 
unÿchedInFlight
 = 
	`RegIn™
(
Vec
.
	`fl
(
maxUnÿchedInFlight
)(
çl£
.
B
))

163 
v®
 
unÿchedReqs
 = 
	`Reg
(
	`Vec
(
maxUnÿchedInFlight
, 
Ãw
 
H–ÏCacheReq
))

166 
v®
 
s0_»ad
 = 
	`isR—d
(
io
.
ıu
.
»q
.
b™s
.
cmd
)

167 
d©aArb
.
io
.
	`š
(3).
v®id
 :ğio.
ıu
.
»q
.v®id && 
	`lik–yN“dsR—d
(io.ıu.»q.
b™s
)

168 
d©aArb
.
io
.
	`š
(3).
b™s
 := dataArb.io.in(1).bits

169 
d©aArb
.
io
.
	`š
(3).
b™s
.
wr™e
 :ğ
çl£


170 
d©aArb
.
io
.
	`š
(3).
b™s
.
addr
 :ğio.
ıu
.
»q
.bits.addr

171 
d©aArb
.
io
.
	`š
(3).
b™s
.
wÜdMask
 :ğ
	`UIÁToOH
(io.
ıu
.
»q
.b™s.
addr
.
	`exŒaù
(
rowOffB™s
-1,
off£sb
))

172 
d©aArb
.
io
.
	`š
(3).
b™s
.
way_’
 :ğ~
	`UIÁ
(0, 
nWays
)

173 
	`wh’
 (!
d©aArb
.
io
.
	`š
(3).
»ady
 && 
s0_»ad
è{ io.
ıu
.
»q
.»ady :ğ
çl£
 }

174 
v®
 
s1_did_»ad
 = 
	`RegEÇbË
(
d©aArb
.
io
.
	`š
(3).
»ady
 && (io.
ıu
.
»q
.
v®id
 && 
	`ÃedsR—d
(io.ıu.»q.
b™s
)), 
s0_şk_’
)

175 
m‘aArb
.
io
.
	`š
(7).
v®id
 :ğio.
ıu
.
»q
.valid

176 
m‘aArb
.
io
.
	`š
(7).
b™s
.
wr™e
 :ğ
çl£


177 
m‘aArb
.
io
.
	`š
(7).
b™s
.
idx
 :ğio.
ıu
.
»q
.b™s.
	`addr
(
idxMSB
, 
idxLSB
)

178 
m‘aArb
.
io
.
	`š
(7).
b™s
.
addr
 :ğio.
ıu
.
»q
.bits.addr

179 
m‘aArb
.
io
.
	`š
(7).
b™s
.
way_’
 := metaArb.io.in(4).bits.way_en

180 
m‘aArb
.
io
.
	`š
(7).
b™s
.
d©a
 := metaArb.io.in(4).bits.data

181 
	`wh’
 (!
m‘aArb
.
io
.
	`š
(7).
»ady
è{ io.
ıu
.
»q
.»ady :ğ
çl£
 }

184 
v®
 
b
 = 
	`ModuË
(
Ãw
 
	`TLB
(
çl£
, 
	`log2Ce
(
cÜeD©aBy‹s
), 
	`TLBCÚfig
(
nTLBEÁr›s
)))

185 
io
.
±w
 <> 
b
.io.ptw

186 
b
.
io
.
kl
 :ğio.
ıu
.
s2_kl


187 
b
.
io
.
»q
.
v®id
 :ğ
s1_v®id
 && !io.
ıu
.
s1_kl
 && 
s1_»adwr™e


188 
b
.
io
.
»q
.
b™s
.
·s¡hrough
 :ğ
s1_»q
.
phys


189 
b
.
io
.
»q
.
b™s
.
vaddr
 :ğ
s1_»q
.
addr


190 
b
.
io
.
»q
.
b™s
.
size
 :ğ
s1_»q
.
typ


191 
b
.
io
.
»q
.
b™s
.
cmd
 :ğ
s1_»q
.cmd

192 
	`wh’
 (!
b
.
io
.
»q
.
»ady
 && !b.io.
±w
.
»¥
.
v®id
 && !io.
ıu
.»q.
b™s
.
phys
è{ io.ıu.»q.»ady :ğ
çl£
 }

193 
	`wh’
 (
s1_v®id
 && 
s1_»adwr™e
 && 
b
.
io
.
»¥
.
miss
è{ 
s1_Çck
 :ğ
Œue
 }

195 
b
.
io
.
sãnû
.
v®id
 :ğ
s1_v®id
 && !io.
ıu
.
s1_kl
 && 
s1_sãnû


196 
b
.
io
.
sãnû
.
b™s
.
rs1
 :ğ
s1_»q
.
	`typ
(0)

197 
b
.
io
.
sãnû
.
b™s
.
rs2
 :ğ
s1_»q
.
	`typ
(1)

198 
b
.
io
.
sãnû
.
b™s
.
asid
 :ğio.
ıu
.
s1_d©a
.
d©a


199 
b
.
io
.
sãnû
.
b™s
.
addr
 :ğ
s1_»q
.addr

201 
v®
 
s1_·ddr
 = 
b
.
io
.
»¥
.
·ddr


202 
v®
 
s1_viùim_way
 = 
	`Wœe
(
š™
 = 
»¶aûr
.
way
)

203 
	`v®
 (
s1_h™_way
, 
s1_h™_¡©e
, 
s1_m‘a
, 
s1_viùim_m‘a
) =

204 ià(
usšgD©aSü©ch·d
) {

205 
v®
 
ba£Addr
 = 
	`p
(
LookupByH¬tId
)(
_
.
dÿche
.
	`æ©M­
(_.
sü©ch
.
	`m­
(_.
U
)), 
io
.
h¬tid
)

206 
v®
 
šSü©ch·d
 = 
s1_·ddr
 >ğ
ba£Addr
 && s1_·dd¸< ba£Add¸+ 
nS‘s
 * 
ÿcheBlockBy‹s


207 
v®
 
h™S‹
 = 
	`Mux
(
šSü©ch·d
, 
Cl›ÁM‘ad©a
.
maximum
, Cl›ÁM‘ad©a.
ÚRe£t
)

208 
v®
 
dummyM‘a
 = 
	`L1M‘ad©a
(
	`UIÁ
(0), 
Cl›ÁM‘ad©a
.
ÚRe£t
)

209 (
šSü©ch·d
, 
h™S‹
, 
	`Seq
(
tECC
.
	`’code
(
dummyM‘a
.
asUIÁ
)), dummyMeta)

211 
v®
 
m‘aReq
 = 
m‘aArb
.
io
.
out


212 
v®
 
m‘aIdx
 = 
m‘aReq
.
b™s
.
idx


213 
	`wh’
 (
m‘aReq
.
v®id
 && m‘aReq.
b™s
.
wr™e
) {

214 
v®
 
wmask
 = ià(
nWays
 =ğ1è
	`Seq
(
Œue
.
B
è
m‘aReq
.
b™s
.
way_’
.
toBoŞs


215 
g_¬¿y
.
	`wr™e
(
m‘aIdx
, 
Vec
.
	`fl
(
nWays
)(
m‘aReq
.
b™s
.
d©a
), 
wmask
)

217 
v®
 
s1_m‘a
 = 
g_¬¿y
.
	`»ad
(
m‘aIdx
, 
m‘aReq
.
v®id
 && !m‘aReq.
b™s
.
wr™e
)

218 
v®
 
s1_m‘a_uncÜ»ùed
 = 
s1_m‘a
.
	`m­
(
tECC
.
	`decode
(
_
).
uncÜ»ùed
.
	`asTy³Of
(
Ãw
 
L1M‘ad©a
))

219 
v®
 
s1_g
 = 
s1_·ddr
 >> 
gLSB


220 
v®
 
s1_m‘a_h™_way
 = 
s1_m‘a_uncÜ»ùed
.
	`m­
(
r
 =>„.
coh
.
	`isV®id
(è&&„.
g
 ==ğ
s1_g
).
asUIÁ


221 
v®
 
s1_m‘a_h™_¡©e
 = 
Cl›ÁM‘ad©a
.
ÚRe£t
.
	`äomB™s
(

222 
s1_m‘a_uncÜ»ùed
.
	`m­
(
r
 => 
	`Mux
Ô.
g
 ==ğ
s1_g
 && !
s1_æush_v®id
,„.
coh
.
asUIÁ
, 
	`UIÁ
(0)))

223 .
	`»duû
 (
_
|_))

224 (
s1_m‘a_h™_way
, 
s1_m‘a_h™_¡©e
, 
s1_m‘a
, 
	`s1_m‘a_uncÜ»ùed
(
s1_viùim_way
))

226 
v®
 
s1_d©a_way
 = 
	`Wœe
(
š™
 = ià(
nWays
 =ğ1è1.U 
	`Mux
(
šWr™eback
, 
»Ëa£Way
, 
s1_h™_way
))

227 
v®
 
s1_®l_d©a_ways
 = 
	`Vec
(
d©a
.
io
.
»¥
 :+ 
	`dummyEncodeD©a
(
_out
.
d
.
b™s
.data))

228 
v®
 
s1_mask
 = 
	`Mux
(
s1_»q
.
cmd
 ==ğ
M_PWR
, 
io
.
ıu
.
s1_d©a
.
mask
, 
Ãw
 
	`StÜeG’
(s1_»q.
typ
, s1_»q.
addr
, 
	`UIÁ
(0), 
wÜdBy‹s
).mask)

230 
v®
 
s2_v®id_´e_xıt
 = 
	`Reg
(
Ãxt
=
s1_v®id_masked
 && !
s1_sãnû
, 
š™
=
	`BoŞ
(
çl£
))

231 
v®
 
s2_v®id
 = 
s2_v®id_´e_xıt
 && !
io
.
ıu
.
s2_xıt
.
asUIÁ
.
ÜR


232 
v®
 
s2_´obe
 = 
	`Reg
(
Ãxt
=
s1_´obe
, 
š™
=
	`BoŞ
(
çl£
))

233 
v®
 
»Ëa£InFlight
 = 
s1_´obe
 || 
s2_´obe
 || 
»Ëa£_¡©e
 =/ğ
s_»ady


234 
v®
 
s2_v®id_masked
 = 
s2_v®id
 && 
	`Reg
(
Ãxt
 = !
s1_Çck
)

235 
v®
 
s2_v®id_nÙ_kËd
 = 
s2_v®id_masked
 && !
io
.
ıu
.
s2_kl


236 
v®
 
s2_»q
 = 
	`Reg
(
io
.
ıu
.
»q
.
b™s
)

237 
v®
 
s2_unÿched
 = 
	`Reg
(
	`BoŞ
())

238 
v®
 
s2_unÿched_»¥_addr
 = 
	`Reg
(
	`UIÁ
())

239 
	`wh’
 (
s1_v®id_nÙ_Çcked
 || 
s1_æush_v®id
) {

240 
s2_»q
 :ğ
s1_»q


241 
s2_»q
.
addr
 :ğ
s1_·ddr


242 
s2_unÿched
 :ğ!
b
.
io
.
»¥
.
ÿch—bË


244 
v®
 
s2_vaddr
 = 
	`C©
(
	`RegEÇbË
(
s1_»q
.
addr
, 
s1_v®id_nÙ_Çcked
 || 
s1_æush_v®id
è>> 
pgIdxB™s
, 
s2_»q
.
	`addr
(pgIdxBits-1, 0))

245 
v®
 
s2_»ad
 = 
	`isR—d
(
s2_»q
.
cmd
)

246 
v®
 
s2_wr™e
 = 
	`isWr™e
(
s2_»q
.
cmd
)

247 
v®
 
s2_»adwr™e
 = 
s2_»ad
 || 
s2_wr™e


248 
v®
 
s2_æush_v®id_´e_g_ecc
 = 
	`RegNext
(
s1_æush_v®id
)

249 
v®
 
s1_m‘a_decoded
 = 
s1_m‘a
.
	`m­
(
tECC
.
	`decode
(
_
))

250 
v®
 
s1_m‘a_şk_’
 = 
s1_v®id_nÙ_Çcked
 || 
s1_æush_v®id
 || 
s1_´obe


251 
v®
 
s2_m‘a_cÜ»ùabË_”rÜs
 = 
s1_m‘a_decoded
.
	`m­
(
m
 => 
	`RegEÇbË
(m.
cÜ»ùabË
, 
s1_m‘a_şk_’
)).
asUIÁ


252 
v®
 
s2_m‘a_uncÜ»ùabË_”rÜs
 = 
s1_m‘a_decoded
.
	`m­
(
m
 => 
	`RegEÇbË
(m.
uncÜ»ùabË
, 
s1_m‘a_şk_’
)).
asUIÁ


253 
v®
 
s2_m‘a_”rÜ_uncÜ»ùabË
 = 
s2_m‘a_uncÜ»ùabË_”rÜs
.
ÜR


254 
v®
 
s2_m‘a_cÜ»ùed
 = 
s1_m‘a_decoded
.
	`m­
(
m
 => 
	`RegEÇbË
(m.
cÜ»ùed
, 
s1_m‘a_şk_’
).
	`asTy³Of
(
Ãw
 
L1M‘ad©a
))

255 
v®
 
s2_m‘a_”rÜ
 = (
s2_m‘a_uncÜ»ùabË_”rÜs
 | 
s2_m‘a_cÜ»ùabË_”rÜs
).
ÜR


256 
v®
 
s2_æush_v®id
 = 
s2_æush_v®id_´e_g_ecc
 && !
s2_m‘a_”rÜ


257 
v®
 
s2_d©a
 = {

258 
v®
 
’
 = 
s1_v®id
 || 
šWr™eback


259 ià(
ÿcheP¬ams
.
p–šeWayMux
) {

260 
v®
 
s2_d©a_way
 = 
	`RegEÇbË
(
s1_d©a_way
, 
’
)

261 
v®
 
s2_®l_d©a_ways
 = (0 
uÁ
 
nWays
).
	`m­
(
i
 => 
	`RegEÇbË
(
	`s1_®l_d©a_ways
(i), 
’
))

262 
	`Mux1H
(
s2_d©a_way
, 
s2_®l_d©a_ways
)

264 
	`RegEÇbË
(
	`Mux1H
(
s1_d©a_way
, 
s1_®l_d©a_ways
), 
’
 || 
_out
.
d
.
	`fœe
())

267 
v®
 
s2_´obe_way
 = 
	`RegEÇbË
(
s1_h™_way
, 
s1_´obe
)

268 
v®
 
s2_´obe_¡©e
 = 
	`RegEÇbË
(
s1_h™_¡©e
, 
s1_´obe
)

269 
v®
 
s2_h™_way
 = 
	`RegEÇbË
(
s1_h™_way
, 
s1_v®id_nÙ_Çcked
)

270 
v®
 
s2_h™_¡©e
 = 
	`RegEÇbË
(
s1_h™_¡©e
, 
s1_v®id_nÙ_Çcked
 || 
s1_æush_v®id
)

271 
v®
 
s2_waw_haz¬d
 = 
	`RegEÇbË
(
s1_waw_haz¬d
, 
s1_v®id_nÙ_Çcked
)

272 
v®
 
s2_¡Üe_m”ge
 = 
	`Wœe
(
	`BoŞ
())

273 
v®
 
s2_h™_v®id
 = 
s2_h™_¡©e
.
	`isV®id
()

274 
	`v®
 (
s2_h™
, 
s2_grow_·¿m
, 
s2_Ãw_h™_¡©e
èğ
s2_h™_¡©e
.
	`ÚAcûss
(
s2_»q
.
cmd
)

275 
v®
 
s2_d©a_decoded
 = 
	`decodeD©a
(
s2_d©a
)

276 
v®
 
s2_wÜd_idx
 = 
s2_»q
.
addr
.
	`exŒaù
(
	`log2Up
(
rowB™s
/8)-1,†og2Up(
wÜdBy‹s
))

277 
v®
 
s2_did_»ad
 = 
	`RegEÇbË
(
s1_did_»ad
, 
s1_v®id_nÙ_Çcked
)

278 
v®
 
s2_d©a_”rÜ
 = 
s2_did_»ad
 && (
s2_d©a_decoded
.
	`m­
(
_
.
”rÜ
).
	`grou³d
(
wÜdB™s
/
eccB™s
).m­(_.
	`»duû
(_||_)).
toSeq
)(
s2_wÜd_idx
)

279 
v®
 
s2_d©a_”rÜ_uncÜ»ùabË
 = (
s2_d©a_decoded
.
	`m­
(
_
.
uncÜ»ùabË
).
	`grou³d
(
wÜdB™s
/
eccB™s
).m­(_.
	`»duû
(_||_)).
toSeq
)(
s2_wÜd_idx
)

280 
v®
 
s2_d©a_cÜ»ùed
 = (
s2_d©a_decoded
.
	`m­
(
_
.
cÜ»ùed
): 
Seq
[
UIÁ
]).
asUIÁ


281 
v®
 
s2_d©a_uncÜ»ùed
 = (
s2_d©a_decoded
.
	`m­
(
_
.
uncÜ»ùed
): 
Seq
[
UIÁ
]).
asUIÁ


282 
v®
 
s2_v®id_h™_´e_d©a_ecc
 = 
s2_v®id_masked
 && 
s2_»adwr™e
 && !
s2_m‘a_”rÜ
 && 
s2_h™


283 
v®
 
s2_v®id_d©a_”rÜ
 = 
s2_v®id_h™_´e_d©a_ecc
 && 
s2_d©a_”rÜ
 && 
ÿn_acquœe_befÜe_»Ëa£


284 
v®
 
s2_v®id_h™
 = 
s2_v®id_h™_´e_d©a_ecc
 && !
s2_d©a_”rÜ
 && (!
s2_waw_haz¬d
 || 
s2_¡Üe_m”ge
)

285 
v®
 
s2_v®id_miss
 = 
s2_v®id_masked
 && 
s2_»adwr™e
 && !
s2_m‘a_”rÜ
 && !
s2_h™
 && 
ÿn_acquœe_befÜe_»Ëa£


286 
v®
 
s2_v®id_ÿched_miss
 = 
s2_v®id_miss
 && !
s2_unÿched
 && !
unÿchedInFlight
.
asUIÁ
.
ÜR


287 
	`dÚtTouch
(
s2_v®id_ÿched_miss
)

288 
v®
 
s2_wªt_viùimize
 = 
	`BoŞ
(!
usšgD©aSü©ch·d
è&& (
s2_v®id_ÿched_miss
 || 
s2_v®id_d©a_”rÜ
 || 
s2_æush_v®id
)

289 
v®
 
s2_ÿÂÙ_viùimize
 = !
s2_æush_v®id
 && 
io
.
ıu
.
s2_kl


290 
v®
 
s2_viùimize
 = 
s2_wªt_viùimize
 && !
s2_ÿÂÙ_viùimize


291 
v®
 
s2_v®id_unÿched_³ndšg
 = 
s2_v®id_miss
 && 
s2_unÿched
 && !
unÿchedInFlight
.
asUIÁ
.
ªdR


292 
v®
 
s2_viùim_way
 = 
	`Mux
(
s2_h™_v®id
, 
s2_h™_way
, 
	`UIÁToOH
(
	`RegEÇbË
(
s1_viùim_way
, 
s1_v®id_nÙ_Çcked
 || 
s1_æush_v®id
)))

293 
v®
 
s2_viùim_g
 = 
	`Mux
(
s2_v®id_d©a_”rÜ
, 
s2_»q
.
	`addr
(
·ddrB™s
-1, 
gLSB
), 
	`RegEÇbË
(
s1_viùim_m‘a
.
g
, 
s1_v®id_nÙ_Çcked
 || 
s1_æush_v®id
))

294 
v®
 
s2_viùim_¡©e
 = 
	`Mux
(
s2_h™_v®id
, 
s2_h™_¡©e
, 
	`RegEÇbË
(
s1_viùim_m‘a
.
coh
, 
s1_v®id_nÙ_Çcked
 || 
s1_æush_v®id
))

296 
	`v®
 (
s2_´b_ack_d©a
, 
s2_»pÜt_·¿m
, 
´obeNewCoh
)ğ
s2_´obe_¡©e
.
	`ÚProbe
(
´obe_b™s
.
·¿m
)

297 
	`v®
 (
s2_viùim_dœty
, 
s2_shršk_·¿m
, 
vŞuÁ¬yNewCoh
èğ
s2_viùim_¡©e
.
	`ÚCacheCÚŒŞ
(
M_FLUSH
)

298 
	`dÚtTouch
(
s2_viùim_dœty
)

299 
v®
 
s2_upd©e_m‘a
 = 
s2_h™_¡©e
 =/ğ
s2_Ãw_h™_¡©e


300 
io
.
ıu
.
s2_Çck
 :ğ
s2_v®id
 && !
s2_v®id_h™
 && !(
s2_v®id_unÿched_³ndšg
 && 
_out_a
.
»ady
)

301 
	`wh’
 (
io
.
ıu
.
s2_Çck
 || (
s2_v®id_h™
 && 
s2_upd©e_m‘a
)è{ 
s1_Çck
 :ğ
Œue
 }

304 
v®
 
s2_fœ¡_m‘a_cÜ»ùed
 = 
	`PriÜ™yMux
(
s2_m‘a_cÜ»ùabË_”rÜs
, 
s2_m‘a_cÜ»ùed
)

305 
m‘aArb
.
io
.
	`š
(1).
v®id
 :ğ
s2_m‘a_”rÜ
 && (
s2_v®id_masked
 || 
s2_æush_v®id_´e_g_ecc
 || 
s2_´obe
)

306 
m‘aArb
.
io
.
	`š
(1).
b™s
.
wr™e
 :ğ
Œue


307 
m‘aArb
.
io
.
	`š
(1).
b™s
.
way_’
 :ğ
s2_m‘a_uncÜ»ùabË_”rÜs
 | 
	`Mux
(
s2_m‘a_”rÜ_uncÜ»ùabË
, 0.U, 
	`PriÜ™yEncod”OH
(
s2_m‘a_cÜ»ùabË_”rÜs
))

308 
m‘aArb
.
io
.
	`š
(1).
b™s
.
idx
 :ğ
	`Mux
(
s2_´obe
, 
	`´obeIdx
(
´obe_b™s
), 
	`s2_vaddr
(
idxMSB
, 
idxLSB
))

309 
m‘aArb
.
io
.
	`š
(1).
b™s
.
addr
 :ğ
	`C©
(io.
ıu
.
»q
.b™s.add¸>> 
uÁagB™s
, m‘aArb.io.š(1).b™s.
idx
 << 
blockOffB™s
)

310 
m‘aArb
.
io
.
	`š
(1).
b™s
.
d©a
 :ğ
tECC
.
’code
 {

311 
v®
 
Ãw_m‘a
 = 
	`Wœe
(
š™
 = 
s2_fœ¡_m‘a_cÜ»ùed
)

312 
	`wh’
 (
s2_m‘a_”rÜ_uncÜ»ùabË
è{ 
Ãw_m‘a
.
coh
 :ğ
Cl›ÁM‘ad©a
.
ÚRe£t
 }

313 
Ãw_m‘a
.
asUIÁ


317 
m‘aArb
.
io
.
	`š
(2).
v®id
 :ğ(
s2_v®id_h™
 && 
s2_upd©e_m‘a
è|| (
s2_wªt_viùimize
 && !
s2_viùim_dœty
)

318 
m‘aArb
.
io
.
	`š
(2).
b™s
.
wr™e
 :ğ!
s2_ÿÂÙ_viùimize


319 
m‘aArb
.
io
.
	`š
(2).
b™s
.
way_’
 :ğ
s2_viùim_way


320 
m‘aArb
.
io
.
	`š
(2).
b™s
.
idx
 :ğ
	`s2_vaddr
(
idxMSB
, 
idxLSB
)

321 
m‘aArb
.
io
.
	`š
(2).
b™s
.
addr
 :ğ
	`C©
(io.
ıu
.
»q
.b™s.add¸>> 
uÁagB™s
, 
	`s2_vaddr
(
idxMSB
, 0))

322 
m‘aArb
.
io
.
	`š
(2).
b™s
.
d©a
 :ğ
tECC
.
	`’code
(
	`L1M‘ad©a
(
s2_»q
.
addr
 >> 
gLSB
, 
	`Mux
(
s2_v®id_h™
, 
s2_Ãw_h™_¡©e
, 
Cl›ÁM‘ad©a
.
ÚRe£t
)).
asUIÁ
)

325 
v®
 
s2_Ì
 = 
	`BoŞ
(
usšgAtomics
 && !
usšgD©aSü©ch·d
è&& 
s2_»q
.
cmd
 ==ğ
M_XLR


326 
v®
 
s2_sc
 = 
	`BoŞ
(
usšgAtomics
 && !
usšgD©aSü©ch·d
è&& 
s2_»q
.
cmd
 ==ğ
M_XSC


327 
v®
 
ÌscCouÁ
 = 
	`Reg
(
š™
=
	`UIÁ
(0))

328 
v®
 
ÌscV®id
 = 
ÌscCouÁ
 > 
ÌscBackoff


329 
v®
 
ÌscBackšgOff
 = 
ÌscCouÁ
 > 0 && !
ÌscV®id


330 
v®
 
ÌscAddr
 = 
	`Reg
(
	`UIÁ
())

331 
v®
 
ÌscAddrM©ch
 = 
ÌscAddr
 ==ğ(
s2_»q
.
addr
 >> 
blockOffB™s
)

332 
v®
 
s2_sc_ç
 = 
s2_sc
 && !(
ÌscV®id
 && 
ÌscAddrM©ch
)

333 
	`wh’
 ((
s2_v®id_h™
 && 
s2_Ì
 && !
ÿched_g¿Á_wa™
 || 
s2_v®id_ÿched_miss
è&& !
io
.
ıu
.
s2_kl
) {

334 
ÌscCouÁ
 :ğ
	`Mux
(
s2_h™
, 
ÌscCyşes
 - 1, 0.U)

335 
ÌscAddr
 :ğ
s2_»q
.
addr
 >> 
blockOffB™s


337 
	`wh’
 (
ÌscCouÁ
 > 0) {†rscCount :=†rscCount - 1 }

338 
	`wh’
 (
s2_v®id_nÙ_kËd
 && 
ÌscV®id
è{ 
ÌscCouÁ
 :ğ
ÌscBackoff
 }

339 
	`wh’
 (
s1_´obe
è{ 
ÌscCouÁ
 := 0 }

342 
v®
 
s2_cÜ»ù
 = 
s2_d©a_”rÜ
 && !
ªy_p¡Üe_v®id
 && !
	`RegNext
×ny_p¡Üe_v®idè&& 
	`BoŞ
(
usšgD©aSü©ch·d
)

344 
v®
 
s2_v®id_cÜ»ù
 = 
s2_v®id_h™_´e_d©a_ecc
 && 
s2_cÜ»ù
 && !
io
.
ıu
.
s2_kl


345 
def
 
s2_¡Üe_v®id_´e_kl
 = 
s2_v®id_h™
 && 
s2_wr™e
 && !
s2_sc_ç


346 
def
 
s2_¡Üe_v®id
 = 
s2_¡Üe_v®id_´e_kl
 && !
io
.
ıu
.
s2_kl


347 
v®
 
p¡Üe1_cmd
 = 
	`RegEÇbË
(
s1_»q
.
cmd
, 
s1_v®id_nÙ_Çcked
 && 
s1_wr™e
)

348 
v®
 
p¡Üe1_addr
 = 
	`RegEÇbË
(
s1_»q
.
addr
, 
s1_v®id_nÙ_Çcked
 && 
s1_wr™e
)

349 
v®
 
p¡Üe1_d©a
 = 
	`RegEÇbË
(
io
.
ıu
.
s1_d©a
.
d©a
, 
s1_v®id_nÙ_Çcked
 && 
s1_wr™e
)

350 
v®
 
p¡Üe1_way
 = 
	`RegEÇbË
(
s1_h™_way
, 
s1_v®id_nÙ_Çcked
 && 
s1_wr™e
)

351 
v®
 
p¡Üe1_mask
 = 
	`RegEÇbË
(
s1_mask
, 
s1_v®id_nÙ_Çcked
 && 
s1_wr™e
)

352 
v®
 
p¡Üe1_¡Üeg’_d©a
 = 
	`Wœe
(
š™
 = 
p¡Üe1_d©a
)

353 
v®
 
p¡Üe1_rmw
 = 
	`BoŞ
(
usšgRMW
è&& 
	`RegEÇbË
(
	`ÃedsR—d
(
s1_»q
), 
s1_v®id_nÙ_Çcked
 && 
s1_wr™e
)

354 
v®
 
p¡Üe1_m”ge_lik–y
 = 
s2_v®id
 && 
s2_wr™e
 && 
s2_¡Üe_m”ge


355 
v®
 
p¡Üe1_m”ge
 = 
s2_¡Üe_v®id
 && 
s2_¡Üe_m”ge


356 
v®
 
p¡Üe2_v®id
 = 
	`Reg
(
	`BoŞ
())

357 
v®
 
p¡Üe_d¿š_İpÜtuni¡ic
 = !(
io
.
ıu
.
»q
.
v®id
 && 
	`lik–yN“dsR—d
(io.ıu.»q.
b™s
))

358 
v®
 
p¡Üe_d¿š_Ú_miss
 = 
»Ëa£InFlight


359 
v®
 
p¡Üe1_h–d
 = 
	`Reg
(
	`BoŞ
())

360 
v®
 
p¡Üe1_v®id_lik–y
 = 
s2_v®id
 && 
s2_wr™e
 || 
p¡Üe1_h–d


361 
v®
 
p¡Üe1_v®id_´e_kl
 = 
s2_¡Üe_v®id_´e_kl
 || 
p¡Üe1_h–d


362 
def
 
	`p¡Üe1_v®id_nÙ_rmw
(
s2_kl
: 
BoŞ
èğ
s2_v®id_h™_´e_d©a_ecc
 && (!
s2_waw_haz¬d
 || 
s2_¡Üe_m”ge
è&& 
s2_wr™e
 && !
s2_sc_ç
 && !s2_kÈ|| 
p¡Üe1_h–d


363 
v®
 
p¡Üe1_v®id
 = 
s2_¡Üe_v®id
 || 
p¡Üe1_h–d


364 
ªy_p¡Üe_v®id
 :ğ
p¡Üe1_v®id_´e_kl
 || 
p¡Üe2_v®id


365 
v®
 
p¡Üe_d¿š_¡ruùu¿l
 = 
p¡Üe1_v®id_lik–y
 && 
p¡Üe2_v®id
 && ((
s1_v®id
 && 
s1_wr™e
è|| 
p¡Üe1_rmw
)

366 
	`as£¹
(
p¡Üe1_rmw
 || 
	`p¡Üe1_v®id_nÙ_rmw
(
io
.
ıu
.
s2_kl
è==ğ
p¡Üe1_v®id
)

367 
	`ccov”
(
p¡Üe_d¿š_¡ruùu¿l
, "STORE_STRUCTURAL_HAZARD", "D$„ead-modify-write structural hazard")

368 
	`ccov”
(
p¡Üe1_v®id
 && 
p¡Üe_d¿š_Ú_miss
, "STORE_DRAIN_ON_MISS", "D$ store buffer drain on miss")

369 
	`ccov”
(
s1_v®id_nÙ_Çcked
 && 
s1_waw_haz¬d
, "WAW_HAZARD", "D$ write-after-write hazard")

370 
def
 
	`should_p¡Üe_d¿š
(
Œuly
: 
BoŞ
) = {

371 
v®
 
s2_kl
 = 
Œuly
 && 
io
.
ıu
.s2_kill

372 !
p¡Üe1_m”ge_lik–y
 &&

373 (
	`BoŞ
(
usšgRMW
è&& 
p¡Üe_d¿š_¡ruùu¿l
 ||

374 (((
	`p¡Üe1_v®id_nÙ_rmw
(
s2_kl
è&& !
p¡Üe1_rmw
è|| 
p¡Üe2_v®id
è&& (
p¡Üe_d¿š_İpÜtuni¡ic
 || 
p¡Üe_d¿š_Ú_miss
)))

376 
v®
 
p¡Üe_d¿š
 = 
	`should_p¡Üe_d¿š
(
Œue
)

377 
p¡Üe1_h–d
 :ğ(
s2_¡Üe_v®id
 && !
s2_¡Üe_m”ge
 ||…¡Üe1_h–dè&& 
p¡Üe2_v®id
 && !
p¡Üe_d¿š


378 
v®
 
advªû_p¡Üe1
 = (
p¡Üe1_v®id
 || 
s2_v®id_cÜ»ù
è&& (
p¡Üe2_v®id
 ==ğ
p¡Üe_d¿š
)

379 
p¡Üe2_v®id
 :ğp¡Üe2_v®id && !
p¡Üe_d¿š
 || 
advªû_p¡Üe1


380 
v®
 
p¡Üe2_addr
 = 
	`RegEÇbË
(
	`Mux
(
s2_cÜ»ù
, 
s2_vaddr
, 
p¡Üe1_addr
), 
advªû_p¡Üe1
)

381 
v®
 
p¡Üe2_way
 = 
	`RegEÇbË
(
	`Mux
(
s2_cÜ»ù
, 
s2_h™_way
, 
p¡Üe1_way
), 
advªû_p¡Üe1
)

382 
v®
 
p¡Üe2_¡Üeg’_d©a
 = {

383 
i
 <- 0 
uÁ
 
wÜdBy‹s
)

384 
y›ld
 
	`RegEÇbË
(
	`p¡Üe1_¡Üeg’_d©a
(8*(
i
+1)-1, 8*i), 
advªû_p¡Üe1
 || 
p¡Üe1_m”ge
 && 
	`p¡Üe1_mask
(i))

385 }.
asUIÁ


386 
v®
 
p¡Üe2_¡Üeg’_mask
 = {

387 
v®
 
mask
 = 
	`Reg
(
	`UIÁ
(
width
 = 
wÜdBy‹s
))

388 
	`wh’
 (
advªû_p¡Üe1
 || 
p¡Üe1_m”ge
) {

389 
v®
 
m”gedMask
 = 
p¡Üe1_mask
 | 
	`Mux
(
p¡Üe1_m”ge
, 
mask
, 0.U)

390 
mask
 :ğ~
	`Mux
(
s2_cÜ»ù
, 0.U, ~
m”gedMask
)

392 
mask


394 
s2_¡Üe_m”ge
 :ğ(ià(
eccBy‹s
 =ğ1è
çl£
.
B
 {

395 
	`ccov”
(
p¡Üe1_m”ge
, "STORE_MERGED", "D$ store merged")

398 
v®
 
wÜdM©ch
 = (
	`eccMask
(
p¡Üe2_¡Üeg’_mask
è| ~eccMask(
p¡Üe1_mask
)).
ªdR


399 
v®
 
idxM©ch
 = 
	`s2_vaddr
(
uÁagB™s
-1, 
	`log2Ce
(
wÜdBy‹s
)è==ğ
	`p¡Üe2_addr
(untagBits-1,†og2Ceil(wordBytes))

400 
v®
 
gM©ch
 = (
s2_h™_way
 & 
p¡Üe2_way
).
ÜR


401 
p¡Üe2_v®id
 && 
wÜdM©ch
 && 
idxM©ch
 && 
gM©ch


403 
d©aArb
.
io
.
	`š
(0).
v®id
 :ğ
	`should_p¡Üe_d¿š
(
çl£
)

404 
d©aArb
.
io
.
	`š
(0).
b™s
.
wr™e
 :ğ
p¡Üe_d¿š


405 
d©aArb
.
io
.
	`š
(0).
b™s
.
addr
 :ğ
	`Mux
(
p¡Üe2_v®id
, 
p¡Üe2_addr
, 
p¡Üe1_addr
)

406 
d©aArb
.
io
.
	`š
(0).
b™s
.
way_’
 :ğ
	`Mux
(
p¡Üe2_v®id
, 
p¡Üe2_way
, 
p¡Üe1_way
)

407 
d©aArb
.
io
.
	`š
(0).
b™s
.
wd©a
 :ğ
	`Fl
(
rowWÜds
, 
	`Mux
(
p¡Üe2_v®id
, 
p¡Üe2_¡Üeg’_d©a
, 
p¡Üe1_d©a
))

408 
d©aArb
.
io
.
	`š
(0).
b™s
.
poisÚ
 :ğ
çl£


409 
d©aArb
.
io
.
	`š
(0).
b™s
.
wÜdMask
 :ğ
	`UIÁToOH
(
	`Mux
(
p¡Üe2_v®id
, 
p¡Üe2_addr
, 
p¡Üe1_addr
).
	`exŒaù
(
rowOffB™s
-1,
off£sb
))

410 
d©aArb
.
io
.
	`š
(0).
b™s
.
eccMask
 :ğ
	`eccMask
(
	`Mux
(
p¡Üe2_v®id
, 
p¡Üe2_¡Üeg’_mask
, 
p¡Üe1_mask
))

413 
def
 
	`s1D•’ds
(
addr
: 
UIÁ
, 
mask
: UInt) =

414 
	`addr
(
idxMSB
, 
wÜdOffB™s
è==ğ
s1_»q
.addr(idxMSB, wordOffBits) &&

415 
	`Mux
(
s1_wr™e
, (
	`eccBy‹Mask
(
mask
è&ƒccBy‹Mask(
s1_mask
)).
ÜR
, (mask & s1_mask).orR)

416 
v®
 
s1_haz¬d
 =

417 (
p¡Üe1_v®id_´e_kl
 && 
	`s1D•’ds
(
p¡Üe1_addr
, 
p¡Üe1_mask
)) ||

418 (
p¡Üe2_v®id
 && 
	`s1D•’ds
(
p¡Üe2_addr
, 
p¡Üe2_¡Üeg’_mask
))

419 
v®
 
s1_¿w_haz¬d
 = 
s1_»ad
 && 
s1_haz¬d


420 
s1_waw_haz¬d
 :ğ(ià(
eccBy‹s
 =ğ1è
çl£
.
B
 {

421 
	`ccov”
(
s1_v®id_nÙ_Çcked
 && 
s1_waw_haz¬d
, "WAW_HAZARD", "D$ write-after-write hazard")

422 
s1_wr™e
 && (
s1_haz¬d
 || 
	`ÃedsR—d
(
s1_»q
è&& !
s1_did_»ad
)

424 
	`wh’
 (
s1_v®id
 && 
s1_¿w_haz¬d
è{ 
s1_Çck
 :ğ
Œue
 }

427 
io
.
ıu
.
s2_Çck_ÿu£_¿w
 :ğ
	`RegNext
(
s1_¿w_haz¬d
)

430 
v®
 
a_sourû
 = 
	`PriÜ™yEncod”
(~
unÿchedInFlight
.
asUIÁ
 << 
mmioOff£t
)

431 
v®
 
acquœe_add»ss
 = (
s2_»q
.
addr
 >> 
idxLSB
) << idxLSB

432 
v®
 
acûss_add»ss
 = 
s2_»q
.
addr


433 
v®
 
a_size
 = 
	`mtSize
(
s2_»q
.
typ
)

434 
v®
 
a_d©a
 = 
	`Fl
(
b—tWÜds
, 
p¡Üe1_d©a
)

435 
v®
 
g‘
 = 
edge
.
	`G‘
(
a_sourû
, 
acûss_add»ss
, 
a_size
).
_2


436 
v®
 
put
 = 
edge
.
	`Put
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
).
_2


437 
v®
 
©omics
 = ià(
edge
.
mªag”
.
ªySuµÜtLogiÿl
) {

438 
	`MuxLookup
(
s2_»q
.
cmd
, 
	`Wœe
(
Ãw
 
	`TLBundËA
(
edge
.
bundË
)), 
	`A¼ay
(

439 
M_XA_SWAP
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
SWAP
).
_2
,

440 
M_XA_XOR
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
XOR
è.
_2
,

441 
M_XA_OR
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
OR
è.
_2
,

442 
M_XA_AND
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
AND
è.
_2
,

443 
M_XA_ADD
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
ADD
).
_2
,

444 
M_XA_MIN
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MIN
).
_2
,

445 
M_XA_MAX
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAX
).
_2
,

446 
M_XA_MINU
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MINU
).
_2
,

447 
M_XA_MAXU
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
acûss_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAXU
).
_2
))

450 
	`as£¹
 (!(
_out_a
.
v®id
 && 
s2_»ad
 && 
s2_wr™e
 && 
s2_unÿched
))

451 
	`Wœe
(
Ãw
 
	`TLBundËA
(
edge
.
bundË
))

454 
_out_a
.
v®id
 :ğ!
io
.
ıu
.
s2_kl
 && ((
s2_v®id_ÿched_miss
 && (
	`BoŞ
(
ÿcheP¬ams
.
acquœeBefÜeR–—£
è|| !
s2_viùim_dœty
)è|| 
s2_v®id_unÿched_³ndšg
)

455 
_out_a
.
b™s
 :ğ
	`Mux
(!
s2_unÿched
, 
	`acquœe
(
s2_vaddr
, 
s2_»q
.
addr
, 
s2_grow_·¿m
), Mux(!
s2_wr™e
, 
g‘
, Mux(!
s2_»ad
, 
put
, 
©omics
)))

458 
v®
 
a_£l
 = 
	`UIÁToOH
(
a_sourû
, 
maxUnÿchedInFlight
+
mmioOff£t
) >> mmioOffset

459 
	`wh’
 (
_out_a
.
	`fœe
()) {

460 
	`wh’
 (
s2_unÿched
) {

461 (
a_£l
.
toBoŞs
 
	`z
 (
unÿchedInFlight
 
z
 
unÿchedReqs
)è
fÜ—ch
 { (
s
, (
f
, 
r
)) =>

462 
	`wh’
 (
s
) {

463 
f
 :ğ
	`BoŞ
(
Œue
)

464 
r
 :ğ
s2_»q


467 }.
Ùh”wi£
 {

468 
ÿched_g¿Á_wa™
 :ğ
Œue


473 
	`v®
 (
d_fœ¡
, 
d_Ï¡
, 
d_dÚe
, 
d_add»ss_šc
èğ
edge
.
	`addr_šc
(
_out
.
d
)

474 
	`v®
 (
d_İc
, 
g¿ÁIsUnÿched
, 
g¿ÁIsUnÿchedD©a
) = {

475 
v®
 
unÿchedG¿ÁOpcodesSªsD©a
 = 
	`Seq
(
AcûssAck
, 
HštAck
)

476 
v®
 
unÿchedG¿ÁOpcodesW™hD©a
 = 
	`Seq
(
AcûssAckD©a
)

477 
v®
 
unÿchedG¿ÁOpcodes
 = 
unÿchedG¿ÁOpcodesW™hD©a
 ++ 
unÿchedG¿ÁOpcodesSªsD©a


478 
v®
 
whŞe_İc
 = 
_out
.
d
.
b™s
.
İcode


479 ià(
usšgD©aSü©ch·d
) {

480 
	`as£¹
(!
_out
.
d
.
v®id
 || 
whŞe_İc
.
	`isOÃOf
(
unÿchedG¿ÁOpcodes
))

482 
v®
 
İc
 = 
	`whŞe_İc
(
unÿchedG¿ÁOpcodes
.
	`m­
(
_
.
g‘Width
).
max
 - 1, 0)

483 
v®
 
d©a
 = 
	`DecodeLogic
(
İc
, 
unÿchedG¿ÁOpcodesW™hD©a
, 
unÿchedG¿ÁOpcodesSªsD©a
)

484 (
İc
, 
Œue
.
B
, 
d©a
)

486 (
whŞe_İc
, whŞe_İc.
	`isOÃOf
(
unÿchedG¿ÁOpcodes
), whŞe_İc.isOÃOf(
unÿchedG¿ÁOpcodesW™hD©a
))

489 
v®
 
g¿ÁIsCached
 = 
d_İc
.
	`isOÃOf
(
G¿Á
, 
G¿ÁD©a
)

490 
v®
 
g¿ÁIsVŞuÁ¬y
 = 
d_İc
 ==ğ
R–—£Ack


491 
v®
 
g¿ÁIsRefl
 = 
d_İc
 ==ğ
G¿ÁD©a


492 
v®
 
g¿ÁInProg»ss
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

493 
v®
 
blockProbeAá”G¿ÁCouÁ
 = 
	`Reg
(
š™
=
	`UIÁ
(0))

494 
	`wh’
 (
blockProbeAá”G¿ÁCouÁ
 > 0) { blockProbeAfterGrantCount := blockProbeAfterGrantCount - 1 }

495 
v®
 
ÿnAcû±CachedG¿Á
 = ià(
ÿcheP¬ams
.
acquœeBefÜeR–—£
è!
»Ëa£_¡©e
.
	`isOÃOf
(
s_vŞuÁ¬y_wr™eback
, 
s_vŞuÁ¬y_wr™e_m‘a
è
Œue
.
B


496 
_out
.
d
.
»ady
 :ğ
	`Mux
(
g¿ÁIsCached
, (!
d_fœ¡
 ||l_out.
e
.»adyè&& 
ÿnAcû±CachedG¿Á
, 
Œue
.
B
)

497 
	`wh’
 (
_out
.
d
.
	`fœe
()) {

498 
	`wh’
 (
g¿ÁIsCached
) {

499 
g¿ÁInProg»ss
 :ğ
Œue


500 
	`as£¹
(
ÿched_g¿Á_wa™
, "A GrantData was unexpected byhe dcache.")

501 
	`wh’
(
d_Ï¡
) {

502 
ÿched_g¿Á_wa™
 :ğ
çl£


503 
g¿ÁInProg»ss
 :ğ
çl£


504 
blockProbeAá”G¿ÁCouÁ
 :ğ
blockProbeAá”G¿ÁCyşes
 - 1

505 
»¶aûr
.
miss


507 } .
	`–£wh’
 (
g¿ÁIsUnÿched
) {

508 
v®
 
d_£l
 = 
	`UIÁToOH
(
_out
.
d
.
b™s
.
sourû
, 
maxUnÿchedInFlight
+
mmioOff£t
) >> mmioOffset

509 
v®
 
»q
 = 
	`Mux1H
(
d_£l
, 
unÿchedReqs
)

510 (
d_£l
.
toBoŞs
 
z
 
unÿchedInFlight
è
fÜ—ch
 { (
s
, 
f
) =>

511 
	`wh’
 (
s
 && 
d_Ï¡
) {

512 
	`as£¹
(
f
, "An AccessAck was unexpected byhe dcache.")

513 
f
 :ğ
çl£


516 
	`wh’
 (
g¿ÁIsUnÿchedD©a
) {

517 ià(!
ÿcheP¬ams
.
p–šeWayMux
)

518 
s1_d©a_way
 :ğ1.U << 
nWays


519 
s2_»q
.
cmd
 :ğ
M_XRD


520 
s2_»q
.
typ
 :ğ
»q
.typ

521 
s2_»q
.
g
 :ğ
»q
.tag

522 
s2_»q
.
addr
 := {

523 
	`»quœe
(
rowOffB™s
 >ğ
b—tOffB™s
)

524 
v®
 
dÚtC¬eB™s
 = 
s1_·ddr
 >> 
rowOffB™s
 <<„owOffBits

525 
dÚtC¬eB™s
 | 
»q
.
	`addr
(
b—tOffB™s
-1, 0)

527 
s2_unÿched_»¥_addr
 :ğ
»q
.
addr


529 } .
	`–£wh’
 (
g¿ÁIsVŞuÁ¬y
) {

530 
	`as£¹
(
»Ëa£_ack_wa™
, "A ReleaseAck was unexpected byhe dcache.")

531 
»Ëa£_ack_wa™
 :ğ
çl£


536 
_out
.
e
.
v®id
 :ğ_out.
d
.v®id && 
d_fœ¡
 && 
g¿ÁIsCached
 && 
ÿnAcû±CachedG¿Á


537 
_out
.
e
.
b™s
 :ğ
edge
.
	`G¿ÁAck
Ñl_out.
d
.bits)

538 
	`as£¹
(
_out
.
e
.
	`fœe
(è==ğÑl_out.
d
.fœe(è&& 
d_fœ¡
 && 
g¿ÁIsCached
))

543 
d©aArb
.
io
.
	`š
(1).
v®id
 :ğ
_out
.
d
.v®id && 
g¿ÁIsRefl
 && 
ÿnAcû±CachedG¿Á


544 
	`wh’
 (
g¿ÁIsRefl
 && !
d©aArb
.
io
.
	`š
(1).
»ady
) {

545 
_out
.
e
.
v®id
 :ğ
çl£


546 
_out
.
d
.
»ady
 :ğ
çl£


548 ià(!
usšgD©aSü©ch·d
) {

549 
d©aArb
.
io
.
	`š
(1).
b™s
.
wr™e
 :ğ
Œue


550 
d©aArb
.
io
.
	`š
(1).
b™s
.
addr
 :ğ(
s2_vaddr
 >> 
idxLSB
è<< idxLSB | 
d_add»ss_šc


551 
d©aArb
.
io
.
	`š
(1).
b™s
.
way_’
 :ğ
s2_viùim_way


552 
d©aArb
.
io
.
	`š
(1).
b™s
.
wd©a
 :ğ
_out
.
d
.b™s.
d©a


553 
d©aArb
.
io
.
	`š
(1).
b™s
.
poisÚ
 :ğ
_out
.
d
.b™s.
cÜru±


554 
d©aArb
.
io
.
	`š
(1).
b™s
.
wÜdMask
 :ğ~
	`UIÁ
(0, 
rowBy‹s
 / 
wÜdBy‹s
)

555 
d©aArb
.
io
.
	`š
(1).
b™s
.
eccMask
 :ğ~
	`UIÁ
(0, 
wÜdBy‹s
 / 
eccBy‹s
)

557 
d©aArb
.
io
.
	`š
(1).
b™s
 := dataArb.io.in(0).bits

564 
m‘aArb
.
io
.
	`š
(3).
v®id
 :ğ
g¿ÁIsCached
 && 
d_dÚe
 && !
_out
.
d
.
b™s
.
d’›d


565 
m‘aArb
.
io
.
	`š
(3).
b™s
.
wr™e
 :ğ
Œue


566 
m‘aArb
.
io
.
	`š
(3).
b™s
.
way_’
 :ğ
s2_viùim_way


567 
m‘aArb
.
io
.
	`š
(3).
b™s
.
idx
 :ğ
	`s2_vaddr
(
idxMSB
, 
idxLSB
)

568 
m‘aArb
.
io
.
	`š
(3).
b™s
.
addr
 :ğ
	`C©
(io.
ıu
.
»q
.b™s.add¸>> 
uÁagB™s
, 
	`s2_vaddr
(
idxMSB
, 0))

569 
m‘aArb
.
io
.
	`š
(3).
b™s
.
d©a
 :ğ
tECC
.
	`’code
(
	`L1M‘ad©a
(
s2_»q
.
addr
 >> 
gLSB
, 
s2_h™_¡©e
.
	`ÚG¿Á
(s2_»q.
cmd
, 
_out
.
d
.b™s.
·¿m
)).
asUIÁ
)

572 
v®
 
blockUnÿchedG¿Á
 = 
	`Reg
(
	`BoŞ
())

573 
blockUnÿchedG¿Á
 :ğ
d©aArb
.
io
.
out
.
v®id


574 
	`wh’
 (
g¿ÁIsUnÿchedD©a
 && (
blockUnÿchedG¿Á
 || 
s1_v®id
)) {

575 
_out
.
d
.
»ady
 :ğ
çl£


577 
	`wh’
 (
_out
.
d
.
v®id
) {

578 
io
.
ıu
.
»q
.
»ady
 :ğ
çl£


579 
d©aArb
.
io
.
	`š
(1).
v®id
 :ğ
Œue


580 
d©aArb
.
io
.
	`š
(1).
b™s
.
wr™e
 :ğ
çl£


581 
blockUnÿchedG¿Á
 :ğ!
d©aArb
.
io
.
	`š
(1).
»ady


584 
	`ccov”
(
_out
.
d
.
v®id
 && !_out.d.
»ady
, "BLOCK_D", "D$ D-channel blocked")

587 
v®
 
block_´obe
 = 
»Ëa£InFlight
 || 
g¿ÁInProg»ss
 || 
blockProbeAá”G¿ÁCouÁ
 > 0 || 
ÌscV®id


588 
m‘aArb
.
io
.
	`š
(6).
v®id
 :ğ
_out
.
b
.v®id && (!
block_´obe
 || 
ÌscBackšgOff
)

589 
_out
.
b
.
»ady
 :ğ
m‘aArb
.
io
.
	`š
(6).»ady && !
block_´obe
 && !
s1_v®id
 && !
s2_v®id


590 
m‘aArb
.
io
.
	`š
(6).
b™s
.
wr™e
 :ğ
çl£


591 
m‘aArb
.
io
.
	`š
(6).
b™s
.
idx
 :ğ
	`´obeIdx
(
_out
.
b
.bits)

592 
m‘aArb
.
io
.
	`š
(6).
b™s
.
addr
 :ğ
	`C©
(io.
ıu
.
»q
.b™s.add¸>> 
·ddrB™s
, 
_out
.
b
.b™s.
add»ss
)

593 
m‘aArb
.
io
.
	`š
(6).
b™s
.
way_’
 := metaArb.io.in(4).bits.way_en

594 
m‘aArb
.
io
.
	`š
(6).
b™s
.
d©a
 := metaArb.io.in(4).bits.data

597 
	`v®
 (
c_fœ¡
, 
c_Ï¡
, 
»Ëa£DÚe
, 
c_couÁ
èğ
edge
.
	`couÁ
(
_out_c
)

598 
v®
 
»Ëa£Rejeùed
 = 
_out_c
.
v®id
 && !_out_c.
»ady


599 
v®
 
s1_»Ëa£_d©a_v®id
 = 
	`Reg
(
Ãxt
 = 
d©aArb
.
io
.
	`š
(2).
	`fœe
())

600 
v®
 
s2_»Ëa£_d©a_v®id
 = 
	`Reg
(
Ãxt
 = 
s1_»Ëa£_d©a_v®id
 && !
»Ëa£Rejeùed
)

601 
v®
 
»Ëa£D©aB—t
 = 
	`C©
(
	`UIÁ
(0), 
c_couÁ
è+ 
	`Mux
(
»Ëa£Rejeùed
, UIÁ(0), 
s1_»Ëa£_d©a_v®id
 + C©(UIÁ(0), 
s2_»Ëa£_d©a_v®id
))

602 
v®
 
wr™eback_d©a_”rÜ
 = 
s2_d©a_decoded
.
	`m­
(
_
.
”rÜ
).
	`»duû
(_||_)

603 
v®
 
wr™eback_d©a_uncÜ»ùabË
 = 
s2_d©a_decoded
.
	`m­
(
_
.
uncÜ»ùabË
).
	`»duû
(_||_)

605 
v®
 
ÇckRe¥Ú£Mes§ge
 = 
edge
.
	`ProbeAck
(
b
 = 
´obe_b™s
, 
»pÜtP”missiÚs
 = 
TLP”missiÚs
.
NtoN
)

606 
v®
 
ş—nR–—£Mes§ge
 = 
edge
.
	`ProbeAck
(
b
 = 
´obe_b™s
, 
»pÜtP”missiÚs
 = 
s2_»pÜt_·¿m
)

607 
v®
 
dœtyR–—£Mes§ge
 = 
edge
.
	`ProbeAck
(
b
 = 
´obe_b™s
, 
»pÜtP”missiÚs
 = 
s2_»pÜt_·¿m
, 
d©a
 = 0.U)

609 
_out_c
.
v®id
 :ğ
s2_»Ëa£_d©a_v®id


610 
_out_c
.
b™s
 :ğ
ÇckRe¥Ú£Mes§ge


611 
v®
 
ÃwCoh
 = 
	`Wœe
(
š™
 = 
´obeNewCoh
)

612 
»Ëa£Way
 :ğ
s2_´obe_way


614 ià(!
usšgD©aSü©ch·d
) {

615 
	`wh’
 (
s2_viùimize
 && 
s2_viùim_dœty
) {

616 
	`as£¹
(!(
s2_v®id
 && 
s2_h™_v®id
 && !
s2_d©a_”rÜ
))

617 
»Ëa£_¡©e
 :ğ
s_vŞuÁ¬y_wr™eback


618 
´obe_b™s
 :ğ
	`add»ssToProbe
(
s2_vaddr
, 
	`C©
(
s2_viùim_g
, 
s2_»q
.
	`addr
(
gLSB
-1, 
idxLSB
)) << idxLSB)

620 
	`wh’
 (
s2_´obe
) {

621 
v®
 
´obeNack
 = 
	`Wœe
(
š™
 = 
Œue
.
B
)

622 
	`wh’
 (
s2_m‘a_”rÜ
) {

623 
»Ëa£_¡©e
 :ğ
s_´obe_»Œy


624 }.
	`–£wh’
 (
s2_´b_ack_d©a
) {

625 
»Ëa£_¡©e
 :ğ
s_´obe_»p_dœty


626 }.
	`–£wh’
 (
s2_´obe_¡©e
.
	`isV®id
()) {

627 
_out_c
.
v®id
 :ğ
Œue


628 
_out_c
.
b™s
 :ğ
ş—nR–—£Mes§ge


629 
»Ëa£_¡©e
 :ğ
	`Mux
(
»Ëa£DÚe
, 
s_´obe_wr™e_m‘a
, 
s_´obe_»p_ş—n
)

630 }.
Ùh”wi£
 {

631 
_out_c
.
v®id
 :ğ
Œue


632 
´obeNack
 :ğ!
»Ëa£DÚe


633 
»Ëa£_¡©e
 :ğ
	`Mux
(
»Ëa£DÚe
, 
s_»ady
, 
s_´obe_»p_miss
)

635 
	`wh’
 (
´obeNack
è{ 
s1_Çck
 :ğ
Œue
 }

637 
	`wh’
 (
»Ëa£_¡©e
 ==ğ
s_´obe_»Œy
) {

638 
m‘aArb
.
io
.
	`š
(6).
v®id
 :ğ
Œue


639 
m‘aArb
.
io
.
	`š
(6).
b™s
.
idx
 :ğ
	`´obeIdx
(
´obe_b™s
)

640 
m‘aArb
.
io
.
	`š
(6).
b™s
.
addr
 :ğ
	`C©
(io.
ıu
.
»q
.b™s.add¸>> 
·ddrB™s
, 
´obe_b™s
.
add»ss
)

641 
	`wh’
 (
m‘aArb
.
io
.
	`š
(6).
»ady
) {

642 
»Ëa£_¡©e
 :ğ
s_»ady


643 
s1_´obe
 :ğ
Œue


646 
	`wh’
 (
»Ëa£_¡©e
 ==ğ
s_´obe_»p_miss
) {

647 
_out_c
.
v®id
 :ğ
Œue


648 
	`wh’
 (
»Ëa£DÚe
è{ 
»Ëa£_¡©e
 :ğ
s_»ady
 }

650 
	`wh’
 (
»Ëa£_¡©e
 ==ğ
s_´obe_»p_ş—n
) {

651 
_out_c
.
v®id
 :ğ
Œue


652 
_out_c
.
b™s
 :ğ
ş—nR–—£Mes§ge


653 
	`wh’
 (
»Ëa£DÚe
è{ 
»Ëa£_¡©e
 :ğ
s_´obe_wr™e_m‘a
 }

655 
	`wh’
 (
»Ëa£_¡©e
 ==ğ
s_´obe_»p_dœty
) {

656 
_out_c
.
b™s
 :ğ
dœtyR–—£Mes§ge


657 
	`wh’
 (
»Ëa£DÚe
è{ 
»Ëa£_¡©e
 :ğ
s_´obe_wr™e_m‘a
 }

659 
	`wh’
 (
»Ëa£_¡©e
.
	`isOÃOf
(
s_vŞuÁ¬y_wr™eback
, 
s_vŞuÁ¬y_wr™e_m‘a
)) {

660 
_out_c
.
b™s
 :ğ
edge
.
	`R–—£
(
äomSourû
 = 0.U,

661 
toAdd»ss
 = 0.U,

662 
lgSize
 = 
lgCacheBlockBy‹s
,

663 
shrškP”missiÚs
 = 
s2_shršk_·¿m
,

664 
d©a
 = 0.U).
_2


665 
ÃwCoh
 :ğ
vŞuÁ¬yNewCoh


666 
»Ëa£Way
 :ğ
s2_viùim_way


667 
	`wh’
 (
»Ëa£DÚe
è{ 
»Ëa£_¡©e
 :ğ
s_vŞuÁ¬y_wr™e_m‘a
 }

668 
	`wh’
 (
_out_c
.
	`fœe
(è&& 
c_fœ¡
è{ 
»Ëa£_ack_wa™
 :ğ
Œue
 }

670 
_out_c
.
b™s
.
sourû
 :ğ
´obe_b™s
.source

671 
_out_c
.
b™s
.
add»ss
 :ğ
´obe_b™s
.address

672 
_out_c
.
b™s
.
d©a
 :ğ
s2_d©a_cÜ»ùed


673 
_out_c
.
b™s
.
cÜru±
 :ğ
šWr™eback
 && 
wr™eback_d©a_uncÜ»ùabË


676 
d©aArb
.
io
.
	`š
(2).
v®id
 :ğ
šWr™eback
 && 
»Ëa£D©aB—t
 < 
»flCyşes


677 
d©aArb
.
io
.
	`š
(2).
b™s
 := dataArb.io.in(1).bits

678 
d©aArb
.
io
.
	`š
(2).
b™s
.
wr™e
 :ğ
çl£


679 
d©aArb
.
io
.
	`š
(2).
b™s
.
addr
 :ğ(
	`´obeIdx
(
´obe_b™s
è<< 
blockOffB™s
è| (
	`»Ëa£D©aB—t
(
	`log2Up
(
»flCyşes
)-1,0è<< 
rowOffB™s
)

680 
d©aArb
.
io
.
	`š
(2).
b™s
.
wÜdMask
 :ğ~
	`UIÁ
(0, 
rowBy‹s
 / 
wÜdBy‹s
)

681 
d©aArb
.
io
.
	`š
(2).
b™s
.
way_’
 :ğ~
	`UIÁ
(0, 
nWays
)

683 
m‘aArb
.
io
.
	`š
(4).
v®id
 :ğ
»Ëa£_¡©e
.
	`isOÃOf
(
s_vŞuÁ¬y_wr™e_m‘a
, 
s_´obe_wr™e_m‘a
)

684 
m‘aArb
.
io
.
	`š
(4).
b™s
.
wr™e
 :ğ
Œue


685 
m‘aArb
.
io
.
	`š
(4).
b™s
.
way_’
 :ğ
»Ëa£Way


686 
m‘aArb
.
io
.
	`š
(4).
b™s
.
idx
 :ğ
	`´obeIdx
(
´obe_b™s
)

687 
m‘aArb
.
io
.
	`š
(4).
b™s
.
addr
 :ğ
	`C©
(io.
ıu
.
»q
.b™s.add¸>> 
uÁagB™s
, 
´obe_b™s
.
	`add»ss
(
idxMSB
, 0))

688 
m‘aArb
.
io
.
	`š
(4).
b™s
.
d©a
 :ğ
tECC
.
	`’code
(
	`L1M‘ad©a
(
_out_c
.b™s.
add»ss
 >> 
gLSB
, 
ÃwCoh
).
asUIÁ
)

689 
	`wh’
 (
m‘aArb
.
io
.
	`š
(4).
	`fœe
()è{ 
»Ëa£_¡©e
 :ğ
s_»ady
 }

692 
io
.
ıu
.
»¥
.
v®id
 :ğ
s2_v®id_h™


693 
io
.
ıu
.
»¥
.
b™s
 <> 
s2_»q


694 
io
.
ıu
.
»¥
.
b™s
.
has_d©a
 :ğ
s2_»ad


695 
io
.
ıu
.
»¥
.
b™s
.
»¶ay
 :ğ
çl£


699 
v®
 
s1_isSÏvePÜtAcûss
 = 
usšgD©aSü©ch·d
 && 
s1_»q
.
phys


700 
v®
 
s2_isSÏvePÜtAcûss
 = 
usšgD©aSü©ch·d
 && 
s2_»q
.
phys


701 
io
.
ıu
.
Üd”ed
 :ğ!(
s1_v®id
 && !
s1_isSÏvePÜtAcûss
 || 
s2_v®id
 && !
s2_isSÏvePÜtAcûss
 || 
ÿched_g¿Á_wa™
 || 
unÿchedInFlight
.
asUIÁ
.
ÜR
)

703 
v®
 
s1_xıt_v®id
 = 
b
.
io
.
»q
.
v®id
 && !
s1_Çck


704 
v®
 
s1_xıt
 = 
b
.
io
.
»¥


705 
io
.
ıu
.
s2_xıt
 :ğ
	`Mux
(
	`RegNext
(
s1_xıt_v®id
), 
	`RegEÇbË
(
s1_xıt
, 
s1_v®id_nÙ_Çcked
), 0.U.a
	`sTy³Of
(s1_xcpt))

707 ià(
usšgD©aSü©ch·d
) {

708 
	`»quœe
(!
usšgVM
)

709 
	`wh’
 (
s2_isSÏvePÜtAcûss
) {

710 
	`as£¹
(!
s2_v®id
 || 
s2_h™_v®id
)

711 
io
.
ıu
.
s2_xıt
 :ğ0.U.a
	`sTy³Of
(io.cpu.s2_xcpt)

713 
	`as£¹
(!(
s2_v®id_masked
 && 
s2_»q
.
cmd
.
	`isOÃOf
(
M_XLR
, 
M_XSC
)))

715 
	`ccov”
(
_out
.
b
.
v®id
 && !_out.b.
»ady
, "BLOCK_B", "D$ B-channel blocked")

719 
io
.
ıu
.
»¶ay_Ãxt
 :ğ
_out
.
d
.
	`fœe
(è&& 
g¿ÁIsUnÿchedD©a


720 
v®
 
doUnÿchedRe¥
 = 
	`Reg
(
Ãxt
 = 
io
.
ıu
.
»¶ay_Ãxt
)

721 
v®
 
s2_unÿched_d©a_b—t
 = 
	`RegEÇbË
(
_out
.
d
.
b™s
.
d©a
, 
io
.
ıu
.
»¶ay_Ãxt
)

722 
	`wh’
 (
doUnÿchedRe¥
) {

723 
	`as£¹
(!
s2_v®id_h™
)

724 
io
.
ıu
.
»¥
.
v®id
 :ğ
Œue


725 
io
.
ıu
.
»¥
.
b™s
.
»¶ay
 :ğ
Œue


726 
io
.
ıu
.
»¥
.
b™s
.
addr
 :ğ
s2_unÿched_»¥_addr


730 
v®
 
s2_d©a_wÜd
 = ((0 
uÁ
 
rowB™s
 
by
 
wÜdB™s
).
	`m­
(
i
 => 
	`s2_d©a_uncÜ»ùed
(wÜdB™s+i-1,i)): 
Seq
[
UIÁ
])(
s2_wÜd_idx
)

731 
v®
 
s2_d©a_wÜd_cÜ»ùed
 = ((0 
uÁ
 
rowB™s
 
by
 
wÜdB™s
).
	`m­
(
i
 => 
	`s2_d©a_cÜ»ùed
(wÜdB™s+i-1,i)): 
Seq
[
UIÁ
])(
s2_wÜd_idx
)

732 
v®
 
s2_unÿched_d©a_wÜd
 = ((0 
uÁ
 
ÿcheD©aB™s
 
by
 
wÜdB™s
).
	`m­
(
i
 => 
	`s2_unÿched_d©a_b—t
(wÜdB™s+i-1,i)): 
Seq
[
UIÁ
])(
s2_wÜd_idx
)

733 
v®
 
s2_d©a_wÜd_possibly_unÿched
 = 
	`Mux
(
ÿcheP¬ams
.
p–šeWayMux
 && 
doUnÿchedRe¥
, 
s2_unÿched_d©a_wÜd
, 
s2_d©a_wÜd
)

734 
v®
 
lßdg’
 = 
Ãw
 
	`LßdG’
(
s2_»q
.
typ
, 
	`mtSigÃd
(s2_»q.typ), s2_»q.
addr
, 
s2_d©a_wÜd_possibly_unÿched
, 
s2_sc
, 
wÜdBy‹s
)

735 
io
.
ıu
.
»¥
.
b™s
.
d©a
 :ğ
lßdg’
.d©¨| 
s2_sc_ç


736 
io
.
ıu
.
»¥
.
b™s
.
d©a_wÜd_by·ss
 :ğ
lßdg’
.
wÜdD©a


737 
io
.
ıu
.
»¥
.
b™s
.
d©a_¿w
 :ğ
s2_d©a_wÜd


738 
io
.
ıu
.
»¥
.
b™s
.
¡Üe_d©a
 :ğ
p¡Üe1_d©a


741 ià(
usšgRMW
) {

743 
v®
 
amßlu
 = 
	`ModuË
(
Ãw
 
	`AMOALU
(
cÜeD©aB™s
))

744 
amßlu
.
io
.
mask
 :ğ
p¡Üe1_mask


745 
amßlu
.
io
.
cmd
 :ğ(ià(
usšgAtomicsInCache
è
p¡Üe1_cmd
 
M_XWR
)

746 
amßlu
.
io
.
lhs
 :ğ
s2_d©a_wÜd


747 
amßlu
.
io
.
rhs
 :ğ
p¡Üe1_d©a


748 
p¡Üe1_¡Üeg’_d©a
 :ğ(ià(!
usšgD©aSü©ch·d
è
amßlu
.
io
.
out
 {

749 
v®
 
mask
 = 
	`FlIÁ”Ëaved
(8, 
	`Mux
(
s2_cÜ»ù
, 0.U, 
p¡Üe1_mask
))

750 
amßlu
.
io
.
out_unmasked
 & 
mask
 | 
s2_d©a_wÜd_cÜ»ùed
 & ~mask

752 } ià(!
usšgAtomics
) {

753 
	`as£¹
(!(
s1_v®id_masked
 && 
s1_»ad
 && 
s1_wr™e
), "unsupported D$ operation")

757 
v®
 
»£‰šg
 = 
	`RegIn™
(
çl£
.
B
)

758 ià(!
usšgD©aSü©ch·d
)

759 
	`wh’
 (
	`RegNext
(
»£t
)è{ 
»£‰šg
 :ğ
Œue
 }

760 
v®
 
æushed
 = 
	`Reg
(
š™
=
	`BoŞ
(
Œue
))

761 
v®
 
æushšg
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

762 
v®
 
æushCouÁ”
 = 
	`Reg
(
š™
=
	`UIÁ
(
nS‘s
 * (
nWays
-1), 
	`log2Ce
(nSets *‚Ways)))

763 
v®
 
æushCouÁ”Next
 = 
æushCouÁ”
 +& 1

764 
v®
 
æushDÚe
 = (
æushCouÁ”Next
 >> 
	`log2Ce
(
nS‘s
)è==ğ
nWays


765 
v®
 
æushCouÁ”W¿p
 = 
	`æushCouÁ”Next
(
	`log2Ce
(
nS‘s
)-1, 0)

766 
	`wh’
 (
s2_v®id_masked
 && 
s2_»q
.
cmd
 ==ğ
M_FLUSH_ALL
) {

767 
io
.
ıu
.
s2_Çck
 :ğ!
æushed


768 
	`wh’
 (!
æushed
) {

769 
æushšg
 :ğ!
io
.
ıu
.
s2_kl
 && !
»Ëa£_ack_wa™
 && !
unÿchedInFlight
.
asUIÁ
.
ÜR


772 
	`ccov”
(
s2_v®id_masked
 && 
s2_»q
.
cmd
 ==ğ
M_FLUSH_ALL
 && 
s2_m‘a_”rÜ
, "TAG_ECC_ERROR_DURING_FENCE_I", "D$ ECCƒrror inag‡rray during cache flush")

773 
	`ccov”
(
s2_v®id_masked
 && 
s2_»q
.
cmd
 ==ğ
M_FLUSH_ALL
 && 
s2_d©a_”rÜ
, "DATA_ECC_ERROR_DURING_FENCE_I", "D$ ECCƒrror in data‡rray during cache flush")

774 
s1_æush_v®id
 :ğ
m‘aArb
.
io
.
	`š
(5).
	`fœe
(è&& !s1_æush_v®id && !
s2_æush_v®id_´e_g_ecc
 && 
»Ëa£_¡©e
 ==ğ
s_»ady
 && !
»Ëa£_ack_wa™


775 
m‘aArb
.
io
.
	`š
(5).
v®id
 :ğ
æushšg


776 
m‘aArb
.
io
.
	`š
(5).
b™s
.
wr™e
 :ğ
çl£


777 
m‘aArb
.
io
.
	`š
(5).
b™s
.
idx
 :ğ
	`æushCouÁ”
(
idxB™s
-1, 0)

778 
m‘aArb
.
io
.
	`š
(5).
b™s
.
addr
 :ğ
	`C©
(io.
ıu
.
»q
.b™s.add¸>> 
uÁagB™s
, m‘aArb.io.š(5).b™s.
idx
 << 
blockOffB™s
)

779 
m‘aArb
.
io
.
	`š
(5).
b™s
.
way_’
 := metaArb.io.in(4).bits.way_en

780 
m‘aArb
.
io
.
	`š
(5).
b™s
.
d©a
 := metaArb.io.in(4).bits.data

783 
v®
 
suµÜts_æush
 = !
edge
.
mªag”
.
mªag”s
.
	`fÜ®l
(
m
 => !m.
suµÜtsAcquœeT
 || !m.
execubË
 || m.
»giÚTy³
 >ğ
RegiÚTy³
.
TRACKED
 || m.»giÚTy³ <ğRegiÚTy³.
UNCACHEABLE
)

784 ià(
suµÜts_æush
) {

785 
	`wh’
 (
_out_a
.
	`fœe
(è&& !
s2_unÿched
è{ 
æushed
 :ğ
çl£
 }

786 
	`wh’
 (
æushšg
) {

787 
s1_viùim_way
 :ğ
æushCouÁ”
 >> 
	`log2Up
(
nS‘s
)

788 
	`wh’
 (
s2_æush_v®id
) {

789 
æushCouÁ”
 :ğ
æushCouÁ”Next


790 
	`wh’
 (
æushDÚe
) {

791 
æushed
 :ğ
Œue


792 ià(!
	`isPow2
(
nWays
)è
æushCouÁ”
 :ğ
æushCouÁ”W¿p


795 
	`wh’
 (
æushed
 && 
»Ëa£_¡©e
 ==ğ
s_»ady
 && !
»Ëa£_ack_wa™
) {

796 
æushšg
 :ğ
çl£


800 
m‘aArb
.
io
.
	`š
(0).
v®id
 :ğ
»£‰šg


801 
m‘aArb
.
io
.
	`š
(0).
b™s
 := metaArb.io.in(5).bits

802 
m‘aArb
.
io
.
	`š
(0).
b™s
.
wr™e
 :ğ
Œue


803 
m‘aArb
.
io
.
	`š
(0).
b™s
.
way_’
 :ğ~
	`UIÁ
(0, 
nWays
)

804 
m‘aArb
.
io
.
	`š
(0).
b™s
.
d©a
 :ğ
tECC
.
	`’code
(
	`L1M‘ad©a
(
s2_»q
.
addr
 >> 
gLSB
, 
Cl›ÁM‘ad©a
.
ÚRe£t
).
asUIÁ
)

805 
	`wh’
 (
»£‰šg
) {

806 
æushCouÁ”
 :ğ
æushCouÁ”Next


807 
	`wh’
 (
æushDÚe
) {

808 
»£‰šg
 :ğ
çl£


809 ià(!
	`isPow2
(
nWays
)è
æushCouÁ”
 :ğ
æushCouÁ”W¿p


814 
şock_’_»g
 :ğ
io
.
±w
.
cu¡omCSRs
.
di§bËDCacheClockG©e
 ||

815 
io
.
ıu
.
k“p_şock_’abËd
 ||

816 
m‘aArb
.
io
.
out
.
v®id
 ||

817 
s1_´obe
 || 
s2_´obe
 ||

818 
s1_v®id
 || 
s2_v®id_´e_xıt
 ||

819 
p¡Üe1_h–d
 || 
p¡Üe2_v®id
 ||

820 
»Ëa£_¡©e
 =/ğ
s_»ady
 ||

821 
»Ëa£_ack_wa™
 || !
»Ëa£_queue_em±y
 ||

822 !
b
.
io
.
»q
.
»ady
 ||

823 
ÿched_g¿Á_wa™
 || 
unÿchedInFlight
.
asUIÁ
.
ÜR
 ||

824 
ÌscCouÁ
 > 0 || 
blockProbeAá”G¿ÁCouÁ
 > 0

827 
io
.
ıu
.
³rf
.
acquœe
 :ğ
edge
.
	`dÚe
(
_out_a
)

828 
io
.
ıu
.
³rf
.
»Ëa£
 :ğ
edge
.
	`dÚe
(
_out_c
)

829 
io
.
ıu
.
³rf
.
g¿Á
 :ğ
d_dÚe


830 
io
.
ıu
.
³rf
.
bMiss
 :ğio.
±w
.
»q
.
	`fœe
()

831 
io
.
ıu
.
³rf
.
blocked
 := {

833 
v®
 
cyşes
 = 
ou‹r
.
bufãrUnÿchedReque¡s
.
	`m­
(
n
 => iàÒ > 1è1 2).
	`g‘OrEl£
(2)

834 
ÿched_g¿Á_wa™
 && 
d_add»ss_šc
 < ((
ÿcheBlockBy‹s
 - 
cyşes
 * 
b—tBy‹s
è
max
 0)

838 
	`v®
 (
d©a_”rÜ
, 
d©a_”rÜ_uncÜ»ùabË
, 
d©a_”rÜ_addr
) =

839 ià(
usšgD©aSü©ch·d
è(
s2_v®id_d©a_”rÜ
, 
s2_d©a_”rÜ_uncÜ»ùabË
, 
s2_»q
.
addr
) {

840 (
	`RegNext
(
_out_c
.
	`fœe
(è&& 
šWr™eback
 && 
wr™eback_d©a_”rÜ
),

841 
	`RegNext
(
wr™eback_d©a_uncÜ»ùabË
),

842 
´obe_b™s
.
add»ss
)

845 
v®
 
”rÜ_addr
 =

846 
	`Mux
(
m‘aArb
.
io
.
	`š
(1).
v®id
, 
	`C©
(
s2_fœ¡_m‘a_cÜ»ùed
.
g
, m‘aArb.io.š(1).
b™s
.
	`addr
(
gLSB
-1, 
idxLSB
)),

847 
d©a_”rÜ_addr
 >> 
idxLSB
) << idxLSB

848 
io
.
”rÜs
.
uncÜ»ùabË
.
fÜ—ch
 { 
u
 =>

849 
u
.
v®id
 :ğ
m‘aArb
.
io
.
	`š
(1).v®id && 
s2_m‘a_”rÜ_uncÜ»ùabË
 || 
d©a_”rÜ
 && 
d©a_”rÜ_uncÜ»ùabË


850 
u
.
b™s
 :ğ
”rÜ_addr


852 
io
.
”rÜs
.
cÜ»ùabË
.
fÜ—ch
 { 
c
 =>

853 
c
.
v®id
 :ğ
m‘aArb
.
io
.
	`š
(1).v®id || 
d©a_”rÜ


854 
c
.
b™s
 :ğ
”rÜ_addr


855 
io
.
”rÜs
.
uncÜ»ùabË
.
fÜ—ch
 { 
u
 => 
	`wh’
 (u.
v®id
è{ 
c
.v®id :ğ
çl£
 } }

857 
io
.
”rÜs
.
bus
.
v®id
 :ğ
_out
.
d
.
	`fœe
(è&& (_out.d.
b™s
.
d’›d
 ||l_out.d.b™s.
cÜru±
)

858 
io
.
”rÜs
.
bus
.
b™s
 :ğ
	`Mux
(
g¿ÁIsCached
, 
s2_»q
.
addr
 >> 
idxLSB
 << idxLSB, 0.U)

860 
	`ccov”NÙSü©ch·d
(
io
.
”rÜs
.
bus
.
v®id
 && 
g¿ÁIsCached
, "D_ERROR_CACHED", "D$ D-channelƒrror, cached")

861 
	`ccov”
(
io
.
”rÜs
.
bus
.
v®id
 && !
g¿ÁIsCached
, "D_ERROR_UNCACHED", "D$ D-channelƒrror, uncached")

864 ià(
usšgD©aSü©ch·d
) {

865 
v®
 
d©a_”rÜ_cov”
 = 
	`Seq
(

866 
	`Cov”BoŞ—n
(!
d©a_”rÜ
, 
	`Seq
("no_data_error")),

867 
	`Cov”BoŞ—n
(
d©a_”rÜ
 && !
d©a_”rÜ_uncÜ»ùabË
, 
	`Seq
("data_correctable_error")),

868 
	`Cov”BoŞ—n
(
d©a_”rÜ
 && 
d©a_”rÜ_uncÜ»ùabË
, 
	`Seq
("data_uncorrectable_error")))

869 
v®
 
»que¡_sourû
 = 
	`Seq
(

870 
	`Cov”BoŞ—n
(
s2_isSÏvePÜtAcûss
, 
	`Seq
("from_TL")),

871 
	`Cov”BoŞ—n
(!
s2_isSÏvePÜtAcûss
, 
	`Seq
("from_CPU")))

873 
	`cov”
(
Ãw
 
	`CrossPrİ”ty
(

874 
	`Seq
(
d©a_”rÜ_cov”
, 
»que¡_sourû
),

875 
	`Seq
(),

879 
v®
 
d©a_”rÜ_ty³
 = 
	`Seq
(

880 
	`Cov”BoŞ—n
(!
s2_v®id_d©a_”rÜ
, 
	`Seq
("no_data_error")),

881 
	`Cov”BoŞ—n
(
s2_v®id_d©a_”rÜ
 && !
s2_d©a_”rÜ_uncÜ»ùabË
, 
	`Seq
("data_correctable_error")),

882 
	`Cov”BoŞ—n
(
s2_v®id_d©a_”rÜ
 && 
s2_d©a_”rÜ_uncÜ»ùabË
, 
	`Seq
("data_uncorrectable_error")))

883 
v®
 
d©a_”rÜ_dœty
 = 
	`Seq
(

884 
	`Cov”BoŞ—n
(!
s2_viùim_dœty
, 
	`Seq
("data_clean")),

885 
	`Cov”BoŞ—n
(
s2_viùim_dœty
, 
	`Seq
("data_dirty")))

886 
v®
 
»que¡_sourû
 = ià(
suµÜts_æush
) {

887 
	`Seq
(

888 
	`Cov”BoŞ—n
(!
æushšg
, 
	`Seq
("access")),

889 
	`Cov”BoŞ—n
(
æushšg
, 
	`Seq
("during_flush")))

891 
	`Seq
(
	`Cov”BoŞ—n
(
Œue
.
B
, Seq("never_flush")))

893 
v®
 
g_”rÜ_cov”
 = 
	`Seq
(

894 
	`Cov”BoŞ—n
Ğ!
m‘aArb
.
io
.
	`š
(1).
v®id
, 
	`Seq
("no_tag_error")),

895 
	`Cov”BoŞ—n
Ğ
m‘aArb
.
io
.
	`š
(1).
v®id
 && !
s2_m‘a_”rÜ_uncÜ»ùabË
, 
	`Seq
("tag_correctable_error")),

896 
	`Cov”BoŞ—n
Ğ
m‘aArb
.
io
.
	`š
(1).
v®id
 && 
s2_m‘a_”rÜ_uncÜ»ùabË
, 
	`Seq
("tag_uncorrectable_error")))

897 
	`cov”
(
Ãw
 
	`CrossPrİ”ty
(

898 
	`Seq
(
d©a_”rÜ_ty³
, 
d©a_”rÜ_dœty
, 
»que¡_sourû
, 
g_”rÜ_cov”
),

899 
	`Seq
(),

905 
def
 
	`’codeD©a
(
x
: 
UIÁ
, 
poisÚ
: 
BoŞ
èğx.
	`grou³d
(
eccB™s
).
	`m­
(
dECC
.
	`’code
(
_
, ià(dECC.
ÿnD‘eù
èpoisÚ 
çl£
.
B
)).
asUIÁ


906 
def
 
	`dummyEncodeD©a
(
x
: 
UIÁ
èğx.
	`grou³d
(
eccB™s
).
	`m­
(
dECC
.
	`swizzË
(
_
)).
asUIÁ


907 
def
 
	`decodeD©a
(
x
: 
UIÁ
èğx.
	`grou³d
(
dECC
.
	`width
(
eccB™s
)).
	`m­
(dECC.
	$decode
(
_
))

908 
def
 
	`eccMask
(
by‹Mask
: 
UIÁ
èğby‹Mask.
	`grou³d
(
eccBy‹s
).
	`m­
(
_
.
ÜR
).
asUIÁ


909 
def
 
	`eccBy‹Mask
(
by‹Mask
: 
UIÁ
èğ
	`FlIÁ”Ëaved
(
eccBy‹s
, 
	$eccMask
(
by‹Mask
))

911 
def
 
	`lik–yN“dsR—d
(
»q
: 
H–ÏCacheReq
) = {

912 
v®
 
»s
 = !
»q
.
cmd
.
	`isOÃOf
(
M_XWR
, 
M_PFW
è|| 
	`mtSize
Ôeq.
typ
è< 
	`log2Ce
(
eccBy‹s
)

913 
	`as£¹
(!
	`ÃedsR—d
(
»q
è|| 
»s
)

914 
»s


915 
	}
}

916 
def
 
ÃedsR—d
(
»q
: 
H–ÏCacheReq
) =

917 
isR—d
(
»q
.
cmd
) ||

918 (
isWr™e
(
»q
.
cmd
è&& (»q.cmd ==ğ
M_PWR
 || 
mtSize
Ôeq.
typ
è< 
	$log2Ce
(
eccBy‹s
)))

920 
def
 
	$ccov”
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

921 
	`cov”
(
cÚd
, 
s
"DCACHE_$Ïb–", "MemÜySy¡em;;" + 
desc
)

922 
def
 
	$ccov”NÙSü©ch·d
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

923 ià(!
usšgD©aSü©ch·d
è
	$ccov”
(
cÚd
, 
Ïb–
, 
desc
)

925 
	`»quœe
(!
usšgVM
 || 
gLSB
 <ğ
pgIdxB™s
)

926 
def
 
gLSB
: 
IÁ
 = 
uÁagB™s


927 
def
 
	$´obeIdx
(
b
: 
TLBundËB
): 
UIÁ
 = b.
	$add»ss
(
idxMSB
, 
idxLSB
)

928 
def
 
	$add»ssToProbe
(
vaddr
: 
UIÁ
, 
·ddr
: UIÁ): 
TLBundËB
 = {

929 
v®
 
»s
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
edge
.
bundË
))

930 
»s
.
add»ss
 :ğ
·ddr


931 
»s
.
sourû
 :ğ
mmioOff£t
 - 1

932 
»s


933 
	}
}

934 
def
 
	$acquœe
(
vaddr
: 
UIÁ
, 
·ddr
: UIÁ, 
·¿m
: UIÁ): 
TLBundËA
 = {

935 ià(!
edge
.
mªag”
.
ªySuµÜtAcquœeT
è
	`Wœe
(
Ãw
 
	`TLBundËA
Ódge.
bundË
))

936 
edge
.
	`AcquœeBlock
(
	`UIÁ
(0), 
·ddr
 >> 
lgCacheBlockBy‹s
 <<†gCacheBlockBy‹s,†gCacheBlockBy‹s, 
·¿m
).
_2


937 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Decode.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.{
	gA¼ayBufãr
, 
	gM­
}

8 
objeù
 
	gDecodeLogic


10 
def
 
‹rm
(
l™
: 
B™P©
) =

11 
Ãw
 
T”m
(
l™
.
v®ue
, 
BigIÁ
(2).
pow
Ö™.
g‘Width
)-Ö™.
mask
+1))

12 
def
 
logic
(
addr
: 
UIÁ
, 
addrWidth
: 
IÁ
, 
ÿche
: 
M­
[
T”m
,
BoŞ
], 
‹rms
: 
Seq
[Term]) = {

13 
‹rms
.
m­
 { 
t
 =>

14 
ÿche
.
g‘OrEl£Upd©e
(
t
, (iàÑ.
mask
 =ğ0è
addr
 add¸& 
B™s
(
BigIÁ
(2).
pow
(
addrWidth
)-Ñ.mask+1),‡ddrWidth)è==ğB™sÑ.
v®ue
,‡ddrWidth))

15 }.
fŞdLeá
(
BoŞ
(
çl£
))(
	g_
||_)

17 
def
 
­¶y
(
addr
: 
UIÁ
, : 
B™P©
, 
m­pšg
: 
I‹¿bË
[(BitPat, BitPat)]): UInt = {

18 
v®
 
ÿche
 = 
ÿches
.
g‘OrEl£Upd©e
(
addr
, 
M­
[
T”m
,
BoŞ
]())

19 
v®
 
	gd‹rm
 = 
‹rm
()

20 
v®
 (
keys
, 
v®ues
èğ
m­pšg
.
unz


21 
v®
 
addrWidth
 = 
keys
.
m­
(
_
.
g‘Width
).
max


22 
v®
 
‹rms
 = 
keys
.
toLi¡
.
m­
(
k
 => 
‹rm
(k))

23 
v®
 
‹rmv®ues
 = 
‹rms
 
z
 
v®ues
.
toLi¡
.
m­
(
‹rm
(
_
))

25 
t
 <- 
keys
.
z
(
‹rms
).
s
; !
	gt
.
	gisEm±y
)

26 
	gu
 <- 
	gt
.
	g
)

27 
as£¹
(!
t
.
h—d
.
_2
.
š‹r£ùs
(
u
._2), "DecodeLogic: keys " +.head + "‡nd " + u + " overlap")

29 
C©
((0 
uÁ
 .
g‘Width
.
max
(
v®ues
.
m­
(
_
.g‘Width).max)).m­({ (
i
: 
IÁ
) =>

30 
v®
 
mšt
 = 
‹rmv®ues
.
f‹r
 { (
k
,
t
è=> (Ñ.
mask
 >> 
i
è& 1è=ğ0 && (Ñ.
v®ue
 >> iè& 1è=ğ1 }.
m­
(
_
.
_1
)

31 
v®
 
maxt
 = 
‹rmv®ues
.
f‹r
 { (
k
,
t
è=> (Ñ.
mask
 >> 
i
è& 1è=ğ0 && (Ñ.
v®ue
 >> iè& 1è=ğ0 }.
m­
(
_
.
_1
)

32 
v®
 
dc
 = 
‹rmv®ues
.
f‹r
 { (
k
,
t
è=> (Ñ.
mask
 >> 
i
è& 1è=ğ1 }.
m­
(
_
.
_1
)

34 ià(((
d‹rm
.
mask
 >> 
i
) & 1) != 0) {

35 
logic
(
addr
, 
addrWidth
, 
ÿche
, 
Sim¶ifyDC
(
mšt
, 
maxt
,‡ddrWidth))

37 
v®
 
defb™
 = (
d‹rm
.
v®ue
.
toIÁ
 >> 
i
) & 1

38 
v®
 
t
 = ià(
defb™
 =ğ0è
mšt
 
maxt


39 
v®
 
b™
 = 
logic
(
addr
, 
addrWidth
, 
ÿche
, 
Sim¶ify
(
t
, 
dc
,‡ddrWidth))

40 ià(
defb™
 =ğ0è
b™
 ~bit

42 }).
»v”£
)

44 
def
 
­¶y
(
addr
: 
UIÁ
, : 
Seq
[
B™P©
], 
m­pšgIn
: 
I‹¿bË
[(BitPat, Seq[BitPat])]): Seq[UInt] = {

45 
v®
 
m­pšg
 = 
A¼ayBufãr
.
fl
(.
size
)(A¼ayBufãr[(
B™P©
, BitPat)]())

46 (
	gkey
, 
	gv®ues
è<- 
	gm­pšgIn
)

47 (
	gv®ue
, 
	gi
è<- 
v®ues
 
	gzW™hIndex
)

48 
m­pšg
(
i
è+ğ
key
 -> 
v®ue


49 (
thisDeçuÉ
, 
	gthisM­pšg
è<-  
z
 
	gm­pšg
)

50 
y›ld
 
­¶y
(
addr
, 
thisDeçuÉ
, 
thisM­pšg
)

52 
def
 
­¶y
(
addr
: 
UIÁ
, : 
Seq
[
B™P©
], 
m­pšgIn
: 
Li¡
[(UInt, Seq[BitPat])]): Seq[UInt] =

53 
­¶y
(
addr
, , 
m­pšgIn
.
m­
(
m
 => (
B™P©
(m.
_1
), m.
_2
)).
asIn¡ªûOf
[
I‹¿bË
[(B™P©, 
Seq
[BitPat])]])

54 
def
 
­¶y
(
addr
: 
UIÁ
, 
Œues
: 
I‹¿bË
[UIÁ], 
çl£s
: I‹¿bË[UIÁ]): 
BoŞ
 =

55 
­¶y
(
addr
, 
B™P©
.
dÚtC¬e
(1), 
Œues
.
m­
(B™P©(
_
è-> B™P©("b1")è++ 
çl£s
.m­(B™P©(_è-> B™P©("b0"))).
toBoŞ


56 
´iv©e
 
v®
 
	gÿches
 = 
M­
[
UIÁ
,M­[
T”m
,
BoŞ
]]()

59 
şass
 
	$T”m
(
v®
 
v®ue
: 
BigIÁ
, v® 
mask
: BigInt = 0)

61 
v¬
 
´ime
 = 
Œue


63 
def
 
	`cov”s
(
x
: 
T”m
èğ((
v®ue
 ^ x.v®ueè&~ 
mask
 | x.mask &~ mask) == 0

64 
def
 
	`š‹r£ùs
(
x
: 
T”m
èğ((
v®ue
 ^ x.v®ueè&~ 
mask
 &~ x.mask) == 0

65 
ov”ride
 
def
 
	`equ®s
(
th©
: 
Any
èğth© 
m©ch
 {

66 
x
: 
T”m
 => x.
v®ue
 =ğv®u&& x.
mask
 == mask

67 
_
 => 
çl£


69 
ov”ride
 
def
 
hashCode
 = 
v®ue
.
toIÁ


70 
def
 < (
th©
: 
T”m
èğ
v®ue
 <h©.v®u|| v®u=ğth©.v®u&& 
mask
 <hat.mask

71 
def
 
	`sim¬
(
x
: 
T”m
) = {

72 
v®
 
diff
 = 
v®ue
 - 
x
.value

73 
mask
 =ğ
x
.mask && 
v®ue
 > x.v®u&& (
diff
 & diff-1) == 0

75 
def
 
	`m”ge
(
x
: 
T”m
) = {

76 
´ime
 = 
çl£


77 
x
.
´ime
 = 
çl£


78 
v®
 
b™
 = 
v®ue
 - 
x
.value

79 
Ãw
 
	`T”m
(
v®ue
 &~ 
b™
, 
mask
 | bit)

82 
ov”ride
 
def
 
toSŒšg
 = 
v®ue
.
	`toSŒšg
(16è+ "-" + 
mask
.toSŒšg(16è+ (ià(
´ime
) "p" "")

83 
	}
}

85 
objeù
 
	gSim¶ify


87 
def
 
g‘PrimeIm¶iÿÁs
(
im¶iÿÁs
: 
Seq
[
T”m
], 
b™s
: 
IÁ
) = {

88 
v¬
 
´ime
 = 
Li¡
[
T”m
]()

89 
im¶iÿÁs
.
fÜ—ch
(
_
.
´ime
 = 
Œue
)

90 
v®
 
cŞs
 = (0 
to
 
b™s
).
m­
(
b
 => 
im¶iÿÁs
.
f‹r
(b =ğ
_
.
mask
.
b™CouÁ
))

91 
v®
 
bË
 = 
cŞs
.
m­
(
c
 => (0 
to
 
b™s
).m­(
b
 => 
cŞËùiÚ
.
mubË
.
S‘
(c.
f‹r
(b =ğ
_
.
v®ue
.
b™CouÁ
):_*)))

92 
i
 <- 0 
to
 
b™s
) {

93 
j
 <- 0 
uÁ
 
b™s
-
i
)

94 
bË
(
i
)(
j
).
fÜ—ch
(
a
 =>abË(i+1)(jè++ğbË(i)(j+1).
f‹r
(
_
.
sim¬
×)).
m­
(_.
m”ge
(a)))

95 
r
 <- 
bË
(
i
))

96 
p
 <- 
r
; 
	gp
.
	g´ime
)

97 
	g´ime
 = 
p
 :: 
´ime


99 
´ime
.
sÜtW™h
(
_
<_)

101 
def
 
g‘Es£ÁŸlPrimeIm¶iÿÁs
(
´ime
: 
Seq
[
T”m
], 
mš‹rms
: Seq[T”m]): (Seq[T”m],
	gSeq
[Term],Seq[Term]) = {

102 
v®
 
´imeCov”s
 = 
´ime
.
m­
(
p
 => 
mš‹rms
.
f‹r
Õ 
cov”s
 
_
))

103 ((
icov”
, 
	gpi
), 
	gi
è<- (
´imeCov”s
 
z
 
	g´ime
).
	gzW™hIndex
) {

104 ((
	gjcov”
, 
	gpj
), 
	gj
è<- (
´imeCov”s
 
z
 
	g´ime
).
	gzW™hIndex
.
drİ
(
i
+1)) {

105 ià(
	gicov”
.
	gsize
 > 
	gjcov”
.siz&& jcov”.
fÜ®l
(
pi
 
cov”s
 
_
))

106  
g‘Es£ÁŸlPrimeIm¶iÿÁs
(
´ime
.
f‹r
(
_
 !ğ
pj
), 
mš‹rms
)

110 
v®
 
	ges£ÁŸÎyCov”ed
 = 
mš‹rms
.
f‹r
(
t
 => 
´ime
.
couÁ
(
_
 
cov”s
) == 1)

111 
v®
 
es£ÁŸl
 = 
´ime
.
f‹r
(
p
 => 
es£ÁŸÎyCov”ed
.
exi¡s
Õ 
cov”s
 
_
))

112 
v®
 
nÚes£ÁŸl
 = 
´ime
.
f‹rNÙ
(
es£ÁŸl
 
cÚšs
 
_
)

113 
v®
 
uncov”ed
 = 
mš‹rms
.
f‹rNÙ
(
t
 => 
es£ÁŸl
.
exi¡s
(
_
 
cov”s
))

114 ià(
es£ÁŸl
.
isEm±y
 || 
uncov”ed
.isEmpty)

115 (
es£ÁŸl
, 
	gnÚes£ÁŸl
, 
	guncov”ed
)

117 
v®
 (
a
, 
b
, 
c
èğ
g‘Es£ÁŸlPrimeIm¶iÿÁs
(
nÚes£ÁŸl
, 
uncov”ed
)

118 (
	ges£ÁŸl
 ++ 
	ga
, 
	gb
, 
	gc
)

121 
def
 
g‘Co¡
(
cov”
: 
Seq
[
T”m
], 
b™s
: 
IÁ
èğcov”.
m­
(b™ - 
_
.
mask
.
b™CouÁ
).
sum


122 
def
 
ch—³r
(
a
: 
Li¡
[
T”m
], 
b
: Li¡[T”m], 
b™s
: 
IÁ
) = {

123 
v®
 
ÿ
 = 
g‘Co¡
(
a
, 
b™s
)

124 
v®
 
	gcb
 = 
g‘Co¡
(
b
, 
b™s
)

125 
def
 
li¡Less
(
a
: 
Li¡
[
T”m
], 
b
: Li¡[T”m]): 
BoŞ—n
 = !b.
isEm±y
 && (a.isEm±y ||‡.
h—d
 < b.h—d ||‡.h—d =ğb.h—d &&†i¡Less×.

, b.tail))

126 
	gÿ
 < 
	gcb
 || c¨=ğ
cb
 && 
li¡Less
(
a
.
sÜtW™h
(
_
<_), 
b
.sortWith(_<_))

128 
def
 
g‘Cov”
(
im¶iÿÁs
: 
Seq
[
T”m
], 
mš‹rms
: Seq[T”m], 
b™s
: 
IÁ
) = {

129 ià(
mš‹rms
.
nÚEm±y
) {

130 
v®
 
cov”
 = 
mš‹rms
.
m­
(
m
 => 
im¶iÿÁs
.
f‹r
(
_
.
cov”s
(m)))

131 
v®
 
®l
 = 
cov”
.

.
fŞdLeá
(cov”.
h—d
.
m­
(
S‘
(
_
)))((
c0
, 
	gc1
è=> c0.
æ©M­
(
a
 => 
c1
.map(a + _)))

132 
®l
.
m­
(
_
.
toLi¡
).
»duûLeá
((
a
, 
b
è=> ià(
ch—³r
×, b, 
b™s
))‡ b)

134 
	gSeq
[
T”m
]()

136 
def
 
¡ršgify
(
s
: 
Seq
[
T”m
], 
b™s
: 
IÁ
èğs.
m­
(
t
 => (0 
uÁ
 b™s).m­(
i
 => ià(Ñ.
mask
 & (1 << i)è!ğ0è"x" (Ñ.
v®ue
 >> iè& 1).
toSŒšg
).
»duûLeá
(
_
+_).
»v”£
).reduceLeft(_+" + "+_)

138 
def
 
­¶y
(
mš‹rms
: 
Seq
[
T”m
], 
dÚtÿ»s
: Seq[T”m], 
b™s
: 
IÁ
) = {

139 
v®
 
´ime
 = 
g‘PrimeIm¶iÿÁs
(
mš‹rms
 ++ 
dÚtÿ»s
, 
b™s
)

140 
	gmš‹rms
.
fÜ—ch
(
t
 => 
as£¹
(
´ime
.
exi¡s
(
_
.
cov”s
(t))))

141 
v®
 (
•rime
, 
´ime2
, 
uncov”ed
èğ
g‘Es£ÁŸlPrimeIm¶iÿÁs
(
´ime
, 
mš‹rms
)

142 
v®
 
	gcov”
 = 
•rime
 ++ 
g‘Cov”
(
´ime2
, 
uncov”ed
, 
b™s
)

143 
	gmš‹rms
.
fÜ—ch
(
t
 => 
as£¹
(
cov”
.
exi¡s
(
_
.
cov”s
(t))))

144 
cov”


148 
objeù
 
	gSim¶ifyDC


150 
def
 
g‘Im¶ic™DC
(
max‹rms
: 
Seq
[
T”m
], 
‹rm
: T”m, 
b™s
: 
IÁ
, 
above
: 
BoŞ—n
): Term = {

151 
i
 <- 0 
uÁ
 
b™s
) {

152 
v¬
 
t
: 
T”m
 = 
nuÎ


153 ià(
above
 && ((
‹rm
.
v®ue
 |”m.
mask
è& (
BigIÁ
(1è<< 
i
)) == 0)

154 
t
 = 
Ãw
 
T”m
(
‹rm
.
v®ue
 | (
BigIÁ
(1è<< 
i
),”m.
mask
)

155 ià(!
	gabove
 && (
	g‹rm
.
	gv®ue
 & (
BigIÁ
(1è<< 
	gi
)) != 0)

156 
t
 = 
Ãw
 
T”m
(
‹rm
.
v®ue
 & ~(
BigIÁ
(1è<< 
i
),”m.
mask
)

157 ià(
	gt
 !ğ
nuÎ
 && !
max‹rms
.
exi¡s
(
_
.
š‹r£ùs
(
t
)))

158  
t


160 
	gnuÎ


162 
def
 
g‘PrimeIm¶iÿÁs
(
mš‹rms
: 
Seq
[
T”m
], 
max‹rms
: Seq[T”m], 
b™s
: 
IÁ
) = {

163 
v¬
 
´ime
 = 
Li¡
[
T”m
]()

164 
mš‹rms
.
fÜ—ch
(
_
.
´ime
 = 
Œue
)

165 
v¬
 
mšt
 = 
mš‹rms
.
m­
(
t
 => 
Ãw
 
T”m
Ñ.
v®ue
,.
mask
))

166 
v®
 
	gcŞs
 = (0 
to
 
b™s
).
m­
(
b
 => 
mšt
.
f‹r
(b =ğ
_
.
mask
.
b™CouÁ
))

167 
v®
 
bË
 = 
cŞs
.
m­
(
c
 => (0 
to
 
b™s
).m­(
b
 => 
cŞËùiÚ
.
mubË
.
S‘
(c.
f‹r
(b =ğ
_
.
v®ue
.
b™CouÁ
):_*)))

169 
i
 <- 0 
to
 
b™s
) {

170 
j
 <- 0 
uÁ
 
b™s
-
i
) {

171 
bË
(
i
)(
j
).
fÜ—ch
(
a
 =>abË(i+1)(jè++ğbË(i)(j+1).
f‹r
(
_
 
sim¬
‡).
m­
(_ 
m”ge
‡))

173 
j
 <- 0 
uÁ
 
b™s
-
i
) {

174 
a
 <- 
bË
(
i
)(
j
).
f‹r
(
_
.
´ime
)) {

175 
v®
 
dc
 = 
g‘Im¶ic™DC
(
max‹rms
, 
a
, 
b™s
, 
Œue
)

176 ià(
	gdc
 !ğ
nuÎ
)

177 
bË
(
i
+1)(
j
è+ğ
dc
 
m”ge
 
a


179 
	ga
 <- 
bË
(
i
)(
	gj
+1).
f‹r
(
_
.
´ime
)) {

180 
v®
 
	gdc
 = 
g‘Im¶ic™DC
(
max‹rms
, 
a
, 
b™s
, 
çl£
)

181 ià(
	gdc
 !ğ
nuÎ
)

182 
bË
(
i
+1)(
j
è+ğ
a
 
m”ge
 
dc


185 
	gr
 <- 
bË
(
i
))

186 
	gp
 <- 
	gr
; p.
	g´ime
)

187 
	g´ime
 = 
p
 :: 
´ime


189 
´ime
.
sÜtW™h
(
_
<_)

192 
def
 
v”ify
(
cov”
: 
Seq
[
T”m
], 
mš‹rms
: Seq[T”m], 
max‹rms
: Seq[Term]) = {

193 
as£¹
(
mš‹rms
.
fÜ®l
(
t
 => 
cov”
.
exi¡s
(
_
 
cov”s
)))

194 
as£¹
(
max‹rms
.
fÜ®l
(
t
 => !
cov”
.
exi¡s
(
_
 
š‹r£ùs
)))

196 
def
 
­¶y
(
mš‹rms
: 
Seq
[
T”m
], 
max‹rms
: Seq[T”m], 
b™s
: 
IÁ
) = {

197 
v®
 
´ime
 = 
g‘PrimeIm¶iÿÁs
(
mš‹rms
, 
max‹rms
, 
b™s
)

198 
v®
 (
•rime
, 
´ime2
, 
uncov”ed
èğ
Sim¶ify
.
g‘Es£ÁŸlPrimeIm¶iÿÁs
(
´ime
, 
mš‹rms
)

199 
v®
 
	gcov”
 = 
•rime
 ++ 
Sim¶ify
.
g‘Cov”
(
´ime2
, 
uncov”ed
, 
b™s
)

200 
v”ify
(
cov”
, 
mš‹rms
, 
max‹rms
)

201 
	gcov”


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Events.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


10 
şass
 
Ev’tS‘
(
g©e
: (
UIÁ
, UIÁè=> 
BoŞ
, 
ev’ts
: 
Seq
[(
SŒšg
, () => Bool)]) {

11 
def
 
size
 = 
ev’ts
.size

12 
def
 
h™s
 = 
ev’ts
.
m­
(
_
.
_2
()).
asUIÁ


13 
def
 
check
(
mask
: 
UIÁ
èğ
g©e
(mask, 
h™s
)

14 
def
 
dump
() {

15 ((
	gÇme
, 
	g_
), 
	gi
è<- 
	gev’ts
.
	gzW™hIndex
)

16 
wh’
 (
check
(1.U << 
i
)è{ 
´štf
(
s
"Event $name\n") }

18 
def
 
	gw™hCov”s
 {

19 
	gev’ts
.
	gzW™hIndex
.
	gfÜ—ch
 {

20 ((
	gÇme
, 
	g_
), 
	gi
è=> 
cov”
(
check
(1.U << 
i
), 
Çme
)

25 
şass
 
	$Ev’tS‘s
(
v®
 
ev’tS‘s
: 
Seq
[
Ev’tS‘
]) {

26 
def
 
	`maskEv’tS–eùÜ
(
ev’tS–
: 
UIÁ
): UInt = {

28 
v®
 
£tMask
 = (
	`BigIÁ
(1è<< 
	`log2Ce
(
ev’tS‘s
.
size
)) - 1

29 
v®
 
maskMask
 = ((
	`BigIÁ
(1è<< 
ev’tS‘s
.
	`m­
(
_
.
size
).
max
è- 1è<< 
ev’tS‘IdB™s


30 
ev’tS–
 & (
£tMask
 | 
maskMask
).
U


33 
´iv©e
 
def
 
	`decode
(
couÁ”
: 
UIÁ
): (UInt, UInt) = {

34 
	`»quœe
(
ev’tS‘s
.
size
 <ğ(1 << 
ev’tS‘IdB™s
))

35 (
	`couÁ”
(
	`log2Ce
(
ev’tS‘s
.
size
)-1, 0), 
couÁ”
 >> 
ev’tS‘IdB™s
)

38 
def
 
	`ev®u©e
(
ev’tS–
: 
UIÁ
): 
BoŞ
 = {

39 
	`v®
 (
£t
, 
mask
èğ
	`decode
(
ev’tS–
)

40 
v®
 
£ts
 = 
ev’tS‘s
 
	`m­
 (
_
 
check
 
mask
)

41 
	`£ts
(
£t
)

44 
def
 
	`cov”
(èğ
ev’tS‘s
.
fÜ—ch
 { 
_
 
w™hCov”s
 }

46 
´iv©e
 
def
 
ev’tS‘IdB™s
 = 8

47 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Frontend.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


15 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


16 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


18 şas 
	cFrÚ‹ndReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

19 
v®
 
pc
 = 
	$UIÁ
(
width
 = 
vaddrB™sEx‹nded
)

20 
v®
 
¥ecuÏtive
 = 
	`BoŞ
()

23 şas 
	cFrÚ‹ndExû±iÚs
 
ex‹nds
 
BundË
 {

24 
v®
 
pf
 = 
Ãw
 
BundË
 {

25 
v®
 
š¡
 = 
	`BoŞ
()

27 
v®
 
«
 = 
Ãw
 
BundË
 {

28 
v®
 
š¡
 = 
	`BoŞ
()

29 
	}
}

32 şas 
	cFrÚ‹ndRe¥
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

33 
v®
 
btb
 = 
Ãw
 
BTBRe¥


34 
v®
 
pc
 = 
	$UIÁ
(
width
 = 
vaddrB™sEx‹nded
)

35 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
ãtchWidth
 * 
cÜeIn¡B™s
)

36 
v®
 
mask
 = 
	$B™s
(
width
 = 
ãtchWidth
)

37 
v®
 
xıt
 = 
Ãw
 
FrÚ‹ndExû±iÚs


38 
v®
 
»¶ay
 = 
	`BoŞ
()

41 şas 
	cFrÚ‹ndP”fEv’ts
 
ex‹nds
 
BundË
 {

42 
v®
 
acquœe
 = 
	$BoŞ
()

43 
v®
 
bMiss
 = 
	`BoŞ
()

46 şas 
	cFrÚ‹ndIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

47 
v®
 
might_»que¡
 = 
	$BoŞ
(
OUTPUT
)

48 
v®
 
»q
 = 
	$V®id
(
Ãw
 
FrÚ‹ndReq
)

49 
v®
 
sãnû
 = 
	$V®id
(
Ãw
 
SF’ûReq
)

50 
v®
 
»¥
 = 
	`Decou¶ed
(
Ãw
 
FrÚ‹ndRe¥
).
æ


51 
v®
 
btb_upd©e
 = 
	$V®id
(
Ãw
 
BTBUpd©e
)

52 
v®
 
bht_upd©e
 = 
	$V®id
(
Ãw
 
BHTUpd©e
)

53 
v®
 
¿s_upd©e
 = 
	$V®id
(
Ãw
 
RASUpd©e
)

54 
v®
 
æush_iÿche
 = 
	$BoŞ
(
OUTPUT
)

55 
v®
 
Åc
 = 
	$UIÁ
(
INPUT
, 
width
 = 
vaddrB™sEx‹nded
)

56 
v®
 
³rf
 = 
Ãw
 
	`FrÚ‹ndP”fEv’ts
().
asIÅut


59 
şass
 
	$FrÚ‹nd
(
v®
 
iÿcheP¬ams
: 
ICacheP¬ams
, 
h¬tid
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

60 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`FrÚ‹ndModuË
(
this
)

61 
v®
 
iÿche
 = 
	`LazyModuË
(
Ãw
 
	`ICache
(
iÿcheP¬ams
, 
h¬tid
))

62 
v®
 
ma¡”Node
 = 
iÿche
.masterNode

63 
v®
 
¦aveNode
 = 
iÿche
.slaveNode

64 
	}
}

66 
şass
 
	$FrÚ‹ndBundË
(
v®
 
ou‹r
: 
FrÚ‹nd
è
ex‹nds
 
	$CÜeBundË
()(
ou‹r
.
p
)

67 
w™h
 
HasEx‹º®lyDriv’TeCÚ¡ªts
 {

68 
v®
 
ıu
 = 
Ãw
 
	`FrÚ‹ndIO
().
æ


69 
v®
 
±w
 = 
Ãw
 
	`TLBPTWIO
()

70 
v®
 
”rÜs
 = 
Ãw
 
ICacheE¼Üs


71 
	}
}

73 @
chi£lName


74 şas 
	cFrÚ‹ndModuË
(
ou‹r
: 
FrÚ‹nd
è
ex‹nds
 
	$LazyModuËImp
(
ou‹r
)

75 
w™h
 
HasRock‘CÜeP¬am‘”s


76 
w™h
 
HasL1ICacheP¬am‘”s
 {

77 
v®
 
io
 = 
	`IO
(
Ãw
 
	$FrÚ‹ndBundË
(
ou‹r
))

78 
im¶ic™
 
v®
 
edge
 = 
ou‹r
.
ma¡”Node
.
edges
.
	$out
(0)

79 
v®
 
iÿche
 = 
ou‹r
.iÿche.
moduË


80 
	$»quœe
(
ãtchWidth
*
cÜeIn¡By‹s
 =ğ
ou‹r
.
iÿcheP¬ams
.
ãtchBy‹s
)

82 
v®
 
fq
 = 
	`w™hRe£t
(
»£t
 || 
io
.
ıu
.
»q
.
v®id
è{ 
	`ModuË
(
Ãw
 
	`ShiáQueue
Òew 
FrÚ‹ndRe¥
, 5, 
æow
 = 
Œue
)) }

84 
v®
 
şock_’_»g
 = 
	`Reg
(
	$BoŞ
())

85 
v®
 
şock_’
 = 
şock_’_»g
 || 
io
.
ıu
.
might_»que¡


86 
	`as£¹
(!(
io
.
ıu
.
»q
.
v®id
 || io.ıu.
sãnû
.v®id || io.ıu.
æush_iÿche
 || io.ıu.
bht_upd©e
.v®id || io.ıu.
btb_upd©e
.v®idè|| io.ıu.
might_»que¡
)

87 
v®
 
g©ed_şock
 =

88 ià(!
rock‘P¬ams
.
şockG©e
è
şock


89 
	`ClockG©e
(
şock
, 
şock_’
, "icache_clock_gate")

91 
iÿche
.
şock
 :ğ
g©ed_şock


92 
iÿche
.
io
.
şock_’abËd
 :ğ
şock_’


93 
	$w™hClock
 (
g©ed_şock
) {

95 
v®
 
b
 = 
	`ModuË
(
Ãw
 
	`TLB
(
Œue
, 
	`log2Ce
(
ãtchBy‹s
), 
	`TLBCÚfig
(
nTLBEÁr›s
)))

97 
v®
 
s0_v®id
 = 
io
.
ıu
.
»q
.
v®id
 || !
fq
.io.
	`mask
(fq.io.
mask
.
g‘Width
-3)

98 
v®
 
s1_v®id
 = 
	`RegNext
(
s0_v®id
)

99 
v®
 
s1_pc
 = 
	`Reg
(
	`UIÁ
(
width
=
vaddrB™sEx‹nded
))

100 
v®
 
s1_¥ecuÏtive
 = 
	`Reg
(
	`BoŞ
())

101 
v®
 
s2_v®id
 = 
	`RegIn™
(
çl£
.
B
)

102 
v®
 
s2_pc
 = 
	`RegIn™
(
t
 = 
	`UIÁ
(
width
 = 
vaddrB™sEx‹nded
), 
	`®ignPC
(
io
.
»£t_veùÜ
))

103 
v®
 
s2_btb_»¥_v®id
 = ià(
usšgBTB
è
	`Reg
(
	`BoŞ
()è
çl£
.
B


104 
v®
 
s2_btb_»¥_b™s
 = 
	`Reg
(
Ãw
 
BTBRe¥
)

105 
v®
 
s2_btb_k’
 = 
s2_btb_»¥_v®id
 && 
s2_btb_»¥_b™s
.
k’


106 
v®
 
s2_b_»¥
 = 
	`Reg
(
b
.
io
.
»¥
)

107 
v®
 
s2_xıt
 = 
s2_b_»¥
.
«
.
š¡
 || s2_b_»¥.
pf
.inst

108 
v®
 
s2_¥ecuÏtive
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

109 
v®
 
s2_·¹Ÿl_š¢_v®id
 = 
	`RegIn™
(
çl£
.
B
)

110 
v®
 
s2_·¹Ÿl_š¢
 = 
	`Reg
(
	`UIÁ
(
width
 = 
cÜeIn¡B™s
))

111 
v®
 
wrÚg_·th
 = 
	`Reg
(
	`BoŞ
())

113 
v®
 
s1_ba£_pc
 = ~(~
s1_pc
 | (
ãtchBy‹s
 - 1))

114 
v®
 
Ápc
 = 
s1_ba£_pc
 + 
ãtchBy‹s
.
U


115 
v®
 
´ediùed_Åc
 = 
	`Wœe
(
š™
 = 
Ápc
)

116 
v®
 
´ediùed_k’
 = 
	`Wœe
(
š™
 = 
	`BoŞ
(
çl£
))

118 
v®
 
s2_»¶ay
 = 
	`Wœe
(
	`BoŞ
())

119 
s2_»¶ay
 :ğ(
s2_v®id
 && !
fq
.
io
.
’q
.
	`fœe
()è|| 
	`RegNext
(s2_»¶ay && !
s0_v®id
, 
Œue
.
B
)

120 
v®
 
Åc
 = 
	`Mux
(
s2_»¶ay
, 
s2_pc
, 
´ediùed_Åc
)

122 
s1_pc
 :ğ
io
.
ıu
.
Åc


125 
v®
 
s0_¥ecuÏtive
 =

126 ià(
usšgCom´es£d
è
s1_¥ecuÏtive
 || 
s2_v®id
 && !
s2_¥ecuÏtive
 || 
´ediùed_k’


127 
	`BoŞ
(
Œue
)

128 
s1_¥ecuÏtive
 :ğ
	`Mux
(
io
.
ıu
.
»q
.
v®id
, io.ıu.»q.
b™s
.
¥ecuÏtive
, Mux(
s2_»¶ay
, 
s2_¥ecuÏtive
, 
s0_¥ecuÏtive
))

130 
v®
 
s2_»dœeù
 = 
	`Wœe
(
š™
 = 
io
.
ıu
.
»q
.
v®id
)

131 
s2_v®id
 :ğ
çl£


132 
	`wh’
 (!
s2_»¶ay
) {

133 
s2_v®id
 :ğ!
s2_»dœeù


134 
s2_pc
 :ğ
s1_pc


135 
s2_¥ecuÏtive
 :ğ
s1_¥ecuÏtive


136 
s2_b_»¥
 :ğ
b
.
io
.
»¥


139 
io
.
±w
 <> 
b
.io.ptw

140 
b
.
io
.
»q
.
v®id
 :ğ
s1_v®id
 && !
s2_»¶ay


141 
b
.
io
.
»q
.
b™s
.
vaddr
 :ğ
s1_pc


142 
b
.
io
.
»q
.
b™s
.
·s¡hrough
 :ğ
	`BoŞ
(
çl£
)

143 
b
.
io
.
»q
.
b™s
.
size
 :ğ
	`log2Ce
(
cÜeIn¡By‹s
*
ãtchWidth
)

144 
b
.
io
.
sãnû
 :ğio.
ıu
.sfence

145 
b
.
io
.
kl
 :ğ!
s2_v®id


147 
iÿche
.
io
.
h¬tid
 := io.hartid

148 
iÿche
.
io
.
»q
.
v®id
 :ğ
s0_v®id


149 
iÿche
.
io
.
»q
.
b™s
.
addr
 :ğio.
ıu
.
Åc


150 
iÿche
.
io
.
šv®id©e
 :ğio.
ıu
.
æush_iÿche


151 
iÿche
.
io
.
s1_·ddr
 :ğ
b
.io.
»¥
.
·ddr


152 
iÿche
.
io
.
s2_vaddr
 :ğ
s2_pc


153 
iÿche
.
io
.
s1_kl
 :ğ
s2_»dœeù
 || 
b
.io.
»¥
.
miss
 || 
s2_»¶ay


154 
iÿche
.
io
.
s2_kl
 :ğ
s2_¥ecuÏtive
 && !
s2_b_»¥
.
ÿch—bË
 || 
s2_xıt


155 
iÿche
.
io
.
s2_´eãtch
 :ğ
s2_b_»¥
.
´eãtchabË


157 
fq
.
io
.
’q
.
v®id
 :ğ
	`RegNext
(
s1_v®id
è&& 
s2_v®id
 && (
iÿche
.io.
»¥
.v®id || !
s2_b_»¥
.
miss
 && iÿche.io.
s2_kl
)

158 
fq
.
io
.
’q
.
b™s
.
pc
 :ğ
s2_pc


159 
io
.
ıu
.
Åc
 :ğ
	`®ignPC
(
	`Mux
(io.ıu.
»q
.
v®id
, io.ıu.»q.
b™s
.
pc
,‚pc))

161 
fq
.
io
.
’q
.
b™s
.
d©a
 :ğ
iÿche
.io.
»¥
.bits.data

162 
fq
.
io
.
’q
.
b™s
.
mask
 :ğ
	`UIÁ
((1 << 
ãtchWidth
)-1è<< 
s2_pc
.
	`exŒaù
(
	`log2Ce
(ãtchWidth)+log2Ce(
cÜeIn¡By‹s
)-1,†og2Ceil(coreInstBytes))

163 
fq
.
io
.
’q
.
b™s
.
»¶ay
 :ğ
iÿche
.io.
»¥
.b™s.»¶ay || iÿche.io.
s2_kl
 && !iÿche.io.»¥.
v®id
 && !
s2_xıt


164 
fq
.
io
.
’q
.
b™s
.
btb
 :ğ
s2_btb_»¥_b™s


165 
fq
.
io
.
’q
.
b™s
.
btb
.
k’
 :ğ
s2_btb_k’


166 
fq
.
io
.
’q
.
b™s
.
xıt
 :ğ
s2_b_»¥


167 
	`wh’
 (
iÿche
.
io
.
»¥
.
v®id
 && iÿche.io.»¥.
b™s
.
«
è{ 
fq
.io.
’q
.b™s.
xıt
.«.
š¡
 :ğ
Œue
 }

169 ià(
usšgBTB
) {

170 
v®
 
btb
 = 
	`ModuË
(
Ãw
 
BTB
)

171 
btb
.
io
.
æush
 :ğ
çl£


172 
btb
.
io
.
»q
.
v®id
 :ğ
çl£


173 
btb
.
io
.
»q
.
b™s
.
addr
 :ğ
s1_pc


174 
btb
.
io
.
btb_upd©e
 :ğio.
ıu
.btb_update

175 
btb
.
io
.
bht_upd©e
 :ğio.
ıu
.bht_update

176 
btb
.
io
.
¿s_upd©e
.
v®id
 :ğ
çl£


177 
btb
.
io
.
bht_advªû
.
v®id
 :ğ
çl£


178 
	`wh’
 (!
s2_»¶ay
) {

179 
btb
.
io
.
»q
.
v®id
 :ğ!
s2_»dœeù


180 
s2_btb_»¥_v®id
 :ğ
btb
.
io
.
»¥
.
v®id


181 
s2_btb_»¥_b™s
 :ğ
btb
.
io
.
»¥
.
b™s


183 
	`wh’
 (
btb
.
io
.
»¥
.
v®id
 && btb.io.»¥.
b™s
.
k’
) {

184 
´ediùed_Åc
 :ğ
btb
.
io
.
»¥
.
b™s
.
rg‘
.
	`£xtTo
(
vaddrB™sEx‹nded
)

185 
´ediùed_k’
 :ğ
	`BoŞ
(
Œue
)

188 
v®
 
fÜû_k’
 = 
io
.
±w
.
cu¡omCSRs
.
bpmStic


189 
	`wh’
 (
io
.
±w
.
cu¡omCSRs
.
æushBTB
è{ 
btb
.io.
æush
 :ğ
Œue
 }

190 
	`wh’
 (
fÜû_k’
è{ 
btb
.
io
.
bht_upd©e
.
v®id
 :ğ
çl£
 }

192 
v®
 
s2_ba£_pc
 = ~(~
s2_pc
 | (
ãtchBy‹s
-1))

193 
v®
 
k’_idx
 = 
	`Wœe
(
	`UIÁ
())

194 
v®
 
aá”_idx
 = 
	`Wœe
(
	`UIÁ
())

195 
v®
 
u£RAS
 = 
	`Wœe
(
š™
=
çl£
.
B
)

196 
v®
 
upd©eBTB
 = 
	`Wœe
(
š™
=
çl£
.
B
)

198 
def
 
	`sÿnIn¢s
(
idx
: 
IÁ
, 
´evV®id
: 
BoŞ
, 
´evB™s
: 
UIÁ
, 
´evTak’
: Bool): Bool = {

199 
def
 
	`š¢IsRVC
(
b™s
: 
UIÁ
èğ
	`b™s
(1,0) =/= 3

200 
v®
 
´evRVI
 = 
´evV®id
 && !
	`š¢IsRVC
(
´evB™s
)

201 
v®
 
v®id
 = 
fq
.
io
.
’q
.
b™s
.
	`mask
(
idx
è&& !
´evRVI


202 
v®
 
b™s
 = 
fq
.
io
.
’q
.b™s.
	`d©a
(
cÜeIn¡B™s
*(
idx
+1)-1, coreInstBits*idx)

203 
v®
 
rvc
 = 
	`š¢IsRVC
(
b™s
)

204 
v®
 
rviB™s
 = 
	`C©
(
b™s
, 
´evB™s
)

205 
v®
 
rviB¿nch
 = 
	`rviB™s
(6,0è==ğ
In¡ruùiÚs
.
BEQ
.
v®ue
.
	`asUIÁ
()(6,0)

206 
v®
 
rviJump
 = 
	`rviB™s
(6,0è==ğ
In¡ruùiÚs
.
JAL
.
v®ue
.
	`asUIÁ
()(6,0)

207 
v®
 
rviJALR
 = 
	`rviB™s
(6,0è==ğ
In¡ruùiÚs
.
JALR
.
v®ue
.
	`asUIÁ
()(6,0)

208 
v®
 
rviR‘uº
 = 
rviJALR
 && !
	`rviB™s
(7è&& 
	`B™P©
("b00?01") ===„viBits(19,15)

209 
v®
 
rviC®l
 = (
rviJALR
 || 
rviJump
è&& 
	`rviB™s
(7)

210 
v®
 
rvcB¿nch
 = 
b™s
 ==ğ
In¡ruùiÚs
.
C_BEQZ
 || b™ ==ğIn¡ruùiÚs.
C_BNEZ


211 
v®
 
rvcJAL
 = 
	`BoŞ
(
xL’
 =ğ32è&& 
b™s
 ==ğ
In¡ruùiÚs
.
C_JAL


212 
v®
 
rvcJump
 = 
b™s
 ==ğ
In¡ruùiÚs
.
C_J
 || 
rvcJAL


213 
v®
 
rvcImm
 = 
	`Mux
(
	`b™s
(14), 
Ãw
 
	`RVCDecod”
(
b™s
, 
xL’
).
bImm
.
asSIÁ
,‚ew RVCDecod”(b™s, xL’).
jImm
.asSInt)

214 
v®
 
rvcJR
 = 
b™s
 ==ğ
In¡ruùiÚs
.
C_MV
 && 
	`b™s
(6,2) === 0

215 
v®
 
rvcR‘uº
 = 
rvcJR
 && 
	`B™P©
("b00?01"è==ğ
	`b™s
(11,7)

216 
v®
 
rvcJALR
 = 
b™s
 ==ğ
In¡ruùiÚs
.
C_ADD
 && 
	`b™s
(6,2) === 0

217 
v®
 
rvcC®l
 = 
rvcJAL
 || 
rvcJALR


218 
v®
 
rviImm
 = 
	`Mux
(
	`rviB™s
(3), 
	`ImmG’
(
IMM_UJ
, 
rviB™s
), ImmG’(
IMM_SB
,„viBits))

219 
v®
 
´ediù_k’
 = 
s2_btb_»¥_b™s
.
bht
.
k’
 || 
fÜû_k’


220 
v®
 
k’
 =

221 
´evRVI
 && (
rviJump
 || 
rviJALR
 || 
rviB¿nch
 && 
´ediù_k’
) ||

222 
v®id
 && (
rvcJump
 || 
rvcJALR
 || 
rvcJR
 || 
rvcB¿nch
 && 
´ediù_k’
)

223 
v®
 
´ediùR‘uº
 = 
btb
.
io
.
¿s_h—d
.
v®id
 && (
´evRVI
 && 
rviR‘uº
 || v®id && 
rvcR‘uº
)

224 
v®
 
´ediùJump
 = 
´evRVI
 && 
rviJump
 || 
v®id
 && 
rvcJump


225 
v®
 
´ediùB¿nch
 = 
´ediù_k’
 && (
´evRVI
 && 
rviB¿nch
 || 
v®id
 && 
rvcB¿nch
)

227 
	`wh’
 (
s2_v®id
 && 
s2_btb_»¥_v®id
 && 
s2_btb_»¥_b™s
.
bridx
 ==ğ
idx
 && 
v®id
 && !
rvc
) {

230 
btb
.
io
.
æush
 :ğ
Œue


231 
fq
.
io
.
’q
.
b™s
.
»¶ay
 :ğ
Œue


232 
wrÚg_·th
 :ğ
Œue


233 
	`ccov”
(
wrÚg_·th
, "BTB_NON_CFI_ON_WRONG_PATH", "BTB…redicted‡‚on-branch wasaken while onhe wrong…ath")

236 
	`wh’
 (!
´evTak’
) {

237 
k’_idx
 :ğ
idx


238 
aá”_idx
 :ğ
idx
 + 1

239 
btb
.
io
.
¿s_upd©e
.
v®id
 :ğ
fq
.io.
’q
.
	`fœe
(è&& !
wrÚg_·th
 && (
´evRVI
 && (
rviC®l
 || 
rviR‘uº
è|| v®id && (
rvcC®l
 || 
rvcR‘uº
))

240 
btb
.
io
.
¿s_upd©e
.
b™s
.
cfiTy³
 :ğ
	`Mux
(Mux(
´evRVI
, 
rviR‘uº
, 
rvcR‘uº
), 
CFITy³
.
»t
,

241 
	`Mux
(Mux(
´evRVI
, 
rviC®l
, 
rvcC®l
), 
CFITy³
.
ÿÎ
,

242 
	`Mux
(Mux(
´evRVI
, 
rviB¿nch
, 
rvcB¿nch
è&& !
fÜû_k’
, 
CFITy³
.
b¿nch
,

243 
CFITy³
.
jump
)))

245 
	`wh’
 (!
s2_btb_k’
) {

246 
	`wh’
 (
fq
.
io
.
’q
.
	`fœe
(è&& 
k’
 && !
´ediùB¿nch
 && !
´ediùJump
 && !
´ediùR‘uº
) {

247 
wrÚg_·th
 :ğ
Œue


249 
	`wh’
 (
s2_v®id
 && 
´ediùR‘uº
) {

250 
u£RAS
 :ğ
Œue


252 
	`wh’
 (
s2_v®id
 && (
´ediùB¿nch
 || 
´ediùJump
)) {

253 
v®
 
pc
 = 
s2_ba£_pc
 | (
idx
*
cÜeIn¡By‹s
)

254 
v®
 
Åc
 =

255 ià(
idx
 =ğ0è
pc
.
asSIÁ
 + 
	`Mux
(
´evRVI
, 
rviImm
 -& 2.
S
, 
rvcImm
)

256 
	`Mux
(
´evRVI
, 
pc
 - 
cÜeIn¡By‹s
,…c).
asSIÁ
 + MuxÕ»vRVI, 
rviImm
, 
rvcImm
)

257 
´ediùed_Åc
 :ğ
Åc
.
asUIÁ


260 
	`wh’
 (
´evRVI
 && 
rviB¿nch
 || 
v®id
 && 
rvcB¿nch
) {

261 
btb
.
io
.
bht_advªû
.
v®id
 :ğ
fq
.io.
’q
.
	`fœe
(è&& !
wrÚg_·th


262 
btb
.
io
.
bht_advªû
.
b™s
 :ğ
s2_btb_»¥_b™s


264 
	`wh’
 (!
s2_btb_»¥_v®id
 && (
´ediùB¿nch
 && 
s2_btb_»¥_b™s
.
bht
.
¡rÚgly_k’
 || 
´ediùJump
 || 
´ediùR‘uº
)) {

265 
upd©eBTB
 :ğ
Œue


269 ià(
idx
 =ğ
ãtchWidth
-1) {

270 
	`wh’
 (
fq
.
io
.
’q
.
	`fœe
()) {

271 
s2_·¹Ÿl_š¢_v®id
 :ğ
çl£


272 
	`wh’
 (
v®id
 && !
´evTak’
 && !
rvc
) {

273 
s2_·¹Ÿl_š¢_v®id
 :ğ
Œue


274 
s2_·¹Ÿl_š¢
 :ğ
b™s
 | 0x3

277 
´evTak’
 || 
k’


279 
	`sÿnIn¢s
(
idx
 + 1, 
v®id
, 
b™s
, 
´evTak’
 || 
k’
)

283 
	`wh’
 (!
io
.
ıu
.
btb_upd©e
.
v®id
) {

284 
v®
 
ãtch_bubbË_lik–y
 = !
fq
.
io
.
	`mask
(1)

285 
btb
.
io
.
btb_upd©e
.
v®id
 :ğ
fq
.io.
’q
.
	`fœe
(è&& !
wrÚg_·th
 && 
ãtch_bubbË_lik–y
 && 
upd©eBTB


286 
btb
.
io
.
btb_upd©e
.
b™s
.
´ediùiÚ
.
’Œy
 :ğ
	`UIÁ
(
teP¬ams
.btb.
g‘
.
nEÁr›s
)

287 
btb
.
io
.
btb_upd©e
.
b™s
.
isV®id
 :ğ
Œue


288 
btb
.
io
.
btb_upd©e
.
b™s
.
cfiTy³
 :ğbtb.io.
¿s_upd©e
.bits.cfiType

289 
btb
.
io
.
btb_upd©e
.
b™s
.
br_pc
 :ğ
s2_ba£_pc
 | (
k’_idx
 << 
	`log2Ce
(
cÜeIn¡By‹s
))

290 
btb
.
io
.
btb_upd©e
.
b™s
.
pc
 :ğ
s2_ba£_pc


293 
btb
.
io
.
¿s_upd©e
.
b™s
.
»tuºAddr
 :ğ
s2_ba£_pc
 + (
aá”_idx
 << 
	`log2Ce
(
cÜeIn¡By‹s
))

295 
v®
 
k’
 = 
	`sÿnIn¢s
(0, 
s2_·¹Ÿl_š¢_v®id
, 
s2_·¹Ÿl_š¢
, 
çl£
.
B
)

296 
	`wh’
 (
u£RAS
) {

297 
´ediùed_Åc
 :ğ
btb
.
io
.
¿s_h—d
.
b™s


299 
	`wh’
 (
fq
.
io
.
’q
.
	`fœe
(è&& (
s2_btb_k’
 || 
k’
)) {

300 
s2_·¹Ÿl_š¢_v®id
 :ğ
çl£


302 
	`wh’
 (!
s2_btb_k’
) {

303 
	`wh’
 (
k’
) {

304 
fq
.
io
.
’q
.
b™s
.
btb
.
bridx
 :ğ
k’_idx


305 
fq
.
io
.
’q
.
b™s
.
btb
.
k’
 :ğ
Œue


306 
fq
.
io
.
’q
.
b™s
.
btb
.
’Œy
 :ğ
	`UIÁ
(
teP¬ams
.btb.
g‘
.
nEÁr›s
)

307 
	`wh’
 (
fq
.
io
.
’q
.
	`fœe
()è{ 
s2_»dœeù
 :ğ
Œue
 }

311 
	`as£¹
(!
s2_·¹Ÿl_š¢_v®id
 || 
fq
.
io
.
’q
.
b™s
.
	`mask
(0))

312 
	`wh’
 (
s2_»dœeù
è{ 
s2_·¹Ÿl_š¢_v®id
 :ğ
çl£
 }

313 
	`wh’
 (
io
.
ıu
.
»q
.
v®id
è{ 
wrÚg_·th
 :ğ
çl£
 }

316 
io
.
ıu
.
»¥
 <> 
fq
.io.
deq


319 
io
.
ıu
.
³rf
 :ğ
iÿche
.io.perf

320 
io
.
ıu
.
³rf
.
bMiss
 :ğio.
±w
.
»q
.
	`fœe
()

321 
io
.
”rÜs
 :ğ
iÿche
.io.errors

324 
şock_’_»g
 :ğ
io
.
ıu
.
might_»que¡
 ||

325 
iÿche
.
io
.
k“p_şock_’abËd
 ||

326 
s1_v®id
 || 
s2_v®id
 ||

327 !
b
.
io
.
»q
.
»ady
 ||

328 !
fq
.
io
.
	`mask
(fq.io.
mask
.
g‘Width
-1)

329 
	}
}

331 
def
 
®ignPC
(
pc
: 
UIÁ
èğ~(~pø| (
cÜeIn¡By‹s
 - 1))

333 
def
 
	$ccov”
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

334 
	`cov”
(
cÚd
, 
s
"FRONTEND_$Ïb–", "Rock‘;;" + 
desc
)

335 
	}
}

338 
Œa™
 
HasICacheFrÚ‹nd
 
ex‹nds
 
	gCªHavePTW
 { 
	gthis
: 
Ba£Te
 =>

339 
v®
 
moduË
: 
HasICacheFrÚ‹ndModuË


340 
v®
 
äÚ‹nd
 = 
LazyModuË
(
Ãw
 
FrÚ‹nd
(
teP¬ams
.
iÿche
.
g‘
, 
h¬tId
))

341 
	gMa¡”Xb¬
.
	gnode
 :ğ
äÚ‹nd
.
ma¡”Node


342 
cÚÃùTLSÏve
(
äÚ‹nd
.
¦aveNode
, 
teP¬ams
.
cÜe
.
ãtchBy‹s
)

343 
	gnPTWPÜts
 += 1

346 
Œa™
 
HasICacheFrÚ‹ndModuË
 
ex‹nds
 
	gCªHavePTWModuË
 {

347 
v®
 
	gou‹r
: 
HasICacheFrÚ‹nd


348 
±wPÜts
 +ğ
ou‹r
.
äÚ‹nd
.
moduË
.
io
.
±w


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCache.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
dÚtTouch


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gP¬am‘”s
, 
	gF›ld
}

9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


14 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
Li¡Bufãr


16 
şass
 
	$DCacheP¬ams
(

17 
nS‘s
: 
IÁ
 = 64,

18 
nWays
: 
IÁ
 = 4,

19 
rowB™s
: 
IÁ
 = 64,

20 
nTLBEÁr›s
: 
IÁ
 = 32,

21 
gECC
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

22 
d©aECC
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

23 
d©aECCBy‹s
: 
IÁ
 = 1,

24 
nMSHRs
: 
IÁ
 = 1,

25 
nSDQ
: 
IÁ
 = 17,

26 
nRPQ
: 
IÁ
 = 16,

27 
nMMIOs
: 
IÁ
 = 1,

28 
blockBy‹s
: 
IÁ
 = 64,

29 
acquœeBefÜeR–—£
: 
BoŞ—n
 = 
çl£
,

30 
p–šeWayMux
: 
BoŞ—n
 = 
çl£
,

31 
şockG©e
: 
BoŞ—n
 = 
çl£
,

32 
sü©ch
: 
O±iÚ
[
BigIÁ
] = 
NÚe
è
ex‹nds
 
L1CacheP¬ams
 {

34 
def
 
gCode
: 
Code
 = Code.
	`äomSŒšg
(
gECC
)

35 
def
 
d©aCode
: 
Code
 = Code.
	`äomSŒšg
(
d©aECC
)

37 
def
 
d©aSü©ch·dBy‹s
: 
IÁ
 = 
sü©ch
.
	`m­
(
_
 => 
nS‘s
*
blockBy‹s
).
	`g‘OrEl£
(0)

39 
def
 
»¶aûm’t
 = 
Ãw
 
	`RªdomR•Ïûm’t
(
nWays
)

41 
	`»quœe
((!
sü©ch
.
isDefšed
 || 
nWays
 == 1),

43 
	`»quœe
((!
sü©ch
.
isDefšed
 || 
nMSHRs
 == 0),

45 
	`»quœe
(
	`isPow2
(
nS‘s
), 
s
"nSets($nSets) must be…ow2")

46 
	}
}

48 
Œa™
 
HasL1H–ÏCacheP¬am‘”s
 
ex‹nds
 
HasL1CacheP¬am‘”s
 
w™h
 
	gHasCÜeP¬am‘”s
 {

49 
v®
 
	gÿcheP¬ams
 = 
teP¬ams
.
dÿche
.
g‘


50 
v®
 
cfg
 = 
ÿcheP¬ams


52 
def
 
wÜdB™s
 = 
cÜeD©aB™s


53 
def
 
wÜdBy‹s
 = 
cÜeD©aBy‹s


54 
def
 
wÜdOffB™s
 = 
log2Up
(
wÜdBy‹s
)

55 
def
 
b—tBy‹s
 = 
ÿcheBlockBy‹s
 / 
ÿcheD©aB—ts


56 
def
 
b—tWÜds
 = 
b—tBy‹s
 / 
wÜdBy‹s


57 
def
 
b—tOffB™s
 = 
log2Up
(
b—tBy‹s
)

58 
def
 
idxMSB
 = 
uÁagB™s
-1

59 
def
 
idxLSB
 = 
blockOffB™s


60 
def
 
off£tmsb
 = 
idxLSB
-1

61 
def
 
off£sb
 = 
wÜdOffB™s


62 
def
 
rowWÜds
 = 
rowB™s
/
wÜdB™s


63 
def
 
doN¬rowR—d
 = 
cÜeD©aB™s
 * 
nWays
 % 
rowB™s
 == 0

64 
def
 
eccBy‹s
 = 
ÿcheP¬ams
.
d©aECCBy‹s


65 
v®
 
eccB™s
 = 
ÿcheP¬ams
.
d©aECCBy‹s
 * 8

66 
v®
 
’cB™s
 = 
ÿcheP¬ams
.
d©aCode
.
width
(
eccB™s
)

67 
v®
 
’cWÜdB™s
 = 
’cB™s
 * (
wÜdB™s
 / 
eccB™s
)

68 
def
 
’cD©aB™s
 = 
ÿcheP¬ams
.
d©aCode
.
width
(
cÜeD©aB™s
)

69 
def
 
’cRowB™s
 = 
’cD©aB™s
*
rowWÜds


70 
def
 
ÌscCyşes
 = 
cÜeP¬ams
.lrscCycles

71 
def
 
ÌscBackoff
 = 3

72 
def
 
blockProbeAá”G¿ÁCyşes
 = 8

73 
def
 
nIOMSHRs
 = 
ÿcheP¬ams
.
nMMIOs


74 
def
 
maxUnÿchedInFlight
 = 
ÿcheP¬ams
.
nMMIOs


75 
def
 
d©aSü©ch·dSize
 = 
ÿcheP¬ams
.
d©aSü©ch·dBy‹s


77 
»quœe
(
rowB™s
 >ğ
cÜeD©aB™s
, 
s
"rowBits($rowBits) < coreDataBits($coreDataBits)")

78 ià(!
	gusšgD©aSü©ch·d
)

79 
»quœe
(
rowB™s
 =ğ
ÿcheD©aB™s
, 
s
"rowBits($rowBits) != cacheDataBits($cacheDataBits)")

81 
»quœe
(
xL’
 <ğ
ÿcheD©aB™s
, 
s
"xLen($xLen) > cacheDataBits($cacheDataBits)")

84 
ab¡¿ù
 cÏs 
	cL1H–ÏCacheModuË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË


85 
w™h
 
HasL1H–ÏCacheP¬am‘”s


87 
ab¡¿ù
 cÏs 
	cL1H–ÏCacheBundË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
)

88 
w™h
 
HasL1H–ÏCacheP¬am‘”s


92 
Œa™
 
HasCÜeMemOp
 
ex‹nds
 
HasCÜeP¬am‘”s
 {

93 
v®
 
addr
 = 
	$UIÁ
(
width
 = 
cÜeMaxAddrB™s
)

94 
v®
 
g
 = 
	$B™s
(
width
 = 
dÿcheReqTagB™s
)

95 
v®
 
cmd
 = 
	$B™s
(
width
 = 
M_SZ
)

96 
v®
 
typ
 = 
	`B™s
(
width
 = 
MT_SZ
)

99 
Œa™
 
HasCÜeD©a
 
ex‹nds
 
HasCÜeP¬am‘”s
 {

100 
v®
 
d©a
 = 
	`B™s
(
width
 = 
cÜeD©aB™s
)

101 
	}
}

103 şas 
	cH–ÏCacheReqIÁ”Çl
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
è
w™h
 
HasCÜeMemOp
 {

104 
v®
 
phys
 = 
	`BoŞ
()

107 şas 
	cH–ÏCacheReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$H–ÏCacheReqIÁ”Çl
()(
p
è
w™h
 
HasCÜeD©a


109 şas 
	cH–ÏCacheRe¥
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
)

110 
w™h
 
HasCÜeMemOp


111 
w™h
 
HasCÜeD©a
 {

112 
v®
 
»¶ay
 = 
	$BoŞ
()

113 
v®
 
has_d©a
 = 
	$BoŞ
()

114 
v®
 
d©a_wÜd_by·ss
 = 
	$B™s
(
width
 = 
cÜeD©aB™s
)

115 
v®
 
d©a_¿w
 = 
	$B™s
(
width
 = 
cÜeD©aB™s
)

116 
v®
 
¡Üe_d©a
 = 
	`B™s
(
width
 = 
cÜeD©aB™s
)

119 şas 
	cAlignm’tExû±iÚs
 
ex‹nds
 
BundË
 {

120 
v®
 
ld
 = 
	$BoŞ
()

121 
v®
 
¡
 = 
	`BoŞ
()

124 şas 
	cH–ÏCacheExû±iÚs
 
ex‹nds
 
BundË
 {

125 
v®
 
ma
 = 
Ãw
 
Alignm’tExû±iÚs


126 
v®
 
pf
 = 
Ãw
 
Alignm’tExû±iÚs


127 
v®
 
«
 = 
Ãw
 
Alignm’tExû±iÚs


130 şas 
	cH–ÏCacheWr™eD©a
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

131 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
cÜeD©aB™s
)

132 
v®
 
mask
 = 
	`UIÁ
(
width
 = 
cÜeD©aBy‹s
)

135 şas 
	cH–ÏCacheP”fEv’ts
 
ex‹nds
 
BundË
 {

136 
v®
 
acquœe
 = 
	$BoŞ
()

137 
v®
 
»Ëa£
 = 
	$BoŞ
()

138 
v®
 
g¿Á
 = 
	$BoŞ
()

139 
v®
 
bMiss
 = 
	$BoŞ
()

140 
v®
 
blocked
 = 
	`BoŞ
()

144 şas 
	cH–ÏCacheIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

145 
v®
 
»q
 = 
	$Decou¶ed
(
Ãw
 
H–ÏCacheReq
)

146 
v®
 
s1_kl
 = 
	$BoŞ
(
OUTPUT
)

147 
v®
 
s1_d©a
 = 
Ãw
 
	`H–ÏCacheWr™eD©a
().
asOuut


148 
v®
 
s2_Çck
 = 
	$BoŞ
(
INPUT
)

149 
v®
 
s2_Çck_ÿu£_¿w
 = 
	$BoŞ
(
INPUT
)

150 
v®
 
s2_kl
 = 
	$BoŞ
(
OUTPUT
)

152 
v®
 
»¥
 = 
	`V®id
(
Ãw
 
H–ÏCacheRe¥
).
æ


153 
v®
 
»¶ay_Ãxt
 = 
	$BoŞ
(
INPUT
)

154 
v®
 
s2_xıt
 = (
Ãw
 
H–ÏCacheExû±iÚs
).
asIÅut


155 
v®
 
Üd”ed
 = 
	$BoŞ
(
INPUT
)

156 
v®
 
³rf
 = 
Ãw
 
	`H–ÏCacheP”fEv’ts
().
asIÅut


158 
v®
 
k“p_şock_’abËd
 = 
	$BoŞ
(
OUTPUT
)

159 
v®
 
şock_’abËd
 = 
	`BoŞ
(
INPUT
)

164 
ab¡¿ù
 cÏs 
	cH–ÏCache
(
h¬tid
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

165 
´Ùeùed
 
v®
 
cfg
 = 
	`p
(
TeKey
).
dÿche
.
g‘


167 
´Ùeùed
 
def
 
ÿcheCl›ÁP¬am‘”s
 = 
cfg
.
sü©ch
.
	`m­
(
x
 => 
	`Seq
()).
	`g‘OrEl£
(Seq(
	`TLCl›ÁP¬am‘”s
(

168 
Çme
 = 
s
"Core ${hartid} DCache",

169 
sourûId
 = 
	`IdRªge
(0, 1 
max
 
cfg
.
nMSHRs
),

170 
suµÜtsProbe
 = 
	$T¿nsãrSizes
(
cfg
.
blockBy‹s
, cfg.blockBytes))))

172 
´Ùeùed
 
def
 
mmioCl›ÁP¬am‘”s
 = 
	`Seq
(
	`TLCl›ÁP¬am‘”s
(

173 
Çme
 = 
s
"Core ${hartid} DCache MMIO",

174 
sourûId
 = 
	`IdRªge
(
fœ¡MMIO
, fœ¡MMIO + 
cfg
.
nMMIOs
),

175 
»que¡Fifo
 = 
Œue
))

177 
def
 
fœ¡MMIO
 = (
ÿcheCl›ÁP¬am‘”s
.
	$m­
(
_
.
sourûId
.
’d
è:+ 0).
max


179 
v®
 
node
 = 
	`TLCl›ÁNode
(
	`Seq
(
	`TLCl›ÁPÜtP¬am‘”s
(

180 
ÿcheCl›ÁP¬am‘”s
 ++ 
mmioCl›ÁP¬am‘”s
,

181 
mšL©’cy
 = 1)))

183 
v®
 
moduË
: 
H–ÏCacheModuË


186 şas 
	cH–ÏCacheBundË
(
v®
 
ou‹r
: 
H–ÏCache
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

187 
v®
 
h¬tid
 = 
	$UIÁ
(
INPUT
, 
h¬tIdL’
)

188 
v®
 
ıu
 = (
Ãw
 
H–ÏCacheIO
).
æ


189 
v®
 
±w
 = 
Ãw
 
	$TLBPTWIO
()

190 
v®
 
”rÜs
 = 
Ãw
 
DCacheE¼Üs


193 şas 
	cH–ÏCacheModuË
(
ou‹r
: 
H–ÏCache
è
ex‹nds
 
	$LazyModuËImp
(
ou‹r
)

194 
w™h
 
HasL1H–ÏCacheP¬am‘”s
 {

195 
im¶ic™
 
v®
 
edge
 = 
ou‹r
.
node
.
edges
.
	$out
(0)

196 
	`v®
 (
_out
, 
_
èğ
ou‹r
.
node
.
	$out
(0)

197 
v®
 
io
 = 
	`IO
(
Ãw
 
	$H–ÏCacheBundË
(
ou‹r
))

198 
	$dÚtTouch
(
io
.
ıu
.
»¥
)

199 
	$dÚtTouch
(
io
.
ıu
.
s1_d©a
)

201 
´iv©e
 
v®
 
fifoMªag”s
 = 
edge
.
mªag”
.
mªag”s
.
	$f‹r
(
TLFIFOFix”
.
®lUnÿch—bË
)

202 
fifoMªag”s
.
fÜ—ch
 { 
m
 =>

203 
	`»quœe
 (
m
.
fifoId
 =ğ
fifoMªag”s
.
h—d
.fifoId,

204 
s
"IOMSHRs must be FIFO for‡ll„egions withƒffects, but HellaCache sees ${m.nodePath.map(_.name)}")

206 
	}
}

210 
Œa™
 
	gHasH–ÏCache
 { 
	gthis
: 
Ba£Te
 =>

211 
v®
 
moduË
: 
HasH–ÏCacheModuË


212 
im¶ic™
 
v®
 
p
: 
P¬am‘”s


213 
def
 
fšdSü©ch·dFromICache
: 
O±iÚ
[
Add»ssS‘
]

214 
v¬
 
nDCachePÜts
 = 0

215 
Ïzy
 
v®
 
dÿche
: 
H–ÏCache
 = 
LazyModuË
(

216 if(
teP¬ams
.
dÿche
.
g‘
.
nMSHRs
 == 0) {

217 
Ãw
 
DCache
(
h¬tId
, 
fšdSü©ch·dFromICache
 
_
, 
p
(
Rock‘CrossšgKey
).
h—d
.
knownR©io
)

218 } { 
Ãw
 
NÚBlockšgDCache
(
h¬tId
) })

220 
Ma¡”Xb¬
.
node
 :ğ
dÿche
.node

223 
Œa™
 
HasH–ÏCacheModuË
 {

224 
v®
 
ou‹r
: 
HasH–ÏCache
 
w™h
 
HasTeP¬am‘”s


225 
im¶ic™
 
v®
 
p
: 
P¬am‘”s


226 
v®
 
dÿchePÜts
 = 
Li¡Bufãr
[
H–ÏCacheIO
]()

227 
v®
 
dÿcheArb
 = 
ModuË
(
Ãw
 
H–ÏCacheArb™”
(
ou‹r
.
nDCachePÜts
)(ou‹r.
p
))

228 
ou‹r
.
dÿche
.
moduË
.
io
.
ıu
 <> 
dÿcheArb
.io.
mem


233 şas 
	cL1M‘ad©a
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheBundË
()(
p
) {

234 
v®
 
coh
 = 
Ãw
 
Cl›ÁM‘ad©a


235 
v®
 
g
 = 
	`UIÁ
(
width
 = 
gB™s
)

238 
objeù
 
L1M‘ad©a
 {

239 
def
 
	`­¶y
(
g
: 
B™s
, 
coh
: 
Cl›ÁM‘ad©a
)(
im¶ic™
 
p
: 
P¬am‘”s
) = {

240 
v®
 
m‘a
 = 
	`Wœe
(
Ãw
 
L1M‘ad©a
)

241 
m‘a
.
g
 :=ag

242 
m‘a
.
coh
 := coh

243 
m‘a


245 
	}
}

247 şas 
	cL1M‘aR—dReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheBundË
()(
p
) {

248 
v®
 
idx
 = 
	$UIÁ
(
width
 = 
idxB™s
)

249 
v®
 
way_’
 = 
	$UIÁ
(
width
 = 
nWays
)

250 
v®
 
g
 = 
	`UIÁ
(
width
 = 
gB™s
)

253 şas 
	cL1M‘aWr™eReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1M‘aR—dReq
()(
p
) {

254 
v®
 
d©a
 = 
Ãw
 
L1M‘ad©a


257 
şass
 
L1M‘ad©aA¼ay
[
T
 <: 
L1M‘ad©a
](
ÚRe£t
: (è=> T)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

258 
v®
 
r¡V®
 = 
	`ÚRe£t
()

259 
v®
 
io
 = 
Ãw
 
BundË
 {

260 
v®
 
»ad
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aR—dReq
).
æ


261 
v®
 
wr™e
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aWr™eReq
).
æ


262 
v®
 
»¥
 = 
	`Vec
(
nWays
, 
r¡V®
.
şÚeTy³
).
asOuut


264 
v®
 
r¡_út
 = 
	`Reg
(
š™
=
	`UIÁ
(0, 
	`log2Up
(
nS‘s
+1)))

265 
v®
 
r¡
 = 
r¡_út
 < 
	`UIÁ
(
nS‘s
)

266 
v®
 
waddr
 = 
	`Mux
(
r¡
, 
r¡_út
, 
io
.
wr™e
.
b™s
.
idx
)

267 
v®
 
wd©a
 = 
	`Mux
(
r¡
, 
r¡V®
, 
io
.
wr™e
.
b™s
.
d©a
).
asUIÁ


268 
v®
 
wmask
 = 
	`Mux
(
r¡
 || 
	`BoŞ
(
nWays
 =ğ1), 
	`SIÁ
(-1), 
io
.
wr™e
.
b™s
.
way_’
.
asSIÁ
).
toBoŞs


269 
v®
 
rmask
 = 
	`Mux
(
r¡
 || 
	`BoŞ
(
nWays
 =ğ1), 
	`SIÁ
(-1), 
io
.
»ad
.
b™s
.
way_’
.
asSIÁ
).
toBoŞs


270 
	`wh’
 (
r¡
è{ 
r¡_út
 :ğr¡_út+
	`UIÁ
(1) }

272 
v®
 
m‘ab™s
 = 
r¡V®
.
g‘Width


273 
v®
 
g_¬¿y
 = 
	`SeqMem
(
nS‘s
, 
	`Vec
(
nWays
, 
	`UIÁ
(
width
 = 
m‘ab™s
)))

274 
v®
 
w’
 = 
r¡
 || 
io
.
wr™e
.
v®id


275 
	`wh’
 (
w’
) {

276 
g_¬¿y
.
	`wr™e
(
waddr
, 
Vec
.
	`fl
(
nWays
)(
wd©a
), 
wmask
)

278 
io
.
»¥
 :ğ
g_¬¿y
.
	`»ad
(io.
»ad
.
b™s
.
idx
, io.»ad.
	`fœe
()).
	`m­
(
r¡V®
.
	`äomB™s
(
_
))

280 
io
.
»ad
.
»ady
 :ğ!
w’


281 
io
.
wr™e
.
»ady
 :ğ!
r¡


282 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCacheArbiter.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 şas 
	cH–ÏCacheArb™”
(
n
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË


11 
v®
 
io
 = 
Ãw
 
BundË
 {

12 
v®
 
»que¡Ü
 = 
	`Vec
(
n
, 
Ãw
 
H–ÏCacheIO
).
æ


13 
v®
 
mem
 = 
Ãw
 
H–ÏCacheIO


16 ià(
n
 == 1) {

17 
io
.
mem
 <> io.
»que¡Ü
.
h—d


18 
	}
} {

19 
v®
 
s1_id
 = 
Reg
(
UIÁ
())

20 
v®
 
s2_id
 = 
Reg
(
Ãxt
=
s1_id
)

22 
io
.
mem
.
k“p_şock_’abËd
 :ğio.
»que¡Ü
.
m­
(
_
.k“p_şock_’abËd).
»duû
(_||_)

24 
io
.
mem
.
»q
.
v®id
 :ğio.
»que¡Ü
.
m­
(
_
.»q.v®id).
»duû
(_||_)

25 
io
.
»que¡Ü
(0).
»q
.
»ady
 :ğio.
mem
.req.ready

26 
i
 <- 1 
uÁ
 
n
)

27 
io
.
»que¡Ü
(
i
).
»q
.
»ady
 :ğio.»que¡Ü(i-1).»q.»ady && !io.»que¡Ü(i-1).»q.
v®id


29 
i
 <- 
n
-1 
to
 0 
by
 -1) {

30 
v®
 
»q
 = 
io
.
»que¡Ü
(
i
).req

31 
def
 
cÚÃù_s0
() = {

32 
io
.
mem
.
»q
.
b™s
.
cmd
 :=„eq.bits.cmd

33 
io
.
mem
.
»q
.
b™s
.
typ
 :=„eq.bits.typ

34 
io
.
mem
.
»q
.
b™s
.
addr
 :=„eq.bits.addr

35 
io
.
mem
.
»q
.
b™s
.
phys
 :=„eq.bits.phys

36 
io
.
mem
.
»q
.
b™s
.
g
 :ğ
C©
Ôeq.b™s.g, 
UIÁ
(
i
, 
log2Up
(
n
)))

37 
	gs1_id
 :ğ
UIÁ
(
i
)

39 
def
 
cÚÃù_s1
() = {

40 
io
.
mem
.
s1_kl
 :ğio.
»que¡Ü
(
i
).s1_kill

41 
io
.
mem
.
s1_d©a
 :ğio.
»que¡Ü
(
i
).s1_data

43 
def
 
cÚÃù_s2
() = {

44 
io
.
mem
.
s2_kl
 :ğio.
»que¡Ü
(
i
).s2_kill

47 ià(
i
 =ğ
n
-1) {

48 
cÚÃù_s0
()

49 
cÚÃù_s1
()

50 
cÚÃù_s2
()

52 
wh’
 (
»q
.
v®id
è{ 
cÚÃù_s0
() }

53 
wh’
 (
s1_id
 ==ğ
UIÁ
(
i
)è{ 
cÚÃù_s1
() }

54 
wh’
 (
s2_id
 ==ğ
UIÁ
(
i
)è{ 
cÚÃù_s2
() }

58 
i
 <- 0 
uÁ
 
n
) {

59 
v®
 
»¥
 = 
io
.
»que¡Ü
(
i
).resp

60 
v®
 
g_h™
 = 
io
.
mem
.
»¥
.
b™s
.
g
(
log2Up
(
n
)-1,0è==ğ
UIÁ
(
i
)

61 
»¥
.
v®id
 :ğ
io
.
mem
.»¥.v®id && 
g_h™


62 
io
.
»que¡Ü
(
i
).
s2_xıt
 :ğio.
mem
.s2_xcpt

63 
io
.
»que¡Ü
(
i
).
Üd”ed
 :ğio.
mem
.ordered

64 
io
.
»que¡Ü
(
i
).
³rf
 :ğio.
mem
.perf

65 
io
.
»que¡Ü
(
i
).
s2_Çck
 :ğio.
mem
.s2_Çck && 
s2_id
 ==ğ
UIÁ
(i)

66 
io
.
»que¡Ü
(
i
).
s2_Çck_ÿu£_¿w
 :ğio.
mem
.s2_nack_cause_raw

67 
io
.
»que¡Ü
(
i
).
şock_’abËd
 :ğio.
mem
.clock_enabled

68 
»¥
.
b™s
 :ğ
io
.
mem
.resp.bits

69 
»¥
.
b™s
.
g
 :ğ
io
.
mem
.»¥.b™s.g >> 
log2Up
(
n
)

71 
io
.
»que¡Ü
(
i
).
»¶ay_Ãxt
 :ğio.
mem
.replay_next

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IBuf.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 şas 
	cIn¡ruùiÚ
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
P¬am‘”izedBundË
 
w™h
 
HasCÜeP¬am‘”s
 {

12 
v®
 
xıt0
 = 
Ãw
 
FrÚ‹ndExû±iÚs


13 
v®
 
xıt1
 = 
Ãw
 
FrÚ‹ndExû±iÚs


14 
v®
 
»¶ay
 = 
	$BoŞ
()

15 
v®
 
rvc
 = 
	$BoŞ
()

16 
v®
 
š¡
 = 
Ãw
 
Ex·ndedIn¡ruùiÚ


17 
v®
 
¿w
 = 
	$UIÁ
(
width
 = 32)

18 
	`»quœe
(
cÜeIn¡B™s
 =ğ(ià(
usšgCom´es£d
) 16 32))

21 şas 
	cIBuf
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
CÜeModuË
 {

22 
v®
 
io
 = 
Ãw
 
BundË
 {

23 
v®
 
imem
 = 
	`Decou¶ed
(
Ãw
 
FrÚ‹ndRe¥
).
æ


24 
v®
 
kl
 = 
	`BoŞ
(
INPUT
)

25 
v®
 
pc
 = 
	`UIÁ
(
OUTPUT
, 
vaddrB™sEx‹nded
)

26 
v®
 
btb_»¥
 = 
Ãw
 
	`BTBRe¥
().
asOuut


27 
v®
 
š¡
 = 
	`Vec
(
»tœeWidth
, 
	`Decou¶ed
(
Ãw
 
In¡ruùiÚ
))

31 
	$»quœe
(
decodeWidth
 == 1)

33 
v®
 
n
 = 
ãtchWidth
 - 1

34 
v®
 
nBufV®id
 = ià(
n
 =ğ0è
	$UIÁ
(0è
	`Reg
(
š™
=
	`UIÁ
(0, 
	$log2Ce
(
ãtchWidth
)))

35 
v®
 
buf
 = 
	$Reg
(
io
.
imem
.
b™s
)

36 
v®
 
ibufBTBRe¥
 = 
	$Reg
(
Ãw
 
BTBRe¥
)

37 
v®
 
pcWÜdMask
 = 
	`UIÁ
(
cÜeIn¡By‹s
*
ãtchWidth
-1, 
vaddrB™sEx‹nded
)

39 
v®
 
pcWÜdB™s
 = 
io
.
imem
.
b™s
.
pc
.
	`exŒaù
(
	`log2Ce
(
ãtchWidth
*
cÜeIn¡By‹s
)-1, 
	$log2Ce
(
cÜeIn¡By‹s
))

40 
v®
 
nR—dy
 = 
	`Wœe
(
š™
 = 
	`UIÁ
(0, 
	`log2Ce
(
ãtchWidth
+1)))

41 
v®
 
nIC
 = 
	`Mux
(
io
.
imem
.
b™s
.
btb
.
k’
, io.imem.b™s.btb.
bridx
 +& 1, 
	`UIÁ
(
ãtchWidth
)è- 
pcWÜdB™s


42 
v®
 
nICR—dy
 = 
nR—dy
 - 
nBufV®id


43 
v®
 
nV®id
 = 
	`Mux
(
io
.
imem
.
v®id
, 
nIC
, 
	`UIÁ
(0)è+ 
nBufV®id


44 
io
.
imem
.
»ady
 :ğio.
	`š¡
(0).»ady && 
nR—dy
 >ğ
nBufV®id
 && (
nICR—dy
 >ğ
nIC
 || 
n
 >=‚IC -‚ICReady)

46 ià(
n
 > 0) {

47 
	`wh’
 (
io
.
	`š¡
(0).
»ady
) {

48 
nBufV®id
 :ğ
	`Mux
(
nR—dy
 >ğnBufV®id, 
	`UIÁ
(0),‚BufValid -‚Ready)

49 ià(
n
 > 1è
	`wh’
 (
nR—dy
 > 0 &&‚R—dy < 
nBufV®id
) {

50 
v®
 
shiáedBuf
 = 
	`shiáIn¢Right
(
buf
.
	`d©a
(
n
*
cÜeIn¡B™s
-1, cÜeIn¡B™s), (
nR—dy
-1)(
	`log2Ce
(n-1)-1,0))

51 
buf
.
d©a
 :ğ
	`C©
(buf.
	`d©a
(
n
*
cÜeIn¡B™s
-1, (n-1)*cÜeIn¡B™s), 
	`shiáedBuf
((n-1)*coreInstBits-1, 0))

52 
buf
.
pc
 :ğbuf.pø& ~
pcWÜdMask
 | (buf.pø+ (
nR—dy
 << 
	`log2Ce
(
cÜeIn¡By‹s
))) &…cWordMask

54 
	`wh’
 (
io
.
imem
.
v®id
 && 
nR—dy
 >ğ
nBufV®id
 && 
nICR—dy
 < 
nIC
 && 
n
 >=‚IC -‚ICReady) {

55 
v®
 
shamt
 = 
pcWÜdB™s
 + 
nICR—dy


56 
nBufV®id
 :ğ
nIC
 - 
nICR—dy


57 
buf
 :ğ
io
.
imem
.
b™s


58 
buf
.
d©a
 :ğ
	`shiáIn¢Right
(
io
.
imem
.
b™s
.d©a, 
shamt
)(
n
*
cÜeIn¡B™s
-1,0)

59 
buf
.
pc
 :ğ
io
.
imem
.
b™s
.pø& ~
pcWÜdMask
 | (io.imem.b™s.pø+ (
nICR—dy
 << 
	`log2Ce
(
cÜeIn¡By‹s
))) &…cWordMask

60 
ibufBTBRe¥
 :ğ
io
.
imem
.
b™s
.
btb


63 
	`wh’
 (
io
.
kl
) {

64 
nBufV®id
 := 0

66 
	}
}

68 
v®
 
icShiáAmt
 = (
ãtchWidth
 + 
nBufV®id
 - 
pcWÜdB™s
)(
log2Ce
(fetchWidth), 0)

69 
v®
 
	gicD©a
 = 
shiáIn¢Leá
(
C©
(
io
.
imem
.
b™s
.
d©a
, 
Fl
(
ãtchWidth
, io.imem.b™s.d©a(
cÜeIn¡B™s
-1, 0))), 
icShiáAmt
)

70 .
exŒaù
(3*
ãtchWidth
*
cÜeIn¡B™s
-1, 2*fetchWidth*coreInstBits)

71 
v®
 
	gicMask
 = (~
UIÁ
(0, 
ãtchWidth
*
cÜeIn¡B™s
è<< (
	gnBufV®id
 << 
	$log2Ce
(
cÜeIn¡B™s
)))(
ãtchWidth
*coreInstBits-1,0)

72 
v®
 
š¡
 = 
icD©a
 & 
icMask
 | 
buf
.
d©a
 & ~icMask

74 
v®
 
v®id
 = (
	`UIÁToOH
(
nV®id
è- 1)(
ãtchWidth
-1, 0)

75 
v®
 
bufMask
 = 
	`UIÁToOH
(
nBufV®id
) - 1

76 
v®
 
xıt
 = (0 
uÁ
 
bufMask
.
g‘Width
).
	`m­
(
i
 => 
	`Mux
(
	`bufMask
(i), 
buf
.xıt, 
io
.
imem
.
b™s
.xcpt))

77 
v®
 
buf_»¶ay
 = 
	`Mux
(
buf
.
»¶ay
, 
bufMask
, 
	$UIÁ
(0))

78 
v®
 
ic_»¶ay
 = 
buf_»¶ay
 | 
	`Mux
(
io
.
imem
.
b™s
.
»¶ay
, 
v®id
 & ~
bufMask
, 
	$UIÁ
(0))

79 
	`as£¹
(!
io
.
imem
.
v®id
 || !io.imem.
b™s
.
btb
.
k’
 || io.imem.b™s.btb.
bridx
 >ğ
pcWÜdB™s
)

81 
io
.
btb_»¥
 :ğio.
imem
.
b™s
.
btb


82 
io
.
pc
 :ğ
	`Mux
(
nBufV®id
 > 0, 
buf
.pc, io.
imem
.
b™s
.pc)

83 
	$ex·nd
(0, 0, 
š¡
)

85 
def
 
	$ex·nd
(
i
: 
IÁ
, 
j
: 
UIÁ
, 
curIn¡
: UIÁ): 
Un™
 = ià(˜< 
»tœeWidth
) {

86 
v®
 
exp
 = 
	`ModuË
(
Ãw
 
RVCEx·nd”
)

87 
exp
.
io
.
š
 :ğ
curIn¡


88 
io
.
	`š¡
(
i
).
b™s
.
š¡
 :ğ
exp
.io.
out


89 
io
.
	`š¡
(
i
).
b™s
.
¿w
 :ğ
curIn¡


91 ià(
usšgCom´es£d
) {

92 
v®
 
»¶ay
 = 
	`ic_»¶ay
(
j
è|| (!
exp
.
io
.
rvc
 && ic_replay(j+1))

93 
v®
 
fuÎ_š¢
 = 
exp
.
io
.
rvc
 || 
	`v®id
(
j
+1è|| 
	`buf_»¶ay
(j)

94 
io
.
	`š¡
(
i
).
v®id
 :ğ
	`v®id
(
j
è&& 
fuÎ_š¢


95 
io
.
	`š¡
(
i
).
b™s
.
xıt0
 :ğ
	`xıt
(
j
)

96 
io
.
	`š¡
(
i
).
b™s
.
xıt1
 :ğ
	`Mux
(
exp
.io.
rvc
, 0.U, 
	`xıt
(
j
+1).
asUIÁ
).
	`asTy³Of
(
Ãw
 
FrÚ‹ndExû±iÚs
)

97 
io
.
	`š¡
(
i
).
b™s
.
»¶ay
 :=„eplay

98 
io
.
	`š¡
(
i
).
b™s
.
rvc
 :ğ
exp
.io.rvc

100 
	`wh’
 ((
	`bufMask
(
j
è&& 
exp
.
io
.
rvc
è|| bufMask(j+1)è{ io.
btb_»¥
 :ğ
ibufBTBRe¥
 }

102 
	`wh’
 (
fuÎ_š¢
 && (
i
 =ğ0 || 
io
.
	`š¡
(i).
»ady
)è{ 
nR—dy
 :ğ
	`Mux
(
exp
.io.
rvc
, 
j
+1, j+2) }

104 
	`ex·nd
(
i
+1, 
	`Mux
(
exp
.
io
.
rvc
, 
j
+1, j+2), MuxÓxp.io.rvc, 
curIn¡
 >> 16, curInst >> 32))

106 
	`wh’
 (
i
 =ğ0 || 
io
.
	`š¡
(i).
»ady
è{ 
nR—dy
 := i+1 }

107 
io
.
	`š¡
(
i
).
v®id
 :ğ
	`v®id
(i)

108 
io
.
	`š¡
(
i
).
b™s
.
xıt0
 :ğ
	`xıt
(i)

109 
io
.
	`š¡
(
i
).
b™s
.
xıt1
 :ğ0.U.a
	`sTy³Of
(
Ãw
 
FrÚ‹ndExû±iÚs
)

110 
io
.
	`š¡
(
i
).
b™s
.
»¶ay
 :ğ
	`ic_»¶ay
(i)

111 
io
.
	`š¡
(
i
).
b™s
.
rvc
 :ğ
çl£


113 
	`ex·nd
(
i
+1, 
nuÎ
, 
curIn¡
 >> 32)

115 
	}
}

117 
def
 
shiáIn¢Leá
(
š
: 
UIÁ
, 
di¡
: UInt) = {

118 
v®
 
r
 = 
š
.
g‘Width
/
cÜeIn¡B™s


119 
»quœe
(
š
.
g‘Width
 % 
cÜeIn¡B™s
 == 0)

120 
v®
 
d©a
 = 
C©
(
Fl
((1 << (
log2Ce
(
r
è+ 1)è-„, 
š
 >> (r-1)*
cÜeIn¡B™s
), in)

121 
	gd©a
 << (
	gdi¡
 << 
log2Ce
(
cÜeIn¡B™s
))

124 
def
 
shiáIn¢Right
(
š
: 
UIÁ
, 
di¡
: UInt) = {

125 
v®
 
r
 = 
š
.
g‘Width
/
cÜeIn¡B™s


126 
»quœe
(
š
.
g‘Width
 % 
cÜeIn¡B™s
 == 0)

127 
v®
 
d©a
 = 
C©
(
Fl
((1 << (
log2Ce
(
r
è+ 1)è-„, 
š
 >> (r-1)*
cÜeIn¡B™s
), in)

128 
	gd©a
 >> (
	gdi¡
 << 
log2Ce
(
cÜeIn¡B™s
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ICache.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gDesüibedSRAM
, 
	g_
}

13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


14 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


15 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
dÚtTouch


17 
şass
 
	$ICacheP¬ams
(

18 
nS‘s
: 
IÁ
 = 64,

19 
nWays
: 
IÁ
 = 4,

20 
rowB™s
: 
IÁ
 = 128,

21 
nTLBEÁr›s
: 
IÁ
 = 32,

22 
ÿcheIdB™s
: 
IÁ
 = 0,

23 
gECC
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

24 
d©aECC
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

25 
™imAddr
: 
O±iÚ
[
BigIÁ
] = 
NÚe
,

26 
´eãtch
: 
BoŞ—n
 = 
çl£
,

27 
blockBy‹s
: 
IÁ
 = 64,

28 
Ï‹ncy
: 
IÁ
 = 2,

29 
ãtchBy‹s
: 
IÁ
 = 4è
ex‹nds
 
L1CacheP¬ams
 {

30 
def
 
gCode
: 
Code
 = Code.
	`äomSŒšg
(
gECC
)

31 
def
 
d©aCode
: 
Code
 = Code.
	`äomSŒšg
(
d©aECC
)

32 
def
 
»¶aûm’t
 = 
Ãw
 
	`RªdomR•Ïûm’t
(
nWays
)

33 
	}
}

35 
Œa™
 
HasL1ICacheP¬am‘”s
 
ex‹nds
 
HasL1CacheP¬am‘”s
 
w™h
 
HasCÜeP¬am‘”s
 {

36 
v®
 
ÿcheP¬ams
 = 
teP¬ams
.
iÿche
.
g‘


39 şas 
	cICacheReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
è
w™h
 
HasL1ICacheP¬am‘”s
 {

40 
v®
 
addr
 = 
	`UIÁ
(
width
 = 
vaddrB™s
)

43 şas 
	cICacheE¼Üs
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
)

44 
w™h
 
HasL1ICacheP¬am‘”s


45 
w™h
 
CªHaveE¼Üs
 {

46 
v®
 
cÜ»ùabË
 = (
ÿcheP¬ams
.
gCode
.
ÿnD‘eù
 || cacheP¬ams.
d©aCode
.ÿnD‘eù).
	`İtiÚ
(
	`V®id
(
	$UIÁ
(
width
 = 
·ddrB™s
)))

47 
v®
 
uncÜ»ùabË
 = (
ÿcheP¬ams
.
™imAddr
.
nÚEm±y
 && cacheP¬ams.
d©aCode
.
ÿnD‘eù
).
	`İtiÚ
(
	`V®id
(
	`UIÁ
(
width
 = 
·ddrB™s
)))

50 
şass
 
	$ICache
(
v®
 
iÿcheP¬ams
: 
ICacheP¬ams
, v® 
h¬tId
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

51 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`ICacheModuË
(
this
)

52 
v®
 
ma¡”Node
 = 
	`TLCl›ÁNode
(
	`Seq
(
	`TLCl›ÁPÜtP¬am‘”s
(Seq(
	`TLCl›ÁP¬am‘”s
(

53 
sourûId
 = 
	`IdRªge
(0, 1 + 
iÿcheP¬ams
.
´eãtch
.
toIÁ
),

54 
Çme
 = 
s
"Core ${hartId} ICache")))))

56 
v®
 
size
 = 
iÿcheP¬ams
.
nS‘s
 * iÿcheP¬ams.
nWays
 * iÿcheP¬ams.
blockBy‹s


57 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("™im", 
	`Seq
("sifive,itim0"))

58 
´iv©e
 
v®
 
wÜdBy‹s
 = 
iÿcheP¬ams
.
ãtchBy‹s


59 
v®
 
¦aveNode
 =

60 
	`TLMªag”Node
(
iÿcheP¬ams
.
™imAddr
.
toSeq
.
m­
 { itimAdd¸=> 
	`TLMªag”PÜtP¬am‘”s
(

61 
	`Seq
(
	`TLMªag”P¬am‘”s
(

62 
add»ss
 = 
	`Seq
(
	`Add»ssS‘
(
™imAddr
, 
size
-1)),

63 
»sourûs
 = 
deviû
.
	`»g
("mem"),

64 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHEABLE
,

65 
execubË
 = 
Œue
,

66 
suµÜtsPutFuÎ
 = 
	`T¿nsãrSizes
(1, 
wÜdBy‹s
),

67 
suµÜtsPutP¬tŸl
 = 
	`T¿nsãrSizes
(1, 
wÜdBy‹s
),

68 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(1, 
wÜdBy‹s
),

69 
fifoId
 = 
	`Some
(0))),

70 
b—tBy‹s
 = 
wÜdBy‹s
,

71 
mšL©’cy
 = 1)})

72 
	}
}

74 şas 
	cICacheRe¥
(
ou‹r
: 
ICache
è
ex‹nds
 
BundË
 {

75 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
ou‹r
.
iÿcheP¬ams
.
ãtchBy‹s
*8)

76 
v®
 
»¶ay
 = 
	$BoŞ
()

77 
v®
 
«
 = 
	$BoŞ
()

79 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`ICacheRe¥
(
ou‹r
).
asIn¡ªûOf
[
this
.
ty³
]

82 şas 
	cICacheP”fEv’ts
 
ex‹nds
 
BundË
 {

83 
v®
 
acquœe
 = 
	`BoŞ
()

86 
şass
 
	$ICacheBundË
(
v®
 
ou‹r
: 
ICache
è
ex‹nds
 
	$CÜeBundË
()(
ou‹r
.
p
) {

87 
v®
 
h¬tid
 = 
	`UIÁ
(
INPUT
, 
h¬tIdL’
)

88 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
ICacheReq
).
æ


89 
v®
 
s1_·ddr
 = 
	`UIÁ
(
INPUT
, 
·ddrB™s
)

90 
v®
 
s2_vaddr
 = 
	`UIÁ
(
INPUT
, 
vaddrB™s
)

91 
v®
 
s1_kl
 = 
	`BoŞ
(
INPUT
)

92 
v®
 
s2_kl
 = 
	`BoŞ
(
INPUT
)

93 
v®
 
s2_´eãtch
 = 
	`BoŞ
(
INPUT
)

95 
v®
 
»¥
 = 
	`V®id
(
Ãw
 
	`ICacheRe¥
(
ou‹r
))

96 
v®
 
šv®id©e
 = 
	`BoŞ
(
INPUT
)

98 
v®
 
”rÜs
 = 
Ãw
 
ICacheE¼Üs


99 
v®
 
³rf
 = 
Ãw
 
	`ICacheP”fEv’ts
().
asOuut


101 
v®
 
şock_’abËd
 = 
	`BoŞ
(
INPUT
)

102 
v®
 
k“p_şock_’abËd
 = 
	`BoŞ
(
OUTPUT
)

103 
	}
}

105 şas 
	cICacheModuË
(
ou‹r
: 
ICache
è
ex‹nds
 
	$LazyModuËImp
(
ou‹r
)

106 
w™h
 
HasL1ICacheP¬am‘”s
 {

107 
ov”ride
 
v®
 
ÿcheP¬ams
 = 
ou‹r
.
iÿcheP¬ams


109 
v®
 
io
 = 
	`IO
(
Ãw
 
	$ICacheBundË
(
ou‹r
))

110 
	`v®
 (
_out
, 
edge_out
èğ
ou‹r
.
ma¡”Node
.
	$out
(0)

112 
	`v®
 (
_š
, 
edge_š
èğ
ou‹r
.
¦aveNode
.
š
.
h—dO±iÚ
.
unz


114 
v®
 
tECC
 = 
ÿcheP¬ams
.
gCode


115 
v®
 
dECC
 = 
ÿcheP¬ams
.
d©aCode


117 
	`»quœe
(
	`isPow2
(
nS‘s
è&& 
	$isPow2
(
nWays
))

118 
	`»quœe
(!
usšgVM
 || 
pgIdxB™s
 >ğ
uÁagB™s
)

120 
v®
 
sü©ch·dOn
 = 
	$RegIn™
(
çl£
.
B
)

121 
v®
 
sü©ch·dMax
 = 
_š
.
	`m­
(

 => 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Ce
(
nS‘s
 * (
nWays
 - 1)))))

122 
def
 
	`lšeInSü©ch·d
(
lše
: 
UIÁ
èğ
sü©ch·dMax
.
	`m­
(
sü©ch·dOn
 &&†š<ğ
_
).
	$g‘OrEl£
(
çl£
.
B
)

123 
v®
 
sü©ch·dBa£
 = 
ou‹r
.
iÿcheP¬ams
.
™imAddr
.
m­
 { 
dummy
 =>

124 
	`p
(
LookupByH¬tId
)(
_
.
iÿche
.
	`æ©M­
(_.
™imAddr
.
	`m­
(_.
U
)), 
io
.
h¬tid
)

126 
def
 
	`addrMaybeInSü©ch·d
(
addr
: 
UIÁ
èğ
sü©ch·dBa£
.
	`m­
(
ba£
 =>‡dd¸>ğba£ &&‡dd¸< ba£ + 
ou‹r
.
size
).
	$g‘OrEl£
(
çl£
.
B
)

127 
def
 
	`addrInSü©ch·d
(
addr
: 
UIÁ
èğ
	`addrMaybeInSü©ch·d
×ddrè&& 
	`lšeInSü©ch·d
(
	`addr
(
uÁagB™s
+
	`log2Ce
(
nWays
)-1, 
blockOffB™s
))

128 
def
 
	`sü©ch·dWay
(
addr
: 
UIÁ
èğaddr.
	`exŒaù
(
uÁagB™s
+
	`log2Ce
(
nWays
)-1, untagBits)

129 
def
 
	`sü©ch·dWayV®id
(
way
: 
UIÁ
èğway < 
nWays
 - 1

130 
def
 
	`sü©ch·dLše
(
addr
: 
UIÁ
èğ
	`addr
(
uÁagB™s
+
	`log2Ce
(
nWays
)-1, 
blockOffB™s
)

131 
v®
 
s0_¦aveV®id
 = 
_š
.
	`m­
(
_
.
a
.
	`fœe
()).
	$g‘OrEl£
(
çl£
.
B
)

132 
v®
 
s1_¦aveV®id
 = 
	$RegNext
(
s0_¦aveV®id
, 
çl£
.
B
)

133 
v®
 
s2_¦aveV®id
 = 
	$RegNext
(
s1_¦aveV®id
, 
çl£
.
B
)

134 
v®
 
s3_¦aveV®id
 = 
	$RegNext
(
çl£
.
B
)

136 
v®
 
s1_v®id
 = 
	`Reg
(
š™
=
	$BoŞ
(
çl£
))

137 
v®
 
s1_g_h™
 = 
	`Wœe
(
	`Vec
(
nWays
, 
	$BoŞ
()))

138 
v®
 
s1_h™
 = 
s1_g_h™
.
	`»duû
(
_
||_è|| 
	`Mux
(
s1_¦aveV®id
, 
Œue
.
B
, 
	$addrMaybeInSü©ch·d
(
io
.
s1_·ddr
))

139 
	$dÚtTouch
(
s1_h™
)

140 
v®
 
s2_v®id
 = 
	`RegNext
(
s1_v®id
 && !
io
.
s1_kl
, 
	$BoŞ
(
çl£
))

141 
v®
 
s2_h™
 = 
	$RegNext
(
s1_h™
)

143 
v®
 
šv®id©ed
 = 
	`Reg
(
	$BoŞ
())

144 
v®
 
»fl_v®id
 = 
	$RegIn™
(
çl£
.
B
)

145 
v®
 
£nd_hšt
 = 
	$RegIn™
(
çl£
.
B
)

146 
v®
 
»fl_fœe
 = 
_out
.
a
.
	`fœe
(è&& !
£nd_hšt


147 
v®
 
hšt_out¡ªdšg
 = 
	$RegIn™
(
çl£
.
B
)

148 
v®
 
s2_miss
 = 
s2_v®id
 && !
s2_h™
 && !
io
.
s2_kl


149 
v®
 
s1_ÿn_»que¡_»fl
 = !(
s2_miss
 || 
»fl_v®id
)

150 
v®
 
s2_»que¡_»fl
 = 
s2_miss
 && 
	$RegNext
(
s1_ÿn_»que¡_»fl
)

151 
v®
 
»fl_addr
 = 
	$RegEÇbË
(
io
.
s1_·ddr
, 
s1_v®id
 && 
s1_ÿn_»que¡_»fl
)

152 
v®
 
»fl_g
 = 
	`»fl_addr
(
gB™s
+
uÁagB™s
-1,untagBits)

153 
v®
 
»fl_idx
 = 
	`»fl_addr
(
uÁagB™s
-1,
blockOffB™s
)

154 
v®
 
»fl_Úe_b—t
 = 
_out
.
d
.
	`fœe
(è&& 
edge_out
.
	$hasD©a
(
_out
.
d
.
b™s
)

156 
io
.
»q
.
»ady
 :ğ!(
»fl_Úe_b—t
 || 
s0_¦aveV®id
 || 
s3_¦aveV®id
)

157 
v®
 
s0_v®id
 = 
io
.
»q
.
	$fœe
()

158 
v®
 
s0_vaddr
 = 
io
.
»q
.
b™s
.
addr


159 
s1_v®id
 :ğ
s0_v®id


161 
	`v®
 (
_
, _, 
d_dÚe
, 
»fl_út
èğ
edge_out
.
	$couÁ
(
_out
.
d
)

162 
v®
 
»fl_dÚe
 = 
»fl_Úe_b—t
 && 
d_dÚe


163 
_out
.
d
.
»ady
 :ğ!
s3_¦aveV®id


164 
	`»quœe
 (
edge_out
.
mªag”
.
mšL©’cy
 > 0)

166 
v®
 
»¶_way
 = ià(
isDM
è
	$UIÁ
(0) {

168 
v®
 
v0
 = 
	`LFSR16
(
»fl_fœe
)(
	`log2Up
(
nWays
)-1,0)

169 
v¬
 
v
 = 
v0


170 
i
 <- 
	`log2Ce
(
nWays
è- 1 
to
 0 
by
 -1) {

171 
v®
 
mask
 = 
nWays
 - (
	`BigIÁ
(1è<< (
i
 + 1))

172 
v
 = v | (
	`lšeInSü©ch·d
(
	`C©
(
v0
 | 
mask
.
U
, 
»fl_idx
)è<< 
i
)

174 
	`as£¹
(!
	`lšeInSü©ch·d
(
	`C©
(
v
, 
»fl_idx
)))

175 
v


176 
	}
}

178 
v®
 
	gg_¬¿y
 = 
DesüibedSRAM
(

179 
Çme
 = "tag_array",

180 
desc
 = "ICache Tag Array",

181 
size
 = 
nS‘s
,

182 
d©a
 = 
Vec
(
nWays
, 
UIÁ
(
width
 = 
tECC
.width(1 + 
gB™s
)))

185 
v®
 
g_rd©a
 = 
g_¬¿y
.
»ad
(
s0_vaddr
(
uÁagB™s
-1,
blockOffB™s
), !
»fl_dÚe
 && 
s0_v®id
)

186 
v®
 
	gacüuedReflE¼Ü
 = 
Reg
(
	$BoŞ
())

187 
	$wh’
 (
»fl_dÚe
) {

189 
v®
 
’c_g
 = 
tECC
.
	`’code
(
	`C©
(
_out
.
d
.
b™s
.
cÜru±
, 
»fl_g
))

190 
g_¬¿y
.
	`wr™e
(
»fl_idx
, 
Vec
.
	`fl
(
nWays
)(
’c_g
), 
Seq
.
	`buÏ‹
ÒWays)(
»¶_way
 ==ğ
_
))

192 
	`ccov”
(
_out
.
d
.
b™s
.
cÜru±
, "D_CORRUPT", "I$ D-channel corrupt")

193 
	}
}

195 
v®
 
	gvb_¬¿y
 = 
Reg
(
š™
=
	$B™s
(0, 
nS‘s
*
nWays
))

196 
	$wh’
 (
»fl_Úe_b—t
) {

198 
vb_¬¿y
 :ğvb_¬¿y.
	`b™S‘
(
	`C©
(
»¶_way
, 
»fl_idx
), 
»fl_dÚe
 && !
šv®id©ed
)

199 
	}
}

200 
v®
 
	gšv®id©e
 = 
	$Wœe
(
š™
 = 
io
.
šv®id©e
)

201 
	$wh’
 (
šv®id©e
) {

202 
vb_¬¿y
 :ğ
	`B™s
(0)

203 
šv®id©ed
 :ğ
	`BoŞ
(
Œue
)

204 
	}
}

206 
v®
 
s1_g_di¥¬™y
 = 
Wœe
(
Vec
(
nWays
, 
	$BoŞ
()))

207 
v®
 
s1__”rÜ
 = 
	`Wœe
(
	`Vec
(
nWays
, 
	$BoŞ
()))

208 
v®
 
wÜdB™s
 = 
ou‹r
.
iÿcheP¬ams
.
ãtchBy‹s
*8

209 
v®
 
s1_dout
 = 
	`Wœe
(
	`Vec
(
nWays
, 
	`UIÁ
(
width
 = 
dECC
.
	$width
(
wÜdB™s
))))

211 
v®
 
s0_¦aveAddr
 = 
_š
.
	`m­
(
_
.
a
.
b™s
.
add»ss
).
	$g‘OrEl£
(0.U)

212 
v®
 
s1s3_¦aveAddr
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	$log2Ce
(
ou‹r
.
size
)))

213 
v®
 
s1s3_¦aveD©a
 = 
	`Reg
(
	$UIÁ
(
width
 = 
wÜdB™s
))

215 
i
 <- 0 
uÁ
 
nWays
) {

216 
v®
 
s1_idx
 = 
io
.
	`s1_·ddr
(
uÁagB™s
-1,
blockOffB™s
)

217 
v®
 
s1_g
 = 
io
.
	`s1_·ddr
(
gB™s
+
uÁagB™s
-1,untagBits)

218 
v®
 
sü©ch·dH™
 = 
	`sü©ch·dWayV®id
(
i
) &&

219 
	`Mux
(
s1_¦aveV®id
,

220 
	`lšeInSü©ch·d
(
	`sü©ch·dLše
(
s1s3_¦aveAddr
)è&& 
	`sü©ch·dWay
(s1s3_¦aveAddrè==ğ
i
,

221 
	`addrInSü©ch·d
(
io
.
s1_·ddr
è&& 
	`sü©ch·dWay
(io.s1_·ddrè==ğ
i
)

222 
v®
 
s1_vb
 = 
	`vb_¬¿y
(
	`C©
(
	`UIÁ
(
i
), 
s1_idx
)è&& !
s1_¦aveV®id


223 
v®
 
’c_g
 = 
tECC
.
	`decode
(
	`g_rd©a
(
i
))

224 
	`v®
 (
_”rÜ
, 
g
èğ
	`S¶™
(
’c_g
.
uncÜ»ùed
, 
gB™s
)

225 
v®
 
gM©ch
 = 
s1_vb
 && 
g
 ==ğ
s1_g


226 
	`s1_g_di¥¬™y
(
i
è:ğ
s1_vb
 && 
’c_g
.
”rÜ


227 
	`s1__”rÜ
(
i
è:ğ
gM©ch
 && 
_”rÜ
.
toBoŞ


228 
	`s1_g_h™
(
i
è:ğ
gM©ch
 || 
sü©ch·dH™


229 
	}
}

230 
as£¹
(!(
s1_v®id
 || 
s1_¦aveV®id
è|| 
PİCouÁ
(
s1_g_h™
 
z
 
s1_g_di¥¬™y
 
m­
 { (
h
, 
d
) => h && !d }) <= 1)

232 
»quœe
(
_out
.
d
.
b™s
.
d©a
.
g‘Width
 % 
wÜdB™s
 == 0)

234 
v®
 
d©a_¬¿ys
 = 
Seq
.
buÏ‹
(
_out
.
d
.
b™s
.
d©a
.
g‘Width
 / 
wÜdB™s
) {

235 
i
 =>

236 
DesüibedSRAM
(

237 
Çme
 = 
s
"data_arrays_${i}",

238 
desc
 = "ICache Data Array",

239 
size
 = 
nS‘s
 * 
»flCyşes
,

240 
d©a
 = 
Vec
(
nWays
, 
UIÁ
(
width
 = 
dECC
.width(
wÜdB™s
)))

244 (
	gd©a_¬¿y
, 
	gi
è<- 
d©a_¬¿ys
 
	gzW™hIndex
) {

245 
def
 
wÜdM©ch
(
addr
: 
UIÁ
èğaddr.
exŒaù
(
log2Ce
(
_out
.
d
.
b™s
.
d©a
.
g‘Width
/8)-1,†og2Ce(
wÜdB™s
/8)è==ğ
i


246 
def
 
row
(
addr
: 
UIÁ
èğaddr(
uÁagB™s
-1, 
blockOffB™s
-
log2Ce
(
»flCyşes
))

247 
v®
 
	gs0_»n
 = (
s0_v®id
 && 
wÜdM©ch
(
s0_vaddr
)è|| (
s0_¦aveV®id
 && wÜdM©ch(
s0_¦aveAddr
))

248 
v®
 
w’
 = (
»fl_Úe_b—t
 && !
šv®id©ed
è|| (
s3_¦aveV®id
 && 
wÜdM©ch
(
s1s3_¦aveAddr
))

249 
v®
 
mem_idx
 = 
Mux
(
»fl_Úe_b—t
, (
»fl_idx
 << 
log2Ce
(
»flCyşes
)è| 
»fl_út
,

250 
Mux
(
s3_¦aveV®id
, 
row
(
s1s3_¦aveAddr
),

251 
Mux
(
s0_¦aveV®id
, 
row
(
s0_¦aveAddr
),

252 
row
(
s0_vaddr
))))

253 
wh’
 (
w’
) {

254 
v®
 
	gd©a
 = 
Mux
(
s3_¦aveV®id
, 
s1s3_¦aveD©a
, 
_out
.
d
.
b™s
.
d©a
(
wÜdB™s
*(
i
+1)-1, wordBits*i))

255 
v®
 
	gway
 = 
Mux
(
s3_¦aveV®id
, 
sü©ch·dWay
(
s1s3_¦aveAddr
), 
»¶_way
)

256 
	gd©a_¬¿y
.
wr™e
(
mem_idx
, 
Vec
.
fl
(
nWays
)(
dECC
.
’code
(
d©a
)), (0 
uÁ
‚Ways).
m­
(
way
 ==ğ
_
))

258 
v®
 
	gdout
 = 
d©a_¬¿y
.
»ad
(
mem_idx
, !
w’
 && 
s0_»n
)

259 
wh’
 (
wÜdM©ch
(
Mux
(
s1_¦aveV®id
, 
s1s3_¦aveAddr
, 
io
.
s1_·ddr
))) {

260 
	gs1_dout
 :ğ
dout


264 
v®
 
s1_şk_’
 = 
s1_v®id
 || 
s1_¦aveV®id


265 
v®
 
s2_g_h™
 = 
	$RegEÇbË
(
s1_g_h™
, 
s1_şk_’
)

266 
v®
 
s2_h™_way
 = 
	$OHToUIÁ
(
s2_g_h™
)

267 
v®
 
s2_sü©ch·d_wÜd_addr
 = 
	`C©
(
s2_h™_way
, 
	$Mux
(
s2_¦aveV®id
, 
s1s3_¦aveAddr
, 
io
.
s2_vaddr
)(
uÁagB™s
-1, 
	`log2Ce
(
wÜdB™s
/8)), 
	`UIÁ
(0,†og2Ceil(wordBits/8)))

268 
v®
 
s2_dout
 = 
	$RegEÇbË
(
s1_dout
, 
s1_şk_’
)

269 
v®
 
s2_way_mux
 = 
	$Mux1H
(
s2_g_h™
, 
s2_dout
)

271 
v®
 
s2_g_di¥¬™y
 = 
	`RegEÇbË
(
s1_g_di¥¬™y
, 
s1_şk_’
).
asUIÁ
.
ÜR


272 
v®
 
s2__”rÜ
 = 
	$RegEÇbË
(
s1__”rÜ
.
asUIÁ
.
ÜR
, 
s1_şk_’
)

273 
v®
 
s2_d©a_decoded
 = 
dECC
.
	$decode
(
s2_way_mux
)

274 
v®
 
s2_di¥¬™y
 = 
s2_g_di¥¬™y
 || 
s2_d©a_decoded
.
”rÜ


275 
v®
 
s2_fuÎ_wÜd_wr™e
 = 
	$Wœe
(
š™
 = 
çl£
.
B
)

277 
v®
 
s1_sü©ch·d_h™
 = 
	`Mux
(
s1_¦aveV®id
, 
	`lšeInSü©ch·d
(
	`sü©ch·dLše
(
s1s3_¦aveAddr
)), 
	$addrInSü©ch·d
(
io
.
s1_·ddr
))

278 
v®
 
s2_sü©ch·d_h™
 = 
	$RegEÇbË
(
s1_sü©ch·d_h™
, 
s1_şk_’
)

279 
v®
 
s2_»pÜt_uncÜ»ùabË_”rÜ
 = 
s2_sü©ch·d_h™
 && 
s2_d©a_decoded
.
uncÜ»ùabË
 && (
s2_v®id
 || (
s2_¦aveV®id
 && !
s2_fuÎ_wÜd_wr™e
))

280 
v®
 
s2_”rÜ_addr
 = 
sü©ch·dBa£
.
	`m­
(
ba£
 => 
	`Mux
(
s2_sü©ch·d_h™
, ba£ + 
s2_sü©ch·d_wÜd_addr
, 0.U)).
	$g‘OrEl£
(0.U)

283 
ou‹r
.
iÿcheP¬ams
.
Ï‹ncy
 
m©ch
 {

285 
	`»quœe
(
tECC
.
isIn¡ªûOf
[
Id’t™yCode
])

286 
	`»quœe
(
dECC
.
isIn¡ªûOf
[
Id’t™yCode
])

287 
	`»quœe
(
ou‹r
.
iÿcheP¬ams
.
™imAddr
.
isEm±y
)

288 
io
.
»¥
.
b™s
.
d©a
 :ğ
	`Mux1H
(
s1_g_h™
, 
s1_dout
)

289 
io
.
»¥
.
b™s
.
«
 :ğ
s1__”rÜ
.
asUIÁ
.
ÜR


290 
io
.
»¥
.
v®id
 :ğ
s1_v®id
 && 
s1_h™


294 
	`wh’
 (
s2_v®id
 && 
s2_di¥¬™y
è{ 
šv®id©e
 :ğ
Œue
 }

296 
io
.
»¥
.
b™s
.
d©a
 :ğ
s2_d©a_decoded
.
uncÜ»ùed


297 
io
.
»¥
.
b™s
.
«
 :ğ
s2__”rÜ


298 
io
.
»¥
.
b™s
.
»¶ay
 :ğ
s2_di¥¬™y


299 
io
.
»¥
.
v®id
 :ğ
s2_v®id
 && 
s2_h™


301 
io
.
”rÜs
.
cÜ»ùabË
.
fÜ—ch
 { 
c
 =>

302 
c
.
v®id
 :ğ(
s2_v®id
 || 
s2_¦aveV®id
è&& 
s2_di¥¬™y
 && !
s2_»pÜt_uncÜ»ùabË_”rÜ


303 
c
.
b™s
 :ğ
s2_”rÜ_addr


305 
io
.
”rÜs
.
uncÜ»ùabË
.
fÜ—ch
 { 
u
 =>

306 
u
.
v®id
 :ğ
s2_»pÜt_uncÜ»ùabË_”rÜ


307 
u
.
b™s
 :ğ
s2_”rÜ_addr


310 
_š
.
m­
 { 

 =>

311 
v®
 
»¥V®id
 = 
	`RegIn™
(
çl£
.
B
)

312 

.
a
.
»ady
 :ğ!(
_out
.
d
.
v®id
 || 
s1_¦aveV®id
 || 
s2_¦aveV®id
 || 
s3_¦aveV®id
 || 
»¥V®id
 || !
io
.
şock_’abËd
)

313 
v®
 
s1_a
 = 
	`RegEÇbË
(

.
a
.
b™s
, 
s0_¦aveV®id
)

314 
s2_fuÎ_wÜd_wr™e
 :ğ
edge_š
.
g‘
.
	`hasD©a
(
s1_a
è&& s1_a.
mask
.
ªdR


315 
	`wh’
 (
s0_¦aveV®id
) {

316 
v®
 
a
 = 

.a.
b™s


317 
s1s3_¦aveAddr
 :ğ

.
a
.
b™s
.
add»ss


318 
s1s3_¦aveD©a
 :ğ

.
a
.
b™s
.
d©a


319 
	`wh’
 (
edge_š
.
g‘
.
	`hasD©a
(
a
)) {

320 
v®
 
’abË
 = 
	`sü©ch·dWayV®id
(
	`sü©ch·dWay
(
a
.
add»ss
))

321 
	`wh’
 (!
	`lšeInSü©ch·d
(
	`sü©ch·dLše
(
a
.
add»ss
))) {

322 
sü©ch·dMax
.
g‘
 :ğ
	`sü©ch·dLše
(
a
.
add»ss
)

323 
šv®id©e
 :ğ
Œue


325 
sü©ch·dOn
 :ğ
’abË


327 
v®
 
™im_®loÿ‹d
 = !
sü©ch·dOn
 && 
’abË


328 
v®
 
™im_d—Îoÿ‹d
 = 
sü©ch·dOn
 && !
’abË


329 
v®
 
™im_šü—£
 = 
sü©ch·dOn
 && 
’abË
 && 
	`sü©ch·dLše
(
a
.
add»ss
è> 
sü©ch·dMax
.
g‘


330 
v®
 
»flšg
 = 
»fl_v®id
 && 
»fl_út
 > 0

331 
	`ccov”
(
™im_®loÿ‹d
, "ITIM_ALLOCATE", "ITIM‡llocated")

332 
	`ccov”
(
™im_®loÿ‹d
 && 
»flšg
, "ITIM_ALLOCATE_WHILE_REFILL", "ITIM‡llocated while I$„efill")

333 
	`ccov”
(
™im_d—Îoÿ‹d
, "ITIM_DEALLOCATE", "ITIM deallocated")

334 
	`ccov”
(
™im_d—Îoÿ‹d
 && 
»flšg
, "ITIM_DEALLOCATE_WHILE_REFILL", "ITIM deallocated while I$„efill")

335 
	`ccov”
(
™im_šü—£
, "ITIM_SIZE_INCREASE", "ITIM size increased")

336 
	`ccov”
(
™im_šü—£
 && 
»flšg
, "ITIM_SIZE_INCREASE_WHILE_REFILL", "ITIM size increased while I$„efill")

340 
	`as£¹
(!
s2_v®id
 || 
	`RegNext
(RegNext(
s0_vaddr
)è==ğ
io
.
s2_vaddr
)

341 
	`wh’
 (!(

.
a
.
v®id
 || 
s1_¦aveV®id
 || 
s2_¦aveV®id
 || 
»¥V®id
)

342 && 
s2_v®id
 && 
s2_d©a_decoded
.
”rÜ
 && !
s2_g_di¥¬™y
) {

347 
s3_¦aveV®id
 :ğ
Œue


348 
s1s3_¦aveD©a
 :ğ
s2_d©a_decoded
.
cÜ»ùed


349 
s1s3_¦aveAddr
 :ğ
s2_sü©ch·d_wÜd_addr
 | 
	`s1s3_¦aveAddr
(
	`log2Ce
(
wÜdB™s
/8)-1, 0)

352 
»¥V®id
 :ğ
s2_¦aveV®id
 || (»¥V®id && !

.
d
.
»ady
)

353 
v®
 
»¥E¼Ü
 = 
	`RegEÇbË
(
s2_sü©ch·d_h™
 && 
s2_d©a_decoded
.
uncÜ»ùabË
 && !
s2_fuÎ_wÜd_wr™e
, 
s2_¦aveV®id
)

354 
	`wh’
 (
s2_¦aveV®id
) {

355 
	`wh’
 (
edge_š
.
g‘
.
	`hasD©a
(
s1_a
è|| 
s2_d©a_decoded
.
”rÜ
è{ 
s3_¦aveV®id
 :ğ
Œue
 }

356 
def
 
	`by‹En
(
i
: 
IÁ
èğ!(
edge_š
.
g‘
.
	`hasD©a
(
s1_a
è&& s1_a.
	`mask
(i))

357 
s1s3_¦aveD©a
 :ğ(0 
uÁ
 
wÜdB™s
/8).
	`m­
(
i
 => 
	`Mux
(
	`by‹En
(i), 
s2_d©a_decoded
.
cÜ»ùed
, s1s3_¦aveD©a)(8*(i+1)-1, 8*i)).
asUIÁ


360 

.
d
.
v®id
 :ğ
»¥V®id


361 

.
d
.
b™s
 :ğ
	`Mux
(
edge_š
.
g‘
.
	`hasD©a
(
s1_a
),

362 
edge_š
.
g‘
.
	`AcûssAck
(
s1_a
),

363 
edge_š
.
g‘
.
	`AcûssAck
(
s1_a
, 
	`UIÁ
(0), 
d’›d
 = 
	`BoŞ
(
çl£
), 
cÜru±
 = 
»¥E¼Ü
))

364 

.
d
.
b™s
.
d©a
 :ğ
s1s3_¦aveD©a


367 

.
b
.
v®id
 :ğ
çl£


368 

.
c
.
»ady
 :ğ
Œue


369 

.
e
.
»ady
 :ğ
Œue


371 
	`ccov”
(
s0_v®id
 && 
s1_¦aveV®id
, "CONCURRENT_ITIM_ACCESS_1", "ITIM‡ccessed,hen I$‡ccessed‚ext cycle")

372 
	`ccov”
(
s0_v®id
 && 
s2_¦aveV®id
, "CONCURRENT_ITIM_ACCESS_2", "ITIM‡ccessed,hen I$‡ccessedwo cycles†ater")

373 
	`ccov”
(

.
d
.
v®id
 && !.d.
»ady
, "ITIM_D_STALL", "ITIM„esponse blocked by D-channel")

374 
	`ccov”
(
_out
.
d
.
v®id
 && !_out.d.
»ady
, "ITIM_BLOCK_D", "D-channel blocked by ITIM‡ccess")

376 
	}
}

378 
	g_out
.
	ga
.
	gv®id
 :ğ
s2_»que¡_»fl


379 
_out
.
a
.
b™s
 :ğ
edge_out
.
G‘
(

380 
äomSourû
 = 
UIÁ
(0),

381 
toAdd»ss
 = (
»fl_addr
 >> 
blockOffB™s
) << blockOffBits,

382 
lgSize
 = 
lgCacheBlockBy‹s
).
_2


383 ià(
ÿcheP¬ams
.
´eãtch
) {

384 
v®
 (
üos£s_·ge
, 
Ãxt_block
èğ
S¶™
(
»fl_addr
(
pgIdxB™s
-1, 
blockOffB™s
) +& 1,…gIdxBits-blockOffBits)

385 
wh’
 (
_out
.
a
.
fœe
()) {

386 
	g£nd_hšt
 :ğ!
hšt_out¡ªdšg
 && 
io
.
s2_´eãtch
 && !
üos£s_·ge


387 
wh’
 (
£nd_hšt
) {

388 
£nd_hšt
 :ğ
çl£


389 
hšt_out¡ªdšg
 :ğ
Œue


392 
wh’
 (
»fl_dÚe
) {

393 
£nd_hšt
 :ğ
çl£


395 
wh’
 (
_out
.
d
.
fœe
(è&& !
»fl_Úe_b—t
) {

396 
hšt_out¡ªdšg
 :ğ
çl£


399 
wh’
 (
£nd_hšt
) {

400 
_out
.
a
.
v®id
 :ğ
Œue


401 
_out
.
a
.
b™s
 :ğ
edge_out
.
Hšt
(

402 
äomSourû
 = 
UIÁ
(1),

403 
toAdd»ss
 = 
C©
(
»fl_addr
 >> 
pgIdxB™s
, 
Ãxt_block
è<< 
blockOffB™s
,

404 
lgSize
 = 
lgCacheBlockBy‹s
,

405 
·¿m
 = 
TLHšts
.
PREFETCH_READ
).
_2


408 
ccov”
(
£nd_hšt
 && !
_out
.
a
.
»ady
, "PREFETCH_A_STALL", "I$…refetch blocked by A-channel")

409 
ccov”
(
»fl_v®id
 && (
_out
.
d
.
fœe
(è&& !
»fl_Úe_b—t
), "PREFETCH_D_BEFORE_MISS_D", "I$…refetch„esolves before miss")

410 
ccov”
(!
»fl_v®id
 && (
_out
.
d
.
fœe
(è&& !
»fl_Úe_b—t
), "PREFETCH_D_AFTER_MISS_D", "I$…refetch„esolves‡fter miss")

411 
ccov”
(
_out
.
a
.
fœe
(è&& 
hšt_out¡ªdšg
, "PREFETCH_D_AFTER_MISS_A", "I$…refetch„esolves‡fter second miss")

413 
	g_out
.
	gb
.
	g»ady
 :ğ
	$BoŞ
(
Œue
)

414 
_out
.
c
.
v®id
 :ğ
	$BoŞ
(
çl£
)

415 
_out
.
e
.
v®id
 :ğ
	$BoŞ
(
çl£
)

416 
	`as£¹
(!(
_out
.
a
.
v®id
 && 
	$addrMaybeInSü©ch·d
(
_out
.
a
.
b™s
.
add»ss
)))

418 
	`wh’
 (!
»fl_v®id
è{ 
šv®id©ed
 :ğ
çl£
.
B
 
	}
}

419 
	$wh’
 (
»fl_fœe
è{ 
»fl_v®id
 :ğ
Œue
.
B
 
	}
}

420 
	$wh’
 (
»fl_dÚe
è{ 
»fl_v®id
 :ğ
çl£
.
B
}

422 
io
.
³rf
.
acquœe
 :ğ
»fl_fœe


423 
io
.
k“p_şock_’abËd
 :=

424 
_š
.
m­
(

 =>l.
a
.
v®id
 ||l.
d
.v®id || 
s1_¦aveV®id
 || 
s2_¦aveV®id
 || 
s3_¦aveV®id
).
g‘OrEl£
(
çl£
.
B
) ||

425 
s1_v®id
 || 
s2_v®id
 || 
»fl_v®id
 || 
£nd_hšt
 || 
hšt_out¡ªdšg


427 
ccov”
(!
£nd_hšt
 && (
_out
.
a
.
v®id
 && !_out.a.
»ady
), "MISS_A_STALL", "I$ miss blocked by A-channel")

428 
ccov”
(
šv®id©e
 && 
»fl_v®id
, "FLUSH_DURING_MISS", "I$ flushed during miss")

430 
def
 
	$ccov”
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

431 
	`cov”
(
cÚd
, 
s
"ICACHE_$Ïb–", "MemÜySy¡em;;" + 
desc
)

433 
v®
 
mem_aùive_v®id
 = 
	`Seq
(
	`Cov”BoŞ—n
(
s2_v®id
, Seq("mem_active")))

434 
v®
 
d©a_”rÜ
 = 
	`Seq
(

435 
	`Cov”BoŞ—n
(!
s2_d©a_decoded
.
cÜ»ùabË
 && !s2_d©a_decoded.
uncÜ»ùabË
, 
	`Seq
("no_data_error")),

436 
	`Cov”BoŞ—n
(
s2_d©a_decoded
.
cÜ»ùabË
, 
	`Seq
("data_correctable_error")),

437 
	`Cov”BoŞ—n
(
s2_d©a_decoded
.
uncÜ»ùabË
, 
	`Seq
("data_uncorrectable_error")))

438 
v®
 
»que¡_sourû
 = 
	`Seq
(

439 
	`Cov”BoŞ—n
(!
s2_¦aveV®id
, 
	`Seq
("from_CPU")),

440 
	`Cov”BoŞ—n
(
s2_¦aveV®id
, 
	`Seq
("from_TL"))

442 
v®
 
g_”rÜ
 = 
	`Seq
(

443 
	`Cov”BoŞ—n
(!
s2_g_di¥¬™y
, 
	`Seq
("no_tag_error")),

444 
	`Cov”BoŞ—n
(
s2_g_di¥¬™y
, 
	`Seq
("tag_error"))

446 
v®
 
mem_mode
 = 
	`Seq
(

447 
	`Cov”BoŞ—n
(
s2_sü©ch·d_h™
, 
	`Seq
("ITIM_mode")),

448 
	`Cov”BoŞ—n
(!
s2_sü©ch·d_h™
, 
	`Seq
("cache_mode"))

451 
v®
 
”rÜ_üoss_cov”s
 = 
Ãw
 
	`CrossPrİ”ty
(

452 
	`Seq
(
mem_aùive_v®id
, 
d©a_”rÜ
, 
g_”rÜ
, 
»que¡_sourû
, 
mem_mode
),

453 
	`Seq
(

455 
	`Seq
("tag_error", "ITIM_mode"),

457 
	`Seq
("from_TL", "cache_mode")

461 
	`cov”
(
”rÜ_üoss_cov”s
)

462 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IDecode.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
HasCÜeP¬am‘”s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsc›
.
SCIE


12 
impÜt
 
	gIn¡ruùiÚs
.
_


13 
impÜt
 
	gALU
.
_


15 
ab¡¿ù
 
Œa™
 
DecodeCÚ¡ªts
 
ex‹nds
 
	gHasCÜeP¬am‘”s


17 
v®
 
	gbË
: 
A¼ay
[(
B™P©
, 
Li¡
[BitPat])]

20 şas 
	cIÁCŒlSigs
 
ex‹nds
 
	mBundË
 {

21 
v®
 
	mËg®
 = 
	$BoŞ
()

22 
v®
 
å
 = 
	$BoŞ
()

23 
v®
 
rocc
 = 
	$BoŞ
()

24 
v®
 
b¿nch
 = 
	$BoŞ
()

25 
v®
 
j®
 = 
	$BoŞ
()

26 
v®
 
j®r
 = 
	$BoŞ
()

27 
v®
 
rxs2
 = 
	$BoŞ
()

28 
v®
 
rxs1
 = 
	$BoŞ
()

29 
v®
 
sc›
 = 
	$BoŞ
()

30 
v®
 
£l_®u2
 = 
	$B™s
(
width
 = 
A2_X
.
g‘Width
)

31 
v®
 
£l_®u1
 = 
	$B™s
(
width
 = 
A1_X
.
g‘Width
)

32 
v®
 
£l_imm
 = 
	$B™s
(
width
 = 
IMM_X
.
g‘Width
)

33 
v®
 
®u_dw
 = 
	$BoŞ
()

34 
v®
 
®u_â
 = 
	$B™s
(
width
 = 
FN_X
.
g‘Width
)

35 
v®
 
mem
 = 
	$BoŞ
()

36 
v®
 
mem_cmd
 = 
	$B™s
(
width
 = 
M_SZ
)

37 
v®
 
mem_ty³
 = 
	$B™s
(
width
 = 
MT_SZ
)

38 
v®
 
rfs1
 = 
	$BoŞ
()

39 
v®
 
rfs2
 = 
	$BoŞ
()

40 
v®
 
rfs3
 = 
	$BoŞ
()

41 
v®
 
wfd
 = 
	$BoŞ
()

42 
v®
 
mul
 = 
	$BoŞ
()

43 
v®
 
div
 = 
	$BoŞ
()

44 
v®
 
wxd
 = 
	$BoŞ
()

45 
v®
 
c¤
 = 
	$B™s
(
width
 = 
CSR
.
SZ
)

46 
v®
 
ãnû_i
 = 
	$BoŞ
()

47 
v®
 
ãnû
 = 
	$BoŞ
()

48 
v®
 
amo
 = 
	$BoŞ
()

49 
v®
 
dp
 = 
	$BoŞ
()

51 
def
 : 
Li¡
[
B™P©
] =

60 
	$Li¡
(
N
,
X
,X,X,X,X,X,X,X,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, X,X,X,X,X,X,X,
CSR
.X,X,X,X,X)

62 
def
 
	`decode
(
š¡
: 
UIÁ
, 
bË
: 
I‹¿bË
[(
B™P©
, 
Li¡
[BitPat])]) = {

63 
v®
 
decod”
 = 
	`DecodeLogic
(
š¡
, , 
bË
)

64 
v®
 
sigs
 = 
	`Seq
(
Ëg®
, 
å
, 
rocc
, 
b¿nch
, 
j®
, 
j®r
, 
rxs2
, 
rxs1
, 
sc›
, 
£l_®u2
,

65 
£l_®u1
, 
£l_imm
, 
®u_dw
, 
®u_â
, 
mem
, 
mem_cmd
, 
mem_ty³
,

66 
rfs1
, 
rfs2
, 
rfs3
, 
wfd
, 
mul
, 
div
, 
wxd
, 
c¤
, 
ãnû_i
, 
ãnû
, 
amo
, 
dp
)

67 
sigs
 
z
 
decod”
 
m­
 {(
s
,
d
) => s := d}

68 
this


70 
	}
}

72 şas 
	cIDecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


74 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

75 
BNE
-> 
	`Li¡
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SNE
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

76 
BEQ
-> 
	`Li¡
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SEQ
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

77 
BLT
-> 
	`Li¡
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SLT
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

78 
BLTU
-> 
	`Li¡
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SLTU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

79 
BGE
-> 
	`Li¡
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SGE
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

80 
BGEU
-> 
	`Li¡
(
Y
,
N
,N,Y,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_SB
,
DW_X
, 
FN_SGEU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

82 
JAL
-> 
	`Li¡
(
Y
,
N
,N,N,Y,N,N,N,N,
A2_SIZE
,
A1_PC
, 
IMM_UJ
,
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

83 
JALR
-> 
	`Li¡
(
Y
,
N
,N,N,N,Y,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

84 
AUIPC
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_PC
, 
IMM_U
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

86 
LB
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_B
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

87 
LH
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_H
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

88 
LW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

89 
LBU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_BU
,N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

90 
LHU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_HU
,N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

91 
SB
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_B
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

92 
SH
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_H
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

93 
SW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_W
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

95 
LUI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_U
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

96 
ADDI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

97 
SLTI
 -> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SLT
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

98 
SLTIU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SLTU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

99 
ANDI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_AND
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

100 
ORI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_OR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

101 
XORI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_XOR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

102 
ADD
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

103 
SUB
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SUB
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

104 
SLT
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SLT
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

105 
SLTU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SLTU
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

106 
AND
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_AND
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

107 
OR
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_OR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

108 
XOR
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_XOR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

109 
SLL
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

110 
SRL
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

111 
SRA
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

113 
FENCE
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,Y,N,N),

114 
FENCE_I
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, Y,
M_FLUSH_ALL
,
MT_X
, N,N,N,N,N,N,N,
CSR
.N,Y,N,N,N),

116 
SCALL
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

117 
SBREAK
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

118 
MRET
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

119 
WFI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N),

120 
CSRRW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
W
,N,N,N,N),

121 
CSRRS
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
S
,N,N,N,N),

122 
CSRRC
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
C
,N,N,N,N),

123 
CSRRWI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_Z
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
W
,N,N,N,N),

124 
CSRRSI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_Z
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
S
,N,N,N,N),

125 
CSRRCI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,N,N,
A2_IMM
, 
A1_ZERO
,
IMM_Z
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.
C
,N,N,N,N))

128 şas 
	cSDecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


130 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

131 
SFENCE_VMA
->
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_SFENCE
, 
MT_W
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

132 
SRET
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N))

135 şas 
	cDebugDecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


137 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

138 
DRET
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,
X
,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.
I
,N,N,N,N))

141 şas 
	cI32Decode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


143 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

144 
SLLI_RV32
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

145 
SRLI_RV32
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

146 
SRAI_RV32
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

149 şas 
	cI64Decode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


151 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

152 
LD
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

153 
LWU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_WU
,N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

154 
SD
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_D
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

156 
SLLI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

157 
SRLI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

158 
SRAI
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

160 
ADDIW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

161 
SLLIW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

162 
SRLIW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

163 
SRAIW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_32
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

164 
ADDW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

165 
SUBW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SUB
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

166 
SLLW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SL
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

167 
SRLW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SR
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

168 
SRAW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
,
FN_SRA
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

171 şas 
	cMDecode
(
p–šedMul
: 
BoŞ—n
)(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


173 
v®
 
M
 = ià(
p–šedMul
è
Y
 
N


174 
v®
 
D
 = ià(
p–šedMul
è
N
 
Y


175 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

176 
MUL
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MUL
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

177 
MULH
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MULH
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

178 
MULHU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MULHU
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

179 
MULHSU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_MULHSU
,N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

181 
DIV
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_DIV
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

182 
DIVU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_DIVU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

183 
REM
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_REM
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

184 
REMU
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_REMU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N))

187 şas 
	cM64Decode
(
p–šedMul
: 
BoŞ—n
)(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


189 
v®
 
M
 = ià(
p–šedMul
è
Y
 
N


190 
v®
 
D
 = ià(
p–šedMul
è
N
 
Y


191 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

192 
MULW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_MUL
, N,
M_X
, 
MT_X
, N,N,N,N,
M
,
D
,Y,
CSR
.N,N,N,N,N),

194 
DIVW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_DIV
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

195 
DIVUW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_DIVU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

196 
REMW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_REM
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N),

197 
REMUW
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_RS2
, 
A1_RS1
, 
IMM_X
, 
DW_32
, 
FN_REMU
, N,
M_X
, 
MT_X
, N,N,N,N,N,Y,Y,
CSR
.N,N,N,N,N))

200 şas 
	cADecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


202 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

203 
AMOADD_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_ADD
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

204 
AMOXOR_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_XOR
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

205 
AMOSWAP_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_SWAP
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

206 
AMOAND_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_AND
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

207 
AMOOR_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_OR
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

208 
AMOMIN_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MIN
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

209 
AMOMINU_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MINU
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

210 
AMOMAX_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAX
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

211 
AMOMAXU_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAXU
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

213 
LR_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XLR
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

214 
SC_W
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XSC
, 
MT_W
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N))

217 şas 
	cA64Decode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


219 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

220 
AMOADD_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_ADD
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

221 
AMOSWAP_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_SWAP
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

222 
AMOXOR_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_XOR
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

223 
AMOAND_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_AND
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

224 
AMOOR_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_OR
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

225 
AMOMIN_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MIN
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

226 
AMOMINU_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MINU
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

227 
AMOMAX_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAX
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

228 
AMOMAXU_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XA_MAXU
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

230 
LR_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XLR
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N),

231 
SC_D
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, Y,
M_XSC
, 
MT_D
, N,N,N,N,N,N,Y,
CSR
.N,N,N,Y,N))

234 şas 
	cFDecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


236 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

237 
FSGNJ_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

238 
FSGNJX_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

239 
FSGNJN_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

240 
FMIN_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

241 
FMAX_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

242 
FADD_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

243 
FSUB_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

244 
FMUL_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

245 
FMADD_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

246 
FMSUB_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

247 
FNMADD_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

248 
FNMSUB_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,N),

249 
FCLASS_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

250 
FMV_X_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

251 
FCVT_W_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

252 
FCVT_WU_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

253 
FEQ_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,N),

254 
FLT_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,N),

255 
FLE_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,N),

256 
FMV_S_X
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

257 
FCVT_S_W
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

258 
FCVT_S_WU
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

259 
FLW
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_W
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

260 
FSW
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_W
, N,Y,N,N,N,N,N,
CSR
.N,N,N,N,N),

261 
FDIV_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N),

262 
FSQRT_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,N))

265 şas 
	cDDecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


267 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

268 
FCVT_S_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

269 
FCVT_D_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

270 
FSGNJ_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

271 
FSGNJX_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

272 
FSGNJN_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

273 
FMIN_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

274 
FMAX_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

275 
FADD_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

276 
FSUB_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

277 
FMUL_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

278 
FMADD_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

279 
FMSUB_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

280 
FNMADD_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

281 
FNMSUB_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,Y,Y,N,N,N,
CSR
.N,N,N,N,Y),

282 
FCLASS_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

283 
FCVT_W_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

284 
FCVT_WU_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

285 
FEQ_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

286 
FLT_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

287 
FLE_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

288 
FCVT_D_W
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

289 
FCVT_D_WU
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

290 
FLD
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_I
, 
DW_XPR
,
FN_ADD
, Y,
M_XRD
, 
MT_D
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

291 
FSD
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_IMM
, 
A1_RS1
, 
IMM_S
, 
DW_XPR
,
FN_ADD
, Y,
M_XWR
, 
MT_D
, N,Y,N,N,N,N,N,
CSR
.N,N,N,N,Y),

292 
FDIV_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

293 
FSQRT_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,Y,N,Y,N,N,N,
CSR
.N,N,N,N,Y))

296 şas 
	cF64Decode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


298 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

299 
FCVT_L_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

300 
FCVT_LU_S
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

301 
FCVT_S_L
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N),

302 
FCVT_S_LU
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,N))

305 şas 
	cD64Decode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


307 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

308 
FMV_X_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

309 
FCVT_L_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

310 
FCVT_LU_D
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,N,N,
A2_X
, 
A1_X
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, Y,N,N,N,N,N,Y,
CSR
.N,N,N,N,Y),

311 
FMV_D_X
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

312 
FCVT_D_L
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y),

313 
FCVT_D_LU
-> 
	`Li¡
(
Y
,Y,
N
,N,N,N,N,Y,N,
A2_X
, 
A1_RS1
, 
IMM_X
, 
DW_X
, 
FN_X
, N,
M_X
, 
MT_X
, N,N,N,Y,N,N,N,
CSR
.N,N,N,N,Y))

316 şas 
	cSCIEDecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


318 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

319 
SCIE
.
İcode
-> 
	`Li¡
(
Y
,
N
,N,N,N,N,Y,Y,Y,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_X
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

322 şas 
	cRoCCDecode
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
DecodeCÚ¡ªts


324 
v®
 
bË
: 
A¼ay
[(
B™P©
, 
Li¡
[B™P©])] = 
	`A¼ay
(

325 
CUSTOM0
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

326 
CUSTOM0_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

327 
CUSTOM0_RS1_RS2
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

328 
CUSTOM0_RD
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

329 
CUSTOM0_RD_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

330 
CUSTOM0_RD_RS1_RS2
->
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

331 
CUSTOM1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

332 
CUSTOM1_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

333 
CUSTOM1_RS1_RS2
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

334 
CUSTOM1_RD
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

335 
CUSTOM1_RD_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

336 
CUSTOM1_RD_RS1_RS2
->
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

337 
CUSTOM2
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

338 
CUSTOM2_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

339 
CUSTOM2_RS1_RS2
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

340 
CUSTOM2_RD
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

341 
CUSTOM2_RD_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

342 
CUSTOM2_RD_RS1_RS2
->
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

343 
CUSTOM3
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

344 
CUSTOM3_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

345 
CUSTOM3_RS1_RS2
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,N,
CSR
.N,N,N,N,N),

346 
CUSTOM3_RD
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,N,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

347 
CUSTOM3_RD_RS1
-> 
	`Li¡
(
Y
,
N
,Y,N,N,N,N,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N),

348 
CUSTOM3_RD_RS1_RS2
->
	`Li¡
(
Y
,
N
,Y,N,N,N,Y,Y,N,
A2_ZERO
,
A1_RS1
, 
IMM_X
, 
DW_XPR
,
FN_ADD
, N,
M_X
, 
MT_X
, N,N,N,N,N,N,Y,
CSR
.N,N,N,N,N))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Instructions.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


9 
objeù
 
	gIn¡ruùiÚs
 {

10 
def
 
	gBEQ
 = 
B™P©
("b?????????????????000?????1100011")

11 
def
 
BNE
 = 
B™P©
("b?????????????????001?????1100011")

12 
def
 
BLT
 = 
B™P©
("b?????????????????100?????1100011")

13 
def
 
BGE
 = 
B™P©
("b?????????????????101?????1100011")

14 
def
 
BLTU
 = 
B™P©
("b?????????????????110?????1100011")

15 
def
 
BGEU
 = 
B™P©
("b?????????????????111?????1100011")

16 
def
 
JALR
 = 
B™P©
("b?????????????????000?????1100111")

17 
def
 
JAL
 = 
B™P©
("b?????????????????????????1101111")

18 
def
 
LUI
 = 
B™P©
("b?????????????????????????0110111")

19 
def
 
AUIPC
 = 
B™P©
("b?????????????????????????0010111")

20 
def
 
ADDI
 = 
B™P©
("b?????????????????000?????0010011")

21 
def
 
SLLI
 = 
B™P©
("b000000???????????001?????0010011")

22 
def
 
SLTI
 = 
B™P©
("b?????????????????010?????0010011")

23 
def
 
SLTIU
 = 
B™P©
("b?????????????????011?????0010011")

24 
def
 
XORI
 = 
B™P©
("b?????????????????100?????0010011")

25 
def
 
SRLI
 = 
B™P©
("b000000???????????101?????0010011")

26 
def
 
SRAI
 = 
B™P©
("b010000???????????101?????0010011")

27 
def
 
ORI
 = 
B™P©
("b?????????????????110?????0010011")

28 
def
 
ANDI
 = 
B™P©
("b?????????????????111?????0010011")

29 
def
 
ADD
 = 
B™P©
("b0000000??????????000?????0110011")

30 
def
 
SUB
 = 
B™P©
("b0100000??????????000?????0110011")

31 
def
 
SLL
 = 
B™P©
("b0000000??????????001?????0110011")

32 
def
 
SLT
 = 
B™P©
("b0000000??????????010?????0110011")

33 
def
 
SLTU
 = 
B™P©
("b0000000??????????011?????0110011")

34 
def
 
XOR
 = 
B™P©
("b0000000??????????100?????0110011")

35 
def
 
SRL
 = 
B™P©
("b0000000??????????101?????0110011")

36 
def
 
SRA
 = 
B™P©
("b0100000??????????101?????0110011")

37 
def
 
OR
 = 
B™P©
("b0000000??????????110?????0110011")

38 
def
 
AND
 = 
B™P©
("b0000000??????????111?????0110011")

39 
def
 
ADDIW
 = 
B™P©
("b?????????????????000?????0011011")

40 
def
 
SLLIW
 = 
B™P©
("b0000000??????????001?????0011011")

41 
def
 
SRLIW
 = 
B™P©
("b0000000??????????101?????0011011")

42 
def
 
SRAIW
 = 
B™P©
("b0100000??????????101?????0011011")

43 
def
 
ADDW
 = 
B™P©
("b0000000??????????000?????0111011")

44 
def
 
SUBW
 = 
B™P©
("b0100000??????????000?????0111011")

45 
def
 
SLLW
 = 
B™P©
("b0000000??????????001?????0111011")

46 
def
 
SRLW
 = 
B™P©
("b0000000??????????101?????0111011")

47 
def
 
SRAW
 = 
B™P©
("b0100000??????????101?????0111011")

48 
def
 
LB
 = 
B™P©
("b?????????????????000?????0000011")

49 
def
 
LH
 = 
B™P©
("b?????????????????001?????0000011")

50 
def
 
LW
 = 
B™P©
("b?????????????????010?????0000011")

51 
def
 
LD
 = 
B™P©
("b?????????????????011?????0000011")

52 
def
 
LBU
 = 
B™P©
("b?????????????????100?????0000011")

53 
def
 
LHU
 = 
B™P©
("b?????????????????101?????0000011")

54 
def
 
LWU
 = 
B™P©
("b?????????????????110?????0000011")

55 
def
 
SB
 = 
B™P©
("b?????????????????000?????0100011")

56 
def
 
SH
 = 
B™P©
("b?????????????????001?????0100011")

57 
def
 
SW
 = 
B™P©
("b?????????????????010?????0100011")

58 
def
 
SD
 = 
B™P©
("b?????????????????011?????0100011")

59 
def
 
FENCE
 = 
B™P©
("b?????????????????000?????0001111")

60 
def
 
FENCE_I
 = 
B™P©
("b?????????????????001?????0001111")

61 
def
 
MUL
 = 
B™P©
("b0000001??????????000?????0110011")

62 
def
 
MULH
 = 
B™P©
("b0000001??????????001?????0110011")

63 
def
 
MULHSU
 = 
B™P©
("b0000001??????????010?????0110011")

64 
def
 
MULHU
 = 
B™P©
("b0000001??????????011?????0110011")

65 
def
 
DIV
 = 
B™P©
("b0000001??????????100?????0110011")

66 
def
 
DIVU
 = 
B™P©
("b0000001??????????101?????0110011")

67 
def
 
REM
 = 
B™P©
("b0000001??????????110?????0110011")

68 
def
 
REMU
 = 
B™P©
("b0000001??????????111?????0110011")

69 
def
 
MULW
 = 
B™P©
("b0000001??????????000?????0111011")

70 
def
 
DIVW
 = 
B™P©
("b0000001??????????100?????0111011")

71 
def
 
DIVUW
 = 
B™P©
("b0000001??????????101?????0111011")

72 
def
 
REMW
 = 
B™P©
("b0000001??????????110?????0111011")

73 
def
 
REMUW
 = 
B™P©
("b0000001??????????111?????0111011")

74 
def
 
AMOADD_W
 = 
B™P©
("b00000????????????010?????0101111")

75 
def
 
AMOXOR_W
 = 
B™P©
("b00100????????????010?????0101111")

76 
def
 
AMOOR_W
 = 
B™P©
("b01000????????????010?????0101111")

77 
def
 
AMOAND_W
 = 
B™P©
("b01100????????????010?????0101111")

78 
def
 
AMOMIN_W
 = 
B™P©
("b10000????????????010?????0101111")

79 
def
 
AMOMAX_W
 = 
B™P©
("b10100????????????010?????0101111")

80 
def
 
AMOMINU_W
 = 
B™P©
("b11000????????????010?????0101111")

81 
def
 
AMOMAXU_W
 = 
B™P©
("b11100????????????010?????0101111")

82 
def
 
AMOSWAP_W
 = 
B™P©
("b00001????????????010?????0101111")

83 
def
 
LR_W
 = 
B™P©
("b00010??00000?????010?????0101111")

84 
def
 
SC_W
 = 
B™P©
("b00011????????????010?????0101111")

85 
def
 
AMOADD_D
 = 
B™P©
("b00000????????????011?????0101111")

86 
def
 
AMOXOR_D
 = 
B™P©
("b00100????????????011?????0101111")

87 
def
 
AMOOR_D
 = 
B™P©
("b01000????????????011?????0101111")

88 
def
 
AMOAND_D
 = 
B™P©
("b01100????????????011?????0101111")

89 
def
 
AMOMIN_D
 = 
B™P©
("b10000????????????011?????0101111")

90 
def
 
AMOMAX_D
 = 
B™P©
("b10100????????????011?????0101111")

91 
def
 
AMOMINU_D
 = 
B™P©
("b11000????????????011?????0101111")

92 
def
 
AMOMAXU_D
 = 
B™P©
("b11100????????????011?????0101111")

93 
def
 
AMOSWAP_D
 = 
B™P©
("b00001????????????011?????0101111")

94 
def
 
LR_D
 = 
B™P©
("b00010??00000?????011?????0101111")

95 
def
 
SC_D
 = 
B™P©
("b00011????????????011?????0101111")

96 
def
 
ECALL
 = 
B™P©
("b00000000000000000000000001110011")

97 
def
 
EBREAK
 = 
B™P©
("b00000000000100000000000001110011")

98 
def
 
URET
 = 
B™P©
("b00000000001000000000000001110011")

99 
def
 
SRET
 = 
B™P©
("b00010000001000000000000001110011")

100 
def
 
MRET
 = 
B™P©
("b00110000001000000000000001110011")

101 
def
 
DRET
 = 
B™P©
("b01111011001000000000000001110011")

102 
def
 
SFENCE_VMA
 = 
B™P©
("b0001001??????????000000001110011")

103 
def
 
WFI
 = 
B™P©
("b00010000010100000000000001110011")

104 
def
 
CSRRW
 = 
B™P©
("b?????????????????001?????1110011")

105 
def
 
CSRRS
 = 
B™P©
("b?????????????????010?????1110011")

106 
def
 
CSRRC
 = 
B™P©
("b?????????????????011?????1110011")

107 
def
 
CSRRWI
 = 
B™P©
("b?????????????????101?????1110011")

108 
def
 
CSRRSI
 = 
B™P©
("b?????????????????110?????1110011")

109 
def
 
CSRRCI
 = 
B™P©
("b?????????????????111?????1110011")

110 
def
 
FADD_S
 = 
B™P©
("b0000000??????????????????1010011")

111 
def
 
FSUB_S
 = 
B™P©
("b0000100??????????????????1010011")

112 
def
 
FMUL_S
 = 
B™P©
("b0001000??????????????????1010011")

113 
def
 
FDIV_S
 = 
B™P©
("b0001100??????????????????1010011")

114 
def
 
FSGNJ_S
 = 
B™P©
("b0010000??????????000?????1010011")

115 
def
 
FSGNJN_S
 = 
B™P©
("b0010000??????????001?????1010011")

116 
def
 
FSGNJX_S
 = 
B™P©
("b0010000??????????010?????1010011")

117 
def
 
FMIN_S
 = 
B™P©
("b0010100??????????000?????1010011")

118 
def
 
FMAX_S
 = 
B™P©
("b0010100??????????001?????1010011")

119 
def
 
FSQRT_S
 = 
B™P©
("b010110000000?????????????1010011")

120 
def
 
FADD_D
 = 
B™P©
("b0000001??????????????????1010011")

121 
def
 
FSUB_D
 = 
B™P©
("b0000101??????????????????1010011")

122 
def
 
FMUL_D
 = 
B™P©
("b0001001??????????????????1010011")

123 
def
 
FDIV_D
 = 
B™P©
("b0001101??????????????????1010011")

124 
def
 
FSGNJ_D
 = 
B™P©
("b0010001??????????000?????1010011")

125 
def
 
FSGNJN_D
 = 
B™P©
("b0010001??????????001?????1010011")

126 
def
 
FSGNJX_D
 = 
B™P©
("b0010001??????????010?????1010011")

127 
def
 
FMIN_D
 = 
B™P©
("b0010101??????????000?????1010011")

128 
def
 
FMAX_D
 = 
B™P©
("b0010101??????????001?????1010011")

129 
def
 
FCVT_S_D
 = 
B™P©
("b010000000001?????????????1010011")

130 
def
 
FCVT_D_S
 = 
B™P©
("b010000100000?????????????1010011")

131 
def
 
FSQRT_D
 = 
B™P©
("b010110100000?????????????1010011")

132 
def
 
FADD_Q
 = 
B™P©
("b0000011??????????????????1010011")

133 
def
 
FSUB_Q
 = 
B™P©
("b0000111??????????????????1010011")

134 
def
 
FMUL_Q
 = 
B™P©
("b0001011??????????????????1010011")

135 
def
 
FDIV_Q
 = 
B™P©
("b0001111??????????????????1010011")

136 
def
 
FSGNJ_Q
 = 
B™P©
("b0010011??????????000?????1010011")

137 
def
 
FSGNJN_Q
 = 
B™P©
("b0010011??????????001?????1010011")

138 
def
 
FSGNJX_Q
 = 
B™P©
("b0010011??????????010?????1010011")

139 
def
 
FMIN_Q
 = 
B™P©
("b0010111??????????000?????1010011")

140 
def
 
FMAX_Q
 = 
B™P©
("b0010111??????????001?????1010011")

141 
def
 
FCVT_S_Q
 = 
B™P©
("b010000000011?????????????1010011")

142 
def
 
FCVT_Q_S
 = 
B™P©
("b010001100000?????????????1010011")

143 
def
 
FCVT_D_Q
 = 
B™P©
("b010000100011?????????????1010011")

144 
def
 
FCVT_Q_D
 = 
B™P©
("b010001100001?????????????1010011")

145 
def
 
FSQRT_Q
 = 
B™P©
("b010111100000?????????????1010011")

146 
def
 
FLE_S
 = 
B™P©
("b1010000??????????000?????1010011")

147 
def
 
FLT_S
 = 
B™P©
("b1010000??????????001?????1010011")

148 
def
 
FEQ_S
 = 
B™P©
("b1010000??????????010?????1010011")

149 
def
 
FLE_D
 = 
B™P©
("b1010001??????????000?????1010011")

150 
def
 
FLT_D
 = 
B™P©
("b1010001??????????001?????1010011")

151 
def
 
FEQ_D
 = 
B™P©
("b1010001??????????010?????1010011")

152 
def
 
FLE_Q
 = 
B™P©
("b1010011??????????000?????1010011")

153 
def
 
FLT_Q
 = 
B™P©
("b1010011??????????001?????1010011")

154 
def
 
FEQ_Q
 = 
B™P©
("b1010011??????????010?????1010011")

155 
def
 
FCVT_W_S
 = 
B™P©
("b110000000000?????????????1010011")

156 
def
 
FCVT_WU_S
 = 
B™P©
("b110000000001?????????????1010011")

157 
def
 
FCVT_L_S
 = 
B™P©
("b110000000010?????????????1010011")

158 
def
 
FCVT_LU_S
 = 
B™P©
("b110000000011?????????????1010011")

159 
def
 
FMV_X_W
 = 
B™P©
("b111000000000?????000?????1010011")

160 
def
 
FCLASS_S
 = 
B™P©
("b111000000000?????001?????1010011")

161 
def
 
FCVT_W_D
 = 
B™P©
("b110000100000?????????????1010011")

162 
def
 
FCVT_WU_D
 = 
B™P©
("b110000100001?????????????1010011")

163 
def
 
FCVT_L_D
 = 
B™P©
("b110000100010?????????????1010011")

164 
def
 
FCVT_LU_D
 = 
B™P©
("b110000100011?????????????1010011")

165 
def
 
FMV_X_D
 = 
B™P©
("b111000100000?????000?????1010011")

166 
def
 
FCLASS_D
 = 
B™P©
("b111000100000?????001?????1010011")

167 
def
 
FCVT_W_Q
 = 
B™P©
("b110001100000?????????????1010011")

168 
def
 
FCVT_WU_Q
 = 
B™P©
("b110001100001?????????????1010011")

169 
def
 
FCVT_L_Q
 = 
B™P©
("b110001100010?????????????1010011")

170 
def
 
FCVT_LU_Q
 = 
B™P©
("b110001100011?????????????1010011")

171 
def
 
FMV_X_Q
 = 
B™P©
("b111001100000?????000?????1010011")

172 
def
 
FCLASS_Q
 = 
B™P©
("b111001100000?????001?????1010011")

173 
def
 
FCVT_S_W
 = 
B™P©
("b110100000000?????????????1010011")

174 
def
 
FCVT_S_WU
 = 
B™P©
("b110100000001?????????????1010011")

175 
def
 
FCVT_S_L
 = 
B™P©
("b110100000010?????????????1010011")

176 
def
 
FCVT_S_LU
 = 
B™P©
("b110100000011?????????????1010011")

177 
def
 
FMV_W_X
 = 
B™P©
("b111100000000?????000?????1010011")

178 
def
 
FCVT_D_W
 = 
B™P©
("b110100100000?????????????1010011")

179 
def
 
FCVT_D_WU
 = 
B™P©
("b110100100001?????????????1010011")

180 
def
 
FCVT_D_L
 = 
B™P©
("b110100100010?????????????1010011")

181 
def
 
FCVT_D_LU
 = 
B™P©
("b110100100011?????????????1010011")

182 
def
 
FMV_D_X
 = 
B™P©
("b111100100000?????000?????1010011")

183 
def
 
FCVT_Q_W
 = 
B™P©
("b110101100000?????????????1010011")

184 
def
 
FCVT_Q_WU
 = 
B™P©
("b110101100001?????????????1010011")

185 
def
 
FCVT_Q_L
 = 
B™P©
("b110101100010?????????????1010011")

186 
def
 
FCVT_Q_LU
 = 
B™P©
("b110101100011?????????????1010011")

187 
def
 
FMV_Q_X
 = 
B™P©
("b111101100000?????000?????1010011")

188 
def
 
FLW
 = 
B™P©
("b?????????????????010?????0000111")

189 
def
 
FLD
 = 
B™P©
("b?????????????????011?????0000111")

190 
def
 
FLQ
 = 
B™P©
("b?????????????????100?????0000111")

191 
def
 
FSW
 = 
B™P©
("b?????????????????010?????0100111")

192 
def
 
FSD
 = 
B™P©
("b?????????????????011?????0100111")

193 
def
 
FSQ
 = 
B™P©
("b?????????????????100?????0100111")

194 
def
 
FMADD_S
 = 
B™P©
("b?????00??????????????????1000011")

195 
def
 
FMSUB_S
 = 
B™P©
("b?????00??????????????????1000111")

196 
def
 
FNMSUB_S
 = 
B™P©
("b?????00??????????????????1001011")

197 
def
 
FNMADD_S
 = 
B™P©
("b?????00??????????????????1001111")

198 
def
 
FMADD_D
 = 
B™P©
("b?????01??????????????????1000011")

199 
def
 
FMSUB_D
 = 
B™P©
("b?????01??????????????????1000111")

200 
def
 
FNMSUB_D
 = 
B™P©
("b?????01??????????????????1001011")

201 
def
 
FNMADD_D
 = 
B™P©
("b?????01??????????????????1001111")

202 
def
 
FMADD_Q
 = 
B™P©
("b?????11??????????????????1000011")

203 
def
 
FMSUB_Q
 = 
B™P©
("b?????11??????????????????1000111")

204 
def
 
FNMSUB_Q
 = 
B™P©
("b?????11??????????????????1001011")

205 
def
 
FNMADD_Q
 = 
B™P©
("b?????11??????????????????1001111")

206 
def
 
C_ADDI4SPN
 = 
B™P©
("b????????????????000???????????00")

207 
def
 
C_FLD
 = 
B™P©
("b????????????????001???????????00")

208 
def
 
C_LW
 = 
B™P©
("b????????????????010???????????00")

209 
def
 
C_FLW
 = 
B™P©
("b????????????????011???????????00")

210 
def
 
C_FSD
 = 
B™P©
("b????????????????101???????????00")

211 
def
 
C_SW
 = 
B™P©
("b????????????????110???????????00")

212 
def
 
C_FSW
 = 
B™P©
("b????????????????111???????????00")

213 
def
 
C_ADDI
 = 
B™P©
("b????????????????000???????????01")

214 
def
 
C_JAL
 = 
B™P©
("b????????????????001???????????01")

215 
def
 
C_LI
 = 
B™P©
("b????????????????010???????????01")

216 
def
 
C_LUI
 = 
B™P©
("b????????????????011???????????01")

217 
def
 
C_SRLI
 = 
B™P©
("b????????????????100?00????????01")

218 
def
 
C_SRAI
 = 
B™P©
("b????????????????100?01????????01")

219 
def
 
C_ANDI
 = 
B™P©
("b????????????????100?10????????01")

220 
def
 
C_SUB
 = 
B™P©
("b????????????????100011???00???01")

221 
def
 
C_XOR
 = 
B™P©
("b????????????????100011???01???01")

222 
def
 
C_OR
 = 
B™P©
("b????????????????100011???10???01")

223 
def
 
C_AND
 = 
B™P©
("b????????????????100011???11???01")

224 
def
 
C_SUBW
 = 
B™P©
("b????????????????100111???00???01")

225 
def
 
C_ADDW
 = 
B™P©
("b????????????????100111???01???01")

226 
def
 
C_J
 = 
B™P©
("b????????????????101???????????01")

227 
def
 
C_BEQZ
 = 
B™P©
("b????????????????110???????????01")

228 
def
 
C_BNEZ
 = 
B™P©
("b????????????????111???????????01")

229 
def
 
C_SLLI
 = 
B™P©
("b????????????????000???????????10")

230 
def
 
C_FLDSP
 = 
B™P©
("b????????????????001???????????10")

231 
def
 
C_LWSP
 = 
B™P©
("b????????????????010???????????10")

232 
def
 
C_FLWSP
 = 
B™P©
("b????????????????011???????????10")

233 
def
 
C_MV
 = 
B™P©
("b????????????????1000??????????10")

234 
def
 
C_ADD
 = 
B™P©
("b????????????????1001??????????10")

235 
def
 
C_FSDSP
 = 
B™P©
("b????????????????101???????????10")

236 
def
 
C_SWSP
 = 
B™P©
("b????????????????110???????????10")

237 
def
 
C_FSWSP
 = 
B™P©
("b????????????????111???????????10")

238 
def
 
C_NOP
 = 
B™P©
("b????????????????0000000000000001")

239 
def
 
C_ADDI16SP
 = 
B™P©
("b????????????????011?00010?????01")

240 
def
 
C_JR
 = 
B™P©
("b????????????????1000?????0000010")

241 
def
 
C_JALR
 = 
B™P©
("b????????????????1001?????0000010")

242 
def
 
C_EBREAK
 = 
B™P©
("b????????????????1001000000000010")

243 
def
 
C_LD
 = 
B™P©
("b????????????????011???????????00")

244 
def
 
C_SD
 = 
B™P©
("b????????????????111???????????00")

245 
def
 
C_ADDIW
 = 
B™P©
("b????????????????001???????????01")

246 
def
 
C_LDSP
 = 
B™P©
("b????????????????011???????????10")

247 
def
 
C_SDSP
 = 
B™P©
("b????????????????111???????????10")

248 
def
 
C_SLLI_RV32
 = 
B™P©
("b????????????????0000??????????10")

249 
def
 
C_SRLI_RV32
 = 
B™P©
("b????????????????100000????????01")

250 
def
 
C_SRAI_RV32
 = 
B™P©
("b????????????????100001????????01")

251 
def
 
CUSTOM0
 = 
B™P©
("b?????????????????000?????0001011")

252 
def
 
CUSTOM0_RS1
 = 
B™P©
("b?????????????????010?????0001011")

253 
def
 
CUSTOM0_RS1_RS2
 = 
B™P©
("b?????????????????011?????0001011")

254 
def
 
CUSTOM0_RD
 = 
B™P©
("b?????????????????100?????0001011")

255 
def
 
CUSTOM0_RD_RS1
 = 
B™P©
("b?????????????????110?????0001011")

256 
def
 
CUSTOM0_RD_RS1_RS2
 = 
B™P©
("b?????????????????111?????0001011")

257 
def
 
CUSTOM1
 = 
B™P©
("b?????????????????000?????0101011")

258 
def
 
CUSTOM1_RS1
 = 
B™P©
("b?????????????????010?????0101011")

259 
def
 
CUSTOM1_RS1_RS2
 = 
B™P©
("b?????????????????011?????0101011")

260 
def
 
CUSTOM1_RD
 = 
B™P©
("b?????????????????100?????0101011")

261 
def
 
CUSTOM1_RD_RS1
 = 
B™P©
("b?????????????????110?????0101011")

262 
def
 
CUSTOM1_RD_RS1_RS2
 = 
B™P©
("b?????????????????111?????0101011")

263 
def
 
CUSTOM2
 = 
B™P©
("b?????????????????000?????1011011")

264 
def
 
CUSTOM2_RS1
 = 
B™P©
("b?????????????????010?????1011011")

265 
def
 
CUSTOM2_RS1_RS2
 = 
B™P©
("b?????????????????011?????1011011")

266 
def
 
CUSTOM2_RD
 = 
B™P©
("b?????????????????100?????1011011")

267 
def
 
CUSTOM2_RD_RS1
 = 
B™P©
("b?????????????????110?????1011011")

268 
def
 
CUSTOM2_RD_RS1_RS2
 = 
B™P©
("b?????????????????111?????1011011")

269 
def
 
CUSTOM3
 = 
B™P©
("b?????????????????000?????1111011")

270 
def
 
CUSTOM3_RS1
 = 
B™P©
("b?????????????????010?????1111011")

271 
def
 
CUSTOM3_RS1_RS2
 = 
B™P©
("b?????????????????011?????1111011")

272 
def
 
CUSTOM3_RD
 = 
B™P©
("b?????????????????100?????1111011")

273 
def
 
CUSTOM3_RD_RS1
 = 
B™P©
("b?????????????????110?????1111011")

274 
def
 
CUSTOM3_RD_RS1_RS2
 = 
B™P©
("b?????????????????111?????1111011")

275 
def
 
SLLI_RV32
 = 
B™P©
("b0000000??????????001?????0010011")

276 
def
 
SRLI_RV32
 = 
B™P©
("b0000000??????????101?????0010011")

277 
def
 
SRAI_RV32
 = 
B™P©
("b0100000??????????101?????0010011")

278 
def
 
FRFLAGS
 = 
B™P©
("b00000000000100000010?????1110011")

279 
def
 
FSFLAGS
 = 
B™P©
("b000000000001?????001?????1110011")

280 
def
 
FSFLAGSI
 = 
B™P©
("b000000000001?????101?????1110011")

281 
def
 
FRRM
 = 
B™P©
("b00000000001000000010?????1110011")

282 
def
 
FSRM
 = 
B™P©
("b000000000010?????001?????1110011")

283 
def
 
FSRMI
 = 
B™P©
("b000000000010?????101?????1110011")

284 
def
 
FSCSR
 = 
B™P©
("b000000000011?????001?????1110011")

285 
def
 
FRCSR
 = 
B™P©
("b00000000001100000010?????1110011")

286 
def
 
RDCYCLE
 = 
B™P©
("b11000000000000000010?????1110011")

287 
def
 
RDTIME
 = 
B™P©
("b11000000000100000010?????1110011")

288 
def
 
RDINSTRET
 = 
B™P©
("b11000000001000000010?????1110011")

289 
def
 
RDCYCLEH
 = 
B™P©
("b11001000000000000010?????1110011")

290 
def
 
RDTIMEH
 = 
B™P©
("b11001000000100000010?????1110011")

291 
def
 
RDINSTRETH
 = 
B™P©
("b11001000001000000010?????1110011")

292 
def
 
SCALL
 = 
B™P©
("b00000000000000000000000001110011")

293 
def
 
SBREAK
 = 
B™P©
("b00000000000100000000000001110011")

294 
def
 
FMV_X_S
 = 
B™P©
("b111000000000?????000?????1010011")

295 
def
 
FMV_S_X
 = 
B™P©
("b111100000000?????000?????1010011")

296 
def
 
FENCE_TSO
 = 
B™P©
("b100000110011?????000?????0001111")

298 
objeù
 
	gCau£s
 {

299 
v®
 
	gmi§ligÃd_ãtch
 = 0x0

300 
v®
 
ãtch_acûss
 = 0x1

301 
v®
 
Ëg®_š¡ruùiÚ
 = 0x2

302 
v®
 
b»akpošt
 = 0x3

303 
v®
 
mi§ligÃd_lßd
 = 0x4

304 
v®
 
lßd_acûss
 = 0x5

305 
v®
 
mi§ligÃd_¡Üe
 = 0x6

306 
v®
 
¡Üe_acûss
 = 0x7

307 
v®
 
u£r_eÿÎ
 = 0x8

308 
v®
 
su³rvisÜ_eÿÎ
 = 0x9

309 
v®
 
hy³rvisÜ_eÿÎ
 = 0xa

310 
v®
 
machše_eÿÎ
 = 0xb

311 
v®
 
ãtch_·ge_çuÉ
 = 0xc

312 
v®
 
lßd_·ge_çuÉ
 = 0xd

313 
v®
 
¡Üe_·ge_çuÉ
 = 0xf

314 
v®
 
®l
 = {

315 
v®
 
»s
 = 
cŞËùiÚ
.
mubË
.
A¼ayBufãr
[
IÁ
]()

316 
»s
 +ğ
mi§ligÃd_ãtch


317 
»s
 +ğ
ãtch_acûss


318 
»s
 +ğ
Ëg®_š¡ruùiÚ


319 
»s
 +ğ
b»akpošt


320 
»s
 +ğ
mi§ligÃd_lßd


321 
»s
 +ğ
lßd_acûss


322 
»s
 +ğ
mi§ligÃd_¡Üe


323 
»s
 +ğ
¡Üe_acûss


324 
»s
 +ğ
u£r_eÿÎ


325 
»s
 +ğ
su³rvisÜ_eÿÎ


326 
»s
 +ğ
hy³rvisÜ_eÿÎ


327 
»s
 +ğ
machše_eÿÎ


328 
»s
 +ğ
ãtch_·ge_çuÉ


329 
»s
 +ğ
lßd_·ge_çuÉ


330 
»s
 +ğ
¡Üe_·ge_çuÉ


331 
»s
.
toA¼ay


334 
objeù
 
	gCSRs
 {

335 
v®
 
	gfæags
 = 0x1

336 
v®
 
äm
 = 0x2

337 
v®
 
fc¤
 = 0x3

338 
v®
 
cyşe
 = 0xc00

339 
v®
 
time
 = 0xc01

340 
v®
 
š¡»t
 = 0xc02

341 
v®
 
hpmcouÁ”3
 = 0xc03

342 
v®
 
hpmcouÁ”4
 = 0xc04

343 
v®
 
hpmcouÁ”5
 = 0xc05

344 
v®
 
hpmcouÁ”6
 = 0xc06

345 
v®
 
hpmcouÁ”7
 = 0xc07

346 
v®
 
hpmcouÁ”8
 = 0xc08

347 
v®
 
hpmcouÁ”9
 = 0xc09

348 
v®
 
hpmcouÁ”10
 = 0xc0a

349 
v®
 
hpmcouÁ”11
 = 0xc0b

350 
v®
 
hpmcouÁ”12
 = 0xc0c

351 
v®
 
hpmcouÁ”13
 = 0xc0d

352 
v®
 
hpmcouÁ”14
 = 0xc0e

353 
v®
 
hpmcouÁ”15
 = 0xc0f

354 
v®
 
hpmcouÁ”16
 = 0xc10

355 
v®
 
hpmcouÁ”17
 = 0xc11

356 
v®
 
hpmcouÁ”18
 = 0xc12

357 
v®
 
hpmcouÁ”19
 = 0xc13

358 
v®
 
hpmcouÁ”20
 = 0xc14

359 
v®
 
hpmcouÁ”21
 = 0xc15

360 
v®
 
hpmcouÁ”22
 = 0xc16

361 
v®
 
hpmcouÁ”23
 = 0xc17

362 
v®
 
hpmcouÁ”24
 = 0xc18

363 
v®
 
hpmcouÁ”25
 = 0xc19

364 
v®
 
hpmcouÁ”26
 = 0xc1a

365 
v®
 
hpmcouÁ”27
 = 0xc1b

366 
v®
 
hpmcouÁ”28
 = 0xc1c

367 
v®
 
hpmcouÁ”29
 = 0xc1d

368 
v®
 
hpmcouÁ”30
 = 0xc1e

369 
v®
 
hpmcouÁ”31
 = 0xc1f

370 
v®
 
s¡©us
 = 0x100

371 
v®
 
s›
 = 0x104

372 
v®
 
¡vec
 = 0x105

373 
v®
 
scouÁ”’
 = 0x106

374 
v®
 
ssü©ch
 = 0x140

375 
v®
 
£pc
 = 0x141

376 
v®
 
sÿu£
 = 0x142

377 
v®
 
sbadaddr
 = 0x143

378 
v®
 
s
 = 0x144

379 
v®
 
¥tbr
 = 0x180

380 
v®
 
¥cod”ªge0
 = 0x190

381 
v®
 
¥cod”ªge1
 = 0x191

382 
v®
 
¥cod”ªge2
 = 0x192

383 
v®
 
¥cod”ªge3
 = 0x193

387 
v®
 
m¡©us
 = 0x300

388 
v®
 
mi§
 = 0x301

389 
v®
 
med–eg
 = 0x302

390 
v®
 
mid–eg
 = 0x303

391 
v®
 
m›
 = 0x304

392 
v®
 
mtvec
 = 0x305

393 
v®
 
mcouÁ”’
 = 0x306

394 
v®
 
msü©ch
 = 0x340

395 
v®
 
m•c
 = 0x341

396 
v®
 
mÿu£
 = 0x342

397 
v®
 
mbadaddr
 = 0x343

398 
v®
 
m
 = 0x344

399 
v®
 
pmpcfg0
 = 0x3a0

400 
v®
 
pmpcfg1
 = 0x3a1

401 
v®
 
pmpcfg2
 = 0x3a2

402 
v®
 
pmpcfg3
 = 0x3a3

403 
v®
 
pm·ddr0
 = 0x3b0

404 
v®
 
pm·ddr1
 = 0x3b1

405 
v®
 
pm·ddr2
 = 0x3b2

406 
v®
 
pm·ddr3
 = 0x3b3

407 
v®
 
pm·ddr4
 = 0x3b4

408 
v®
 
pm·ddr5
 = 0x3b5

409 
v®
 
pm·ddr6
 = 0x3b6

410 
v®
 
pm·ddr7
 = 0x3b7

411 
v®
 
pm·ddr8
 = 0x3b8

412 
v®
 
pm·ddr9
 = 0x3b9

413 
v®
 
pm·ddr10
 = 0x3ba

414 
v®
 
pm·ddr11
 = 0x3bb

415 
v®
 
pm·ddr12
 = 0x3bc

416 
v®
 
pm·ddr13
 = 0x3bd

417 
v®
 
pm·ddr14
 = 0x3be

418 
v®
 
pm·ddr15
 = 0x3bf

419 
v®
 
t£Ëù
 = 0x7a0

420 
v®
 
td©a1
 = 0x7a1

421 
v®
 
td©a2
 = 0x7a2

422 
v®
 
td©a3
 = 0x7a3

423 
v®
 
dc¤
 = 0x7b0

424 
v®
 
dpc
 = 0x7b1

425 
v®
 
dsü©ch
 = 0x7b2

426 
v®
 
mcyşe
 = 0xb00

427 
v®
 
mš¡»t
 = 0xb02

428 
v®
 
mhpmcouÁ”3
 = 0xb03

429 
v®
 
mhpmcouÁ”4
 = 0xb04

430 
v®
 
mhpmcouÁ”5
 = 0xb05

431 
v®
 
mhpmcouÁ”6
 = 0xb06

432 
v®
 
mhpmcouÁ”7
 = 0xb07

433 
v®
 
mhpmcouÁ”8
 = 0xb08

434 
v®
 
mhpmcouÁ”9
 = 0xb09

435 
v®
 
mhpmcouÁ”10
 = 0xb0a

436 
v®
 
mhpmcouÁ”11
 = 0xb0b

437 
v®
 
mhpmcouÁ”12
 = 0xb0c

438 
v®
 
mhpmcouÁ”13
 = 0xb0d

439 
v®
 
mhpmcouÁ”14
 = 0xb0e

440 
v®
 
mhpmcouÁ”15
 = 0xb0f

441 
v®
 
mhpmcouÁ”16
 = 0xb10

442 
v®
 
mhpmcouÁ”17
 = 0xb11

443 
v®
 
mhpmcouÁ”18
 = 0xb12

444 
v®
 
mhpmcouÁ”19
 = 0xb13

445 
v®
 
mhpmcouÁ”20
 = 0xb14

446 
v®
 
mhpmcouÁ”21
 = 0xb15

447 
v®
 
mhpmcouÁ”22
 = 0xb16

448 
v®
 
mhpmcouÁ”23
 = 0xb17

449 
v®
 
mhpmcouÁ”24
 = 0xb18

450 
v®
 
mhpmcouÁ”25
 = 0xb19

451 
v®
 
mhpmcouÁ”26
 = 0xb1a

452 
v®
 
mhpmcouÁ”27
 = 0xb1b

453 
v®
 
mhpmcouÁ”28
 = 0xb1c

454 
v®
 
mhpmcouÁ”29
 = 0xb1d

455 
v®
 
mhpmcouÁ”30
 = 0xb1e

456 
v®
 
mhpmcouÁ”31
 = 0xb1f

457 
v®
 
mhpmev’t3
 = 0x323

458 
v®
 
mhpmev’t4
 = 0x324

459 
v®
 
mhpmev’t5
 = 0x325

460 
v®
 
mhpmev’t6
 = 0x326

461 
v®
 
mhpmev’t7
 = 0x327

462 
v®
 
mhpmev’t8
 = 0x328

463 
v®
 
mhpmev’t9
 = 0x329

464 
v®
 
mhpmev’t10
 = 0x32a

465 
v®
 
mhpmev’t11
 = 0x32b

466 
v®
 
mhpmev’t12
 = 0x32c

467 
v®
 
mhpmev’t13
 = 0x32d

468 
v®
 
mhpmev’t14
 = 0x32e

469 
v®
 
mhpmev’t15
 = 0x32f

470 
v®
 
mhpmev’t16
 = 0x330

471 
v®
 
mhpmev’t17
 = 0x331

472 
v®
 
mhpmev’t18
 = 0x332

473 
v®
 
mhpmev’t19
 = 0x333

474 
v®
 
mhpmev’t20
 = 0x334

475 
v®
 
mhpmev’t21
 = 0x335

476 
v®
 
mhpmev’t22
 = 0x336

477 
v®
 
mhpmev’t23
 = 0x337

478 
v®
 
mhpmev’t24
 = 0x338

479 
v®
 
mhpmev’t25
 = 0x339

480 
v®
 
mhpmev’t26
 = 0x33a

481 
v®
 
mhpmev’t27
 = 0x33b

482 
v®
 
mhpmev’t28
 = 0x33c

483 
v®
 
mhpmev’t29
 = 0x33d

484 
v®
 
mhpmev’t30
 = 0x33e

485 
v®
 
mhpmev’t31
 = 0x33f

486 
v®
 
mv’dÜid
 = 0xf11

487 
v®
 
m¬chid
 = 0xf12

488 
v®
 
mimpid
 = 0xf13

489 
v®
 
mh¬tid
 = 0xf14

490 
v®
 
cyşeh
 = 0xc80

491 
v®
 
timeh
 = 0xc81

492 
v®
 
š¡»th
 = 0xc82

493 
v®
 
hpmcouÁ”3h
 = 0xc83

494 
v®
 
hpmcouÁ”4h
 = 0xc84

495 
v®
 
hpmcouÁ”5h
 = 0xc85

496 
v®
 
hpmcouÁ”6h
 = 0xc86

497 
v®
 
hpmcouÁ”7h
 = 0xc87

498 
v®
 
hpmcouÁ”8h
 = 0xc88

499 
v®
 
hpmcouÁ”9h
 = 0xc89

500 
v®
 
hpmcouÁ”10h
 = 0xc8a

501 
v®
 
hpmcouÁ”11h
 = 0xc8b

502 
v®
 
hpmcouÁ”12h
 = 0xc8c

503 
v®
 
hpmcouÁ”13h
 = 0xc8d

504 
v®
 
hpmcouÁ”14h
 = 0xc8e

505 
v®
 
hpmcouÁ”15h
 = 0xc8f

506 
v®
 
hpmcouÁ”16h
 = 0xc90

507 
v®
 
hpmcouÁ”17h
 = 0xc91

508 
v®
 
hpmcouÁ”18h
 = 0xc92

509 
v®
 
hpmcouÁ”19h
 = 0xc93

510 
v®
 
hpmcouÁ”20h
 = 0xc94

511 
v®
 
hpmcouÁ”21h
 = 0xc95

512 
v®
 
hpmcouÁ”22h
 = 0xc96

513 
v®
 
hpmcouÁ”23h
 = 0xc97

514 
v®
 
hpmcouÁ”24h
 = 0xc98

515 
v®
 
hpmcouÁ”25h
 = 0xc99

516 
v®
 
hpmcouÁ”26h
 = 0xc9a

517 
v®
 
hpmcouÁ”27h
 = 0xc9b

518 
v®
 
hpmcouÁ”28h
 = 0xc9c

519 
v®
 
hpmcouÁ”29h
 = 0xc9d

520 
v®
 
hpmcouÁ”30h
 = 0xc9e

521 
v®
 
hpmcouÁ”31h
 = 0xc9f

522 
v®
 
mcyşeh
 = 0xb80

523 
v®
 
mš¡»th
 = 0xb82

524 
v®
 
mhpmcouÁ”3h
 = 0xb83

525 
v®
 
mhpmcouÁ”4h
 = 0xb84

526 
v®
 
mhpmcouÁ”5h
 = 0xb85

527 
v®
 
mhpmcouÁ”6h
 = 0xb86

528 
v®
 
mhpmcouÁ”7h
 = 0xb87

529 
v®
 
mhpmcouÁ”8h
 = 0xb88

530 
v®
 
mhpmcouÁ”9h
 = 0xb89

531 
v®
 
mhpmcouÁ”10h
 = 0xb8a

532 
v®
 
mhpmcouÁ”11h
 = 0xb8b

533 
v®
 
mhpmcouÁ”12h
 = 0xb8c

534 
v®
 
mhpmcouÁ”13h
 = 0xb8d

535 
v®
 
mhpmcouÁ”14h
 = 0xb8e

536 
v®
 
mhpmcouÁ”15h
 = 0xb8f

537 
v®
 
mhpmcouÁ”16h
 = 0xb90

538 
v®
 
mhpmcouÁ”17h
 = 0xb91

539 
v®
 
mhpmcouÁ”18h
 = 0xb92

540 
v®
 
mhpmcouÁ”19h
 = 0xb93

541 
v®
 
mhpmcouÁ”20h
 = 0xb94

542 
v®
 
mhpmcouÁ”21h
 = 0xb95

543 
v®
 
mhpmcouÁ”22h
 = 0xb96

544 
v®
 
mhpmcouÁ”23h
 = 0xb97

545 
v®
 
mhpmcouÁ”24h
 = 0xb98

546 
v®
 
mhpmcouÁ”25h
 = 0xb99

547 
v®
 
mhpmcouÁ”26h
 = 0xb9a

548 
v®
 
mhpmcouÁ”27h
 = 0xb9b

549 
v®
 
mhpmcouÁ”28h
 = 0xb9c

550 
v®
 
mhpmcouÁ”29h
 = 0xb9d

551 
v®
 
mhpmcouÁ”30h
 = 0xb9e

552 
v®
 
mhpmcouÁ”31h
 = 0xb9f

553 
v®
 
®l
 = {

554 
v®
 
»s
 = 
cŞËùiÚ
.
mubË
.
A¼ayBufãr
[
IÁ
]()

555 
»s
 +ğ
fæags


556 
»s
 +ğ
äm


557 
»s
 +ğ
fc¤


558 
»s
 +ğ
cyşe


559 
»s
 +ğ
time


560 
»s
 +ğ
š¡»t


561 
»s
 +ğ
hpmcouÁ”3


562 
»s
 +ğ
hpmcouÁ”4


563 
»s
 +ğ
hpmcouÁ”5


564 
»s
 +ğ
hpmcouÁ”6


565 
»s
 +ğ
hpmcouÁ”7


566 
»s
 +ğ
hpmcouÁ”8


567 
»s
 +ğ
hpmcouÁ”9


568 
»s
 +ğ
hpmcouÁ”10


569 
»s
 +ğ
hpmcouÁ”11


570 
»s
 +ğ
hpmcouÁ”12


571 
»s
 +ğ
hpmcouÁ”13


572 
»s
 +ğ
hpmcouÁ”14


573 
»s
 +ğ
hpmcouÁ”15


574 
»s
 +ğ
hpmcouÁ”16


575 
»s
 +ğ
hpmcouÁ”17


576 
»s
 +ğ
hpmcouÁ”18


577 
»s
 +ğ
hpmcouÁ”19


578 
»s
 +ğ
hpmcouÁ”20


579 
»s
 +ğ
hpmcouÁ”21


580 
»s
 +ğ
hpmcouÁ”22


581 
»s
 +ğ
hpmcouÁ”23


582 
»s
 +ğ
hpmcouÁ”24


583 
»s
 +ğ
hpmcouÁ”25


584 
»s
 +ğ
hpmcouÁ”26


585 
»s
 +ğ
hpmcouÁ”27


586 
»s
 +ğ
hpmcouÁ”28


587 
»s
 +ğ
hpmcouÁ”29


588 
»s
 +ğ
hpmcouÁ”30


589 
»s
 +ğ
hpmcouÁ”31


590 
»s
 +ğ
s¡©us


591 
»s
 +ğ
s›


592 
»s
 +ğ
¡vec


593 
»s
 +ğ
scouÁ”’


594 
»s
 +ğ
ssü©ch


595 
»s
 +ğ
£pc


596 
»s
 +ğ
sÿu£


597 
»s
 +ğ
sbadaddr


598 
»s
 +ğ
s


599 
»s
 +ğ
¥tbr


600 
»s
 +ğ
¥cod”ªge0


601 
»s
 +ğ
¥cod”ªge1


602 
»s
 +ğ
¥cod”ªge2


603 
»s
 +ğ
¥cod”ªge3


604 
»s
 +ğ
m¡©us


605 
»s
 +ğ
mi§


606 
»s
 +ğ
med–eg


607 
»s
 +ğ
mid–eg


608 
»s
 +ğ
m›


609 
»s
 +ğ
mtvec


610 
»s
 +ğ
mcouÁ”’


611 
»s
 +ğ
msü©ch


612 
»s
 +ğ
m•c


613 
»s
 +ğ
mÿu£


614 
»s
 +ğ
mbadaddr


615 
»s
 +ğ
m


616 
»s
 +ğ
pmpcfg0


617 
»s
 +ğ
pmpcfg1


618 
»s
 +ğ
pmpcfg2


619 
»s
 +ğ
pmpcfg3


620 
»s
 +ğ
pm·ddr0


621 
»s
 +ğ
pm·ddr1


622 
»s
 +ğ
pm·ddr2


623 
»s
 +ğ
pm·ddr3


624 
»s
 +ğ
pm·ddr4


625 
»s
 +ğ
pm·ddr5


626 
»s
 +ğ
pm·ddr6


627 
»s
 +ğ
pm·ddr7


628 
»s
 +ğ
pm·ddr8


629 
»s
 +ğ
pm·ddr9


630 
»s
 +ğ
pm·ddr10


631 
»s
 +ğ
pm·ddr11


632 
»s
 +ğ
pm·ddr12


633 
»s
 +ğ
pm·ddr13


634 
»s
 +ğ
pm·ddr14


635 
»s
 +ğ
pm·ddr15


636 
»s
 +ğ
t£Ëù


637 
»s
 +ğ
td©a1


638 
»s
 +ğ
td©a2


639 
»s
 +ğ
td©a3


640 
»s
 +ğ
dc¤


641 
»s
 +ğ
dpc


642 
»s
 +ğ
dsü©ch


643 
»s
 +ğ
mcyşe


644 
»s
 +ğ
mš¡»t


645 
»s
 +ğ
mhpmcouÁ”3


646 
»s
 +ğ
mhpmcouÁ”4


647 
»s
 +ğ
mhpmcouÁ”5


648 
»s
 +ğ
mhpmcouÁ”6


649 
»s
 +ğ
mhpmcouÁ”7


650 
»s
 +ğ
mhpmcouÁ”8


651 
»s
 +ğ
mhpmcouÁ”9


652 
»s
 +ğ
mhpmcouÁ”10


653 
»s
 +ğ
mhpmcouÁ”11


654 
»s
 +ğ
mhpmcouÁ”12


655 
»s
 +ğ
mhpmcouÁ”13


656 
»s
 +ğ
mhpmcouÁ”14


657 
»s
 +ğ
mhpmcouÁ”15


658 
»s
 +ğ
mhpmcouÁ”16


659 
»s
 +ğ
mhpmcouÁ”17


660 
»s
 +ğ
mhpmcouÁ”18


661 
»s
 +ğ
mhpmcouÁ”19


662 
»s
 +ğ
mhpmcouÁ”20


663 
»s
 +ğ
mhpmcouÁ”21


664 
»s
 +ğ
mhpmcouÁ”22


665 
»s
 +ğ
mhpmcouÁ”23


666 
»s
 +ğ
mhpmcouÁ”24


667 
»s
 +ğ
mhpmcouÁ”25


668 
»s
 +ğ
mhpmcouÁ”26


669 
»s
 +ğ
mhpmcouÁ”27


670 
»s
 +ğ
mhpmcouÁ”28


671 
»s
 +ğ
mhpmcouÁ”29


672 
»s
 +ğ
mhpmcouÁ”30


673 
»s
 +ğ
mhpmcouÁ”31


674 
»s
 +ğ
mhpmev’t3


675 
»s
 +ğ
mhpmev’t4


676 
»s
 +ğ
mhpmev’t5


677 
»s
 +ğ
mhpmev’t6


678 
»s
 +ğ
mhpmev’t7


679 
»s
 +ğ
mhpmev’t8


680 
»s
 +ğ
mhpmev’t9


681 
»s
 +ğ
mhpmev’t10


682 
»s
 +ğ
mhpmev’t11


683 
»s
 +ğ
mhpmev’t12


684 
»s
 +ğ
mhpmev’t13


685 
»s
 +ğ
mhpmev’t14


686 
»s
 +ğ
mhpmev’t15


687 
»s
 +ğ
mhpmev’t16


688 
»s
 +ğ
mhpmev’t17


689 
»s
 +ğ
mhpmev’t18


690 
»s
 +ğ
mhpmev’t19


691 
»s
 +ğ
mhpmev’t20


692 
»s
 +ğ
mhpmev’t21


693 
»s
 +ğ
mhpmev’t22


694 
»s
 +ğ
mhpmev’t23


695 
»s
 +ğ
mhpmev’t24


696 
»s
 +ğ
mhpmev’t25


697 
»s
 +ğ
mhpmev’t26


698 
»s
 +ğ
mhpmev’t27


699 
»s
 +ğ
mhpmev’t28


700 
»s
 +ğ
mhpmev’t29


701 
»s
 +ğ
mhpmev’t30


702 
»s
 +ğ
mhpmev’t31


703 
»s
 +ğ
mv’dÜid


704 
»s
 +ğ
m¬chid


705 
»s
 +ğ
mimpid


706 
»s
 +ğ
mh¬tid


707 
»s
.
toA¼ay


709 
v®
 
	g®l32
 = {

710 
v®
 
»s
 = 
cŞËùiÚ
.
mubË
.
A¼ayBufãr
(
®l
:
_
*)

711 
»s
 +ğ
cyşeh


712 
»s
 +ğ
timeh


713 
»s
 +ğ
š¡»th


714 
»s
 +ğ
hpmcouÁ”3h


715 
»s
 +ğ
hpmcouÁ”4h


716 
»s
 +ğ
hpmcouÁ”5h


717 
»s
 +ğ
hpmcouÁ”6h


718 
»s
 +ğ
hpmcouÁ”7h


719 
»s
 +ğ
hpmcouÁ”8h


720 
»s
 +ğ
hpmcouÁ”9h


721 
»s
 +ğ
hpmcouÁ”10h


722 
»s
 +ğ
hpmcouÁ”11h


723 
»s
 +ğ
hpmcouÁ”12h


724 
»s
 +ğ
hpmcouÁ”13h


725 
»s
 +ğ
hpmcouÁ”14h


726 
»s
 +ğ
hpmcouÁ”15h


727 
»s
 +ğ
hpmcouÁ”16h


728 
»s
 +ğ
hpmcouÁ”17h


729 
»s
 +ğ
hpmcouÁ”18h


730 
»s
 +ğ
hpmcouÁ”19h


731 
»s
 +ğ
hpmcouÁ”20h


732 
»s
 +ğ
hpmcouÁ”21h


733 
»s
 +ğ
hpmcouÁ”22h


734 
»s
 +ğ
hpmcouÁ”23h


735 
»s
 +ğ
hpmcouÁ”24h


736 
»s
 +ğ
hpmcouÁ”25h


737 
»s
 +ğ
hpmcouÁ”26h


738 
»s
 +ğ
hpmcouÁ”27h


739 
»s
 +ğ
hpmcouÁ”28h


740 
»s
 +ğ
hpmcouÁ”29h


741 
»s
 +ğ
hpmcouÁ”30h


742 
»s
 +ğ
hpmcouÁ”31h


743 
»s
 +ğ
mcyşeh


744 
»s
 +ğ
mš¡»th


745 
»s
 +ğ
mhpmcouÁ”3h


746 
»s
 +ğ
mhpmcouÁ”4h


747 
»s
 +ğ
mhpmcouÁ”5h


748 
»s
 +ğ
mhpmcouÁ”6h


749 
»s
 +ğ
mhpmcouÁ”7h


750 
»s
 +ğ
mhpmcouÁ”8h


751 
»s
 +ğ
mhpmcouÁ”9h


752 
»s
 +ğ
mhpmcouÁ”10h


753 
»s
 +ğ
mhpmcouÁ”11h


754 
»s
 +ğ
mhpmcouÁ”12h


755 
»s
 +ğ
mhpmcouÁ”13h


756 
»s
 +ğ
mhpmcouÁ”14h


757 
»s
 +ğ
mhpmcouÁ”15h


758 
»s
 +ğ
mhpmcouÁ”16h


759 
»s
 +ğ
mhpmcouÁ”17h


760 
»s
 +ğ
mhpmcouÁ”18h


761 
»s
 +ğ
mhpmcouÁ”19h


762 
»s
 +ğ
mhpmcouÁ”20h


763 
»s
 +ğ
mhpmcouÁ”21h


764 
»s
 +ğ
mhpmcouÁ”22h


765 
»s
 +ğ
mhpmcouÁ”23h


766 
»s
 +ğ
mhpmcouÁ”24h


767 
»s
 +ğ
mhpmcouÁ”25h


768 
»s
 +ğ
mhpmcouÁ”26h


769 
»s
 +ğ
mhpmcouÁ”27h


770 
»s
 +ğ
mhpmcouÁ”28h


771 
»s
 +ğ
mhpmcouÁ”29h


772 
»s
 +ğ
mhpmcouÁ”30h


773 
»s
 +ğ
mhpmcouÁ”31h


774 
»s
.
toA¼ay


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Multiplier.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gALU
.
_


11 
şass
 
	$MuÉl›rReq
(
d©aB™s
: 
IÁ
, 
gB™s
: IÁè
ex‹nds
 
BundË
 {

12 
v®
 
â
 = 
	`B™s
(
width
 = 
SZ_ALU_FN
)

13 
v®
 
dw
 = 
	`B™s
(
width
 = 
SZ_DW
)

14 
v®
 
š1
 = 
	`B™s
(
width
 = 
d©aB™s
)

15 
v®
 
š2
 = 
	`B™s
(
width
 = 
d©aB™s
)

16 
v®
 
g
 = 
	`UIÁ
(
width
 = 
gB™s
)

17 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`MuÉl›rReq
(
d©aB™s
, 
gB™s
).
asIn¡ªûOf
[
this
.
ty³
]

18 
	}
}

20 
şass
 
	$MuÉl›rRe¥
(
d©aB™s
: 
IÁ
, 
gB™s
: IÁè
ex‹nds
 
BundË
 {

21 
v®
 
d©a
 = 
	`B™s
(
width
 = 
d©aB™s
)

22 
v®
 
g
 = 
	`UIÁ
(
width
 = 
gB™s
)

23 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`MuÉl›rRe¥
(
d©aB™s
, 
gB™s
).
asIn¡ªûOf
[
this
.
ty³
]

24 
	}
}

26 
şass
 
	$MuÉl›rIO
(
d©aB™s
: 
IÁ
, 
gB™s
: IÁè
ex‹nds
 
BundË
 {

27 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
	`MuÉl›rReq
(
d©aB™s
, 
gB™s
)).
æ


28 
v®
 
kl
 = 
	`BoŞ
(
INPUT
)

29 
v®
 
»¥
 = 
	`Decou¶ed
(
Ãw
 
	`MuÉl›rRe¥
(
d©aB™s
, 
gB™s
))

30 
	}
}

32 
şass
 
	$MulDivP¬ams
(

33 
mulUÄŞl
: 
IÁ
 = 1,

34 
divUÄŞl
: 
IÁ
 = 1,

35 
mulE¬lyOut
: 
BoŞ—n
 = 
çl£
,

36 
divE¬lyOut
: 
BoŞ—n
 = 
çl£
,

37 
divE¬lyOutG¿nuÏr™y
: 
IÁ
 = 1

40 
şass
 
	$MulDiv
(
cfg
: 
MulDivP¬ams
, 
width
: 
IÁ
, 
nX´
: IÁ = 32è
ex‹nds
 
ModuË
 {

41 
´iv©e
 
def
 
mšDivL©’cy
 = (
cfg
.
divUÄŞl
 > 0).
	`İtiÚ
(ià(cfg.
divE¬lyOut
è3 1 + 
w
/cfg.divUnroll)

42 
´iv©e
 
def
 
mšMulL©’cy
 = (
cfg
.
mulUÄŞl
 > 0).
	`İtiÚ
(ià(cfg.
mulE¬lyOut
è2 
w
/cfg.mulUnroll)

43 
def
 
mšL©’cy
: 
IÁ
 = (
mšDivL©’cy
 ++ 
mšMulL©’cy
).
mš


45 
v®
 
io
 = 
Ãw
 
	`MuÉl›rIO
(
width
, 
	`log2Up
(
nX´
))

46 
v®
 
w
 = 
io
.
»q
.
b™s
.
š1
.
g‘Width


47 
v®
 
mulw
 = ià(
cfg
.
mulUÄŞl
 =ğ0è
w
 (w + cfg.mulUnroll - 1) / cfg.mulUnroll * cfg.mulUnroll

48 
v®
 
ç¡MulW
 = ià(
cfg
.
mulUÄŞl
 =ğ0è
çl£
 
w
/2 > cfg.mulUnroll && w % (2*cfg.mulUnroll) == 0

50 
v®
 
s_»ady
 :: 
s_Ãg_šputs
 :: 
s_mul
 :: 
s_div
 :: 
s_dummy
 :: 
s_Ãg_ouut
 :: 
s_dÚe_mul
 :: 
s_dÚe_div
 :: 
N
 = 
	`Enum
(
	`UIÁ
(), 8)

51 
v®
 
¡©e
 = 
	`Reg
(
š™
=
s_»ady
)

53 
v®
 
»q
 = 
	`Reg
(
io
.»q.
b™s
)

54 
v®
 
couÁ
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Ce
(

55 ((
cfg
.
divUÄŞl
 !ğ0).
	`İtiÚ
(
w
/cfg.divUÄŞÈ+ 1).
toSeq
 ++

56 (
cfg
.
mulUÄŞl
 !ğ0).
	`İtiÚ
(
mulw
/cfg.mulUÄŞl)).
	`»duû
(
_
 
max
 _))))

57 
v®
 
Ãg_out
 = 
	`Reg
(
	`BoŞ
())

58 
v®
 
isHi
 = 
	`Reg
(
	`BoŞ
())

59 
v®
 
»sHi
 = 
	`Reg
(
	`BoŞ
())

60 
v®
 
divisÜ
 = 
	`Reg
(
	`B™s
(
width
 = 
w
+1))

61 
v®
 
»mašd”
 = 
	`Reg
(
	`B™s
(
width
 = 2*
mulw
+2))

63 
v®
 
mulDecode
 = 
	`Li¡
(

64 
FN_MUL
 -> 
	`Li¡
(
Y
, 
N
, 
X
, X),

65 
FN_MULH
 -> 
	`Li¡
(
Y
, Y, Y, Y),

66 
FN_MULHU
 -> 
	`Li¡
(
Y
, Y, 
N
, N),

67 
FN_MULHSU
 -> 
	`Li¡
(
Y
, Y, Y, 
N
))

68 
v®
 
divDecode
 = 
	`Li¡
(

69 
FN_DIV
 -> 
	`Li¡
(
N
, N, 
Y
, Y),

70 
FN_REM
 -> 
	`Li¡
(
N
, 
Y
, Y, Y),

71 
FN_DIVU
 -> 
	`Li¡
(
N
, N, N, N),

72 
FN_REMU
 -> 
	`Li¡
(
N
, 
Y
, N, N))

73 
v®
 
cmdMul
 :: 
cmdHi
 :: 
lhsSigÃd
 :: 
rhsSigÃd
 :: 
N
 =

74 
	`DecodeLogic
(
io
.
»q
.
b™s
.
â
, 
	`Li¡
(
X
, X, X, X),

75 (ià(
cfg
.
divUÄŞl
 !ğ0è
divDecode
 
N
è++ (ià(cfg.
mulUÄŞl
 !ğ0è
mulDecode
 N)).
	`m­
(
_
.
toBoŞ
)

77 
	`»quœe
(
w
 == 32 || w == 64)

78 
def
 
	`h®fWidth
(
»q
: 
MuÉl›rReq
èğ
	`BoŞ
(
w
 > 32è&&„eq.
dw
 ==ğ
DW_32


80 
def
 
	`£xt
(
x
: 
B™s
, 
h®fW
: 
BoŞ
, signed: Bool) = {

81 
v®
 
sign
 = sigÃd && 
	`Mux
(
h®fW
, 
	`x
(
w
/2-1), x(w-1))

82 
v®
 
hi
 = 
	`Mux
(
h®fW
, 
	`Fl
(
w
/2, 
sign
), 
	`x
(w-1,w/2))

83 (
	`C©
(
hi
, 
	`x
(
w
/2-1,0)), 
sign
)

85 
	`v®
 (
lhs_š
, 
lhs_sign
èğ
	`£xt
(
io
.
»q
.
b™s
.
š1
, 
	`h®fWidth
(io.»q.b™s), 
lhsSigÃd
)

86 
	`v®
 (
rhs_š
, 
rhs_sign
èğ
	`£xt
(
io
.
»q
.
b™s
.
š2
, 
	`h®fWidth
(io.»q.b™s), 
rhsSigÃd
)

88 
v®
 
subŒaùÜ
 = 
	`»mašd”
(2*
w
,wè- 
divisÜ


89 
v®
 
»suÉ
 = 
	`Mux
(
»sHi
, 
	`»mašd”
(2*
w
, w+1),„emainder(w-1, 0))

90 
v®
 
Ãg©ed_»mašd”
 = -
»suÉ


92 ià(
cfg
.
divUÄŞl
 !ğ0è
	`wh’
 (
¡©e
 ==ğ
s_Ãg_šputs
) {

93 
	`wh’
 (
	`»mašd”
(
w
-1)) {

94 
»mašd”
 :ğ
Ãg©ed_»mašd”


96 
	`wh’
 (
	`divisÜ
(
w
-1)) {

97 
divisÜ
 :ğ
subŒaùÜ


99 
¡©e
 :ğ
s_div


101 ià(
cfg
.
divUÄŞl
 !ğ0è
	`wh’
 (
¡©e
 ==ğ
s_Ãg_ouut
) {

102 
»mašd”
 :ğ
Ãg©ed_»mašd”


103 
¡©e
 :ğ
s_dÚe_div


104 
»sHi
 :ğ
çl£


106 ià(
cfg
.
mulUÄŞl
 !ğ0è
	`wh’
 (
¡©e
 ==ğ
s_mul
) {

107 
v®
 
mulReg
 = 
	`C©
(
	`»mašd”
(2*
mulw
+1,
w
+1),remainder(w-1,0))

108 
v®
 
m¶›rSign
 = 
	`»mašd”
(
w
)

109 
v®
 
m¶›r
 = 
	`mulReg
(
mulw
-1,0)

110 
v®
 
accum
 = 
	`mulReg
(2*
mulw
,mulw).
asSIÁ


111 
v®
 
mpÿnd
 = 
divisÜ
.
asSIÁ


112 
v®
 
´od
 = 
	`C©
(
m¶›rSign
, 
	`m¶›r
(
cfg
.
mulUÄŞl
-1, 0)).
asSIÁ
 * 
mpÿnd
 + 
accum


113 
v®
 
ÃxtMulReg
 = 
	`C©
(
´od
, 
	`m¶›r
(
mulw
-1, 
cfg
.
mulUÄŞl
))

114 
v®
 
ÃxtM¶›rSign
 = 
couÁ
 ==ğ
mulw
/
cfg
.
mulUÄŞl
-2 && 
Ãg_out


116 
v®
 
eOutMask
 = (
	`SIÁ
(
	`BigIÁ
(-1è<< 
mulw
è>> (
couÁ
 * 
cfg
.
mulUÄŞl
)(
	`log2Up
(mulw)-1,0))(mulw-1,0)

117 
v®
 
eOut
 = 
	`BoŞ
(
cfg
.
mulE¬lyOut
è&& 
couÁ
 =/ğ
mulw
/cfg.
mulUÄŞl
-1 && count =/= 0 &&

118 !
isHi
 && (
m¶›r
 & ~
eOutMask
è==ğ
	`UIÁ
(0)

119 
v®
 
eOutRes
 = (
mulReg
 >> (
mulw
 - 
couÁ
 * 
cfg
.
mulUÄŞl
)(
	`log2Up
(mulw)-1,0))

120 
v®
 
ÃxtMulReg1
 = 
	`C©
(
	`ÃxtMulReg
(2*
mulw
,mulw), 
	`Mux
(
eOut
, 
eOutRes
, 
ÃxtMulReg
)(mulw-1,0))

121 
»mašd”
 :ğ
	`C©
(
ÃxtMulReg1
 >> 
w
, 
ÃxtM¶›rSign
, 
	`ÃxtMulReg1
(w-1,0))

123 
couÁ
 := count + 1

124 
	`wh’
 (
eOut
 || 
couÁ
 ==ğ
mulw
/
cfg
.
mulUÄŞl
-1) {

125 
¡©e
 :ğ
s_dÚe_mul


126 
»sHi
 :ğ
isHi


129 ià(
cfg
.
divUÄŞl
 !ğ0è
	`wh’
 (
¡©e
 ==ğ
s_div
) {

130 
v®
 
uÄŞls
 = ((0 
uÁ
 
cfg
.
divUÄŞl
è
sÿnLeá
 
»mašd”
è{ (
»m
, 
i
) =>

132 
v®
 
difã»nû
 = ià(
i
 =ğ0è
subŒaùÜ
 
	`»m
(2*
w
,wè- 
	`divisÜ
(w-1,0)

133 
v®
 
Ëss
 = 
	`difã»nû
(
w
)

134 
	`C©
(
	`Mux
(
Ëss
, 
	`»m
(2*
w
-1,w), 
	`difã»nû
(w-1,0)),„em(w-1,0), !less)

135 } 



137 
»mašd”
 :ğ
uÄŞls
.
Ï¡


138 
	`wh’
 (
couÁ
 ==ğ
w
/
cfg
.
divUÄŞl
) {

139 
¡©e
 :ğ
	`Mux
(
Ãg_out
, 
s_Ãg_ouut
, 
s_dÚe_div
)

140 
»sHi
 :ğ
isHi


141 ià(
w
 % 
cfg
.
divUÄŞl
 < cfg.divUnroll - 1)

142 
»mašd”
 :ğ
	`uÄŞls
(
w
 % 
cfg
.
divUÄŞl
)

144 
couÁ
 := count + 1

146 
v®
 
divby0
 = 
couÁ
 ==ğ0 && !
	`subŒaùÜ
(
w
)

147 ià(
cfg
.
divE¬lyOut
) {

148 
v®
 
®ign
 = 1 << 
	`log2FloÜ
(
cfg
.
divUÄŞl
 
max
 cfg.
divE¬lyOutG¿nuÏr™y
)

149 
v®
 
®ignMask
 = ~
	`UIÁ
(
®ign
-1, 
	`log2Ce
(
w
))

150 
v®
 
divisÜMSB
 = 
	`Log2
(
	`divisÜ
(
w
-1,0), wè& 
®ignMask


151 
v®
 
divid’dMSB
 = 
	`Log2
(
	`»mašd”
(
w
-1,0), wè| ~
®ignMask


152 
v®
 
eOutPos
 = ~(
divid’dMSB
 - 
divisÜMSB
)

153 
v®
 
eOut
 = 
couÁ
 ==ğ0 && !
divby0
 && 
eOutPos
 >ğ
®ign


154 
	`wh’
 (
eOut
) {

155 
»mašd”
 :ğ
	`»mašd”
(
w
-1,0è<< 
eOutPos


156 
couÁ
 :ğ
eOutPos
 >> 
	`log2FloÜ
(
cfg
.
divUÄŞl
)

159 
	`wh’
 (
divby0
 && !
isHi
è{ 
Ãg_out
 :ğ
çl£
 }

161 
	`wh’
 (
io
.
»¥
.
	`fœe
(è|| io.
kl
) {

162 
¡©e
 :ğ
s_»ady


164 
	`wh’
 (
io
.
»q
.
	`fœe
()) {

165 
¡©e
 :ğ
	`Mux
(
cmdMul
, 
s_mul
, Mux(
lhs_sign
 || 
rhs_sign
, 
s_Ãg_šputs
, 
s_div
))

166 
isHi
 :ğ
cmdHi


167 
»sHi
 :ğ
çl£


168 
couÁ
 :ğ(ià(
ç¡MulW
è
Mux
[
UIÁ
](
cmdMul
 && 
	`h®fWidth
(
io
.
»q
.
b™s
), 
w
/
cfg
.
mulUÄŞl
/2, 0) 0)

169 
Ãg_out
 :ğ
	`Mux
(
cmdHi
, 
lhs_sign
,†hs_sigÀ=/ğ
rhs_sign
)

170 
divisÜ
 :ğ
	`C©
(
rhs_sign
, 
rhs_š
)

171 
»mašd”
 :ğ
lhs_š


172 
»q
 :ğ
io
.»q.
b™s


175 
v®
 
outMul
 = (
¡©e
 & (
s_dÚe_mul
 ^ 
s_dÚe_div
)) === (s_done_mul & ~s_done_div)

176 
v®
 
loOut
 = 
	`Mux
(
	`BoŞ
(
ç¡MulW
è&& 
	`h®fWidth
(
»q
è&& 
outMul
, 
	`»suÉ
(
w
-1,w/2),„esult(w/2-1,0))

177 
v®
 
hiOut
 = 
	`Mux
(
	`h®fWidth
(
»q
), 
	`Fl
(
w
/2, 
	`loOut
(w/2-1)), 
	`»suÉ
(w-1,w/2))

178 
io
.
»¥
.
b™s
 <> 
»q


179 
io
.
»¥
.
b™s
.
d©a
 :ğ
	`C©
(
hiOut
, 
loOut
)

180 
io
.
»¥
.
v®id
 :ğ(
¡©e
 ==ğ
s_dÚe_mul
 || s‹ ==ğ
s_dÚe_div
)

181 
io
.
»q
.
»ady
 :ğ
¡©e
 ==ğ
s_»ady


182 
	}
}

184 
şass
 
	$P–šedMuÉl›r
(
width
: 
IÁ
, 
Ï‹ncy
: IÁ, 
nX´
: IÁ = 32è
ex‹nds
 
ModuË
 
w™h
 
ShouldBeR‘imed
 {

185 
v®
 
io
 = 
Ãw
 
BundË
 {

186 
v®
 
»q
 = 
	`V®id
(
Ãw
 
	`MuÉl›rReq
(
width
, 
	`log2Ce
(
nX´
))).
æ


187 
v®
 
»¥
 = 
	`V®id
(
Ãw
 
	`MuÉl›rRe¥
(
width
, 
	`log2Ce
(
nX´
)))

190 
v®
 
š
 = 
	`Pe
(
io
.
»q
)

192 
v®
 
decode
 = 
	`Li¡
(

193 
FN_MUL
 -> 
	`Li¡
(
N
, 
X
, X),

194 
FN_MULH
 -> 
	`Li¡
(
Y
, Y, Y),

195 
FN_MULHU
 -> 
	`Li¡
(
Y
, 
N
, N),

196 
FN_MULHSU
 -> 
	`Li¡
(
Y
, Y, 
N
))

197 
v®
 
cmdHi
 :: 
lhsSigÃd
 :: 
rhsSigÃd
 :: 
N
 =

198 
	`DecodeLogic
(
š
.
b™s
.
â
, 
	`Li¡
(
X
, X, X), 
decode
).
	`m­
(
_
.
toBoŞ
)

199 
v®
 
cmdH®f
 = 
	`BoŞ
(
width
 > 32è&& 
š
.
b™s
.
dw
 ==ğ
DW_32


201 
v®
 
lhs
 = 
	`C©
(
lhsSigÃd
 && 
š
.
b™s
.
	`š1
(
width
-1), in.b™s.
š1
).
asSIÁ


202 
v®
 
rhs
 = 
	`C©
(
rhsSigÃd
 && 
š
.
b™s
.
	`š2
(
width
-1), in.b™s.
š2
).
asSIÁ


203 
v®
 
´od
 = 
lhs
 * 
rhs


204 
v®
 
muxed
 = 
	`Mux
(
cmdHi
, 
	`´od
(2*
width
-1, width), Mux(
cmdH®f
,…rod(width/2-1, 0).
	`£xtTo
(width),…rod(width-1, 0)))

206 
io
.
»¥
 :ğ
	`Pe
(
š
, 
Ï‹ncy
-1)

207 
io
.
»¥
.
b™s
.
d©a
 :ğ
	`Pe
(
š
.
v®id
, 
muxed
, 
Ï‹ncy
-1).bits

208 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/NBDcache.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


13 
Œa™
 
HasMissInfo
 
ex‹nds
 
	gHasL1H–ÏCacheP¬am‘”s
 {

14 
v®
 
	gg_m©ch
 = 
BoŞ
()

15 
v®
 
Şd_m‘a
 = 
Ãw
 
L1M‘ad©a


16 
v®
 
way_’
 = 
B™s
(
width
 = 
nWays
)

19 şas 
	cL1D©aR—dReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheBundË
()(
p
) {

20 
v®
 
way_’
 = 
	$B™s
(
width
 = 
nWays
)

21 
v®
 
addr
 = 
	`B™s
(
width
 = 
uÁagB™s
)

24 şas 
	cL1D©aWr™eReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1D©aR—dReq
()(
p
) {

25 
v®
 
wmask
 = 
	$B™s
(
width
 = 
rowWÜds
)

26 
v®
 
d©a
 = 
	`B™s
(
width
 = 
’cRowB™s
)

29 şas 
	cL1ReflReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1D©aR—dReq
()(
p
)

31 şas 
	cR•Ïy
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$H–ÏCacheReqIÁ”Çl
()(
p
è
w™h
 
HasCÜeD©a


33 şas 
	cR•ÏyIÁ”Çl
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$H–ÏCacheReqIÁ”Çl
()(
p
)

34 
w™h
 
HasL1H–ÏCacheP¬am‘”s
 {

35 
v®
 
sdq_id
 = 
	`UIÁ
(
width
 = 
	`log2Up
(
cfg
.
nSDQ
))

38 şas 
	cMSHRReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$R•Ïy
()(
p
è
w™h
 
HasMissInfo


40 şas 
	cMSHRReqIÁ”Çl
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$R•ÏyIÁ”Çl
()(
p
è
w™h
 
HasMissInfo


42 şas 
	cWr™ebackReq
(
·¿ms
: 
TLBundËP¬am‘”s
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheBundË
()(
p
) {

43 
v®
 
g
 = 
	$B™s
(
width
 = 
gB™s
)

44 
v®
 
idx
 = 
	$B™s
(
width
 = 
idxB™s
)

45 
v®
 
sourû
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sourûB™s
)

46 
v®
 
·¿m
 = 
	$UIÁ
(
width
 = 
TLP”missiÚs
.
cWidth
)

47 
v®
 
way_’
 = 
	$B™s
(
width
 = 
nWays
)

48 
v®
 
vŞuÁ¬y
 = 
	$BoŞ
()

50 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	$Wr™ebackReq
(
·¿ms
)(
p
).
asIn¡ªûOf
[
this
.
ty³
]

53 
şass
 
	$IOMSHR
(
id
: 
IÁ
)(
im¶ic™
 
edge
: 
TLEdgeOut
, 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

54 
v®
 
io
 = 
Ãw
 
BundË
 {

55 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
H–ÏCacheReq
).
æ


56 
v®
 
»¥
 = 
	`Decou¶ed
(
Ãw
 
H–ÏCacheRe¥
)

57 
v®
 
mem_acûss
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËA
(
edge
.
bundË
))

58 
v®
 
mem_ack
 = 
	`V®id
(
Ãw
 
	`TLBundËD
(
edge
.
bundË
)).
æ


59 
v®
 
»¶ay_Ãxt
 = 
	`BoŞ
(
OUTPUT
)

62 
def
 
	`b—tOff£t
(
addr
: 
UIÁ
èğaddr.
	`exŒaù
(
b—tOffB™s
 - 1, 
wÜdOffB™s
)

64 
def
 
	`wÜdFromB—t
(
addr
: 
UIÁ
, 
d©
: UInt) = {

65 
v®
 
shiá
 = 
	`C©
(
	`b—tOff£t
(
addr
), 
	`UIÁ
(0, 
wÜdOffB™s
 + 
	`log2Up
(
wÜdBy‹s
)))

66 (
d©
 >> 
shiá
)(
wÜdB™s
 - 1, 0)

69 
v®
 
»q
 = 
	`Reg
(
Ãw
 
H–ÏCacheReq
)

70 
v®
 
g¿Á_wÜd
 = 
	`Reg
(
	`UIÁ
(
width
 = 
wÜdB™s
))

72 
v®
 
s_idË
 :: 
s_mem_acûss
 :: 
s_mem_ack
 :: 
s_»¥
 :: 
N
 = 
	`Enum
(
	`B™s
(), 4)

73 
v®
 
¡©e
 = 
	`Reg
(
š™
 = 
s_idË
)

74 
io
.
»q
.
»ady
 :ğ(
¡©e
 ==ğ
s_idË
)

76 
v®
 
lßdg’
 = 
Ãw
 
	`LßdG’
(
»q
.
typ
, 
	`mtSigÃd
Ôeq.typ),„eq.
addr
, 
g¿Á_wÜd
, 
çl£
.
B
, 
wÜdBy‹s
)

78 
v®
 
a_sourû
 = 
	`UIÁ
(
id
)

79 
v®
 
a_add»ss
 = 
»q
.
addr


80 
v®
 
a_size
 = 
	`mtSize
(
»q
.
typ
)

81 
v®
 
a_d©a
 = 
	`Fl
(
b—tWÜds
, 
»q
.
d©a
)

83 
v®
 
g‘
 = 
edge
.
	`G‘
(
a_sourû
, 
a_add»ss
, 
a_size
).
_2


84 
v®
 
put
 = 
edge
.
	`Put
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
).
_2


85 
v®
 
©omics
 = ià(
edge
.
mªag”
.
ªySuµÜtLogiÿl
) {

86 
	`MuxLookup
(
»q
.
cmd
, 
	`Wœe
(
Ãw
 
	`TLBundËA
(
edge
.
bundË
)), 
	`A¼ay
(

87 
M_XA_SWAP
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
SWAP
).
_2
,

88 
M_XA_XOR
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
XOR
è.
_2
,

89 
M_XA_OR
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
OR
è.
_2
,

90 
M_XA_AND
 -> 
edge
.
	`Logiÿl
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
AND
è.
_2
,

91 
M_XA_ADD
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
ADD
).
_2
,

92 
M_XA_MIN
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MIN
).
_2
,

93 
M_XA_MAX
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAX
).
_2
,

94 
M_XA_MINU
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MINU
).
_2
,

95 
M_XA_MAXU
 -> 
edge
.
	`Ar™hm‘ic
(
a_sourû
, 
a_add»ss
, 
a_size
, 
a_d©a
, 
TLAtomics
.
MAXU
).
_2
))

98 
	`as£¹
(
¡©e
 ==ğ
s_idË
 || !
	`isAMO
(
»q
.
cmd
))

99 
	`Wœe
(
Ãw
 
	`TLBundËA
(
edge
.
bundË
))

101 
	`as£¹
(
¡©e
 ==ğ
s_idË
 || 
»q
.
cmd
 =/ğ
M_XSC
)

103 
io
.
mem_acûss
.
v®id
 :ğ(
¡©e
 ==ğ
s_mem_acûss
)

104 
io
.
mem_acûss
.
b™s
 :ğ
	`Mux
(
	`isAMO
(
»q
.
cmd
), 
©omics
, Mux(
	`isR—d
Ôeq.cmd), 
g‘
, 
put
))

106 
io
.
»¶ay_Ãxt
 :ğ(
¡©e
 ==ğ
s_mem_ack
è|| io.
»¥
.
v®id
 && !io.»¥.
»ady


107 
io
.
»¥
.
v®id
 :ğ(
¡©e
 ==ğ
s_»¥
)

108 
io
.
»¥
.
b™s
 :ğ
»q


109 
io
.
»¥
.
b™s
.
has_d©a
 :ğ
	`isR—d
(
»q
.
cmd
)

110 
io
.
»¥
.
b™s
.
d©a
 :ğ
lßdg’
.data

111 
io
.
»¥
.
b™s
.
¡Üe_d©a
 :ğ
»q
.
d©a


112 
io
.
»¥
.
b™s
.
»¶ay
 :ğ
	`BoŞ
(
Œue
)

114 
	`wh’
 (
io
.
»q
.
	`fœe
()) {

115 
»q
 :ğ
io
.»q.
b™s


116 
¡©e
 :ğ
s_mem_acûss


119 
	`wh’
 (
io
.
mem_acûss
.
	`fœe
()) {

120 
¡©e
 :ğ
s_mem_ack


123 
	`wh’
 (
¡©e
 ==ğ
s_mem_ack
 && 
io
.
mem_ack
.
v®id
) {

124 
¡©e
 :ğ
s_»¥


125 
	`wh’
 (
	`isR—d
(
»q
.
cmd
)) {

126 
g¿Á_wÜd
 :ğ
	`wÜdFromB—t
(
»q
.
addr
, 
io
.
mem_ack
.
b™s
.
d©a
)

130 
	`wh’
 (
io
.
»¥
.
	`fœe
()) {

131 
¡©e
 :ğ
s_idË


133 
	}
}

135 
şass
 
	$MSHR
(
id
: 
IÁ
)(
im¶ic™
 
edge
: 
TLEdgeOut
, 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

136 
v®
 
io
 = 
Ãw
 
BundË
 {

137 
v®
 
»q_´i_v®
 = 
	`BoŞ
(
INPUT
)

138 
v®
 
»q_´i_rdy
 = 
	`BoŞ
(
OUTPUT
)

139 
v®
 
»q_£c_v®
 = 
	`BoŞ
(
INPUT
)

140 
v®
 
»q_£c_rdy
 = 
	`BoŞ
(
OUTPUT
)

141 
v®
 
»q_b™s
 = 
Ãw
 
	`MSHRReqIÁ”Çl
().
asIÅut


143 
v®
 
idx_m©ch
 = 
	`BoŞ
(
OUTPUT
)

144 
v®
 
g
 = 
	`B™s
(
OUTPUT
, 
gB™s
)

146 
v®
 
mem_acquœe
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËA
(
edge
.
bundË
))

147 
v®
 
mem_g¿Á
 = 
	`V®id
(
Ãw
 
	`TLBundËD
(
edge
.
bundË
)).
æ


148 
v®
 
mem_fšish
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËE
(
edge
.
bundË
))

150 
v®
 
»fl
 = 
Ãw
 
	`L1ReflReq
().
asOuut


151 
v®
 
m‘a_»ad
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aR—dReq
)

152 
v®
 
m‘a_wr™e
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aWr™eReq
)

153 
v®
 
»¶ay
 = 
	`Decou¶ed
(
Ãw
 
R•ÏyIÁ”Çl
)

154 
v®
 
wb_»q
 = 
	`Decou¶ed
(
Ãw
 
	`Wr™ebackReq
(
edge
.
bundË
))

155 
v®
 
´obe_rdy
 = 
	`BoŞ
(
OUTPUT
)

158 
v®
 
s_šv®id
 :: 
s_wb_»q
 :: 
s_wb_»¥
 :: 
s_m‘a_ş—r
 :: 
s_»fl_»q
 :: 
s_»fl_»¥
 :: 
s_m‘a_wr™e_»q
 :: 
s_m‘a_wr™e_»¥
 :: 
s_d¿š_½q
 :: 
N
 = 
	`Enum
(
	`UIÁ
(), 9)

159 
v®
 
¡©e
 = 
	`Reg
(
š™
=
s_šv®id
)

161 
v®
 
»q
 = 
	`Reg
(
Ãw
 
MSHRReqIÁ”Çl
)

162 
v®
 
»q_idx
 = 
»q
.
	`addr
(
uÁagB™s
-1,
blockOffB™s
)

163 
v®
 
»q_g
 = 
»q
.
addr
 >> 
uÁagB™s


164 
v®
 
»q_block_addr
 = (
»q
.
addr
 >> 
blockOffB™s
) << blockOffBits

165 
v®
 
idx_m©ch
 = 
»q_idx
 ==ğ
io
.
»q_b™s
.
	`addr
(
uÁagB™s
-1,
blockOffB™s
)

167 
v®
 
Ãw_coh
 = 
	`Reg
(
š™
=
Cl›ÁM‘ad©a
.
ÚRe£t
)

168 
	`v®
 (
_
, 
shršk_·¿m
, 
coh_Ú_ş—r
èğ
»q
.
Şd_m‘a
.
coh
.
	`ÚCacheCÚŒŞ
(
M_FLUSH
)

169 
v®
 
grow_·¿m
 = 
Ãw_coh
.
	`ÚAcûss
(
»q
.
cmd
).
_2


170 
v®
 
coh_Ú_g¿Á
 = 
Ãw_coh
.
	`ÚG¿Á
(
»q
.
cmd
, 
io
.
mem_g¿Á
.
b™s
.
·¿m
)

175 
	`v®
 (
cmd_»quœes_£cÚd_acquœe
, 
is_h™_agaš
, 
_
, 
dœt›r_coh
, 
dœt›r_cmd
) =

176 
Ãw_coh
.
	`ÚSecÚd¬yAcûss
(
»q
.
cmd
, 
io
.
»q_b™s
.cmd)

178 
v®
 
¡©es_befÜe_»fl
 = 
	`Seq
(
s_wb_»q
, 
s_wb_»¥
, 
s_m‘a_ş—r
)

179 
	`v®
 (
_
, _, 
»fl_dÚe
, 
»fl_add»ss_šc
èğ
edge
.
	`addr_šc
(
io
.
mem_g¿Á
)

180 
v®
 
£c_rdy
 = 
idx_m©ch
 &&

181 (
¡©e
.
	`isOÃOf
(
¡©es_befÜe_»fl
) ||

182 (
¡©e
.
	`isOÃOf
(
s_»fl_»q
, 
s_»fl_»¥
) &&

183 !
cmd_»quœes_£cÚd_acquœe
 && !
»fl_dÚe
))

185 
v®
 
½q
 = 
	`ModuË
(
Ãw
 
	`Queue
Òew 
R•ÏyIÁ”Çl
, 
cfg
.
nRPQ
))

186 
½q
.
io
.
’q
.
v®id
 :ğ(io.
»q_´i_v®
 && io.
»q_´i_rdy
 || io.
»q_£c_v®
 && 
£c_rdy
è&& !
	`isP»ãtch
(io.
»q_b™s
.
cmd
)

187 
½q
.
io
.
’q
.
b™s
 :ğio.
»q_b™s


188 
½q
.
io
.
deq
.
»ady
 :ğ(io.
»¶ay
.»ady && 
¡©e
 ==ğ
s_d¿š_½q
è|| s‹ ==ğ
s_šv®id


190 
	`wh’
 (
¡©e
 ==ğ
s_d¿š_½q
 && !
½q
.
io
.
deq
.
v®id
) {

191 
¡©e
 :ğ
s_šv®id


193 
	`wh’
 (
¡©e
 ==ğ
s_m‘a_wr™e_»¥
) {

195 
¡©e
 :ğ
s_d¿š_½q


197 
	`wh’
 (
¡©e
 ==ğ
s_m‘a_wr™e_»q
 && 
io
.
m‘a_wr™e
.
»ady
) {

198 
¡©e
 :ğ
s_m‘a_wr™e_»¥


200 
	`wh’
 (
¡©e
 ==ğ
s_»fl_»¥
 && 
»fl_dÚe
) {

201 
Ãw_coh
 :ğ
coh_Ú_g¿Á


202 
¡©e
 :ğ
s_m‘a_wr™e_»q


204 
	`wh’
 (
io
.
mem_acquœe
.
	`fœe
()) {

205 
¡©e
 :ğ
s_»fl_»¥


207 
	`wh’
 (
¡©e
 ==ğ
s_m‘a_ş—r
 && 
io
.
m‘a_wr™e
.
»ady
) {

208 
¡©e
 :ğ
s_»fl_»q


210 
	`wh’
 (
¡©e
 ==ğ
s_wb_»¥
 && 
io
.
mem_g¿Á
.
v®id
) {

211 
¡©e
 :ğ
s_m‘a_ş—r


213 
	`wh’
 (
io
.
wb_»q
.
	`fœe
()) {

214 
¡©e
 :ğ
s_wb_»¥


216 
	`wh’
 (
io
.
»q_£c_v®
 && io.
»q_£c_rdy
) {

220 
»q
.
cmd
 :ğ
dœt›r_cmd


221 
	`wh’
 (
is_h™_agaš
) {

222 
Ãw_coh
 :ğ
dœt›r_coh


225 
	`wh’
 (
io
.
»q_´i_v®
 && io.
»q_´i_rdy
) {

226 
»q
 :ğ
io
.
»q_b™s


227 
v®
 
Şd_coh
 = 
io
.
»q_b™s
.
Şd_m‘a
.
coh


228 
v®
 
Ãeds_wb
 = 
Şd_coh
.
	`ÚCacheCÚŒŞ
(
M_FLUSH
).
_1


229 
	`v®
 (
is_h™
, 
_
, 
coh_Ú_h™
èğ
Şd_coh
.
	`ÚAcûss
(
io
.
»q_b™s
.
cmd
)

230 
	`wh’
 (
io
.
»q_b™s
.
g_m©ch
) {

231 
	`wh’
 (
is_h™
) {

232 
Ãw_coh
 :ğ
coh_Ú_h™


233 
¡©e
 :ğ
s_m‘a_wr™e_»q


234 }.
Ùh”wi£
 {

235 
Ãw_coh
 :ğ
Şd_coh


236 
¡©e
 :ğ
s_»fl_»q


238 }.
Ùh”wi£
 {

239 
Ãw_coh
 :ğ
Cl›ÁM‘ad©a
.
ÚRe£t


240 
¡©e
 :ğ
	`Mux
(
Ãeds_wb
, 
s_wb_»q
, 
s_m‘a_ş—r
)

244 
v®
 
g¿Áackq
 = 
	`ModuË
(
Ãw
 
	`Queue
(
io
.
mem_fšish
.
b™s
, 1))

245 
v®
 
ÿn_fšish
 = 
¡©e
.
	`isOÃOf
(
s_šv®id
, 
s_»fl_»q
)

246 
g¿Áackq
.
io
.
’q
.
v®id
 :ğ
»fl_dÚe
 && 
edge
.
	`isReque¡
(io.
mem_g¿Á
.
b™s
)

247 
g¿Áackq
.
io
.
’q
.
b™s
 :ğ
edge
.
	`G¿ÁAck
(io.
mem_g¿Á
.bits)

248 
io
.
mem_fšish
.
v®id
 :ğ
g¿Áackq
.io.
deq
.v®id && 
ÿn_fšish


249 
io
.
mem_fšish
.
b™s
 :ğ
g¿Áackq
.io.
deq
.bits

250 
g¿Áackq
.
io
.
deq
.
»ady
 :ğio.
mem_fšish
.»ady && 
ÿn_fšish


252 
io
.
idx_m©ch
 :ğ(
¡©e
 =/ğ
s_šv®id
) && idx_match

253 
io
.
»fl
.
way_’
 :ğ
»q
.way_en

254 
io
.
»fl
.
addr
 :ğ
»q_block_addr
 | 
»fl_add»ss_šc


255 
io
.
g
 :ğ
»q_g


256 
io
.
»q_´i_rdy
 :ğ
¡©e
 ==ğ
s_šv®id


257 
io
.
»q_£c_rdy
 :ğ
£c_rdy
 && 
½q
.io.
’q
.
»ady


259 
v®
 
m‘a_haz¬d
 = 
	`Reg
(
š™
=
	`UIÁ
(0,2))

260 
	`wh’
 (
m‘a_haz¬d
 =/ğ
	`UIÁ
(0)) { meta_hazard := meta_hazard + 1 }

261 
	`wh’
 (
io
.
m‘a_wr™e
.
	`fœe
()è{ 
m‘a_haz¬d
 := 1 }

262 
io
.
´obe_rdy
 :ğ!
idx_m©ch
 || (!
¡©e
.
	`isOÃOf
(
¡©es_befÜe_»fl
è&& 
m‘a_haz¬d
 === 0)

264 
io
.
m‘a_wr™e
.
v®id
 :ğ
¡©e
.
	`isOÃOf
(
s_m‘a_wr™e_»q
, 
s_m‘a_ş—r
)

265 
io
.
m‘a_wr™e
.
b™s
.
idx
 :ğ
»q_idx


266 
io
.
m‘a_wr™e
.
b™s
.
d©a
.
coh
 :ğ
	`Mux
(
¡©e
 ==ğ
s_m‘a_ş—r
, 
coh_Ú_ş—r
, 
Ãw_coh
)

267 
io
.
m‘a_wr™e
.
b™s
.
d©a
.
g
 := io.tag

268 
io
.
m‘a_wr™e
.
b™s
.
way_’
 :ğ
»q
.way_en

270 
io
.
wb_»q
.
v®id
 :ğ
¡©e
 ==ğ
s_wb_»q


271 
io
.
wb_»q
.
b™s
.
sourû
 :ğ
	`UIÁ
(
id
)

272 
io
.
wb_»q
.
b™s
.
g
 :ğ
»q
.
Şd_m‘a
.tag

273 
io
.
wb_»q
.
b™s
.
idx
 :ğ
»q_idx


274 
io
.
wb_»q
.
b™s
.
·¿m
 :ğ
shršk_·¿m


275 
io
.
wb_»q
.
b™s
.
way_’
 :ğ
»q
.way_en

276 
io
.
wb_»q
.
b™s
.
vŞuÁ¬y
 :ğ
	`BoŞ
(
Œue
)

278 
io
.
mem_acquœe
.
v®id
 :ğ
¡©e
 ==ğ
s_»fl_»q
 && 
g¿Áackq
.io.
’q
.
»ady


279 
io
.
mem_acquœe
.
b™s
 :ğ
edge
.
	`AcquœeBlock
(

280 
äomSourû
 = 
	`UIÁ
(
id
),

281 
toAdd»ss
 = 
	`C©
(
io
.
g
, 
»q_idx
è<< 
blockOffB™s
,

282 
lgSize
 = 
lgCacheBlockBy‹s
,

283 
growP”missiÚs
 = 
grow_·¿m
).
_2


285 
io
.
m‘a_»ad
.
v®id
 :ğ
¡©e
 ==ğ
s_d¿š_½q


286 
io
.
m‘a_»ad
.
b™s
.
idx
 :ğ
»q_idx


287 
io
.
m‘a_»ad
.
b™s
.
g
 := io.tag

289 
io
.
»¶ay
.
v®id
 :ğ
¡©e
 ==ğ
s_d¿š_½q
 && 
½q
.io.
deq
.valid

290 
io
.
»¶ay
.
b™s
 :ğ
½q
.io.
deq
.bits

291 
io
.
»¶ay
.
b™s
.
phys
 :ğ
	`BoŞ
(
Œue
)

292 
io
.
»¶ay
.
b™s
.
addr
 :ğ
	`C©
(io.
g
, 
»q_idx
, 
½q
.io.
deq
.b™s.
	`addr
(
blockOffB™s
-1,0))

294 
	`wh’
 (!
io
.
m‘a_»ad
.
»ady
) {

295 
½q
.
io
.
deq
.
»ady
 :ğ
	`BoŞ
(
çl£
)

296 
io
.
»¶ay
.
b™s
.
cmd
 :ğ
M_FLUSH_ALL


298 
	}
}

300 
şass
 
	$MSHRFe
(
im¶ic™
 
edge
: 
TLEdgeOut
, 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

301 
v®
 
io
 = 
Ãw
 
BundË
 {

302 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
MSHRReq
).
æ


303 
v®
 
»¥
 = 
	`Decou¶ed
(
Ãw
 
H–ÏCacheRe¥
)

304 
v®
 
£cÚd¬y_miss
 = 
	`BoŞ
(
OUTPUT
)

306 
v®
 
mem_acquœe
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËA
(
edge
.
bundË
))

307 
v®
 
mem_g¿Á
 = 
	`V®id
(
Ãw
 
	`TLBundËD
(
edge
.
bundË
)).
æ


308 
v®
 
mem_fšish
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËE
(
edge
.
bundË
))

310 
v®
 
»fl
 = 
Ãw
 
	`L1ReflReq
().
asOuut


311 
v®
 
m‘a_»ad
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aR—dReq
)

312 
v®
 
m‘a_wr™e
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aWr™eReq
)

313 
v®
 
»¶ay
 = 
	`Decou¶ed
(
Ãw
 
R•Ïy
)

314 
v®
 
wb_»q
 = 
	`Decou¶ed
(
Ãw
 
	`Wr™ebackReq
(
edge
.
bundË
))

316 
v®
 
´obe_rdy
 = 
	`BoŞ
(
OUTPUT
)

317 
v®
 
ãnû_rdy
 = 
	`BoŞ
(
OUTPUT
)

318 
v®
 
»¶ay_Ãxt
 = 
	`BoŞ
(
OUTPUT
)

322 
v®
 
ÿch—bË
 = 
edge
.
mªag”
.
	`suµÜtsAcquœeBFa¡
(
io
.
»q
.
b™s
.
addr
, 
lgCacheBlockBy‹s
)

324 
v®
 
sdq_v®
 = 
	`Reg
(
š™
=
	`B™s
(0, 
cfg
.
nSDQ
))

325 
v®
 
sdq_®loc_id
 = 
	`PriÜ™yEncod”
(~
	`sdq_v®
(
cfg
.
nSDQ
-1,0))

326 
v®
 
sdq_rdy
 = !
sdq_v®
.
ªdR


327 
v®
 
sdq_’q
 = 
io
.
»q
.
v®id
 && io.»q.
»ady
 && 
ÿch—bË
 && 
	`isWr™e
(io.»q.
b™s
.
cmd
)

328 
v®
 
sdq
 = 
	`Mem
(
cfg
.
nSDQ
, 
io
.
»q
.
b™s
.
d©a
)

329 
	`wh’
 (
sdq_’q
è{ 
	`sdq
(
sdq_®loc_id
è:ğ
io
.
»q
.
b™s
.
d©a
 }

331 
v®
 
idxM©ch
 = 
	`Wœe
(
	`Vec
(
cfg
.
nMSHRs
, 
	`BoŞ
()))

332 
v®
 
gLi¡
 = 
	`Wœe
(
	`Vec
(
cfg
.
nMSHRs
, 
	`B™s
(
width
 = 
gB™s
)))

333 
v®
 
g_m©ch
 = 
	`Mux1H
(
idxM©ch
, 
gLi¡
è==ğ
io
.
»q
.
b™s
.
addr
 >> 
uÁagB™s


335 
v®
 
wbTagLi¡
 = 
	`Wœe
(
	`Vec
(
cfg
.
nMSHRs
, 
	`B™s
()))

336 
v®
 
»flMux
 = 
	`Wœe
(
	`Vec
(
cfg
.
nMSHRs
, 
Ãw
 
L1ReflReq
))

337 
v®
 
m‘a_»ad_¬b
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
L1M‘aR—dReq
, 
cfg
.
nMSHRs
))

338 
v®
 
m‘a_wr™e_¬b
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
L1M‘aWr™eReq
, 
cfg
.
nMSHRs
))

339 
v®
 
wb_»q_¬b
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
	`Wr™ebackReq
(
edge
.
bundË
), 
cfg
.
nMSHRs
))

340 
v®
 
»¶ay_¬b
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
R•ÏyIÁ”Çl
, 
cfg
.
nMSHRs
))

341 
v®
 
®loc_¬b
 = 
	`ModuË
(
Ãw
 
	`Arb™”
(
	`BoŞ
(), 
cfg
.
nMSHRs
))

343 
v¬
 
idx_m©ch
 = 
	`BoŞ
(
çl£
)

344 
v¬
 
´i_rdy
 = 
	`BoŞ
(
çl£
)

345 
v¬
 
£c_rdy
 = 
	`BoŞ
(
çl£
)

347 
io
.
ãnû_rdy
 :ğ
Œue


348 
io
.
´obe_rdy
 :ğ
Œue


350 
v®
 
mshrs
 = (0 
uÁ
 
cfg
.
nMSHRs
è
m­
 { 
i
 =>

351 
v®
 
mshr
 = 
	`ModuË
(
Ãw
 
	`MSHR
(
i
))

353 
	`idxM©ch
(
i
è:ğ
mshr
.
io
.
idx_m©ch


354 
	`gLi¡
(
i
è:ğ
mshr
.
io
.
g


355 
	`wbTagLi¡
(
i
è:ğ
mshr
.
io
.
wb_»q
.
b™s
.
g


357 
®loc_¬b
.
io
.
	`š
(
i
).
v®id
 :ğ
mshr
.io.
»q_´i_rdy


358 
mshr
.
io
.
»q_´i_v®
 :ğ
®loc_¬b
.io.
	`š
(
i
).
»ady


360 
mshr
.
io
.
»q_£c_v®
 :ğio.
»q
.
v®id
 && 
sdq_rdy
 && 
g_m©ch


361 
mshr
.
io
.
»q_b™s
 :ğio.
»q
.
b™s


362 
mshr
.
io
.
»q_b™s
.
sdq_id
 :ğ
sdq_®loc_id


364 
m‘a_»ad_¬b
.
io
.
	`š
(
i
è<> 
mshr
.io.
m‘a_»ad


365 
m‘a_wr™e_¬b
.
io
.
	`š
(
i
è<> 
mshr
.io.
m‘a_wr™e


366 
wb_»q_¬b
.
io
.
	`š
(
i
è<> 
mshr
.io.
wb_»q


367 
»¶ay_¬b
.
io
.
	`š
(
i
è<> 
mshr
.io.
»¶ay


369 
mshr
.
io
.
mem_g¿Á
.
v®id
 :ğio.mem_g¿Á.v®id && io.mem_g¿Á.
b™s
.
sourû
 ==ğ
	`UIÁ
(
i
)

370 
mshr
.
io
.
mem_g¿Á
.
b™s
 := io.mem_grant.bits

371 
	`»flMux
(
i
è:ğ
mshr
.
io
.
»fl


373 
´i_rdy
 =…ri_rdy || 
mshr
.
io
.
»q_´i_rdy


374 
£c_rdy
 = sec_rdy || 
mshr
.
io
.
»q_£c_rdy


375 
idx_m©ch
 = idx_m©ch || 
mshr
.
io
.idx_match

377 
	`wh’
 (!
mshr
.
io
.
»q_´i_rdy
è{ io.
ãnû_rdy
 :ğ
çl£
 }

378 
	`wh’
 (!
mshr
.
io
.
´obe_rdy
è{ io.´obe_rdy :ğ
çl£
 }

380 
mshr


384 
®loc_¬b
.
io
.
out
.
»ady
 :ğio.
»q
.
v®id
 && 
sdq_rdy
 && 
ÿch—bË
 && !
idx_m©ch


386 
io
.
m‘a_»ad
 <> 
m‘a_»ad_¬b
.io.
out


387 
io
.
m‘a_wr™e
 <> 
m‘a_wr™e_¬b
.io.
out


388 
io
.
wb_»q
 <> 
wb_»q_¬b
.io.
out


390 
v®
 
mmio_®loc_¬b
 = 
	`ModuË
(
Ãw
 
	`Arb™”
(
	`BoŞ
(), 
nIOMSHRs
))

391 
v®
 
»¥_¬b
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
H–ÏCacheRe¥
, 
nIOMSHRs
))

393 
v¬
 
mmio_rdy
 = 
	`BoŞ
(
çl£
)

394 
io
.
»¶ay_Ãxt
 :ğ
	`BoŞ
(
çl£
)

396 
v®
 
mmios
 = (0 
uÁ
 
nIOMSHRs
è
m­
 { 
i
 =>

397 
v®
 
id
 = 
cfg
.
nMSHRs
 + 
i


398 
v®
 
mshr
 = 
	`ModuË
(
Ãw
 
	`IOMSHR
(
id
))

400 
mmio_®loc_¬b
.
io
.
	`š
(
i
).
v®id
 :ğ
mshr
.io.
»q
.
»ady


401 
mshr
.
io
.
»q
.
v®id
 :ğ
mmio_®loc_¬b
.io.
	`š
(
i
).
»ady


402 
mshr
.
io
.
»q
.
b™s
 := io.req.bits

404 
mmio_rdy
 = mmio_rdy || 
mshr
.
io
.
»q
.
»ady


406 
mshr
.
io
.
mem_ack
.
b™s
 :ğio.
mem_g¿Á
.bits

407 
mshr
.
io
.
mem_ack
.
v®id
 :ğio.
mem_g¿Á
.v®id && io.mem_g¿Á.
b™s
.
sourû
 ==ğ
	`UIÁ
(
id
)

409 
»¥_¬b
.
io
.
	`š
(
i
è<> 
mshr
.io.
»¥


411 
	`wh’
 (!
mshr
.
io
.
»q
.
»ady
è{ io.
ãnû_rdy
 :ğ
	`BoŞ
(
çl£
) }

412 
	`wh’
 (
mshr
.
io
.
»¶ay_Ãxt
è{ io.»¶ay_Ãxˆ:ğ
	`BoŞ
(
Œue
) }

414 
mshr


417 
mmio_®loc_¬b
.
io
.
out
.
»ady
 :ğio.
»q
.
v®id
 && !
ÿch—bË


419 
TLArb™”
.
	`lowe¡FromSeq
(
edge
, 
io
.
mem_acquœe
, 
mshrs
.
	`m­
(
_
.io.mem_acquœeè++ 
mmios
.m­(_.io.
mem_acûss
))

420 
TLArb™”
.
	`lowe¡FromSeq
(
edge
, 
io
.
mem_fšish
, 
mshrs
.
	`m­
(
_
.io.mem_finish))

422 
io
.
»¥
 <> 
»¥_¬b
.io.
out


423 
io
.
»q
.
»ady
 :ğ
	`Mux
(!
ÿch—bË
,

424 
mmio_rdy
,

425 
sdq_rdy
 && 
	`Mux
(
idx_m©ch
, 
g_m©ch
 && 
£c_rdy
, 
´i_rdy
))

426 
io
.
£cÚd¬y_miss
 :ğ
idx_m©ch


427 
io
.
»fl
 :ğ
	`»flMux
(io.
mem_g¿Á
.
b™s
.
sourû
)

429 
v®
 
ä“_sdq
 = 
io
.
»¶ay
.
	`fœe
(è&& 
	`isWr™e
(io.»¶ay.
b™s
.
cmd
)

430 
io
.
»¶ay
.
b™s
.
d©a
 :ğ
	`sdq
(
	`RegEÇbË
(
»¶ay_¬b
.io.
out
.b™s.
sdq_id
, 
ä“_sdq
))

431 
io
.
»¶ay
 <> 
»¶ay_¬b
.io.
out


433 
	`wh’
 (
io
.
»¶ay
.
v®id
 || 
sdq_’q
) {

434 
sdq_v®
 :ğsdq_v® & ~(
	`UIÁToOH
(
»¶ay_¬b
.
io
.
out
.
b™s
.
sdq_id
è& 
	`Fl
(
cfg
.
nSDQ
, 
ä“_sdq
)) |

435 
	`PriÜ™yEncod”OH
(~
	`sdq_v®
(
cfg
.
nSDQ
-1,0)è& 
	`Fl
(cfg.nSDQ, 
sdq_’q
)

437 
	}
}

439 
şass
 
	$Wr™ebackUn™
(
im¶ic™
 
edge
: 
TLEdgeOut
, 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

440 
v®
 
io
 = 
Ãw
 
BundË
 {

441 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
	`Wr™ebackReq
(
edge
.
bundË
)).
æ


442 
v®
 
m‘a_»ad
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aR—dReq
)

443 
v®
 
d©a_»q
 = 
	`Decou¶ed
(
Ãw
 
L1D©aR—dReq
)

444 
v®
 
d©a_»¥
 = 
	`B™s
(
INPUT
, 
’cRowB™s
)

445 
v®
 
»Ëa£
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËC
(
edge
.
bundË
))

448 
v®
 
»q
 = 
	`Reg
(
Ãw
 
	`Wr™ebackReq
(
edge
.
bundË
))

449 
v®
 
aùive
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

450 
v®
 
r1_d©a_»q_fœed
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

451 
v®
 
r2_d©a_»q_fœed
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

452 
v®
 
d©a_»q_út
 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
width
 = 
	`log2Up
(
»flCyşes
+1)))

453 
	`v®
 (
_
, 
Ï¡_b—t
, 
®l_b—ts_dÚe
, 
b—t_couÁ
èğ
edge
.
	`couÁ
(
io
.
»Ëa£
)

455 
io
.
»Ëa£
.
v®id
 :ğ
çl£


456 
	`wh’
 (
aùive
) {

457 
r1_d©a_»q_fœed
 :ğ
çl£


458 
r2_d©a_»q_fœed
 :ğ
r1_d©a_»q_fœed


459 
	`wh’
 (
io
.
d©a_»q
.
	`fœe
(è&& io.
m‘a_»ad
.fire()) {

460 
r1_d©a_»q_fœed
 :ğ
Œue


461 
d©a_»q_út
 := data_req_cnt + 1

463 
	`wh’
 (
r2_d©a_»q_fœed
) {

464 
io
.
»Ëa£
.
v®id
 :ğ
Œue


465 
	`wh’
(!
io
.
»Ëa£
.
»ady
) {

466 
r1_d©a_»q_fœed
 :ğ
çl£


467 
r2_d©a_»q_fœed
 :ğ
çl£


468 
d©a_»q_út
 :ğd©a_»q_úˆ- 
Mux
[
UIÁ
](
	`BoŞ
(
»flCyşes
 > 1è&& 
r1_d©a_»q_fœed
, 2, 1)

470 
	`wh’
(!
r1_d©a_»q_fœed
) {

472 
aùive
 :ğ
d©a_»q_út
 < 
	`UIÁ
(
»flCyşes
è|| !
io
.
»Ëa£
.
»ady


476 
	`wh’
 (
io
.
»q
.
	`fœe
()) {

477 
aùive
 :ğ
Œue


478 
d©a_»q_út
 := 0

479 
»q
 :ğ
io
.»q.
b™s


482 
io
.
»q
.
»ady
 :ğ!
aùive


484 
v®
 
fœe
 = 
aùive
 && 
d©a_»q_út
 < 
	`UIÁ
(
»flCyşes
)

487 
io
.
m‘a_»ad
.
v®id
 :ğ
fœe


488 
io
.
m‘a_»ad
.
b™s
.
idx
 :ğ
»q
.idx

489 
io
.
m‘a_»ad
.
b™s
.
g
 :ğ
»q
.tag

491 
io
.
d©a_»q
.
v®id
 :ğ
fœe


492 
io
.
d©a_»q
.
b™s
.
way_’
 :ğ
»q
.way_en

493 
io
.
d©a_»q
.
b™s
.
addr
 :ğ(if(
»flCyşes
 > 1)

494 
	`C©
(
»q
.
idx
, 
	`d©a_»q_út
(
	`log2Up
(
»flCyşes
)-1,0))

495 
»q
.
idx
è<< 
rowOffB™s


497 
v®
 
r_add»ss
 = 
	`C©
(
»q
.
g
,„eq.
idx
è<< 
blockOffB™s


498 
v®
 
´obeRe¥Ú£
 = 
edge
.
	`ProbeAck
(

499 
äomSourû
 = 
»q
.
sourû
,

500 
toAdd»ss
 = 
r_add»ss
,

501 
lgSize
 = 
lgCacheBlockBy‹s
,

502 
»pÜtP”missiÚs
 = 
»q
.
·¿m
,

503 
d©a
 = 
io
.
d©a_»¥
)

505 
v®
 
vŞuÁ¬yR–—£
 = 
edge
.
	`R–—£
(

506 
äomSourû
 = 
»q
.
sourû
,

507 
toAdd»ss
 = 
r_add»ss
,

508 
lgSize
 = 
lgCacheBlockBy‹s
,

509 
shrškP”missiÚs
 = 
»q
.
·¿m
,

510 
d©a
 = 
io
.
d©a_»¥
).
_2


512 
io
.
»Ëa£
.
b™s
 :ğ
	`Mux
(
»q
.
vŞuÁ¬y
, 
vŞuÁ¬yR–—£
, 
´obeRe¥Ú£
)

513 
	}
}

515 
şass
 
	$ProbeUn™
(
im¶ic™
 
edge
: 
TLEdgeOut
, 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

516 
v®
 
io
 = 
Ãw
 
BundË
 {

517 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËB
(
edge
.
bundË
)).
æ


518 
v®
 
»p
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËC
(
edge
.
bundË
))

519 
v®
 
m‘a_»ad
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aR—dReq
)

520 
v®
 
m‘a_wr™e
 = 
	`Decou¶ed
(
Ãw
 
L1M‘aWr™eReq
)

521 
v®
 
wb_»q
 = 
	`Decou¶ed
(
Ãw
 
	`Wr™ebackReq
(
edge
.
bundË
))

522 
v®
 
way_’
 = 
	`B™s
(
INPUT
, 
nWays
)

523 
v®
 
mshr_rdy
 = 
	`BoŞ
(
INPUT
)

524 
v®
 
block_¡©e
 = 
Ãw
 
	`Cl›ÁM‘ad©a
().
asIÅut


527 
	`v®
 (
s_šv®id
 :: 
s_m‘a_»ad
 :: 
s_m‘a_»¥
 :: 
s_mshr_»q
 ::

528 
s_mshr_»¥
 :: 
s_»Ëa£
 :: 
s_wr™eback_»q
 :: 
s_wr™eback_»¥
 ::

529 
s_m‘a_wr™e
 :: 
N
èğ
	`Enum
(
	`UIÁ
(), 9)

530 
v®
 
¡©e
 = 
	`Reg
(
š™
=
s_šv®id
)

532 
v®
 
»q
 = 
	`Reg
(
Ãw
 
	`TLBundËB
(
edge
.
bundË
))

533 
v®
 
»q_idx
 = 
»q
.
	`add»ss
(
idxMSB
, 
idxLSB
)

534 
v®
 
»q_g
 = 
»q
.
add»ss
 >> 
uÁagB™s


536 
v®
 
way_’
 = 
	`Reg
(
	`B™s
())

537 
v®
 
g_m©ches
 = 
way_’
.
ÜR


538 
v®
 
Şd_coh
 = 
	`Reg
(
Ãw
 
Cl›ÁM‘ad©a
)

539 
v®
 
miss_coh
 = 
Cl›ÁM‘ad©a
.
ÚRe£t


540 
v®
 
»¶y_coh
 = 
	`Mux
(
g_m©ches
, 
Şd_coh
, 
miss_coh
)

541 
	`v®
 (
is_dœty
, 
»pÜt_·¿m
, 
Ãw_coh
èğ
»¶y_coh
.
	`ÚProbe
(
»q
.
·¿m
)

543 
io
.
»q
.
»ady
 :ğ
¡©e
 ==ğ
s_šv®id


544 
io
.
»p
.
v®id
 :ğ
¡©e
 ==ğ
s_»Ëa£


545 
io
.
»p
.
b™s
 :ğ
edge
.
	`ProbeAck
(
»q
, 
»pÜt_·¿m
)

547 
	`as£¹
(!
io
.
»p
.
v®id
 || !
edge
.
	`hasD©a
(io.»p.
b™s
),

550 
io
.
m‘a_»ad
.
v®id
 :ğ
¡©e
 ==ğ
s_m‘a_»ad


551 
io
.
m‘a_»ad
.
b™s
.
idx
 :ğ
»q_idx


552 
io
.
m‘a_»ad
.
b™s
.
g
 :ğ
»q_g


554 
io
.
m‘a_wr™e
.
v®id
 :ğ
¡©e
 ==ğ
s_m‘a_wr™e


555 
io
.
m‘a_wr™e
.
b™s
.
way_’
 := way_en

556 
io
.
m‘a_wr™e
.
b™s
.
idx
 :ğ
»q_idx


557 
io
.
m‘a_wr™e
.
b™s
.
d©a
.
g
 :ğ
»q_g


558 
io
.
m‘a_wr™e
.
b™s
.
d©a
.
coh
 :ğ
Ãw_coh


560 
io
.
wb_»q
.
v®id
 :ğ
¡©e
 ==ğ
s_wr™eback_»q


561 
io
.
wb_»q
.
b™s
.
sourû
 :ğ
»q
.source

562 
io
.
wb_»q
.
b™s
.
idx
 :ğ
»q_idx


563 
io
.
wb_»q
.
b™s
.
g
 :ğ
»q_g


564 
io
.
wb_»q
.
b™s
.
·¿m
 :ğ
»pÜt_·¿m


565 
io
.
wb_»q
.
b™s
.
way_’
 := way_en

566 
io
.
wb_»q
.
b™s
.
vŞuÁ¬y
 :ğ
	`BoŞ
(
çl£
)

569 
	`wh’
 (
io
.
»q
.
	`fœe
()) {

570 
¡©e
 :ğ
s_m‘a_»ad


571 
»q
 :ğ
io
.»q.
b™s


575 
	`wh’
 (
io
.
m‘a_»ad
.
	`fœe
()) {

576 
¡©e
 :ğ
s_m‘a_»¥


580 
	`wh’
 (
¡©e
 ==ğ
s_m‘a_»¥
) {

581 
¡©e
 :ğ
s_mshr_»q


584 
	`wh’
 (
¡©e
 ==ğ
s_mshr_»q
) {

585 
Şd_coh
 :ğ
io
.
block_¡©e


586 
way_’
 :ğ
io
.way_en

588 
¡©e
 :ğ
	`Mux
(
io
.
mshr_rdy
, 
s_mshr_»¥
, 
s_m‘a_»ad
)

591 
	`wh’
 (
¡©e
 ==ğ
s_mshr_»¥
) {

592 
¡©e
 :ğ
	`Mux
(
g_m©ches
 && 
is_dœty
, 
s_wr™eback_»q
, 
s_»Ëa£
)

595 
	`wh’
 (
¡©e
 ==ğ
s_»Ëa£
 && 
io
.
»p
.
»ady
) {

596 
¡©e
 :ğ
	`Mux
(
g_m©ches
, 
s_m‘a_wr™e
, 
s_šv®id
)

600 
	`wh’
 (
io
.
wb_»q
.
	`fœe
()) {

601 
¡©e
 :ğ
s_wr™eback_»¥


605 
	`wh’
 (
¡©e
 ==ğ
s_wr™eback_»¥
 && 
io
.
wb_»q
.
»ady
) {

606 
¡©e
 :ğ
s_m‘a_wr™e


609 
	`wh’
 (
io
.
m‘a_wr™e
.
	`fœe
()) {

610 
¡©e
 :ğ
s_šv®id


612 
	}
}

614 şas 
	cD©aA¼ay
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$L1H–ÏCacheModuË
()(
p
) {

615 
v®
 
io
 = 
Ãw
 
BundË
 {

616 
v®
 
»ad
 = 
	`Decou¶ed
(
Ãw
 
L1D©aR—dReq
).
æ


617 
v®
 
wr™e
 = 
	`Decou¶ed
(
Ãw
 
L1D©aWr™eReq
).
æ


618 
v®
 
»¥
 = 
	`Vec
(
nWays
, 
	`B™s
(
OUTPUT
, 
’cRowB™s
))

621 
v®
 
waddr
 = 
io
.
wr™e
.
b™s
.
addr
 >> 
rowOffB™s


622 
v®
 
¿ddr
 = 
io
.
»ad
.
b™s
.
addr
 >> 
rowOffB™s


624 ià(
doN¬rowR—d
) {

625 
w
 <- 0 
uÁ
 
nWays
 
by
 
rowWÜds
) {

626 
v®
 
wway_’
 = 
io
.
wr™e
.
b™s
.
	`way_’
(
w
+
rowWÜds
-1,w)

627 
v®
 
rway_’
 = 
io
.
»ad
.
b™s
.
	`way_’
(
w
+
rowWÜds
-1,w)

628 
v®
 
»¥
 = 
	`Wœe
(
	`Vec
(
rowWÜds
, 
	`B™s
(
width
 = 
’cRowB™s
)))

629 
v®
 
r_¿ddr
 = 
	`RegEÇbË
(
io
.
»ad
.
b™s
.
addr
, io.»ad.
v®id
)

630 
i
 <- 0 
uÁ
 
»¥
.
size
) {

631 
v®
 
¬¿y
 = 
	`DesüibedSRAM
(

632 
Çme
 = 
s
"array_${w}_${i}",

633 
desc
 = "Non-blocking DCache Data Array",

634 
size
 = 
nS‘s
 * 
»flCyşes
,

635 
d©a
 = 
	`Vec
(
rowWÜds
, 
	`B™s
(
width
=
’cD©aB™s
))

637 
	`wh’
 (
wway_’
.
ÜR
 && 
io
.
wr™e
.
v®id
 && io.wr™e.
b™s
.
	`wmask
(
i
)) {

638 
v®
 
d©a
 = 
Vec
.
	`fl
(
rowWÜds
)(
io
.
wr™e
.
b™s
.
	`d©a
(
’cD©aB™s
*(
i
+1)-1,encDataBits*i))

639 
¬¿y
.
	`wr™e
(
waddr
, 
d©a
, 
wway_’
.
toBoŞs
)

641 
	`»¥
(
i
è:ğ
¬¿y
.
	`»ad
(
¿ddr
, 
rway_’
.
ÜR
 && 
io
.
»ad
.
v®id
).
asUIÁ


643 
dw
 <- 0 
uÁ
 
rowWÜds
) {

644 
v®
 
r
 = 
	`Vec
(
»¥
.
	`m­
(
	`_
(
’cD©aB™s
*(
dw
+1)-1,encDataBits*dw)))

645 
v®
 
»¥_mux
 =

646 ià(
r
.
size
 == 1)„

647 
	`Vec
(
	`r
(
	`r_¿ddr
(
rowOffB™s
-1,
wÜdOffB™s
)), 
r
.

:
_
*)

648 
io
.
	`»¥
(
w
+
dw
è:ğ
»¥_mux
.
asUIÁ


651 
	}
} {

652 
w
 <- 0 
uÁ
 
nWays
) {

653 
v®
 
¬¿y
 = 
DesüibedSRAM
(

654 
Çme
 = 
s
"array_${w}",

655 
desc
 = "Non-blocking DCache Data Array",

656 
size
 = 
nS‘s
 * 
»flCyşes
,

657 
d©a
 = 
Vec
(
rowWÜds
, 
B™s
(
width
=
’cD©aB™s
))

659 
wh’
 (
io
.
wr™e
.
b™s
.
way_’
(
w
è&& io.wr™e.
v®id
) {

660 
v®
 
d©a
 = 
Vec
.
buÏ‹
(
rowWÜds
)(
i
 => 
io
.
wr™e
.
b™s
.d©a(
’cD©aB™s
*(i+1)-1,encDataBits*i))

661 
	g¬¿y
.
wr™e
(
waddr
, 
d©a
, 
io
.wr™e.
b™s
.
wmask
.
toBoŞs
)

663 
	gio
.
»¥
(
w
è:ğ
¬¿y
.
»ad
(
¿ddr
, 
io
.»ad.
b™s
.
way_’
(wè&& io.»ad.
v®id
).
	gasUIÁ


667 
	gio
.
	g»ad
.
	g»ady
 :ğ
	$BoŞ
(
Œue
)

668 
io
.
wr™e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

669 
	}
}

671 şas 
	cNÚBlockšgDCache
(
h¬tid
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$H–ÏCache
(
h¬tid
)(
p
) {

672 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`NÚBlockšgDCacheModuË
(
this
)

675 şas 
	cNÚBlockšgDCacheModuË
(
ou‹r
: 
NÚBlockšgDCache
è
ex‹nds
 
	$H–ÏCacheModuË
(
ou‹r
) {

677 
	`»quœe
(
	$isPow2
(
nWays
))

678 
	$»quœe
(
d©aSü©ch·dSize
 == 0)

679 
	`»quœe
(!
usšgVM
 || 
uÁagB™s
 <ğ
pgIdxB™s
, 
s
"untagBits($untagBits) >…gIdxBits($pgIdxBits)")

682 
	$»quœe
(
ÿcheP¬ams
.
gCode
.
isIn¡ªûOf
[
Id’t™yCode
])

683 
v®
 
dECC
 = 
ÿcheP¬ams
.
d©aCode


685 
v®
 
wb
 = 
	$ModuË
(
Ãw
 
Wr™ebackUn™
)

686 
v®
 
´ob”
 = 
	$ModuË
(
Ãw
 
ProbeUn™
)

687 
v®
 
mshrs
 = 
	$ModuË
(
Ãw
 
MSHRFe
)

689 
io
.
ıu
.
»q
.
»ady
 :ğ
	$BoŞ
(
Œue
)

690 
v®
 
s1_v®id
 = 
	`Reg
(
Ãxt
=
io
.
ıu
.
»q
.
	`fœe
(), 
š™
=
	$BoŞ
(
çl£
))

691 
v®
 
s1_»q
 = 
	$Reg
(
io
.
ıu
.
»q
.
b™s
)

692 
v®
 
s1_v®id_masked
 = 
s1_v®id
 && !
io
.
ıu
.
s1_kl


693 
v®
 
s1_»¶ay
 = 
	`Reg
(
š™
=
	$BoŞ
(
çl£
))

694 
v®
 
s1_şk_’
 = 
	`Reg
(
	$BoŞ
())

695 
v®
 
s1_sãnû
 = 
s1_»q
.
cmd
 ==ğ
M_SFENCE


697 
v®
 
s2_v®id
 = 
	`Reg
(
Ãxt
=
s1_v®id_masked
 && !
s1_sãnû
, 
š™
=
	`BoŞ
(
çl£
)è&& !
io
.
ıu
.
s2_xıt
.
asUIÁ
.
ÜR


698 
v®
 
s2_»q
 = 
	$Reg
(
io
.
ıu
.
»q
.
b™s
)

699 
v®
 
s2_»¶ay
 = 
	`Reg
(
Ãxt
=
s1_»¶ay
, 
š™
=
	`BoŞ
(
çl£
)è&& 
s2_»q
.
cmd
 =/ğ
M_FLUSH_ALL


700 
v®
 
s2_»cyşe
 = 
	`Wœe
(
	$BoŞ
())

701 
v®
 
s2_v®id_masked
 = 
	`Wœe
(
	$BoŞ
())

703 
v®
 
s3_v®id
 = 
	`Reg
(
š™
=
	$BoŞ
(
çl£
))

704 
v®
 
s3_»q
 = 
	$Reg
(
io
.
ıu
.
»q
.
b™s
)

705 
v®
 
s3_way
 = 
	`Reg
(
	$B™s
())

707 
v®
 
s1_»cyşed
 = 
	`RegEÇbË
(
s2_»cyşe
, 
	`BoŞ
(
çl£
), 
s1_şk_’
)

708 
v®
 
s1_»ad
 = 
	$isR—d
(
s1_»q
.
cmd
)

709 
v®
 
s1_wr™e
 = 
	$isWr™e
(
s1_»q
.
cmd
)

710 
v®
 
s1_»adwr™e
 = 
s1_»ad
 || 
s1_wr™e
 || 
	$isP»ãtch
(
s1_»q
.
cmd
)

712 
	`as£¹
(!
s1_v®id
 || !
s1_»q
.
cmd
.
	$isOÃOf
(
M_PWR
))

714 
v®
 
db
 = 
	`ModuË
(
Ãw
 
	`TLB
(
çl£
, 
	`log2Ce
(
cÜeD©aBy‹s
), 
	$TLBCÚfig
(
nTLBEÁr›s
)))

715 
io
.
±w
 <> 
db
.io.ptw

716 
db
.
io
.
kl
 :ğio.
ıu
.
s2_kl


717 
db
.
io
.
»q
.
v®id
 :ğ
s1_v®id
 && !io.
ıu
.
s1_kl
 && 
s1_»adwr™e


718 
db
.
io
.
»q
.
b™s
.
·s¡hrough
 :ğ
s1_»q
.
phys


719 
db
.
io
.
»q
.
b™s
.
vaddr
 :ğ
s1_»q
.
addr


720 
db
.
io
.
»q
.
b™s
.
size
 :ğ
s1_»q
.
typ


721 
db
.
io
.
»q
.
b™s
.
cmd
 :ğ
s1_»q
.cmd

722 
	`wh’
 (!
db
.
io
.
»q
.
»ady
 && !io.
ıu
.»q.
b™s
.
phys
è{ io.ıu.»q.»ady :ğ
	`BoŞ
(
çl£
) }

724 
db
.
io
.
sãnû
.
v®id
 :ğ
s1_v®id
 && !io.
ıu
.
s1_kl
 && 
s1_sãnû


725 
db
.
io
.
sãnû
.
b™s
.
rs1
 :ğ
s1_»q
.
	$typ
(0)

726 
db
.
io
.
sãnû
.
b™s
.
rs2
 :ğ
s1_»q
.
	$typ
(1)

727 
db
.
io
.
sãnû
.
b™s
.
addr
 :ğ
s1_»q
.addr

728 
db
.
io
.
sãnû
.
b™s
.
asid
 :ğio.
ıu
.
s1_d©a
.
d©a


730 
	$wh’
 (
io
.
ıu
.
»q
.
v®id
) {

731 
s1_»q
 :ğ
io
.
ıu
.
»q
.
b™s


732 
	}
}

733 
	$wh’
 (
wb
.
io
.
m‘a_»ad
.
v®id
) {

734 
s1_»q
.
addr
 :ğ
	`C©
(
wb
.
io
.
m‘a_»ad
.
b™s
.
g
, wb.io.m‘a_»ad.b™s.
idx
è<< 
blockOffB™s


735 
s1_»q
.
phys
 :ğ
	`BoŞ
(
Œue
)

736 
	}
}

737 
	$wh’
 (
´ob”
.
io
.
m‘a_»ad
.
v®id
) {

738 
s1_»q
.
addr
 :ğ
	`C©
(
´ob”
.
io
.
m‘a_»ad
.
b™s
.
g
,…rob”.io.m‘a_»ad.b™s.
idx
è<< 
blockOffB™s


739 
s1_»q
.
phys
 :ğ
	`BoŞ
(
Œue
)

740 
	}
}

741 
	$wh’
 (
mshrs
.
io
.
»¶ay
.
v®id
) {

742 
s1_»q
 :ğ
mshrs
.
io
.
»¶ay
.
b™s


743 
	}
}

744 
	$wh’
 (
s2_»cyşe
) {

745 
s1_»q
 :ğ
s2_»q


746 
	}
}

747 
v®
 
s1_addr
 = 
db
.
io
.
»¥
.
·ddr


749 
	$wh’
 (
s1_şk_’
) {

750 
s2_»q
.
typ
 :ğ
s1_»q
.typ

751 
s2_»q
.
phys
 :ğ
s1_»q
.phys

752 
s2_»q
.
addr
 :ğ
s1_addr


753 
	`wh’
 (
s1_wr™e
) {

754 
s2_»q
.
d©a
 :ğ
	`Mux
(
s1_»¶ay
, 
mshrs
.
io
.
»¶ay
.
b™s
.d©a, io.
ıu
.
s1_d©a
.data)

756 
	`wh’
 (
s1_»cyşed
è{ 
s2_»q
.
d©a
 :ğ
s1_»q
.data }

757 
s2_»q
.
g
 :ğ
s1_»q
.tag

758 
s2_»q
.
cmd
 :ğ
s1_»q
.cmd

759 
	}
}

762 
def
 
ÚRe£t
 = 
L1M‘ad©a
(
UIÁ
(0), 
Cl›ÁM‘ad©a
.onReset)

763 
v®
 
	gm‘a
 = 
ModuË
(
Ãw
 
	$L1M‘ad©aA¼ay
(
ÚRe£t
 
_
))

764 
v®
 
m‘aR—dArb
 = 
	`ModuË
(
Ãw
 
	$Arb™”
(
Ãw
 
L1M‘aR—dReq
, 5))

765 
v®
 
m‘aWr™eArb
 = 
	`ModuË
(
Ãw
 
	$Arb™”
(
Ãw
 
L1M‘aWr™eReq
, 2))

766 
m‘a
.
io
.
»ad
 <> 
m‘aR—dArb
.io.
out


767 
m‘a
.
io
.
wr™e
 <> 
m‘aWr™eArb
.io.
out


770 
v®
 
d©a
 = 
	$ModuË
(
Ãw
 
D©aA¼ay
)

771 
v®
 
»adArb
 = 
	`ModuË
(
Ãw
 
	$Arb™”
(
Ãw
 
L1D©aR—dReq
, 4))

772 
v®
 
wr™eArb
 = 
	`ModuË
(
Ãw
 
	$Arb™”
(
Ãw
 
L1D©aWr™eReq
, 2))

773 
d©a
.
io
.
wr™e
.
v®id
 :ğ
wr™eArb
.io.
out
.valid

774 
wr™eArb
.
io
.
out
.
»ady
 :ğ
d©a
.io.
wr™e
.ready

775 
d©a
.
io
.
wr™e
.
b™s
 :ğ
wr™eArb
.io.
out
.bits

776 
v®
 
wd©a_’coded
 = (0 
uÁ
 
rowWÜds
).
	`m­
(
i
 => 
dECC
.
	`’code
(
wr™eArb
.
io
.
out
.
b™s
.
	`d©a
(
cÜeD©aB™s
*(i+1)-1,coreDataBits*i)))

777 
d©a
.
io
.
wr™e
.
b™s
.d©¨:ğ
wd©a_’coded
.
asUIÁ


780 
m‘aR—dArb
.
io
.
	`š
(4).
v®id
 :ğio.
ıu
.
»q
.valid

781 
m‘aR—dArb
.
io
.
	`š
(4).
b™s
.
idx
 :ğio.
ıu
.
»q
.b™s.
addr
 >> 
blockOffB™s


782 
	`wh’
 (!
m‘aR—dArb
.
io
.
	`š
(4).
»ady
è{ io.
ıu
.
»q
.»ady :ğ
	`BoŞ
(
çl£
è
	}
}

785 
»adArb
.
io
.
š
(3).
v®id
 :ğio.
ıu
.
»q
.valid

786 
»adArb
.
io
.
š
(3).
b™s
.
addr
 :ğio.
ıu
.
»q
.bits.addr

787 
»adArb
.
io
.
š
(3).
b™s
.
way_’
 :ğ~
	$UIÁ
(0, 
nWays
)

788 
	`wh’
 (!
»adArb
.
io
.
	`š
(3).
»ady
è{ io.
ıu
.
»q
.»ady :ğ
	`BoŞ
(
çl£
è
	}
}

791 
m‘aR—dArb
.
io
.
š
(0).
v®id
 :ğ
s2_»cyşe


792 
m‘aR—dArb
.
io
.
š
(0).
b™s
.
idx
 :ğ
s2_»q
.
addr
 >> 
blockOffB™s


793 
»adArb
.
io
.
š
(0).
v®id
 :ğ
s2_»cyşe


794 
»adArb
.
io
.
š
(0).
b™s
.
addr
 :ğ
s2_»q
.addr

795 
»adArb
.
io
.
š
(0).
b™s
.
way_’
 :ğ~
	$UIÁ
(0, 
nWays
)

798 
def
 
wayM­
[
T
 <: 
D©a
](
f
: 
IÁ
 => Tèğ
	`Vec
((0 
uÁ
 
nWays
).
	$m­
(
f
))

799 
v®
 
s1_g_eq_way
 = 
	`wayM­
((
w
: 
IÁ
è=> 
m‘a
.
io
.
	`»¥
(w).
g
 ==ğ(
s1_addr
 >> 
uÁagB™s
)).
asUIÁ


800 
v®
 
s1_g_m©ch_way
 = 
	`wayM­
((
w
: 
IÁ
è=> 
	`s1_g_eq_way
(wè&& 
m‘a
.
io
.
	`»¥
(w).
coh
.
	`isV®id
()).
asUIÁ


801 
s1_şk_’
 :ğ
m‘aR—dArb
.
io
.
out
.
v®id


802 
v®
 
s1_wr™eback
 = 
s1_şk_’
 && !
s1_v®id
 && !
s1_»¶ay


803 
v®
 
s2_g_m©ch_way
 = 
	$RegEÇbË
(
s1_g_m©ch_way
, 
s1_şk_’
)

804 
v®
 
s2_g_m©ch
 = 
s2_g_m©ch_way
.
ÜR


805 
v®
 
s2_h™_¡©e
 = 
	`Mux1H
(
s2_g_m©ch_way
, 
	`wayM­
((
w
: 
IÁ
è=> 
	`RegEÇbË
(
m‘a
.
io
.
	`»¥
(w).
coh
, 
s1_şk_’
)))

806 
	`v®
 (
s2_has_³rmissiÚ
, 
_
, 
s2_Ãw_h™_¡©e
èğ
s2_h™_¡©e
.
	$ÚAcûss
(
s2_»q
.
cmd
)

807 
v®
 
s2_h™
 = 
s2_g_m©ch
 && 
s2_has_³rmissiÚ
 && 
s2_h™_¡©e
 ==ğ
s2_Ãw_h™_¡©e


810 
v®
 
Ìsc_couÁ
 = 
	`Reg
(
š™
=
	$UIÁ
(0))

811 
v®
 
Ìsc_v®id
 = 
Ìsc_couÁ
 > 
ÌscBackoff


812 
v®
 
Ìsc_addr
 = 
	`Reg
(
	$UIÁ
())

813 
	`v®
 (
s2_Ì
, 
s2_sc
èğ(
s2_»q
.
cmd
 ==ğ
M_XLR
, s2_»q.cmd ==ğ
M_XSC
)

814 
v®
 
s2_Ìsc_addr_m©ch
 = 
Ìsc_v®id
 && 
Ìsc_addr
 ==ğ(
s2_»q
.
addr
 >> 
blockOffB™s
)

815 
v®
 
s2_sc_ç
 = 
s2_sc
 && !
s2_Ìsc_addr_m©ch


816 
	`wh’
 (
Ìsc_couÁ
 > 0è{†rsc_couÁ :ğÌsc_couÁ - 1 
	}
}

817 
wh’
 (
s2_v®id_masked
 && 
s2_h™
 || 
s2_»¶ay
) {

818 
wh’
 (
s2_Ì
) {

819 
Ìsc_couÁ
 :ğ
ÌscCyşes
 - 1

820 
Ìsc_addr
 :ğ
s2_»q
.
addr
 >> 
blockOffB™s


822 
wh’
 (
Ìsc_couÁ
 > 0) {

823 
Ìsc_couÁ
 := 0

827 
v®
 
s2_d©a
 = 
Wœe
(
Vec
(
nWays
, 
	$B™s
(
width
=
’cRowB™s
)))

828 
w
 <- 0 
uÁ
 
nWays
) {

829 
v®
 
»gs
 = 
	`Reg
(
	`Vec
(
rowWÜds
, 
	`B™s
(
width
 = 
’cD©aB™s
)))

830 
v®
 
’1
 = 
s1_şk_’
 && 
	`s1_g_eq_way
(
w
)

831 
i
 <- 0 
uÁ
 
»gs
.
size
) {

832 
v®
 
’
 = 
’1
 && ((
	`BoŞ
(
i
 =ğ0è|| !BoŞ(
doN¬rowR—d
)è|| 
s1_wr™eback
)

833 
	`wh’
 (
’
è{ 
	`»gs
(
i
è:ğ
d©a
.
io
.
	`»¥
(
w
è>> 
’cD©aB™s
*i }

835 
	`s2_d©a
(
w
è:ğ
»gs
.
asUIÁ


836 
	}
}

837 
v®
 
s2_d©a_muxed
 = 
	$Mux1H
(
s2_g_m©ch_way
, 
s2_d©a
)

838 
v®
 
s2_d©a_decoded
 = (0 
uÁ
 
rowWÜds
).
	`m­
(
i
 => 
dECC
.
	`decode
(
	`s2_d©a_muxed
(
’cD©aB™s
*(i+1)-1,encDataBits*i)))

839 
v®
 
s2_d©a_cÜ»ùed
 = 
s2_d©a_decoded
.
	`m­
(
_
.
cÜ»ùed
).
asUIÁ


840 
v®
 
s2_d©a_uncÜ»ùed
 = 
s2_d©a_decoded
.
	`m­
(
_
.
uncÜ»ùed
).
asUIÁ


841 
v®
 
s2_wÜd_idx
 = if(
doN¬rowR—d
è
	$UIÁ
(0è
s2_»q
.
	`addr
(
	`log2Up
(
rowWÜds
*
cÜeD©aBy‹s
)-1,
	$log2Up
(
wÜdBy‹s
))

842 
v®
 
s2_d©a_cÜ»ùabË
 = 
s2_d©a_decoded
.
	`m­
(
_
.
cÜ»ùabË
).
	$asUIÁ
()(
s2_wÜd_idx
)

845 
s3_v®id
 :ğ(
s2_v®id_masked
 && 
s2_h™
 || 
s2_»¶ay
è&& !
s2_sc_ç
 && 
	$isWr™e
(
s2_»q
.
cmd
)

846 
v®
 
amßlu
 = 
	`ModuË
(
Ãw
 
	$AMOALU
(
xL’
))

847 
	`wh’
 ((
s2_v®id
 || 
s2_»¶ay
è&& (
	`isWr™e
(
s2_»q
.
cmd
è|| 
s2_d©a_cÜ»ùabË
)) {

848 
s3_»q
 :ğ
s2_»q


849 
s3_»q
.
d©a
 :ğ
	`Mux
(
s2_d©a_cÜ»ùabË
, 
s2_d©a_cÜ»ùed
, 
amßlu
.
io
.
out
)

850 
s3_way
 :ğ
s2_g_m©ch_way


851 
	}
}

853 
wr™eArb
.
io
.
š
(0).
b™s
.
addr
 :ğ
s3_»q
.addr

854 
wr™eArb
.
io
.
š
(0).
b™s
.
wmask
 :ğ
UIÁToOH
(
s3_»q
.
addr
.
exŒaù
(
rowOffB™s
-1,
off£sb
))

855 
	gwr™eArb
.
	gio
.
š
(0).
	gb™s
.
	gd©a
 :ğ
	$Fl
(
rowWÜds
, 
s3_»q
.
d©a
)

856 
wr™eArb
.
io
.
	`š
(0).
v®id
 :ğ
s3_v®id


857 
wr™eArb
.
io
.
	`š
(0).
b™s
.
way_’
 :ğ
s3_way


860 
v®
 
»¶aûr
 = 
ÿcheP¬ams
.
»¶aûm’t


861 
v®
 
s1_»¶aûd_way_’
 = 
	$UIÁToOH
(
»¶aûr
.
way
)

862 
v®
 
s2_»¶aûd_way_’
 = 
	`UIÁToOH
(
	$RegEÇbË
(
»¶aûr
.
way
, 
s1_şk_’
))

863 
v®
 
s2_»¶_m‘a
 = 
	`Mux1H
(
s2_»¶aûd_way_’
, 
	`wayM­
((
w
: 
IÁ
è=> 
	`RegEÇbË
(
m‘a
.
io
.
	`»¥
(w), 
s1_şk_’
 && 
	`s1_»¶aûd_way_’
(w))).
toSeq
)

866 
mshrs
.
io
.
»q
.
v®id
 :ğ
s2_v®id_masked
 && !
s2_h™
 && (
	`isP»ãtch
(
s2_»q
.
cmd
è|| 
	`isR—d
(s2_»q.cmdè|| 
	$isWr™e
(
s2_»q
.
cmd
))

867 
mshrs
.
io
.
»q
.
b™s
 :ğ
s2_»q


868 
mshrs
.
io
.
»q
.
b™s
.
g_m©ch
 :ğ
s2_g_m©ch


869 
mshrs
.
io
.
»q
.
b™s
.
Şd_m‘a
 :ğ
	`Mux
(
s2_g_m©ch
, 
	`L1M‘ad©a
(
s2_»¶_m‘a
.
g
, 
s2_h™_¡©e
), s2_repl_meta)

870 
mshrs
.
io
.
»q
.
b™s
.
way_’
 :ğ
	$Mux
(
s2_g_m©ch
, 
s2_g_m©ch_way
, 
s2_»¶aûd_way_’
)

871 
mshrs
.
io
.
»q
.
b™s
.
d©a
 :ğ
s2_»q
.data

872 
	`wh’
 (
mshrs
.
io
.
»q
.
	$fœe
()è{ 
»¶aûr
.
miss
 
	}
}

873 
_out
.
a
 <> 
mshrs
.
io
.
mem_acquœe


876 
»adArb
.
io
.
š
(1).
v®id
 :ğ
mshrs
.io.
»¶ay
.valid

877 
»adArb
.
io
.
š
(1).
b™s
 :ğ
mshrs
.io.
»¶ay
.bits

878 
»adArb
.
io
.
š
(1).
b™s
.
way_’
 :ğ~
	$UIÁ
(0, 
nWays
)

879 
mshrs
.
io
.
»¶ay
.
»ady
 :ğ
»adArb
.io.
	`š
(1).ready

880 
s1_»¶ay
 :ğ
mshrs
.
io
.
»¶ay
.
v®id
 && 
»adArb
.io.
	`š
(1).
»ady


881 
m‘aR—dArb
.
io
.
	`š
(1è<> 
mshrs
.io.
m‘a_»ad


882 
m‘aWr™eArb
.
io
.
	`š
(0è<> 
mshrs
.io.
m‘a_wr™e


885 
´ob”
.
io
.
»q
.
v®id
 :ğ
_out
.
b
.v®id && !
Ìsc_v®id


886 
_out
.
b
.
»ady
 :ğ
´ob”
.
io
.
»q
.»ady && !
Ìsc_v®id


887 
´ob”
.
io
.
»q
.
b™s
 :ğ
_out
.
b
.bits

888 
´ob”
.
io
.
way_’
 :ğ
s2_g_m©ch_way


889 
´ob”
.
io
.
block_¡©e
 :ğ
s2_h™_¡©e


890 
m‘aR—dArb
.
io
.
	`š
(2è<> 
´ob”
.io.
m‘a_»ad


891 
m‘aWr™eArb
.
io
.
	`š
(1è<> 
´ob”
.io.
m‘a_wr™e


892 
´ob”
.
io
.
mshr_rdy
 :ğ
mshrs
.io.
´obe_rdy


895 
v®
 
g¿Á_has_d©a
 = 
edge
.
	$hasD©a
(
_out
.
d
.
b™s
)

896 
mshrs
.
io
.
mem_g¿Á
.
v®id
 :ğ
_out
.
d
.
	$fœe
()

897 
mshrs
.
io
.
mem_g¿Á
.
b™s
 :ğ
_out
.
d
.bits

898 
_out
.
d
.
»ady
 :ğ
wr™eArb
.
io
.
	`š
(1).»ady || !
g¿Á_has_d©a


902 
wr™eArb
.
io
.
	`š
(1).
v®id
 :ğ
_out
.
d
.v®id && 
g¿Á_has_d©a
 &&

903 
_out
.
d
.
b™s
.
sourû
 < 
	$UIÁ
(
cfg
.
nMSHRs
)

904 
wr™eArb
.
io
.
	`š
(1).
b™s
.
addr
 :ğ
mshrs
.io.
»fl
.addr

905 
wr™eArb
.
io
.
	`š
(1).
b™s
.
way_’
 :ğ
mshrs
.io.
»fl
.way_en

906 
wr™eArb
.
io
.
	`š
(1).
b™s
.
wmask
 :ğ~
	$UIÁ
(0, 
rowWÜds
)

907 
wr™eArb
.
io
.
	`š
(1).
b™s
.
d©a
 :ğ
_out
.
d
.b™s.
	`d©a
(
’cRowB™s
-1,0)

908 
d©a
.
io
.
»ad
 <> 
»adArb
.io.
out


909 
»adArb
.
io
.
out
.
»ady
 :ğ!
_out
.
d
.
v®id
 ||l_out.d.ready

910 
_out
.
e
 <> 
mshrs
.
io
.
mem_fšish


913 
v®
 
wbArb
 = 
	`ModuË
(
Ãw
 
	`Arb™”
Òew 
	`Wr™ebackReq
(
edge
.
bundË
), 2))

914 
wbArb
.
io
.
	`š
(0è<> 
´ob”
.io.
wb_»q


915 
wbArb
.
io
.
	`š
(1è<> 
mshrs
.io.
wb_»q


916 
wb
.
io
.
»q
 <> 
wbArb
.io.
out


917 
m‘aR—dArb
.
io
.
	`š
(3è<> 
wb
.io.
m‘a_»ad


918 
»adArb
.
io
.
	`š
(2è<> 
wb
.io.
d©a_»q


919 
wb
.
io
.
d©a_»¥
 :ğ
s2_d©a_cÜ»ùed


920 
TLArb™”
.
	$lowe¡
(
edge
, 
_out
.
c
, 
wb
.
io
.
»Ëa£
, 
´ob”
.io.
»p
)

923 
v®
 
s4_v®id
 = 
	`Reg
(
Ãxt
=
s3_v®id
, 
š™
=
	$BoŞ
(
çl£
))

924 
v®
 
s4_»q
 = 
	$RegEÇbË
(
s3_»q
, 
s3_v®id
 && 
m‘aR—dArb
.
io
.
out
.
v®id
)

925 
v®
 
by·s£s
 = 
	`Li¡
(

926 ((
s2_v®id_masked
 || 
s2_»¶ay
è&& !
s2_sc_ç
, 
s2_»q
, 
amßlu
.
io
.
out
),

927 (
s3_v®id
, 
s3_»q
, s3_»q.
d©a
),

928 (
s4_v®id
, 
s4_»q
, s4_»q.
d©a
)

929 ).
	`m­
(
r
 => (r.
_1
 && (
s1_addr
 >> 
wÜdOffB™s
 ==ğr.
_2
.
addr
 >> wÜdOffB™sè&& 
	`isWr™e
Ô._2.
cmd
),„.
_3
))

930 
v®
 
s2_¡Üe_by·ss_d©a
 = 
	`Reg
(
	$B™s
(
width
 = 
cÜeD©aB™s
))

931 
v®
 
s2_¡Üe_by·ss
 = 
	`Reg
(
	$BoŞ
())

932 
	$wh’
 (
s1_şk_’
) {

933 
s2_¡Üe_by·ss
 :ğ
çl£


934 
	`wh’
 (
by·s£s
.
	`m­
(
_
.
_1
).
	`»duû
(_||_)) {

935 
s2_¡Üe_by·ss_d©a
 :ğ
	`PriÜ™yMux
(
by·s£s
)

936 
s2_¡Üe_by·ss
 :ğ
Œue


938 
	}
}

941 
v®
 
s2_d©a_wÜd_´eby·ss
 = 
s2_d©a_uncÜ»ùed
 >> 
C©
(
s2_wÜd_idx
, 
B™s
(0,
	$log2Up
(
cÜeD©aB™s
)))

942 
v®
 
s2_d©a_wÜd
 = 
	$Mux
(
s2_¡Üe_by·ss
, 
s2_¡Üe_by·ss_d©a
, 
s2_d©a_wÜd_´eby·ss
)

943 
v®
 
lßdg’
 = 
Ãw
 
	`LßdG’
(
s2_»q
.
typ
, 
	`mtSigÃd
(s2_»q.typ), s2_»q.
addr
, 
s2_d©a_wÜd
, 
s2_sc
, 
wÜdBy‹s
)

945 
amßlu
.
io
.
mask
 :ğ
Ãw
 
	`StÜeG’
(
s2_»q
.
typ
, s2_»q.
addr
, 0.U, 
xL’
/8).mask

946 
amßlu
.
io
.
cmd
 :ğ
s2_»q
.cmd

947 
amßlu
.
io
.
lhs
 :ğ
s2_d©a_wÜd


948 
amßlu
.
io
.
rhs
 :ğ
s2_»q
.
d©a


951 
v®
 
s1_Çck
 = 
db
.
io
.
»q
.
v®id
 && db.io.
»¥
.
miss
 ||

952 
s1_»q
.
	`addr
(
idxMSB
,
idxLSB
è==ğ
´ob”
.
io
.
m‘a_wr™e
.
b™s
.
idx
 && !´ob”.io.
»q
.
»ady


953 
v®
 
s2_Çck_h™
 = 
	`RegEÇbË
(
s1_Çck
, 
s1_v®id
 || 
s1_»¶ay
)

954 
	$wh’
 (
s2_Çck_h™
è{ 
mshrs
.
io
.
»q
.
v®id
 :ğ
	`BoŞ
(
çl£
è
	}
}

955 
v®
 
s2_Çck_viùim
 = 
s2_h™
 && 
mshrs
.
io
.
£cÚd¬y_miss


956 
v®
 
s2_Çck_miss
 = !
s2_h™
 && !
mshrs
.
io
.
»q
.
»ady


957 
v®
 
s2_Çck
 = 
s2_Çck_h™
 || 
s2_Çck_viùim
 || 
s2_Çck_miss


958 
s2_v®id_masked
 :ğ
s2_v®id
 && !
s2_Çck
 && !
io
.
ıu
.
s2_kl


960 
v®
 
s2_»cyşe_ecc
 = (
s2_v®id
 || 
s2_»¶ay
è&& 
s2_h™
 && 
s2_d©a_cÜ»ùabË


961 
v®
 
s2_»cyşe_Ãxt
 = 
Reg
(
š™
=
	$BoŞ
(
çl£
))

962 
	`wh’
 (
s1_v®id
 || 
s1_»¶ay
è{ 
s2_»cyşe_Ãxt
 :ğ
s2_»cyşe_ecc
 
	}
}

963 
s2_»cyşe
 :ğ
s2_»cyşe_ecc
 || 
s2_»cyşe_Ãxt


966 
v®
 
block_miss
 = 
Reg
(
š™
=
	$BoŞ
(
çl£
))

967 
block_miss
 :ğ(
s2_v®id
 || block_missè&& 
s2_Çck_miss


968 
	$wh’
 (
block_miss
) {

969 
io
.
ıu
.
»q
.
»ady
 :ğ
	`BoŞ
(
çl£
)

970 
	}
}

972 
v®
 
ÿche_»¥
 = 
Wœe
(
	$V®id
(
Ãw
 
H–ÏCacheRe¥
))

973 
ÿche_»¥
.
v®id
 :ğ(
s2_»¶ay
 || 
s2_v®id_masked
 && 
s2_h™
è&& !
s2_d©a_cÜ»ùabË


974 
ÿche_»¥
.
b™s
 :ğ
s2_»q


975 
ÿche_»¥
.
b™s
.
has_d©a
 :ğ
	$isR—d
(
s2_»q
.
cmd
)

976 
ÿche_»¥
.
b™s
.
d©a
 :ğ
lßdg’
.d©¨| 
s2_sc_ç


977 
ÿche_»¥
.
b™s
.
¡Üe_d©a
 :ğ
s2_»q
.
d©a


978 
ÿche_»¥
.
b™s
.
»¶ay
 :ğ
s2_»¶ay


980 
v®
 
unÿche_»¥
 = 
	`Wœe
(
	$V®id
(
Ãw
 
H–ÏCacheRe¥
))

981 
unÿche_»¥
.
b™s
 :ğ
mshrs
.
io
.
»¥
.bits

982 
unÿche_»¥
.
v®id
 :ğ
mshrs
.
io
.
»¥
.valid

983 
mshrs
.
io
.
»¥
.
»ady
 :ğ
	`Reg
(
Ãxt
ğ!(
s1_v®id
 || 
s1_»¶ay
))

985 
io
.
ıu
.
s2_Çck
 :ğ
s2_v®id
 && s2_nack

986 
io
.
ıu
.
»¥
 :ğ
	$Mux
(
mshrs
.
io
.
»¥
.
»ady
, 
unÿche_»¥
, 
ÿche_»¥
)

987 
io
.
ıu
.
»¥
.
b™s
.
d©a_wÜd_by·ss
 :ğ
lßdg’
.
wÜdD©a


988 
io
.
ıu
.
»¥
.
b™s
.
d©a_¿w
 :ğ
s2_d©a_wÜd


989 
io
.
ıu
.
Üd”ed
 :ğ
mshrs
.io.
ãnû_rdy
 && !
s1_v®id
 && !
s2_v®id


990 
io
.
ıu
.
»¶ay_Ãxt
 :ğ(
s1_»¶ay
 && 
s1_»ad
è|| 
mshrs
.io.replay_next

992 
v®
 
s1_xıt_v®id
 = 
db
.
io
.
»q
.
v®id
 && !
s1_Çck


993 
v®
 
s1_xıt
 = 
db
.
io
.
»¥


994 
io
.
ıu
.
s2_xıt
 :ğ
	`Mux
(
	`RegNext
(
s1_xıt_v®id
), 
	`RegEÇbË
(
s1_xıt
, 
s1_şk_’
), 0.U.a
	$sTy³Of
(
s1_xıt
))

997 
io
.
ıu
.
³rf
.
acquœe
 :ğ
edge
.
	$dÚe
(
_out
.
a
)

998 
io
.
ıu
.
³rf
.
»Ëa£
 :ğ
edge
.
	$dÚe
(
_out
.
c
)

999 
io
.
ıu
.
³rf
.
bMiss
 :ğio.
±w
.
»q
.
	$fœe
()

1002 
io
.
ıu
.
şock_’abËd
 :ğ
Œue


1003 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PMP.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 şas 
	cPMPCÚfig
 
ex‹nds
 
	mBundË
 {

12 
v®
 
	ml
 = 
	$BoŞ
()

13 
v®
 
»s
 = 
	$UIÁ
(
width
 = 2)

14 
v®
 
a
 = 
	$UIÁ
(
width
 = 2)

15 
v®
 
x
 = 
	$BoŞ
()

16 
v®
 
w
 = 
	$BoŞ
()

17 
v®
 
r
 = 
	`BoŞ
()

20 
objeù
 
PMP
 {

21 
def
 
lgAlign
 = 2

23 
def
 
	`­¶y
(
»g
: 
PMPReg
): 
PMP
 = {

24 
v®
 
pmp
 = 
	`Wœe
(
Ãw
 
	`PMP
()(
»g
.
p
))

25 
pmp
 :ğ
»g


26 
pmp
.
mask
 :ğpmp.
compu‹Mask


27 
pmp


29 
	}
}

31 şas 
	cPMPReg
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

32 
v®
 
cfg
 = 
Ãw
 
PMPCÚfig


33 
v®
 
addr
 = 
	`UIÁ
(
width
 = 
·ddrB™s
 - 
PMP
.
lgAlign
)

35 
def
 
»adAddr
 = ià(
pmpG¿nuÏr™y
.
log2
 =ğ
PMP
.
lgAlign
è
addr
 {

36 
v®
 
mask
 = ((
	`BigIÁ
(1è<< (
pmpG¿nuÏr™y
.
log2
 - 
PMP
.
lgAlign
)è- 1).
U


37 
	`Mux
(
ÇpÙ
, 
addr
 | (
mask
 >> 1), ~(~addr | mask))

39 
def
 
ÇpÙ
 = 
cfg
.
	$a
(1)

40 
def
 
tÜNÙNAPOT
 = 
cfg
.
	$a
(0)

41 
def
 
tÜ
 = !
ÇpÙ
 && 
tÜNÙNAPOT


42 
def
 
cfgLocked
 = 
cfg
.
l


43 
def
 
	`addrLocked
(
Ãxt
: 
PMPReg
èğ
cfgLocked
 ||‚ext.cfgLocked &&‚ext.
tÜ


44 
	}
}

46 şas 
	cPMP
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
PMPReg
 {

47 
v®
 
mask
 = 
	$UIÁ
(
width
 = 
·ddrB™s
)

49 
impÜt
 
PMP
.
_


50 
def
 
compu‹Mask
 = {

51 
v®
 
ba£
 = 
	`C©
(
addr
, 
cfg
.
	`a
(0)è| ((
pmpG¿nuÏr™y
 - 1è>> 
lgAlign
)

52 
	`C©
(
ba£
 & ~(ba£ + 1), 
	`UIÁ
((1 << 
lgAlign
) - 1))

54 
´iv©e
 
def
 
com·¿nd
 = ~(~(
addr
 << 
lgAlign
è| (
pmpG¿nuÏr™y
 - 1))

56 
´iv©e
 
def
 
	`pow2M©ch
(
x
: 
UIÁ
, 
lgSize
: UIÁ, 
lgMaxSize
: 
IÁ
) = {

57 
def
 
	`ev®
(
a
: 
UIÁ
, 
b
: UIÁ, 
m
: UInt) = ((a ^ b) & ~m) === 0

58 ià(
lgMaxSize
 <ğ
pmpG¿nuÏr™y
.
log2
) {

59 
	`ev®
(
x
, 
com·¿nd
, 
mask
)

62 
v®
 
lsbMask
 = 
mask
 | 
	`UIÁToOH1
(
lgSize
, 
lgMaxSize
)

63 
v®
 
msbM©ch
 = 
	`ev®
(
x
 >> 
lgMaxSize
, 
com·¿nd
 >>†gMaxSize, 
mask
 >>†gMaxSize)

64 
v®
 
lsbM©ch
 = 
	`ev®
(
	`x
(
lgMaxSize
-1, 0), 
	`com·¿nd
ÖgMaxSize-1, 0), 
	`lsbMask
(lgMaxSize-1, 0))

65 
msbM©ch
 && 
lsbM©ch


67 
	}
}

69 
´iv©e
 
def
 
boundM©ch
(
x
: 
UIÁ
, 
lsbMask
: UIÁ, 
lgMaxSize
: 
IÁ
) = {

70 ià(
lgMaxSize
 <ğ
pmpG¿nuÏr™y
.
log2
) {

71 
x
 < 
com·¿nd


74 
v®
 
msbsLess
 = (
x
 >> 
lgMaxSize
è< (
com·¿nd
 >>†gMaxSize)

75 
v®
 
msbsEqu®
 = ((
x
 >> 
lgMaxSize
è^ (
com·¿nd
 >>†gMaxSize)) === 0

76 
v®
 
lsbsLess
 = (
x
(
lgMaxSize
-1, 0è| 
	glsbMask
è< 
com·¿nd
(lgMaxSize-1, 0)

77 
	gmsbsLess
 || (
	gmsbsEqu®
 && 
	glsbsLess
)

81 
´iv©e
 
def
 
low”BoundM©ch
(
x
: 
UIÁ
, 
lgSize
: UIÁ, 
lgMaxSize
: 
IÁ
) =

82 !
boundM©ch
(
x
, 
UIÁToOH1
(
lgSize
, 
lgMaxSize
),†gMaxSize)

84 
´iv©e
 
def
 
uµ”BoundM©ch
(
x
: 
UIÁ
, 
lgMaxSize
: 
IÁ
) =

85 
	$boundM©ch
(
x
, 0.U, 
lgMaxSize
)

87 
´iv©e
 
def
 
	`¿ngeM©ch
(
x
: 
UIÁ
, 
lgSize
: UIÁ, 
lgMaxSize
: 
IÁ
, 
´ev
: 
PMP
) =

88 
´ev
.
	`low”BoundM©ch
(
x
, 
lgSize
, 
lgMaxSize
è&& 
	$uµ”BoundM©ch
(
x
, 
lgMaxSize
)

90 
´iv©e
 
def
 
	`pow2Homog’eous
(
x
: 
UIÁ
, 
pgLev–
: UInt) = {

91 
v®
 
maskHomog’eous
 = 
pgLev–M­
 { 
idxB™s
 => ià(idxB™ > 
·ddrB™s
è
çl£
.
B
 
	`mask
(idxB™ - 1è} (
pgLev–
)

92 
maskHomog’eous
 || (
pgLev–M­
 { 
idxB™s
 => ((
x
 ^ 
com·¿nd
è>> idxB™sè=/ğ0 } (
pgLev–
))

93 
	}
}

95 
´iv©e
 
def
 
pgLev–M­
[
T
](
f
: 
IÁ
 => Tèğ(0 
uÁ
 
pgLev–s
).
m­
 { 
i
 =>

96 
f
(
pgIdxB™s
 + (
pgLev–s
 - 1 - 
i
è* 
pgLev–B™s
)

99 
´iv©e
 
def
 
¿ngeHomog’eous
(
x
: 
UIÁ
, 
pgLev–
: UIÁ, 
´ev
: 
PMP
) = {

100 
v®
 
begšsAá”Low”
 = !(
x
 < 
´ev
.
com·¿nd
)

101 
v®
 
begšsAá”Uµ”
 = !(
x
 < 
com·¿nd
)

103 
v®
 
pgMask
 = 
pgLev–M­
 { 
idxB™s
 => (((
BigIÁ
(1è<< 
·ddrB™s
è- (BigIÁ(1è<< idxB™s)è
max
 0).
U
 } (
pgLev–
)

104 
v®
 
’dsBefÜeLow”
 = (
x
 & 
pgMask
è< (
´ev
.
com·¿nd
 &…gMask)

105 
v®
 
’dsBefÜeUµ”
 = (
x
 & 
pgMask
è< (
com·¿nd
 &…gMask)

107 
’dsBefÜeLow”
 || 
begšsAá”Uµ”
 || (
begšsAá”Low”
 && 
’dsBefÜeUµ”
)

111 
def
 
	$homog’eous
(
x
: 
UIÁ
, 
pgLev–
: UIÁ, 
´ev
: 
PMP
): 
BoŞ
 =

112 
	`Mux
(
ÇpÙ
, 
	`pow2Homog’eous
(
x
, 
pgLev–
), !
tÜNÙNAPOT
 || 
	$¿ngeHomog’eous
(
x
, 
pgLev–
, 
´ev
))

115 
def
 
	$®igÃd
(
x
: 
UIÁ
, 
lgSize
: UIÁ, 
lgMaxSize
: 
IÁ
, 
´ev
: 
PMP
): 
BoŞ
 = iàÖgMaxSiz<ğ
pmpG¿nuÏr™y
.
log2
è
Œue
.
B
 {

116 
v®
 
lsbMask
 = 
	`UIÁToOH1
(
lgSize
, 
lgMaxSize
)

117 
v®
 
¡¿ddËsLow”Bound
 = ((
x
 >> 
lgMaxSize
è^ (
´ev
.
com·¿nd
 >>†gMaxSize)è==ğ0 && (´ev.
	`com·¿nd
ÖgMaxSize-1, 0è& ~
	`x
(lgMaxSize-1, 0)) =/= 0

118 
v®
 
¡¿ddËsUµ”Bound
 = ((
x
 >> 
lgMaxSize
è^ (
com·¿nd
 >>†gMaxSize)è==ğ0 && (
	`com·¿nd
ÖgMaxSize-1, 0è& (
	`x
ÖgMaxSize-1, 0è| 
lsbMask
)) =/= 0

119 
v®
 
¿ngeAligÃd
 = !(
¡¿ddËsLow”Bound
 || 
¡¿ddËsUµ”Bound
)

120 
v®
 
pow2AligÃd
 = (
lsbMask
 & ~
	`mask
(
lgMaxSize
-1, 0)) === 0

121 
	`Mux
(
ÇpÙ
, 
pow2AligÃd
, 
¿ngeAligÃd
)

122 
	}
}

125 
def
 
	$h™
(
x
: 
UIÁ
, 
lgSize
: UIÁ, 
lgMaxSize
: 
IÁ
, 
´ev
: 
PMP
): 
BoŞ
 =

126 
	`Mux
(
ÇpÙ
, 
	`pow2M©ch
(
x
, 
lgSize
, 
lgMaxSize
), 
tÜNÙNAPOT
 && 
	`¿ngeM©ch
(x,†gSize,†gMaxSize, 
´ev
))

127 
	}
}

129 
şass
 
	$PMPHomog’e™yCheck”
(
pmps
: 
Seq
[
PMP
])(
im¶ic™
 
p
: 
P¬am‘”s
) {

130 
def
 
	`­¶y
(
addr
: 
UIÁ
, 
pgLev–
: UIÁ): 
BoŞ
 = {

131 ((
Œue
.
B
, 0.U.a
	`sTy³Of
(
Ãw
 
PMP
)è/: 
pmps
è{ ((
h
, 
´ev
), 
pmp
) =>

132 (
h
 && 
pmp
.
	`homog’eous
(
addr
, 
pgLev–
, 
´ev
),…mp)

133 }.
_1


135 
	}
}

137 şas 
	cPMPCheck”
(
lgMaxSize
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
)

138 
w™h
 
HasCÜeP¬am‘”s
 {

139 
v®
 
io
 = 
Ãw
 
BundË
 {

140 
v®
 
´v
 = 
	`UIÁ
(
INPUT
, 
PRV
.
SZ
)

141 
v®
 
pmp
 = 
	`Vec
(
nPMPs
, 
Ãw
 
PMP
).
asIÅut


142 
v®
 
addr
 = 
	`UIÁ
(
INPUT
, 
·ddrB™s
)

143 
v®
 
size
 = 
	`UIÁ
(
INPUT
, 
	`log2Ce
(
lgMaxSize
 + 1))

144 
v®
 
r
 = 
	`BoŞ
(
OUTPUT
)

145 
v®
 
w
 = 
	`BoŞ
(
OUTPUT
)

146 
v®
 
x
 = 
	`BoŞ
(
OUTPUT
)

149 
v®
  = ià(
io
.
pmp
.
isEm±y
è
Œue
.
B
 io.
´v
 > 
PRV
.
S


150 
v®
 
pmp0
 = 
	`Wœe
(
š™
 = 0.U.a
	$sTy³Of
(
Ãw
 
PMP
))

151 
pmp0
.
cfg
.
r
 := 

152 
pmp0
.
cfg
.
w
 := 

153 
pmp0
.
cfg
.
x
 := 

155 
v®
 
»s
 = (
pmp0
 /: (
io
.
pmp
 
	`z
 (pmp0 +: io.pmp)).
»v”£
è{ (
´ev
, (pmp, 
´evPMP
)) =>

156 
v®
 
h™
 = 
pmp
.
	`h™
(
io
.
addr
, io.
size
, 
lgMaxSize
, 
´evPMP
)

157 
v®
 
ignÜe
 =  && !
pmp
.
cfg
.
l


158 
v®
 
®igÃd
 = 
pmp
.
	`®igÃd
(
io
.
addr
, io.
size
, 
lgMaxSize
, 
´evPMP
)

159 
v®
 
cur
 = 
	`Wœe
(
š™
 = 
pmp
)

160 
cur
.
cfg
.
r
 :ğ(
®igÃd
 && 
pmp
.cfg.rè|| 
ignÜe


161 
cur
.
cfg
.
w
 :ğ(
®igÃd
 && 
pmp
.cfg.wè|| 
ignÜe


162 
cur
.
cfg
.
x
 :ğ(
®igÃd
 && 
pmp
.cfg.xè|| 
ignÜe


163 
	`Mux
(
h™
, 
cur
, 
´ev
)

164 
	}
}

166 
	gio
.
	gr
 :ğ
»s
.
cfg
.
r


167 
io
.
w
 :ğ
»s
.
cfg
.w

168 
io
.
x
 :ğ
»s
.
cfg
.x

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PTW.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
CacheBlockBy‹s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


14 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


15 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
_


16 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
Li¡Bufãr


18 şas 
	cPTWReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

19 
v®
 
addr
 = 
	`UIÁ
(
width
 = 
v²B™s
)

22 şas 
	cPTWRe¥
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

23 
v®
 
«
 = 
	$BoŞ
()

24 
v®
 
±e
 = 
Ãw
 
PTE


25 
v®
 
Ëv–
 = 
	`UIÁ
(
width
 = 
	$log2Ce
(
pgLev–s
))

26 
v®
 
äagm’‹d_su³½age
 = 
	$BoŞ
()

27 
v®
 
homog’eous
 = 
	`BoŞ
()

30 şas 
	cTLBPTWIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
)

31 
w™h
 
HasCÜeP¬am‘”s
 {

32 
v®
 
»q
 = 
	`Decou¶ed
(
	$V®id
(
Ãw
 
PTWReq
))

33 
v®
 
»¥
 = 
	`V®id
(
Ãw
 
PTWRe¥
).
æ


34 
v®
 
±br
 = 
Ãw
 
	`PTBR
().
asIÅut


35 
v®
 
¡©us
 = 
Ãw
 
	`MStus
().
asIÅut


36 
v®
 
pmp
 = 
	`Vec
(
nPMPs
, 
Ãw
 
PMP
).
asIÅut


37 
v®
 
cu¡omCSRs
 = 
cÜeP¬ams
.cu¡omCSRs.
asIÅut


40 şas 
	cPTWP”fEv’ts
 
ex‹nds
 
BundË
 {

41 
v®
 
l2miss
 = 
	`BoŞ
()

44 şas 
	cD©­©hPTWIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
)

45 
w™h
 
HasCÜeP¬am‘”s
 {

46 
v®
 
±br
 = 
Ãw
 
	`PTBR
().
asIÅut


47 
v®
 
sãnû
 = 
	`V®id
(
Ãw
 
SF’ûReq
).
æ


48 
v®
 
¡©us
 = 
Ãw
 
	`MStus
().
asIÅut


49 
v®
 
pmp
 = 
	`Vec
(
nPMPs
, 
Ãw
 
PMP
).
asIÅut


50 
v®
 
³rf
 = 
Ãw
 
	`PTWP”fEv’ts
().
asOuut


51 
v®
 
cu¡omCSRs
 = 
cÜeP¬ams
.cu¡omCSRs.
asIÅut


55 
v®
 
pcode_»q
 = 
	`V®id
(
Ãw
 
PCodeUpd©e
).
æ


56 
v®
 
pcode_»¥
 = 
	`V®id
(
Ãw
 
PCodeUpd©e
)

61 şas 
	cPTE
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

62 
v®
 
µn
 = 
	$UIÁ
(
width
 = 54)

63 
v®
 
»£rved_fÜ_soáw¬e
 = 
	$B™s
(
width
 = 2)

64 
v®
 
d
 = 
	$BoŞ
()

65 
v®
 
a
 = 
	$BoŞ
()

66 
v®
 
g
 = 
	$BoŞ
()

67 
v®
 
u
 = 
	$BoŞ
()

68 
v®
 
x
 = 
	$BoŞ
()

69 
v®
 
w
 = 
	$BoŞ
()

70 
v®
 
r
 = 
	$BoŞ
()

71 
v®
 
v
 = 
	$BoŞ
()

73 
def
 
	`bË
(
dummy
: 
IÁ
 = 0èğ
v
 && !
r
 && !
w
 && !
x


74 
def
 
	`Ëaf
(
dummy
: 
IÁ
 = 0èğ
v
 && (
r
 || (
x
 && !
w
)è&& 
a


75 
def
 
	`ur
(
dummy
: 
IÁ
 = 0èğ
	`¤
(è&& 
u


76 
def
 
	`uw
(
dummy
: 
IÁ
 = 0èğ
	`sw
(è&& 
u


77 
def
 
	`ux
(
dummy
: 
IÁ
 = 0èğ
	`sx
(è&& 
u


78 
def
 
	`¤
(
dummy
: 
IÁ
 = 0èğ
	`Ëaf
(è&& 
r


79 
def
 
	`sw
(
dummy
: 
IÁ
 = 0èğ
	`Ëaf
(è&& 
w
 && 
d


80 
def
 
	`sx
(
dummy
: 
IÁ
 = 0èğ
	`Ëaf
(è&& 
x


83 şas 
	cPCodeLockCfg
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

84 
	`»quœe
(
·ddrB™s
 > 12)

85 
v®
 
ba£
 = 
	`UIÁ
(
width
 = 
·ddrB™s
-12)

86 
v®
 
mask
 = 
	$UIÁ
(
width
 = 10)

87 
v®
 
v®id
 = 
	$BoŞ
()

88 
v®
 
’abË
 = 
	`BoŞ
()

92 şas 
	cPCodeLock
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()

93 
w™h
 
HasCÜeP¬am‘”s
 {

94 
v®
 
io
 = 
Ãw
 
BundË
 {

95 
v®
 
š
 = 
Ãw
 
	`PTE
().
asIÅut


96 
v®
 
out
 = 
Ãw
 
	`PTE
().
asOuut


98 
v®
 
cfg
 = 
	`Vec
(
numPCodeRªges
, 
Ãw
 
PCodeLockCfg
).
asIÅut


101 
	$»quœe
(
·ddrB™s
 == 32)

102 
io
.
out
 :ğio.
š


104 
v®
 
’abË
 = 
io
.
cfg
.
	`fŞdLeá
(
	$BoŞ
(
Œue
))((
l
, 
r
è=>† &&„.
’abË
)

108 
def
 
µn_m©ched
 = 
io
.
cfg
.
	`m­
(

109 
c
 => c.
v®id
 && ((
	`C©
(
	`UIÁ
(0xff,8),C©(c.
mask
, UIÁ(0,
width
=2))è& 
io
.
š
.
	`µn
(
·ddrB™s
-13,0)è==ğc.
ba£
)

110 ).
	`fŞd
(
	$BoŞ
(
çl£
))Ğ(
l
: 
BoŞ
,
r
: Bool) =>† ||„)

114 
def
 
š_pcode
 = 
’abË
 && 
io
.
š
.
	`Ëaf
(è&& 
µn_m©ched


115 
def
 
out_pcode
 = 
’abË
 && 
io
.
š
.
	`Ëaf
(è&& !
µn_m©ched


116 
def
 
by·ss
 = !
’abË
 || !
io
.
š
.
	$Ëaf
()

119 
io
.
out
.
x
 :ğ
	`Mux
(
by·ss
 || io.
š
.
u
, io.š.x, Mux(
µn_m©ched
, 
	`BoŞ
(
Œue
), 
	$BoŞ
(
çl£
)))

120 
io
.
out
.
w
 :ğ
	`Mux
(
by·ss
, io.
š
.w, Mux(
µn_m©ched
, 
	`BoŞ
(
çl£
), io.in.w))

137 
	}
}

139 @
chi£lName


140 
şass
 
	$PTW
(
n
: 
IÁ
)(
im¶ic™
 
edge
: 
TLEdgeOut
, 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
) {

141 
v®
 
io
 = 
Ãw
 
BundË
 {

142 
v®
 
»que¡Ü
 = 
	`Vec
(
n
, 
Ãw
 
TLBPTWIO
).
æ


143 
v®
 
mem
 = 
Ãw
 
H–ÏCacheIO


144 
v®
 
d·th
 = 
Ãw
 
D©­©hPTWIO


151 
v®
 
pcode_cfg
 = 
	`Reg
(
š™
 = 
Vec
.
	`fl
(
numPCodeRªges
){ 
Ãw
 
	`PCodeLockCfg
().
	`äomB™s
(0)} )

152 
v®
 
pcode_»¥
 = 
	`Reg
(
	`V®id
(
Ãw
 
PCodeUpd©e
))

154 ià(
hasPrivCodeLock
) {

155 
	`»quœe
(
numPCodeRªges
 <= 4)

156 
	`»quœe
(
·ddrB™s
 == 32)

157 
io
.
d·th
.
pcode_»¥
 :=…code_resp

158 
	`wh’
(
io
.
d·th
.
pcode_»q
.
v®id
) {

167 
	`pcode_cfg
(
io
.
d·th
.
pcode_»q
.
b™s
.
id
).
ba£
 :ğio.d·th.pcode_»q.b™s.
v®ue
.base

168 
	`pcode_cfg
(
io
.
d·th
.
pcode_»q
.
b™s
.
id
).
mask
 :ğio.d·th.pcode_»q.b™s.
v®ue
.mask

169 
	`pcode_cfg
(
io
.
d·th
.
pcode_»q
.
b™s
.
id
).
v®id
 :ğio.d·th.pcode_»q.b™s.
v®ue
.valid

170 
	`pcode_cfg
(
io
.
d·th
.
pcode_»q
.
b™s
.
id
).
’abË
 :ğio.d·th.pcode_»q.b™s.
v®ue
.
locked


175 
pcode_»¥
.
b™s
 :ğ
io
.
d·th
.
pcode_»q
.bits

180 
v®
 
s_»ady
 :: 
s_»q
 :: 
s_wa™1
 :: 
s_dummy1
 :: 
s_wa™2
 :: 
s_wa™3
 :: 
s_dummy2
 :: 
s_äagm’t_su³½age
 :: 
N
 = 
	`Enum
(
	`UIÁ
(), 8)

181 
v®
 
¡©e
 = 
	`Reg
(
š™
=
s_»ady
)

183 
v®
 
¬b
 = 
	`ModuË
(
Ãw
 
	`RRArb™”
(
	`V®id
Òew 
PTWReq
), 
n
))

184 
¬b
.
io
.
š
 <> io.
»que¡Ü
.
	`m­
(
_
.
»q
)

185 
¬b
.
io
.
out
.
»ady
 :ğ
¡©e
 ==ğ
s_»ady


187 
v®
 
»¥_v®id
 = 
	`Reg
(
Ãxt
 = 
Vec
.
	`fl
(
io
.
»que¡Ü
.
size
)(
	`BoŞ
(
çl£
)))

189 
v®
 
şock_’
 = 
¡©e
 =/ğ
s_»ady
 || 
¬b
.
io
.
out
.
v®id
 || io.
d·th
.
sãnû
.v®id || io.d·th.
cu¡omCSRs
.
di§bËDCacheClockG©e


190 
v®
 
g©ed_şock
 =

191 ià(!
usšgVM
 || !
teP¬ams
.
dÿche
.
g‘
.
şockG©e
è
şock


192 
	`ClockG©e
(
şock
, 
şock_’
, "ptw_clock_gate")

193 
	`w™hClock
 (
g©ed_şock
) {

195 
v®
 
šv®id©ed
 = 
	`Reg
(
	`BoŞ
())

196 
v®
 
couÁ
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Up
(
pgLev–s
)))

197 
v®
 
»¥_«
 = 
	`RegNext
(
çl£
.
B
)

198 
v®
 
»¥_äagm’‹d_su³½age
 = 
	`RegNext
(
çl£
.
B
)

200 
v®
 
r_»q
 = 
	`Reg
(
Ãw
 
PTWReq
)

201 
v®
 
r_»q_de¡
 = 
	`Reg
(
	`B™s
())

202 
v®
 
r_±e
 = 
	`Reg
(
Ãw
 
PTE
)

204 
	`v®
 (
±e
, 
šv®id_·ddr
) = {

205 
v®
 
tmp
 = 
Ãw
 
	`PTE
().
	`äomB™s
(
io
.
mem
.
»¥
.
b™s
.
d©a_wÜd_by·ss
)

206 
v®
 
»s
 = 
	`Wœe
(
š™
 = 
Ãw
 
	`PTE
().
	`äomB™s
(
io
.
mem
.
»¥
.
b™s
.
d©a_wÜd_by·ss
))

207 
»s
.
µn
 :ğ
tmp
.
	`µn
(
µnB™s
-1, 0)

208 
	`wh’
 (
tmp
.
r
 ||mp.
w
 ||mp.
x
) {

210 
i
 <- 0 
uÁ
 
pgLev–s
-1)

211 
	`wh’
 (
couÁ
 <ğ
i
 && 
tmp
.
	`µn
((
pgLev–s
-1-i)*
pgLev–B™s
-1, (pgLev–s-2-i)*pgLev–B™sè=/ğ0è{ 
»s
.
v
 :ğ
çl£
 }

213 (
»s
, (
tmp
.
µn
 >> 
µnB™s
) =/= 0)

215 
v®
 
Œav”£
 = 
±e
.
	`bË
(è&& !
šv®id_·ddr
 && 
couÁ
 < 
pgLev–s
-1

216 
v®
 
±e_addr
 = ià(!
usšgVM
) 0.U {

217 
v®
 
v²_idxs
 = (0 
uÁ
 
pgLev–s
).
	`m­
(
i
 => (
r_»q
.
addr
 >> (pgLev–s-i-1)*
pgLev–B™s
)(pgLevelBits-1,0))

218 
v®
 
v²_idx
 = 
	`v²_idxs
(
couÁ
)

219 
	`C©
(
r_±e
.
µn
, 
v²_idx
è<< 
	`log2Ce
(
xL’
/8)

221 
v®
 
äagm’‹d_su³½age_µn
 = {

222 
v®
 
choiûs
 = (
pgLev–s
-1 
uÁ
 0 
by
 -1).
	`m­
(
i
 => 
	`C©
(
r_±e
.
µn
 >> (pgLev–s*i), 
r_»q
.
	`addr
(pgLevels*i-1, 0)))

223 
	`choiûs
(
couÁ
)

226 
	`wh’
 (
¬b
.
io
.
out
.
	`fœe
()) {

227 
r_»q
 :ğ
¬b
.
io
.
out
.
b™s
.bits

228 
r_»q_de¡
 :ğ
¬b
.
io
.
cho£n


231 
	`v®
 (
±e_ÿche_h™
, 
±e_ÿche_d©a
) = {

232 
v®
 
size
 = 1 << 
	`log2Up
(
pgLev–s
 * 2)

233 
v®
 
¶ru
 = 
Ãw
 
	`P£udoLRU
(
size
)

234 
v®
 
šv®id
 = 
	`RegIn™
(
Œue
.
B
)

235 
v®
 
»g_v®id
 = 
	`Reg
(
	`UIÁ
(
size
.
W
))

236 
v®
 
v®id
 = 
	`Mux
(
šv®id
, 0.U, 
»g_v®id
)

237 
v®
 
gs
 = 
	`Reg
(
	`Vec
(
size
, 
	`UIÁ
(
width
 = 
·ddrB™s
)))

238 
v®
 
d©a
 = 
	`Reg
(
	`Vec
(
size
, 
	`UIÁ
(
width
 = 
µnB™s
)))

240 
v®
 
h™s
 = 
gs
.
	`m­
(
_
 ==ğ
±e_addr
).
asUIÁ
 & 
v®id


241 
v®
 
h™
 = 
h™s
.
ÜR


242 
	`wh’
 ((
¡©e
 ==ğ
s_wa™2
 || s‹ ==ğ
s_wa™3
è&& 
Œav”£
 && !
h™
 && !
šv®id©ed
) {

243 
v®
 
r
 = 
	`Mux
(
v®id
.
ªdR
, 
¶ru
.
»¶aû
, 
	`PriÜ™yEncod”
(~valid))

244 
šv®id
 :ğ
çl£


245 
»g_v®id
 :ğ
	`Mux
(
io
.
mem
.
»¥
.
v®id
, v®id | 
	`UIÁToOH
(
r
), valid & ~UIntToOH(r))

246 
	`gs
(
r
è:ğ
±e_addr


247 
	`d©a
(
r
è:ğ
±e
.
µn


249 
	`wh’
 (
h™
 && 
¡©e
 ==ğ
s_»q
è{ 
¶ru
.
	`acûss
(
	`OHToUIÁ
(
h™s
)) }

250 
	`wh’
 (
io
.
d·th
.
sãnû
.
v®id
 && !io.d·th.sãnû.
b™s
.
rs1
è{ 
šv®id
 :ğ
Œue
 }

252 
i
 <- 0 
uÁ
 
pgLev–s
-1)

253 
	`ccov”
(
h™
 && 
¡©e
 ==ğ
s_»q
 && 
couÁ
 ==ğ
i
, 
s
"PTE_CACHE_HIT_L$i", s"PTE cache hit,†evel $i")

255 (
h™
 && 
couÁ
 < 
pgLev–s
-1, 
	`Mux1H
(
h™s
, 
d©a
))

258 
v®
 
l2_»fl
 = 
	`RegNext
(
çl£
.
B
)

259 
io
.
d·th
.
³rf
.
l2miss
 :ğ
çl£


260 
	`v®
 (
l2_h™
, 
l2_v®id
, 
l2_±e
, 
l2_b_¿m
èğià(
cÜeP¬ams
.
nL2TLBEÁr›s
 =ğ0è(
çl£
.
B
, f®£.B, 
	`Wœe
(
Ãw
 
PTE
), 
NÚe
) {

261 
v®
 
code
 = 
Ãw
 
P¬™yCode


262 
	`»quœe
(
	`isPow2
(
cÜeP¬ams
.
nL2TLBEÁr›s
))

263 
v®
 
idxB™s
 = 
	`log2Ce
(
cÜeP¬ams
.
nL2TLBEÁr›s
)

264 
v®
 
gB™s
 = 
v²B™s
 - 
idxB™s


266 şas 
	cEÁry
 
ex‹nds
 
BundË
 {

267 
v®
 
g
 = 
	`UIÁ
(
width
 = 
gB™s
)

268 
v®
 
µn
 = 
	`UIÁ
(
width
 = 
µnB™s
)

269 
v®
 
d
 = 
	`BoŞ
()

270 
v®
 
a
 = 
	`BoŞ
()

271 
v®
 
u
 = 
	`BoŞ
()

272 
v®
 
x
 = 
	`BoŞ
()

273 
v®
 
w
 = 
	`BoŞ
()

274 
v®
 
r
 = 
	`BoŞ
()

276 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`EÁry
().
asIn¡ªûOf
[
this
.
ty³
]

279 
v®
 
¿m
 = 
	`DesüibedSRAM
(

280 
Çme
 = "l2_tlb_ram",

281 
desc
 = "L2 TLB",

282 
size
 = 
cÜeP¬ams
.
nL2TLBEÁr›s
,

283 
d©a
 = 
	`UIÁ
(
width
 = 
code
.
	`width
(
Ãw
 
	`EÁry
().
g‘Width
))

286 
v®
 
g
 = 
	`Reg
(
	`UIÁ
(
width
 = 
cÜeP¬ams
.
nL2TLBEÁr›s
))

287 
v®
 
v®id
 = 
	`RegIn™
(
	`UIÁ
(0, 
cÜeP¬ams
.
nL2TLBEÁr›s
))

288 
	`v®
 (
r_g
, 
r_idx
èğ
	`S¶™
(
r_»q
.
addr
, 
idxB™s
)

289 
	`wh’
 (
l2_»fl
 && !
šv®id©ed
) {

290 
v®
 
’Œy
 = 
	`Wœe
(
Ãw
 
EÁry
)

291 
’Œy
 :ğ
r_±e


292 
’Œy
.
g
 :ğ
r_g


293 
¿m
.
	`wr™e
(
r_idx
, 
code
.
	`’code
(
’Œy
.
asUIÁ
))

295 
v®
 
mask
 = 
	`UIÁToOH
(
r_idx
)

296 
v®id
 :ğv®id | 
mask


297 
g
 :ğ
	`Mux
(
r_±e
.g, g | 
mask
, g & ~mask)

299 
	`wh’
 (
io
.
d·th
.
sãnû
.
v®id
) {

300 
v®id
 :=

301 
	`Mux
(
io
.
d·th
.
sãnû
.
b™s
.
rs1
, 
v®id
 & ~
	`UIÁToOH
(io.d·th.sãnû.b™s.
	`addr
(
idxB™s
+
pgIdxB™s
-1,…gIdxBits)),

302 
	`Mux
(
io
.
d·th
.
sãnû
.
b™s
.
rs2
, 
v®id
 & 
g
, 0.U))

305 
v®
 
s0_v®id
 = !
l2_»fl
 && 
¬b
.
io
.
out
.
	`fœe
()

306 
v®
 
s1_v®id
 = 
	`RegNext
(
s0_v®id
 && 
¬b
.
io
.
out
.
b™s
.
v®id
)

307 
v®
 
s2_v®id
 = 
	`RegNext
(
s1_v®id
)

308 
v®
 
s1_rd©a
 = 
¿m
.
	`»ad
(
¬b
.
io
.
out
.
b™s
.b™s.
	`addr
(
idxB™s
-1, 0), 
s0_v®id
)

309 
v®
 
s2_rd©a
 = 
code
.
	`decode
(
	`RegEÇbË
(
s1_rd©a
, 
s1_v®id
))

310 
v®
 
s2_v®id_b™
 = 
	`RegEÇbË
(
	`v®id
(
r_idx
), 
s1_v®id
)

311 
v®
 
s2_g
 = 
	`RegEÇbË
(
	`g
(
r_idx
), 
s1_v®id
)

312 
	`wh’
 (
s2_v®id
 && 
s2_v®id_b™
 && 
s2_rd©a
.
”rÜ
è{ 
v®id
 := 0.U }

314 
v®
 
s2_’Œy
 = 
s2_rd©a
.
uncÜ»ùed
.
	`asTy³Of
(
Ãw
 
EÁry
)

315 
v®
 
s2_h™
 = 
s2_v®id
 && 
s2_v®id_b™
 && !
s2_rd©a
.
”rÜ
 && 
r_g
 ==ğ
s2_’Œy
.
g


316 
io
.
d·th
.
³rf
.
l2miss
 :ğ
s2_v®id
 && !(
s2_v®id_b™
 && 
r_g
 ==ğ
s2_’Œy
.
g
)

317 
v®
 
s2_±e
 = 
	`Wœe
(
Ãw
 
PTE
)

318 
s2_±e
 :ğ
s2_’Œy


319 
s2_±e
.
g
 :ğ
s2_g


320 
s2_±e
.
v
 :ğ
Œue


322 
	`ccov”
(
s2_h™
, "L2_TLB_HIT", "L2 TLB hit")

324 (
s2_h™
, 
s2_v®id
 && 
s2_v®id_b™
, 
s2_±e
, 
	`Some
(
¿m
))

328 
šv®id©ed
 :ğ
io
.
d·th
.
sãnû
.
v®id
 || (šv®id©ed && 
¡©e
 =/ğ
s_»ady
)

330 
io
.
mem
.
»q
.
v®id
 :ğ
¡©e
 ==ğ
s_»q
 || s‹ ==ğ
s_dummy1


331 
io
.
mem
.
»q
.
b™s
.
phys
 :ğ
	`BoŞ
(
Œue
)

332 
io
.
mem
.
»q
.
b™s
.
cmd
 :ğ
M_XRD


333 
io
.
mem
.
»q
.
b™s
.
typ
 :ğ
	`log2Ce
(
xL’
/8)

334 
io
.
mem
.
»q
.
b™s
.
addr
 :ğ
±e_addr


335 
io
.
mem
.
s1_kl
 :ğ
l2_h™
 || 
¡©e
 =/ğ
s_wa™1


336 
io
.
mem
.
s2_kl
 :ğ
	`BoŞ
(
çl£
)

338 
v®
 
·geG¿nuÏr™yPMPs
 = 
pmpG¿nuÏr™y
 >ğ(1 << 
pgIdxB™s
)

339 
v®
 
pmaPgLev–Homog’eous
 = (0 
uÁ
 
pgLev–s
è
m­
 { 
i
 =>

340 
v®
 
pgSize
 = 
	`BigIÁ
(1è<< (
pgIdxB™s
 + ((
pgLev–s
 - 1 - 
i
è* 
pgLev–B™s
))

341 ià(
·geG¿nuÏr™yPMPs
 && 
i
 =ğ
pgLev–s
 - 1) {

342 
	`»quœe
(
TLBPageLookup
.
	`homog’eous
(
edge
.
mªag”
.
mªag”s
, 
pgSize
), 
s
"All memory„egions must be $pgSize-byte‡ligned")

343 
Œue
.
B


345 
	`TLBPageLookup
(
edge
.
mªag”
.
mªag”s
, 
xL’
, 
	`p
(
CacheBlockBy‹s
), 
pgSize
)(
±e_addr
).
homog’eous


348 
v®
 
pmaHomog’eous
 = 
	`pmaPgLev–Homog’eous
(
couÁ
)

349 
v®
 
pmpHomog’eous
 = 
Ãw
 
	`PMPHomog’e™yCheck”
(
io
.
d·th
.
pmp
).
	`­¶y
(
±e_addr
 >> 
pgIdxB™s
 <<…gIdxB™s, 
couÁ
)

350 
v®
 
homog’eous
 = 
pmaHomog’eous
 && 
pmpHomog’eous


353 
i
 <- 0 
uÁ
 
io
.
»que¡Ü
.
size
) {

357 
io
.
	`»que¡Ü
(
i
).
»¥
.
v®id
 :ğ
	`»¥_v®id
(i)

358 
io
.
	`»que¡Ü
(
i
).
»¥
.
b™s
.
«
 :ğ
»¥_«


359 
io
.
	`»que¡Ü
(
i
).
»¥
.
b™s
.
±e
 :ğ
r_±e


360 
io
.
	`»que¡Ü
(
i
).
»¥
.
b™s
.
Ëv–
 :ğ
couÁ


361 
io
.
	`»que¡Ü
(
i
).
»¥
.
b™s
.
homog’eous
 :ğhomog’eou || 
·geG¿nuÏr™yPMPs


362 
io
.
	`»que¡Ü
(
i
).
»¥
.
b™s
.
äagm’‹d_su³½age
 :ğ
»¥_äagm’‹d_su³½age
 && 
·geG¿nuÏr™yPMPs


363 
io
.
	`»que¡Ü
(
i
).
±br
 :ğio.
d·th
.ptbr

364 
io
.
	`»que¡Ü
(
i
).
cu¡omCSRs
 :ğio.
d·th
.customCSRs

365 
io
.
	`»que¡Ü
(
i
).
¡©us
 :ğio.
d·th
.status

366 
io
.
	`»que¡Ü
(
i
).
pmp
 :ğio.
d·th
.pmp

370 
v®
 
Ãxt_¡©e
 = 
	`Wœe
(
š™
 = 
¡©e
)

371 
¡©e
 :ğ
	`O±imiz©iÚB¬r›r
(
Ãxt_¡©e
)

373 
¡©e
) {

374 
	`is
 (
s_»ady
) {

375 
	`wh’
 (
¬b
.
io
.
out
.
	`fœe
()) {

376 
Ãxt_¡©e
 :ğ
	`Mux
(
¬b
.
io
.
out
.
b™s
.
v®id
, 
s_»q
, 
s_»ady
)

378 
couÁ
 :ğ
	`UIÁ
(0)

380 
	`is
 (
s_»q
) {

381 
	`wh’
 (
±e_ÿche_h™
) {

382 
couÁ
 := count + 1

383 }.
Ùh”wi£
 {

384 
Ãxt_¡©e
 :ğ
	`Mux
(
io
.
mem
.
»q
.
»ady
, 
s_wa™1
, 
s_»q
)

387 
	`is
 (
s_wa™1
) {

388 
Ãxt_¡©e
 :ğ
s_wa™2


390 
	`is
 (
s_wa™2
) {

391 
Ãxt_¡©e
 :ğ
s_wa™3


392 
	`wh’
 (
io
.
mem
.
s2_xıt
.
«
.
ld
) {

393 
»¥_«
 :ğ
Œue


394 
Ãxt_¡©e
 :ğ
s_»ady


395 
	`»¥_v®id
(
r_»q_de¡
è:ğ
Œue


398 
	`is
 (
s_äagm’t_su³½age
) {

399 
Ãxt_¡©e
 :ğ
s_»ady


400 
	`»¥_v®id
(
r_»q_de¡
è:ğ
Œue


401 
»¥_«
 :ğ
çl£


402 
	`wh’
 (!
homog’eous
) {

403 
couÁ
 :ğ
pgLev–s
-1

404 
»¥_äagm’‹d_su³½age
 :ğ
Œue


409 
def
 
	`makePTE
(
µn
: 
UIÁ
, : 
PTE
) = {

410 
v®
 
±e
 = 
	`Wœe
(
š™
 = )

411 
±e
.
µn
 :=…pn

412 
±e


414 
v®
 
pCodeLock
 = 
	`ModuË
(
Ãw
 
	`PCodeLock
())

445 
def
 
r_±e_´e
 = 
	`O±imiz©iÚB¬r›r
(

446 
	`Mux
(
io
.
mem
.
»¥
.
v®id
, 
±e
,

447 
	`Mux
(
l2_h™
, 
l2_±e
,

448 
	`Mux
(
¡©e
 ==ğ
s_äagm’t_su³½age
 && !
homog’eous
, 
	`makePTE
(
äagm’‹d_su³½age_µn
, 
r_±e
),

449 
	`Mux
(
¡©e
 ==ğ
s_»q
 && 
±e_ÿche_h™
, 
	`makePTE
(
±e_ÿche_d©a
, 
l2_±e
),

450 
	`Mux
(
¬b
.
io
.
out
.
	`fœe
(), 
	`makePTE
(io.
d·th
.
±br
.
µn
, 
r_±e
),

451 
r_±e
))))))

453 
pCodeLock
.
io
.
cfg
 :ğ
pcode_cfg


454 
pCodeLock
.
io
.
š
 :ğ
r_±e_´e


455 
r_±e
 :ğ
pCodeLock
.
io
.
out


458 
	`wh’
 (
l2_h™
) {

459 
	`as£¹
(
¡©e
 ==ğ
s_»q
 || s‹ ==ğ
s_wa™1
)

460 
Ãxt_¡©e
 :ğ
s_»ady


461 
	`»¥_v®id
(
r_»q_de¡
è:ğ
Œue


462 
»¥_«
 :ğ
çl£


463 
couÁ
 :ğ
pgLev–s
-1

465 
	`wh’
 (
io
.
mem
.
s2_Çck
) {

466 
	`as£¹
(
¡©e
 ==ğ
s_wa™2
)

467 
Ãxt_¡©e
 :ğ
s_»q


469 
	`wh’
 (
io
.
mem
.
»¥
.
v®id
) {

470 
	`as£¹
(
¡©e
 ==ğ
s_wa™2
 || s‹ ==ğ
s_wa™3
)

471 
	`wh’
 (
Œav”£
) {

472 
Ãxt_¡©e
 :ğ
s_»q


473 
couÁ
 := count + 1

474 }.
Ùh”wi£
 {

475 
l2_»fl
 :ğ
±e
.
v
 && !
šv®id_·ddr
 && 
couÁ
 ==ğ
pgLev–s
-1

476 
v®
 
«
 = 
±e
.
v
 && 
šv®id_·ddr


477 
»¥_«
 :ğ
«


478 
	`wh’
 (
·geG¿nuÏr™yPMPs
 && 
couÁ
 =/ğ
pgLev–s
-1 && !
«
) {

479 
Ãxt_¡©e
 :ğ
s_äagm’t_su³½age


480 }.
Ùh”wi£
 {

481 
Ãxt_¡©e
 :ğ
s_»ady


482 
	`»¥_v®id
(
r_»q_de¡
è:ğ
Œue


487 
i
 <- 0 
uÁ
 
pgLev–s
) {

488 
v®
 
Ëaf
 = 
io
.
mem
.
»¥
.
v®id
 && !
Œav”£
 && 
couÁ
 ==ğ
i


489 
	`ccov”
(
Ëaf
 && 
±e
.
v
 && !
šv®id_·ddr
, 
s
"L$i", s"successful…age-table‡ccess,†evel $i")

490 
	`ccov”
(
Ëaf
 && 
±e
.
v
 && 
šv®id_·ddr
, 
s
"L${i}_BAD_PPN_MSB", s"PPNoo†arge,†evel $i")

491 
	`ccov”
(
Ëaf
 && !
io
.
mem
.
»¥
.
b™s
.
	`d©a_wÜd_by·ss
(0), 
s
"L${i}_INVALID_PTE", s"page‚ot…resent,†evel $i")

492 ià(
i
 !ğ
pgLev–s
-1)

493 
	`ccov”
(
Ëaf
 && !
±e
.
v
 && 
io
.
mem
.
»¥
.
b™s
.
	`d©a_wÜd_by·ss
(0), 
s
"L${i}_BAD_PPN_LSB", s"PPN LSBs‚ot zero,†evel $i")

495 
	`ccov”
(
io
.
mem
.
»¥
.
v®id
 && 
couÁ
 ==ğ
pgLev–s
-1 && 
±e
.
	`bË
(), 
s
"TOO_DEEP", s"pageableoo deep")

496 
	`ccov”
(
io
.
mem
.
s2_Çck
, "NACK", "D$‚acked…age-table‡ccess")

497 
	`ccov”
(
¡©e
 ==ğ
s_wa™2
 && 
io
.
mem
.
s2_xıt
.
«
.
ld
, "AE", "accessƒxception while walking…ageable")

499 
	}
}

501 
´iv©e
 
def
 
	$ccov”
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

502 ià(
usšgVM
è
	`cov”
(
cÚd
, 
s
"PTW_$Ïb–", "MemÜySy¡em;;" + 
desc
)

503 
	}
}

506 
Œa™
 
CªHavePTW
 
ex‹nds
 
HasTeP¬am‘”s
 
w™h
 
	gHasH–ÏCache
 { 
	gthis
: 
Ba£Te
 =>

507 
v®
 
moduË
: 
CªHavePTWModuË


508 
v¬
 
nPTWPÜts
 = 1

509 
nDCachePÜts
 +ğ
usšgPTW
.
toIÁ


512 
Œa™
 
CªHavePTWModuË
 
ex‹nds
 
HasH–ÏCacheModuË
 {

513 
v®
 
ou‹r
: 
CªHavePTW


514 
v®
 
±wPÜts
 = 
Li¡Bufãr
(
ou‹r
.
dÿche
.
moduË
.
io
.
±w
)

515 
v®
 
±w
 = 
ModuË
(
Ãw
 
PTW
(
ou‹r
.
nPTWPÜts
)(ou‹r.
dÿche
.
node
.
edges
.
out
(0), ou‹r.
p
))

516 ià(
	gou‹r
.
	gusšgPTW
)

517 
	gdÿchePÜts
 +ğ
±w
.
io
.
mem


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RVC.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 şas 
	cEx·ndedIn¡ruùiÚ
 
ex‹nds
 
	mBundË
 {

12 
v®
 
	mb™s
 = 
	$UIÁ
(
width
 = 32)

13 
v®
 
rd
 = 
	$UIÁ
(
width
 = 5)

14 
v®
 
rs1
 = 
	$UIÁ
(
width
 = 5)

15 
v®
 
rs2
 = 
	$UIÁ
(
width
 = 5)

16 
v®
 
rs3
 = 
	`UIÁ
(
width
 = 5)

19 
şass
 
	$RVCDecod”
(
x
: 
UIÁ
, 
xL’
: 
IÁ
) {

20 
def
 
	`š¡
(
b™s
: 
UIÁ
, 
rd
: UIÁ = 
	`x
(11,7), 
rs1
: UIÁ = x(19,15), 
rs2
: UIÁ = x(24,20), 
rs3
: UInt = x(31,27)) = {

21 
v®
 
»s
 = 
	`Wœe
(
Ãw
 
Ex·ndedIn¡ruùiÚ
)

22 
»s
.
b™s
 := bits

23 
»s
.
rd
 :=„d

24 
»s
.
rs1
 :=„s1

25 
»s
.
rs2
 :=„s2

26 
»s
.
rs3
 :=„s3

27 
»s


30 
def
 
rs1p
 = 
	`C©
(
	`UIÁ
(1,2), 
	`x
(9,7))

31 
def
 
rs2p
 = 
	`C©
(
	`UIÁ
(1,2), 
	`x
(4,2))

32 
def
 
rs2
 = 
	`x
(6,2)

33 
def
 
rd
 = 
	`x
(11,7)

34 
def
 
addi4¥nImm
 = 
	`C©
(
	`x
(10,7), x(12,11), x(5), x(6), 
	`UIÁ
(0,2))

35 
def
 
lwImm
 = 
	`C©
(
	`x
(5), x(12,10), x(6), 
	`UIÁ
(0,2))

36 
def
 
ldImm
 = 
	`C©
(
	`x
(6,5), x(12,10), 
	`UIÁ
(0,3))

37 
def
 
lw¥Imm
 = 
	`C©
(
	`x
(3,2), x(12), x(6,4), 
	`UIÁ
(0,2))

38 
def
 
ld¥Imm
 = 
	`C©
(
	`x
(4,2), x(12), x(6,5), 
	`UIÁ
(0,3))

39 
def
 
sw¥Imm
 = 
	`C©
(
	`x
(8,7), x(12,9), 
	`UIÁ
(0,2))

40 
def
 
sd¥Imm
 = 
	`C©
(
	`x
(9,7), x(12,10), 
	`UIÁ
(0,3))

41 
def
 
luiImm
 = 
	`C©
(
	`Fl
(15, 
	`x
(12)), x(6,2), 
	`UIÁ
(0,12))

42 
def
 
addi16¥Imm
 = 
	`C©
(
	`Fl
(3, 
	`x
(12)), x(4,3), x(5), x(2), x(6), 
	`UIÁ
(0,4))

43 
def
 
addiImm
 = 
	`C©
(
	`Fl
(7, 
	`x
(12)), x(6,2))

44 
def
 
jImm
 = 
	`C©
(
	`Fl
(10, 
	`x
(12)), x(8), x(10,9), x(6), x(7), x(2), x(11), x(5,3), 
	`UIÁ
(0,1))

45 
def
 
bImm
 = 
	`C©
(
	`Fl
(5, 
	`x
(12)), x(6,5), x(2), x(11,10), x(4,3), 
	`UIÁ
(0,1))

46 
def
 
shamt
 = 
	`C©
(
	`x
(12), x(6,2))

47 
def
 
x0
 = 
	`UIÁ
(0,5)

48 
def
 
¿
 = 
	`UIÁ
(1,5)

49 
def
 
¥
 = 
	`UIÁ
(2,5)

51 
def
 
q0
 = {

52 
def
 
addi4¥n
 = {

53 
v®
 
İc
 = 
	`Mux
(
	`x
(12,5).
ÜR
, 
	`UIÁ
(0x13,7), UInt(0x1F,7))

54 
	`š¡
(
	`C©
(
addi4¥nImm
, 
¥
, 
	`UIÁ
(0,3), 
rs2p
, 
İc
),„s2p, sp,„s2p)

56 
def
 
ld
 = 
	`š¡
(
	`C©
(
ldImm
, 
rs1p
, 
	`UIÁ
(3,3), 
rs2p
, UInt(0x03,7)),„s2p,„s1p,„s2p)

57 
def
 
lw
 = 
	`š¡
(
	`C©
(
lwImm
, 
rs1p
, 
	`UIÁ
(2,3), 
rs2p
, UInt(0x03,7)),„s2p,„s1p,„s2p)

58 
def
 
æd
 = 
	`š¡
(
	`C©
(
ldImm
, 
rs1p
, 
	`UIÁ
(3,3), 
rs2p
, UInt(0x07,7)),„s2p,„s1p,„s2p)

59 
def
 
æw
 = {

60 ià(
xL’
 =ğ32è
	`š¡
(
	`C©
(
lwImm
, 
rs1p
, 
	`UIÁ
(2,3), 
rs2p
, UInt(0x07,7)),„s2p,„s1p,„s2p)

61 
ld


63 
def
 
unimp
 = 
	`š¡
(
	`C©
(
lwImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UIÁ
(2,3), 
	`lwImm
(4,0), UInt(0x3F,7)),„s2p,„s1p,„s2p)

64 
def
 
sd
 = 
	`š¡
(
	`C©
(
ldImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UIÁ
(3,3), 
	`ldImm
(4,0), UInt(0x23,7)),„s2p,„s1p,„s2p)

65 
def
 
sw
 = 
	`š¡
(
	`C©
(
lwImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UIÁ
(2,3), 
	`lwImm
(4,0), UInt(0x23,7)),„s2p,„s1p,„s2p)

66 
def
 
fsd
 = 
	`š¡
(
	`C©
(
ldImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UIÁ
(3,3), 
	`ldImm
(4,0), UInt(0x27,7)),„s2p,„s1p,„s2p)

67 
def
 
fsw
 = {

68 ià(
xL’
 =ğ32è
	`š¡
(
	`C©
(
lwImm
 >> 5, 
rs2p
, 
rs1p
, 
	`UIÁ
(2,3), 
	`lwImm
(4,0), UInt(0x27,7)),„s2p,„s1p,„s2p)

69 
sd


71 
	`Seq
(
addi4¥n
, 
æd
, 
lw
, 
æw
, 
unimp
, 
fsd
, 
sw
, 
fsw
)

74 
def
 
q1
 = {

75 
def
 
addi
 = 
	`š¡
(
	`C©
(
addiImm
, 
rd
, 
	`UIÁ
(0,3),„d, UIÁ(0x13,7)),„d,„d, 
rs2p
)

76 
def
 
addiw
 = {

77 
v®
 
İc
 = 
	`Mux
(
rd
.
ÜR
, 
	`UIÁ
(0x1B,7), UInt(0x1F,7))

78 
	`š¡
(
	`C©
(
addiImm
, 
rd
, 
	`UIÁ
(0,3),„d, 
İc
),„d,„d, 
rs2p
)

80 
def
 
j®
 = {

81 ià(
xL’
 =ğ32è
	`š¡
(
	`C©
(
	`jImm
(20), jImm(10,1), jImm(11), jImm(19,12), 
¿
, 
	`UIÁ
(0x6F,7)),„a, 
rd
, 
rs2p
)

82 
addiw


84 
def
 
li
 = 
	`š¡
(
	`C©
(
addiImm
, 
x0
, 
	`UIÁ
(0,3), 
rd
, UIÁ(0x13,7)),„d, x0, 
rs2p
)

85 
def
 
addi16¥
 = {

86 
v®
 
İc
 = 
	`Mux
(
addiImm
.
ÜR
, 
	`UIÁ
(0x13,7), UInt(0x1F,7))

87 
	`š¡
(
	`C©
(
addi16¥Imm
, 
rd
, 
	`UIÁ
(0,3),„d, 
İc
),„d,„d, 
rs2p
)

89 
def
 
lui
 = {

90 
v®
 
İc
 = 
	`Mux
(
addiImm
.
ÜR
, 
	`UIÁ
(0x37,7), UInt(0x3F,7))

91 
v®
 
me
 = 
	`š¡
(
	`C©
(
	`luiImm
(31,12), 
rd
, 
İc
),„d,„d, 
rs2p
)

92 
	`Mux
(
rd
 ==ğ
x0
 ||„d ==ğ
¥
, 
addi16¥
, 
me
)

94 
def
 
j
 = 
	`š¡
(
	`C©
(
	`jImm
(20), jImm(10,1), jImm(11), jImm(19,12), 
x0
, 
	`UIÁ
(0x6F,7)), x0, 
rs1p
, 
rs2p
)

95 
def
 
beqz
 = 
	`š¡
(
	`C©
(
	`bImm
(12), bImm(10,5), 
x0
, 
rs1p
, 
	`UIÁ
(0,3), bImm(4,1), bImm(11), UInt(0x63,7)),„s1p,„s1p, x0)

96 
def
 
bÃz
 = 
	`š¡
(
	`C©
(
	`bImm
(12), bImm(10,5), 
x0
, 
rs1p
, 
	`UIÁ
(1,3), bImm(4,1), bImm(11), UInt(0x63,7)), x0,„s1p, x0)

97 
def
 
¬™h
 = {

98 
def
 
¤li
 = 
	`C©
(
shamt
, 
rs1p
, 
	`UIÁ
(5,3),„s1p, UInt(0x13,7))

99 
def
 
¤ai
 = 
¤li
 | 
	`UIÁ
(1 << 30)

100 
def
 
ªdi
 = 
	`C©
(
addiImm
, 
rs1p
, 
	`UIÁ
(7,3),„s1p, UInt(0x13,7))

101 
def
 
¹y³
 = {

102 
v®
 
funù
 = 
	`Seq
(0.U, 4.U, 6.U, 7.U, 0.U, 0.U, 2.U, 3.U)(
	`C©
(
	`x
(12), x(6,5)))

103 
v®
 
sub
 = 
	`Mux
(
	`x
(6,5è==ğ
	`UIÁ
(0), UInt(1 << 30), UInt(0))

104 
v®
 
İc
 = 
	`Mux
(
	`x
(12), 
	`UIÁ
(0x3B,7), UInt(0x33,7))

105 
	`C©
(
rs2p
, 
rs1p
, 
funù
,„s1p, 
İc
è| 
sub


107 
	`š¡
(
	`Seq
(
¤li
, 
¤ai
, 
ªdi
, 
¹y³
)(
	`x
(11,10)), 
rs1p
,„s1p, 
rs2p
)

109 
	`Seq
(
addi
, 
j®
, 
li
, 
lui
, 
¬™h
, 
j
, 
beqz
, 
bÃz
)

112 
def
 
q2
 = {

113 
v®
 
lßd_İc
 = 
	`Mux
(
rd
.
ÜR
, 
	`UIÁ
(0x03,7), UInt(0x1F,7))

114 
def
 
¦li
 = 
	`š¡
(
	`C©
(
shamt
, 
rd
, 
	`UIÁ
(1,3),„d, UIÁ(0x13,7)),„d,„d, 
rs2
)

115 
def
 
ld¥
 = 
	`š¡
(
	`C©
(
ld¥Imm
, 
¥
, 
	`UIÁ
(3,3), 
rd
, 
lßd_İc
),„d, sp, 
rs2
)

116 
def
 
lw¥
 = 
	`š¡
(
	`C©
(
lw¥Imm
, 
¥
, 
	`UIÁ
(2,3), 
rd
, 
lßd_İc
),„d, sp, 
rs2
)

117 
def
 
æd¥
 = 
	`š¡
(
	`C©
(
ld¥Imm
, 
¥
, 
	`UIÁ
(3,3), 
rd
, UIÁ(0x07,7)),„d, sp, 
rs2
)

118 
def
 
æw¥
 = {

119 ià(
xL’
 =ğ32è
	`š¡
(
	`C©
(
lw¥Imm
, 
¥
, 
	`UIÁ
(2,3), 
rd
, UIÁ(0x07,7)),„d, sp, 
rs2
)

120 
ld¥


122 
def
 
sd¥
 = 
	`š¡
(
	`C©
(
sd¥Imm
 >> 5, 
rs2
, 
¥
, 
	`UIÁ
(3,3), 
	`sd¥Imm
(4,0), UIÁ(0x23,7)), 
rd
, sp,„s2)

123 
def
 
sw¥
 = 
	`š¡
(
	`C©
(
sw¥Imm
 >> 5, 
rs2
, 
¥
, 
	`UIÁ
(2,3), 
	`sw¥Imm
(4,0), UIÁ(0x23,7)), 
rd
, sp,„s2)

124 
def
 
fsd¥
 = 
	`š¡
(
	`C©
(
sd¥Imm
 >> 5, 
rs2
, 
¥
, 
	`UIÁ
(3,3), 
	`sd¥Imm
(4,0), UIÁ(0x27,7)), 
rd
, sp,„s2)

125 
def
 
fsw¥
 = {

126 ià(
xL’
 =ğ32è
	`š¡
(
	`C©
(
sw¥Imm
 >> 5, 
rs2
, 
¥
, 
	`UIÁ
(2,3), 
	`sw¥Imm
(4,0), UIÁ(0x27,7)), 
rd
, sp,„s2)

127 
sd¥


129 
def
 
j®r
 = {

130 
v®
 
mv
 = 
	`š¡
(
	`C©
(
rs2
, 
x0
, 
	`UIÁ
(0,3), 
rd
, UInt(0x33,7)),„d, x0,„s2)

131 
v®
 
add
 = 
	`š¡
(
	`C©
(
rs2
, 
rd
, 
	`UIÁ
(0,3),„d, UInt(0x33,7)),„d,„d,„s2)

132 
v®
 
jr
 = 
	`C©
(
rs2
, 
rd
, 
	`UIÁ
(0,3), 
x0
, UInt(0x67,7))

133 
v®
 
»£rved
 = 
	`C©
(
jr
 >> 7, 
	`UIÁ
(0x1F,7))

134 
v®
 
jr_»£rved
 = 
	`š¡
(
	`Mux
(
rd
.
ÜR
, 
jr
, 
»£rved
), 
x0
,„d, 
rs2
)

135 
v®
 
jr_mv
 = 
	`Mux
(
rs2
.
ÜR
, 
mv
, 
jr_»£rved
)

136 
v®
 
j®r
 = 
	`C©
(
rs2
, 
rd
, 
	`UIÁ
(0,3), 
¿
, UInt(0x67,7))

137 
v®
 
eb»ak
 = 
	`C©
(
jr
 >> 7, 
	`UIÁ
(0x73,7)) | UInt(1 << 20)

138 
v®
 
j®r_eb»ak
 = 
	`š¡
(
	`Mux
(
rd
.
ÜR
, 
j®r
, 
eb»ak
), 
¿
,„d, 
rs2
)

139 
v®
 
j®r_add
 = 
	`Mux
(
rs2
.
ÜR
, 
add
, 
j®r_eb»ak
)

140 
	`Mux
(
	`x
(12), 
j®r_add
, 
jr_mv
)

142 
	`Seq
(
¦li
, 
æd¥
, 
lw¥
, 
æw¥
, 
j®r
, 
fsd¥
, 
sw¥
, 
fsw¥
)

145 
def
 
q3
 = 
Seq
.
	`fl
(8)(
·s¡hrough
)

147 
def
 
·s¡hrough
 = 
	`š¡
(
x
)

149 
def
 
decode
 = {

150 
v®
 
s
 = 
q0
 ++ 
q1
 ++ 
q2
 ++ 
q3


151 
	`s
(
	`C©
(
	`x
(1,0), x(15,13)))

153 
	}
}

155 şas 
	cRVCEx·nd”
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 
w™h
 
HasCÜeP¬am‘”s
 {

156 
v®
 
io
 = 
Ãw
 
BundË
 {

157 
v®
 
š
 = 
	`UIÁ
(
INPUT
, 32)

158 
v®
 
out
 = 
Ãw
 
Ex·ndedIn¡ruùiÚ


159 
v®
 
rvc
 = 
	`BoŞ
(
OUTPUT
)

162 ià(
usšgCom´es£d
) {

163 
io
.
rvc
 :ğio.
	`š
(1,0è=/ğ
	`UIÁ
(3)

164 
io
.
out
 :ğ
Ãw
 
	`RVCDecod”
(io.
š
, 
	`p
(
XL’
)).
decode


165 
	}
} {

166 
	gio
.
	grvc
 :ğ
BoŞ
(
çl£
)

167 
io
.
out
 :ğ
Ãw
 
RVCDecod”
(io.
š
, 
p
(
XL’
)).
	g·s¡hrough


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RocketCore.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsc›
.
_


14 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gimmubË
.
Li¡M­


15 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
A¼ayBufãr


17 
şass
 
Rock‘CÜeP¬ams
(

18 
boÙF»qHz
: 
BigIÁ
 = 0,

19 
u£VM
: 
BoŞ—n
 = 
Œue
,

20 
u£U£r
: 
BoŞ—n
 = 
çl£
,

21 
u£Debug
: 
BoŞ—n
 = 
Œue
,

22 
u£Atomics
: 
BoŞ—n
 = 
Œue
,

23 
u£AtomicsOÆyFÜIO
: 
BoŞ—n
 = 
çl£
,

24 
u£Com´es£d
: 
BoŞ—n
 = 
Œue
,

25 
u£SCIE
: 
BoŞ—n
 = 
çl£
,

26 
nLoÿlIÁ”ru±s
: 
IÁ
 = 0,

27 
nB»akpošts
: 
IÁ
 = 1,

28 
nPMPs
: 
IÁ
 = 8,

29 
nP”fCouÁ”s
: 
IÁ
 = 0,

30 
haveBasicCouÁ”s
: 
BoŞ—n
 = 
Œue
,

31 
mi§Wr™abË
: 
BoŞ—n
 = 
Œue
,

32 
nL2TLBEÁr›s
: 
IÁ
 = 0,

33 
mtvecIn™
: 
O±iÚ
[
BigIÁ
] = 
Some
(BigInt(0)),

34 
mtvecWr™abË
: 
BoŞ—n
 = 
Œue
,

35 
ç¡LßdWÜd
: 
BoŞ—n
 = 
Œue
,

36 
ç¡LßdBy‹
: 
BoŞ—n
 = 
çl£
,

37 
b¿nchP»diùiÚModeCSR
: 
BoŞ—n
 = 
çl£
,

38 
teCÚŒŞAddr
: 
O±iÚ
[
BigIÁ
] = 
NÚe
,

39 
şockG©e
: 
BoŞ—n
 = 
çl£
,

40 
mv’dÜid
: 
IÁ
 = 0,

41 
mulDiv
: 
O±iÚ
[
MulDivP¬ams
] = 
Some
(MulDivParams()),

42 
åu
: 
O±iÚ
[
FPUP¬ams
] = 
Some
(FPUParams()),

43 
ov”ride
 
v®
 
hasPrivCodeLock
: 
BoŞ—n
 = 
çl£
,

44 
ov”ride
 
v®
 
numPCodeRªges
: 
IÁ
 = 8

45 è
ex‹nds
 
CÜeP¬ams
 {

46 
v®
 
haveFSDœty
 = 
çl£


47 
v®
 
pmpG¿nuÏr™y
: 
IÁ
 = 4

48 
v®
 
ãtchWidth
: 
IÁ
 = ià(
u£Com´es£d
) 2 1

50 
v®
 
decodeWidth
: 
IÁ
 = 
ãtchWidth
 / (ià(
u£Com´es£d
) 2 1)

51 
v®
 
»tœeWidth
: 
IÁ
 = 1

52 
v®
 
š¡B™s
: 
IÁ
 = ià(
u£Com´es£d
) 16 32

53 
v®
 
ÌscCyşes
: 
IÁ
 = 80

54 
ov”ride
 
def
 
cu¡omCSRs
(
im¶ic™
 
p
: 
P¬am‘”s
èğ
Ãw
 
Rock‘Cu¡omCSRs


57 
Œa™
 
HasRock‘CÜeP¬am‘”s
 
ex‹nds
 
HasCÜeP¬am‘”s
 {

58 
Ïzy
 
v®
 
rock‘P¬ams
: 
Rock‘CÜeP¬ams
 = 
teP¬ams
.
cÜe
.
asIn¡ªûOf
[RocketCoreParams]

60 
v®
 
ç¡LßdWÜd
 = 
rock‘P¬ams
.fastLoadWord

61 
v®
 
ç¡LßdBy‹
 = 
rock‘P¬ams
.fastLoadByte

63 
v®
 
mulDivP¬ams
 = 
rock‘P¬ams
.
mulDiv
.
g‘OrEl£
(
MulDivP¬ams
())

65 
»quœe
(!
ç¡LßdBy‹
 || 
ç¡LßdWÜd
)

68 şas 
	cRock‘Cu¡omCSRs
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
Cu¡omCSRs
 
w™h
 
HasRock‘CÜeP¬am‘”s
 {

69 
ov”ride
 
def
 
bpmCSR
 = {

70 
rock‘P¬ams
.
b¿nchP»diùiÚModeCSR
.
	`İtiÚ
(
	`Cu¡omCSR
(
bpmCSRId
, 
	`BigIÁ
(1), 
	`Some
(BigInt(0))))

73 
ov”ride
 
def
 
chick’CSR
 = {

74 
v®
 
mask
 = 
	`BigIÁ
(

75 
teP¬ams
.
dÿche
.
g‘
.
şockG©e
.
toIÁ
 << 0 |

76 
rock‘P¬ams
.
şockG©e
.
toIÁ
 << 1 |

77 
rock‘P¬ams
.
şockG©e
.
toIÁ
 << 2

79 
	`Some
(
	`Cu¡omCSR
(
chick’CSRId
, 
mask
, Some(mask)))

80 
	}
}

82 
def
 
	gm¬chid
 = 
Cu¡omCSR
.
cÚ¡ªt
(
CSRs
.
m¬chid
, 
	$BigIÁ
(1))

84 
def
 
mv’dÜid
 = 
Cu¡omCSR
.
	`cÚ¡ªt
(
CSRs
.mv’dÜid, 
	$BigIÁ
(
rock‘P¬ams
.
mv’dÜid
))

93 
def
 
d©e¡amp
 = 0x20181004

94 
def
 
mimpidV®
 = ià(
hasPrivCodeLock
) {

95 0x04000000 & 
d©e¡amp


96 
	}
} {

97 
d©e¡amp


99 
def
 
mimpid
 = 
Cu¡omCSR
.
cÚ¡ªt
(
CSRs
.mimpid, 
	$BigIÁ
(
mimpidV®
))

101 
ov”ride
 
def
 
deşs
 = 
su³r
.deş :+ 
m¬chid
 :+ 
mv’dÜid
 :+ 
mimpid


103 
	}
}

105 @
chi£lName


106 şas 
	cRock‘
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
)

107 
w™h
 
HasRock‘CÜeP¬am‘”s


108 
w™h
 
HasCÜeIO
 {

110 
v®
 
şock_’_»g
 = 
	$RegIn™
(
Œue
.
B
)

111 
v®
 
lÚg_Ï‹ncy_¡®l
 = 
	`Reg
(
	$BoŞ
())

112 
v®
 
imem_might_»que¡_»g
 = 
	`Reg
(
	$BoŞ
())

113 
v®
 
şock_’
 = 
	$Wœe
(
š™
=
Œue
.
B
)

114 
v®
 
g©ed_şock
 =

115 ià(!
rock‘P¬ams
.
şockG©e
è
şock


116 
	`ClockG©e
(
şock
, 
şock_’
, "rocket_clock_gate")

118 @
chi£lName
 cÏs 
	cRock‘Im¶
 {

121 
def
 
p–šeIDToWB
[
T
 <: 
D©a
](
x
: T): T =

122 
	`RegEÇbË
(RegEÇbË(RegEÇbË(
x
, !
ù¾_kld
), 
ex_pc_v®id
), 
mem_pc_v®id
)

123 
v®
 
³rfEv’ts
 = 
Ãw
 
	`Ev’tS‘s
(
	`Seq
(

124 
Ãw
 
	`Ev’tS‘
((
mask
, 
h™s
è=> 
	`Mux
(
	`mask
(0), 
wb_xıt
, 
wb_v®id
 && 
	`p–šeIDToWB
((mask & h™s).
ÜR
)), 
	`Seq
(

125 ("exû±iÚ", (è=> 
çl£
.
B
),

126 ("lßd", (è=> 
id_ù¾
.
mem
 && id_ù¾.
mem_cmd
 ==ğ
M_XRD
 && !id_ù¾.
å
),

127 ("¡Üe", (è=> 
id_ù¾
.
mem
 && id_ù¾.
mem_cmd
 ==ğ
M_XWR
 && !id_ù¾.
å
),

128 ("amo", (è=> 
	`BoŞ
(
usšgAtomics
è&& 
id_ù¾
.
mem
 && (
	`isAMO
(id_ù¾.
mem_cmd
è|| id_ù¾.mem_cmd.
	`isOÃOf
(
M_XLR
, 
M_XSC
))),

129 ("sy¡em", (è=> 
id_ù¾
.
c¤
 =/ğ
CSR
.
N
),

130 ("¬™h", (è=> 
id_ù¾
.
wxd
 && !(id_ù¾.
j®
 || id_ù¾.
j®r
 || id_ù¾.
mem
 || id_ù¾.
å
 || id_ù¾.
mul
 || id_ù¾.
div
 || id_ù¾.
c¤
 =/ğ
CSR
.
N
)),

131 ("b¿nch", (è=> 
id_ù¾
.
b¿nch
),

132 ("j®", (è=> 
id_ù¾
.
j®
),

133 ("j®r", (è=> 
id_ù¾
.
j®r
))

134 ++ (ià(!
usšgMulDiv
è
	`Seq
() Seq(

135 ("mul", (è=> ià(
p–šedMul
è
id_ù¾
.
mul
 id_ù¾.
div
 && (id_ù¾.
®u_â
 & 
ALU
.
FN_DIV
) =/= ALU.FN_DIV),

136 ("div", (è=> ià(
p–šedMul
è
id_ù¾
.
div
 id_ù¾.div && (id_ù¾.
®u_â
 & 
ALU
.
FN_DIV
) === ALU.FN_DIV)))

137 ++ (ià(!
usšgFPU
è
	`Seq
() Seq(

138 ("å†ßd", (è=> 
id_ù¾
.
å
 && 
io
.
åu
.
dec
.
ld¡
 && io.åu.dec.
w’
),

139 ("å stÜe", (è=> 
id_ù¾
.
å
 && 
io
.
åu
.
dec
.
ld¡
 && !io.åu.dec.
w’
),

140 ("å‡dd", (è=> 
id_ù¾
.
å
 && 
io
.
åu
.
dec
.
fma
 && io.åu.dec.
sw­23
),

141 ("å mul", (è=> 
id_ù¾
.
å
 && 
io
.
åu
.
dec
.
fma
 && !io.åu.dec.
sw­23
 && !io.åu.dec.
»n3
),

142 ("å mul-add", (è=> 
id_ù¾
.
å
 && 
io
.
åu
.
dec
.
fma
 && io.åu.dec.
»n3
),

143 ("å div/sq¹", (è=> 
id_ù¾
.
å
 && (
io
.
åu
.
dec
.
div
 || io.åu.dec.
sq¹
)),

144 ("å oth”", (è=> 
id_ù¾
.
å
 && !(
io
.
åu
.
dec
.
ld¡
 || io.åu.dec.
fma
 || io.åu.dec.
div
 || io.åu.dec.
sq¹
))))),

145 
Ãw
 
	`Ev’tS‘
((
mask
, 
h™s
è=> (mask & h™s).
ÜR
, 
	`Seq
(

146 ("lßd-u£ iÁ”lock", (è=> 
id_ex_haz¬d
 && 
ex_ù¾
.
mem
 || 
id_mem_haz¬d
 && 
mem_ù¾
.mem || 
id_wb_haz¬d
 && 
wb_ù¾
.mem),

147 ("lÚg-Ï‹ncy iÁ”lock", (è=> 
id_sbßrd_haz¬d
),

148 ("c¤ iÁ”lock", (è=> 
id_ex_haz¬d
 && 
ex_ù¾
.
c¤
 =/ğ
CSR
.
N
 || 
id_mem_haz¬d
 && 
mem_ù¾
.c¤ =/ğCSR.N || 
id_wb_haz¬d
 && 
wb_ù¾
.csr =/= CSR.N),

149 ("I$ blocked", (è=> 
iÿche_blocked
),

150 ("D$ blocked", (è=> 
id_ù¾
.
mem
 && 
dÿche_blocked
),

151 ("b¿nch mi¥»diùiÚ", (è=> 
ke_pc_mem
 && 
mem_dœeùiÚ_mi¥»diùiÚ
),

152 ("cÚŒŞ-æow¬g‘ mi¥»diùiÚ", (è=> 
ke_pc_mem
 && 
mem_mi¥»diùiÚ
 && 
mem_cfi
 && !
mem_dœeùiÚ_mi¥»diùiÚ
 && !
iÿche_blocked
),

153 ("æush", (è=> 
wb_»g_æush_pe
),

154 ("»¶ay", (è=> 
»¶ay_wb
))

155 ++ (ià(!
usšgMulDiv
è
	`Seq
() Seq(

156 ("mul/div iÁ”lock", (è=> 
id_ex_haz¬d
 && (
ex_ù¾
.
mul
 ||ƒx_ù¾.
div
è|| 
id_mem_haz¬d
 && (
mem_ù¾
.muÈ|| mem_ù¾.divè|| 
id_wb_haz¬d
 && 
wb_ù¾
.div)))

157 ++ (ià(!
usšgFPU
è
	`Seq
() Seq(

158 ("å iÁ”lock", (è=> 
id_ex_haz¬d
 && 
ex_ù¾
.
å
 || 
id_mem_haz¬d
 && 
mem_ù¾
.å || 
id_wb_haz¬d
 && 
wb_ù¾
.å || 
id_ù¾
.å && 
id_¡®l_åu
)))),

159 
Ãw
 
	`Ev’tS‘
((
mask
, 
h™s
è=> (mask & h™s).
ÜR
, 
	`Seq
(

160 ("I$ miss", (è=> 
io
.
imem
.
³rf
.
acquœe
),

161 ("D$ miss", (è=> 
io
.
dmem
.
³rf
.
acquœe
),

162 ("D$„–—£", (è=> 
io
.
dmem
.
³rf
.
»Ëa£
),

163 ("ITLB miss", (è=> 
io
.
imem
.
³rf
.
bMiss
),

164 ("DTLB miss", (è=> 
io
.
dmem
.
³rf
.
bMiss
),

165 ("L2 TLB miss", (è=> 
io
.
±w
.
³rf
.
l2miss
)))))

167 
v®
 
p–šedMul
 = 
usšgMulDiv
 && 
mulDivP¬ams
.
mulUÄŞl
 =ğ
xL’


168 
v®
 
decode_bË
 = {

169 
	`»quœe
(!
usšgRoCC
 || !
rock‘P¬ams
.
u£SCIE
)

170 (ià(
usšgMulDiv
è
Ãw
 
	`MDecode
(
p–šedMul
è+: (
xL’
 > 32).
	`İtiÚ
Òew 
	`M64Decode
Õ–šedMul)).
toSeq
 
N
) ++:

171 (ià(
usšgAtomics
è
Ãw
 
ADecode
 +: (
xL’
 > 32).
	`İtiÚ
Òew 
A64Decode
).
toSeq
 
N
) ++:

172 (ià(
fL’
 >ğ32è
Ãw
 
FDecode
 +: (
xL’
 > 32).
	`İtiÚ
Òew 
F64Decode
).
toSeq
 
N
) ++:

173 (ià(
fL’
 >ğ64è
Ãw
 
DDecode
 +: (
xL’
 > 32).
	`İtiÚ
Òew 
D64Decode
).
toSeq
 
N
) ++:

174 (
usšgRoCC
.
	`İtiÚ
(
Ãw
 
RoCCDecode
)) ++:

175 (
rock‘P¬ams
.
u£SCIE
.
	`İtiÚ
(
Ãw
 
SCIEDecode
)) ++:

176 (ià(
xL’
 =ğ32è
Ãw
 
I32Decode
 Ãw 
I64Decode
) +:

177 (
usšgVM
.
	`İtiÚ
(
Ãw
 
SDecode
)) ++:

178 (
usšgDebug
.
	`İtiÚ
(
Ãw
 
DebugDecode
)) ++:

179 
	`Seq
(
Ãw
 
IDecode
)

180 } 
	`æ©M­
(
_
.
bË
)

182 
v®
 
ex_ù¾
 = 
	`Reg
(
Ãw
 
IÁCŒlSigs
)

183 
v®
 
mem_ù¾
 = 
	`Reg
(
Ãw
 
IÁCŒlSigs
)

184 
v®
 
wb_ù¾
 = 
	`Reg
(
Ãw
 
IÁCŒlSigs
)

186 
v®
 
ex_»g_xıt_š‹¼u±
 = 
	`Reg
(
	`BoŞ
())

187 
v®
 
ex_»g_v®id
 = 
	`Reg
(
	`BoŞ
())

188 
v®
 
ex_»g_rvc
 = 
	`Reg
(
	`BoŞ
())

189 
v®
 
ex_»g_btb_»¥
 = 
	`Reg
(
Ãw
 
BTBRe¥
)

190 
v®
 
ex_»g_xıt
 = 
	`Reg
(
	`BoŞ
())

191 
v®
 
ex_»g_æush_pe
 = 
	`Reg
(
	`BoŞ
())

192 
v®
 
ex_»g_lßd_u£
 = 
	`Reg
(
	`BoŞ
())

193 
v®
 
ex_»g_ÿu£
 = 
	`Reg
(
	`UIÁ
())

194 
v®
 
ex_»g_»¶ay
 = 
	`Reg
(
	`BoŞ
())

195 
v®
 
ex_»g_pc
 = 
	`Reg
(
	`UIÁ
())

196 
v®
 
ex_»g_š¡
 = 
	`Reg
(
	`B™s
())

197 
v®
 
ex_»g_¿w_š¡
 = 
	`Reg
(
	`UIÁ
())

199 
v®
 
mem_»g_xıt_š‹¼u±
 = 
	`Reg
(
	`BoŞ
())

200 
v®
 
mem_»g_v®id
 = 
	`Reg
(
	`BoŞ
())

201 
v®
 
mem_»g_rvc
 = 
	`Reg
(
	`BoŞ
())

202 
v®
 
mem_»g_btb_»¥
 = 
	`Reg
(
Ãw
 
BTBRe¥
)

203 
v®
 
mem_»g_xıt
 = 
	`Reg
(
	`BoŞ
())

204 
v®
 
mem_»g_»¶ay
 = 
	`Reg
(
	`BoŞ
())

205 
v®
 
mem_»g_æush_pe
 = 
	`Reg
(
	`BoŞ
())

206 
v®
 
mem_»g_ÿu£
 = 
	`Reg
(
	`UIÁ
())

207 
v®
 
mem_»g_¦ow_by·ss
 = 
	`Reg
(
	`BoŞ
())

208 
v®
 
mem_»g_lßd
 = 
	`Reg
(
	`BoŞ
())

209 
v®
 
mem_»g_¡Üe
 = 
	`Reg
(
	`BoŞ
())

210 
v®
 
mem_»g_sãnû
 = 
	`Reg
(
	`BoŞ
())

211 
v®
 
mem_»g_pc
 = 
	`Reg
(
	`UIÁ
())

212 
v®
 
mem_»g_š¡
 = 
	`Reg
(
	`B™s
())

213 
v®
 
mem_»g_¿w_š¡
 = 
	`Reg
(
	`UIÁ
())

214 
v®
 
mem_»g_wd©a
 = 
	`Reg
(
	`B™s
())

215 
v®
 
mem_»g_rs2
 = 
	`Reg
(
	`B™s
())

216 
v®
 
mem_br_k’
 = 
	`Reg
(
	`BoŞ
())

217 
v®
 
ke_pc_mem
 = 
	`Wœe
(
	`BoŞ
())

219 
v®
 
wb_»g_v®id
 = 
	`Reg
(
	`BoŞ
())

220 
v®
 
wb_»g_xıt
 = 
	`Reg
(
	`BoŞ
())

221 
v®
 
wb_»g_»¶ay
 = 
	`Reg
(
	`BoŞ
())

222 
v®
 
wb_»g_æush_pe
 = 
	`Reg
(
	`BoŞ
())

223 
v®
 
wb_»g_ÿu£
 = 
	`Reg
(
	`UIÁ
())

224 
v®
 
wb_»g_sãnû
 = 
	`Reg
(
	`BoŞ
())

225 
v®
 
wb_»g_pc
 = 
	`Reg
(
	`UIÁ
())

226 
v®
 
wb_»g_š¡
 = 
	`Reg
(
	`B™s
())

227 
v®
 
wb_»g_¿w_š¡
 = 
	`Reg
(
	`UIÁ
())

228 
v®
 
wb_»g_wd©a
 = 
	`Reg
(
	`B™s
())

229 
v®
 
wb_»g_rs2
 = 
	`Reg
(
	`B™s
())

230 
v®
 
ke_pc_wb
 = 
	`Wœe
(
	`BoŞ
())

232 
v®
 
ke_pc_mem_wb
 = 
ke_pc_wb
 || 
ke_pc_mem


233 
v®
 
ke_pc
 = 
ke_pc_mem_wb


236 
v®
 
ibuf
 = 
	`ModuË
(
Ãw
 
IBuf
)

237 
v®
 
id_ex·nded_š¡
 = 
ibuf
.
io
.
š¡
.
	`m­
(
_
.
b™s
.inst)

238 
v®
 
id_¿w_š¡
 = 
ibuf
.
io
.
š¡
.
	`m­
(
_
.
b™s
.
¿w
)

239 
v®
 
id_š¡
 = 
id_ex·nded_š¡
.
	`m­
(
_
.
b™s
)

240 
ibuf
.
io
.
imem
 <> io.imem.
»¥


241 
ibuf
.
io
.
kl
 :ğ
ke_pc


243 
	`»quœe
(
decodeWidth
 =ğ1 && 
»tœeWidth
 == decodeWidth)

244 
v®
 
id_ù¾
 = 
	`Wœe
(
Ãw
 
	`IÁCŒlSigs
()).
	`decode
(
	`id_š¡
(0), 
decode_bË
)

245 
v®
 
id_¿ddr3
 = 
	`id_ex·nded_š¡
(0).
rs3


246 
v®
 
id_¿ddr2
 = 
	`id_ex·nded_š¡
(0).
rs2


247 
v®
 
id_¿ddr1
 = 
	`id_ex·nded_š¡
(0).
rs1


248 
v®
 
id_waddr
 = 
	`id_ex·nded_š¡
(0).
rd


249 
v®
 
id_lßd_u£
 = 
	`Wœe
(
	`BoŞ
())

250 
v®
 
id_»g_ãnû
 = 
	`Reg
(
š™
=
	`BoŞ
(
çl£
))

251 
v®
 
id_»n
 = 
	`IndexedSeq
(
id_ù¾
.
rxs1
, id_ù¾.
rxs2
)

252 
v®
 
id_¿ddr
 = 
	`IndexedSeq
(
id_¿ddr1
, 
id_¿ddr2
)

253 
v®
 
rf
 = 
Ãw
 
	`RegFe
(31, 
xL’
)

254 
v®
 
id_rs
 = 
id_¿ddr
.
	`m­
(
rf
.
»ad
 
_
)

255 
v®
 
ù¾_kld
 = 
	`Wœe
(
	`BoŞ
())

256 
v®
 
id_Åc
 = (
ibuf
.
io
.
pc
.
asSIÁ
 + 
	`ImmG’
(
IMM_UJ
, 
	`id_š¡
(0))).
asUIÁ


257 
v®
 
c¤
 = 
	`ModuË
(
Ãw
 
	`CSRFe
(
³rfEv’ts
, 
cÜeP¬ams
.
cu¡omCSRs
.
deşs
))

258 
v®
 
id_c¤_’
 = 
id_ù¾
.
c¤
.
	`isOÃOf
(
CSR
.
S
, CSR.
C
, CSR.
W
)

259 
v®
 
id_sy¡em_š¢
 = 
id_ù¾
.
c¤
 ==ğ
CSR
.
I


260 
v®
 
id_c¤_»n
 = 
id_ù¾
.
c¤
.
	`isOÃOf
(
CSR
.
S
, CSR.
C
è&& 
id_¿ddr1
 ==ğ
	`UIÁ
(0)

261 
v®
 
id_c¤
 = 
	`Mux
(
id_c¤_»n
, 
CSR
.
R
, 
id_ù¾
.
c¤
)

262 
v®
 
id_sãnû
 = 
id_ù¾
.
mem
 && id_ù¾.
mem_cmd
 ==ğ
M_SFENCE


263 
v®
 
id_c¤_æush
 = 
id_sãnû
 || 
id_sy¡em_š¢
 || (
id_c¤_’
 && !
id_c¤_»n
 && 
c¤
.
io
.
	`decode
(0).
wr™e_æush
)

268 
io
.
±w
.
pcode_»q
 :ğ
c¤
.io.pcode_req

269 
c¤
.
io
.
pcode_»¥
 :ğio.
±w
.pcode_resp

272 
v®
 
sc›_decod”
 = 
rock‘P¬ams
.
u£SCIE
.
İtiÚ
 {

273 
v®
 
d
 = 
	`ModuË
(
Ãw
 
SCIEDecod”
)

274 
	`as£¹
(!
d
.
io
.
p–šed
 && !d.io.
muÉicyşe
)

275 
d
.
io
.
š¢
 :ğ
	`id_¿w_š¡
(0)

276 
d
.
io


278 
v®
 
id_Ëg®_š¢
 = !
id_ù¾
.
Ëg®
 ||

279 (
id_ù¾
.
mul
 || id_ù¾.
div
è&& !
c¤
.
io
.
¡©us
.
	`i§
('m'-'a') ||

280 
id_ù¾
.
amo
 && !
c¤
.
io
.
¡©us
.
	`i§
('a'-'a') ||

281 
id_ù¾
.
å
 && (
c¤
.
io
.
	`decode
(0).
å_Ëg®
 || io.
åu
.
Ëg®_rm
) ||

282 
id_ù¾
.
dp
 && !
c¤
.
io
.
¡©us
.
	`i§
('d'-'a') ||

283 
ibuf
.
io
.
	`š¡
(0).
b™s
.
rvc
 && !
c¤
.io.
¡©us
.
	`i§
('c'-'a') ||

284 
id_ù¾
.
rocc
 && 
c¤
.
io
.
	`decode
(0).
rocc_Ëg®
 ||

285 
id_ù¾
.
sc›
 && 
sc›_decod”
.
	`m­
(!
_
.
uÅ–šed
).
	`g‘OrEl£
(
çl£
.
B
) ||

286 
id_c¤_’
 && (
c¤
.
io
.
	`decode
(0).
»ad_Ëg®
 || !
id_c¤_»n
 && c¤.io.decode(0).
wr™e_Ëg®
) ||

287 !
ibuf
.
io
.
	`š¡
(0).
b™s
.
rvc
 && ((
id_sãnû
 || 
id_sy¡em_š¢
è&& 
c¤
.io.
	`decode
(0).
sy¡em_Ëg®
)

289 
v®
 
id_amo_aq
 = 
	`id_š¡
(0)(26)

290 
v®
 
id_amo_¾
 = 
	`id_š¡
(0)(25)

291 
v®
 
id_ãnû_Ãxt
 = 
id_ù¾
.
ãnû
 || id_ù¾.
amo
 && 
id_amo_aq


292 
v®
 
id_mem_busy
 = !
io
.
dmem
.
Üd”ed
 || io.dmem.
»q
.
v®id


293 
	`wh’
 (!
id_mem_busy
è{ 
id_»g_ãnû
 :ğ
çl£
 }

294 
v®
 
id_rocc_busy
 = 
	`BoŞ
(
usšgRoCC
) &&

295 (
io
.
rocc
.
busy
 || 
ex_»g_v®id
 && 
ex_ù¾
.rocc ||

296 
mem_»g_v®id
 && 
mem_ù¾
.
rocc
 || 
wb_»g_v®id
 && 
wb_ù¾
.rocc)

297 
v®
 
id_do_ãnû
 = 
	`Wœe
(
š™
 = 
id_rocc_busy
 && 
id_ù¾
.
ãnû
 ||

298 
id_mem_busy
 && (
id_ù¾
.
amo
 && 
id_amo_¾
 || id_ù¾.
ãnû_i
 || 
id_»g_ãnû
 && (id_ù¾.
mem
 || id_ù¾.
rocc
)))

300 
v®
 
bpu
 = 
	`ModuË
(
Ãw
 
	`B»akpoštUn™
(
nB»akpošts
))

301 
bpu
.
io
.
¡©us
 :ğ
c¤
.io.status

302 
bpu
.
io
.
bp
 :ğ
c¤
.io.bp

303 
bpu
.
io
.
pc
 :ğ
ibuf
.io.pc

304 
bpu
.
io
.
—
 :ğ
mem_»g_wd©a


306 
v®
 
id_xıt0
 = 
ibuf
.
io
.
	`š¡
(0).
b™s
.
xıt0


307 
v®
 
id_xıt1
 = 
ibuf
.
io
.
	`š¡
(0).
b™s
.
xıt1


308 
	`v®
 (
id_xıt
, 
id_ÿu£
èğ
	`checkExû±iÚs
(
	`Li¡
(

309 (
c¤
.
io
.
š‹¼u±
, c¤.io.
š‹¼u±_ÿu£
),

310 (
bpu
.
io
.
debug_if
, 
	`UIÁ
(
CSR
.
debugTrigg”Cau£
)),

311 (
bpu
.
io
.
xıt_if
, 
	`UIÁ
(
Cau£s
.
b»akpošt
)),

312 (
id_xıt0
.
pf
.
š¡
, 
	`UIÁ
(
Cau£s
.
ãtch_·ge_çuÉ
)),

313 (
id_xıt0
.
«
.
š¡
, 
	`UIÁ
(
Cau£s
.
ãtch_acûss
)),

314 (
id_xıt1
.
pf
.
š¡
, 
	`UIÁ
(
Cau£s
.
ãtch_·ge_çuÉ
)),

315 (
id_xıt1
.
«
.
š¡
, 
	`UIÁ
(
Cau£s
.
ãtch_acûss
)),

316 (
id_Ëg®_š¢
, 
	`UIÁ
(
Cau£s
.
Ëg®_š¡ruùiÚ
))))

318 
v®
 
idCov”Cau£s
 = 
	`Li¡
(

319 (
CSR
.
debugTrigg”Cau£
, "DEBUG_TRIGGER"),

320 (
Cau£s
.
b»akpošt
, "BREAKPOINT"),

321 (
Cau£s
.
ãtch_·ge_çuÉ
, "FETCH_PAGE_FAULT"),

322 (
Cau£s
.
ãtch_acûss
, "FETCH_ACCESS"),

323 (
Cau£s
.
Ëg®_š¡ruùiÚ
, "ILLEGAL_INSTRUCTION")

325 
	`cov”Exû±iÚs
(
id_xıt
, 
id_ÿu£
, "DECODE", 
idCov”Cau£s
)

327 
v®
 
dÿche_by·ss_d©a
 =

328 ià(
ç¡LßdBy‹
è
io
.
dmem
.
»¥
.
b™s
.
	`d©a
(
xL’
-1, 0)

329 ià(
ç¡LßdWÜd
è
io
.
dmem
.
»¥
.
b™s
.
	`d©a_wÜd_by·ss
(
xL’
-1, 0)

330 
wb_»g_wd©a


333 
v®
 
ex_waddr
 = 
	`ex_»g_š¡
(11,7)

334 
v®
 
mem_waddr
 = 
	`mem_»g_š¡
(11,7)

335 
v®
 
wb_waddr
 = 
	`wb_»g_š¡
(11,7)

336 
v®
 
by·ss_sourûs
 = 
	`IndexedSeq
(

337 (
	`BoŞ
(
Œue
), 
	`UIÁ
(0), UInt(0)),

338 (
ex_»g_v®id
 && 
ex_ù¾
.
wxd
, 
ex_waddr
, 
mem_»g_wd©a
),

339 (
mem_»g_v®id
 && 
mem_ù¾
.
wxd
 && !mem_ù¾.
mem
, 
mem_waddr
, 
wb_»g_wd©a
),

340 (
mem_»g_v®id
 && 
mem_ù¾
.
wxd
, 
mem_waddr
, 
dÿche_by·ss_d©a
))

341 
v®
 
id_by·ss_¤c
 = 
id_¿ddr
.
	`m­
(
¿ddr
 => 
by·ss_sourûs
.m­(
s
 => s.
_1
 && s.
_2
 ===„addr))

344 
v®
 
by·ss_mux
 = 
by·ss_sourûs
.
	`m­
(
_
.
_3
)

345 
v®
 
ex_»g_rs_by·ss
 = 
	`Reg
(
	`Vec
(
id_¿ddr
.
size
, 
	`BoŞ
()))

346 
v®
 
ex_»g_rs_lsb
 = 
	`Reg
(
	`Vec
(
id_¿ddr
.
size
, 
	`UIÁ
(
width
 = 
	`log2Ce
(
by·ss_sourûs
.size))))

347 
v®
 
ex_»g_rs_msb
 = 
	`Reg
(
	`Vec
(
id_¿ddr
.
size
, 
	`UIÁ
()))

348 
v®
 
ex_rs
 = 
i
 <- 0 
uÁ
 
id_¿ddr
.
size
)

349 
y›ld
 
	`Mux
(
	`ex_»g_rs_by·ss
(
i
), 
	`by·ss_mux
(
	`ex_»g_rs_lsb
(i)), 
	`C©
(
	`ex_»g_rs_msb
(i),ƒx_reg_rs_lsb(i)))

350 
v®
 
ex_imm
 = 
	`ImmG’
(
ex_ù¾
.
£l_imm
, 
ex_»g_š¡
)

351 
v®
 
ex_İ1
 = 
	`MuxLookup
(
ex_ù¾
.
£l_®u1
, 
	`SIÁ
(0), 
	`Seq
(

352 
A1_RS1
 -> 
	`ex_rs
(0).
asSIÁ
,

353 
A1_PC
 -> 
ex_»g_pc
.
asSIÁ
))

354 
v®
 
ex_İ2
 = 
	`MuxLookup
(
ex_ù¾
.
£l_®u2
, 
	`SIÁ
(0), 
	`Seq
(

355 
A2_RS2
 -> 
	`ex_rs
(1).
asSIÁ
,

356 
A2_IMM
 -> 
ex_imm
,

357 
A2_SIZE
 -> 
	`Mux
(
ex_»g_rvc
, 
	`SIÁ
(2), SInt(4))))

359 
v®
 
®u
 = 
	`ModuË
(
Ãw
 
ALU
)

360 
®u
.
io
.
dw
 :ğ
ex_ù¾
.
®u_dw


361 
®u
.
io
.
â
 :ğ
ex_ù¾
.
®u_â


362 
®u
.
io
.
š2
 :ğ
ex_İ2
.
asUIÁ


363 
®u
.
io
.
š1
 :ğ
ex_İ1
.
asUIÁ


365 
v®
 
sc›_uÅ–šed
 = 
rock‘P¬ams
.
u£SCIE
.
İtiÚ
 {

366 
v®
 
u
 = 
	`ModuË
(
Ãw
 
	`SCIEUÅ–šed
(
xL’
))

367 
u
.
io
.
š¢
 :ğ
ex_»g_š¡


368 
u
.
io
.
rs1
 :ğ
	`ex_rs
(0)

369 
u
.
io
.
rs2
 :ğ
	`ex_rs
(1)

370 
u
.
io
.
rd


374 
v®
 
div
 = 
	`ModuË
(
Ãw
 
	`MulDiv
(ià(
p–šedMul
è
mulDivP¬ams
.
	`cİy
(
mulUÄŞl
 = 0èmulDivP¬ams, 
width
 = 
xL’
))

375 
div
.
io
.
»q
.
v®id
 :ğ
ex_»g_v®id
 && 
ex_ù¾
.div

376 
div
.
io
.
»q
.
b™s
.
dw
 :ğ
ex_ù¾
.
®u_dw


377 
div
.
io
.
»q
.
b™s
.
â
 :ğ
ex_ù¾
.
®u_â


378 
div
.
io
.
»q
.
b™s
.
š1
 :ğ
	`ex_rs
(0)

379 
div
.
io
.
»q
.
b™s
.
š2
 :ğ
	`ex_rs
(1)

380 
div
.
io
.
»q
.
b™s
.
g
 :ğ
ex_waddr


381 
v®
 
mul
 = 
p–šedMul
.
İtiÚ
 {

382 
v®
 
m
 = 
	`ModuË
(
Ãw
 
	`P–šedMuÉl›r
(
xL’
, 2))

383 
m
.
io
.
»q
.
v®id
 :ğ
ex_»g_v®id
 && 
ex_ù¾
.
mul


384 
m
.
io
.
»q
.
b™s
 :ğ
div
.io.req.bits

385 
m


388 
ex_»g_v®id
 :ğ!
ù¾_kld


389 
ex_»g_»¶ay
 :ğ!
ke_pc
 && 
ibuf
.
io
.
	`š¡
(0).
v®id
 && ibuf.io.š¡(0).
b™s
.
»¶ay


390 
ex_»g_xıt
 :ğ!
ù¾_kld
 && 
id_xıt


391 
ex_»g_xıt_š‹¼u±
 :ğ!
ke_pc
 && 
ibuf
.
io
.
	`š¡
(0).
v®id
 && 
c¤
.io.
š‹¼u±


393 
	`wh’
 (!
ù¾_kld
) {

394 
ex_ù¾
 :ğ
id_ù¾


395 
ex_»g_rvc
 :ğ
ibuf
.
io
.
	`š¡
(0).
b™s
.
rvc


396 
ex_ù¾
.
c¤
 :ğ
id_c¤


397 
	`wh’
 (
id_ãnû_Ãxt
è{ 
id_»g_ãnû
 :ğ
Œue
 }

398 
	`wh’
 (
id_xıt
) {

399 
ex_ù¾
.
®u_â
 :ğ
ALU
.
FN_ADD


400 
ex_ù¾
.
®u_dw
 :ğ
DW_XPR


401 
ex_ù¾
.
£l_®u1
 :ğ
A1_RS1


402 
ex_ù¾
.
£l_®u2
 :ğ
A2_ZERO


403 
	`wh’
 (
id_xıt1
.
asUIÁ
.
ÜR
) {

404 
ex_ù¾
.
£l_®u1
 :ğ
A1_PC


405 
ex_ù¾
.
£l_®u2
 :ğ
A2_SIZE


406 
ex_»g_rvc
 :ğ
Œue


408 
	`wh’
 (
bpu
.
io
.
xıt_if
 || 
id_xıt0
.
asUIÁ
.
ÜR
) {

409 
ex_ù¾
.
£l_®u1
 :ğ
A1_PC


410 
ex_ù¾
.
£l_®u2
 :ğ
A2_ZERO


413 
ex_»g_æush_pe
 :ğ
id_ù¾
.
ãnû_i
 || 
id_c¤_æush


414 
ex_»g_lßd_u£
 :ğ
id_lßd_u£


415 
	`wh’
 (
id_sãnû
) {

416 
ex_ù¾
.
mem_ty³
 :ğ
	`C©
(
id_¿ddr2
 =/ğ
	`UIÁ
(0), 
id_¿ddr1
 =/= UInt(0))

419 
i
 <- 0 
uÁ
 
id_¿ddr
.
size
) {

420 
v®
 
do_by·ss
 = 
	`id_by·ss_¤c
(
i
).
	`»duû
(
_
||_)

421 
v®
 
by·ss_¤c
 = 
	`PriÜ™yEncod”
(
	`id_by·ss_¤c
(
i
))

422 
	`ex_»g_rs_by·ss
(
i
è:ğ
do_by·ss


423 
	`ex_»g_rs_lsb
(
i
è:ğ
by·ss_¤c


424 
	`wh’
 (
	`id_»n
(
i
è&& !
do_by·ss
) {

425 
	`ex_»g_rs_lsb
(
i
è:ğ
	`id_rs
(i)(
	`log2Ce
(
by·ss_sourûs
.
size
)-1, 0)

426 
	`ex_»g_rs_msb
(
i
è:ğ
	`id_rs
(iè>> 
	`log2Ce
(
by·ss_sourûs
.
size
)

429 
	`wh’
 (
id_Ëg®_š¢
) {

430 
v®
 
š¡
 = 
	`Mux
(
ibuf
.
io
.
	`š¡
(0).
b™s
.
rvc
, 
	`id_¿w_š¡
(0)(15, 0), id_raw_inst(0))

431 
	`ex_»g_rs_by·ss
(0è:ğ
çl£


432 
	`ex_»g_rs_lsb
(0è:ğ
	`š¡
(
	`log2Ce
(
by·ss_sourûs
.
size
)-1, 0)

433 
	`ex_»g_rs_msb
(0è:ğ
š¡
 >> 
	`log2Ce
(
by·ss_sourûs
.
size
)

436 
	`wh’
 (!
ù¾_kld
 || 
c¤
.
io
.
š‹¼u±
 || 
ibuf
.io.
	`š¡
(0).
b™s
.
»¶ay
) {

437 
ex_»g_ÿu£
 :ğ
id_ÿu£


438 
ex_»g_š¡
 :ğ
	`id_š¡
(0)

439 
ex_»g_¿w_š¡
 :ğ
	`id_¿w_š¡
(0)

440 
ex_»g_pc
 :ğ
ibuf
.
io
.
pc


441 
ex_»g_btb_»¥
 :ğ
ibuf
.
io
.
btb_»¥


445 
v®
 
ex_pc_v®id
 = 
ex_»g_v®id
 || 
ex_»g_»¶ay
 || 
ex_»g_xıt_š‹¼u±


446 
v®
 
wb_dÿche_miss
 = 
wb_ù¾
.
mem
 && !
io
.
dmem
.
»¥
.
v®id


447 
v®
 
»¶ay_ex_¡ruùu¿l
 = 
ex_ù¾
.
mem
 && !
io
.
dmem
.
»q
.
»ady
 ||

448 
ex_ù¾
.
div
 && !div.
io
.
»q
.
»ady


449 
v®
 
»¶ay_ex_lßd_u£
 = 
wb_dÿche_miss
 && 
ex_»g_lßd_u£


450 
v®
 
»¶ay_ex
 = 
ex_»g_»¶ay
 || (
ex_»g_v®id
 && (
»¶ay_ex_¡ruùu¿l
 || 
»¶ay_ex_lßd_u£
))

451 
v®
 
ù¾_klx
 = 
ke_pc_mem_wb
 || 
»¶ay_ex
 || !
ex_»g_v®id


453 
v®
 
ex_¦ow_by·ss
 = 
ex_ù¾
.
mem_cmd
 ==ğ
M_XSC
 || 
	`Vec
(
MT_B
, 
MT_BU
, 
MT_H
, 
MT_HU
).
	`cÚšs
Óx_ù¾.
mem_ty³
)

454 
v®
 
ex_sãnû
 = 
	`BoŞ
(
usšgVM
è&& 
ex_ù¾
.
mem
 &&ƒx_ù¾.
mem_cmd
 ==ğ
M_SFENCE


456 
	`v®
 (
ex_xıt
, 
ex_ÿu£
èğ
	`checkExû±iÚs
(
	`Li¡
(

457 (
ex_»g_xıt_š‹¼u±
 || 
ex_»g_xıt
, 
ex_»g_ÿu£
)))

459 
v®
 
exCov”Cau£s
 = 
idCov”Cau£s


460 
	`cov”Exû±iÚs
(
ex_xıt
, 
ex_ÿu£
, "EXECUTE", 
exCov”Cau£s
)

463 
v®
 
mem_pc_v®id
 = 
mem_»g_v®id
 || 
mem_»g_»¶ay
 || 
mem_»g_xıt_š‹¼u±


464 
v®
 
mem_br_rg‘
 = 
mem_»g_pc
.
asSIÁ
 +

465 
	`Mux
(
mem_ù¾
.
b¿nch
 && 
mem_br_k’
, 
	`ImmG’
(
IMM_SB
, 
mem_»g_š¡
),

466 
	`Mux
(
mem_ù¾
.
j®
, 
	`ImmG’
(
IMM_UJ
, 
mem_»g_š¡
),

467 
	`Mux
(
mem_»g_rvc
, 
	`SIÁ
(2), SInt(4))))

468 
v®
 
mem_Åc
 = (
	`Mux
(
mem_ù¾
.
j®r
 || 
mem_»g_sãnû
, 
	`’codeVœtu®Add»ss
(
mem_»g_wd©a
, mem_»g_wd©a).
asSIÁ
, 
mem_br_rg‘
è& 
	`SIÁ
(-2)).
asUIÁ


469 
v®
 
mem_wrÚg_Åc
 =

470 
	`Mux
(
ex_pc_v®id
, 
mem_Åc
 =/ğ
ex_»g_pc
,

471 
	`Mux
(
ibuf
.
io
.
	`š¡
(0).
v®id
 || ibuf.io.
imem
.v®id, 
mem_Åc
 =/ğibuf.io.
pc
, 
	`BoŞ
(
Œue
)))

472 
v®
 
mem_Åc_mi§ligÃd
 = !
c¤
.
io
.
¡©us
.
	`i§
('c'-'a'è&& 
	`mem_Åc
(1è&& !
mem_»g_sãnû


473 
v®
 
mem_št_wd©a
 = 
	`Mux
(!
mem_»g_xıt
 && (
mem_ù¾
.
j®r
 ^ 
mem_Åc_mi§ligÃd
), 
mem_br_rg‘
, 
mem_»g_wd©a
.
asSIÁ
).
asUIÁ


474 
v®
 
mem_cfi
 = 
mem_ù¾
.
b¿nch
 || mem_ù¾.
j®r
 || mem_ù¾.
j®


475 
v®
 
mem_cfi_k’
 = (
mem_ù¾
.
b¿nch
 && 
mem_br_k’
è|| mem_ù¾.
j®r
 || mem_ù¾.
j®


476 
v®
 
mem_dœeùiÚ_mi¥»diùiÚ
 = 
mem_ù¾
.
b¿nch
 && 
mem_br_k’
 =/ğ(
usšgBTB
 && 
mem_»g_btb_»¥
.
k’
)

477 
v®
 
mem_mi¥»diùiÚ
 = ià(
usšgBTB
è
mem_wrÚg_Åc
 
mem_cfi_k’


478 
ke_pc_mem
 :ğ
mem_»g_v®id
 && (
mem_mi¥»diùiÚ
 || 
mem_»g_sãnû
)

480 
mem_»g_v®id
 :ğ!
ù¾_klx


481 
mem_»g_»¶ay
 :ğ!
ke_pc_mem_wb
 && 
»¶ay_ex


482 
mem_»g_xıt
 :ğ!
ù¾_klx
 && 
ex_xıt


483 
mem_»g_xıt_š‹¼u±
 :ğ!
ke_pc_mem_wb
 && 
ex_»g_xıt_š‹¼u±


487 
	`wh’
 (
mem_»g_v®id
 && 
mem_»g_æush_pe
) {

488 
mem_»g_sãnû
 :ğ
çl£


489 }.
	`–£wh’
 (
ex_pc_v®id
) {

490 
mem_ù¾
 :ğ
ex_ù¾


491 
mem_»g_rvc
 :ğ
ex_»g_rvc


492 
mem_»g_lßd
 :ğ
ex_ù¾
.
mem
 && 
	`isR—d
Óx_ù¾.
mem_cmd
)

493 
mem_»g_¡Üe
 :ğ
ex_ù¾
.
mem
 && 
	`isWr™e
Óx_ù¾.
mem_cmd
)

494 
mem_»g_sãnû
 :ğ
ex_sãnû


495 
mem_»g_btb_»¥
 :ğ
ex_»g_btb_»¥


496 
mem_»g_æush_pe
 :ğ
ex_»g_æush_pe


497 
mem_»g_¦ow_by·ss
 :ğ
ex_¦ow_by·ss


499 
mem_»g_ÿu£
 :ğ
ex_ÿu£


500 
mem_»g_š¡
 :ğ
ex_»g_š¡


501 
mem_»g_¿w_š¡
 :ğ
ex_»g_¿w_š¡


502 
mem_»g_pc
 :ğ
ex_»g_pc


503 
mem_»g_wd©a
 :ğ
sc›_uÅ–šed
.
	`m­
(
u
 => 
	`Mux
(
ex_ù¾
.
sc›
, u, 
®u
.
io
.
out
)).
	`g‘OrEl£
(alu.io.out)

504 
mem_br_k’
 :ğ
®u
.
io
.
cmp_out


506 
	`wh’
 (
ex_ù¾
.
rxs2
 && (ex_ù¾.
mem
 ||ƒx_ù¾.
rocc
 || 
ex_sãnû
)) {

507 
v®
 
typ
 = 
	`Mux
(
ex_ù¾
.
rocc
, 
	`log2Ce
(
xL’
/8).
U
,ƒx_ù¾.
mem_ty³
)

508 
mem_»g_rs2
 :ğ
Ãw
 
	`StÜeG’
(
typ
, 0.U, 
	`ex_rs
(1), 
cÜeD©aBy‹s
).
d©a


510 
	`wh’
 (
ex_ù¾
.
j®r
 && 
c¤
.
io
.
¡©us
.
debug
) {

512 
mem_ù¾
.
ãnû_i
 :ğ
Œue


513 
mem_»g_æush_pe
 :ğ
Œue


517 
v®
 
mem_b»akpošt
 = (
mem_»g_lßd
 && 
bpu
.
io
.
xıt_ld
è|| (
mem_»g_¡Üe
 && bpu.io.
xıt_¡
)

518 
v®
 
mem_debug_b»akpošt
 = (
mem_»g_lßd
 && 
bpu
.
io
.
debug_ld
è|| (
mem_»g_¡Üe
 && bpu.io.
debug_¡
)

519 
	`v®
 (
mem_ld¡_xıt
, 
mem_ld¡_ÿu£
èğ
	`checkExû±iÚs
(
	`Li¡
(

520 (
mem_debug_b»akpošt
, 
	`UIÁ
(
CSR
.
debugTrigg”Cau£
)),

521 (
mem_b»akpošt
, 
	`UIÁ
(
Cau£s
.
b»akpošt
))))

523 
	`v®
 (
mem_xıt
, 
mem_ÿu£
èğ
	`checkExû±iÚs
(
	`Li¡
(

524 (
mem_»g_xıt_š‹¼u±
 || 
mem_»g_xıt
, 
mem_»g_ÿu£
),

525 (
mem_»g_v®id
 && 
mem_Åc_mi§ligÃd
, 
	`UIÁ
(
Cau£s
.
mi§ligÃd_ãtch
)),

526 (
mem_»g_v®id
 && 
mem_ld¡_xıt
, 
mem_ld¡_ÿu£
)))

528 
v®
 
memCov”Cau£s
 = (
exCov”Cau£s
 ++ 
	`Li¡
(

529 (
CSR
.
debugTrigg”Cau£
, "DEBUG_TRIGGER"),

530 (
Cau£s
.
b»akpošt
, "BREAKPOINT"),

531 (
Cau£s
.
mi§ligÃd_ãtch
, "MISALIGNED_FETCH")

532 )).
di¡šù


533 
	`cov”Exû±iÚs
(
mem_xıt
, 
mem_ÿu£
, "MEMORY", 
memCov”Cau£s
)

535 
v®
 
dÿche_kl_mem
 = 
mem_»g_v®id
 && 
mem_ù¾
.
wxd
 && 
io
.
dmem
.
»¶ay_Ãxt


536 
v®
 
åu_kl_mem
 = 
mem_»g_v®id
 && 
mem_ù¾
.
å
 && 
io
.
åu
.
Çck_mem


537 
v®
 
»¶ay_mem
 = 
dÿche_kl_mem
 || 
mem_»g_»¶ay
 || 
åu_kl_mem


538 
v®
 
klm_commÚ
 = 
dÿche_kl_mem
 || 
ke_pc_wb
 || 
mem_»g_xıt
 || !
mem_»g_v®id


539 
div
.
io
.
kl
 :ğ
klm_commÚ
 && 
	`Reg
(
Ãxt
 = div.io.
»q
.
	`fœe
())

540 
v®
 
ù¾_klm
 = 
klm_commÚ
 || 
mem_xıt
 || 
åu_kl_mem


543 
wb_»g_v®id
 :ğ!
ù¾_klm


544 
wb_»g_»¶ay
 :ğ
»¶ay_mem
 && !
ke_pc_wb


545 
wb_»g_xıt
 :ğ
mem_xıt
 && !
ke_pc_wb


546 
wb_»g_æush_pe
 :ğ!
ù¾_klm
 && 
mem_»g_æush_pe


547 
	`wh’
 (
mem_pc_v®id
) {

548 
wb_ù¾
 :ğ
mem_ù¾


549 
wb_»g_sãnû
 :ğ
mem_»g_sãnû


550 
wb_»g_wd©a
 :ğ
	`Mux
(!
mem_»g_xıt
 && 
mem_ù¾
.
å
 && mem_ù¾.
wxd
, 
io
.
åu
.
tošt_d©a
, 
mem_št_wd©a
)

551 
	`wh’
 (
mem_ù¾
.
rocc
 || 
mem_»g_sãnû
) {

552 
wb_»g_rs2
 :ğ
mem_»g_rs2


554 
wb_»g_ÿu£
 :ğ
mem_ÿu£


555 
wb_»g_š¡
 :ğ
mem_»g_š¡


556 
wb_»g_¿w_š¡
 :ğ
mem_»g_¿w_š¡


557 
wb_»g_pc
 :ğ
mem_»g_pc


560 
	`v®
 (
wb_xıt
, 
wb_ÿu£
èğ
	`checkExû±iÚs
(
	`Li¡
(

561 (
wb_»g_xıt
, 
wb_»g_ÿu£
),

562 (
wb_»g_v®id
 && 
wb_ù¾
.
mem
 && 
io
.
dmem
.
s2_xıt
.
ma
.
¡
, 
	`UIÁ
(
Cau£s
.
mi§ligÃd_¡Üe
)),

563 (
wb_»g_v®id
 && 
wb_ù¾
.
mem
 && 
io
.
dmem
.
s2_xıt
.
ma
.
ld
, 
	`UIÁ
(
Cau£s
.
mi§ligÃd_lßd
)),

564 (
wb_»g_v®id
 && 
wb_ù¾
.
mem
 && 
io
.
dmem
.
s2_xıt
.
pf
.
¡
, 
	`UIÁ
(
Cau£s
.
¡Üe_·ge_çuÉ
)),

565 (
wb_»g_v®id
 && 
wb_ù¾
.
mem
 && 
io
.
dmem
.
s2_xıt
.
pf
.
ld
, 
	`UIÁ
(
Cau£s
.
lßd_·ge_çuÉ
)),

566 (
wb_»g_v®id
 && 
wb_ù¾
.
mem
 && 
io
.
dmem
.
s2_xıt
.
«
.
¡
, 
	`UIÁ
(
Cau£s
.
¡Üe_acûss
)),

567 (
wb_»g_v®id
 && 
wb_ù¾
.
mem
 && 
io
.
dmem
.
s2_xıt
.
«
.
ld
, 
	`UIÁ
(
Cau£s
.
lßd_acûss
))

570 
v®
 
wbCov”Cau£s
 = 
	`Li¡
(

571 (
Cau£s
.
mi§ligÃd_¡Üe
, "MISALIGNED_STORE"),

572 (
Cau£s
.
mi§ligÃd_lßd
, "MISALIGNED_LOAD"),

573 (
Cau£s
.
¡Üe_·ge_çuÉ
, "STORE_PAGE_FAULT"),

574 (
Cau£s
.
lßd_·ge_çuÉ
, "LOAD_PAGE_FAULT"),

575 (
Cau£s
.
¡Üe_acûss
, "STORE_ACCESS"),

576 (
Cau£s
.
lßd_acûss
, "LOAD_ACCESS")

578 
	`cov”Exû±iÚs
(
wb_xıt
, 
wb_ÿu£
, "WRITEBACK", 
wbCov”Cau£s
)

580 
v®
 
wb_pc_v®id
 = 
wb_»g_v®id
 || 
wb_»g_»¶ay
 || 
wb_»g_xıt


581 
v®
 
wb_wxd
 = 
wb_»g_v®id
 && 
wb_ù¾
.
wxd


582 
v®
 
wb_£t_sbßrd
 = 
wb_ù¾
.
div
 || 
wb_dÿche_miss
 || wb_ù¾.
rocc


583 
v®
 
»¶ay_wb_commÚ
 = 
io
.
dmem
.
s2_Çck
 || 
wb_»g_»¶ay


584 
v®
 
»¶ay_wb_rocc
 = 
wb_»g_v®id
 && 
wb_ù¾
.
rocc
 && !
io
.rocc.
cmd
.
»ady


585 
v®
 
»¶ay_wb
 = 
»¶ay_wb_commÚ
 || 
»¶ay_wb_rocc


586 
ke_pc_wb
 :ğ
»¶ay_wb
 || 
wb_xıt
 || 
c¤
.
io
.
”‘
 || 
wb_»g_æush_pe


589 
v®
 
dmem_»¥_xpu
 = !
io
.
dmem
.
»¥
.
b™s
.
	`g
(0).
toBoŞ


590 
v®
 
dmem_»¥_åu
 = 
io
.
dmem
.
»¥
.
b™s
.
	`g
(0).
toBoŞ


591 
v®
 
dmem_»¥_waddr
 = 
io
.
dmem
.
»¥
.
b™s
.
	`g
(5, 1)

592 
v®
 
dmem_»¥_v®id
 = 
io
.
dmem
.
»¥
.
v®id
 && io.dmem.»¥.
b™s
.
has_d©a


593 
v®
 
dmem_»¥_»¶ay
 = 
dmem_»¥_v®id
 && 
io
.
dmem
.
»¥
.
b™s
.
»¶ay


595 
div
.
io
.
»¥
.
»ady
 :ğ!
wb_wxd


596 
v®
 
Î_wd©a
 = 
	`Wœe
(
š™
 = 
div
.
io
.
»¥
.
b™s
.
d©a
)

597 
v®
 
Î_waddr
 = 
	`Wœe
(
š™
 = 
div
.
io
.
»¥
.
b™s
.
g
)

598 
v®
 
Î_w’
 = 
	`Wœe
(
š™
 = 
div
.
io
.
»¥
.
	`fœe
())

599 ià(
usšgRoCC
) {

600 
io
.
rocc
.
»¥
.
»ady
 :ğ!
wb_wxd


601 
	`wh’
 (
io
.
rocc
.
»¥
.
	`fœe
()) {

602 
div
.
io
.
»¥
.
»ady
 :ğ
	`BoŞ
(
çl£
)

603 
Î_wd©a
 :ğ
io
.
rocc
.
»¥
.
b™s
.
d©a


604 
Î_waddr
 :ğ
io
.
rocc
.
»¥
.
b™s
.
rd


605 
Î_w’
 :ğ
	`BoŞ
(
Œue
)

608 
	`wh’
 (
dmem_»¥_»¶ay
 && 
dmem_»¥_xpu
) {

609 
div
.
io
.
»¥
.
»ady
 :ğ
	`BoŞ
(
çl£
)

610 ià(
usšgRoCC
)

611 
io
.
rocc
.
»¥
.
»ady
 :ğ
	`BoŞ
(
çl£
)

612 
Î_waddr
 :ğ
dmem_»¥_waddr


613 
Î_w’
 :ğ
	`BoŞ
(
Œue
)

616 
v®
 
wb_v®id
 = 
wb_»g_v®id
 && !
»¶ay_wb
 && !
wb_xıt


617 
v®
 
wb_w’
 = 
wb_v®id
 && 
wb_ù¾
.
wxd


618 
v®
 
rf_w’
 = 
wb_w’
 || 
Î_w’


619 
v®
 
rf_waddr
 = 
	`Mux
(
Î_w’
, 
Î_waddr
, 
wb_waddr
)

620 
v®
 
rf_wd©a
 = 
	`Mux
(
dmem_»¥_v®id
 && 
dmem_»¥_xpu
, 
io
.
dmem
.
»¥
.
b™s
.
	`d©a
(
xL’
-1, 0),

621 
	`Mux
(
Î_w’
, 
Î_wd©a
,

622 
	`Mux
(
wb_ù¾
.
c¤
 =/ğ
CSR
.
N
, c¤.
io
.
rw
.
rd©a
,

623 
	`Mux
(
wb_ù¾
.
mul
, mul.
	`m­
(
_
.
io
.
»¥
.
b™s
.
d©a
).
	`g‘OrEl£
(
wb_»g_wd©a
),

624 
wb_»g_wd©a
))))

625 
	`wh’
 (
rf_w’
è{ 
rf
.
	`wr™e
(
rf_waddr
, 
rf_wd©a
) }

628 
c¤
.
io
.
ung©ed_şock
 :ğ
şock


629 
c¤
.
io
.
	`decode
(0).c¤ :ğ
	`id_¿w_š¡
(0)(31,20)

630 
c¤
.
io
.
exû±iÚ
 :ğ
wb_xıt


631 
c¤
.
io
.
ÿu£
 :ğ
wb_ÿu£


632 
c¤
.
io
.
»tœe
 :ğ
wb_v®id


633 
c¤
.
io
.
	`š¡
(0è:ğ(ià(
usšgCom´es£d
è
	`C©
(
	`Mux
(
	`wb_»g_¿w_š¡
(1, 0).
ªdR
, 
wb_»g_š¡
 >> 16, 0.U), wb_reg_raw_inst(15, 0)) wb_reg_inst)

634 
c¤
.
io
.
š‹¼u±s
 := io.interrupts

635 
c¤
.
io
.
h¬tid
 := io.hartid

636 
io
.
åu
.
fc¤_rm
 :ğ
c¤
.io.fcsr_rm

637 
c¤
.
io
.
fc¤_æags
 :ğio.
åu
.fcsr_flags

638 
c¤
.
io
.
rocc_š‹¼u±
 :ğio.
rocc
.
š‹¼u±


639 
c¤
.
io
.
pc
 :ğ
wb_»g_pc


640 
v®
 
tv®_v®id
 = 
wb_xıt
 && 
wb_ÿu£
.
	`isOÃOf
(
Cau£s
.
Ëg®_š¡ruùiÚ
, Cau£s.
b»akpošt
,

641 
Cau£s
.
mi§ligÃd_lßd
, Cau£s.
mi§ligÃd_¡Üe
,

642 
Cau£s
.
lßd_acûss
, Cau£s.
¡Üe_acûss
, Cau£s.
ãtch_acûss
,

643 
Cau£s
.
lßd_·ge_çuÉ
, Cau£s.
¡Üe_·ge_çuÉ
, Cau£s.
ãtch_·ge_çuÉ
)

644 
c¤
.
io
.
tv®
 :ğ
	`Mux
(
tv®_v®id
, 
	`’codeVœtu®Add»ss
(
wb_»g_wd©a
, wb_reg_wdata), 0.U)

645 
io
.
±w
.
±br
 :ğ
c¤
.io.ptbr

646 (
io
.
±w
.
cu¡omCSRs
.
c¤s
 
z
 
c¤
.io.cu¡omCSRs).
m­
 { (
lhs
, 
rhs
) =>†hs :=„hs }

647 
io
.
±w
.
¡©us
 :ğ
c¤
.io.status

648 
io
.
±w
.
pmp
 :ğ
c¤
.io.pmp

649 
c¤
.
io
.
rw
.
addr
 :ğ
	`wb_»g_š¡
(31,20)

650 
c¤
.
io
.
rw
.
cmd
 :ğ
CSR
.
	`maskCmd
(
wb_»g_v®id
, 
wb_ù¾
.csr)

651 
c¤
.
io
.
rw
.
wd©a
 :ğ
wb_»g_wd©a


652 
io
.
Œaû
 :ğ
c¤
.io.trace

654 
v®
 
haz¬d_rg‘s
 = 
	`Seq
((
id_ù¾
.
rxs1
 && 
id_¿ddr1
 =/ğ
	`UIÁ
(0), id_raddr1),

655 (
id_ù¾
.
rxs2
 && 
id_¿ddr2
 =/ğ
	`UIÁ
(0), id_raddr2),

656 (
id_ù¾
.
wxd
 && 
id_waddr
 =/ğ
	`UIÁ
(0), id_waddr))

657 
v®
 
å_haz¬d_rg‘s
 = 
	`Seq
((
io
.
åu
.
dec
.
»n1
, 
id_¿ddr1
),

658 (
io
.
åu
.
dec
.
»n2
, 
id_¿ddr2
),

659 (
io
.
åu
.
dec
.
»n3
, 
id_¿ddr3
),

660 (
io
.
åu
.
dec
.
w’
, 
id_waddr
))

662 
v®
 
sbßrd
 = 
Ãw
 
	`ScÜebßrd
(32, 
Œue
)

663 
sbßrd
.
	`ş—r
(
Î_w’
, 
Î_waddr
)

664 
def
 
	`id_sbßrd_ş—r_by·ss
(
r
: 
UIÁ
) = {

666 ià(!
teP¬ams
.
dÿche
.
g‘
.
d©aECC
.
isDefšed
è
Î_w’
 && 
Î_waddr
 ==ğ
r


667 
div
.
io
.
»¥
.
	`fœe
(è&& div.io.»¥.
b™s
.
g
 ==ğ
r
 || 
dmem_»¥_»¶ay
 && 
dmem_»¥_xpu
 && 
dmem_»¥_waddr
 ===„

669 
v®
 
id_sbßrd_haz¬d
 = 
	`checkHaz¬ds
(
haz¬d_rg‘s
, 
rd
 => 
sbßrd
.
	`»ad
Ôdè&& !
	`id_sbßrd_ş—r_by·ss
(rd))

670 
sbßrd
.
	`£t
(
wb_£t_sbßrd
 && 
wb_w’
, 
wb_waddr
)

673 
v®
 
ex_ÿÂÙ_by·ss
 = 
ex_ù¾
.
c¤
 =/ğ
CSR
.
N
 ||ƒx_ù¾.
j®r
 ||ƒx_ù¾.
mem
 ||ƒx_ù¾.
mul
 ||ƒx_ù¾.
div
 ||ƒx_ù¾.
å
 ||ƒx_ù¾.
rocc


674 
v®
 
d©a_haz¬d_ex
 = 
ex_ù¾
.
wxd
 && 
	`checkHaz¬ds
(
haz¬d_rg‘s
, 
_
 ==ğ
ex_waddr
)

675 
v®
 
å_d©a_haz¬d_ex
 = 
ex_ù¾
.
wfd
 && 
	`checkHaz¬ds
(
å_haz¬d_rg‘s
, 
_
 ==ğ
ex_waddr
)

676 
v®
 
id_ex_haz¬d
 = 
ex_»g_v®id
 && (
d©a_haz¬d_ex
 && 
ex_ÿÂÙ_by·ss
 || 
å_d©a_haz¬d_ex
)

679 
v®
 
mem_mem_cmd_bh
 =

680 ià(
ç¡LßdWÜd
è
	`BoŞ
(!
ç¡LßdBy‹
è&& 
mem_»g_¦ow_by·ss


681 
	`BoŞ
(
Œue
)

682 
v®
 
mem_ÿÂÙ_by·ss
 = 
mem_ù¾
.
c¤
 =/ğ
CSR
.
N
 || mem_ù¾.
mem
 && 
mem_mem_cmd_bh
 || mem_ù¾.
mul
 || mem_ù¾.
div
 || mem_ù¾.
å
 || mem_ù¾.
rocc


683 
v®
 
d©a_haz¬d_mem
 = 
mem_ù¾
.
wxd
 && 
	`checkHaz¬ds
(
haz¬d_rg‘s
, 
_
 ==ğ
mem_waddr
)

684 
v®
 
å_d©a_haz¬d_mem
 = 
mem_ù¾
.
wfd
 && 
	`checkHaz¬ds
(
å_haz¬d_rg‘s
, 
_
 ==ğ
mem_waddr
)

685 
v®
 
id_mem_haz¬d
 = 
mem_»g_v®id
 && (
d©a_haz¬d_mem
 && 
mem_ÿÂÙ_by·ss
 || 
å_d©a_haz¬d_mem
)

686 
id_lßd_u£
 :ğ
mem_»g_v®id
 && 
d©a_haz¬d_mem
 && 
mem_ù¾
.
mem


689 
v®
 
d©a_haz¬d_wb
 = 
wb_ù¾
.
wxd
 && 
	`checkHaz¬ds
(
haz¬d_rg‘s
, 
_
 ==ğ
wb_waddr
)

690 
v®
 
å_d©a_haz¬d_wb
 = 
wb_ù¾
.
wfd
 && 
	`checkHaz¬ds
(
å_haz¬d_rg‘s
, 
_
 ==ğ
wb_waddr
)

691 
v®
 
id_wb_haz¬d
 = 
wb_»g_v®id
 && (
d©a_haz¬d_wb
 && 
wb_£t_sbßrd
 || 
å_d©a_haz¬d_wb
)

693 
v®
 
id_¡®l_åu
 = ià(
usšgFPU
) {

694 
v®
 
å_sbßrd
 = 
Ãw
 
	`ScÜebßrd
(32)

695 
å_sbßrd
.
	`£t
((
wb_dÿche_miss
 && 
wb_ù¾
.
wfd
 || 
io
.
åu
.
sbßrd_£t
è&& 
wb_v®id
, 
wb_waddr
)

696 
å_sbßrd
.
	`ş—r
(
dmem_»¥_»¶ay
 && 
dmem_»¥_åu
, 
dmem_»¥_waddr
)

697 
å_sbßrd
.
	`ş—r
(
io
.
åu
.
sbßrd_şr
, io.åu.
sbßrd_ş¿
)

699 
	`checkHaz¬ds
(
å_haz¬d_rg‘s
, 
å_sbßrd
.
»ad
 
_
)

700 } 
	`BoŞ
(
çl£
)

702 
v®
 
dÿche_blocked
 = {

704 
v®
 
blocked
 = 
	`Reg
(
	`BoŞ
())

705 
blocked
 :ğ!
io
.
dmem
.
»q
.
»ady
 && io.dmem.
şock_’abËd
 && !io.dmem.
³rf
.
g¿Á
 && (blocked || io.dmem.»q.
v®id
 || io.dmem.
s2_Çck
)

706 
blocked
 && !
io
.
dmem
.
³rf
.
g¿Á


708 
v®
 
rocc_blocked
 = 
	`Reg
(
	`BoŞ
())

709 
rocc_blocked
 :ğ!
wb_xıt
 && !
io
.
rocc
.
cmd
.
»ady
 && (io.rocc.cmd.
v®id
 ||„occ_blocked)

711 
v®
 
ù¾_¡®ld
 =

712 
id_ex_haz¬d
 || 
id_mem_haz¬d
 || 
id_wb_haz¬d
 || 
id_sbßrd_haz¬d
 ||

713 
c¤
.
io
.
sšgËS‹p
 && (
ex_»g_v®id
 || 
mem_»g_v®id
 || 
wb_»g_v®id
) ||

714 
id_c¤_’
 && 
c¤
.
io
.
	`decode
(0).
å_c¤
 && !io.
åu
.
fc¤_rdy
 ||

715 
id_ù¾
.
å
 && 
id_¡®l_åu
 ||

716 
id_ù¾
.
mem
 && 
dÿche_blocked
 ||

717 
id_ù¾
.
rocc
 && 
rocc_blocked
 ||

718 
id_ù¾
.
div
 && (!(div.
io
.
»q
.
»ady
 || (div.io.
»¥
.
v®id
 && !
wb_wxd
)) || div.io.req.valid) ||

719 !
şock_’
 ||

720 
id_do_ãnû
 ||

721 
c¤
.
io
.
c¤_¡®l


722 
ù¾_kld
 :ğ!
ibuf
.
io
.
	`š¡
(0).
v®id
 || ibuf.io.š¡(0).
b™s
.
»¶ay
 || 
ke_pc_mem_wb
 || 
ù¾_¡®ld
 || 
c¤
.io.
š‹¼u±


724 
io
.
imem
.
»q
.
v®id
 :ğ
ke_pc


725 
io
.
imem
.
»q
.
b™s
.
¥ecuÏtive
 :ğ!
ke_pc_wb


726 
io
.
imem
.
»q
.
b™s
.
pc
 :=

727 
	`Mux
(
wb_xıt
 || 
c¤
.
io
.
”‘
, c¤.io.
evec
,

728 
	`Mux
(
»¶ay_wb
, 
wb_»g_pc
,

729 
mem_Åc
))

730 
io
.
imem
.
æush_iÿche
 :ğ
wb_»g_v®id
 && 
wb_ù¾
.
ãnû_i
 && !io.
dmem
.
s2_Çck


731 
io
.
imem
.
might_»que¡
 := {

732 
imem_might_»que¡_»g
 :ğ
ex_pc_v®id
 || 
mem_pc_v®id
 || 
io
.
±w
.
cu¡omCSRs
.
di§bËICacheClockG©e


733 
imem_might_»que¡_»g


735 
io
.
imem
.
sãnû
.
v®id
 :ğ
wb_»g_v®id
 && 
wb_»g_sãnû


736 
io
.
imem
.
sãnû
.
b™s
.
rs1
 :ğ
wb_ù¾
.
	`mem_ty³
(0)

737 
io
.
imem
.
sãnû
.
b™s
.
rs2
 :ğ
wb_ù¾
.
	`mem_ty³
(1)

738 
io
.
imem
.
sãnû
.
b™s
.
addr
 :ğ
wb_»g_wd©a


739 
io
.
imem
.
sãnû
.
b™s
.
asid
 :ğ
wb_»g_rs2


740 
io
.
±w
.
sãnû
 :ğio.
imem
.sfence

742 
ibuf
.
io
.
	`š¡
(0).
»ady
 :ğ!
ù¾_¡®ld


744 
io
.
imem
.
btb_upd©e
.
v®id
 :ğ
mem_»g_v®id
 && !
ke_pc_wb
 && 
mem_wrÚg_Åc
 && (!
mem_cfi
 || 
mem_cfi_k’
)

745 
io
.
imem
.
btb_upd©e
.
b™s
.
isV®id
 :ğ
mem_cfi


746 
io
.
imem
.
btb_upd©e
.
b™s
.
cfiTy³
 :=

747 
	`Mux
((
mem_ù¾
.
j®
 || mem_ù¾.
j®r
è&& 
	`mem_waddr
(0), 
CFITy³
.
ÿÎ
,

748 
	`Mux
(
mem_ù¾
.
j®r
 && 
	`mem_»g_š¡
(19,15è==ğ
	`B™P©
("b00?01"), 
CFITy³
.
»t
,

749 
	`Mux
(
mem_ù¾
.
j®
 || mem_ù¾.
j®r
, 
CFITy³
.
jump
,

750 
CFITy³
.
b¿nch
)))

751 
io
.
imem
.
btb_upd©e
.
b™s
.
rg‘
 :ğio.imem.
»q
.b™s.
pc


752 
io
.
imem
.
btb_upd©e
.
b™s
.
br_pc
 :ğ(ià(
usšgCom´es£d
è
mem_»g_pc
 + 
	`Mux
(
mem_»g_rvc
, 
	`UIÁ
(0), UInt(2)) mem_reg_pc)

753 
io
.
imem
.
btb_upd©e
.
b™s
.
pc
 :ğ~(~io.imem.btb_upd©e.b™s.
br_pc
 | (
cÜeIn¡By‹s
*
ãtchWidth
-1))

754 
io
.
imem
.
btb_upd©e
.
b™s
.
´ediùiÚ
 :ğ
mem_»g_btb_»¥


756 
io
.
imem
.
bht_upd©e
.
v®id
 :ğ
mem_»g_v®id
 && !
ke_pc_wb


757 
io
.
imem
.
bht_upd©e
.
b™s
.
pc
 :ğio.imem.
btb_upd©e
.bits.pc

758 
io
.
imem
.
bht_upd©e
.
b™s
.
k’
 :ğ
mem_br_k’


759 
io
.
imem
.
bht_upd©e
.
b™s
.
mi¥»diù
 :ğ
mem_wrÚg_Åc


760 
io
.
imem
.
bht_upd©e
.
b™s
.
b¿nch
 :ğ
mem_ù¾
.branch

761 
io
.
imem
.
bht_upd©e
.
b™s
.
´ediùiÚ
 :ğ
mem_»g_btb_»¥
.
bht


763 
io
.
åu
.
v®id
 :ğ!
ù¾_kld
 && 
id_ù¾
.
å


764 
io
.
åu
.
klx
 :ğ
ù¾_klx


765 
io
.
åu
.
klm
 :ğ
klm_commÚ


766 
io
.
åu
.
š¡
 :ğ
	`id_š¡
(0)

767 
io
.
åu
.
äomšt_d©a
 :ğ
	`ex_rs
(0)

768 
io
.
åu
.
dmem_»¥_v®
 :ğ
dmem_»¥_v®id
 && 
dmem_»¥_åu


769 
io
.
åu
.
dmem_»¥_d©a
 :ğio.
dmem
.
»¥
.
b™s
.
d©a_wÜd_by·ss


770 
io
.
åu
.
dmem_»¥_ty³
 :ğio.
dmem
.
»¥
.
b™s
.
typ


771 
io
.
åu
.
dmem_»¥_g
 :ğ
dmem_»¥_waddr


772 
io
.
åu
.
k“p_şock_’abËd
 :ğio.
±w
.
cu¡omCSRs
.
di§bËCÜeClockG©e


774 
io
.
dmem
.
»q
.
v®id
 :ğ
ex_»g_v®id
 && 
ex_ù¾
.
mem


775 
v®
 
ex_dÿche_g
 = 
	`C©
(
ex_waddr
, 
ex_ù¾
.
å
)

776 
	`»quœe
(
cÜeDCacheReqTagB™s
 >ğ
ex_dÿche_g
.
g‘Width
)

777 
io
.
dmem
.
»q
.
b™s
.
g
 :ğ
ex_dÿche_g


778 
io
.
dmem
.
»q
.
b™s
.
cmd
 :ğ
ex_ù¾
.
mem_cmd


779 
io
.
dmem
.
»q
.
b™s
.
typ
 :ğ
ex_ù¾
.
mem_ty³


780 
io
.
dmem
.
»q
.
b™s
.
phys
 :ğ
	`BoŞ
(
çl£
)

781 
io
.
dmem
.
»q
.
b™s
.
addr
 :ğ
	`’codeVœtu®Add»ss
(
	`ex_rs
(0), 
®u
.io.
add”_out
)

782 
io
.
dmem
.
s1_d©a
.
d©a
 :ğ(ià(
fL’
 =ğ0è
mem_»g_rs2
 
	`Mux
(
mem_ù¾
.
å
, 
	`Fl
((
xL’
 
max
 fL’è/ fL’, io.
åu
.
¡Üe_d©a
), mem_reg_rs2))

783 
io
.
dmem
.
s1_kl
 :ğ
klm_commÚ
 || 
mem_ld¡_xıt
 || 
åu_kl_mem


784 
io
.
dmem
.
s2_kl
 :ğ
çl£


786 
io
.
dmem
.
k“p_şock_’abËd
 :ğ
ibuf
.io.
	`š¡
(0).
v®id
 && 
id_ù¾
.
mem


788 
io
.
rocc
.
cmd
.
v®id
 :ğ
wb_»g_v®id
 && 
wb_ù¾
.rocø&& !
»¶ay_wb_commÚ


789 
io
.
rocc
.
exû±iÚ
 :ğ
wb_xıt
 && 
c¤
.io.
¡©us
.
xs
.
ÜR


790 
io
.
rocc
.
cmd
.
b™s
.
¡©us
 :ğ
c¤
.io.status

791 
io
.
rocc
.
cmd
.
b™s
.
š¡
 :ğ
Ãw
 
	`RoCCIn¡ruùiÚ
().
	`äomB™s
(
wb_»g_š¡
)

792 
io
.
rocc
.
cmd
.
b™s
.
rs1
 :ğ
wb_»g_wd©a


793 
io
.
rocc
.
cmd
.
b™s
.
rs2
 :ğ
wb_»g_rs2


796 ià(
rock‘P¬ams
.
şockG©e
) {

797 
lÚg_Ï‹ncy_¡®l
 :ğ
c¤
.
io
.
c¤_¡®l
 || io.
dmem
.
³rf
.
blocked


798 
şock_’
 :ğ
şock_’_»g
 || (!
lÚg_Ï‹ncy_¡®l
 && 
io
.
imem
.
»¥
.
v®id
)

799 
şock_’_»g
 :=

800 
ex_pc_v®id
 || 
mem_pc_v®id
 || 
wb_pc_v®id
 ||

801 
io
.
±w
.
cu¡omCSRs
.
di§bËCÜeClockG©e
 ||

802 !
div
.
io
.
»q
.
»ady
 ||

803 
usšgFPU
 && !
io
.
åu
.
fc¤_rdy
 ||

804 
io
.
dmem
.
»¶ay_Ãxt
 ||

805 (!
lÚg_Ï‹ncy_¡®l
 && (
ibuf
.
io
.
	`š¡
(0).
v®id
 || io.
imem
.
»¥
.valid))

807 
	`as£¹
(!(
ex_pc_v®id
 || 
mem_pc_v®id
 || 
wb_pc_v®id
è|| 
şock_’
)

811 
v®
 
iÿche_blocked
 = !(
io
.
imem
.
»¥
.
v®id
 || 
	`RegNext
(io.imem.resp.valid))

812 
c¤
.
io
.
couÁ”s
 
fÜ—ch
 { 
c
 => c.
šc
 :ğ
	`RegNext
(
³rfEv’ts
.
	`ev®u©e
(c.
ev’tS–
)) }

814 şas 
	cCÜeMÚ™ÜBundË
 
ex‹nds
 
BundË
 {

815 
v®
 
h¬tid
 = 
	`UIÁ
(
width
 = 
h¬tIdL’
)

816 
v®
 
time
 = 
	`UIÁ
(
width
 = 32)

817 
v®
 
v®id
 = 
	`BoŞ
()

818 
v®
 
pc
 = 
	`UIÁ
(
width
 = 
vaddrB™sEx‹nded
)

819 
v®
 
wrd¡
 = 
	`UIÁ
(
width
 = 5)

820 
v®
 
wrd©a
 = 
	`UIÁ
(
width
 = 
xL’
)

821 
v®
 
w»n
 = 
	`BoŞ
()

822 
v®
 
rd0¤c
 = 
	`UIÁ
(
width
 = 5)

823 
v®
 
rd0v®
 = 
	`UIÁ
(
width
 = 
xL’
)

824 
v®
 
rd1¤c
 = 
	`UIÁ
(
width
 = 5)

825 
v®
 
rd1v®
 = 
	`UIÁ
(
width
 = 
xL’
)

826 
v®
 
š¡
 = 
	`UIÁ
(
width
 = 32)

828 
v®
 
cÜeMÚ™ÜBundË
 = 
	`Wœe
(
Ãw
 
CÜeMÚ™ÜBundË
)

830 
cÜeMÚ™ÜBundË
.
h¬tid
 :ğ
io
.hartid

831 
cÜeMÚ™ÜBundË
.
time
 :ğ
c¤
.
io
.
	`time
(31,0)

832 
cÜeMÚ™ÜBundË
.
v®id
 :ğ
c¤
.
io
.
	`Œaû
(0).v®id && !c¤.io.Œaû(0).
exû±iÚ


833 
cÜeMÚ™ÜBundË
.
pc
 :ğ
c¤
.
io
.
	`Œaû
(0).
	`Ÿddr
(
vaddrB™sEx‹nded
-1, 0)

834 
cÜeMÚ™ÜBundË
.
wrd¡
 :ğ
	`Mux
(
rf_w’
 && !(
wb_£t_sbßrd
 && 
wb_w’
), 
rf_waddr
, 
	`UIÁ
(0))

835 
cÜeMÚ™ÜBundË
.
wrd©a
 :ğ
rf_wd©a


836 
cÜeMÚ™ÜBundË
.
w»n
 :ğ
rf_w’


837 
cÜeMÚ™ÜBundË
.
rd0¤c
 :ğ
	`wb_»g_š¡
(19,15)

838 
cÜeMÚ™ÜBundË
.
rd0v®
 :ğ
	`Reg
(
Ãxt
=RegÒext=
	`ex_rs
(0)))

839 
cÜeMÚ™ÜBundË
.
rd1¤c
 :ğ
	`wb_»g_š¡
(24,20)

840 
cÜeMÚ™ÜBundË
.
rd1v®
 :ğ
	`Reg
(
Ãxt
=RegÒext=
	`ex_rs
(1)))

841 
cÜeMÚ™ÜBundË
.
š¡
 :ğ
c¤
.
io
.
	`Œaû
(0).
š¢


843 
	`p
(
BundËMÚ™ÜKey
).
fÜ—ch
 { 
	`_
 ("rock‘_cÜe_mÚ™Ü", 
cÜeMÚ™ÜBundË
) }

845 ià(
’abËComm™Log
) {

846 
v®
 
t
 = 
c¤
.
io
.
	`Œaû
(0)

847 
v®
 
rd
 = 
wb_waddr


848 
v®
 
wfd
 = 
wb_ù¾
.wfd

849 
v®
 
wxd
 = 
wb_ù¾
.wxd

850 
v®
 
has_d©a
 = 
wb_w’
 && !
wb_£t_sbßrd


852 
	`wh’
 (
t
.
v®id
 && !t.
exû±iÚ
) {

853 
	`wh’
 (
wfd
) {

854 
	`´štf
 ("%d 0x%x (0x%xèf%d…%d 0xXXXXXXXXXXXXXXXX\n", 
t
.
´iv
,.
Ÿddr
,.
š¢
, 
rd
,„d+
	`UIÁ
(32))

856 .
	`–£wh’
 (
wxd
 && 
rd
 =/ğ
	`UIÁ
(0è&& 
has_d©a
) {

857 
	`´štf
 ("%d 0x%x (0x%xèx%d 0x%x\n", 
t
.
´iv
,.
Ÿddr
,.
š¢
, 
rd
, 
rf_wd©a
)

859 .
	`–£wh’
 (
wxd
 && 
rd
 =/ğ
	`UIÁ
(0è&& !
has_d©a
) {

860 
	`´štf
 ("%d 0x%x (0x%xèx%d…%d 0xXXXXXXXXXXXXXXXX\n", 
t
.
´iv
,.
Ÿddr
,.
š¢
, 
rd
,„d)

862 .
Ùh”wi£
 {

863 
	`´štf
 ("%d 0x%x (0x%x)\n", 
t
.
´iv
,.
Ÿddr
,.
š¢
)

867 
	`wh’
 (
Î_w’
 && 
rf_waddr
 =/ğ
	`UIÁ
(0)) {

868 
	`´štf
 ("x%d…%d 0x%x\n", 
rf_waddr
,„f_waddr, 
rf_wd©a
)

881 
PlusArg
.
	`timeout
(

882 
Çme
 = "max_core_cycles",

883 
doc¡ršg
 = "Killheƒmulation‡fter INT„dtime cycles. Off if 0."

884 )(
c¤
.
io
.
time
)

887 
	$w™hClock
 (
g©ed_şock
è{ 
Ãw
 
Rock‘Im¶
 
	}
}

889 
def
 
checkExû±iÚs
(
x
: 
Seq
[(
BoŞ
, 
UIÁ
)]) =

890 (
x
.
m­
(
_
.
_1
).
»duû
(_||_), 
	$PriÜ™yMux
(
x
))

892 
def
 
	`cov”Exû±iÚs
(
exû±iÚV®id
: 
BoŞ
, 
ÿu£
: 
UIÁ
, 
Ïb–P»fix
: 
SŒšg
, 
cov”Cau£sLab–s
: 
Seq
[(
IÁ
, SŒšg)]): 
Un™
 = {

893 (
cov”Cau£
, 
Ïb–
è<- 
cov”Cau£sLab–s
) {

894 
	`cov”
(
exû±iÚV®id
 && (
ÿu£
 ==ğ
	`UIÁ
(
cov”Cau£
)), 
s
"${labelPrefix}_${label}")

896 
	}
}

898 
def
 
checkHaz¬ds
(
rg‘s
: 
Seq
[(
BoŞ
, 
UIÁ
)], 
cÚd
: UInt => Bool) =

899 
rg‘s
.
m­
(
h
 => h.
_1
 && 
cÚd
(h.
_2
)).
»duû
(
_
||_)

901 
def
 
’codeVœtu®Add»ss
(
a0
: 
UIÁ
, 
—
: UIÁèğià(
vaddrB™sEx‹nded
 =ğ
vaddrB™s
)ƒa {

904 
v®
 
a
 = 
a0
.
asSIÁ
 >> 
vaddrB™s


905 
v®
 
msb
 = 
Mux
(
a
 ==ğ0.
S
 ||‡ ==ğ-1.S, 
—
(
vaddrB™s
), !ea(vaddrBits-1))

906 
C©
(
msb
, 
—
(
vaddrB™s
-1,0))

909 
şass
 
	$ScÜebßrd
(
n
: 
IÁ
, 
z”o
: 
BoŞ—n
 = 
çl£
)

911 
def
 
	`£t
(
’
: 
BoŞ
, 
addr
: 
UIÁ
): 
Un™
 = 
	`upd©e
Ón, 
_Ãxt
 | 
	`mask
(en,‡ddr))

912 
def
 
	`ş—r
(
’
: 
BoŞ
, 
addr
: 
UIÁ
): 
Un™
 = 
	`upd©e
Ón, 
_Ãxt
 & ~
	`mask
(en,‡ddr))

913 
def
 
	`»ad
(
addr
: 
UIÁ
): 
BoŞ
 = 
	`r
(addr)

914 
def
 
	`»adBy·s£d
(
addr
: 
UIÁ
): 
BoŞ
 = 
	`_Ãxt
(addr)

916 
´iv©e
 
v®
 
_r
 = 
	`Reg
(
š™
=
	`B™s
(0, 
n
))

917 
´iv©e
 
v®
 
r
 = ià(
z”o
è(
_r
 >> 1 << 1) _r

918 
´iv©e
 
v¬
 
_Ãxt
 = 
r


919 
´iv©e
 
v¬
 
’s
 = 
	`BoŞ
(
çl£
)

920 
´iv©e
 
def
 
	`mask
(
’
: 
BoŞ
, 
addr
: 
UIÁ
èğ
	`Mux
Ón, 
	`UIÁ
(1) <<‡ddr, UInt(0))

921 
´iv©e
 
def
 
	`upd©e
(
’
: 
BoŞ
, 
upd©e
: 
UIÁ
) = {

922 
_Ãxt
 = 
upd©e


923 
’s
 =ƒn || 
’


924 
	`wh’
 (
’s
è{ 
_r
 :ğ
_Ãxt
 }

926 
	}
}

929 
şass
 
	$RegFe
(
n
: 
IÁ
, 
w
: IÁ, 
z”o
: 
BoŞ—n
 = 
çl£
) {

930 
´iv©e
 
v®
 
rf
 = 
	`Mem
(
n
, 
	`UIÁ
(
width
 = 
w
))

931 
´iv©e
 
def
 
	`acûss
(
addr
: 
UIÁ
èğ
	`rf
(~
	`addr
(
	`log2Up
(
n
)-1,0))

932 
´iv©e
 
v®
 
»ads
 = 
A¼ayBufãr
[(
UIÁ
,UInt)]()

933 
´iv©e
 
v¬
 
ÿnR—d
 = 
Œue


934 
def
 
	`»ad
(
addr
: 
UIÁ
) = {

935 
	`»quœe
(
ÿnR—d
)

936 
»ads
 +ğ
addr
 -> 
	`Wœe
(
	`UIÁ
())

937 
»ads
.
Ï¡
.
_2
 :ğ
	`Mux
(
	`BoŞ
(
z”o
è&& 
addr
 ==ğ
	`UIÁ
(0), UIÁ(0), 
	`acûss
(addr))

938 
»ads
.
Ï¡
.
_2


940 
def
 
	`wr™e
(
addr
: 
UIÁ
, 
d©a
: UInt) = {

941 
ÿnR—d
 = 
çl£


942 
	`wh’
 (
addr
 =/ğ
	`UIÁ
(0)) {

943 
	`acûss
(
addr
è:ğ
d©a


944 (
¿ddr
, 
rd©a
è<- 
»ads
)

945 
	`wh’
 (
addr
 ==ğ
¿ddr
è{ 
rd©a
 :ğ
d©a
 }

948 
	}
}

950 
objeù
 
ImmG’
 {

951 
def
 
­¶y
(
£l
: 
UIÁ
, 
š¡
: UInt) = {

952 
v®
 
sign
 = 
Mux
(
£l
 ==ğ
IMM_Z
, 
SIÁ
(0), 
š¡
(31).
asSIÁ
)

953 
v®
 
	gb30_20
 = 
Mux
(
£l
 ==ğ
IMM_U
, 
š¡
(30,20).
asSIÁ
, 
sign
)

954 
v®
 
	gb19_12
 = 
Mux
(
£l
 =/ğ
IMM_U
 && s– =/ğ
IMM_UJ
, 
sign
, 
š¡
(19,12).
asSIÁ
)

955 
v®
 
	gb11
 = 
Mux
(
£l
 ==ğ
IMM_U
 || s– ==ğ
IMM_Z
, 
SIÁ
(0),

956 
Mux
(
£l
 ==ğ
IMM_UJ
, 
š¡
(20).
asSIÁ
,

957 
Mux
(
£l
 ==ğ
IMM_SB
, 
š¡
(7).
asSIÁ
, 
sign
)))

958 
v®
 
	gb10_5
 = 
Mux
(
£l
 ==ğ
IMM_U
 || s– ==ğ
IMM_Z
, 
B™s
(0), 
š¡
(30,25))

959 
v®
 
	gb4_1
 = 
Mux
(
£l
 ==ğ
IMM_U
, 
B™s
(0),

960 
Mux
(
£l
 ==ğ
IMM_S
 || s– ==ğ
IMM_SB
, 
š¡
(11,8),

961 
Mux
(
£l
 ==ğ
IMM_Z
, 
š¡
(19,16), inst(24,21))))

962 
v®
 
	gb0
 = 
Mux
(
£l
 ==ğ
IMM_S
, 
š¡
(7),

963 
Mux
(
£l
 ==ğ
IMM_I
, 
š¡
(20),

964 
Mux
(
£l
 ==ğ
IMM_Z
, 
š¡
(15), 
B™s
(0))))

966 
C©
(
sign
, 
b30_20
, 
b19_12
, 
b11
, 
b10_5
, 
b4_1
, 
b0
).
	gasSIÁ


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ScratchpadSlavePort.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


15 
şass
 
	$Sü©ch·dSÏvePÜt
(
add»ss
: 
Add»ssS‘
, 
cÜeD©aBy‹s
: 
IÁ
, 
usšgAtomics
: 
BoŞ—n
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

16 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
("dtim", 
	`Seq
("sifive,dtim0"))

17 
v®
 
node
 = 
	`TLMªag”Node
(
	`Seq
(
	`TLMªag”PÜtP¬am‘”s
(

18 
	`Seq
(
	`TLMªag”P¬am‘”s
(

19 
add»ss
 = 
	`Li¡
(address),

20 
»sourûs
 = 
deviû
.
	`»g
("mem"),

21 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHEABLE
,

22 
execubË
 = 
Œue
,

23 
suµÜtsAr™hm‘ic
 = ià(
usšgAtomics
è
	`T¿nsãrSizes
(4, 
cÜeD©aBy‹s
è
T¿nsãrSizes
.
nÚe
,

24 
suµÜtsLogiÿl
 = ià(
usšgAtomics
è
	`T¿nsãrSizes
(4, 
cÜeD©aBy‹s
è
T¿nsãrSizes
.
nÚe
,

25 
suµÜtsPutP¬tŸl
 = 
	`T¿nsãrSizes
(1, 
cÜeD©aBy‹s
),

26 
suµÜtsPutFuÎ
 = 
	`T¿nsãrSizes
(1, 
cÜeD©aBy‹s
),

27 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(1, 
cÜeD©aBy‹s
),

28 
fifoId
 = 
	`Some
(0))),

29 
b—tBy‹s
 = 
cÜeD©aBy‹s
,

30 
mšL©’cy
 = 1)))

32 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

33 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

34 
v®
 
dmem
 = 
Ãw
 
H–ÏCacheIO


37 
	`v®
 (
_š
, 
edge
èğ
node
.
	`š
(0)

39 
v®
 
s_»ady
 :: 
s_wa™1
 :: 
s_wa™2
 :: 
s_»¶ay
 :: 
s_g¿Á
 :: 
N
 = 
	`Enum
(
	`UIÁ
(), 5)

40 
v®
 
¡©e
 = 
	`Reg
(
š™
 = 
s_»ady
)

41 
v®
 
dmem_»q_v®id
 = 
	`Wœe
(
	`BoŞ
())

42 
	`wh’
 (
¡©e
 ==ğ
s_wa™1
è{ s‹ :ğ
s_wa™2
 }

43 
	`wh’
 (
io
.
dmem
.
»¥
.
v®id
è{ 
¡©e
 :ğ
s_g¿Á
 }

44 
	`wh’
 (
_š
.
d
.
	`fœe
()è{ 
¡©e
 :ğ
s_»ady
 }

45 
	`wh’
 (
io
.
dmem
.
s2_Çck
è{ 
¡©e
 :ğ
s_»¶ay
 }

46 
	`wh’
 (
dmem_»q_v®id
 && 
io
.
dmem
.
»q
.
»ady
è{ 
¡©e
 :ğ
s_wa™1
 }

48 
v®
 
acq
 = 
	`Reg
(
_š
.
a
.
b™s
)

49 
	`wh’
 (
_š
.
a
.
	`fœe
()è{ 
acq
 :ğ_š.a.
b™s
 }

51 
def
 
	`fÜmCacheReq
(
a
: 
TLBundËA
) = {

52 
v®
 
»q
 = 
	`Wœe
(
Ãw
 
H–ÏCacheReq
)

53 
»q
.
cmd
 :ğ
	`MuxLookup
(
a
.
İcode
, 
	`Wœe
(
M_XRD
), 
	`A¼ay
(

54 
TLMes§ges
.
PutFuÎD©a
 -> 
M_XWR
,

55 
TLMes§ges
.
PutP¬tŸlD©a
 -> 
M_PWR
,

56 
TLMes§ges
.
Ar™hm‘icD©a
 -> 
	`MuxLookup
(
a
.
·¿m
, 
	`Wœe
(
M_XRD
), 
	`A¼ay
(

57 
TLAtomics
.
MIN
 -> 
M_XA_MIN
,

58 
TLAtomics
.
MAX
 -> 
M_XA_MAX
,

59 
TLAtomics
.
MINU
 -> 
M_XA_MINU
,

60 
TLAtomics
.
MAXU
 -> 
M_XA_MAXU
,

61 
TLAtomics
.
ADD
 -> 
M_XA_ADD
)),

62 
TLMes§ges
.
LogiÿlD©a
 -> 
	`MuxLookup
(
a
.
·¿m
, 
	`Wœe
(
M_XRD
), 
	`A¼ay
(

63 
TLAtomics
.
XOR
 -> 
M_XA_XOR
,

64 
TLAtomics
.
OR
 -> 
M_XA_OR
,

65 
TLAtomics
.
AND
 -> 
M_XA_AND
,

66 
TLAtomics
.
SWAP
 -> 
M_XA_SWAP
)),

67 
TLMes§ges
.
G‘
 -> 
M_XRD
))

68 
»q
.
typ
 :ğ
a
.
size


69 
»q
.
addr
 :ğ
a
.
add»ss


70 
»q
.
g
 :ğ
	`UIÁ
(0)

71 
»q
.
phys
 :ğ
Œue


72 
»q


78 
v®
 
»ady_lik–y
 = 
¡©e
 ==ğ
s_»ady
 || s‹ ==ğ
s_wa™2


79 
v®
 
»ady
 = 
¡©e
 ==ğ
s_»ady
 || s‹ ==ğ
s_wa™2
 && 
io
.
dmem
.
»¥
.
v®id
 && 
_š
.
d
.ready

80 
dmem_»q_v®id
 :ğ(
_š
.
a
.
v®id
 && 
»ady
è|| 
¡©e
 ==ğ
s_»¶ay


81 
v®
 
dmem_»q_v®id_lik–y
 = (
_š
.
a
.
v®id
 && 
»ady_lik–y
è|| 
¡©e
 ==ğ
s_»¶ay


83 
io
.
dmem
.
»q
.
v®id
 :ğ
dmem_»q_v®id_lik–y


84 
_š
.
a
.
»ady
 :ğ
io
.
dmem
.
»q
.ready &&„eady

85 
io
.
dmem
.
»q
.
b™s
 :ğ
	`fÜmCacheReq
(
	`Mux
(
¡©e
 ==ğ
s_»¶ay
, 
acq
, 
_š
.
a
.bits))

86 
io
.
dmem
.
s1_d©a
.
d©a
 :ğ
acq
.data

87 
io
.
dmem
.
s1_d©a
.
mask
 :ğ
acq
.mask

88 
io
.
dmem
.
s1_kl
 :ğ
¡©e
 =/ğ
s_wa™1


89 
io
.
dmem
.
s2_kl
 :ğ
çl£


91 
_š
.
d
.
v®id
 :ğ
io
.
dmem
.
»¥
.v®id || 
¡©e
 ==ğ
s_g¿Á


92 
_š
.
d
.
b™s
 :ğ
	`Mux
(
acq
.
İcode
.
	`isOÃOf
(
TLMes§ges
.
PutFuÎD©a
, TLMes§ges.
PutP¬tŸlD©a
),

93 
edge
.
	`AcûssAck
(
acq
),

94 
edge
.
	`AcûssAck
(
acq
, 
	`UIÁ
(0)))

95 
_š
.
d
.
b™s
.
d©a
 :ğ
io
.
dmem
.
»¥
.b™s.
d©a_¿w
.
	`hŞdUÆess
(
¡©e
 ==ğ
s_wa™2
)

98 
_š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

99 
_š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

100 
_š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

102 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/SimpleHellaCacheIF.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


18 şas 
	cSim¶eH–ÏCacheIFR•ÏyQueue
(
d•th
: 
IÁ
)

19 (
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË


20 
w™h
 
HasL1H–ÏCacheP¬am‘”s
 {

21 
v®
 
io
 = 
Ãw
 
BundË
 {

22 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
H–ÏCacheReq
).
æ


23 
v®
 
Çck
 = 
	`V®id
(
	`B™s
(
width
 = 
cÜeDCacheReqTagB™s
)).
æ


24 
v®
 
»¥
 = 
	`V®id
(
Ãw
 
H–ÏCacheRe¥
).
æ


25 
v®
 
»¶ay
 = 
	`Decou¶ed
(
Ãw
 
H–ÏCacheReq
)

34 
v®
 
šæight
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 
d•th
))

35 
v®
 
»qs
 = 
	`Reg
(
	$Vec
(
d•th
, 
Ãw
 
H–ÏCacheReq
))

44 
v®
 
Çckq
 = 
	`ModuË
(
Ãw
 
	`Queue
(
	`UIÁ
(
width
 = 
	`log2Up
(
d•th
)), depth))

45 
v®
 
»¶ayšg
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

47 
v®
 
Ãxt_šæight_ÚehÙ
 = 
	`PriÜ™yEncod”OH
(~
šæight
)

48 
v®
 
Ãxt_šæight
 = 
	$OHToUIÁ
(
Ãxt_šæight_ÚehÙ
)

50 
v®
 
Ãxt_»¶ay
 = 
Çckq
.
io
.
deq
.
b™s


51 
v®
 
Ãxt_»¶ay_ÚehÙ
 = 
	$UIÁToOH
(
Ãxt_»¶ay
)

52 
v®
 
Ãxt_»¶ay_»q
 = 
	$»qs
(
Ãxt_»¶ay
)

55 
io
.
»¶ay
.
v®id
 :ğ
Çckq
.io.
deq
.v®id && !
»¶ayšg


56 
io
.
»¶ay
.
b™s
 :ğ
Ãxt_»¶ay_»q


59 
io
.
»q
.
»ady
 :ğ!
šæight
.
ªdR
 && !
Çckq
.io.
deq
.
v®id
 && !io.
Çck
.valid

62 
v®
 
Çck_ÚehÙ
 = 
	`C©
(
»qs
.
	`m­
(
_
.
g
 ==ğ
io
.
Çck
.
b™s
).
»v”£
è& 
šæight


63 
v®
 
»¥_ÚehÙ
 = 
	`C©
(
»qs
.
	`m­
(
_
.
g
 ==ğ
io
.
»¥
.
b™s
.g).
»v”£
è& 
šæight


65 
v®
 
»¶ay_com¶‘e
 = 
io
.
»¥
.
v®id
 && 
»¶ayšg
 && io.»¥.
b™s
.
g
 ==ğ
Ãxt_»¶ay_»q
.tag

66 
v®
 
Çck_h—d
 = 
io
.
Çck
.
v®id
 && 
Çckq
.io.
deq
.v®id && io.Çck.
b™s
 ==ğ
Ãxt_»¶ay_»q
.
g


70 
Çckq
.
io
.
’q
.
v®id
 :ğio.
Çck
.v®id && !
Çck_h—d


71 
Çckq
.
io
.
’q
.
b™s
 :ğ
	$OHToUIÁ
(
Çck_ÚehÙ
)

72 
	`as£¹
(!
Çckq
.
io
.
’q
.
v®id
 ||‚ackq.io.’q.
»ady
,

76 
Çckq
.
io
.
deq
.
»ady
 :ğ
»¶ay_com¶‘e


77 
	`as£¹
(!
Çckq
.
io
.
deq
.
»ady
 ||‚ackq.io.deq.
v®id
,

82 
šæight
 :ğ(šæighˆ| 
	`Mux
(
io
.
»q
.
	`fœe
(), 
Ãxt_šæight_ÚehÙ
, 
	`UIÁ
(0))) &

83 ~
	`Mux
(
io
.
»¥
.
v®id
, 
»¥_ÚehÙ
, 
	$UIÁ
(0))

85 
	`wh’
 (
io
.
»q
.
	$fœe
()) {

86 
	`»qs
(
Ãxt_šæight
è:ğ
io
.
»q
.
b™s


87 
	}
}

90 
wh’
 (
io
.
»¶ay
.
	$fœe
()è{ 
»¶ayšg
 :ğ
	`BoŞ
(
Œue
è
	}
}

91 
wh’
 (
Çck_h—d
 || 
»¶ay_com¶‘e
è{ 
»¶ayšg
 :ğ
BoŞ
(
çl£
) }

95 şas 
	cSim¶eH–ÏCacheIF
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË


97 
v®
 
io
 = 
Ãw
 
BundË
 {

98 
v®
 
»que¡Ü
 = 
Ãw
 
	`H–ÏCacheIO
().
æ


99 
v®
 
ÿche
 = 
Ãw
 
H–ÏCacheIO


102 
v®
 
»¶ayq
 = 
	`ModuË
(
Ãw
 
	$Sim¶eH–ÏCacheIFR•ÏyQueue
(2))

103 
v®
 
»q_¬b
 = 
	`ModuË
(
Ãw
 
	$Arb™”
(
Ãw
 
H–ÏCacheReq
, 2))

105 
v®
 
»q_h–³r
 = 
	`Decou¶edH–³r
(

106 
»q_¬b
.
io
.
	`š
(1).
»ady
,

107 
»¶ayq
.
io
.
»q
.
»ady
,

108 
io
.
»que¡Ü
.
»q
.
v®id
)

110 
»q_¬b
.
io
.
	`š
(0è<> 
»¶ayq
.io.
»¶ay


111 
»q_¬b
.
io
.
	`š
(1).
v®id
 :ğ
»q_h–³r
.
	`fœe
Ôeq_¬b.io.š(1).
»ady
)

112 
»q_¬b
.
io
.
	`š
(1).
b™s
 :ğio.
»que¡Ü
.
»q
.bits

113 
io
.
»que¡Ü
.
»q
.
»ady
 :ğ
»q_h–³r
.
	$fœe
(
io
.
»que¡Ü
.
»q
.
v®id
)

114 
»¶ayq
.
io
.
»q
.
v®id
 :ğ
»q_h–³r
.
	$fœe
(
»¶ayq
.
io
.
»q
.
»ady
)

115 
»¶ayq
.
io
.
»q
.
b™s
 :ğio.
»que¡Ü
.req.bits

117 
v®
 
s0_»q_fœe
 = 
io
.
ÿche
.
»q
.
	$fœe
()

118 
v®
 
s1_»q_fœe
 = 
	$Reg
(
Ãxt
 = 
s0_»q_fœe
)

119 
v®
 
s2_»q_fœe
 = 
	$Reg
(
Ãxt
 = 
s1_»q_fœe
)

120 
v®
 
s1_»q_g
 = 
	$Reg
(
Ãxt
 = 
io
.
ÿche
.
»q
.
b™s
.
g
)

121 
v®
 
s2_»q_g
 = 
	$Reg
(
Ãxt
 = 
s1_»q_g
)

122 
v®
 
s2_kl
 = 
	$Reg
(
Ãxt
 = 
io
.
ÿche
.
s1_kl
)

124 
io
.
ÿche
.
»q
 <> 
»q_¬b
.io.
out


125 
io
.
ÿche
.
s1_kl
 :ğio.ÿche.
s2_Çck


126 
io
.
ÿche
.
s1_d©a
.
d©a
 :ğ
	$RegEÇbË
(
»q_¬b
.
io
.
out
.
b™s
.
d©a
, 
s0_»q_fœe
)

127 
io
.
ÿche
.
s2_kl
 :ğ
çl£
.
B


129 
»¶ayq
.
io
.
Çck
.
v®id
 :ğ(io.
ÿche
.
s2_Çck
 || 
s2_kl
è&& 
s2_»q_fœe


130 
»¶ayq
.
io
.
Çck
.
b™s
 :ğ
s2_»q_g


131 
»¶ayq
.
io
.
»¥
 :ğio.
ÿche
.resp

132 
io
.
»que¡Ü
.
»¥
 :ğio.
ÿche
.resp

134 
	`as£¹
(!
	`RegNext
(RegNext(
io
.
ÿche
.
»q
.
	`fœe
())è|| !io.ÿche.
s2_xıt
.
asUIÁ
.
ÜR
,

136 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLB.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
CacheBlockBy‹s


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
RegiÚTy³


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.{
	gXL’
, 
	gCÜeModuË
, 
	gCÜeBundË
}

13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


15 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


16 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


18 
objeù
 
PgLev–s
 
ex‹nds
 
	gF›ld
[
IÁ
](2)

19 
objeù
 
ASIdB™s
 
ex‹nds
 
	gF›ld
[
IÁ
](0)

21 şas 
	cSF’ûReq
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

22 
v®
 
rs1
 = 
	$BoŞ
()

23 
v®
 
rs2
 = 
	$BoŞ
()

24 
v®
 
addr
 = 
	$UIÁ
(
width
 = 
vaddrB™s
)

25 
v®
 
asid
 = 
	`UIÁ
(
width
 = 
asIdB™s
 
max
 1)

28 şas 
	cTLBReq
(
lgMaxSize
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

29 
v®
 
vaddr
 = 
	$UIÁ
(
width
 = 
vaddrB™sEx‹nded
)

30 
v®
 
·s¡hrough
 = 
	$BoŞ
()

31 
v®
 
size
 = 
	`UIÁ
(
width
 = 
	`log2Ce
(
lgMaxSize
 + 1))

32 
v®
 
cmd
 = 
	$B™s
(
width
 = 
M_SZ
)

34 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`TLBReq
(
lgMaxSize
).
asIn¡ªûOf
[
this
.
ty³
]

37 şas 
	cTLBExû±iÚs
 
ex‹nds
 
BundË
 {

38 
v®
 
ld
 = 
	$BoŞ
()

39 
v®
 
¡
 = 
	$BoŞ
()

40 
v®
 
š¡
 = 
	`BoŞ
()

43 şas 
	cTLBRe¥
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

45 
v®
 
miss
 = 
	$BoŞ
()

46 
v®
 
·ddr
 = 
	$UIÁ
(
width
 = 
·ddrB™s
)

47 
v®
 
pf
 = 
Ãw
 
TLBExû±iÚs


48 
v®
 
«
 = 
Ãw
 
TLBExû±iÚs


49 
v®
 
ma
 = 
Ãw
 
TLBExû±iÚs


50 
v®
 
ÿch—bË
 = 
	$BoŞ
()

51 
v®
 
´eãtchabË
 = 
	`BoŞ
()

54 
şass
 
	$TLBCÚfig
(

55 
nEÁr›s
: 
IÁ
,

56 
nSeùÜs
: 
IÁ
 = 4,

57 
nSu³½ageEÁr›s
: 
IÁ
 = 4)

59 
şass
 
	$TLB
(
š¡ruùiÚ
: 
BoŞ—n
, 
lgMaxSize
: 
IÁ
, 
cfg
: 
TLBCÚfig
)(
im¶ic™
 
edge
: 
TLEdgeOut
, 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
) {

60 
v®
 
io
 = 
Ãw
 
BundË
 {

61 
v®
 
»q
 = 
	`Decou¶ed
(
Ãw
 
	`TLBReq
(
lgMaxSize
)).
æ


62 
v®
 
»¥
 = 
Ãw
 
	`TLBRe¥
().
asOuut


63 
v®
 
sãnû
 = 
	`V®id
(
Ãw
 
SF’ûReq
).
asIÅut


64 
v®
 
±w
 = 
Ãw
 
TLBPTWIO


65 
v®
 
kl
 = 
	`BoŞ
(
INPUT
)

68 şas 
	cEÁryD©a
 
ex‹nds
 
BundË
 {

69 
v®
 
µn
 = 
	`UIÁ
(
width
 = 
µnB™s
)

70 
v®
 
u
 = 
	`BoŞ
()

71 
v®
 
g
 = 
	`BoŞ
()

72 
v®
 
«
 = 
	`BoŞ
()

73 
v®
 
sw
 = 
	`BoŞ
()

74 
v®
 
sx
 = 
	`BoŞ
()

75 
v®
 
¤
 = 
	`BoŞ
()

76 
v®
 
pw
 = 
	`BoŞ
()

77 
v®
 
px
 = 
	`BoŞ
()

78 
v®
 
´
 = 
	`BoŞ
()

79 
v®
 
·l
 = 
	`BoŞ
()

80 
v®
 
·a
 = 
	`BoŞ
()

81 
v®
 
eff
 = 
	`BoŞ
()

82 
v®
 
c
 = 
	`BoŞ
()

83 
v®
 
äagm’‹d_su³½age
 = 
	`BoŞ
()

84 
	}
}

86 
şass
 
	$EÁry
(
v®
 
nSeùÜs
: 
IÁ
, v® 
su³½age
: 
BoŞ—n
, v® 
su³½ageOÆy
: BoŞ—nè
ex‹nds
 
BundË
 {

87 
	`»quœe
(
nSeùÜs
 =ğ1 || !
su³½age
)

88 
	`»quœe
(!
su³½ageOÆy
 || 
su³½age
)

90 
v®
 
Ëv–
 = 
	`UIÁ
(
width
 = 
	`log2Ce
(
pgLev–s
))

91 
v®
 
g
 = 
	`UIÁ
(
width
 = 
v²B™s
)

92 
v®
 
d©a
 = 
	`Vec
(
nSeùÜs
, 
	`UIÁ
(
width
 = 
Ãw
 
	`EÁryD©a
().
g‘Width
))

93 
v®
 
v®id
 = 
	`Vec
(
nSeùÜs
, 
	`BoŞ
())

94 
def
 
’Œy_d©a
 = 
d©a
.
	`m­
(
_
.
	`asTy³Of
(
Ãw
 
EÁryD©a
))

96 
´iv©e
 
def
 
	`£ùÜIdx
(
v²
: 
UIÁ
èğv².
	`exŒaù
(
nSeùÜs
.
log2
-1, 0)

97 
def
 
	`g‘D©a
(
v²
: 
UIÁ
èğ
	`d©a
(
	`£ùÜIdx
(v²)).
	`asTy³Of
(
Ãw
 
EÁryD©a
)

98 
def
 
	`£ùÜH™
(
v²
: 
UIÁ
èğ
v®id
.
ÜR
 && 
	`£ùÜTagM©ch
(vpn)

99 
def
 
	`£ùÜTagM©ch
(
v²
: 
UIÁ
èğ((
g
 ^ v²è>> 
nSeùÜs
.
log2
) === 0

100 
def
 
	`h™
(
v²
: 
UIÁ
) = {

101 ià(
su³½age
 && 
usšgVM
) {

102 
v¬
 
gM©ch
 = 
v®id
.
h—d


103 
j
 <- 0 
uÁ
 
pgLev–s
) {

104 
v®
 
ba£
 = 
v²B™s
 - (
j
 + 1è* 
pgLev–B™s


105 
v®
 
ignÜe
 = 
Ëv–
 < 
j
 || 
su³½ageOÆy
 && j =ğ
pgLev–s
 - 1

106 
gM©ch
 =agM©ch && (
ignÜe
 || 
	`g
(
ba£
 + 
pgLev–B™s
 - 1, ba£è==ğ
	`v²
(base +…gLevelBits - 1, base))

108 
gM©ch


110 
v®
 
idx
 = 
	`£ùÜIdx
(
v²
)

111 
	`v®id
(
idx
è&& 
	`£ùÜTagM©ch
(
v²
)

114 
def
 
	`µn
(
v²
: 
UIÁ
) = {

115 
v®
 
d©a
 = 
	`g‘D©a
(
v²
)

116 ià(
su³½age
 && 
usšgVM
) {

117 
v¬
 
»s
 = 
d©a
.
µn
 >> 
pgLev–B™s
*(
pgLev–s
 - 1)

118 
j
 <- 1 
uÁ
 
pgLev–s
) {

119 
v®
 
ignÜe
 = 
Ëv–
 < 
j
 || 
su³½ageOÆy
 && j =ğ
pgLev–s
 - 1

120 
»s
 = 
	`C©
Ôes, (
	`Mux
(
ignÜe
, 
v²
, 0.Uè| 
d©a
.
µn
)(
v²B™s
 - 
j
*
pgLev–B™s
 - 1, vpnBits - (j + 1)*pgLevelBits))

122 
»s


124 
d©a
.
µn


128 
def
 
	`š£¹
(
g
: 
UIÁ
, 
Ëv–
: UIÁ, 
’Œy
: 
EÁryD©a
) {

129 
this
.
g
 :=ag

130 
this
.
Ëv–
 :ğËv–.
	`exŒaù
(
	`log2Ce
(
pgLev–s
 - 
su³½ageOÆy
.
toIÁ
)-1, 0)

132 
v®
 
idx
 = 
	`£ùÜIdx
(
g
)

133 
	`v®id
(
idx
è:ğ
Œue


134 
	`d©a
(
idx
è:ğ
’Œy
.
asUIÁ


137 
def
 
	`šv®id©e
(è{ 
v®id
.
	`fÜ—ch
(
_
 :ğ
çl£
) }

138 
def
 
	`šv®id©eVPN
(
v²
: 
UIÁ
) {

139 ià(
su³½age
) {

140 
	`wh’
 (
	`h™
(
v²
)è{ 
	`šv®id©e
() }

142 
	`wh’
 (
	`£ùÜTagM©ch
(
v²
)è{ 
	`v®id
(
	`£ùÜIdx
(v²)è:ğ
çl£
 }

146 
	`wh’
 (((
g
 ^ 
v²
è>> (
pgLev–B™s
 * (
pgLev–s
 - 1))) === 0) {

147 (
v
, 
e
è<- 
v®id
 
z
 
’Œy_d©a
)

148 
	`wh’
 (
e
.
äagm’‹d_su³½age
è{ 
v
 :ğ
çl£
 }

152 
def
 
	`šv®id©eNÚGlob®
() {

153 (
v
, 
e
è<- 
v®id
 
z
 
’Œy_d©a
)

154 
	`wh’
 (!
e
.
g
è{ 
v
 :ğ
çl£
 }

156 
	}
}

158 
v®
 
·geG¿nuÏr™yPMPs
 = 
pmpG¿nuÏr™y
 >ğ(1 << 
pgIdxB™s
)

159 
v®
 
£ùÜed_’Œ›s
 = 
Reg
(
Vec
(
cfg
.
nEÁr›s
 / cfg.
nSeùÜs
, 
Ãw
 
	$EÁry
(
cfg
.
nSeùÜs
, 
çl£
, false)))

160 
v®
 
su³½age_’Œ›s
 = 
	`Reg
(
	`Vec
(
cfg
.
nSu³½ageEÁr›s
, 
Ãw
 
	$EÁry
(1, 
Œue
,rue)))

161 
v®
 
¥ecŸl_’Œy
 = (!
·geG¿nuÏr™yPMPs
).
	`İtiÚ
(
	`Reg
(
Ãw
 
	$EÁry
(1, 
Œue
, 
çl£
)))

162 
def
 
Üdš¬y_’Œ›s
 = 
£ùÜed_’Œ›s
 ++ 
su³½age_’Œ›s


163 
def
 
®l_’Œ›s
 = 
Üdš¬y_’Œ›s
 ++ 
¥ecŸl_’Œy


165 
v®
 
s_»ady
 :: 
s_»que¡
 :: 
s_wa™
 :: 
s_wa™_šv®id©e
 :: 
N
 = 
	`Enum
(
	`UIÁ
(), 4)

166 
v®
 
¡©e
 = 
	$Reg
(
š™
=
s_»ady
)

167 
v®
 
r_»fl_g
 = 
	`Reg
(
	$UIÁ
(
width
 = 
v²B™s
))

168 
v®
 
r_su³½age_»¶_addr
 = 
	`Reg
(
	`UIÁ
(
	`log2Ce
(
su³½age_’Œ›s
.
size
).
W
))

169 
v®
 
r_£ùÜed_»¶_addr
 = 
	`Reg
(
	`UIÁ
(
	`log2Ce
(
£ùÜed_’Œ›s
.
size
).
W
))

170 
v®
 
r_£ùÜed_h™_addr
 = 
	`Reg
(
	`UIÁ
(
	`log2Ce
(
£ùÜed_’Œ›s
.
size
).
W
))

171 
v®
 
r_£ùÜed_h™
 = 
	`Reg
(
	$BoŞ
())

173 
v®
 
´iv
 = ià(
š¡ruùiÚ
è
io
.
±w
.
¡©us
.
´v
 io.±w.¡©us.
d´v


174 
v®
 
´iv_s
 = 
	$´iv
(0)

175 
v®
 
´iv_u£s_vm
 = 
´iv
 <ğ
PRV
.
S


176 
v®
 
vm_’abËd
 = 
	`BoŞ
(
usšgVM
è&& 
io
.
±w
.
±br
.
	`mode
(io.±w.±br.
mode
.
g‘Width
-1è&& 
´iv_u£s_vm
 && !io.
»q
.
b™s
.
·s¡hrough


179 
v®
 
v²
 = 
io
.
»q
.
b™s
.
	`vaddr
(
vaddrB™s
-1, 
pgIdxB™s
)

180 
v®
 
»fl_µn
 = 
io
.
±w
.
»¥
.
b™s
.
±e
.
	`µn
(
µnB™s
-1, 0)

181 
v®
 
do_»fl
 = 
	`BoŞ
(
usšgVM
è&& 
io
.
±w
.
»¥
.
v®id


182 
v®
 
šv®id©e_»fl
 = 
¡©e
.
	$isOÃOf
(
s_»que¡
 , 
s_wa™_šv®id©e
)

183 
v®
 
mpu_µn
 = 
	`Mux
(
do_»fl
, 
»fl_µn
,

184 
	`Mux
(
vm_’abËd
 && 
¥ecŸl_’Œy
.
nÚEm±y
, s³cŸl_’Œy.
	`m­
(
_
.
	`µn
(
v²
)).
	`g‘OrEl£
(0.U), 
io
.
»q
.
b™s
.
vaddr
 >> 
pgIdxB™s
))

185 
v®
 
mpu_phy§ddr
 = 
	`C©
(
mpu_µn
, 
io
.
»q
.
b™s
.
	`vaddr
(
pgIdxB™s
-1, 0))

186 
v®
 
pmp
 = 
	`ModuË
(
Ãw
 
	$PMPCheck”
(
lgMaxSize
))

187 
pmp
.
io
.
addr
 :ğ
mpu_phy§ddr


188 
pmp
.
io
.
size
 :ğio.
»q
.
b™s
.size

189 
pmp
.
io
.pm°:ğ(io.
±w
.pmp: 
Seq
[
PMP
])

190 
pmp
.
io
.
´v
 :ğ
	`Mux
(
	`BoŞ
(
usšgVM
è&& (
do_»fl
 || io.
»q
.
b™s
.
·s¡hrough
 ), 
PRV
.
S
, 
´iv
)

191 
v®
 
Ëg®_add»ss
 = 
edge
.
mªag”
.
	`fšdSaã
(
mpu_phy§ddr
).
	`»duû
(
_
||_)

192 
def
 
	`ç¡Check
(
memb”
: 
TLMªag”P¬am‘”s
 => 
BoŞ—n
) =

193 
Ëg®_add»ss
 && 
edge
.
mªag”
.
	`ç¡Prİ”ty
(
mpu_phy§ddr
, 
memb”
, (
b
:
BoŞ—n
è=> 
	$BoŞ
(
b
))

194 
v®
 
ÿch—bË
 = 
	`ç¡Check
(
_
.
suµÜtsAcquœeT
è&& (
š¡ruùiÚ
 || !
usšgD©aSü©ch·d
)

195 
v®
 
homog’eous
 = 
	`TLBPageLookup
(
edge
.
mªag”
.
mªag”s
, 
xL’
, 
	`p
(
CacheBlockBy‹s
), 
	`BigIÁ
(1è<< 
pgIdxB™s
)(
mpu_phy§ddr
).homogeneous

196 
v®
 
´Ù_r
 = 
	`ç¡Check
(
_
.
suµÜtsG‘
è&& 
pmp
.
io
.
r


197 
v®
 
´Ù_w
 = 
	`ç¡Check
(
_
.
suµÜtsPutFuÎ
è&& 
pmp
.
io
.
w


198 
v®
 
´Ù_®
 = 
	`ç¡Check
(
_
.
suµÜtsLogiÿl
è|| (
ÿch—bË
 && 
usšgAtomicsInCache
)

199 
v®
 
´Ù_¯
 = 
	`ç¡Check
(
_
.
suµÜtsAr™hm‘ic
è|| (
ÿch—bË
 && 
usšgAtomicsInCache
)

200 
v®
 
´Ù_x
 = 
	`ç¡Check
(
_
.
execubË
è&& 
pmp
.
io
.
x


201 
v®
 
´Ù_eff
 = 
	`ç¡Check
(
	$Seq
(
RegiÚTy³
.
PUT_EFFECTS
, RegiÚTy³.
GET_EFFECTS
è
cÚšs
 
_
.
»giÚTy³
)

203 
v®
 
£ùÜ_h™s
 = 
£ùÜed_’Œ›s
.
	`m­
(
_
.
	$£ùÜH™
(
v²
))

204 
v®
 
su³½age_h™s
 = 
su³½age_’Œ›s
.
	`m­
(
_
.
	$h™
(
v²
))

205 
v®
 
h™sVec
 = 
®l_’Œ›s
.
	`m­
(
vm_’abËd
 && 
_
.
	$h™
(
v²
))

206 
v®
 
»®_h™s
 = 
h™sVec
.
asUIÁ


207 
v®
 
h™s
 = 
	`C©
(!
vm_’abËd
, 
»®_h™s
)

208 
v®
 
µn
 = 
	`Mux1H
(
h™sVec
 :+ !
vm_’abËd
, 
®l_’Œ›s
.
	`m­
(
_
.
	$µn
(
v²
)è:+ 
	`v²
(
µnB™s
-1, 0))

211 
	`wh’
 (
do_»fl
 && !
šv®id©e_»fl
) {

212 
v®
 
±e
 = 
io
.
±w
.
»¥
.
b™s
.pte

213 
v®
 
ÃwEÁry
 = 
	`Wœe
(
Ãw
 
EÁryD©a
)

214 
ÃwEÁry
.
µn
 :ğ
±e
.ppn

215 
ÃwEÁry
.
c
 :ğ
ÿch—bË


216 
ÃwEÁry
.
u
 :ğ
±e
.u

217 
ÃwEÁry
.
g
 :ğ
±e
.g

218 
ÃwEÁry
.
«
 :ğ
io
.
±w
.
»¥
.
b™s
.ae

219 
ÃwEÁry
.
¤
 :ğ
±e
.
	`¤
()

220 
ÃwEÁry
.
sw
 :ğ
±e
.
	`sw
()

221 
ÃwEÁry
.
sx
 :ğ
±e
.
	`sx
()

222 
ÃwEÁry
.
´
 :ğ
´Ù_r


223 
ÃwEÁry
.
pw
 :ğ
´Ù_w


224 
ÃwEÁry
.
px
 :ğ
´Ù_x


225 
ÃwEÁry
.
·l
 :ğ
´Ù_®


226 
ÃwEÁry
.
·a
 :ğ
´Ù_¯


227 
ÃwEÁry
.
eff
 :ğ
´Ù_eff


228 
ÃwEÁry
.
äagm’‹d_su³½age
 :ğ
io
.
±w
.
»¥
.
b™s
.fragmented_superpage

230 
	`wh’
 (
¥ecŸl_’Œy
.
nÚEm±y
 && !
io
.
±w
.
»¥
.
b™s
.
homog’eous
) {

231 
¥ecŸl_’Œy
.
	`fÜ—ch
(
_
.
	`š£¹
(
r_»fl_g
, 
io
.
±w
.
»¥
.
b™s
.
Ëv–
, 
ÃwEÁry
))

232 }.
	`–£wh’
 (
io
.
±w
.
»¥
.
b™s
.
Ëv–
 < 
pgLev–s
-1) {

233 (
e
, 
i
è<- 
su³½age_’Œ›s
.
zW™hIndex
è
	`wh’
 (
r_su³½age_»¶_addr
 === i) {

234 
e
.
	`š£¹
(
r_»fl_g
, 
io
.
±w
.
»¥
.
b™s
.
Ëv–
, 
ÃwEÁry
)

236 }.
Ùh”wi£
 {

237 
v®
 
waddr
 = 
	`Mux
(
r_£ùÜed_h™
, 
r_£ùÜed_h™_addr
, 
r_£ùÜed_»¶_addr
)

238 (
e
, 
i
è<- 
£ùÜed_’Œ›s
.
zW™hIndex
è
	`wh’
 (
waddr
 === i) {

239 
	`wh’
 (!
r_£ùÜed_h™
è{ 
e
.
	`šv®id©e
() }

240 
e
.
	`š£¹
(
r_»fl_g
, 0.U, 
ÃwEÁry
)

243 
	}
}

245 
v®
 
	g’Œ›s
 = 
®l_’Œ›s
.
m­
(
_
.
	$g‘D©a
(
v²
))

246 
v®
 
nÜm®_’Œ›s
 = 
Üdš¬y_’Œ›s
.
	`m­
(
_
.
	$g‘D©a
(
v²
))

247 
v®
 
nPhysiÿlEÁr›s
 = 1 + 
¥ecŸl_’Œy
.
size


248 
v®
 
±w_«_¬¿y
 = 
	`C©
(
çl£
.
B
, 
’Œ›s
.
	`m­
(
_
.
«
).
asUIÁ
)

249 
v®
 
´iv_rw_ok
 = 
	`Mux
(!
´iv_s
 || 
io
.
±w
.
¡©us
.
sum
, 
’Œ›s
.
	`m­
(
_
.
u
).
asUIÁ
, 0.U) | Mux(priv_s, ~entries.map(_.u).asUInt, 0.U)

250 
v®
 
´iv_x_ok
 = 
	`Mux
(
´iv_s
, ~
’Œ›s
.
	`m­
(
_
.
u
).
asUIÁ
,ƒntries.map(_.u).asUInt)

251 
v®
 
r_¬¿y
 = 
	`C©
(
Œue
.
B
, 
´iv_rw_ok
 & (
’Œ›s
.
	`m­
(
_
.
¤
).
asUIÁ
 | 
	`Mux
(
io
.
±w
.
¡©us
.
mxr
,ƒÁr›s.m­(_.
sx
).asUIÁ, 
	$UIÁ
(0))))

252 
v®
 
w_¬¿y
 = 
	`C©
(
Œue
.
B
, 
´iv_rw_ok
 & 
’Œ›s
.
	`m­
(
_
.
sw
).
asUIÁ
)

253 
v®
 
x_¬¿y
 = 
	`C©
(
Œue
.
B
, 
´iv_x_ok
 & 
’Œ›s
.
	`m­
(
_
.
sx
).
asUIÁ
)

254 
v®
 
´_¬¿y
 = 
	`C©
(
	`Fl
(
nPhysiÿlEÁr›s
, 
´Ù_r
), 
nÜm®_’Œ›s
.
	`m­
(
_
.
´
).
asUIÁ
è| 
±w_«_¬¿y


255 
v®
 
pw_¬¿y
 = 
	`C©
(
	`Fl
(
nPhysiÿlEÁr›s
, 
´Ù_w
), 
nÜm®_’Œ›s
.
	`m­
(
_
.
pw
).
asUIÁ
è| 
±w_«_¬¿y


256 
v®
 
px_¬¿y
 = 
	`C©
(
	`Fl
(
nPhysiÿlEÁr›s
, 
´Ù_x
), 
nÜm®_’Œ›s
.
	`m­
(
_
.
px
).
asUIÁ
è| 
±w_«_¬¿y


257 
v®
 
·a_¬¿y
 = 
	`C©
(
	`Fl
(
nPhysiÿlEÁr›s
, 
´Ù_¯
), 
nÜm®_’Œ›s
.
	`m­
(
_
.
·a
).
asUIÁ
)

258 
v®
 
·l_¬¿y
 = 
	`C©
(
	`Fl
(
nPhysiÿlEÁr›s
, 
´Ù_®
), 
nÜm®_’Œ›s
.
	`m­
(
_
.
·l
).
asUIÁ
)

259 
v®
 
eff_¬¿y
 = 
	`C©
(
	`Fl
(
nPhysiÿlEÁr›s
, 
´Ù_eff
), 
nÜm®_’Œ›s
.
	`m­
(
_
.
eff
).
asUIÁ
)

260 
v®
 
c_¬¿y
 = 
	`C©
(
	`Fl
(
nPhysiÿlEÁr›s
, 
ÿch—bË
), 
nÜm®_’Œ›s
.
	`m­
(
_
.
c
).
asUIÁ
)

261 
v®
 
´eãtchabË_¬¿y
 = 
	`C©
((
ÿch—bË
 && 
homog’eous
è<< (
nPhysiÿlEÁr›s
-1), 
nÜm®_’Œ›s
.
	`m­
(
_
.
c
).
asUIÁ
)

263 
v®
 
mi§ligÃd
 = (
io
.
»q
.
b™s
.
vaddr
 & (
	`UIÁToOH
(io.»q.b™s.
size
è- 1)).
ÜR


264 
v®
 
bad_va
 = 
vm_’abËd
 &&

265 (ià(
v²B™s
 =ğ
v²B™sEx‹nded
è
	$BoŞ
(
çl£
)

266 (
io
.
»q
.
b™s
.
vaddr
.
asSIÁ
 < 0.
S
è=/ğ(
v²
.asSInt < 0.S))

268 
v®
 
ÌscAÎowed
 = 
	`Mux
(
	`BoŞ
(
usšgD©aSü©ch·d
 || 
usšgAtomicsOÆyFÜIO
), 0.U, 
c_¬¿y
)

269 
v®
 
«_¬¿y
 =

270 
	`Mux
(
mi§ligÃd
, 
eff_¬¿y
, 0.U) |

271 
	`Mux
(
	`BoŞ
(
usšgAtomics
è&& 
io
.
»q
.
b™s
.
cmd
.
	`isOÃOf
(
M_XLR
, 
M_XSC
), ~
ÌscAÎowed
, 0.U)

272 
v®
 
«_ld_¬¿y
 = 
	`Mux
(
	`isR—d
(
io
.
»q
.
b™s
.
cmd
), 
«_¬¿y
 | ~
´_¬¿y
, 0.U)

273 
v®
 
«_¡_¬¿y
 =

274 
	`Mux
(
	`isWr™e
(
io
.
»q
.
b™s
.
cmd
), 
«_¬¿y
 | ~
pw_¬¿y
, 0.U) |

275 
	`Mux
(
	`BoŞ
(
usšgAtomics
è&& 
	`isAMOLogiÿl
(
io
.
»q
.
b™s
.
cmd
), ~
·l_¬¿y
, 0.U) |

276 
	`Mux
(
	`BoŞ
(
usšgAtomics
è&& 
	`isAMOAr™hm‘ic
(
io
.
»q
.
b™s
.
cmd
), ~
·a_¬¿y
, 0.U)

277 
v®
 
ma_ld_¬¿y
 = 
	`Mux
(
mi§ligÃd
 && 
	`isR—d
(
io
.
»q
.
b™s
.
cmd
), ~
eff_¬¿y
, 0.U)

278 
v®
 
ma_¡_¬¿y
 = 
	`Mux
(
mi§ligÃd
 && 
	`isWr™e
(
io
.
»q
.
b™s
.
cmd
), ~
eff_¬¿y
, 0.U)

279 
v®
 
pf_ld_¬¿y
 = 
	`Mux
(
	`isR—d
(
io
.
»q
.
b™s
.
cmd
), ~(
r_¬¿y
 | 
±w_«_¬¿y
), 0.U)

280 
v®
 
pf_¡_¬¿y
 = 
	`Mux
(
	`isWr™e
(
io
.
»q
.
b™s
.
cmd
), ~(
w_¬¿y
 | 
±w_«_¬¿y
), 0.U)

281 
v®
 
pf_š¡_¬¿y
 = ~(
x_¬¿y
 | 
±w_«_¬¿y
)

283 
v®
 
b_h™
 = 
»®_h™s
.
ÜR


284 
v®
 
b_miss
 = 
vm_’abËd
 && !
bad_va
 && !
b_h™


286 
v®
 
£ùÜed_¶ru
 = 
Ãw
 
	$P£udoLRU
(
£ùÜed_’Œ›s
.
size
)

287 
v®
 
su³½age_¶ru
 = 
Ãw
 
	$P£udoLRU
(
su³½age_’Œ›s
.
size
)

288 
	$wh’
 (
io
.
»q
.
v®id
 && 
vm_’abËd
) {

289 
	`wh’
 (
£ùÜ_h™s
.
ÜR
è{ 
£ùÜed_¶ru
.
	`acûss
(
	`OHToUIÁ
(sector_hits)) }

290 
	`wh’
 (
su³½age_h™s
.
ÜR
è{ 
su³½age_¶ru
.
	`acûss
(
	`OHToUIÁ
(superpage_hits)) }

291 
	}
}

298 
v®
 
muÉËH™s
 = 
	$PİCouÁAtL—¡
(
»®_h™s
, 2)

300 
io
.
»q
.
»ady
 :ğ
¡©e
 ==ğ
s_»ady


301 
io
.
»¥
.
pf
.
ld
 :ğ(
bad_va
 && 
	`isR—d
(io.
»q
.
b™s
.
cmd
)è|| (
pf_ld_¬¿y
 & 
h™s
).
ÜR


302 
io
.
»¥
.
pf
.
¡
 :ğ(
bad_va
 && 
	`isWr™e
(io.
»q
.
b™s
.
cmd
)è|| (
pf_¡_¬¿y
 & 
h™s
).
ÜR


303 
io
.
»¥
.
pf
.
š¡
 :ğ
bad_va
 || (
pf_š¡_¬¿y
 & 
h™s
).
ÜR


304 
io
.
»¥
.
«
.
ld
 :ğ(
«_ld_¬¿y
 & 
h™s
).
ÜR


305 
io
.
»¥
.
«
.
¡
 :ğ(
«_¡_¬¿y
 & 
h™s
).
ÜR


306 
io
.
»¥
.
«
.
š¡
 :ğ(~
px_¬¿y
 & 
h™s
).
ÜR


307 
io
.
»¥
.
ma
.
ld
 :ğ(
ma_ld_¬¿y
 & 
h™s
).
ÜR


308 
io
.
»¥
.
ma
.
¡
 :ğ(
ma_¡_¬¿y
 & 
h™s
).
ÜR


309 
io
.
»¥
.
ma
.
š¡
 :ğ
çl£


310 
io
.
»¥
.
ÿch—bË
 :ğ(
c_¬¿y
 & 
h™s
).
ÜR


311 
io
.
»¥
.
´eãtchabË
 :ğ(
´eãtchabË_¬¿y
 & 
h™s
).
ÜR
 && 
edge
.
mªag”
.
mªag”s
.
	`fÜ®l
(
m
 => !m.
suµÜtsAcquœeB
 || m.
suµÜtsHšt
)

312 
io
.
»¥
.
miss
 :ğ
do_»fl
 || 
b_miss
 || 
muÉËH™s


313 
io
.
»¥
.
·ddr
 :ğ
	`C©
(
µn
, io.
»q
.
b™s
.
	`vaddr
(
pgIdxB™s
-1, 0))

315 
io
.
±w
.
»q
.
v®id
 :ğ
¡©e
 ==ğ
s_»que¡


316 
io
.
±w
.
»q
.
b™s
.
v®id
 :ğ!io.
kl


317 
io
.
±w
.
»q
.
b™s
.b™s.
addr
 :ğ
r_»fl_g


319 ià(
usšgVM
) {

320 
v®
 
sãnû
 = 
io
.sãnû.
v®id


321 
	`wh’
 (
io
.
»q
.
	`fœe
(è&& 
b_miss
) {

322 
¡©e
 :ğ
s_»que¡


323 
r_»fl_g
 :ğ
v²


325 
r_su³½age_»¶_addr
 :ğ
	`»¶aûm’tEÁry
(
su³½age_’Œ›s
, 
su³½age_¶ru
.
»¶aû
)

326 
r_£ùÜed_»¶_addr
 :ğ
	`»¶aûm’tEÁry
(
£ùÜed_’Œ›s
, 
£ùÜed_¶ru
.
»¶aû
)

327 
r_£ùÜed_h™_addr
 :ğ
	`OHToUIÁ
(
£ùÜ_h™s
)

328 
r_£ùÜed_h™
 :ğ
£ùÜ_h™s
.
ÜR


330 
	`wh’
 (
¡©e
 ==ğ
s_»que¡
) {

331 
	`wh’
 (
sãnû
è{ 
¡©e
 :ğ
s_»ady
 }

332 
	`wh’
 (
io
.
±w
.
»q
.
»ady
è{ 
¡©e
 :ğ
	`Mux
(
sãnû
, 
s_wa™_šv®id©e
, 
s_wa™
) }

333 
	`wh’
 (
io
.
kl
è{ 
¡©e
 :ğ
s_»ady
 }

335 
	`wh’
 (
¡©e
 ==ğ
s_wa™
 && 
sãnû
) {

336 
¡©e
 :ğ
s_wa™_šv®id©e


338 
	`wh’
 (
io
.
±w
.
»¥
.
v®id
) {

339 
¡©e
 :ğ
s_»ady


342 
	`wh’
 (
sãnû
) {

343 
	`as£¹
(!
io
.
sãnû
.
b™s
.
rs1
 || (io.sãnû.b™s.
addr
 >> 
pgIdxB™s
è==ğ
v²
)

344 
e
 <- 
®l_’Œ›s
) {

345 
	`wh’
 (
io
.
sãnû
.
b™s
.
rs1
è{ 
e
.
	`šv®id©eVPN
(
v²
) }

346 .
	`–£wh’
 (
io
.
sãnû
.
b™s
.
rs2
è{ 
e
.
	`šv®id©eNÚGlob®
() }

347 .
Ùh”wi£
 { 
e
.
	`šv®id©e
() }

350 
	`wh’
 (
muÉËH™s
 || 
»£t
) {

351 
®l_’Œ›s
.
	`fÜ—ch
(
_
.
	`šv®id©e
())

354 
	`ccov”
(
io
.
±w
.
»q
.
	`fœe
(), "MISS", "TLB miss")

355 
	`ccov”
(
io
.
±w
.
»q
.
v®id
 && !io.±w.»q.
»ady
, "PTW_STALL", "TLB miss, but PTW busy")

356 
	`ccov”
(
¡©e
 ==ğ
s_wa™_šv®id©e
, "SFENCE_DURING_REFILL", "flush TLB during TLB„efill")

357 
	`ccov”
(
sãnû
 && !
io
.sãnû.
b™s
.
rs1
 && !io.sãnû.b™s.
rs2
, "SFENCE_ALL", "flush TLB")

358 
	`ccov”
(
sãnû
 && !
io
.sãnû.
b™s
.
rs1
 && io.sãnû.b™s.
rs2
, "SFENCE_ASID", "flush TLB ASID")

359 
	`ccov”
(
sãnû
 && 
io
.sãnû.
b™s
.
rs1
 && !io.sãnû.b™s.
rs2
, "SFENCE_LINE", "flush TLB†ine")

360 
	`ccov”
(
sãnû
 && 
io
.sãnû.
b™s
.
rs1
 && io.sãnû.b™s.
rs2
, "SFENCE_LINE_ASID", "flush TLB†ine/ASID")

361 
	`ccov”
(
muÉËH™s
, "MULTIPLE_HITS", "Two matchingranslations in TLB")

362 
	}
}

364 
def
 
	$ccov”
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

365 
	`cov”
(
cÚd
, 
s
"${ià(š¡ruùiÚè"
I
"ƒl£ "
D
"}TLB_$Ïb–", "MemÜySy¡em;;" + 
desc
)

367 
def
 
	`»¶aûm’tEÁry
(
£t
: 
Seq
[
EÁry
], 
®t
: 
UIÁ
) = {

368 
v®
 
v®ids
 = 
£t
.
	`m­
(
_
.
v®id
.
ÜR
).
asUIÁ


369 
	`Mux
(
v®ids
.
ªdR
, 
®t
, 
	`PriÜ™yEncod”
(~valids))

370 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLBPermissions.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
rock‘


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
şass
 
	$TLBP”missiÚs
(

11 
homog’eous
: 
BoŞ
,

12 
r
: 
BoŞ
,

13 
w
: 
BoŞ
,

14 
x
: 
BoŞ
,

15 
c
: 
BoŞ
,

16 
a
: 
BoŞ
,

17 
l
: 
BoŞ
)

19 
objeù
 
TLBPageLookup


21 
´iv©e
 
şass
 
	`TLBFixedP”missiÚs
(

22 
e
: 
BoŞ—n
,

23 
r
: 
BoŞ—n
,

24 
w
: 
BoŞ—n
,

25 
x
: 
BoŞ—n
,

26 
c
: 
BoŞ—n
,

27 
a
: 
BoŞ—n
,

28 
l
: 
BoŞ—n
) {

29 
v®
 
u£ful
 = 
r
 || 
w
 || 
x
 || 
c
 || 
a
 || 
l


32 
´iv©e
 
def
 
	`groupRegiÚs
(
mªag”s
: 
Seq
[
TLMªag”P¬am‘”s
]): 
M­
[
TLBFixedP”missiÚs
, Seq[
Add»ssS‘
]] = {

33 
v®
 
³rmissiÚs
 = 
mªag”s
.
m­
 { 
m
 =>

34 (
m
.
add»ss
, 
	`TLBFixedP”missiÚs
(

35 
e
 = 
	`Seq
(
RegiÚTy³
.
PUT_EFFECTS
, RegiÚTy³.
GET_EFFECTS
è
cÚšs
 
m
.
»giÚTy³
,

36 
r
 = 
m
.
suµÜtsG‘
 || m.
suµÜtsAcquœeB
,

37 
w
 = 
m
.
suµÜtsPutFuÎ
 || m.
suµÜtsAcquœeT
,

38 
x
 = 
m
.
execubË
,

39 
c
 = 
m
.
suµÜtsAcquœeB
,

40 
a
 = 
m
.
suµÜtsAr™hm‘ic
,

41 
l
 = 
m
.
suµÜtsLogiÿl
))

44 
³rmissiÚs


45 .
	`f‹r
(
_
.
_2
.
u£ful
)

46 .
	`groupBy
(
_
.
_2
)

47 .
	`m­V®ues
(
£q
 =>

48 
Add»ssS‘
.
	`unify
(
£q
.
	`æ©M­
(
_
.
_1
)))

52 
def
 
	`­¶y
(
mªag”s
: 
Seq
[
TLMªag”P¬am‘”s
], 
xL’
: 
IÁ
, 
ÿcheBlockBy‹s
: IÁ, 
·geSize
: 
BigIÁ
): 
UIÁ
 => 
TLBP”missiÚs
 = {

53 
	`»quœe
 (
	`isPow2
(
xL’
) && xLen >= 8)

54 
	`»quœe
 (
	`isPow2
(
ÿcheBlockBy‹s
è&& cacheBlockBy‹ >ğ
xL’
/8)

55 
	`»quœe
 (
	`isPow2
(
·geSize
è&&…ageSiz>ğ
ÿcheBlockBy‹s
)

57 
v®
 
xãrSizes
 = 
	`T¿nsãrSizes
(
ÿcheBlockBy‹s
, cacheBlockBytes)

58 
v®
 
®lSizes
 = 
	`T¿nsãrSizes
(1, 
ÿcheBlockBy‹s
)

59 
v®
 
amoSizes
 = 
	`T¿nsãrSizes
(4, 
xL’
/8)

61 
v®
 
³rmissiÚs
 = 
mªag”s
.
fÜ—ch
 { 
m
 =>

62 
	`»quœe
 (!
m
.
suµÜtsG‘
 || m.suµÜtsG‘ .
	`cÚšs
(
®lSizes
), 
s
"Memory„egion '${m.name}'‡t ${m.address} only supports ${m.supportsGet} Get, but must support ${allSizes}")

63 
	`»quœe
 (!
m
.
suµÜtsPutFuÎ
 || m.suµÜtsPutFuÎ .
	`cÚšs
(
®lSizes
), 
s
"Memory„egion '${m.name}'‡t ${m.address} only supports ${m.supportsPutFull} PutFull, but must support ${allSizes}")

64 
	`»quœe
 (!
m
.
suµÜtsAcquœeB
 || m.suµÜtsAcquœeB .
	`cÚšs
(
xãrSizes
), 
s
"Memory„egion '${m.name}'‡t ${m.address} only supports ${m.supportsAcquireB} AcquireB, but must support ${xferSizes}")

65 
	`»quœe
 (!
m
.
suµÜtsAcquœeT
 || m.suµÜtsAcquœeT .
	`cÚšs
(
xãrSizes
), 
s
"Memory„egion '${m.name}'‡t ${m.address} only supports ${m.supportsAcquireT} AcquireT, but must support ${xferSizes}")

66 
	`»quœe
 (!
m
.
suµÜtsLogiÿl
 || m.suµÜtsLogiÿÈ.
	`cÚšs
(
amoSizes
), 
s
"Memory„egion '${m.name}'‡t ${m.address} only supports ${m.supportsLogical} Logical, but must support ${amoSizes}")

67 
	`»quœe
 (!
m
.
suµÜtsAr™hm‘ic
 || m.suµÜtsAr™hm‘ic.
	`cÚšs
(
amoSizes
), 
s
"Memory„egion '${m.name}'‡t ${m.address} only supports ${m.supportsArithmetic} Arithmetic, but must support ${amoSizes}")

70 
v®
 
grou³d
 = 
	`groupRegiÚs
(
mªag”s
)

71 .
	`m­V®ues
(
_
.
	`f‹r
(_.
®ignm’t
 >ğ
·geSize
))

73 
def
 
	`lowCo¡Prİ”ty
(
´İ
: 
TLBFixedP”missiÚs
 => 
BoŞ—n
): 
UIÁ
 => 
BoŞ
 = {

74 
	`v®
 (
yesm
, 
nom
èğ
grou³d
.
·¹™iÚ
 { (
k
, 
eq
è=> 
	`´İ
(k) }

75 
	`v®
 (
yes
, 
no
èğ(
yesm
.
v®ues
.
æ©‹n
.
toLi¡
, 
nom
.values.flatten.toList)

77 
v®
 
decisiÚMask
 = 
	`Add»ssDecod”
(
	`Seq
(
yes
, 
no
))

78 
def
 
	`sim¶ify
(
x
: 
Seq
[
Add»ssS‘
]èğAdd»ssS‘.
	`unify
(x.
	`m­
(
_
.
	`wid’
(~
decisiÚMask
)).
di¡šù
)

79 
	`v®
 (
yesf
, 
nof
èğ(
	`sim¶ify
(
yes
), sim¶ify(
no
))

80 ià(
yesf
.
size
 < 
no
.size) {

81 (
x
: 
UIÁ
è=> 
yesf
.
	`m­
(
_
.
	`cÚšs
(x)).
	`fŞdLeá
(
çl£
.
B
)(_ || _)

83 (
x
: 
UIÁ
è=> !
nof
.
	`m­
(
_
.
	`cÚšs
(x)).
	`fŞdLeá
(
çl£
.
B
)(_ || _)

88 
v®
 
râ
 = 
	`lowCo¡Prİ”ty
(
_
.
r
)

89 
v®
 
wâ
 = 
	`lowCo¡Prİ”ty
(
_
.
w
)

90 
v®
 
xâ
 = 
	`lowCo¡Prİ”ty
(
_
.
x
)

91 
v®
 
câ
 = 
	`lowCo¡Prİ”ty
(
_
.
c
)

92 
v®
 
aâ
 = 
	`lowCo¡Prİ”ty
(
_
.
a
)

93 
v®
 
lâ
 = 
	`lowCo¡Prİ”ty
(
_
.
l
)

95 
v®
 
homo
 = 
Add»ssS‘
.
	`unify
(
grou³d
.
v®ues
.
æ©‹n
.
toLi¡
)

96 (
x
: 
UIÁ
è=> 
	`TLBP”missiÚs
(

97 
homog’eous
 = 
homo
.
	`m­
(
_
.
	`cÚšs
(
x
)).
	`fŞdLeá
(
çl£
.
B
)(_ || _),

98 
r
 = 
	`râ
(
x
),

99 
w
 = 
	`wâ
(
x
),

100 
x
 = 
	`xâ
(x),

101 
c
 = 
	`câ
(
x
),

102 
a
 = 
	`aâ
(
x
),

103 
l
 = 
	`lâ
(
x
))

107 
def
 
	`homog’eous
(
mªag”s
: 
Seq
[
TLMªag”P¬am‘”s
], 
·geSize
: 
BigIÁ
): 
BoŞ—n
 = {

108 
	`groupRegiÚs
(
mªag”s
).
v®ues
.
	`fÜ®l
(
_
.fÜ®l(_.
®ignm’t
 >ğ
·geSize
))

110 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
·ckage
 
objeù
 
rock‘
 
ex‹nds
 
	grock‘
.
	gcÚ¡ªts
.
SÿÏrOpCÚ¡ªts
 
w™h
„ock‘.cÚ¡ªts.
	gMemÜyOpCÚ¡ªts


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/scie/SCIE.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
sc›


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.{
	gB™P©
, 
	gHasBÏckBoxIÆše
}

7 
impÜt
 
	gchi£l3
.
	gex³rim’l
.{
	gIÁP¬am
, 
	gäomIÁToIÁP¬am
}

9 
objeù
 
	gSCIE
 {

10 
v®
 
	gİcode
 = 
B™P©
("b?????????????????????????0?01011")

11 
v®
 
iL’
 = 32

14 şas 
	cSCIEDecod”IÁ”çû
 
ex‹nds
 
	mBundË
 {

15 
v®
 
	mš¢
 = 
IÅut
(
	$UIÁ
(
SCIE
.
iL’
.
W
))

16 
v®
 
uÅ–šed
 = 
	`Ouut
(
	$BoŞ
())

17 
v®
 
p–šed
 = 
	`Ouut
(
	$BoŞ
())

18 
v®
 
muÉicyşe
 = 
	`Ouut
(
	`BoŞ
())

21 şas 
	cSCIEDecod”
 
ex‹nds
 
BÏckBox
 
w™h
 
HasBÏckBoxIÆše
 {

22 
v®
 
io
 = 
	$IO
(
Ãw
 
SCIEDecod”IÁ”çû
)

24 
	`£tIÆše
("SCIEDecoder.v",

25 
s
"""

26 |
moduË
 
	`SCIEDecod”
 (

27 | 
šput
 [
$
{
SCIE
.
iL’
-1}:0] 
š¢
,

28 | 
ouut
 
uÅ–šed
,

29 | 
ouut
 
p–šed
,

30 | 
ouut
 
muÉicyşe
);

43 | 
assign
 
uÅ–šed
 = (
š¢
[14:12] <= 3'b1);

44 | 
assign
 
p–šed
 = 1'b0;

45 | 
assign
 
muÉicyşe
 = 1'b0;

47 |
’dmoduË


49 
	}
}

51 şas 
	cSCIEUÅ–šedIÁ”çû
(
xL’
: 
IÁ
è
ex‹nds
 
BundË
 {

52 
v®
 
š¢
 = 
	`IÅut
(
	$UIÁ
(
SCIE
.
iL’
.
W
))

53 
v®
 
rs1
 = 
	`IÅut
(
	$UIÁ
(
xL’
.
W
))

54 
v®
 
rs2
 = 
	`IÅut
(
	$UIÁ
(
xL’
.
W
))

55 
v®
 
rd
 = 
	`Ouut
(
	`UIÁ
(
xL’
.
W
))

58 
şass
 
	$SCIEUÅ–šed
(
xL’
: 
IÁ
è
ex‹nds
 
	`BÏckBox
(
	`M­
("XLEN" -> xL’)è
w™h
 
HasBÏckBoxIÆše
 {

59 
v®
 
io
 = 
	`IO
(
Ãw
 
	`SCIEUÅ–šedIÁ”çû
(
xL’
))

61 
	`£tIÆše
("SCIEUnpipelined.v",

62 
s
"""

63 |
moduË
 
SCIEUÅ–šed
 #(
·¿m‘”
 
XLEN
 = 32) (

64 | 
šput
 [
$
{
SCIE
.
iL’
-1}:0] 
š¢
,

65 | 
šput
 [
XLEN
-1:0] 
rs1
,

66 | 
šput
 [
XLEN
-1:0] 
rs2
,

67 | 
ouut
 [
XLEN
-1:0] 
rd
);

81 | 
wœe
 
u£_immedŸ‹
 = 
š¢
[5];

82 | 
wœe
 
pick_sm®Ër
 = !
š¢
[12];

85 | 
wœe
 [
XLEN
-1:0] 
immedŸ‹
 = {{(XLEN-12){
š¢
[31]}}, insn[31:20]};

86 | 
wœe
 [
XLEN
-1:0] 
rhs
 = 
u£_immedŸ‹
 ? 
immedŸ‹
 : 
rs2
;

87 | 
wœe
 [
XLEN
-1:0] 
lhs
 = 
rs1
;

90 | 
wœe
 
lhs_sm®Ër
 = 
	`$$sigÃd
(
lhs
è< $$sigÃd(
rhs
);

91 | 
wœe
 [
XLEN
-1:0] 
»suÉ
 = 
lhs_sm®Ër
 =ğ
pick_sm®Ër
 ? 
lhs
 : 
rhs
;

94 | 
assign
 
rd
 = 
»suÉ
;

96 |
’dmoduË


98 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/BaseSubsystem.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gP¬am‘”s
, 
	gF›ld
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
objeù
 
BudSy¡emBus
 
ex‹nds
 
	gF›ld
[
P¬am‘”s
 => 
Sy¡emBus
](
p
 => 
Ãw
 Sy¡emBus(
	$p
(
Sy¡emBusKey
))(
p
))

14 
ab¡¿ù
 cÏs 
	cB¬eSubsy¡em
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 
w™h
 
BšdšgScİe
 {

15 
Ïzy
 
v®
 
dts
 = 
	$DTS
(
bšdšgT»e
)

16 
Ïzy
 
v®
 
dtb
 = 
	$DTB
(
dts
)

17 
Ïzy
 
v®
 
jsÚ
 = 
	`JSON
(
bšdšgT»e
)

20 
ab¡¿ù
 
şass
 
B¬eSubsy¡emModuËImp
[+
L
 <: 
B¬eSubsy¡em
](
_ou‹r
: Lè
ex‹nds
 
	$LazyModuËImp
(
_ou‹r
) {

21 
v®
 
ou‹r
 = 
_ou‹r


22 
EÏbÜ©iÚA¹eçùs
.
	`add
("g¿phml", 
ou‹r
.
g¿phML
)

23 
EÏbÜ©iÚA¹eçùs
.
	`add
("dts", 
ou‹r
.
dts
)

24 
EÏbÜ©iÚA¹eçùs
.
	`add
("jsÚ", 
ou‹r
.
jsÚ
)

25 
EÏbÜ©iÚA¹eçùs
.
	`add
("¶usArgs", 
PlusArgA¹eçùs
.
£rŸlize_cH—d”
)

26 
	`´šn
(
ou‹r
.
dts
)

27 
	}
}

30 
ab¡¿ù
 cÏs 
	cBa£Subsy¡em
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
B¬eSubsy¡em
 {

31 
ov”ride
 
v®
 
moduË
: 
Ba£Subsy¡emModuËImp
[
Ba£Subsy¡em
]

35 
v®
 
ibus
 = 
Ãw
 
	$IÁ”ru±BusW¿µ”
()

36 
v®
 
sbus
 = 
	`LazyModuË
(
	$p
(
BudSy¡emBus
)(
p
))

37 
v®
 
pbus
 = 
	`LazyModuË
(
Ãw
 
	`P”h”yBus
(
	$p
(
P”h”yBusKey
)))

38 
v®
 
fbus
 = 
	`LazyModuË
(
Ãw
 
	`FrÚtBus
(
	$p
(
FrÚtBusKey
)))

41 
pbus
.
üossFromCÚŒŞBus
 { 
sbus
.
cÚŒŞ_bus
.
	`toSÏveBus
("pbus") }

44 
FlR’d”šg
 { 
im¶ic™
 
p
 =>

45 
fbus
.
üossToSy¡emBus
 { 
sbus
.
	`äomMa¡”Bus
("fbus") }

46 
	}
}

49 
´iv©e
 
v®
 
mbusP¬ams
 = 
	$p
(
MemÜyBusKey
)

50 
´iv©e
 
v®
 
l2P¬ams
 = 
	$p
(
BªkedL2Key
)

51 
v®
 
	`MemÜyBusP¬ams
(
memBusB—tBy‹s
, 
memBusBlockBy‹s
, 
_
, _èğ
mbusP¬ams


52 
v®
 
	`BªkedL2P¬ams
(
nBªks
, 
coh”’ûMªag”
èğ
l2P¬ams


53 
v®
 
ÿcheBlockBy‹s
 = 
memBusBlockBy‹s


56 
´iv©e
 
	`v®
 (
š
, 
out
, 
h®t
èğ
	$coh”’ûMªag”
(
this
)

57 
def
 
memBusCªCau£H®t
: (è=> 
O±iÚ
[
BoŞ
] = 
h®t


59 
	`»quœe
 (
	`isPow2
(
nBªks
) ||‚Banks == 0)

60 
	`»quœe
 (
	$isPow2
(
memBusBlockBy‹s
))

62 
v®
 
mbus
 = 
	`LazyModuË
(
Ãw
 
	$MemÜyBus
(
mbusP¬ams
))

63 ià(
nBªks
 != 0) {

64 
sbus
.
	`cou¶eTo
("mbus"è{ 
š
 :*ğ
_
 }

65 
mbus
.
	`cou¶eFrom
(
s
"coh”’û_mªag”"è{ 
_
 :=* 
	`BªkBšd”
(
ÿcheBlockBy‹s
 * (
nBªks
-1)è:*ğ
out
 }

66 
	}
}

68 
Ïzy
 
v®
 
tİMªag”s
 = 
	$Mªag”UnifiÿtiÚ
(
sbus
.
busV›w
.
mªag”
.
mªag”s
)

69 
ResourûBšdšg
 {

70 
v®
 
mªag”s
 = 
tİMªag”s


71 
v®
 
max
 = 
mªag”s
.
	`æ©M­
(
_
.
add»ss
).
	`m­
(_.max).max

72 
v®
 
width
 = 
	`ResourûIÁ
((
	`log2Ce
(
max
)+31) / 32)

73 
v®
 
mod–
 = 
	`p
(
DTSMod–
)

74 
v®
 
com·t
 = 
	`p
(
DTSCom·t
)

75 
v®
 
devCom·t
 = (
mod–
 +: 
com·t
).
	`m­
(
s
 => 
	`ResourûSŒšg
(s + "-dev"))

76 
v®
 
socCom·t
 = (
mod–
 +: 
com·t
).
	`m­
(
s
 => 
	`ResourûSŒšg
(s + "-soc"))

77 
devCom·t
.
fÜ—ch
 { 
	`Resourû
(
ResourûAnchÜs
.
roÙ
, "com·t").
	`bšd
(
_
) }

78 
socCom·t
.
fÜ—ch
 { 
	`Resourû
(
ResourûAnchÜs
.
soc
, "com·t").
	`bšd
(
_
) }

79 
	`Resourû
(
ResourûAnchÜs
.
roÙ
, "mod–").
	`bšd
(
	`ResourûSŒšg
(
mod–
))

80 
	`Resourû
(
ResourûAnchÜs
.
roÙ
, "width").
	`bšd
(
width
)

81 
	`Resourû
(
ResourûAnchÜs
.
soc
, "width").
	`bšd
(
width
)

82 
	`Resourû
(
ResourûAnchÜs
.
ıus
, "width").
	`bšd
(
	`ResourûIÁ
(1))

84 
mªag”s
.
fÜ—ch
 { 
mªag”
 =>

85 
v®
 
v®ue
 = 
mªag”
.
toResourû


86 
mªag”
.
»sourûs
.
fÜ—ch
 { 
»sourû
 =>

87 
»sourû
.
	`bšd
(
v®ue
)

90 
	}
}

94 
ab¡¿ù
 
şass
 
	gBa£Subsy¡emModuËImp
[+
L
 <: 
Ba£Subsy¡em
](
_ou‹r
: Lè
ex‹nds
 
	$B¬eSubsy¡emModuËImp
(
_ou‹r
) {

95 
´iv©e
 
v®
 
m­pšg
: 
Seq
[
Add»ssM­EÁry
] = 
AÂÙ©ed
.
	`add»ssM­pšg
(
this
, {

96 
ou‹r
.
cŞËùResourûAdd»s£s
.
	`groupBy
(
_
.
_2
).
toLi¡
.
æ©M­
 { (
key
, 
£q
) =>

97 
Add»ssRªge
.
	`äomS‘s
(
key
.
add»ss
).
m­
 { 
r
 => 
	`Add»ssM­EÁry
Ô, key.
³rmissiÚs
, 
£q
.
	`m­
(
_
.
_1
)) }

98 }.
	`sÜtBy
(
_
.
¿nge
)

101 
AÂÙ©ed
.
	`add»ssM­pšg
(
this
, 
m­pšg
)

103 
	`´šn
("Generated Address Map")

104 
m­pšg
.
	`m­
(
’Œy
 => 
	`´šn
ÓÁry.
	`toSŒšg
((
ou‹r
.
sbus
.
busV›w
.
bundË
.
add»ssB™s
-1)/4 + 1)))

105 
	`´šn
("")

107 
EÏbÜ©iÚA¹eçùs
.
	`add
("memm­.jsÚ", 
s
"""{"
m­pšg
":[${mapping.map(_.toJSON).mkString(",")}]}""")

110 
´iv©e
 
v®
 
dtsRªges
 = 
Add»ssRªge
.
	`unify
(
m­pšg
.
	`m­
(
_
.
¿nge
))

111 
´iv©e
 
v®
 
®lRªges
 = 
Add»ssRªge
.
	`unify
(
ou‹r
.
tİMªag”s
.
æ©M­
 { 
m
 => Add»ssRªge.
	`äomS‘s
(m.
add»ss
) })

113 ià(
dtsRªges
 !ğ
®lRªges
) {

114 
	`´šn
("Address map described by DTS differs from…hysical implementation:")

115 
Add»ssRªge
.
	`subŒaù
(
®lRªges
, 
dtsRªges
).
fÜ—ch
 { 
r
 =>

116 
	`´šn
(
s
"\texists, but undescribed by DTS: ${r}")

118 
Add»ssRªge
.
	`subŒaù
(
dtsRªges
, 
®lRªges
).
fÜ—ch
 { 
r
 =>

119 
	`´šn
(
s
"\tdoes‚otƒxist, but described by DTS: ${r}")

121 
	`´šn
("")

123 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Configs.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


16 
şass
 
Ba£Subsy¡emCÚfig
 
ex‹nds
 
CÚfig
 ((
s™e
, 
h”e
, 
up
) => {

18 
PgLev–s
 => ià(
s™e
(
XL’
) == 64) 3 2

19 
XL’
 => 64

20 
MaxH¬tIdB™s
 => 
log2Up
(
s™e
(
Rock‘TesKey
).
size
)

22 
Sy¡emBusKey
 => 
Sy¡emBusP¬ams
(
b—tBy‹s
 = 
s™e
(
XL’
)/8, 
blockBy‹s
 = s™e(
CacheBlockBy‹s
))

23 
P”h”yBusKey
 => 
P”h”yBusP¬ams
(

24 
b—tBy‹s
 = 
s™e
(
XL’
)/8,

25 
blockBy‹s
 = 
s™e
(
CacheBlockBy‹s
),

26 
”rÜDeviû
 = 
Some
(
DevNuÎP¬ams
(
Li¡
(
Add»ssS‘
(0x3000, 0xfff)), 
maxAtomic
=
s™e
(
XL’
)/8, 
maxT¿nsãr
=4096)))

27 
MemÜyBusKey
 => 
MemÜyBusP¬ams
(
b—tBy‹s
 = 
s™e
(
XL’
)/8, 
blockBy‹s
 = s™e(
CacheBlockBy‹s
))

28 
FrÚtBusKey
 => 
FrÚtBusP¬ams
(
b—tBy‹s
 = 
s™e
(
XL’
)/8, 
blockBy‹s
 = s™e(
CacheBlockBy‹s
))

30 
BoÙROMP¬ams
 => BoÙROMP¬ams(
cÚ‹ÁFeName
 = "./bootrom/bootrom.img")

31 
DebugModuËP¬ams
 => 
DeçuÉDebugModuËP¬ams
(
s™e
(
XL’
))

32 
CLINTKey
 => 
Some
(
CLINTP¬ams
())

33 
PLICKey
 => 
Some
(
PLICP¬ams
())

38 
şass
 
	$W™hNBigCÜes
(
n
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

39 
Rock‘TesKey
 => {

40 
v®
 
big
 = 
	`Rock‘TeP¬ams
(

41 
cÜe
 = 
	`Rock‘CÜeP¬ams
(
mulDiv
 = 
	`Some
(
	`MulDivP¬ams
(

42 
mulUÄŞl
 = 8,

43 
mulE¬lyOut
 = 
Œue
,

44 
divE¬lyOut
 = 
Œue
))),

45 
dÿche
 = 
	`Some
(
	`DCacheP¬ams
(

46 
rowB™s
 = 
	`s™e
(
Sy¡emBusKey
).
b—tB™s
,

47 
nMSHRs
 = 0,

48 
blockBy‹s
 = 
	`s™e
(
CacheBlockBy‹s
))),

49 
iÿche
 = 
	`Some
(
	`ICacheP¬ams
(

50 
rowB™s
 = 
	`s™e
(
Sy¡emBusKey
).
b—tB™s
,

51 
blockBy‹s
 = 
	`s™e
(
CacheBlockBy‹s
))))

52 
Li¡
.
	`buÏ‹
(
n
)(
i
 => 
big
.
	`cİy
(
h¬tId
 = i))

54 
	}
})

56 
şass
 
	$W™hNSm®lCÜes
(
n
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

57 
Rock‘TesKey
 => {

58 
v®
 
sm®l
 = 
	`Rock‘TeP¬ams
(

59 
cÜe
 = 
	`Rock‘CÜeP¬ams
(
u£VM
 = 
çl£
, 
åu
 = 
NÚe
),

60 
btb
 = 
NÚe
,

61 
dÿche
 = 
	`Some
(
	`DCacheP¬ams
(

62 
rowB™s
 = 
	`s™e
(
Sy¡emBusKey
).
b—tB™s
,

63 
nS‘s
 = 64,

64 
nWays
 = 1,

65 
nTLBEÁr›s
 = 4,

66 
nMSHRs
 = 0,

67 
blockBy‹s
 = 
	`s™e
(
CacheBlockBy‹s
))),

68 
iÿche
 = 
	`Some
(
	`ICacheP¬ams
(

69 
rowB™s
 = 
	`s™e
(
Sy¡emBusKey
).
b—tB™s
,

70 
nS‘s
 = 64,

71 
nWays
 = 1,

72 
nTLBEÁr›s
 = 4,

73 
blockBy‹s
 = 
	`s™e
(
CacheBlockBy‹s
))))

74 
Li¡
.
	`buÏ‹
(
n
)(
i
 => 
sm®l
.
	`cİy
(
h¬tId
 = i))

76 
	}
})

78 
şass
 
W™h1TšyCÜe
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

79 
XL’
 => 32

80 
Rock‘TesKey
 => 
Li¡
(
Rock‘TeP¬ams
(

81 
cÜe
 = 
Rock‘CÜeP¬ams
(

82 
u£VM
 = 
çl£
,

83 
åu
 = 
NÚe
,

84 
mulDiv
 = 
Some
(
MulDivP¬ams
(
mulUÄŞl
 = 8))),

85 
btb
 = 
NÚe
,

86 
dÿche
 = 
Some
(
DCacheP¬ams
(

87 
rowB™s
 = 
s™e
(
Sy¡emBusKey
).
b—tB™s
,

88 
nS‘s
 = 256,

89 
nWays
 = 1,

90 
nTLBEÁr›s
 = 4,

91 
nMSHRs
 = 0,

92 
blockBy‹s
 = 
s™e
(
CacheBlockBy‹s
),

93 
sü©ch
 = 
Some
(0x80000000L))),

94 
iÿche
 = 
Some
(
ICacheP¬ams
(

95 
rowB™s
 = 
s™e
(
Sy¡emBusKey
).
b—tB™s
,

96 
nS‘s
 = 64,

97 
nWays
 = 1,

98 
nTLBEÁr›s
 = 4,

99 
blockBy‹s
 = 
s™e
(
CacheBlockBy‹s
)))))

100 
Rock‘CrossšgKey
 => 
Li¡
(
Rock‘CrossšgP¬ams
(

101 
üossšgTy³
 = 
SynchrÚousCrossšg
(),

102 
ma¡”
 = 
TeMa¡”PÜtP¬ams
()

106 
şass
 
	$W™hNBªks
(
n
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

107 
BªkedL2Key
 => 
	`up
(BªkedL2Key, 
s™e
).
	`cİy
(
nBªks
 = 
n
)

108 
	}
})

110 
şass
 
	$W™hNT¿ck”sP”Bªk
(
n
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

111 
Brßdÿ¡Key
 => 
	`up
(Brßdÿ¡Key, 
s™e
).
	`cİy
(
nT¿ck”s
 = 
n
)

112 
	}
})

115 
şass
 
	$W™hL1ICacheS‘s
(
£ts
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

116 
Rock‘TesKey
 => 
	`up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

117 
r
.
	`cİy
(
iÿche
 =„.iÿche.
	`m­
(
_
.cİy(
nS‘s
 = 
£ts
))) }

118 
	}
})

121 
şass
 
	$W™hL1DCacheS‘s
(
£ts
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

122 
Rock‘TesKey
 => 
	`up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

123 
r
.
	`cİy
(
dÿche
 =„.dÿche.
	`m­
(
_
.cİy(
nS‘s
 = 
£ts
))) }

124 
	}
})

126 
şass
 
	$W™hL1ICacheWays
(
ways
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

127 
Rock‘TesKey
 => 
	`up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

128 
r
.
	`cİy
(
iÿche
 =„.iÿche.
	`m­
(
_
.cİy(
nWays
 = 
ways
)))

130 
	}
})

132 
şass
 
	$W™hL1DCacheWays
(
ways
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

133 
Rock‘TesKey
 => 
	`up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

134 
r
.
	`cİy
(
dÿche
 =„.dÿche.
	`m­
(
_
.cİy(
nWays
 = 
ways
)))

136 
	}
})

138 
şass
 
	$W™hCacheBlockBy‹s
(
lšesize
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

139 
CacheBlockBy‹s
 => 
lšesize


140 
	}
})

142 
şass
 
W™hBufã¾essBrßdÿ¡Hub
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

143 
Brßdÿ¡Key
 => 
up
(Brßdÿ¡Key, 
s™e
).
cİy
(
bufã¾ess
 = 
Œue
)

158 
şass
 
W™hIncoh”’tTes
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

159 
Rock‘CrossšgKey
 => 
up
(Rock‘CrossšgKey, 
s™e
è
m­
 { 
r
 =>

160 
r
.
cİy
(
ma¡”
 =„.ma¡”.cİy(
cÜk
 = 
Some
(
Œue
)))

162 
BªkedL2Key
 => 
up
(BªkedL2Key, 
s™e
).
cİy
(
coh”’ûMªag”
 = { 
subsy¡em
 =>

163 
v®
 
ww
 = 
LazyModuË
(
Ãw
 
TLWidthWidg‘
(
subsy¡em
.
sbus
.
b—tBy‹s
)(subsy¡em.
p
))

164 (
ww
.
node
, ww.node, (è=> 
NÚe
)

168 
şass
 
W™hRV32
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

169 
XL’
 => 32

170 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

171 
r
.
cİy
(
cÜe
 =„.core.copy(

172 
åu
 = 
r
.
cÜe
.åu.
m­
(
_
.
cİy
(
fL’
 = 32)),

173 
mulDiv
 = 
Some
(
MulDivP¬ams
(
mulUÄŞl
 = 8))))

177 
şass
 
	$W™hNÚblockšgL1
(
nMSHRs
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

178 
Rock‘TesKey
 => 
	`up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

179 
r
.
	`cİy
(
dÿche
 =„.dÿche.
	`m­
(
_
.cİy(
nMSHRs
 =‚MSHRs)))

181 
	}
})

183 
şass
 
	$W™hNB»akpošts
(
hwbp
: 
IÁ
è
ex‹nds
 
	`CÚfig
 ((
s™e
, 
h”e
, 
up
) => {

184 
Rock‘TesKey
 => 
	`up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

185 
r
.
	`cİy
(
cÜe
 =„.cÜe.cİy(
nB»akpošts
 = 
hwbp
))

187 
	}
})

189 
şass
 
W™hRoccExam¶e
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

190 
BudRoCC
 => 
Li¡
(

191 (
p
: 
P¬am‘”s
) => {

192 
v®
 
accumuÏtÜ
 = 
LazyModuË
(
Ãw
 
AccumuÏtÜExam¶e
(
OpcodeS‘
.
cu¡om0
, 
n
 = 4)(
p
))

193 
accumuÏtÜ


195 (
p
: 
P¬am‘”s
) => {

196 
v®
 
Œª¦©Ü
 = 
LazyModuË
(
Ãw
 
T¿n¦©ÜExam¶e
(
OpcodeS‘
.
cu¡om1
)(
p
))

197 
Œª¦©Ü


199 (
p
: 
P¬am‘”s
) => {

200 
v®
 
couÁ”
 = 
LazyModuË
(
Ãw
 
Ch¬aù”CouÁExam¶e
(
OpcodeS‘
.
cu¡om2
)(
p
))

201 
couÁ”


205 
şass
 
W™hDeçuÉBtb
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

206 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

207 
r
.
cİy
(
btb
 = 
Some
(
BTBP¬ams
()))

211 
şass
 
W™hFa¡MulDiv
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

212 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

213 
r
.
cİy
(
cÜe
 =„.cÜe.cİy(
mulDiv
 = 
Some
(

214 
MulDivP¬ams
(
mulUÄŞl
 = 8, 
mulE¬lyOut
 = (
s™e
(
XL’
è> 32), 
divE¬lyOut
 = 
Œue
)

218 
şass
 
W™houtMulDiv
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

219 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

220 
r
.
cİy
(
cÜe
 =„.cÜe.cİy(
mulDiv
 = 
NÚe
))

224 
şass
 
W™houtFPU
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

225 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

226 
r
.
cİy
(
cÜe
 =„.cÜe.cİy(
åu
 = 
NÚe
))

230 
şass
 
W™hFPUW™houtDivSq¹
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

231 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

232 
r
.
cİy
(
cÜe
 =„.cÜe.cİy(
åu
 =„.cÜe.åu.
m­
(
_
.cİy(
divSq¹
 = 
çl£
))))

236 
şass
 
	$W™hBoÙROMFe
(
boÙROMFe
: 
SŒšg
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

237 
BoÙROMP¬ams
 => 
	`up
(BoÙROMP¬ams, 
s™e
).
	`cİy
(
cÚ‹ÁFeName
 = 
boÙROMFe
)

238 
	}
})

240 
şass
 
W™hSynchrÚousRock‘Tes
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

241 
Rock‘CrossšgKey
 => 
up
(Rock‘CrossšgKey, 
s™e
è
m­
 { 
r
 =>

242 
r
.
cİy
(
üossšgTy³
 = 
SynchrÚousCrossšg
())

246 
şass
 
	$W™hAsynchrÚousRock‘Tes
(
d•th
: 
IÁ
, 
sync
: IÁè
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

247 
Rock‘CrossšgKey
 => 
	`up
(Rock‘CrossšgKey, 
s™e
è
m­
 { 
r
 =>

248 
r
.
	`cİy
(
üossšgTy³
 = 
	`AsynchrÚousCrossšg
(
d•th
, 
sync
))

250 
	}
})

252 
şass
 
W™hR©iÚ®Rock‘Tes
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

253 
Rock‘CrossšgKey
 => 
up
(Rock‘CrossšgKey, 
s™e
è
m­
 { 
r
 =>

254 
r
.
cİy
(
üossšgTy³
 = 
R©iÚ®Crossšg
())

258 
şass
 
	$W™hEdgeD©aB™s
(
d©aB™s
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

259 
MemÜyBusKey
 => 
	`up
(MemÜyBusKey, 
s™e
).
	`cİy
(
b—tBy‹s
 = 
d©aB™s
/8)

260 
ExtIn
 => 
	`up
(ExtIn, 
s™e
).
	`m­
(
_
.
	`cİy
(
b—tBy‹s
 = 
d©aB™s
/8))

262 
	}
})

264 
şass
 
W™hJgDTM
 
ex‹nds
 
CÚfig
 ((
s™e
, 
h”e
, 
up
) => {

265 
InşudeJgDTM
 => 
Œue


268 
şass
 
W™hDebugSBA
 
ex‹nds
 
CÚfig
 ((
s™e
, 
h”e
, 
up
) => {

269 
DebugModuËP¬ams
 => 
up
(DebugModuËP¬ams).
cİy
(
hasBusMa¡”
 = 
Œue
)

272 
şass
 
	$W™hNB™P”h”yBus
(
nB™s
: 
IÁ
è
ex‹nds
 
	`CÚfig
 ((
s™e
, 
h”e
, 
up
) => {

273 
P”h”yBusKey
 => 
	`up
(P”h”yBusKey, 
s™e
).
	`cİy
(
b—tBy‹s
 = 
nB™s
/8)

274 
	}
})

276 
şass
 
W™houtTLMÚ™Üs
 
ex‹nds
 
CÚfig
 ((
s™e
, 
h”e
, 
up
) => {

277 
MÚ™ÜsEÇbËd
 => 
çl£


280 
şass
 
	$W™hNExtTİIÁ”ru±s
(
nExtIÁs
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

281 
NExtTİIÁ”ru±s
 => 
nExtIÁs


282 
	}
})

284 
şass
 
	$W™hNMemÜyChªÃls
(
n
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

285 
ExtMem
 => 
	`up
(ExtMem, 
s™e
).
	`m­
(
_
.
	`cİy
(
nMemÜyChªÃls
 = 
n
))

286 
	}
})

288 
şass
 
	$W™hExtMemSize
(
n
: 
LÚg
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

289 
ExtMem
 => 
	`up
(ExtMem, 
s™e
).
	`m­
(
x
 => x.
	`cİy
(
ma¡”
 = x.ma¡”.cİy(
size
 = 
n
)))

290 
	}
})

292 
şass
 
	$W™hDTS
(
mod–
: 
SŒšg
, 
com·t
: 
Seq
[SŒšg]è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

293 
DTSMod–
 => 
mod–


294 
DTSCom·t
 => 
com·t


295 
	}
})

297 
şass
 
	$W™hTimeba£
(
h”tz
: 
BigIÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

298 
DTSTimeba£
 => 
h”tz


299 
	}
})

301 
şass
 
W™hDeçuÉMemPÜt
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

302 
ExtMem
 => 
Some
(
MemÜyPÜtP¬ams
(
Ma¡”PÜtP¬ams
(

303 
ba£
 = 
x
"8000_0000",

304 
size
 = 
x
"1000_0000",

305 
b—tBy‹s
 = 
s™e
(
MemÜyBusKey
).beatBytes,

306 
idB™s
 = 4), 1))

309 
şass
 
W™hNoMemPÜt
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

310 
ExtMem
 => 
NÚe


313 
şass
 
W™hDeçuÉMMIOPÜt
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

314 
ExtBus
 => 
Some
(
Ma¡”PÜtP¬ams
(

315 
ba£
 = 
x
"6000_0000",

316 
size
 = 
x
"2000_0000",

317 
b—tBy‹s
 = 
s™e
(
MemÜyBusKey
).beatBytes,

318 
idB™s
 = 4))

321 
şass
 
W™hNoMMIOPÜt
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

322 
ExtBus
 => 
NÚe


325 
şass
 
W™hDeçuÉSÏvePÜt
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

326 
ExtIn
 => 
Some
(
SÏvePÜtP¬ams
(
b—tBy‹s
 = 8, 
idB™s
 = 8, 
sourûB™s
 = 4))

329 
şass
 
W™hNoSÏvePÜt
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

330 
ExtIn
 => 
NÚe


333 
şass
 
W™hSü©ch·dsOÆy
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

334 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

335 
r
.
cİy
(

336 
cÜe
 = 
r
.cÜe.
cİy
(
u£VM
 = 
çl£
),

337 
dÿche
 = 
r
.dÿche.
m­
(
_
.
cİy
(

338 
nS‘s
 = 256,

339 
nWays
 = 1,

340 
sü©ch
 = 
Some
(0x80000000L))))

344 
şass
 
W™hPrivCodeLock1
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

345 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

346 
r
.
cİy
(

347 
cÜe
 = 
r
.cÜe.
cİy
(

348 
hasPrivCodeLock
 = 
Œue
,

349 
numPCodeRªges
 = 1

355 
şass
 
W™hPrivCodeLock
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

356 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

357 
r
.
cİy
(

358 
cÜe
 = 
r
.cÜe.
cİy
(

359 
hasPrivCodeLock
 = 
Œue
,

360 
numPCodeRªges
 = 4

366 
şass
 
W™hPrivCodeLock3
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

367 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

368 
r
.
cİy
(

369 
cÜe
 = 
r
.cÜe.
cİy
(

370 
hasPrivCodeLock
 = 
Œue
,

371 
numPCodeRªges
 = 3

377 
şass
 
W™hPrivCodeLock2
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

378 
Rock‘TesKey
 => 
up
(Rock‘TesKey, 
s™e
è
m­
 { 
r
 =>

379 
r
.
cİy
(

380 
cÜe
 = 
r
.cÜe.
cİy
(

381 
hasPrivCodeLock
 = 
Œue
,

382 
numPCodeRªges
 = 4

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/CrossingWrapper.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	gaxi4
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
	g_


12 @
d•»ÿ‹d
("Only usehisrait if you‡re confident you island will onlyƒver be crossedo‡ single clock", "rocket-chip 1.3")

13 
Œa™
 
HasCrossšg
 
ex‹nds
 
	gCros£sToOÆyOÃClockDomaš
 { 
	gthis
: 
LazyModuË
 => }

20 
Œa™
 
Cros£sToOÆyOÃClockDomaš
 
ex‹nds
 
HasClockDomašCrossšg
 { 
this
: 
LazyModuË
 =>

22 
def
 
üossšg
: 
ClockCrossšgTy³


24 
def
 
üossTLIn
(
n
: 
TLInw¬dNode
)(
im¶ic™
 
p
: 
P¬am‘”s
): TLInwardNode = {

25 
v®
 
InXšg
 = 
this
.
üossIn
(
n
)

26 
InXšg
(
üossšg
)

29 
def
 
üossTLOut
(
n
: 
TLOutw¬dNode
)(
im¶ic™
 
p
: 
P¬am‘”s
): TLOutwardNode = {

30 
v®
 
OutXšg
 = 
this
.
üossOut
(
n
)

31 
OutXšg
(
üossšg
)

34 
def
 
üossAXI4In
(
n
: 
AXI4Inw¬dNode
)(
im¶ic™
 
p
: 
P¬am‘”s
): AXI4InwardNode = {

35 
v®
 
axi4InXšg
 = 
this
.
üossIn
(
n
)

36 
axi4InXšg
(
üossšg
)

39 
def
 
üossAXI4Out
(
n
: 
AXI4Outw¬dNode
)(
im¶ic™
 
p
: 
P¬am‘”s
): AXI4OutwardNode = {

40 
v®
 
axi4OutXšg
 = 
this
.
üossOut
(
n
)

41 
axi4OutXšg
(
üossšg
)

44 
def
 
üossIÁIn
(
n
: 
IÁInw¬dNode
)(
im¶ic™
 
p
: 
P¬am‘”s
): IntInwardNode = {

45 
v®
 
štInXšg
 = 
this
.
üossIn
(
n
)

46 
štInXšg
(
üossšg
)

49 
def
 
üossIÁOut
(
n
: 
IÁOutw¬dNode
)(
im¶ic™
 
p
: 
P¬am‘”s
): IntOutwardNode = {

50 
v®
 
štOutXšg
 = 
this
.
üossOut
(
n
)

51 
štOutXšg
(
üossšg
)

56 
şass
 
	$CrossšgW¿µ”
(
v®
 
üossšg
: 
ClockCrossšgTy³
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
Sim¶eLazyModuË
 
w™h
 
Cros£sToOÆyOÃClockDomaš


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/FrontBus.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
şass
 
FrÚtBusP¬ams
(

12 
b—tBy‹s
: 
IÁ
,

13 
blockBy‹s
: 
IÁ
,

14 
sbusCrossšg
: 
ClockCrossšgTy³
 = 
SynchrÚousCrossšg
(),

15 
sbusBufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
è
ex‹nds
 
HasTLBusP¬ams


17 
objeù
 
FrÚtBusKey
 
ex‹nds
 
F›ld
[
FrÚtBusP¬ams
]

19 
şass
 
	$FrÚtBus
(
·¿ms
: 
FrÚtBusP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
)

20 
ex‹nds
 
	`TLBusW¿µ”
(
·¿ms
, "front_bus")

21 
w™h
 
HasClockDomašCrossšg


22 
w™h
 
CªA‰achTLMa¡”s


23 
w™h
 
HasTLXb¬Phy
 {

25 
def
 
	`äomCoh”’tCh
(
g’
: => 
TLNode
): 
TLInw¬dNode
 = {

26 
	`äom
("coh”’t_subsy¡em"è{ 
šw¬dNode
 :=* 
g’
 }

29 
def
 
	`üossToSy¡emBus
(
g’
: (=> 
TLOutw¬dNode
è=> 
NoHªdË
) {

30 
	`to
("sbus") {

31 
v®
 
_xšg
 = 
this
.
	`üossOut
(
	`TLBufãr
(
·¿ms
.
sbusBufãr
è:=* 
outw¬dNode
)

32 
	`g’
(
	`_xšg
(
·¿ms
.
sbusCrossšg
))

35 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/HasTiles.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
dÚtTouch


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.
TLDebugModuË


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.{
	gBasicBusBlock”
, 
	gBasicBusBlock”P¬ams
, 
	gCLINT
, 
	gCLINTCÚ¡s
, 
	gTLPLIC
, 
	gPLICKey
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.{
	gBa£Te
, 
	gLookupByH¬tId
, 
	gLookupByH¬tIdIm¶
, 
	gTeKey
, 
	gTeP¬ams
, 
	gSh¬edMemÜyTLEdge
, 
	gHasEx‹º®lyDriv’TeCÚ¡ªts
}

13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


16 şas 
	cClockedTeIÅuts
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
P¬am‘”izedBundË


17 
w™h
 
HasEx‹º®lyDriv’TeCÚ¡ªts


18 
w™h
 
Clocked


20 
Œa™
 
HasTes
 { 
this
: 
Ba£Subsy¡em
 =>

21 
im¶ic™
 
v®
 
p
: 
P¬am‘”s


22 
v®
 
tes
: 
Seq
[
Ba£Te
]

23 
´Ùeùed
 
def
 
teP¬ams
: 
Seq
[
TeP¬ams
] = 
tes
.
	$m­
(
_
.
teP¬ams
)

24 
def
 
nTes
: 
IÁ
 = 
teP¬ams
.
size


25 
def
 
h¬tIdLi¡
: 
Seq
[
IÁ
] = 
teP¬ams
.
	$m­
(
_
.
h¬tId
)

26 
def
 
loÿlIÁCouÁs
: 
Seq
[
IÁ
] = 
teP¬ams
.
	$m­
(
_
.
cÜe
.
nLoÿlIÁ”ru±s
)

27 
def
 
sh¬edMemÜyTLEdge
 = 
sbus
.
busV›w


28 
v®
 
meNode
 = 
	$p
(
PLICKey
è
m©ch
 {

29 
	`Some
(
_
è=> 
NÚe


30 
NÚe
 => 
	`Some
(
	`IÁSourûNode
(
	`IÁSourûPÜtSim¶e
(
num
 = 1, 
pÜts
 = 1, 
sourûs
 = 1)))

33 
´iv©e
 
v®
 
lookupByH¬tId
 = 
Ãw
 
LookupByH¬tIdIm¶
 {

34 
def
 
­¶y
[
T
 <: 
D©a
](
f
: 
TeP¬ams
 => 
O±iÚ
[T], 
h¬tId
: 
UIÁ
): T =

35 
	`PriÜ™yMux
(
teP¬ams
.
cŞËù
 { 
t
 
	`f
Ñ).
isDefšed
 => (t.
h¬tId
.
U
 ==ğh¬tIdè-> fÑ).
g‘
 })

36 
	}
}

38 
´Ùeùed
 
def
 
	$augm’‹dTeP¬am‘”s
(

: 
TeP¬ams
): 
P¬am‘”s
 = 
p
.
®‹rP¬tŸl
 {

41 
TeKey
 => 



42 
Sh¬edMemÜyTLEdge
 => 
sh¬edMemÜyTLEdge


43 
LookupByH¬tId
 => 
lookupByH¬tId


44 
	}
}

46 
´Ùeùed
 
def
 
	$cÚÃùMa¡”PÜtsToSBus
(
te
: 
Ba£Te
, 
üossšg
: 
Rock‘CrossšgP¬ams
) {

47 
sbus
.
	`äomTe
(
te
.
teP¬ams
.
Çme
, 
üossšg
.
ma¡”
.
bufãrs
) {

48 
üossšg
.
ma¡”
.
cÜk


49 .
m­
 { 
u
 => 
	`TLCacheCÜk
(
un§ã
 = u) }

50 .
m­
 { 
_
 :=* 
te
.
	`üossMa¡”PÜt
() }

51 .
g‘OrEl£
 { 
te
.
	`üossMa¡”PÜt
() }

53 
	}
}

55 
´Ùeùed
 
def
 
	$cÚÃùSÏvePÜtsToCBus
(
te
: 
Ba£Te
, 
üossšg
: 
Rock‘CrossšgP¬ams
)(
im¶ic™
 
v®Name
: 
V®Name
) {

57 
Di§bËMÚ™Üs
 { 
im¶ic™
 
p
 =>

58 
sbus
.
cÚŒŞ_bus
.
	`toTe
(
te
.
teP¬ams
.
Çme
) {

59 
üossšg
.
¦ave
.
block”CŒlAddr


60 .
m­
 { 
	`BasicBusBlock”P¬ams
(
_
, 
pbus
.
b—tBy‹s
, 
sbus
.beatBytes) }

61 .
m­
 { 
bbbp
 => 
	`LazyModuË
(
Ãw
 
	`BasicBusBlock”
(bbbp)) }

62 .
m­
 { 
bbb
 =>

63 
sbus
.
cÚŒŞ_bus
.
	`toV¬ŸbËWidthSÏve
(
	`Some
("bus_block”")è{ 
bbb
.
cÚŒŞNode
 }

64 
te
.
	`üossSÏvePÜt
(è:*ğ
bbb
.
node


65 } .
g‘OrEl£
 { 
te
.
	`üossSÏvePÜt
() }

68 
	}
}

70 
´Ùeùed
 
def
 
	$cÚÃùIÁ”ru±s
(
te
: 
Ba£Te
, 
debugO±
: 
O±iÚ
[
TLDebugModuË
], 
şštO±
: O±iÚ[
CLINT
], 
¶icO±
: O±iÚ[
TLPLIC
]) {

77 
te
.
štInw¬dNode
 :=

78 
debugO±


79 .
m­
 { 
te
 { 
	`IÁSyncCrossšgSšk
(3è} :ğ
_
.
šŠode
 }

80 .
g‘OrEl£
 { 
	`NuÎIÁSourû
() }

86 
te
.
	`üossIÁIn
() :=

87 
şštO±
.
m­
 { 
_
.
šŠode
 }

88 .
g‘OrEl£
 { 
	`NuÎIÁSourû
(
sourûs
 = 
CLINTCÚ¡s
.
šts
) }

91 
te
.
	`üossIÁIn
() :=

92 
¶icO±
 .
m­
 { 
_
.
šŠode
 }

93 .
g‘OrEl£
 { 
meNode
.
g‘
 }

96 ià(
te
.
teP¬ams
.
cÜe
.
u£VM
) {

97 
te
.
	`üossIÁIn
() :=

98 
¶icO±
 .
m­
 { 
_
.
šŠode
 }

99 .
g‘OrEl£
 { 
	`NuÎIÁSourû
() }

107 
¶icO±
.
fÜ—ch
 { 
¶ic
 =>

108 
FlR’d”šg
 { 
im¶ic™
 
p
 =>

109 
¶ic
.
šŠode
 :=* 
te
.
	`üossIÁOut
()

112 
	}
}

114 
´Ùeùed
 
def
 
³rTeOrGlob®S‘tšg
[
T
](
š
: 
Seq
[T], 
	gn
: 
IÁ
): Seq[T] = in.
size
 
m©ch
 {

115 1 => 
Li¡
.
fl
(
n
)(
š
.
h—d
)

116 
x
 x =ğ
n
 => 
š


117 
_
 => 
throw
 
Ãw
 
Exû±iÚ
("must…rovideƒxactly 1 or #tiles ofhis key")

121 
Œa™
 
HasTesBundË
 {

122 
v®
 
te_šputs
: 
Vec
[
ClockedTeIÅuts
]

125 
Œa™
 
HasTesModuËImp
 
ex‹nds
 
LazyModuËImp


126 
w™h
 
HasTesBundË


127 
w™h
 
HasRe£tVeùÜWœe
 {

128 
v®
 
ou‹r
: 
HasTes


130 
def
 
»£tVeùÜB™s
: 
IÁ
 = {

132 
v®
 
veùÜs
 = 
ou‹r
.
tes
.
m­
(
_
.
moduË
.
cÚ¡ªts
.
»£t_veùÜ
)

133 
»quœe
(
veùÜs
.

.
fÜ®l
(
_
.
g‘Width
 =ğveùÜs.
h—d
.getWidth))

134 
veùÜs
.
h—d
.
g‘Width


137 
v®
 
te_šputs
 = 
dÚtTouch
(
Wœe
(
Vec
(
ou‹r
.
nTes
, 
Ãw
 
ClockedTeIÅuts
()(
p
.
®‹rP¬tŸl
 {

138 
Sh¬edMemÜyTLEdge
 => 
ou‹r
.
sh¬edMemÜyTLEdge


142 
	gou‹r
.
	gtes
.
m­
(
_
.
moduË
).
z
(
te_šputs
).
	gfÜ—ch
 { (
	gte
, 
	gwœe
) =>

143 
te
.
şock
 :ğ
wœe
.clock

144 
te
.
»£t
 :ğ
wœe
.reset

145 
te
.
cÚ¡ªts
.
h¬tid
 :ğ
wœe
.hartid

146 
te
.
cÚ¡ªts
.
»£t_veùÜ
 :ğ
wœe
.reset_vector

149 
v®
 
me
 = if(
ou‹r
.
meNode
.
isDefšed
è
Some
(
IO
(
BoŞ
(
INPUT
))è
NÚe


150 
me
.
fÜ—ch
 { (
ou‹r
.
meNode
.
g‘
.
out
(0).
_1
)(0è:ğ
_
 }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/InterruptBus.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


11 şas 
	cIÁ”ru±BusW¿µ”
(
im¶ic™
 
p
: 
P¬am‘”s
) {

13 
v®
 
št_bus
 = 
	$LazyModuË
(
Ãw
 
IÁXb¬
)

15 
´iv©e
 
def
 
	$synchrÚize
(
sync
: 
IÁ
): 
IÁInw¬dNode
 = {

16 
v®
 
asyncXšg
 = 
	`LazyModuË
(
Ãw
 
	`IÁXšg
(
sync
))

17 
št_bus
.
šŠode
 :ğ
asyncXšg
.intnode

18 
asyncXšg
.
šŠode


21 
def
 
äomAsync
: 
IÁInw¬dNode
 = 
	$synchrÚize
(3)

22 
def
 
äomR©iÚ®
: 
IÁInw¬dNode
 = 
	$synchrÚize
(1)

23 
def
 
äomSync
: 
IÁInw¬dNode
 = 
št_bus
.
šŠode


24 
def
 
toPLIC
: 
IÁOutw¬dNode
 = 
št_bus
.
šŠode


25 
	}
}

28 
objeù
 
NExtTİIÁ”ru±s
 
ex‹nds
 
F›ld
[
IÁ
](0)

34 
ab¡¿ù
 
Œa™
 
HasExtIÁ”ru±s
 { 
this
: 
Ba£Subsy¡em
 =>

35 
´iv©e
 
v®
 
deviû
 = 
Ãw
 
Deviû
 
w™h
 
DeviûIÁ”ru±s
 {

36 
def
 
desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

37 
DesütiÚ
("soc/ex‹º®-š‹¼u±s", 
desüibeIÁ”ru±s
(
»sourûs
))

41 
v®
 
	gnExtIÁ”ru±s
 = 
p
(
NExtTİIÁ”ru±s
)

42 
v®
 
extIÁ”ru±s
 = 
IÁSourûNode
(
IÁSourûPÜtSim¶e
(
num
 = 
nExtIÁ”ru±s
, 
»sourûs
 = 
deviû
.))

48 
Œa™
 
HasAsyncExtIÁ”ru±s
 
ex‹nds
 
	gHasExtIÁ”ru±s
 { 
	gthis
: 
Ba£Subsy¡em
 =>

49 ià(
nExtIÁ”ru±s
 > 0) {

50 
ibus
.
äomAsync
 :ğ
extIÁ”ru±s


57 
Œa™
 
HasSyncExtIÁ”ru±s
 
ex‹nds
 
HasExtIÁ”ru±s
 { 
this
: 
Ba£Subsy¡em
 =>

58 ià(
nExtIÁ”ru±s
 > 0) {

59 
ibus
.
äomSync
 :ğ
extIÁ”ru±s


64 
Œa™
 
HasExtIÁ”ru±sBundË
 {

65 
v®
 
š‹¼u±s
: 
UIÁ


67 
def
 
t›OffIÁ”ru±s
(
dummy
: 
IÁ
 = 1) {

68 
š‹¼u±s
 :ğ
UIÁ
(0)

75 
Œa™
 
HasExtIÁ”ru±sModuËImp
 
ex‹nds
 
LazyModuËImp
 
w™h
 
HasExtIÁ”ru±sBundË
 {

76 
v®
 
ou‹r
: 
HasExtIÁ”ru±s


77 
v®
 
š‹¼u±s
 = 
IO
(
UIÁ
(
INPUT
, 
width
 = 
ou‹r
.
nExtIÁ”ru±s
))

79 
ou‹r
.
extIÁ”ru±s
.
out
.
m­
(
_
.
_1
).
æ©‹n
.
zW™hIndex
.
fÜ—ch
 { (
o
, 
i
è=> o :ğ
š‹¼u±s
(i) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/MemoryBus.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.{
	gDevNuÎP¬ams
, 
	gTLE¼Ü
, 
	gTLZ”o
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


13 
objeù
 
CacheBlockBy‹s
 
ex‹nds
 
	gF›ld
[
IÁ
](64)

16 
şass
 
	$Brßdÿ¡P¬ams
(

17 
nT¿ck”s
: 
IÁ
 = 4,

18 
bufã¾ess
: 
BoŞ—n
 = 
çl£
)

20 
objeù
 
Brßdÿ¡Key
 
ex‹nds
 
	`F›ld
(
	$Brßdÿ¡P¬ams
())

23 
şass
 
	`BªkedL2P¬ams
(

24 
nBªks
: 
IÁ
 = 1,

25 
coh”’ûMªag”
: 
Ba£Subsy¡em
 => (
TLInw¬dNode
, 
TLOutw¬dNode
, (è=> 
O±iÚ
[
BoŞ
]èğ{ 
subsy¡em
 =>

26 
im¶ic™
 
v®
 
p
 = 
subsy¡em
.p

27 
v®
 
	`Brßdÿ¡P¬ams
(
nT¿ck”s
, 
bufã¾ess
èğ
	`p
(
Brßdÿ¡Key
)

28 
v®
 
bh
 = 
	`LazyModuË
(
Ãw
 
	`TLBrßdÿ¡
(
subsy¡em
.
memBusBlockBy‹s
, 
nT¿ck”s
, 
bufã¾ess
))

29 
v®
 
ww
 = 
	`LazyModuË
(
Ãw
 
	`TLWidthWidg‘
(
subsy¡em
.
sbus
.
b—tBy‹s
))

30 
ww
.
node
 :*ğ
bh
.node

31 (
bh
.
node
, 
ww
.node, (è=> 
NÚe
)

32 
	}
}) {

35 
objeù
 
BªkedL2Key
 
ex‹nds
 
F›ld
(
	$BªkedL2P¬ams
())

38 
şass
 
	$MemÜyBusP¬ams
(

39 
b—tBy‹s
: 
IÁ
,

40 
blockBy‹s
: 
IÁ
,

41 
z”oDeviû
: 
O±iÚ
[
Add»ssS‘
] = 
NÚe
,

42 
”rÜDeviû
: 
O±iÚ
[
DevNuÎP¬ams
] = 
NÚe
è
ex‹nds
 
HasTLBusP¬ams


44 
objeù
 
MemÜyBusKey
 
ex‹nds
 
F›ld
[
MemÜyBusP¬ams
]

47 
şass
 
	$MemÜyBus
(
·¿ms
: 
MemÜyBusP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
)

48 
ex‹nds
 
	`TLBusW¿µ”
(
·¿ms
, "memÜy_bus")(
p
)

49 
w™h
 
CªA‰achTLSÏves
 {

51 
´iv©e
 
v®
 
xb¬
 = 
	`LazyModuË
(
Ãw
 
TLXb¬
).
	`sugge¡Name
(
busName
 + "_xbar")

52 
def
 
šw¬dNode
: 
TLInw¬dNode
 = 
xb¬
.
node


53 
def
 
outw¬dNode
: 
TLOutw¬dNode
 = 
	`ProbePick”
(è:*ğ
xb¬
.
node


55 
·¿ms
.
z”oDeviû
.
fÜ—ch
 { 
addr
 => 
	`LazyScİe
("wrapped_zero_device") {

56 
v®
 
z”o
 = 
	`LazyModuË
(
Ãw
 
	`TLZ”o
(

57 
add»ss
 = 
addr
,

58 
b—tBy‹s
 = 
·¿ms
.beatBytes))

59 
z”o
.
node
 :ğ
	`TLF¿gm’‹r
(
·¿ms
.
b—tBy‹s
,…¬ams.
blockBy‹s
è:ğ
	`TLBufãr
(è:ğ
outw¬dNode


62 
·¿ms
.
”rÜDeviû
.
fÜ—ch
 { 
dÅ
 => 
	`LazyScİe
("wrapped_error_device") {

63 
v®
 
”rÜ
 = 
	`LazyModuË
(
Ãw
 
	`TLE¼Ü
(

64 
·¿ms
 = 
dÅ
,

65 
b—tBy‹s
 = 
·¿ms
.beatBytes))

66 
”rÜ
.
node
 :ğ
	`TLBufãr
(è:ğ
outw¬dNode


69 
def
 
toDRAMCÚŒŞËr
[
D
,
U
,
E
,
B
 <: 
D©a
]

70 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
bufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

71 (
g’
: => 
NodeHªdË
[ 
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
, 
D
,
U
,
E
,
B
] =

72 
	`TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

73 
	`to
("memÜy_cÚŒŞËr" 
Çmed
 
Çme
è{ 
g’
 :ğ
	`TLBufãr
(
bufãr
è:ğ
outw¬dNode
 }

75 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/PeripheryBus.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.{
	gDevNuÎP¬ams
, 
	gTLE¼Ü
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
şass
 
	$BusAtomics
(

13 
¬™hm‘ic
: 
BoŞ—n
 = 
Œue
,

14 
bufãr
: 
BufãrP¬ams
 = BufferParams.

17 
şass
 
	`P”h”yBusP¬ams
(

18 
b—tBy‹s
: 
IÁ
,

19 
blockBy‹s
: 
IÁ
,

20 
©omics
: 
O±iÚ
[
BusAtomics
] = 
	`Some
(
	`BusAtomics
()),

21 
sbusCrossšgTy³
: 
ClockCrossšgTy³
 = 
	`SynchrÚousCrossšg
(),

22 
äequ’cy
: 
BigIÁ
 = 
	`BigIÁ
(100000000),

23 
”rÜDeviû
: 
O±iÚ
[
DevNuÎP¬ams
] = 
NÚe


24 è
ex‹nds
 
HasTLBusP¬ams


26 
objeù
 
P”h”yBusKey
 
ex‹nds
 
F›ld
[
P”h”yBusP¬ams
]

28 
şass
 
	$P”h”yBus
(
·¿ms
: 
P”h”yBusP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
)

29 
ex‹nds
 
	`TLBusW¿µ”
(
·¿ms
, "periphery_bus")

30 
w™h
 
HasClockDomašCrossšg


31 
w™h
 
CªA‰achTLSÏves
 {

33 
´iv©e
 
v®
 
š_xb¬
 = 
	`LazyModuË
(
Ãw
 
TLXb¬
)

34 
´iv©e
 
v®
 
out_xb¬
 = 
	`LazyModuË
(
Ãw
 
TLXb¬
)

35 
´iv©e
 
v®
 
©omics
 = 
·¿ms
.©omics.
m­
 { 
·
 =>

36 
	`TLBufãr
(
·
.
bufãr
è:*ğ
	`TLAtomicAutom©a
(
¬™hm‘ic
 =…a.arithmetic)

37 }.
	`g‘OrEl£
(
	`TLNameNode
("no_atomics"))

39 
out_xb¬
.
node
 :*ğ
©omics
 :*ğ
š_xb¬
.node

41 
def
 
šw¬dNode
: 
TLInw¬dNode
 = 
š_xb¬
.
node


42 
def
 
outw¬dNode
: 
TLOutw¬dNode
 = 
out_xb¬
.
node


44 
·¿ms
.
”rÜDeviû
.
fÜ—ch
 { 
dÅ
 => 
	`LazyScİe
("wrapped_error_device") {

45 
v®
 
”rÜ
 = 
	`LazyModuË
(
Ãw
 
	`TLE¼Ü
(
·¿ms
 = 
dÅ
, 
b—tBy‹s
 =…arams.beatBytes))

46 
”rÜ
.
node
 :ğ
outw¬dNode


49 
def
 
	`üossFromSy¡emBus
(
g’
: (=> 
TLInw¬dNode
è=> 
NoHªdË
) {

50 
	`äom
("sbus") {

51 
v®
 
äom_sbus
 = 
this
.
	`üossIn
(
šw¬dNode
)

52 
	`g’
(
	`äom_sbus
(
·¿ms
.
sbusCrossšgTy³
))

56 
def
 
	`üossFromCÚŒŞBus
(
g’
: (=> 
TLInw¬dNode
è=> 
NoHªdË
) {

57 
	`äom
("cbus") {

58 
v®
 
äom_cbus
 = 
this
.
	`üossIn
(
šw¬dNode
)

59 
	`g’
(
	`äom_cbus
(
·¿ms
.
sbusCrossšgTy³
))

63 
def
 
äomOth”Ma¡”
[
D
,
U
,
E
,
B
 <: 
D©a
]

64 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
bufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

65 (
g’
: => 
NodeHªdË
[
D
,
U
,
E
,
B
,
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeOut
,
TLBundË
] =

66 
	`TLNameNode
(
Çme
)): 
Inw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

67 
	`äom
("ma¡”" 
Çmed
 
Çme
) {

68 
šw¬dNode
 :=* 
	`TLBufãr
(
bufãr
è:=* 
g’


72 
def
 
toTe


73 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
bufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

74 (
g’
: => 
TLInw¬dNode
): 
NoHªdË
 = {

75 
	`to
("te" 
Çmed
 
Çme
è{ 
FlR’d”šg
 { 
im¶ic™
 
p
 =>

76 
g’
 :*ğ
	`TLBufãr
(
bufãr
è:*ğ
outw¬dNode


80 
def
 
	`toSÏveBus
(
Çme
: 
SŒšg
): (=> 
TLInw¬dNode
è=> 
NoHªdË
 =

81 
g’
 => 
	`to
(
s
"bus_named_$name") {

82 (
g’


83 :*ğ
	`TLWidthWidg‘
(
·¿ms
.
b—tBy‹s
)

84 :*ğ
outw¬dNode
)

86 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Ports.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	gaxi4
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


13 
şass
 
	$Ma¡”PÜtP¬ams
(

14 
ba£
: 
BigIÁ
,

15 
size
: 
BigIÁ
,

16 
b—tBy‹s
: 
IÁ
,

17 
idB™s
: 
IÁ
,

18 
maxXãrBy‹s
: 
IÁ
 = 256,

19 
execubË
: 
BoŞ—n
 = 
Œue
)

22 
şass
 
	$SÏvePÜtP¬ams
(
b—tBy‹s
: 
IÁ
, 
idB™s
: IÁ, 
sourûB™s
: Int)

23 
şass
 
	$MemÜyPÜtP¬ams
(
ma¡”
: 
Ma¡”PÜtP¬ams
, 
nMemÜyChªÃls
: 
IÁ
)

25 
objeù
 
ExtMem
 
ex‹nds
 
F›ld
[
O±iÚ
[
MemÜyPÜtP¬ams
]](
NÚe
)

26 
objeù
 
ExtBus
 
ex‹nds
 
F›ld
[
O±iÚ
[
Ma¡”PÜtP¬ams
]](
NÚe
)

27 
objeù
 
ExtIn
 
ex‹nds
 
F›ld
[
O±iÚ
[
SÏvePÜtP¬ams
]](
NÚe
)

32 
Œa™
 
CªHaveMa¡”AXI4MemPÜt
 { 
this
: 
Ba£Subsy¡em
 =>

33 
v®
 
moduË
: 
CªHaveMa¡”AXI4MemPÜtModuËImp


35 
v®
 
memAXI4Node
 = 
	`p
(
ExtMem
).
m­
 { 
	`MemÜyPÜtP¬ams
(
memPÜtP¬ams
, 
nMemÜyChªÃls
) =>

36 
v®
 
pÜtName
 = "axi4"

37 
v®
 
deviû
 = 
Ãw
 
MemÜyDeviû


39 
v®
 
memAXI4Node
 = 
	`AXI4SÏveNode
(
Seq
.
	`buÏ‹
(
nMemÜyChªÃls
è{ 
chªÃl
 =>

40 
v®
 
ba£
 = 
	`Add»ssS‘
(
memPÜtP¬ams
.ba£, memPÜtP¬ams.
size
-1)

41 
v®
 
f‹r
 = 
	`Add»ssS‘
(
chªÃl
 * 
ÿcheBlockBy‹s
, ~((
nMemÜyChªÃls
-1) * cacheBlockBytes))

43 
	`AXI4SÏvePÜtP¬am‘”s
(

44 
¦aves
 = 
	`Seq
(
	`AXI4SÏveP¬am‘”s
(

45 
add»ss
 = 
ba£
.
	`š‹r£ù
(
f‹r
).
toLi¡
,

46 
»sourûs
 = 
deviû
.
»g
,

47 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

48 
execubË
 = 
Œue
,

49 
suµÜtsWr™e
 = 
	`T¿nsãrSizes
(1, 
ÿcheBlockBy‹s
),

50 
suµÜtsR—d
 = 
	`T¿nsãrSizes
(1, 
ÿcheBlockBy‹s
),

51 
š‹¾—vedId
 = 
	`Some
(0))),

52 
b—tBy‹s
 = 
memPÜtP¬ams
.beatBytes)

55 
memAXI4Node
 :ğ
mbus
.
	`toDRAMCÚŒŞËr
(
	`Some
(
pÜtName
)) {

56 
	`AXI4U£rYªk”
(è:ğ
	`AXI4IdIndex”
(
memPÜtP¬ams
.
idB™s
è:ğ
	`TLToAXI4
()

59 
memAXI4Node


61 
	}
}

64 
Œa™
 
CªHaveMa¡”AXI4MemPÜtModuËImp
 
ex‹nds
 
LazyModuËImp
 {

65 
v®
 
ou‹r
: 
CªHaveMa¡”AXI4MemPÜt


67 
v®
 
mem_axi4
 = 
ou‹r
.
memAXI4Node
.
m­
(
x
 => 
IO
(
H‘”og’eousBag
.
äomNode
(x.
š
)))

68 (
mem_axi4
 
z
 
ou‹r
.
memAXI4Node
è
fÜ—ch
 { (
io
, 
node
) =>

69 (
io
 
z
 
node
.
š
).
fÜ—ch
 { (io, (
bundË
, 
_
)) => io <> bundle }

72 
def
 
cÚÃùSimAXIMem
() {

73 (
mem_axi4
 
z
 
	gou‹r
.
	gmemAXI4Node
).
	gfÜ—ch
 { (
	gio
, 
	gnode
) =>

74 (
io
 
z
 
node
.
š
).
fÜ—ch
 { (io, (
_
, 
edge
)) =>

75 
v®
 
mem
 = 
LazyModuË
(
Ãw
 
SimAXIMem
(
edge
, 
size
 = 
p
(
ExtMem
).
g‘
.
ma¡”
.size))

76 
ModuË
(
mem
.
moduË
).
io
.
axi4
.
h—d
 <> io

83 
Œa™
 
	gCªHaveMa¡”AXI4MMIOPÜt
 { 
	gthis
: 
Ba£Subsy¡em
 =>

84 
´iv©e
 
v®
 
mmioPÜtP¬amsO±
 = 
p
(
ExtBus
)

85 
´iv©e
 
v®
 
pÜtName
 = "mmio_port_axi4"

86 
´iv©e
 
v®
 
deviû
 = 
Ãw
 
Sim¶eBus
(
pÜtName
.
kebab
, 
N
)

88 
v®
 
	gmmioAXI4Node
 = 
AXI4SÏveNode
(

89 
mmioPÜtP¬amsO±
.
m­
(
·¿ms
 =>

90 
AXI4SÏvePÜtP¬am‘”s
(

91 
¦aves
 = 
Seq
(
AXI4SÏveP¬am‘”s
(

92 
add»ss
 = 
Add»ssS‘
.
mi§ligÃd
(
·¿ms
.
ba£
,…¬ams.
size
),

93 
»sourûs
 = 
deviû
.
¿nges
,

94 
execubË
 = 
·¿ms
.executable,

95 
suµÜtsWr™e
 = 
T¿nsãrSizes
(1, 
·¿ms
.
maxXãrBy‹s
),

96 
suµÜtsR—d
 = 
T¿nsãrSizes
(1, 
·¿ms
.
maxXãrBy‹s
))),

97 
b—tBy‹s
 = 
·¿ms
.b—tBy‹s)).
toSeq
)

99 
mmioPÜtP¬amsO±
.
m­
 { 
·¿ms
 =>

100 
mmioAXI4Node
 :ğ
sbus
.
toFixedWidthPÜt
(
Some
(
pÜtName
)) {

101 (
AXI4Bufãr
()

102 :ğ
AXI4U£rYªk”
()

103 :ğ
AXI4Deš‹¾—v”
(
sbus
.
blockBy‹s
)

104 :ğ
AXI4IdIndex”
(
·¿ms
.
idB™s
)

105 :ğ
TLToAXI4
())

111 
Œa™
 
CªHaveMa¡”AXI4MMIOPÜtModuËImp
 
ex‹nds
 
LazyModuËImp
 {

112 
v®
 
ou‹r
: 
CªHaveMa¡”AXI4MMIOPÜt


113 
v®
 
mmio_axi4
 = 
IO
(
H‘”og’eousBag
.
äomNode
(
ou‹r
.
mmioAXI4Node
.
š
))

115 (
mmio_axi4
 
z
 
ou‹r
.
mmioAXI4Node
.
š
è
fÜ—ch
 { (
io
, (
bundË
, 
_
)) => io <> bundle }

117 
def
 
cÚÃùSimAXIMMIO
() {

118 (
mmio_axi4
 
z
 
	gou‹r
.
	gmmioAXI4Node
.
	gš
è
	gfÜ—ch
 { (
	gio
, (
	g_
, 
	gedge
)) =>

119 
v®
 
mmio_mem
 = 
LazyModuË
(
Ãw
 
SimAXIMem
(
edge
, 
size
 = 4096))

120 
ModuË
(
mmio_mem
.
moduË
).
io
.
axi4
.
h—d
 <> io

126 
Œa™
 
	gCªHaveSÏveAXI4PÜt
 { 
	gthis
: 
Ba£Subsy¡em
 =>

127 
´iv©e
 
v®
 
¦avePÜtP¬amsO±
 = 
p
(
ExtIn
)

128 
´iv©e
 
v®
 
pÜtName
 = "slave_port_axi4"

129 
´iv©e
 
v®
 
fifoB™s
 = 1

131 
v®
 
l2FrÚ‹ndAXI4Node
 = 
AXI4Ma¡”Node
(

132 
¦avePÜtP¬amsO±
.
m­
(
·¿ms
 =>

133 
AXI4Ma¡”PÜtP¬am‘”s
(

134 
ma¡”s
 = 
Seq
(
AXI4Ma¡”P¬am‘”s
(

135 
Çme
 = 
pÜtName
.
kebab
,

136 
id
 = 
IdRªge
(0, 1 << 
·¿ms
.
idB™s
))))).
toSeq
)

138 
	g¦avePÜtP¬amsO±
.
	gm­
 { 
	g·¿ms
 =>

139 
fbus
.
äomPÜt
(
Some
(
pÜtName
), 
bufãr
 = 
BufãrP¬ams
.) {

140 (
TLWidthWidg‘
(
·¿ms
.
b—tBy‹s
)

141 :ğ
AXI4ToTL
()

142 :ğ
AXI4U£rYªk”
(
Some
(1 << (
·¿ms
.
sourûB™s
 - 
fifoB™s
 - 1)))

143 :ğ
AXI4F¿gm’‹r
()

144 :ğ
AXI4IdIndex”
(
fifoB™s
))

145 } :ğ
l2FrÚ‹ndAXI4Node


150 
Œa™
 
CªHaveSÏveAXI4PÜtModuËImp
 
ex‹nds
 
LazyModuËImp
 {

151 
v®
 
ou‹r
: 
CªHaveSÏveAXI4PÜt


152 
v®
 
l2_äÚ‹nd_bus_axi4
 = 
IO
(
H‘”og’eousBag
.
äomNode
(
ou‹r
.
l2FrÚ‹ndAXI4Node
.
out
).
æ
)

153 (
ou‹r
.
l2FrÚ‹ndAXI4Node
.
out
 
z
 
l2_äÚ‹nd_bus_axi4
è
fÜ—ch
 { ((
bundË
, 
_
), 
io
) => bundle <> io }

157 
Œa™
 
	gCªHaveMa¡”TLMMIOPÜt
 { 
	gthis
: 
Ba£Subsy¡em
 =>

158 
´iv©e
 
v®
 
mmioPÜtP¬amsO±
 = 
p
(
ExtBus
)

159 
´iv©e
 
v®
 
pÜtName
 = "mmio_port_tl"

160 
´iv©e
 
v®
 
deviû
 = 
Ãw
 
Sim¶eBus
(
pÜtName
.
kebab
, 
N
)

162 
v®
 
	gmmioTLNode
 = 
TLMªag”Node
(

163 
mmioPÜtP¬amsO±
.
m­
(
·¿ms
 =>

164 
TLMªag”PÜtP¬am‘”s
(

165 
mªag”s
 = 
Seq
(
TLMªag”P¬am‘”s
(

166 
add»ss
 = 
Add»ssS‘
.
mi§ligÃd
(
·¿ms
.
ba£
,…¬ams.
size
),

167 
»sourûs
 = 
deviû
.
¿nges
,

168 
execubË
 = 
·¿ms
.executable,

169 
suµÜtsG‘
 = 
T¿nsãrSizes
(1, 
sbus
.
blockBy‹s
),

170 
suµÜtsPutFuÎ
 = 
T¿nsãrSizes
(1, 
sbus
.
blockBy‹s
),

171 
suµÜtsPutP¬tŸl
 = 
T¿nsãrSizes
(1, 
sbus
.
blockBy‹s
))),

172 
b—tBy‹s
 = 
·¿ms
.b—tBy‹s)).
toSeq
)

174 
mmioPÜtP¬amsO±
.
m­
 { 
·¿ms
 =>

175 
mmioTLNode
 :ğ
sbus
.
toFixedWidthPÜt
(
Some
(
pÜtName
)) {

176 
TLBufãr
(è:ğ
TLSourûShršk”
(1 << 
·¿ms
.
idB™s
)

183 
Œa™
 
CªHaveMa¡”TLMMIOPÜtModuËImp
 
ex‹nds
 
LazyModuËImp
 {

184 
v®
 
ou‹r
: 
CªHaveMa¡”TLMMIOPÜt


185 
v®
 
mmio_
 = 
IO
(
H‘”og’eousBag
.
äomNode
(
ou‹r
.
mmioTLNode
.
š
))

186 (
mmio_
 
z
 
ou‹r
.
mmioTLNode
.
š
è
fÜ—ch
 { (
io
, (
bundË
, 
_
)) => io <> bundle }

192 
Œa™
 
	gCªHaveSÏveTLPÜt
 { 
	gthis
: 
Ba£Subsy¡em
 =>

193 
´iv©e
 
v®
 
¦avePÜtP¬amsO±
 = 
p
(
ExtIn
)

194 
´iv©e
 
v®
 
pÜtName
 = "slave_port_tl"

196 
v®
 
l2FrÚ‹ndTLNode
 = 
TLCl›ÁNode
(

197 
¦avePÜtP¬amsO±
.
m­
(
·¿ms
 =>

198 
TLCl›ÁPÜtP¬am‘”s
(

199 
ş›Ás
 = 
Seq
(
TLCl›ÁP¬am‘”s
(

200 
Çme
 = 
pÜtName
.
kebab
,

201 
sourûId
 = 
IdRªge
(0, 1 << 
·¿ms
.
idB™s
))))).
toSeq
)

203 
	g¦avePÜtP¬amsO±
.
	gm­
 { 
	g·¿ms
 =>

204 
sbus
.
äomPÜt
(
Some
(
pÜtName
)) {

205 
TLSourûShršk”
(1 << 
·¿ms
.
sourûB™s
è:ğ
TLWidthWidg‘
Õ¬ams.
b—tBy‹s
)

206 } :ğ
l2FrÚ‹ndTLNode


211 
Œa™
 
CªHaveSÏveTLPÜtModuËImp
 
ex‹nds
 
LazyModuËImp
 {

212 
v®
 
ou‹r
: 
CªHaveSÏveTLPÜt


213 
v®
 
l2_äÚ‹nd_bus_
 = 
IO
(
H‘”og’eousBag
.
äomNode
(
ou‹r
.
l2FrÚ‹ndTLNode
.
out
).
æ
)

214 (
ou‹r
.
l2FrÚ‹ndTLNode
.
out
 
z
 
l2_äÚ‹nd_bus_
è
fÜ—ch
 { ((
bundË
, 
_
), 
io
) => bundle <> io }

218 
şass
 
	$SimAXIMem
(
edge
: 
AXI4EdgeP¬am‘”s
, 
size
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

219 
v®
 
node
 = 
	`AXI4Ma¡”Node
(
	`Li¡
(
edge
.
ma¡”
))

221 
v®
 
¤am
 = 
	`LazyModuË
(
Ãw
 
	`AXI4RAM
(
	`Add»ssS‘
(0, 
size
-1), 
b—tBy‹s
 = 
edge
.
bundË
.
d©aB™s
/8))

222 
¤am
.
node
 :ğ
	`AXI4Bufãr
(è:ğ
	`AXI4F¿gm’‹r
() :=‚ode

224 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

225 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 { v® 
axi4
 = 
H‘”og’eousBag
.
	`äomNode
(
node
.
out
).
æ
 })

226 (
node
.
out
 
z
 
io
.
axi4
è
fÜ—ch
 { ((
bundË
, 
_
), io) => bundle <> io }

228 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RTC.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.{
	gLazyModuËImp
, 
	gDTSTimeba£
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
CªHaveP”h”yCLINT


9 
Œa™
 
HasRTCModuËImp
 
ex‹nds
 
	gLazyModuËImp
 {

10 
v®
 
	gou‹r
: 
Ba£Subsy¡em
 
w™h
 
CªHaveP”h”yCLINT


11 
´iv©e
 
v®
 
pbusF»q
 = 
ou‹r
.
p
(
P”h”yBusKey
).
äequ’cy


12 
´iv©e
 
v®
 
¹cF»q
 = 
ou‹r
.
p
(
DTSTimeba£
)

13 
´iv©e
 
v®
 
š‹º®P”iod
: 
BigIÁ
 = 
pbusF»q
 / 
¹cF»q


16 
»quœe
(
š‹º®P”iod
 > 0)

18 
»quœe
((
pbusF»q
 - 
¹cF»q
 * 
š‹º®P”iod
) * 100 /…busFreq <= 5)

21 
v®
 (
_
, 
št_¹c_tick
èğ
CouÁ”
(
Œue
.
B
, 
š‹º®P”iod
.
toIÁ
)

23 
	gou‹r
.
	gşštO±
.
	gfÜ—ch
 { 
	gşšt
 =>

24 
şšt
.
moduË
.
io
.
¹cTick
 :ğ
št_¹c_tick


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/ResetVector.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


8 
Œa™
 
	gHasRe£tVeùÜWœe
 {

9 
def
 
	g»£tVeùÜB™s
: 
IÁ


10 
v®
 
glob®_»£t_veùÜ
 = 
Wœe
(
UIÁ
(
width
 = 
»£tVeùÜB™s
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RocketSubsystem.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.{
	gHasP”h”yDebug
, 
	gHasP”h”yDebugModuËImp
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


17 
şass
 
	$TeMa¡”PÜtP¬ams
(
bufãrs
: 
IÁ
 = 0, 
cÜk
: 
O±iÚ
[
BoŞ—n
] = 
NÚe
)

18 
şass
 
	$TeSÏvePÜtP¬ams
(
bufãrs
: 
IÁ
 = 0, 
block”CŒlAddr
: 
O±iÚ
[
BigIÁ
] = 
NÚe
)

20 
şass
 
	`Rock‘CrossšgP¬ams
(

21 
üossšgTy³
: 
ClockCrossšgTy³
 = 
	`SynchrÚousCrossšg
(),

22 
ma¡”
: 
TeMa¡”PÜtP¬ams
 = 
	`TeMa¡”PÜtP¬ams
(),

23 
¦ave
: 
TeSÏvePÜtP¬ams
 = 
	$TeSÏvePÜtP¬ams
()) {

24 
def
 
knownR©io
: 
O±iÚ
[
IÁ
] = 
üossšgTy³
 
m©ch
 {

25 
	`R©iÚ®Crossšg
(
_
è=> 
	`Some
(2)

26 
_
 => 
NÚe


28 
	}
}

30 
objeù
 
Rock‘TesKey
 
ex‹nds
 
F›ld
[
Seq
[
Rock‘TeP¬ams
]](
N
)

31 
objeù
 
Rock‘CrossšgKey
 
ex‹nds
 
F›ld
[
Seq
[
Rock‘CrossšgP¬ams
]](
Li¡
(
	$Rock‘CrossšgP¬ams
()))

33 
Œa™
 
HasRock‘Tes
 
ex‹nds
 
HasTes


34 
w™h
 
CªHaveP”h”yPLIC


35 
w™h
 
CªHaveP”h”yCLINT


36 
w™h
 
HasP”h”yDebug
 { 
this
: 
Ba£Subsy¡em
 =>

37 
v®
 
moduË
: 
HasRock‘TesModuËImp


39 
´Ùeùed
 
v®
 
rock‘TeP¬ams
 = 
	`p
(
Rock‘TesKey
)

40 
´iv©e
 
v®
 
üossšgs
 = 
	`³rTeOrGlob®S‘tšg
(
	`p
(
Rock‘CrossšgKey
), 
rock‘TeP¬ams
.
size
)

46 
v®
 
rock‘Tes
 = 
rock‘TeP¬ams
.
	`z
(
üossšgs
).
m­
 { (

, 
üossšg
) =>

47 
v®
 
rock‘
 = 
	`LazyModuË
(
Ãw
 
	`Rock‘Te
(

, 
üossšg
.
üossšgTy³
)(
	`augm’‹dTeP¬am‘”s
(tp)))

48 .
	`sugge¡Name
(

.
Çme
)

50 
	`cÚÃùMa¡”PÜtsToSBus
(
rock‘
, 
üossšg
)

51 
	`cÚÃùSÏvePÜtsToCBus
(
rock‘
, 
üossšg
)

52 
	`cÚÃùIÁ”ru±s
(
rock‘
, 
	`Some
(
debug
), 
şštO±
, 
¶icO±
)

54 
rock‘


56 
	}
}

58 
Œa™
 
HasRock‘TesModuËImp
 
ex‹nds
 
HasTesModuËImp


59 
w™h
 
	gHasP”h”yDebugModuËImp
 {

60 
v®
 
	gou‹r
: 
HasRock‘Tes


63 şas 
	cRock‘Subsy¡em
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
Ba£Subsy¡em


64 
w™h
 
HasRock‘Tes
 {

65 
v®
 
tes
 = 
rock‘Tes


66 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`Rock‘Subsy¡emModuËImp
(
this
)

69 
şass
 
Rock‘Subsy¡emModuËImp
[+
L
 <: 
Rock‘Subsy¡em
](
_ou‹r
: Lè
ex‹nds
 
	$Ba£Subsy¡emModuËImp
(
_ou‹r
)

70 
w™h
 
HasRock‘TesModuËImp
 {

71 
te_šputs
.
	`z
(
ou‹r
.
h¬tIdLi¡
).
fÜ—ch
 { (
wœe
, 
i
) =>

72 
wœe
.
şock
 := clock

73 
wœe
.
»£t
 :=„eset

74 
wœe
.
h¬tid
 :ğ
	`UIÁ
(
i
)

75 
wœe
.
»£t_veùÜ
 :ğ
glob®_»£t_veùÜ


77 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/SystemBus.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
subsy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.{
	gDevNuÎP¬ams
, 
	gTLE¼Ü
, 
	gTLZ”o
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
şass
 
Sy¡emBusP¬ams
(

13 
b—tBy‹s
: 
IÁ
,

14 
blockBy‹s
: 
IÁ
,

15 
©omics
: 
O±iÚ
[
BusAtomics
] = 
Some
(BusAtomics()),

16 
pbusBufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
,

17 
pŞicy
: 
TLArb™”
.
PŞicy
 = TLArb™”.
roundRobš
,

18 
”rÜDeviû
: 
O±iÚ
[
DevNuÎP¬ams
] = 
NÚe
è
ex‹nds
 
HasTLBusP¬ams


20 
objeù
 
Sy¡emBusKey
 
ex‹nds
 
F›ld
[
Sy¡emBusP¬ams
]

22 
şass
 
	$Sy¡emBus
(
·¿ms
: 
Sy¡emBusP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
)

23 
ex‹nds
 
	`TLBusW¿µ”
(
·¿ms
, "system_bus")

24 
w™h
 
CªA‰achTLSÏves


25 
w™h
 
CªA‰achTLMa¡”s


26 
w™h
 
HasTLXb¬Phy
 {

28 
v®
 
cbus_·¿ms
 = 
Ãw
 
	`P”h”yBusP¬ams
(

29 
	`p
(
P”h”yBusKey
).
b—tBy‹s
,

30 
·¿ms
.
blockBy‹s
,

31 
·¿ms
.
©omics
,

32 
NoCrossšg
)

33 
v®
 
cÚŒŞ_bus
 = 
	`LazyModuË
(
Ãw
 
	`P”h”yBus
(
cbus_·¿ms
))

34 
cÚŒŞ_bus
.
üossFromSy¡emBus
 { 
this
.
	`toSÏveBus
("cbus") }

36 
´iv©e
 
v®
 
ma¡”_¥l™‹r
 = 
	`LazyModuË
(
Ãw
 
TLS¶™‹r
)

37 
šw¬dNode
 :=* 
ma¡”_¥l™‹r
.
node


39 
·¿ms
.
”rÜDeviû
.
fÜ—ch
 { 
dÅ
 => 
	`LazyScİe
("wrapped_error_device") {

40 
v®
 
”rÜ
 = 
	`LazyModuË
(
Ãw
 
	`TLE¼Ü
(
·¿ms
 = 
dÅ
, 
b—tBy‹s
 =…arams.beatBytes))

41 
”rÜ
.
node
 :ğ
	`TLBufãr
(è:ğ
outw¬dNode


43 
def
 
busV›w
 = 
ma¡”_¥l™‹r
.
node
.
edges
.
š
.
h—d


45 
def
 
	`toSÏveBus
(
Çme
: 
SŒšg
): (=> 
TLInw¬dNode
è=> 
NoHªdË
 =

46 
g’
 => 
	`to
(
s
"bus_named_$name") {

47 (
g’


48 :*ğ
	`TLFIFOFix”
(
TLFIFOFix”
.
®l
)

49 :*ğ
	`TLWidthWidg‘
(
·¿ms
.
b—tBy‹s
)

50 :*ğ
	`TLBufãr
(
·¿ms
.
pbusBufãr
)

51 :*ğ
outw¬dNode
)

54 
def
 
	`äomMa¡”Bus
(
Çme
: 
SŒšg
): (=> 
TLOutw¬dNode
è=> 
NoHªdË
 =

55 
g’
 => 
	`äom
(
s
"bus_Çmed_$Çme"è{ 
ma¡”_¥l™‹r
.
node
 :=* gen }

57 
def
 
toS¶™SÏve
[
D
,
U
,
E
,
B
 <: 
D©a
]

58 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
)

59 (
g’
: => 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
,
D
,
U
,
E
,
B
] =

60 
	`TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

61 
	`to
("¦ave" 
Çmed
 
Çme
è{ 
g’
 :=* 
ma¡”_¥l™‹r
.
node
 }

64 
def
 
äomTe


65 (
Çme
: 
O±iÚ
[
SŒšg
], 
bufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
, 
cÜk
: O±iÚ[
BoŞ—n
] = 
NÚe
)

66 (
g’
: => 
TLOutw¬dNode
): 
NoHªdË
 = {

67 
	`äom
("te" 
Çmed
 
Çme
) {

68 
ma¡”_¥l™‹r
.
node
 :=* 
	`TLBufãr
(
bufãr
è:=* 
	`TLFIFOFix”
(
TLFIFOFix”
.
®lUnÿch—bË
è:=* 
g’


71 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Configs.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
sy¡em


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
CÚfig


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.{
	gInşudeJgDTM
, 
	gJgDTMKey
}

10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


12 
şass
 
W™hJgDTMSy¡em
 
ex‹nds
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
W™hJgDTM


13 
şass
 
W™hDebugSBASy¡em
 
ex‹nds
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
W™hDebugSBA


15 
şass
 
Ba£CÚfig
 
ex‹nds
 
CÚfig
(

16 
Ãw
 
W™hDeçuÉMemPÜt
() ++

17 
Ãw
 
W™hDeçuÉMMIOPÜt
() ++

18 
Ãw
 
W™hDeçuÉSÏvePÜt
() ++

19 
Ãw
 
W™hTimeba£
(
BigIÁ
(1000000)) ++

20 
Ãw
 
W™hDTS
("ä“chs,rock‘ch-unknown", 
N
) ++

21 
Ãw
 
W™hNExtTİIÁ”ru±s
(2) ++

22 
Ãw
 
	$Ba£Subsy¡emCÚfig
()

25 
şass
 
DeçuÉCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNBigCÜes
(4è++‚ew 
Ba£CÚfig
)

26 
şass
 
DeçuÉPCLCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
W™hPrivCodeLock
 ++‚ew 
DeçuÉCÚfig
)

27 
şass
 
DeçuÉPCL1CÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
W™hPrivCodeLock1
 ++‚ew 
DeçuÉCÚfig
)

28 
şass
 
DeçuÉPCL2CÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
W™hPrivCodeLock2
 ++‚ew 
DeçuÉCÚfig
)

29 
şass
 
DeçuÉPCL3CÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
W™hPrivCodeLock3
 ++‚ew 
DeçuÉCÚfig
)

31 
şass
 
DeçuÉBufã¾essCÚfig
 
ex‹nds
 
	`CÚfig
(

32 
Ãw
 
W™hBufã¾essBrßdÿ¡Hub
 ++‚ew 
	`W™hNBigCÜes
(1è++‚ew 
Ba£CÚfig
)

34 
şass
 
DeçuÉSm®lCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNSm®lCÜes
(1è++‚ew 
Ba£CÚfig
)

35 
şass
 
DeçuÉRV32CÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
W™hRV32
 ++‚ew 
DeçuÉCÚfig
)

37 
şass
 
Du®BªkCÚfig
 
ex‹nds
 
	`CÚfig
(

38 
Ãw
 
	`W™hNBªks
(2è++‚ew 
Ba£CÚfig
)

40 
şass
 
Du®ChªÃlCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNMemÜyChªÃls
(2è++‚ew 
Ba£CÚfig
)

42 
şass
 
Du®ChªÃlDu®BªkCÚfig
 
ex‹nds
 
	`CÚfig
(

43 
Ãw
 
	`W™hNMemÜyChªÃls
(2) ++

44 
Ãw
 
	`W™hNBªks
(4è++‚ew 
Ba£CÚfig
)

46 
şass
 
RoccExam¶eCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
W™hRoccExam¶e
 ++‚ew 
DeçuÉCÚfig
)

48 
şass
 
Edge128B™CÚfig
 
ex‹nds
 
	`CÚfig
(

49 
Ãw
 
	`W™hEdgeD©aB™s
(128è++‚ew 
Ba£CÚfig
)

50 
şass
 
Edge32B™CÚfig
 
ex‹nds
 
	`CÚfig
(

51 
Ãw
 
	`W™hEdgeD©aB™s
(32è++‚ew 
Ba£CÚfig
)

53 
şass
 
SšgËChªÃlB’chm¬kCÚfig
 
ex‹nds
 
	$CÚfig
(
Ãw
 
DeçuÉCÚfig
)

54 
şass
 
Du®ChªÃlB’chm¬kCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNMemÜyChªÃls
(2è++‚ew 
SšgËChªÃlB’chm¬kCÚfig
)

55 
şass
 
QuadChªÃlB’chm¬kCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNMemÜyChªÃls
(4è++‚ew 
SšgËChªÃlB’chm¬kCÚfig
)

56 
şass
 
OùoChªÃlB’chm¬kCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNMemÜyChªÃls
(8è++‚ew 
SšgËChªÃlB’chm¬kCÚfig
)

58 
şass
 
EightChªÃlCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNMemÜyChªÃls
(8è++‚ew 
Ba£CÚfig
)

60 
şass
 
Du®CÜeCÚfig
 
ex‹nds
 
	`CÚfig
(

61 
Ãw
 
	`W™hNBigCÜes
(2è++‚ew 
Ba£CÚfig
)

63 
şass
 
TšyCÚfig
 
ex‹nds
 
	`CÚfig
(

64 
Ãw
 
W™hNoMemPÜt
 ++

65 
Ãw
 
	`W™hNMemÜyChªÃls
(0) ++

66 
Ãw
 
	`W™hNBªks
(0) ++

67 
Ãw
 
W™h1TšyCÜe
 ++

68 
Ãw
 
Ba£CÚfig
)

70 
şass
 
MemPÜtOÆyCÚfig
 
ex‹nds
 
	`CÚfig
(

71 
Ãw
 
W™hNoMMIOPÜt
 ++

72 
Ãw
 
W™hNoSÏvePÜt
 ++

73 
Ãw
 
DeçuÉCÚfig


76 
şass
 
MMIOPÜtOÆyCÚfig
 
ex‹nds
 
	`CÚfig
(

77 
Ãw
 
W™hNoSÏvePÜt
 ++

78 
Ãw
 
W™hNoMemPÜt
 ++

79 
Ãw
 
	`W™hNMemÜyChªÃls
(0) ++

80 
Ãw
 
	`W™hNBªks
(0) ++

81 
Ãw
 
W™hIncoh”’tTes
 ++

82 
Ãw
 
W™hSü©ch·dsOÆy
 ++

83 
Ãw
 
DeçuÉCÚfig


86 
şass
 
Ba£FPGACÚfig
 
ex‹nds
 
	$CÚfig
(
Ãw
 
Ba£CÚfig
)

88 
şass
 
DeçuÉFPGACÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
	`W™hNSm®lCÜes
(1è++‚ew 
Ba£FPGACÚfig
)

89 
şass
 
DeçuÉFPGASm®lCÚfig
 
ex‹nds
 
	`CÚfig
(
Ãw
 
DeçuÉFPGACÚfig
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/ExampleRocketSystem.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
sy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
DÚtTouch


14 şas 
	cExam¶eRock‘Sy¡em
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
Rock‘Subsy¡em


15 
w™h
 
HasAsyncExtIÁ”ru±s


16 
w™h
 
CªHaveMa¡”AXI4MemPÜt


17 
w™h
 
CªHaveMa¡”AXI4MMIOPÜt


18 
w™h
 
CªHaveSÏveAXI4PÜt


19 
w™h
 
HasP”h”yBoÙROM
 {

20 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`Exam¶eRock‘Sy¡emModuËImp
(
this
)

23 
şass
 
Exam¶eRock‘Sy¡emModuËImp
[+
L
 <: 
Exam¶eRock‘Sy¡em
](
_ou‹r
: Lè
ex‹nds
 
	$Rock‘Subsy¡emModuËImp
(
_ou‹r
)

24 
w™h
 
HasRTCModuËImp


25 
w™h
 
HasExtIÁ”ru±sModuËImp


26 
w™h
 
CªHaveMa¡”AXI4MemPÜtModuËImp


27 
w™h
 
CªHaveMa¡”AXI4MMIOPÜtModuËImp


28 
w™h
 
CªHaveSÏveAXI4PÜtModuËImp


29 
w™h
 
HasP”h”yBoÙROMModuËImp


30 
w™h
 
DÚtTouch


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Generator.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
sy¡em


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
Rock‘TesKey


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gte
.
XL’


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
G’”©ÜAµ


9 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
LškedHashS‘


12 
objeù
 
G’”©Ü
 
ex‹nds
 
	gG’”©ÜAµ
 {

14 
v®
 
	grv64RegrTe¡Names
 = 
LškedHashS‘
(

41 
v®
 
	grv32RegrTe¡Names
 = 
LškedHashS‘
(

50 
ov”ride
 
def
 
	gaddTe¡Su™es
 {

51 
impÜt
 
	gDeçuÉTe¡Su™es
.
_


52 
v®
 
	gxËn
 = 
·¿ms
(
XL’
)

54 
v®
 
teP¬ams
 = 
·¿ms
(
Rock‘TesKey
).
h—d


55 
v®
 
cÜeP¬ams
 = 
teP¬ams
.
cÜe


56 
v®
 
vm
 = 
cÜeP¬ams
.
u£VM


57 
v®
 
’v
 = ià(
vm
è
Li¡
("p","v") List("p")

58 
	gcÜeP¬ams
.
åu
 
	gfÜ—ch
 { 
	gcfg
 =>

59 ià(
xËn
 == 32) {

60 
Te¡G’”©iÚ
.
addSu™es
(
’v
.
m­
(
rv32uf
))

61 ià(
cfg
.
fL’
 >= 64)

62 
Te¡G’”©iÚ
.
addSu™es
(
’v
.
m­
(
rv32ud
))

64 
	gTe¡G’”©iÚ
.
addSu™e
(
rv32udB’chm¬ks
)

65 
	gTe¡G’”©iÚ
.
addSu™es
(
’v
.
m­
(
rv64uf
))

66 ià(
	gcfg
.
	gfL’
 >= 64)

67 
Te¡G’”©iÚ
.
addSu™es
(
’v
.
m­
(
rv64ud
))

70 ià(
	gcÜeP¬ams
.
	gu£Atomics
) {

71 ià(
	gteP¬ams
.
	gdÿche
.
æ©M­
(
_
.
sü©ch
).
	gisEm±y
)

72 
	gTe¡G’”©iÚ
.
addSu™es
(
’v
.
m­
(ià(
xËn
 =ğ64è
rv64ua
 
rv32ua
))

74 
Te¡G’”©iÚ
.
addSu™es
(
’v
.
m­
(ià(
xËn
 =ğ64è
rv64uaSªsLRSC
 
rv32uaSªsLRSC
))

76 ià(
	gcÜeP¬ams
.
	gu£Com´es£d
è
	gTe¡G’”©iÚ
.
addSu™es
(
’v
.
m­
(ià(
xËn
 =ğ64è
rv64uc
 
rv32uc
))

77 
v®
 (
rvi
, 
rvu
) =

78 ià(
xËn
 =ğ64è((ià(
vm
è
rv64i
 
rv64pi
), 
	grv64u
)

79 ((ià(
	gvm
è
rv32i
 
	grv32pi
), 
	grv32u
)

81 
	gTe¡G’”©iÚ
.
addSu™es
(
rvi
.
m­
(
_
("p")))

82 
	gTe¡G’”©iÚ
.
addSu™es
((ià(
vm
è
Li¡
("v"èLi¡()).
æ©M­
(
’v
 => 
rvu
.
m­
(
_
(env))))

83 
Te¡G’”©iÚ
.
addSu™e
(
b’chm¬ks
)

84 
Te¡G’”©iÚ
.
addSu™e
(
Ãw
 
Reg»ssiÚTe¡Su™e
(ià(
xËn
 =ğ64è
rv64RegrTe¡Names
 
rv32RegrTe¡Names
))

87 
v®
 
	glÚgName
 = 
Çmes
.
cÚfigProjeù
 + "." +‚ames.
cÚfigs


88 
g’”©eFœ¹l


89 
g’”©eAÂo


90 
g’”©eTe¡Su™eMakeäags


91 
g’”©eROMs


92 
g’”©eA¹eçùs


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/RocketTestSuite.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
sy¡em


6 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
LškedHashS‘


8 
ab¡¿ù
 cÏs 
	cRock‘Te¡Su™e
 {

9 
v®
 
	mdœ
: 
SŒšg


10 
v®
 
makeT¬g‘Name
: 
SŒšg


11 
v®
 
Çmes
: 
LškedHashS‘
[
SŒšg
]

12 
v®
 
’vName
: 
SŒšg


13 
def
 
kšd
: 
SŒšg


14 
def
 
po¡Süt
 = 
s
"""

16 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .
hex
, 
	$$$
(
$makeT¬g‘Name
))): 
	`$$
(
ouut_dœ
)/%.
hex
: 
$dœ
/%.hex

17 \
tmkdœ
 -
p
 
	`$$
(
ouut_dœ
)

18 \
n
 -
fs
 
$$
< $$@

20 
	`$$
(
add´efix
 $$(
ouut_dœ
)/, 
	$$$
(
$makeT¬g‘Name
)): 
	`$$
(
ouut_dœ
)/%: 
$dœ
/%

21 \
tmkdœ
 -
p
 
	`$$
(
ouut_dœ
)

22 \
n
 -
fs
 
$$
< $$@

24 
run
-
$makeT¬g‘Name
: 
	`$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .
out
, $$($makeTargetName)))

25 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
^ /
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

27 
run
-
$makeT¬g‘Name
-
debug
: 
	`$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .
vpd
, $$($makeTargetName)))

28 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
	`$$
(
·tsub¡
 %.
vpd
,%.
out
,
$$
^è/
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

30 
run
-
$makeT¬g‘Name
-
f¡
: 
	`$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .fst, $$($makeTargetName)))

31 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
	`$$
(
·tsub¡
 %.
f¡
,%.
out
,
$$
^è/
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

35 
şass
 
	$As£mblyTe¡Su™e
(
´efix
: 
SŒšg
, 
v®
 
Çmes
: 
LškedHashS‘
[SŒšg])(v® 
’vName
: SŒšgè
ex‹nds
 
Rock‘Te¡Su™e
 {

36 
v®
 
dœ
 = "$(RISCV)/riscv64-unknown-elf/share/riscv-tests/isa"

37 
v®
 
makeT¬g‘Name
 = 
´efix
 + "-" + 
’vName
 + "-asm-tests"

38 
def
 
kšd
 = "asm"

39 
ov”ride
 
def
 
toSŒšg
 = 
s
"$makeT¬g‘Namğ\\\n" + 
Çmes
.
	`m­
(
n
 => s"\t$´efix-$’vName-$n").
	`mkSŒšg
(" \\\n"è+ 
po¡Süt


40 
	}
}

42 
şass
 
	$B’chm¬kTe¡Su™e
(
makeP»fix
: 
SŒšg
, 
v®
 
dœ
: SŒšg, v® 
Çmes
: 
LškedHashS‘
[SŒšg]è
ex‹nds
 
Rock‘Te¡Su™e
 {

43 
v®
 
’vName
 = ""

44 
v®
 
makeT¬g‘Name
 = 
makeP»fix
 + "-bmark-tests"

45 
def
 
kšd
 = "bmark"

46 
ov”ride
 
def
 
toSŒšg
 = 
s
"$makeT¬g‘Namğ\\\n" + 
Çmes
.
	`m­
(
n
 => s"\t$n.riscv").
	`mkSŒšg
(" \\\n"è+ 
po¡Süt


47 
	}
}

49 
şass
 
	$Reg»ssiÚTe¡Su™e
(
v®
 
Çmes
: 
LškedHashS‘
[
SŒšg
]è
ex‹nds
 
Rock‘Te¡Su™e
 {

50 
v®
 
’vName
 = ""

51 
v®
 
dœ
 = "$(RISCV)/riscv64-unknown-elf/share/riscv-tests/isa"

52 
v®
 
makeT¬g‘Name
 = "regression-tests"

53 
def
 
kšd
 = "regression"

54 
ov”ride
 
def
 
toSŒšg
 = 
s
"$makeT¬g‘Namğ\\\n" + 
Çmes
.
	`mkSŒšg
(" \\\n")

55 
	}
}

57 
objeù
 
Te¡G’”©iÚ
 {

58 
´iv©e
 
v®
 
su™es
 = 
cŞËùiÚ
.
mubË
.
Li¡M­
[
SŒšg
, 
Rock‘Te¡Su™e
]()

60 
def
 
addSu™e
(
s
: 
Rock‘Te¡Su™e
è{ 
su™es
 +ğ(s.
makeT¬g‘Name
 -> s) }

62 
def
 
addSu™es
(
s
: 
Seq
[
Rock‘Te¡Su™e
]è{ s.
fÜ—ch
(
addSu™e
) }

64 
def
 
g’”©eMakeäag
: 
SŒšg
 = {

65 
def
 
g’
(
kšd
: 
SŒšg
, 
s
: 
Seq
[
Rock‘Te¡Su™e
]) = {

66 if(
s
.
Ëngth
 > 0) {

67 
v®
 
’vs
 = 
s
.
groupBy
(
_
.
’vName
)

68 
v®
 
rg‘s
 = 
s
.
m­
(
t
 => s"$$(${t.makeT¬g‘Name})").
mkSŒšg
(" ")

69 
s
.
m­
(
_
.
toSŒšg
).
mkSŒšg
("\n") +

70 
’vs
.
f‹rKeys
(
_
 !ğ"").
m­
( {

71 (
’v
,
’vsu™es
) => {

72 
v®
 
su™es
 = 
’vsu™es
.
m­
(
t
 => 
s
"$$(${t.makeT¬g‘Name})").
mkSŒšg
(" ")

73 
s
"""

74 
run
-
$kšd
-
$’v
-
‹¡s
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .
out
, 
$su™es
))

75 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
^ /
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

76 
run
-
$kšd
-
$’v
-
‹¡s
-
debug
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .
vpd
, 
$su™es
))

77 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
(
·tsub¡
 %.
vpd
,%.
out
,$$^è/
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

78 
run
-
$kšd
-
$’v
-
‹¡s
-
f¡
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .f¡, 
$su™es
))

79 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
(
·tsub¡
 %.
f¡
,%.
out
,$$^è/
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

80 
run
-
$kšd
-
$’v
-
‹¡s
-
ç¡
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .run, 
$su™es
))

81 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
^ /
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

82 """} } ).mkSŒšg("\
n
") + s"""

83 
run
-
$kšd
-
‹¡s
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .
out
, 
$rg‘s
))

84 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
^ /
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

85 
run
-
$kšd
-
‹¡s
-
debug
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .
vpd
, 
$rg‘s
))

86 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
(
·tsub¡
 %.
vpd
,%.
out
,$$^è/
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

87 
run
-
$kšd
-
‹¡s
-
f¡
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .f¡, 
$rg‘s
))

88 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
(
·tsub¡
 %.
f¡
,%.
out
,$$^è/
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

89 
run
-
$kšd
-
‹¡s
-
ç¡
: 
$$
(
add´efix
 $$(
ouut_dœ
)/, $$(
addsuffix
 .run, 
$rg‘s
))

90 \
t
@
echo
; 
³¾
 -
Ã
 '´šˆ" [$$$$1] $$$$ARGV \\t$$$$2\\n" ifĞ/\\*{3}(.{8})\\*{3}(.*)/ || /ASSERTION (FAILED):(.*)/˜)' 
$$
^ /
dev
/
nuÎ
 |…”È-
³
 'BEGIN { $$$$failed = 0 } $$$$failed = 1 if(/FAILED/i); END {ƒxit($$$$failed) }'

95 
su™es
.
v®ues
.
toSeq
.
groupBy
(
_
.
kšd
).
m­
 { (kšd, 
s
è=> 
g’
(kšd, sè}.
mkSŒšg
("\n")

100 
objeù
 
DeçuÉTe¡Su™es
 {

101 
v®
 
rv32uiNames
 = 
LškedHashS‘
(

105 
v®
 
rv32ui
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32ui", 
rv32uiNames
)(
_
)

107 
v®
 
rv32ucNames
 = 
LškedHashS‘
("rvc")

108 
v®
 
rv32uc
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32uc", 
rv32ucNames
)(
_
)

110 
v®
 
rv32umNames
 = 
LškedHashS‘
("mul", "mulh", "mulhsu", "mulhu", "div", "divu", "rem", "remu")

111 
v®
 
rv32um
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32um", 
rv32umNames
)(
_
)

113 
v®
 
rv32uaSªsLRSCNames
 = 
LškedHashS‘
("amoadd_w", "amoand_w", "amoor_w", "amoxor_w", "amoswap_w", "amomax_w", "amomaxu_w", "amomin_w", "amominu_w")

114 
v®
 
rv32uaSªsLRSC
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32ua", 
rv32uaSªsLRSCNames
)(
_
)

116 
v®
 
rv32uaNames
 = 
rv32uaSªsLRSCNames
 + "lrsc"

117 
v®
 
rv32ua
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32ua", 
rv32uaNames
)(
_
)

119 
v®
 
rv32siNames
 = 
LškedHashS‘
("csr", "ma_fetch", "scall", "sbreak", "wfi", "dirty")

120 
v®
 
rv32si
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32si", 
rv32siNames
)(
_
)

122 
v®
 
rv32miNames
 = 
LškedHashS‘
("csr", "mcsr", "illegal", "ma_addr", "ma_fetch", "sbreak", "scall")

123 
v®
 
rv32mi
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32mi", 
rv32miNames
)(
_
)

125 
v®
 
rv32u
 = 
Li¡
(
rv32ui
, 
rv32um
)

126 
v®
 
rv32i
 = 
Li¡
(
rv32ui
, 
rv32si
, 
rv32mi
)

127 
v®
 
rv32pi
 = 
Li¡
(
rv32ui
, 
rv32mi
)

129 
v®
 
rv64uiNames
 = 
LškedHashS‘
("addw", "addiw", "ld", "lwu", "sd", "slliw", "sllw", "sltiu", "sltu", "sraiw", "sraw", "srliw", "srlw", "subw")

130 
v®
 
rv64ui
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64ui", 
rv32uiNames
 ++ 
rv64uiNames
)(
_
)

132 
v®
 
rv64umNames
 = 
LškedHashS‘
("divuw", "divw", "mulw", "remuw", "remw")

133 
v®
 
rv64um
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64um", 
rv32umNames
 ++ 
rv64umNames
)(
_
)

135 
v®
 
rv64uaSªsLRSCNames
 = 
rv32uaSªsLRSCNames
.
m­
(
_
.
»¶aûAÎ
("_w","_d"))

136 
v®
 
rv64uaSªsLRSC
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64ua", 
rv32uaSªsLRSCNames
 ++ 
rv64uaSªsLRSCNames
)(
_
)

138 
v®
 
rv64uaNames
 = 
rv64uaSªsLRSCNames
 + "lrsc"

139 
v®
 
rv64ua
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64ua", 
rv32uaNames
 ++ 
rv64uaNames
)(
_
)

141 
v®
 
rv64ucNames
 = 
rv32ucNames


142 
v®
 
rv64uc
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64uc", 
rv64ucNames
)(
_
)

144 
v®
 
rv64ufNames
 = 
LškedHashS‘
("ldst", "move", "fcmp", "fcvt", "fcvt_w", "fclass", "fadd", "fdiv", "fmin", "fmadd")

145 
v®
 
rv64uf
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64uf", 
rv64ufNames
)(
_
)

147 
v®
 
rv32uf
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32uf", 
rv64ufNames
)(
_
)

148 
v®
 
rv32ud
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32ud", 
rv64ufNames
 - "move")(
_
)

150 
v®
 
rv64udNames
 = 
rv64ufNames
 + "structural"

151 
v®
 
rv64ud
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64ud", 
rv64udNames
)(
_
)

153 
v®
 
rv64siNames
 = 
rv32siNames


154 
v®
 
rv64si
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64si", 
rv64siNames
)(
_
)

156 
v®
 
rv64miNames
 = 
rv32miNames
 + "breakpoint" + "access"

157 
v®
 
rv64mi
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64mi", 
rv64miNames
)(
_
)

159 
v®
 
ground‹¡Names
 = 
LškedHashS‘
("simple")

160 
v®
 
ground‹¡64
 = 
Ãw
 
As£mblyTe¡Su™e
("rv64ui", 
ground‹¡Names
)(
_
)

161 
v®
 
ground‹¡32
 = 
Ãw
 
As£mblyTe¡Su™e
("rv32ui", 
ground‹¡Names
)(
_
)

163 
v®
 
rv64u
 = 
Li¡
(
rv64ui
, 
rv64um
)

164 
v®
 
rv64i
 = 
Li¡
(
rv64ui
, 
rv64si
, 
rv64mi
)

165 
v®
 
rv64pi
 = 
Li¡
(
rv64ui
, 
rv64mi
)

167 
v®
 
b’chm¬ks
 = 
Ãw
 
B’chm¬kTe¡Su™e
("rvi", "$(RISCV)/riscv64-unknown-–f/sh¬e/riscv-‹¡s/b’chm¬ks", 
LškedHashS‘
(

170 
v®
 
rv32udB’chm¬ks
 = 
Ãw
 
B’chm¬kTe¡Su™e
("rvd", "$(RISCV)/riscv64-unknown-–f/sh¬e/riscv-‹¡s/b’chm¬ks", 
LškedHashS‘
(

173 
v®
 
em±yBm¬ks
 = 
Ãw
 
B’chm¬kTe¡Su™e
("empty",

174 "$(RISCV)/riscv64-unknown-–f/sh¬e/riscv-‹¡s/b’chm¬ks", 
LškedHashS‘
.
em±y
)

176 
v®
 
sšgËReg»ssiÚ
 = 
Ãw
 
Reg»ssiÚTe¡Su™e
(
LškedHashS‘
("rv64ui-p-simple"))

178 
v®
 
mtBm¬ks
 = 
Ãw
 
B’chm¬kTe¡Su™e
("mt", "$(RISCV)/riscv64-unknown-elf/share/riscv-tests/mt",

179 
LškedHashS‘
(((0 
to
 4).
m­
("vvadd"+
_
) ++

180 
Li¡
("ad","ae","af","ag","ai","ak","al","am","an","ap","aq","ar","at","av","ay","az",

182 "cm","cs","cv","cy","dc","df","dm","do","dr","ds","du","dv").
m­
(
_
+"_matmul")): _*))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/TestHarness.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
sy¡em


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gdebug
.
Debug


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
LazyModuË


10 şas 
	cTe¡H¬Ãss
()(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

11 
v®
 
io
 = 
Ãw
 
BundË
 {

12 
v®
 
sucûss
 = 
	`BoŞ
(
OUTPUT
)

15 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
Exam¶eRock‘Sy¡em
).
moduË
)

16 
dut
.
»£t
 :ğ»£ˆ| dut.
debug
.
nd»£t


18 
dut
.
	$dÚtTouchPÜts
()

19 
dut
.
	$t›OffIÁ”ru±s
()

20 
dut
.
	$cÚÃùSimAXIMem
()

21 
dut
.
	$cÚÃùSimAXIMMIO
()

22 
dut
.
l2_äÚ‹nd_bus_axi4
.
	$fÜ—ch
(
_
.
t›off
)

23 
Debug
.
	`cÚÃùDebug
(
dut
.
debug
, 
şock
, 
»£t
, 
io
.
sucûss
)

24 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/BaseTile.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


15 
objeù
 
Sh¬edMemÜyTLEdge
 
ex‹nds
 
	gF›ld
[
TLEdgeOut
]

16 
objeù
 
TeKey
 
ex‹nds
 
	gF›ld
[
TeP¬ams
]

17 
objeù
 
Re£tVeùÜB™s
 
ex‹nds
 
	gF›ld
[
IÁ
]

18 
objeù
 
MaxH¬tIdB™s
 
ex‹nds
 
	gF›ld
[
IÁ
]

20 
ab¡¿ù
 cÏs 
	cLookupByH¬tIdIm¶
 {

21 
def
 
	m­¶y
[
T
 <: 
D©a
](
f
: 
TeP¬ams
 => 
O±iÚ
[T], 
	mh¬tId
: 
UIÁ
): T

23 
objeù
 
LookupByH¬tId
 
ex‹nds
 
F›ld
[
LookupByH¬tIdIm¶
]

25 
Œa™
 
TeP¬ams
 {

26 
v®
 
cÜe
: 
CÜeP¬ams


27 
v®
 
iÿche
: 
O±iÚ
[
ICacheP¬ams
]

28 
v®
 
dÿche
: 
O±iÚ
[
DCacheP¬ams
]

29 
v®
 
btb
: 
O±iÚ
[
BTBP¬ams
]

30 
v®
 
Œaû
: 
BoŞ—n


31 
v®
 
h¬tId
: 
IÁ


32 
v®
 
block”CŒlAddr
: 
O±iÚ
[
BigIÁ
]

33 
v®
 
Çme
: 
O±iÚ
[
SŒšg
]

36 
Œa™
 
HasTeP¬am‘”s
 {

37 
im¶ic™
 
v®
 
p
: 
P¬am‘”s


38 
def
 
teP¬ams
: 
TeP¬ams
 = 
p
(
TeKey
)

40 
def
 
usšgVM
: 
BoŞ—n
 = 
teP¬ams
.
cÜe
.
u£VM


41 
def
 
usšgU£r
: 
BoŞ—n
 = 
teP¬ams
.
cÜe
.
u£U£r
 || 
usšgVM


42 
def
 
usšgDebug
: 
BoŞ—n
 = 
teP¬ams
.
cÜe
.
u£Debug


43 
def
 
usšgRoCC
: 
BoŞ—n
 = !
p
(
BudRoCC
).
isEm±y


44 
def
 
usšgBTB
: 
BoŞ—n
 = 
teP¬ams
.
btb
.
isDefšed
 &&eP¬ams.btb.
g‘
.
nEÁr›s
 > 0

45 
def
 
usšgPTW
: 
BoŞ—n
 = 
usšgVM


46 
def
 
usšgD©aSü©ch·d
: 
BoŞ—n
 = 
teP¬ams
.
dÿche
.
æ©M­
(
_
.
sü©ch
).
isDefšed


48 
def
 
xL’
: 
IÁ
 = 
p
(
XL’
)

49 
def
 
xBy‹s
: 
IÁ
 = 
xL’
 / 8

50 
def
 
iL’
: 
IÁ
 = 32

51 
def
 
pgIdxB™s
: 
IÁ
 = 12

52 
def
 
pgLev–B™s
: 
IÁ
 = 10 - 
log2Ce
(
xL’
 / 32)

53 
def
 
vaddrB™s
: 
IÁ
 =

54 ià(
usšgVM
) {

55 
v®
 
v
 = 
pgIdxB™s
 + 
pgLev–s
 * 
pgLev–B™s


56 
»quœe
(
v
 =ğ
xL’
 || xL’ > v && v > 
·ddrB™s
)

57 
v


61 (
·ddrB™s
 + 1è
mš
 
xL’


63 
def
 
·ddrB™s
: 
IÁ
 = 
p
(
Sh¬edMemÜyTLEdge
).
bundË
.
add»ssB™s


64 
def
 
v²B™s
: 
IÁ
 = 
vaddrB™s
 - 
pgIdxB™s


65 
def
 
µnB™s
: 
IÁ
 = 
·ddrB™s
 - 
pgIdxB™s


66 
def
 
pgLev–s
: 
IÁ
 = 
p
(
PgLev–s
)

67 
def
 
asIdB™s
: 
IÁ
 = 
p
(
ASIdB™s
)

68 
def
 
v²B™sEx‹nded
: 
IÁ
 = 
v²B™s
 + (
vaddrB™s
 < 
xL’
).
toIÁ


69 
def
 
vaddrB™sEx‹nded
: 
IÁ
 = 
v²B™sEx‹nded
 + 
pgIdxB™s


70 
def
 
maxPAddrB™s
: 
IÁ
 = 
xL’
 
m©ch
 { 32 => 34; 64 => 56 }

72 
def
 
	gh¬tId
: 
IÁ
 = 
teP¬ams
.
h¬tId


73 
def
 
h¬tIdL’
: 
IÁ
 = 
p
(
MaxH¬tIdB™s
)

74 
def
 
»£tVeùÜL’
: 
IÁ
 = 
·ddrB™s


76 
def
 
ÿcheBlockBy‹s
 = 
p
(
CacheBlockBy‹s
)

77 
def
 
lgCacheBlockBy‹s
 = 
log2Up
(
ÿcheBlockBy‹s
)

78 
def
 
ma¡”PÜtB—tBy‹s
 = 
p
(
Sy¡emBusKey
).
b—tBy‹s


82 
def
 
dÿcheArbPÜts
 = 1 + 
usšgVM
.
toIÁ
 + 
usšgD©aSü©ch·d
.toIÁ + 
p
(
BudRoCC
).
size


85 
def
 
i§DTS
: 
SŒšg
 = {

86 
v®
 
m
 = ià(
teP¬ams
.
cÜe
.
mulDiv
.
nÚEm±y
) "m" ""

87 
v®
 
a
 = ià(
teP¬ams
.
cÜe
.
u£Atomics
) "a" ""

88 
v®
 
f
 = ià(
teP¬ams
.
cÜe
.
åu
.
nÚEm±y
) "f" ""

89 
v®
 
d
 = ià(
teP¬ams
.
cÜe
.
åu
.
nÚEm±y
 &&eP¬ams.cÜe.åu.
g‘
.
fL’
 > 32) "d" ""

90 
v®
 
c
 = ià(
teP¬ams
.
cÜe
.
u£Com´es£d
) "c" ""

91 
s
"rv${p(XLen)}i$m$a$f$d$c"

94 
def
 
tePrİ”t›s
: 
Prİ”tyM­
 = {

95 
v®
 
dÿche
 = 
teP¬ams
.dÿche.
f‹r
(!
_
.
sü©ch
.
isDefšed
).
m­
(
d
 => 
M­
(

96 "d-ÿche-block-size" -> 
ÿcheBlockBy‹s
.
asPrİ”ty
,

97 "d-ÿche-£ts" -> 
d
.
nS‘s
.
asPrİ”ty
,

98 "d-ÿche-size" -> (
d
.
nS‘s
 * d.
nWays
 * 
ÿcheBlockBy‹s
).
asPrİ”ty
)

99 ).
g‘OrEl£
(
N
)

101 
v®
 
	gšcoh”’t
 = ià(!
teP¬ams
.
cÜe
.
u£AtomicsOÆyFÜIO
è
N
 
M­
(

102 "sifive,d-ÿche-šcoh”’t" -> 
N
)

104 
v®
 
iÿche
 = 
teP¬ams
.iÿche.
m­
(
i
 => 
M­
(

105 "i-ÿche-block-size" -> 
ÿcheBlockBy‹s
.
asPrİ”ty
,

106 "i-ÿche-£ts" -> 
i
.
nS‘s
.
asPrİ”ty
,

107 "i-ÿche-size" -> (
i
.
nS‘s
 * i.
nWays
 * 
ÿcheBlockBy‹s
).
asPrİ”ty
)

108 ).
g‘OrEl£
(
N
)

110 
v®
 
	gdb
 = 
teP¬ams
.
dÿche
.
f‹r
(
_
 =>eP¬ams.
cÜe
.
u£VM
).
m­
(
d
 => 
M­
(

111 "d-b-size" -> 
d
.
nTLBEÁr›s
.
asPrİ”ty
,

112 "d-b-£ts" -> 1.a
sPrİ”ty
)).
g‘OrEl£
(
N
)

114 
v®
 
	g™lb
 = 
teP¬ams
.
iÿche
.
f‹r
(
_
 =>eP¬ams.
cÜe
.
u£VM
).
m­
(
i
 => 
M­
(

115 "i-b-size" -> 
i
.
nTLBEÁr›s
.
asPrİ”ty
,

116 "i-b-£ts" -> 1.a
sPrİ”ty
)).
g‘OrEl£
(
N
)

118 
v®
 
	gmmu
 = ià(!
teP¬ams
.
cÜe
.
u£VM
è
N
 
M­
(

119 "b-¥l™" -> 
N
,

120 "mmu-ty³" -> (
p
(
PgLev–s
è
m©ch
 {

124 }).
asPrİ”ty
)

126 
	gdÿche
 ++ 
	giÿche
 ++ 
	gdb
 ++ 
	g™lb
 ++ 
	gmmu
 ++ 
	gšcoh”’t


132 
ab¡¿ù
 
şass
 
	$Ba£Te
(
teP¬ams
: 
TeP¬ams
, 
v®
 
üossšg
: 
ClockCrossšgTy³
)

133 (
im¶ic™
 
p
: 
P¬am‘”s
)

134 
ex‹nds
 
LazyModuË
 
w™h
 
Cros£sToOÆyOÃClockDomaš
 w™h 
HasTeP¬am‘”s
 {

135 
def
 
moduË
: 
Ba£TeModuËImp
[
Ba£Te
]

136 
def
 
ma¡”Node
: 
TLOutw¬dNode


137 
def
 
¦aveNode
: 
TLInw¬dNode


138 
def
 
štInw¬dNode
: 
IÁInw¬dNode


139 
def
 
štOutw¬dNode
: 
IÁOutw¬dNode


141 
´Ùeùed
 
v®
 
Oth”Ma¡”sNode
 = 
	`TLId’t™yNode
()

142 
´Ùeùed
 
v®
 
Ma¡”Xb¬
 = 
	`LazyModuË
(
Ãw
 
TLXb¬
)

143 
´Ùeùed
 
v®
 
SÏveXb¬
 = 
	`LazyModuË
(
Ãw
 
TLXb¬
)

144 
´Ùeùed
 
v®
 
štXb¬
 = 
	`LazyModuË
(
Ãw
 
IÁXb¬
)

146 
def
 
	`cÚÃùTLSÏve
(
node
: 
TLNode
, 
by‹s
: 
IÁ
) {

147 
Di§bËMÚ™Üs
 { 
im¶ic™
 
p
 =>

148 (
	`Seq
(
node
, 
	`TLF¿gm’‹r
(
by‹s
, 
ÿcheBlockBy‹s
, 
—¾yAck
=
E¬lyAck
.
PutFuÎs
))

149 ++ (
xBy‹s
 !ğ
by‹s
).
	`İtiÚ
(
	`TLWidthWidg‘
(xBytes)))

150 .
	`fŞdRight
(
SÏveXb¬
.
node
:
TLOutw¬dNode
)(
_
 :*= _)

155 
def
 
ÃxtLev–CachePrİ”ty
: 
Prİ”tyO±iÚ
 = {

156 
v®
 
ou‹r
 = 
Ma¡”Xb¬
.
node
.
edges
.
out


157 .
	`æ©M­
(
_
.
mªag”
.
mªag”s
)

158 .
	`f‹r
(
_
.
suµÜtsAcquœeB
)

159 .
	`æ©M­
(
_
.
»sourûs
.
h—dO±iÚ
)

160 .
	`m­
(
_
.
owÃr
.
Ïb–
)

161 .
di¡šù


162 ià(
ou‹r
.
isEm±y
è
NÚe


163 
	`Some
("Ãxt-Ëv–-ÿche" -> 
ou‹r
.
	`m­
(
l
 => 
	`ResourûReã»nû
Ö)).
toLi¡
)

166 
def
 
ıuPrİ”t›s
: 
Prİ”tyM­
 = 
	`M­
(

167 "deviû_ty³" -> "ıu".
asPrİ”ty
,

168 "¡©us" -> "okay".
asPrİ”ty
,

169 "şock-äequ’cy" -> 
teP¬ams
.
cÜe
.
boÙF»qHz
.
asPrİ”ty
,

170 "riscv,i§" -> 
i§DTS
.
asPrİ”ty
,

171 "timeba£-äequ’cy" -> 
	`p
(
DTSTimeba£
).
asPrİ”ty
)

175 
´Ùeùed
 
def
 
	`makeMa¡”Bound¬yBufãrs
(
im¶ic™
 
p
: 
P¬am‘”s
èğ
	`TLBufãr
(
BufãrP¬ams
.
nÚe
)

176 
def
 
	`üossMa¡”PÜt
(): 
TLOutw¬dNode
 = {

177 
v®
 
Ma¡”Xšg
 = 
this
.
	`üossOut
(
üossšg
 
m©ch
 {

178 
	`R©iÚ®Crossšg
(
_
è=> 
this
 { 
makeMa¡”Bound¬yBufãrs
 } :=* 
ma¡”Node


179 
_
 => 
ma¡”Node


181 
	`Ma¡”Xšg
(
üossšg
)

184 
´Ùeùed
 
def
 
	`makeSÏveBound¬yBufãrs
(
im¶ic™
 
p
: 
P¬am‘”s
èğ
	`TLBufãr
(
BufãrP¬ams
.
nÚe
)

185 
def
 
	`üossSÏvePÜt
(): 
TLInw¬dNode
 = { 
Di§bËMÚ™Üs
 { 
im¶ic™
 
p
 =>

186 
v®
 
SÏveXšg
 = 
this
.
	`üossIn
(
üossšg
 
m©ch
 {

187 
	`R©iÚ®Crossšg
(
_
è=> 
¦aveNode
 :*ğ
this
 { 
makeSÏveBound¬yBufãrs
 }

188 
_
 => 
¦aveNode


190 
	`SÏveXšg
(
üossšg
)

193 
def
 
	`üossIÁIn
(): 
IÁInw¬dNode
 = crossIÁIn(
štInw¬dNode
)

194 
def
 
	`üossIÁOut
(): 
IÁOutw¬dNode
 = crossIÁOut(
štOutw¬dNode
)

195 
	}
}

197 
ab¡¿ù
 
şass
 
Ba£TeModuËImp
[+
L
 <: 
Ba£Te
](
v®
 
ou‹r
: Lè
ex‹nds
 
	$LazyModuËImp
(
ou‹r
è
w™h
 
HasTeP¬am‘”s
 {

199 
	`»quœe
(
xL’
 == 32 || xLen == 64)

200 
	`»quœe
(
·ddrB™s
 <ğ
maxPAddrB™s
)

201 
	`»quœe
(
»£tVeùÜL’
 <ğ
xL’
)

202 
	`»quœe
(
»£tVeùÜL’
 <ğ
vaddrB™sEx‹nded
)

203 
	`»quœe
 (
	`log2Up
(
h¬tId
 + 1è<ğ
h¬tIdL’
, 
s
"p(MaxHartIdBits) of $hartIdLen is‚otƒnough for hartid $hartId")

205 
v®
 
Œaû
 = 
teP¬ams
.Œaû.
	`İtiÚ
(
	`IO
(
	`Vec
ÑeP¬ams.
cÜe
.
»tœeWidth
, 
Ãw
 
T¿ûdIn¡ruùiÚ
).
asOuut
))

206 
v®
 
cÚ¡ªts
 = 
	`IO
(
Ãw
 
TeIÅutCÚ¡ªts
)

208 
v®
 
h®t_ªd_ÿtch_fœe
: 
O±iÚ
[
BoŞ
]

209 
	}
}

212 
Œa™
 
HasEx‹º®lyDriv’TeCÚ¡ªts
 
ex‹nds
 
BundË
 
w™h
 
HasTeP¬am‘”s
 {

213 
v®
 
h¬tid
 = 
UIÁ
(
INPUT
, 
h¬tIdL’
)

214 
v®
 
	g»£t_veùÜ
 = 
UIÁ
(
INPUT
, 
»£tVeùÜL’
)

217 
şass
 
	$TeIÅutCÚ¡ªts
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
P¬am‘”izedBundË
 
w™h
 
HasEx‹º®lyDriv’TeCÚ¡ªts


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Core.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
objeù
 
XL’
 
ex‹nds
 
	gF›ld
[
IÁ
]

14 
Œa™
 
	gCÜeP¬ams
 {

15 
v®
 
	gboÙF»qHz
: 
BigIÁ


16 
v®
 
u£VM
: 
BoŞ—n


17 
v®
 
u£U£r
: 
BoŞ—n


18 
v®
 
u£Debug
: 
BoŞ—n


19 
v®
 
u£Atomics
: 
BoŞ—n


20 
v®
 
u£AtomicsOÆyFÜIO
: 
BoŞ—n


21 
v®
 
u£Com´es£d
: 
BoŞ—n


22 
v®
 
u£SCIE
: 
BoŞ—n


23 
v®
 
mulDiv
: 
O±iÚ
[
MulDivP¬ams
]

24 
v®
 
åu
: 
O±iÚ
[
FPUP¬ams
]

25 
v®
 
ãtchWidth
: 
IÁ


26 
v®
 
decodeWidth
: 
IÁ


27 
v®
 
»tœeWidth
: 
IÁ


28 
v®
 
š¡B™s
: 
IÁ


29 
v®
 
nLoÿlIÁ”ru±s
: 
IÁ


30 
v®
 
nPMPs
: 
IÁ


31 
v®
 
pmpG¿nuÏr™y
: 
IÁ


32 
v®
 
nB»akpošts
: 
IÁ


33 
v®
 
nP”fCouÁ”s
: 
IÁ


34 
v®
 
haveBasicCouÁ”s
: 
BoŞ—n


35 
v®
 
haveFSDœty
: 
BoŞ—n


36 
v®
 
mi§Wr™abË
: 
BoŞ—n


37 
v®
 
nL2TLBEÁr›s
: 
IÁ


38 
v®
 
mtvecIn™
: 
O±iÚ
[
BigIÁ
]

39 
v®
 
mtvecWr™abË
: 
BoŞ—n


40 
v®
 
teCÚŒŞAddr
: 
O±iÚ
[
BigIÁ
]

41 
def
 
cu¡omCSRs
(
im¶ic™
 
p
: 
P¬am‘”s
): 
Cu¡omCSRs
 = 
Ãw
 CustomCSRs

42 
v®
 
hasPrivCodeLock
: 
BoŞ—n
 = 
çl£


43 
v®
 
numPCodeRªges
: 
IÁ
 = 4

44 
def
 
š¡By‹s
: 
IÁ
 = 
š¡B™s
 / 8

45 
def
 
ãtchBy‹s
: 
IÁ
 = 
ãtchWidth
 * 
š¡By‹s


46 
def
 
ÌscCyşes
: 
IÁ


49 
Œa™
 
HasCÜeP¬am‘”s
 
ex‹nds
 
HasTeP¬am‘”s
 {

50 
v®
 
cÜeP¬ams
: 
CÜeP¬ams
 = 
teP¬ams
.
cÜe


52 
v®
 
fL’
 = 
cÜeP¬ams
.
åu
.
m­
(
_
.fL’).
g‘OrEl£
(0)

54 
v®
 
usšgMulDiv
 = 
cÜeP¬ams
.
mulDiv
.
nÚEm±y


55 
v®
 
usšgFPU
 = 
cÜeP¬ams
.
åu
.
nÚEm±y


56 
v®
 
usšgAtomics
 = 
cÜeP¬ams
.
u£Atomics


57 
v®
 
usšgAtomicsOÆyFÜIO
 = 
cÜeP¬ams
.
u£AtomicsOÆyFÜIO


58 
v®
 
usšgAtomicsInCache
 = 
usšgAtomics
 && !
usšgAtomicsOÆyFÜIO


59 
v®
 
usšgCom´es£d
 = 
cÜeP¬ams
.
u£Com´es£d


60 
v®
 
usšgSCIE
 = 
cÜeP¬ams
.
u£SCIE


62 
v®
 
»tœeWidth
 = 
cÜeP¬ams
.retireWidth

63 
v®
 
ãtchWidth
 = 
cÜeP¬ams
.fetchWidth

64 
v®
 
decodeWidth
 = 
cÜeP¬ams
.decodeWidth

66 
v®
 
ãtchBy‹s
 = 
cÜeP¬ams
.fetchBytes

67 
v®
 
cÜeIn¡B™s
 = 
cÜeP¬ams
.
š¡B™s


68 
v®
 
cÜeIn¡By‹s
 = 
cÜeIn¡B™s
/8

69 
v®
 
cÜeD©aB™s
 = 
xL’
 
max
 
fL’


70 
v®
 
cÜeD©aBy‹s
 = 
cÜeD©aB™s
/8

71 
v®
 
cÜeMaxAddrB™s
 = 
·ddrB™s
 
max
 
vaddrB™sEx‹nded


73 
v®
 
nB»akpošts
 = 
cÜeP¬ams
.nBreakpoints

74 
v®
 
nPMPs
 = 
cÜeP¬ams
.nPMPs

75 
v®
 
pmpG¿nuÏr™y
 = 
cÜeP¬ams
.pmpGranularity

76 
v®
 
nP”fCouÁ”s
 = 
cÜeP¬ams
.nPerfCounters

77 
v®
 
mtvecIn™
 = 
cÜeP¬ams
.mtvecInit

78 
v®
 
mtvecWr™abË
 = 
cÜeP¬ams
.mtvecWritable

80 
v®
 
cÜeDCacheReqTagB™s
 = 6

81 
v®
 
dÿcheReqTagB™s
 = 
cÜeDCacheReqTagB™s
 + 
log2Ce
(
dÿcheArbPÜts
)

85 
v®
 
’abËComm™Log
 = 
çl£


87 
def
 
hasPrivCodeLock
 = 
cÜeP¬ams
.hasPrivCodeLock

88 
def
 
numPCodeRªges
 = 
cÜeP¬ams
.numPCodeRanges

91 
ab¡¿ù
 cÏs 
	cCÜeModuË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË


92 
w™h
 
HasCÜeP¬am‘”s


94 
ab¡¿ù
 cÏs 
	cCÜeBundË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
)

95 
w™h
 
HasCÜeP¬am‘”s


97 şas 
	cCÜeIÁ”ru±s
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$TeIÁ”ru±s
()(
p
) {

98 
v®
 
bu£¼Ü
 = 
cÜeP¬ams
.
teCÚŒŞAddr
.
	`m­
(
a
 => 
	`BoŞ
())

101 
Œa™
 
HasCÜeIO
 
ex‹nds
 
HasTeP¬am‘”s
 {

102 
im¶ic™
 
v®
 
p
: 
P¬am‘”s


103 
v®
 
io
 = 
Ãw
 
	`CÜeBundË
()(
p
è
w™h
 
HasEx‹º®lyDriv’TeCÚ¡ªts
 {

104 
v®
 
š‹¼u±s
 = 
Ãw
 
	`CÜeIÁ”ru±s
().
asIÅut


105 
v®
 
imem
 = 
Ãw
 
FrÚ‹ndIO


106 
v®
 
dmem
 = 
Ãw
 
H–ÏCacheIO


107 
v®
 
±w
 = 
Ãw
 
	`D©­©hPTWIO
().
æ


108 
v®
 
åu
 = 
Ãw
 
	`FPUCÜeIO
().
æ


109 
v®
 
rocc
 = 
Ãw
 
	`RoCCCÜeIO
().
æ


110 
v®
 
Œaû
 = 
	`Vec
(
cÜeP¬ams
.
»tœeWidth
, 
Ãw
 
T¿ûdIn¡ruùiÚ
).
asOuut


112 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/CustomCSRs.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


5 
impÜt
 
	gchi£l3
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
şass
 
	$Cu¡omCSR
(
id
: 
IÁ
, 
mask
: 
BigIÁ
, 
š™
: 
O±iÚ
[BigInt])

11 
objeù
 
Cu¡omCSR
 {

12 
def
 
	`cÚ¡ªt
(
id
: 
IÁ
, 
v®ue
: 
BigIÁ
): 
Cu¡omCSR
 = 
	`Cu¡omCSR
(id, 
	`BigIÁ
(0), 
	`Some
(value))

13 
	}
}

15 şas 
	cCu¡omCSRIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
CÜeBundË
 {

16 
v®
 
w’
 = 
	$BoŞ
()

17 
v®
 
wd©a
 = 
	$UIÁ
(
xL’
.
W
)

18 
v®
 
v®ue
 = 
	`UIÁ
(
xL’
.
W
)

21 şas 
	cCu¡omCSRs
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
CÜeBundË
 {

24 
´Ùeùed
 
def
 
bpmCSRId
 = 0x7c0

25 
´Ùeùed
 
def
 
bpmCSR
: 
O±iÚ
[
Cu¡omCSR
] = 
NÚe


27 
´Ùeùed
 
def
 
chick’CSRId
 = 0x7c1

28 
´Ùeùed
 
def
 
chick’CSR
: 
O±iÚ
[
Cu¡omCSR
] = 
NÚe


31 
def
 
deşs
: 
Seq
[
Cu¡omCSR
] = 
bpmCSR
.
toSeq
 ++ 
chick’CSR


33 
v®
 
c¤s
 = 
	$Vec
(
deşs
.
size
, 
Ãw
 
Cu¡omCSRIO
)

35 
def
 
æushBTB
 = 
	$g‘OrEl£
(
bpmCSR
, 
_
.
w’
, 
çl£
.
B
)

36 
def
 
bpmStic
 = 
	`g‘OrEl£
(
bpmCSR
, 
_
.
	`v®ue
(0), 
çl£
.
B
)

37 
def
 
di§bËDCacheClockG©e
 = 
	`g‘OrEl£
(
chick’CSR
, 
_
.
	`v®ue
(0), 
Œue
.
B
)

38 
def
 
di§bËICacheClockG©e
 = 
	`g‘OrEl£
(
chick’CSR
, 
_
.
	`v®ue
(1), 
Œue
.
B
)

39 
def
 
di§bËCÜeClockG©e
 = 
	`g‘OrEl£
(
chick’CSR
, 
_
.
	`v®ue
(2), 
Œue
.
B
)

41 
´Ùeùed
 
def
 
g‘ByIdOrEl£
[
T
](
id
: 
IÁ
, 
f
: 
Cu¡omCSRIO
 => T, 
®t
: T): T = {

42 
v®
 
idx
 = 
deşs
.
	`šdexWh”e
(
_
.
id
 == id)

43 ià(
idx
 < 0è
®t
 
	`f
(
	`c¤s
(idx))

46 
´Ùeùed
 
def
 
g‘OrEl£
[
T
](
c¤
: 
O±iÚ
[
Cu¡omCSR
], 
f
: 
Cu¡omCSRIO
 => T, 
®t
: T): T =

47 
c¤
.
	`m­
(
c
 => 
	`g‘ByIdOrEl£
(c.
id
, 
f
, 
®t
)).
	`g‘OrEl£
(alt)

48 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/FPU.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gChi£l
.
	gIm¶ic™CÚv”siÚs
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
	gIn¡ruùiÚs
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


14 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


15 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
_


17 
şass
 
	$FPUP¬ams
(

18 
fL’
: 
IÁ
 = 64,

19 
divSq¹
: 
BoŞ—n
 = 
Œue
,

20 
sfmaL©’cy
: 
IÁ
 = 3,

21 
dfmaL©’cy
: 
IÁ
 = 4

24 
objeù
 
FPCÚ¡ªts


26 
v®
 
RM_SZ
 = 3

27 
v®
 
FLAGS_SZ
 = 5

28 
	}
}

29 
impÜt
 
FPCÚ¡ªts
.
_


31 
Œa™
 
HasFPUCŒlSigs
 {

32 
v®
 
ld¡
 = 
BoŞ
()

33 
v®
 
w’
 = 
BoŞ
()

34 
v®
 
»n1
 = 
BoŞ
()

35 
v®
 
»n2
 = 
BoŞ
()

36 
v®
 
»n3
 = 
BoŞ
()

37 
v®
 
sw­12
 = 
BoŞ
()

38 
v®
 
sw­23
 = 
BoŞ
()

39 
v®
 
sšgËIn
 = 
BoŞ
()

40 
v®
 
sšgËOut
 = 
BoŞ
()

41 
v®
 
äomšt
 = 
BoŞ
()

42 
v®
 
tošt
 = 
BoŞ
()

43 
v®
 
ç¡pe
 = 
BoŞ
()

44 
v®
 
fma
 = 
BoŞ
()

45 
v®
 
div
 = 
BoŞ
()

46 
v®
 
sq¹
 = 
BoŞ
()

47 
v®
 
wæags
 = 
BoŞ
()

50 şas 
	cFPUCŒlSigs
 
ex‹nds
 
BundË
 
w™h
 
HasFPUCŒlSigs


52 şas 
	cFPUDecod”
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$FPUModuË
()(
p
) {

53 
v®
 
io
 = 
Ãw
 
BundË
 {

54 
v®
 
š¡
 = 
	`B™s
(
INPUT
, 32)

55 
v®
 
sigs
 = 
Ãw
 
	`FPUCŒlSigs
().
asOuut


58 
v®
  = 
	$Li¡
(
X
,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X)

59 
v®
 
f
 =

60 
	`A¼ay
(
FLW
 -> 
	`Li¡
(
Y
,Y,
N
,N,N,
X
,X,X,X,N,N,N,N,N,N,N),

61 
FSW
 -> 
	`Li¡
(
Y
,
N
,N,Y,N,Y,
X
,N,Y,N,Y,N,N,N,N,N),

62 
FMV_S_X
 -> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,Y,N,Y,N,N,N,N,N,N),

63 
FCVT_S_W
 -> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

64 
FCVT_S_WU
-> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

65 
FCVT_S_L
 -> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

66 
FCVT_S_LU
-> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,Y,Y,Y,N,N,N,N,N,Y),

67 
FMV_X_S
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,N,Y,N,Y,N,N,N,N,N),

68 
FCLASS_S
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,N),

69 
FCVT_W_S
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

70 
FCVT_WU_S
-> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

71 
FCVT_L_S
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

72 
FCVT_LU_S
-> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,Y,Y,N,Y,N,N,N,N,Y),

73 
FEQ_S
 -> 
	`Li¡
(
N
,N,
Y
,Y,N,N,N,Y,Y,N,Y,N,N,N,N,Y),

74 
FLT_S
 -> 
	`Li¡
(
N
,N,
Y
,Y,N,N,N,Y,Y,N,Y,N,N,N,N,Y),

75 
FLE_S
 -> 
	`Li¡
(
N
,N,
Y
,Y,N,N,N,Y,Y,N,Y,N,N,N,N,Y),

76 
FSGNJ_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,N),

77 
FSGNJN_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,N),

78 
FSGNJX_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,N),

79 
FMIN_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,Y),

80 
FMAX_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,Y,N,N,N,Y),

81 
FADD_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,Y,Y,Y,N,N,N,Y,N,N,Y),

82 
FSUB_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,Y,Y,Y,N,N,N,Y,N,N,Y),

83 
FMUL_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,N,Y,N,N,Y),

84 
FMADD_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

85 
FMSUB_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

86 
FNMADD_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

87 
FNMSUB_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,Y,Y,N,N,N,Y,N,N,Y),

88 
FDIV_S
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,Y,Y,N,N,N,N,Y,N,Y),

89 
FSQRT_S
 -> 
	$Li¡
(
N
,
Y
,Y,N,N,N,
X
,Y,Y,N,N,N,N,N,Y,Y))

90 
v®
 
d
 =

91 
	`A¼ay
(
FLD
 -> 
	`Li¡
(
Y
,Y,
N
,N,N,
X
,X,X,N,N,N,N,N,N,N,N),

92 
FSD
 -> 
	`Li¡
(
Y
,
N
,N,Y,N,Y,
X
,N,N,N,Y,N,N,N,N,N),

93 
FMV_D_X
 -> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,X,N,Y,N,N,N,N,N,N),

94 
FCVT_D_W
 -> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

95 
FCVT_D_WU
-> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

96 
FCVT_D_L
 -> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

97 
FCVT_D_LU
-> 
	`Li¡
(
N
,
Y
,N,N,N,
X
,X,N,N,Y,N,N,N,N,N,Y),

98 
FMV_X_D
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,N),

99 
FCLASS_D
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,N),

100 
FCVT_W_D
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

101 
FCVT_WU_D
-> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

102 
FCVT_L_D
 -> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

103 
FCVT_LU_D
-> 
	`Li¡
(
N
,N,
Y
,N,N,N,
X
,N,N,N,Y,N,N,N,N,Y),

104 
FCVT_S_D
 -> 
	`Li¡
(
N
,
Y
,Y,N,N,N,
X
,N,Y,N,N,Y,N,N,N,Y),

105 
FCVT_D_S
 -> 
	`Li¡
(
N
,
Y
,Y,N,N,N,
X
,Y,N,N,N,Y,N,N,N,Y),

106 
FEQ_D
 -> 
	`Li¡
(
N
,N,
Y
,Y,N,N,N,N,N,N,Y,N,N,N,N,Y),

107 
FLT_D
 -> 
	`Li¡
(
N
,N,
Y
,Y,N,N,N,N,N,N,Y,N,N,N,N,Y),

108 
FLE_D
 -> 
	`Li¡
(
N
,N,
Y
,Y,N,N,N,N,N,N,Y,N,N,N,N,Y),

109 
FSGNJ_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,N),

110 
FSGNJN_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,N),

111 
FSGNJX_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,N),

112 
FMIN_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,Y),

113 
FMAX_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,Y,N,N,N,Y),

114 
FADD_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,Y,N,N,N,N,N,Y,N,N,Y),

115 
FSUB_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,Y,N,N,N,N,N,Y,N,N,Y),

116 
FMUL_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,N,Y,N,N,Y),

117 
FMADD_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

118 
FMSUB_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

119 
FNMADD_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

120 
FNMSUB_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,Y,N,N,N,N,N,N,N,Y,N,N,Y),

121 
FDIV_D
 -> 
	`Li¡
(
N
,
Y
,Y,Y,N,N,N,N,N,N,N,N,N,Y,N,Y),

122 
FSQRT_D
 -> 
	$Li¡
(
N
,
Y
,Y,N,N,N,
X
,N,N,N,N,N,N,N,Y,Y))

124 
v®
 
š¢s
 = 
fL’
 
m©ch
 {

125 32 => 
f


126 64 => 
f
 ++ 
d


127 
	}
}

128 
v®
 
	gdecod”
 = 
	$DecodeLogic
(
io
.
š¡
, , 
š¢s
)

129 
v®
 
s
 = 
io
.
sigs


130 
v®
 
sigs
 = 
	$Seq
(
s
.
ld¡
, s.
w’
, s.
»n1
, s.
»n2
, s.
»n3
, s.
sw­12
,

131 
s
.
sw­23
, s.
sšgËIn
, s.
sšgËOut
, s.
äomšt
, s.
tošt
,

132 
s
.
ç¡pe
, s.
fma
, s.
div
, s.
sq¹
, s.
wæags
)

133 
sigs
 
z
 
decod”
 
m­
 {(
s
,
d
è=> s :ğ
	}
d}

136 şas 
	cFPUCÜeIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

137 
v®
 
š¡
 = 
	$B™s
(
INPUT
, 32)

138 
v®
 
äomšt_d©a
 = 
	$B™s
(
INPUT
, 
xL’
)

140 
v®
 
fc¤_rm
 = 
	$B™s
(
INPUT
, 
FPCÚ¡ªts
.
RM_SZ
)

141 
v®
 
fc¤_æags
 = 
	`V®id
(
	$B™s
(
width
 = 
FPCÚ¡ªts
.
FLAGS_SZ
))

143 
v®
 
¡Üe_d©a
 = 
	$B™s
(
OUTPUT
, 
fL’
)

144 
v®
 
tošt_d©a
 = 
	$B™s
(
OUTPUT
, 
xL’
)

146 
v®
 
dmem_»¥_v®
 = 
	$BoŞ
(
INPUT
)

147 
v®
 
dmem_»¥_ty³
 = 
	$B™s
(
INPUT
, 3)

148 
v®
 
dmem_»¥_g
 = 
	$UIÁ
(
INPUT
, 5)

149 
v®
 
dmem_»¥_d©a
 = 
	$B™s
(
INPUT
, 
fL’
)

151 
v®
 
v®id
 = 
	$BoŞ
(
INPUT
)

152 
v®
 
fc¤_rdy
 = 
	$BoŞ
(
OUTPUT
)

153 
v®
 
Çck_mem
 = 
	$BoŞ
(
OUTPUT
)

154 
v®
 
Ëg®_rm
 = 
	$BoŞ
(
OUTPUT
)

155 
v®
 
klx
 = 
	$BoŞ
(
INPUT
)

156 
v®
 
klm
 = 
	$BoŞ
(
INPUT
)

157 
v®
 
dec
 = 
Ãw
 
	`FPUCŒlSigs
().
asOuut


158 
v®
 
sbßrd_£t
 = 
	$BoŞ
(
OUTPUT
)

159 
v®
 
sbßrd_şr
 = 
	$BoŞ
(
OUTPUT
)

160 
v®
 
sbßrd_ş¿
 = 
	$UIÁ
(
OUTPUT
, 5)

162 
v®
 
k“p_şock_’abËd
 = 
	`BoŞ
(
INPUT
)

165 şas 
	cFPUIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$FPUCÜeIO
 ()(
p
) {

166 
v®
 
ı_»q
 = 
	`Decou¶ed
(
Ãw
 
	`FPIÅut
()).
æ


167 
v®
 
ı_»¥
 = 
	`Decou¶ed
(
Ãw
 
	`FPResuÉ
())

170 şas 
	cFPResuÉ
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

171 
v®
 
d©a
 = 
	`B™s
(
width
 = 
fL’
+1)

172 
v®
 
exc
 = 
	`B™s
(
width
 = 
FPCÚ¡ªts
.
FLAGS_SZ
)

175 şas 
	cIÁToFPIÅut
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
è
w™h
 
HasFPUCŒlSigs
 {

176 
v®
 
rm
 = 
	$B™s
(
width
 = 
FPCÚ¡ªts
.
RM_SZ
)

177 
v®
 
typ
 = 
	$B™s
(
width
 = 2)

178 
v®
 
š1
 = 
	`B™s
(
width
 = 
xL’
)

181 şas 
	cFPIÅut
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
è
w™h
 
HasFPUCŒlSigs
 {

182 
v®
 
rm
 = 
	$B™s
(
width
 = 
FPCÚ¡ªts
.
RM_SZ
)

183 
v®
 
fmaCmd
 = 
	$B™s
(
width
 = 2)

184 
v®
 
typ
 = 
	$B™s
(
width
 = 2)

185 
v®
 
š1
 = 
	`B™s
(
width
 = 
fL’
+1)

186 
v®
 
š2
 = 
	`B™s
(
width
 = 
fL’
+1)

187 
v®
 
š3
 = 
	`B™s
(
width
 = 
fL’
+1)

189 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`FPIÅut
().
asIn¡ªûOf
[
this
.
ty³
]

192 
şass
 
	$FTy³
(
exp
: 
IÁ
, 
sig
: Int) {

193 
def
 
›“Width
 = 
exp
 + 
sig


194 
def
 
»codedWidth
 = 
›“Width
 + 1

196 
def
 
qNaN
 = 
	`UIÁ
((
	`BigIÁ
(7è<< (
exp
 + 
sig
 - 3)) + (BigInt(1) << (sig - 2)),ƒxp + sig + 1)

197 
def
 
	`isNaN
(
x
: 
UIÁ
èğ
	`x
(
sig
 + 
exp
 - 1, sig +ƒx°- 3).
ªdR


198 
def
 
	`isSNaN
(
x
: 
UIÁ
èğ
	`isNaN
(xè&& !
	`x
(
sig
 - 2)

200 
def
 
	`şassify
(
x
: 
UIÁ
) = {

201 
v®
 
sign
 = 
	`x
(
sig
 + 
exp
)

202 
v®
 
code
 = 
	`x
(
exp
 + 
sig
 - 1,ƒxp + sig - 3)

203 
v®
 
codeHi
 = 
	`code
(2, 1)

204 
v®
 
isS³cŸl
 = 
codeHi
 ==ğ
	`UIÁ
(3)

206 
v®
 
isHighSubnÜm®In
 = 
	`x
(
exp
 + 
sig
 - 3, sig - 1è< 
	`UIÁ
(2)

207 
v®
 
isSubnÜm®
 = 
code
 ==ğ
	`UIÁ
(1è|| 
codeHi
 ==ğUIÁ(1è&& 
isHighSubnÜm®In


208 
v®
 
isNÜm®
 = 
codeHi
 ==ğ
	`UIÁ
(1è&& !
isHighSubnÜm®In
 || codeHi === UInt(2)

209 
v®
 
isZ”o
 = 
code
 ==ğ
	`UIÁ
(0)

210 
v®
 
isInf
 = 
isS³cŸl
 && !
	`code
(0)

211 
v®
 
isNaN
 = 
code
.
ªdR


212 
v®
 
isSNaN
 = 
isNaN
 && !
	`x
(
sig
-2)

213 
v®
 
isQNaN
 = 
isNaN
 && 
	`x
(
sig
-2)

215 
	`C©
(
isQNaN
, 
isSNaN
, 
isInf
 && !
sign
, 
isNÜm®
 && !sign,

216 
isSubnÜm®
 && !
sign
, 
isZ”o
 && !sign, isZero && sign,

217 
isSubnÜm®
 && 
sign
, 
isNÜm®
 && sign, 
isInf
 && sign)

221 
def
 
	`un§ãCÚv”t
(
x
: 
UIÁ
, 
to
: 
FTy³
èğià(
this
 ==o) x {

222 
v®
 
sign
 = 
	`x
(
sig
 + 
exp
)

223 
v®
 
äaùIn
 = 
	`x
(
sig
 - 2, 0)

224 
v®
 
expIn
 = 
	`x
(
sig
 + 
exp
 - 1, sig - 1)

225 
v®
 
äaùOut
 = 
äaùIn
 << 
to
.
sig
 >> sig

226 
v®
 
expOut
 = {

227 
v®
 
expCode
 = 
	`expIn
(
exp
,ƒxp - 2)

228 
v®
 
commÚCa£
 = (
expIn
 + (1 << 
to
.
exp
)) - (1 <<ƒxp)

229 
	`Mux
(
expCode
 ==ğ0 ||ƒxpCod>ğ6, 
	`C©
ÓxpCode, 
	`commÚCa£
(
to
.
exp
 - 3, 0)), commonCase(to.exp, 0))

231 
	`C©
(
sign
, 
expOut
, 
äaùOut
)

234 
def
 
	`»code
(
x
: 
UIÁ
èğ
h¬dæßt
.
	`»cFNFromFN
(
exp
, 
sig
, x)

235 
def
 
	`›“
(
x
: 
UIÁ
èğ
h¬dæßt
.
	`fNFromRecFN
(
exp
, 
sig
, x)

236 
	}
}

238 
objeù
 
	gFTy³
 {

239 
v®
 
	gS
 = 
Ãw
 
FTy³
(8, 24)

240 
v®
 
	gD
 = 
Ãw
 
FTy³
(11, 53)

242 
v®
 
	g®l
 = 
Li¡
(
S
, 
D
)

245 
Œa™
 
	gHasFPUP¬am‘”s
 {

246 
»quœe
(
fL’
 == 32 || fLen == 64)

247 
v®
 
fL’
: 
IÁ


248 
def
 
xL’
: 
IÁ


249 
v®
 
mšXL’
 = 32

250 
v®
 
nIÁTy³s
 = 
log2Ce
(
xL’
/
mšXL’
) + 1

251 
v®
 
æßtTy³s
 = 
FTy³
.
®l
.
f‹r
(
_
.
›“Width
 <ğ
fL’
)

252 
v®
 
mšTy³
 = 
æßtTy³s
.
h—d


253 
v®
 
maxTy³
 = 
æßtTy³s
.
Ï¡


254 
def
 
´evTy³
(
t
: 
FTy³
èğ
æßtTy³s
(
ty³Tag
(t) - 1)

255 
v®
 
maxExpWidth
 = 
maxTy³
.
exp


256 
v®
 
maxSigWidth
 = 
maxTy³
.
sig


257 
def
 
ty³Tag
(
t
: 
FTy³
èğ
æßtTy³s
.
šdexOf
(t)

259 
´iv©e
 
def
 
isBox
(
x
: 
UIÁ
, 
t
: 
FTy³
): 
BoŞ
 = xÑ.
sig
 +.
exp
,.sig +.ex°- 4).
ªdR


261 
´iv©e
 
def
 
box
(
x
: 
UIÁ
, 
xt
: 
FTy³
, 
y
: UIÁ, 
yt
: FType): UInt = {

262 
»quœe
(
xt
.
›“Width
 =ğ2 * 
yt
.ieeeWidth)

263 
v®
 
swizzËdNaN
 = 
C©
(

264 
x
(
xt
.
sig
 + xt.
exp
, xt.sig + xt.exp - 3),

265 
x
(
xt
.
sig
 - 2, 
yt
.
»codedWidth
 - 1).
ªdR
,

266 
x
(
xt
.
sig
 + xt.
exp
 - 5, xt.sig),

267 
y
(
yt
.
»codedWidth
 - 2),

268 
x
(
xt
.
sig
 - 2, 
yt
.
»codedWidth
 - 1),

269 
y
(
yt
.
»codedWidth
 - 1),

270 
y
(
yt
.
»codedWidth
 - 3, 0))

271 
Mux
(
xt
.
isNaN
(
x
), 
swizzËdNaN
, x)

275 
def
 
unbox
(
x
: 
UIÁ
, 
g
: UIÁ, 
exaùTy³
: 
O±iÚ
[
FTy³
]): UInt = {

276 
v®
 
outTy³
 = 
exaùTy³
.
g‘OrEl£
(
maxTy³
)

277 
def
 
h–³r
(
x
: 
UIÁ
, 
t
: 
FTy³
): 
Seq
[(
BoŞ
, UInt)] = {

278 
v®
 
´ev
 =

279 ià(
t
 =ğ
mšTy³
) {

280 
Seq
()

282 
v®
 
´evT
 = 
´evTy³
(
t
)

283 
v®
 
unswizzËd
 = 
C©
(

284 
x
(
´evT
.
sig
 +…»vT.
exp
 - 1),

285 
x
(
t
.
sig
 - 1),

286 
x
(
´evT
.
sig
 +…»vT.
exp
 - 2, 0))

287 
v®
 
	g´ev
 = 
h–³r
(
unswizzËd
, 
´evT
)

288 
v®
 
	gisbox
 = 
isBox
(
x
, 
t
)

289 
	g´ev
.
m­
(
p
 => (
isbox
 &&….
_1
,….
_2
))

291 
	g´ev
 :+ (
Œue
.
B
, 
	gt
.
un§ãCÚv”t
(
x
, 
outTy³
))

294 
v®
 (
oks
, 
æßts
èğ
h–³r
(
x
, 
maxTy³
).
unz


295 ià(
	gexaùTy³
.
	gisEm±y
 || 
	gæßtTy³s
.
	gsize
 == 1) {

296 
Mux
(
oks
(
g
), 
æßts
Ñag), 
maxTy³
.
qNaN
)

298 
v®
 
t
 = 
exaùTy³
.
g‘


299 
æßts
(
ty³Tag
(
t
)è| 
Mux
(
oks
Ñy³TagÑ)), 0.U,.
qNaN
)

304 
def
 
cÚsi¡’t
(
x
: 
UIÁ
): 
BoŞ
 = {

305 
def
 
h–³r
(
x
: 
UIÁ
, 
t
: 
FTy³
): 
BoŞ
 = ià(
ty³Tag
Ñè=ğ0è
Œue
.
B
 {

306 
v®
 
´evT
 = 
´evTy³
(
t
)

307 
v®
 
unswizzËd
 = 
C©
(

308 
x
(
´evT
.
sig
 +…»vT.
exp
 - 1),

309 
x
(
t
.
sig
 - 1),

310 
x
(
´evT
.
sig
 +…»vT.
exp
 - 2, 0))

311 
v®
 
	g´evOK
 = !
isBox
(
x
, 
t
è|| 
h–³r
(
unswizzËd
, 
´evT
)

312 
v®
 
	gcurOK
 = !
t
.
isNaN
(
x
è|| xÑ.
sig
 +.
exp
 - 4è==ğxÑ.sig - 2, 
´evT
.
»codedWidth
 - 1).
ªdR


313 
	g´evOK
 && 
	gcurOK


315 
h–³r
(
x
, 
maxTy³
)

319 
def
 
box
(
x
: 
UIÁ
, 
t
: 
FTy³
): UInt = {

320 ià(
t
 =ğ
maxTy³
) {

321 
x


323 
v®
 
Á
 = 
æßtTy³s
(
ty³Tag
(
t
) + 1)

324 
v®
 
bigg”
 = 
box
(
UIÁ
((
BigIÁ
(1è<< 
Á
.
»codedWidth
)-1),‚t, 
x
, 
t
)

325 
	gbigg”
 | 
UIÁ
((
BigIÁ
(1è<< 
maxTy³
.
»codedWidth
è- (BigIÁ(1è<< 
Á
.recodedWidth))

330 
def
 
box
(
x
: 
UIÁ
, 
g
: UInt): UInt = {

331 
v®
 
İts
 = 
æßtTy³s
.
m­
(
t
 => 
box
(
x
,))

332 
İts
(
g
)

336 
def
 
§n™izeNaN
(
x
: 
UIÁ
, 
t
: 
FTy³
): UInt = {

337 ià(
ty³Tag
(
t
) == 0) {

338 
x


340 
v®
 
maskedNaN
 = 
x
 & ~
UIÁ
((
BigIÁ
(1è<< (
t
.
sig
-1)è| (BigIÁ(1è<< (t.sig+t.
exp
-4)),.
»codedWidth
)

341 
Mux
(
t
.
isNaN
(
x
), 
maskedNaN
, x)

346 
def
 
»code
(
x
: 
UIÁ
, 
g
: UInt): UInt = {

347 
def
 
h–³r
(
x
: 
UIÁ
, 
t
: 
FTy³
): UInt = {

348 ià(
ty³Tag
(
t
) == 0) {

349 
t
.
»code
(
x
)

351 
v®
 
´evT
 = 
´evTy³
(
t
)

352 
box
(
t
.
»code
(
x
),, 
h–³r
(x, 
´evT
),…revT)

357 
v®
 
	gboxes
 = 
æßtTy³s
.
m­
(
t
 => 
UIÁ
((
BigIÁ
(1è<< 
maxTy³
.
›“Width
) - (BigInt(1) <<.ieeeWidth)))

358 
h–³r
(
boxes
(
g
è| 
x
, 
maxTy³
)

362 
def
 
›“
(
x
: 
UIÁ
, 
t
: 
FTy³
 = 
maxTy³
): UInt = {

363 ià(
ty³Tag
(
t
) == 0) {

364 
t
.
›“
(
x
)

366 
v®
 
uÄecoded
 = 
t
.
›“
(
x
)

367 
v®
 
´evT
 = 
´evTy³
(
t
)

368 
v®
 
´evRecoded
 = 
C©
(

369 
x
(
´evT
.
»codedWidth
-2),

370 
x
(
t
.
sig
-1),

371 
x
(
´evT
.
»codedWidth
-3, 0))

372 
v®
 
	g´evUÄecoded
 = 
›“
(
´evRecoded
, 
´evT
)

373 
C©
(
uÄecoded
 >> 
´evT
.
›“Width
, 
Mux
(
t
.
isNaN
(
x
), 
´evUÄecoded
, unrecoded(prevT.ieeeWidth-1, 0)))

378 
ab¡¿ù
 cÏs 
	cFPUModuË
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeModuË
()(
p
è
w™h
 
HasFPUP¬am‘”s


380 şas 
	cFPToIÁ
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$FPUModuË
()(
p
è
w™h
 
ShouldBeR‘imed
 {

381 şas 
	cOuut
 
ex‹nds
 
BundË
 {

382 
v®
 
š
 = 
Ãw
 
FPIÅut


383 
v®
 
É
 = 
	`BoŞ
()

384 
v®
 
¡Üe
 = 
	`B™s
(
width
 = 
fL’
)

385 
v®
 
tošt
 = 
	`B™s
(
width
 = 
xL’
)

386 
v®
 
exc
 = 
	`B™s
(
width
 = 
FPCÚ¡ªts
.
FLAGS_SZ
)

387 
ov”ride
 
def
 
şÚeTy³
 = 
Ãw
 
	`Ouut
().
asIn¡ªûOf
[
this
.
ty³
]

389 
v®
 
io
 = 
Ãw
 
BundË
 {

390 
v®
 
š
 = 
	`V®id
(
Ãw
 
FPIÅut
).
æ


391 
v®
 
out
 = 
	`V®id
(
Ãw
 
Ouut
)

392 
	}
}

394 
v®
 
š
 = 
	$RegEÇbË
(
io
.
š
.
b™s
, io.š.
v®id
)

395 
v®
 
v®id
 = 
	$Reg
(
Ãxt
=
io
.
š
.
v®id
)

397 
v®
 
dcmp
 = 
	`ModuË
(
Ãw
 
h¬dæßt
.
	$Com·»RecFN
(
maxExpWidth
, 
maxSigWidth
))

398 
dcmp
.
io
.
a
 :ğ
š
.
š1


399 
dcmp
.
io
.
b
 :ğ
š
.
š2


400 
dcmp
.
io
.
sigÇlšg
 :ğ!
š
.
	$rm
(1)

402 
v®
 
g
 = !
š
.
sšgËOut


403 
v®
 
¡Üe
 = 
	$›“
(
š
.
š1
)

404 
v®
 
tošt
 = 
	$Wœe
(
š™
 = 
¡Üe
)

405 
v®
 
štTy³
 = 
	$Wœe
(
š™
 = 
g
)

406 
io
.
out
.
b™s
.
¡Üe
 :ğ(
æßtTy³s
.
	`m­
(
t
 => 
	`Fl
(
maxTy³
.
›“Width
 /.›“Width, 
	`¡Üe
Ñ.›“Width - 1, 0))): 
Seq
[
UIÁ
])(
g
)

407 
io
.
out
.
b™s
.
tošt
 :ğ((0 
uÁ
 
nIÁTy³s
).
	`m­
(
i
 => 
	`tošt
((
mšXL’
 << iè- 1, 0).
	$£xtTo
(
xL’
)): 
Seq
[
UIÁ
])(
štTy³
)

408 
io
.
out
.
b™s
.
exc
 :ğ
	$B™s
(0)

410 
	`wh’
 (
š
.
	$rm
(0)) {

411 
v®
 
şassify_out
 = (
æßtTy³s
.
	`m­
(
t
 =>.
	`şassify
(
maxTy³
.
	`un§ãCÚv”t
(
š
.
š1
,))): 
Seq
[
UIÁ
])(
g
)

412 
tošt
 :ğ
şassify_out
 | (
¡Üe
 >> 
mšXL’
 << minXLen)

413 
štTy³
 := 0

414 
	}
}

416 
	$wh’
 (
š
.
wæags
) {

417 
tošt
 :ğ(~
š
.
rm
 & 
	`C©
(
dcmp
.
io
.
É
, dcmp.io.
eq
)).
ÜR
 | (
¡Üe
 >> 
mšXL’
 << minXLen)

418 
io
.
out
.
b™s
.
exc
 :ğ
dcmp
.io.
exû±iÚFÏgs


419 
štTy³
 := 0

421 
	`wh’
 (!
š
.
»n2
) {

422 
v®
 
cvtTy³
 = 
š
.
typ
.
	`exŒaù
(
	`log2Ce
(
nIÁTy³s
), 1)

423 
štTy³
 :ğ
cvtTy³


425 
v®
 
cÚv
 = 
	`ModuË
(
Ãw
 
h¬dæßt
.
	`RecFNToIN
(
maxExpWidth
, 
maxSigWidth
, 
xL’
))

426 
cÚv
.
io
.
š
 :ğš.
š1


427 
cÚv
.
io
.
roundšgMode
 :ğ
š
.
rm


428 
cÚv
.
io
.
sigÃdOut
 :ğ~
š
.
	`typ
(0)

429 
tošt
 :ğ
cÚv
.
io
.
out


430 
io
.
out
.
b™s
.
exc
 :ğ
	`C©
(
cÚv
.io.
	`štExû±iÚFÏgs
(2, 1).
ÜR
, 
	`UIÁ
(0, 3), conv.io.intExceptionFlags(0))

432 
i
 <- 0 
uÁ
 
nIÁTy³s
-1) {

433 
v®
 
w
 = 
mšXL’
 << 
i


434 
	`wh’
 (
cvtTy³
 ==ğ
i
) {

435 
v®
 
Ç¼ow
 = 
	`ModuË
(
Ãw
 
h¬dæßt
.
	`RecFNToIN
(
maxExpWidth
, 
maxSigWidth
, 
w
))

436 
Ç¼ow
.
io
.
š
 :ğš.
š1


437 
Ç¼ow
.
io
.
roundšgMode
 :ğ
š
.
rm


438 
Ç¼ow
.
io
.
sigÃdOut
 :ğ~
š
.
	`typ
(0)

440 
v®
 
excSign
 = 
š
.
	`š1
(
maxExpWidth
 + 
maxSigWidth
è&& !
maxTy³
.
	`isNaN
(š.
š1
)

441 
v®
 
excOut
 = 
	`C©
(
cÚv
.
io
.
sigÃdOut
 ==ğ
excSign
, 
	`Fl
(
w
-1, !excSign))

442 
v®
 
šv®id
 = 
cÚv
.
io
.
	`štExû±iÚFÏgs
(2è|| 
Ç¼ow
.io.intExceptionFlags(1)

443 
	`wh’
 (
šv®id
è{ 
tošt
 :ğ
	`C©
(
cÚv
.
io
.
out
 >> 
w
, 
excOut
) }

444 
io
.
out
.
b™s
.
exc
 :ğ
	`C©
(
šv®id
, 
	`UIÁ
(0, 3), !šv®id && 
cÚv
.io.
	`štExû±iÚFÏgs
(0))

448 
	}
}

450 
	gio
.
	gout
.
	gv®id
 :ğ
v®id


451 
io
.
out
.
b™s
.
É
 :ğ
dcmp
.io.É || (dcmp.io.
a
.
asSIÁ
 < 0.
S
 && dcmp.io.
b
.asSInt >= 0.S)

452 
io
.
out
.
b™s
.
š
 := in

455 şas 
	cIÁToFP
(
v®
 
Ï‹ncy
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$FPUModuË
()(
p
è
w™h
 
ShouldBeR‘imed
 {

456 
v®
 
io
 = 
Ãw
 
BundË
 {

457 
v®
 
š
 = 
	`V®id
(
Ãw
 
IÁToFPIÅut
).
æ


458 
v®
 
out
 = 
	`V®id
(
Ãw
 
FPResuÉ
)

461 
v®
 
š
 = 
	$Pe
(
io
.
š
)

462 
v®
 
g
 = !
š
.
b™s
.
sšgËIn


464 
v®
 
mux
 = 
	$Wœe
(
Ãw
 
FPResuÉ
)

465 
mux
.
exc
 :ğ
	$B™s
(0)

466 
mux
.
d©a
 :ğ
	`»code
(
š
.
b™s
.
š1
, !š.b™s.
sšgËIn
)

468 
v®
 
štV®ue
 = {

469 
v®
 
»s
 = 
	`Wœe
(
š™
 = 
š
.
b™s
.
š1
.
asSIÁ
)

470 
i
 <- 0 
uÁ
 
nIÁTy³s
-1) {

471 
v®
 
sm®lIÁ
 = 
š
.
b™s
.
	`š1
((
mšXL’
 << 
i
) - 1, 0)

472 
	`wh’
 (
š
.
b™s
.
typ
.
	`exŒaù
(
	`log2Ce
(
nIÁTy³s
), 1è==ğ
i
) {

473 
»s
 :ğ
	`Mux
(
š
.
b™s
.
	`typ
(0), 
sm®lIÁ
.
zext
, sm®lIÁ.
asSIÁ
)

476 
»s
.
asUIÁ


477 
	}
}

479 
	$wh’
 (
š
.
b™s
.
wæags
) {

482 
v®
 
i2fResuÉs
 = 
t
 <- 
æßtTy³s
è
y›ld
 {

483 
v®
 
i2f
 = 
	`ModuË
(
Ãw
 
h¬dæßt
.
	`INToRecFN
(
xL’
, 
t
.
exp
,.
sig
))

484 
i2f
.
io
.
sigÃdIn
 :ğ~
š
.
b™s
.
	`typ
(0)

485 
i2f
.
io
.
š
 :ğ
štV®ue


486 
i2f
.
io
.
roundšgMode
 :ğ
š
.
b™s
.
rm


487 
i2f
.
io
.
d‘eùTššess
 :ğ
h¬dæßt
.
cÚ¡s
.
tššess_aá”Roundšg


488 (
	`§n™izeNaN
(
i2f
.
io
.
out
, 
t
), i2f.io.
exû±iÚFÏgs
)

491 
	`v®
 (
d©a
, 
exc
èğ
i2fResuÉs
.
unz


492 
v®
 
d©aPadded
 = 
d©a
.
š™
.
	`m­
(
d
 => 
	`C©
(d©a.
Ï¡
 >> d.
g‘Width
, d)) :+ data.last

493 
mux
.
d©a
 :ğ
	`d©aPadded
(
g
)

494 
mux
.
exc
 :ğ
	`exc
(
g
)

495 
	}
}

497 
io
.
out
 <> 
Pe
(
š
.
v®id
, 
mux
, 
Ï‹ncy
-1)

500 şas 
	cFPToFP
(
v®
 
Ï‹ncy
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$FPUModuË
()(
p
è
w™h
 
ShouldBeR‘imed
 {

501 
v®
 
io
 = 
Ãw
 
BundË
 {

502 
v®
 
š
 = 
	`V®id
(
Ãw
 
FPIÅut
).
æ


503 
v®
 
out
 = 
	`V®id
(
Ãw
 
FPResuÉ
)

504 
v®
 
É
 = 
	`BoŞ
(
INPUT
)

507 
v®
 
š
 = 
	$Pe
(
io
.
š
)

509 
v®
 
signNum
 = 
	`Mux
(
š
.
b™s
.
	`rm
(1), in.b™s.
š1
 ^ in.b™s.
š2
, Mux(in.bits.rm(0), ~in.bits.in2, in.bits.in2))

510 
v®
 
fsgnj
 = 
	`C©
(
	`signNum
(
fL’
), 
š
.
b™s
.
	`š1
(fLen-1, 0))

512 
v®
 
fsgnjMux
 = 
	$Wœe
(
Ãw
 
FPResuÉ
)

513 
fsgnjMux
.
exc
 :ğ
	$UIÁ
(0)

514 
fsgnjMux
.
d©a
 :ğ
fsgnj


516 
	$wh’
 (
š
.
b™s
.
wæags
) {

517 
v®
 
i¢ª1
 = 
maxTy³
.
	`isNaN
(
š
.
b™s
.
š1
)

518 
v®
 
i¢ª2
 = 
maxTy³
.
	`isNaN
(
š
.
b™s
.
š2
)

519 
v®
 
isInv®id
 = 
maxTy³
.
	`isSNaN
(
š
.
b™s
.
š1
è|| maxTy³.isSNaN(š.b™s.
š2
)

520 
v®
 
isNaNOut
 = 
i¢ª1
 && 
i¢ª2


521 
v®
 
isLHS
 = 
i¢ª2
 || 
š
.
b™s
.
	`rm
(0è=/ğ
io
.
É
 && !
i¢ª1


522 
fsgnjMux
.
exc
 :ğ
isInv®id
 << 4

523 
fsgnjMux
.
d©a
 :ğ
	`Mux
(
isNaNOut
, 
maxTy³
.
qNaN
, Mux(
isLHS
, 
š
.
b™s
.
š1
, in.b™s.
š2
))

524 
	}
}

526 
v®
 
	gšTag
 = !
š
.
b™s
.
sšgËIn


527 
v®
 
outTag
 = !
š
.
b™s
.
sšgËOut


528 
v®
 
mux
 = 
	$Wœe
(
š™
 = 
fsgnjMux
)

529 
t
 <- 
æßtTy³s
.
š™
) {

530 
	`wh’
 (
outTag
 ==ğ
	`ty³Tag
(
t
)) {

531 
mux
.
d©a
 :ğ
	`C©
(
fsgnjMux
.d©¨>> 
t
.
»codedWidth
, 
maxTy³
.
	`un§ãCÚv”t
(fsgnjMux.data,))

533 
	}
}

535 
wh’
 (
š
.
b™s
.
wæags
 && !š.b™s.
»n2
) {

536 ià(
	gæßtTy³s
.
	gsize
 > 1) {

538 
v®
 
	gwid’ed
 = 
Mux
(
maxTy³
.
isNaN
(
š
.
b™s
.
š1
), maxTy³.
qNaN
, in.bits.in1)

539 
	gfsgnjMux
.
	gd©a
 :ğ
wid’ed


540 
fsgnjMux
.
exc
 :ğ
maxTy³
.
isSNaN
(
š
.
b™s
.
š1
) << 4

545 
outTy³
 <- 
æßtTy³s
.
š™
è
wh’
 (
outTag
 ==ğ
ty³Tag
(outTy³è&& (ty³Tag(outTy³è=ğ0 || outTag < 
šTag
)) {

546 
v®
 
Ç¼ow”
 = 
ModuË
(
Ãw
 
h¬dæßt
.
RecFNToRecFN
(
maxTy³
.
exp
, maxTy³.
sig
, 
outTy³
.exp, outType.sig))

547 
	gÇ¼ow”
.
	gio
.
	gš
 :ğ
š
.
b™s
.
š1


548 
Ç¼ow”
.
io
.
roundšgMode
 :ğ
š
.
b™s
.
rm


549 
Ç¼ow”
.
io
.
d‘eùTššess
 :ğ
h¬dæßt
.
cÚ¡s
.
tššess_aá”Roundšg


550 
v®
 
Ç¼owed
 = 
§n™izeNaN
(
Ç¼ow”
.
io
.
out
, 
outTy³
)

551 
	gmux
.
	gd©a
 :ğ
C©
(
fsgnjMux
.
d©a
 >> 
Ç¼owed
.
g‘Width
,‚arrowed)

552 
	gmux
.
	gexc
 :ğ
Ç¼ow”
.
io
.
exû±iÚFÏgs


557 
io
.
out
 <> 
Pe
(
š
.
v®id
, 
mux
, 
Ï‹ncy
-1)

560 
şass
 
	$MulAddRecFNPe
(
Ï‹ncy
: 
IÁ
, 
expWidth
: IÁ, 
sigWidth
: IÁè
ex‹nds
 
ModuË


562 
	`»quœe
(
Ï‹ncy
<=2)

564 
v®
 
io
 = 
Ãw
 
BundË
 {

565 
v®
 
v®idš
 = 
	`BoŞ
(
INPUT
)

566 
v®
 
İ
 = 
	`B™s
(
INPUT
, 2)

567 
v®
 
a
 = 
	`B™s
(
INPUT
, 
expWidth
 + 
sigWidth
 + 1)

568 
v®
 
b
 = 
	`B™s
(
INPUT
, 
expWidth
 + 
sigWidth
 + 1)

569 
v®
 
c
 = 
	`B™s
(
INPUT
, 
expWidth
 + 
sigWidth
 + 1)

570 
v®
 
roundšgMode
 = 
	`UIÁ
(
INPUT
, 3)

571 
v®
 
d‘eùTššess
 = 
	`UIÁ
(
INPUT
, 1)

572 
v®
 
out
 = 
	`B™s
(
OUTPUT
, 
expWidth
 + 
sigWidth
 + 1)

573 
v®
 
exû±iÚFÏgs
 = 
	`B™s
(
OUTPUT
, 5)

574 
v®
 
v®idout
 = 
	`BoŞ
(
OUTPUT
)

579 
v®
 
mulAddRecFNToRaw_´eMul
 =

580 
	`ModuË
(
Ãw
 
h¬dæßt
.
	`MulAddRecFNToRaw_´eMul
(
expWidth
, 
sigWidth
))

581 
v®
 
mulAddRecFNToRaw_po¡Mul
 =

582 
	`ModuË
(
Ãw
 
h¬dæßt
.
	`MulAddRecFNToRaw_po¡Mul
(
expWidth
, 
sigWidth
))

584 
mulAddRecFNToRaw_´eMul
.
io
.
İ
 := io.op

585 
mulAddRecFNToRaw_´eMul
.
io
.
a
 := io.a

586 
mulAddRecFNToRaw_´eMul
.
io
.
b
 := io.b

587 
mulAddRecFNToRaw_´eMul
.
io
.
c
 := io.c

589 
v®
 
mulAddResuÉ
 =

590 (
mulAddRecFNToRaw_´eMul
.
io
.
mulAddA
 *

591 
mulAddRecFNToRaw_´eMul
.
io
.
mulAddB
) +&

592 
mulAddRecFNToRaw_´eMul
.
io
.
mulAddC


594 
v®
 
v®id_¡age0
 = 
	`Wœe
(
	`BoŞ
())

595 
v®
 
roundšgMode_¡age0
 = 
	`Wœe
(
	`UIÁ
(
width
=3))

596 
v®
 
d‘eùTššess_¡age0
 = 
	`Wœe
(
	`UIÁ
(
width
=1))

598 
v®
 
po¡mul_»gs
 = if(
Ï‹ncy
>0) 1 0

599 
mulAddRecFNToRaw_po¡Mul
.
io
.
äomP»Mul
 :ğ
	`Pe
(io.
v®idš
, 
mulAddRecFNToRaw_´eMul
.io.
toPo¡Mul
, 
po¡mul_»gs
).
b™s


600 
mulAddRecFNToRaw_po¡Mul
.
io
.
mulAddResuÉ
 :ğ
	`Pe
(io.
v®idš
, mulAddResuÉ, 
po¡mul_»gs
).
b™s


601 
mulAddRecFNToRaw_po¡Mul
.
io
.
roundšgMode
 :ğ
	`Pe
(io.
v®idš
, io.roundšgMode, 
po¡mul_»gs
).
b™s


602 
roundšgMode_¡age0
 :ğ
	`Pe
(
io
.
v®idš
, io.
roundšgMode
, 
po¡mul_»gs
).
b™s


603 
d‘eùTššess_¡age0
 :ğ
	`Pe
(
io
.
v®idš
, io.
d‘eùTššess
, 
po¡mul_»gs
).
b™s


604 
v®id_¡age0
 :ğ
	`Pe
(
io
.
v®idš
, 
çl£
.
B
, 
po¡mul_»gs
).
v®id


608 
v®
 
roundRawFNToRecFN
 = 
	`ModuË
(
Ãw
 
h¬dæßt
.
	`RoundRawFNToRecFN
(
expWidth
, 
sigWidth
, 0))

610 
v®
 
round_»gs
 = if(
Ï‹ncy
==2) 1 0

611 
roundRawFNToRecFN
.
io
.
šv®idExc
 :ğ
	`Pe
(
v®id_¡age0
, 
mulAddRecFNToRaw_po¡Mul
.io.šv®idExc, 
round_»gs
).
b™s


612 
roundRawFNToRecFN
.
io
.
š
 :ğ
	`Pe
(
v®id_¡age0
, 
mulAddRecFNToRaw_po¡Mul
.io.
¿wOut
, 
round_»gs
).
b™s


613 
roundRawFNToRecFN
.
io
.
roundšgMode
 :ğ
	`Pe
(
v®id_¡age0
, 
roundšgMode_¡age0
, 
round_»gs
).
b™s


614 
roundRawFNToRecFN
.
io
.
d‘eùTššess
 :ğ
	`Pe
(
v®id_¡age0
, 
d‘eùTššess_¡age0
, 
round_»gs
).
b™s


615 
io
.
v®idout
 :ğ
	`Pe
(
v®id_¡age0
, 
çl£
.
B
, 
round_»gs
).
v®id


617 
roundRawFNToRecFN
.
io
.
šfš™eExc
 :ğ
	`BoŞ
(
çl£
)

619 
io
.
out
 :ğ
roundRawFNToRecFN
.io.out

620 
io
.
exû±iÚFÏgs
 :ğ
roundRawFNToRecFN
.io.exceptionFlags

621 
	}
}

623 
şass
 
	$FPUFMAPe
(
v®
 
Ï‹ncy
: 
IÁ
, v® 
t
: 
FTy³
)

624 (
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$FPUModuË
()(
p
è
w™h
 
ShouldBeR‘imed
 {

625 
	`»quœe
(
Ï‹ncy
>0)

627 
v®
 
io
 = 
Ãw
 
BundË
 {

628 
v®
 
š
 = 
	`V®id
(
Ãw
 
FPIÅut
).
æ


629 
v®
 
out
 = 
	`V®id
(
Ãw
 
FPResuÉ
)

632 
v®
 
v®id
 = 
	`Reg
(
Ãxt
=
io
.
š
.valid)

633 
v®
 
š
 = 
	`Reg
(
Ãw
 
FPIÅut
)

634 
	`wh’
 (
io
.
š
.
v®id
) {

635 
v®
 
Úe
 = 
	`UIÁ
(1è<< (
t
.
sig
 +.
exp
 - 1)

636 
v®
 
z”o
 = (
io
.
š
.
b™s
.
š1
 ^ io.š.b™s.
š2
è& (
	`UIÁ
(1è<< (
t
.
sig
 +.
exp
))

637 
v®
 
cmd_fma
 = 
io
.
š
.
b™s
.
»n3


638 
v®
 
cmd_addsub
 = 
io
.
š
.
b™s
.
sw­23


639 
š
 :ğ
io
.š.
b™s


640 
	`wh’
 (
cmd_addsub
è{ 
š
.
š2
 :ğ
Úe
 }

641 
	`wh’
 (!(
cmd_fma
 || 
cmd_addsub
)è{ 
š
.
š3
 :ğ
z”o
 }

644 
v®
 
fma
 = 
	`ModuË
(
Ãw
 
	`MulAddRecFNPe
((
Ï‹ncy
-1è
mš
 2, 
t
.
exp
,.
sig
))

645 
fma
.
io
.
v®idš
 :ğ
v®id


646 
fma
.
io
.
İ
 :ğ
š
.
fmaCmd


647 
fma
.
io
.
roundšgMode
 :ğ
š
.
rm


648 
fma
.
io
.
d‘eùTššess
 :ğ
h¬dæßt
.
cÚ¡s
.
tššess_aá”Roundšg


649 
fma
.
io
.
a
 :ğ
š
.
š1


650 
fma
.
io
.
b
 :ğ
š
.
š2


651 
fma
.
io
.
c
 :ğ
š
.
š3


653 
v®
 
»s
 = 
	`Wœe
(
Ãw
 
FPResuÉ
)

654 
»s
.
d©a
 :ğ
	`§n™izeNaN
(
fma
.
io
.
out
, 
t
)

655 
»s
.
exc
 :ğ
fma
.
io
.
exû±iÚFÏgs


657 
io
.
out
 :ğ
	`Pe
(
fma
.io.
v®idout
, 
»s
, (
Ï‹ncy
-3è
max
 0)

658 
	}
}

660 @
chi£lName


661 şas 
	cFPU
(
cfg
: 
FPUP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$FPUModuË
()(
p
) {

662 
v®
 
io
 = 
Ãw
 
FPUIO


664 
v®
 
u£ClockG©šg
 = 
cÜeP¬ams
 
m©ch
 {

665 
r
: 
Rock‘CÜeP¬ams
 =>„.
şockG©e


666 
_
 => 
çl£


668 
v®
 
şock_’_»g
 = 
	`Reg
(
	$BoŞ
())

669 
v®
 
şock_’
 = 
şock_’_»g
 || 
io
.
ı_»q
.
v®id


670 
v®
 
g©ed_şock
 =

671 ià(!
u£ClockG©šg
è
şock


672 
	`ClockG©e
(
şock
, 
şock_’
, "fpu_clock_gate")

674 
v®
 
å_decod”
 = 
	$ModuË
(
Ãw
 
FPUDecod”
)

675 
å_decod”
.
io
.
š¡
 := io.inst

676 
v®
 
id_ù¾
 = 
å_decod”
.
io
.
sigs


678 
v®
 
ex_»g_v®id
 = 
	`Reg
(
Ãxt
=
io
.
v®id
, 
š™
=
	$BoŞ
(
çl£
))

679 
v®
 
ex_»g_š¡
 = 
	$RegEÇbË
(
io
.
š¡
, io.
v®id
)

680 
v®
 
ex_»g_ù¾
 = 
	$RegEÇbË
(
id_ù¾
, 
io
.
v®id
)

681 
v®
 
ex_¿
 = 
Li¡
.
	$fl
(3)(
	`Reg
(
	$UIÁ
()))

683 
	$w™hClock
 (
g©ed_şock
) {

685 
v®
 
»q_v®id
 = 
ex_»g_v®id
 || 
io
.
ı_»q
.
v®id


686 
v®
 
ex_ı_v®id
 = 
io
.
ı_»q
.
	`fœe
()

687 
v®
 
mem_ı_v®id
 = 
	`Reg
(
Ãxt
=
ex_ı_v®id
, 
š™
=
	`BoŞ
(
çl£
))

688 
v®
 
wb_ı_v®id
 = 
	`Reg
(
Ãxt
=
mem_ı_v®id
, 
š™
=
	`BoŞ
(
çl£
))

689 
v®
 
mem_»g_v®id
 = 
	`RegIn™
(
çl£
.
B
)

690 
v®
 
klm
 = (
io
.klm || io.
Çck_mem
è&& !
mem_ı_v®id


694 
v®
 
klx
 = 
io
.klx || 
mem_»g_v®id
 && 
klm


695 
mem_»g_v®id
 :ğ
ex_»g_v®id
 && !
klx
 || 
ex_ı_v®id


696 
v®
 
mem_»g_š¡
 = 
	`RegEÇbË
(
ex_»g_š¡
, 
ex_»g_v®id
)

697 
v®
 
wb_»g_v®id
 = 
	`Reg
(
Ãxt
=
mem_»g_v®id
 && (!
klm
 || 
mem_ı_v®id
), 
š™
=
	`BoŞ
(
çl£
))

699 
v®
 
ı_ù¾
 = 
	`Wœe
(
Ãw
 
FPUCŒlSigs
)

700 
ı_ù¾
 <> 
io
.
ı_»q
.
b™s


701 
io
.
ı_»¥
.
v®id
 :ğ
	`BoŞ
(
çl£
)

702 
io
.
ı_»¥
.
b™s
.
d©a
 :ğ
	`UIÁ
(0)

704 
v®
 
ex_ù¾
 = 
	`Mux
(
ex_ı_v®id
, 
ı_ù¾
, 
ex_»g_ù¾
)

705 
v®
 
mem_ù¾
 = 
	`RegEÇbË
(
ex_ù¾
, 
»q_v®id
)

706 
v®
 
wb_ù¾
 = 
	`RegEÇbË
(
mem_ù¾
, 
mem_»g_v®id
)

709 
v®
 
lßd_wb
 = 
	`Reg
(
Ãxt
=
io
.
dmem_»¥_v®
)

710 
v®
 
lßd_wb_doubË
 = 
	`RegEÇbË
(
io
.
	`dmem_»¥_ty³
(0), io.
dmem_»¥_v®
)

711 
v®
 
lßd_wb_d©a
 = 
	`RegEÇbË
(
io
.
dmem_»¥_d©a
, io.
dmem_»¥_v®
)

712 
v®
 
lßd_wb_g
 = 
	`RegEÇbË
(
io
.
dmem_»¥_g
, io.
dmem_»¥_v®
)

715 
v®
 
»gfe
 = 
	`Mem
(32, 
	`B™s
(
width
 = 
fL’
+1))

716 
	`wh’
 (
lßd_wb
) {

717 
v®
 
wd©a
 = 
	`»code
(
lßd_wb_d©a
, 
lßd_wb_doubË
)

718 
	`»gfe
(
lßd_wb_g
è:ğ
wd©a


719 
	`as£¹
(
	`cÚsi¡’t
(
wd©a
))

720 ià(
’abËComm™Log
)

721 
	`´štf
("f%d…%d 0x%x\n", 
lßd_wb_g
,†ßd_wb_g + 32, 
lßd_wb_d©a
)

724 
v®
 
ex_rs
 = 
ex_¿
.
	`m­
(
a
 => 
	`»gfe
(a))

725 
	`wh’
 (
io
.
v®id
) {

726 
	`wh’
 (
id_ù¾
.
»n1
) {

727 
	`wh’
 (!
id_ù¾
.
sw­12
è{ 
	`ex_¿
(0è:ğ
io
.
	`š¡
(19,15) }

728 
	`wh’
 (
id_ù¾
.
sw­12
è{ 
	`ex_¿
(1è:ğ
io
.
	`š¡
(19,15) }

730 
	`wh’
 (
id_ù¾
.
»n2
) {

731 
	`wh’
 (
id_ù¾
.
sw­12
è{ 
	`ex_¿
(0è:ğ
io
.
	`š¡
(24,20) }

732 
	`wh’
 (
id_ù¾
.
sw­23
è{ 
	`ex_¿
(2è:ğ
io
.
	`š¡
(24,20) }

733 
	`wh’
 (!
id_ù¾
.
sw­12
 && !id_ù¾.
sw­23
è{ 
	`ex_¿
(1è:ğ
io
.
	`š¡
(24,20) }

735 
	`wh’
 (
id_ù¾
.
»n3
è{ 
	`ex_¿
(2è:ğ
io
.
	`š¡
(31,27) }

737 
v®
 
ex_rm
 = 
	`Mux
(
	`ex_»g_š¡
(14,12è==ğ
	`B™s
(7), 
io
.
fc¤_rm
,ƒx_reg_inst(14,12))

739 
def
 
	`fuIÅut
(
mšT
: 
O±iÚ
[
FTy³
]): 
FPIÅut
 = {

740 
v®
 
»q
 = 
	`Wœe
(
Ãw
 
FPIÅut
)

741 
v®
 
g
 = !
ex_ù¾
.
sšgËIn


742 
»q
 :ğ
ex_ù¾


743 
»q
.
rm
 :ğ
ex_rm


744 
»q
.
š1
 :ğ
	`unbox
(
	`ex_rs
(0), 
g
, 
mšT
)

745 
»q
.
š2
 :ğ
	`unbox
(
	`ex_rs
(1), 
g
, 
mšT
)

746 
»q
.
š3
 :ğ
	`unbox
(
	`ex_rs
(2), 
g
, 
mšT
)

747 
»q
.
typ
 :ğ
	`ex_»g_š¡
(21,20)

748 
»q
.
fmaCmd
 :ğ
	`ex_»g_š¡
(3,2è| (!
ex_ù¾
.
»n3
 &&ƒx_reg_inst(27))

749 
	`wh’
 (
ex_ı_v®id
) {

750 
»q
 :ğ
io
.
ı_»q
.
b™s


751 
	`wh’
 (
io
.
ı_»q
.
b™s
.
sw­23
) {

752 
»q
.
š2
 :ğ
io
.
ı_»q
.
b™s
.
š3


753 
»q
.
š3
 :ğ
io
.
ı_»q
.
b™s
.
š2


756 
»q


759 
v®
 
sfma
 = 
	`ModuË
(
Ãw
 
	`FPUFMAPe
(
cfg
.
sfmaL©’cy
, 
FTy³
.
S
))

760 
sfma
.
io
.
š
.
v®id
 :ğ
»q_v®id
 && 
ex_ù¾
.
fma
 &&ƒx_ù¾.
sšgËOut


761 
sfma
.
io
.
š
.
b™s
 :ğ
	`fuIÅut
(
	`Some
(sfma.
t
))

763 
v®
 
åiu
 = 
	`ModuË
(
Ãw
 
FPToIÁ
)

764 
åiu
.
io
.
š
.
v®id
 :ğ
»q_v®id
 && (
ex_ù¾
.
tošt
 ||ƒx_ù¾.
div
 ||ƒx_ù¾.
sq¹
 || (ex_ù¾.
ç¡pe
 &&ƒx_ù¾.
wæags
))

765 
åiu
.
io
.
š
.
b™s
 :ğ
	`fuIÅut
(
NÚe
)

766 
io
.
¡Üe_d©a
 :ğ
åiu
.io.
out
.
b™s
.
¡Üe


767 
io
.
tošt_d©a
 :ğ
åiu
.io.
out
.
b™s
.
tošt


768 
	`wh’
(
åiu
.
io
.
out
.
v®id
 && 
mem_ı_v®id
 && 
mem_ù¾
.
tošt
){

769 
io
.
ı_»¥
.
b™s
.
d©a
 :ğ
åiu
.io.
out
.b™s.
tošt


770 
io
.
ı_»¥
.
v®id
 :ğ
	`BoŞ
(
Œue
)

773 
v®
 
iåu
 = 
	`ModuË
(
Ãw
 
	`IÁToFP
(2))

774 
iåu
.
io
.
š
.
v®id
 :ğ
»q_v®id
 && 
ex_ù¾
.
äomšt


775 
iåu
.
io
.
š
.
b™s
 :ğ
åiu
.io.in.bits

776 
iåu
.
io
.
š
.
b™s
.
š1
 :ğ
	`Mux
(
ex_ı_v®id
, io.
ı_»q
.b™s.š1, io.
äomšt_d©a
)

778 
v®
 
åmu
 = 
	`ModuË
(
Ãw
 
	`FPToFP
(2))

779 
åmu
.
io
.
š
.
v®id
 :ğ
»q_v®id
 && 
ex_ù¾
.
ç¡pe


780 
åmu
.
io
.
š
.
b™s
 :ğ
åiu
.io.in.bits

781 
åmu
.
io
.
É
 :ğ
åiu
.io.
out
.
b™s
.lt

783 
v®
 
divSq¹_w’
 = 
	`Wœe
(
š™
 = 
çl£
.
B
)

784 
v®
 
divSq¹_šFlight
 = 
	`Wœe
(
š™
 = 
çl£
.
B
)

785 
v®
 
divSq¹_waddr
 = 
	`Reg
(
	`UIÁ
(
width
 = 5))

786 
v®
 
divSq¹_ty³Tag
 = 
	`Wœe
(
	`UIÁ
(
width
 = 
	`log2Up
(
æßtTy³s
.
size
)))

787 
v®
 
divSq¹_wd©a
 = 
	`Wœe
(
	`UIÁ
(
width
 = 
fL’
+1))

788 
v®
 
divSq¹_æags
 = 
	`Wœe
(
	`UIÁ
(
width
 = 
FPCÚ¡ªts
.
FLAGS_SZ
))

791 
şass
 
	`Pe
(
p
: 
ModuË
, 
Ït
: 
IÁ
, 
cÚd
: (
FPUCŒlSigs
è=> 
BoŞ
, 
»s
: 
FPResuÉ
)

792 
v®
 
pes
 = 
	`Li¡
(

793 
	`Pe
(
åmu
, fpmu.
Ï‹ncy
, (
c
: 
FPUCŒlSigs
è=> c.
ç¡pe
, fpmu.
io
.
out
.
b™s
),

794 
	`Pe
(
iåu
, iåu.
Ï‹ncy
, (
c
: 
FPUCŒlSigs
è=> c.
äomšt
, iåu.
io
.
out
.
b™s
),

795 
	`Pe
(
sfma
, sfma.
Ï‹ncy
, (
c
: 
FPUCŒlSigs
è=> c.
fma
 && c.
sšgËOut
, sfma.
io
.
out
.
b™s
)) ++

796 (
fL’
 > 32).
	`İtiÚ
({

797 
v®
 
dfma
 = 
	`ModuË
(
Ãw
 
	`FPUFMAPe
(
cfg
.
dfmaL©’cy
, 
FTy³
.
D
))

798 
dfma
.
io
.
š
.
v®id
 :ğ
»q_v®id
 && 
ex_ù¾
.
fma
 && !ex_ù¾.
sšgËOut


799 
dfma
.
io
.
š
.
b™s
 :ğ
	`fuIÅut
(
	`Some
(dfma.
t
))

800 
	`Pe
(
dfma
, dfma.
Ï‹ncy
, (
c
: 
FPUCŒlSigs
è=> c.
fma
 && !c.
sšgËOut
, dfma.
io
.
out
.
b™s
)

802 
def
 
	`Ï‹ncyMask
(
c
: 
FPUCŒlSigs
, 
off£t
: 
IÁ
) = {

803 
	`»quœe
(
pes
.
	`fÜ®l
(
_
.
Ït
 >ğ
off£t
))

804 
pes
.
	`m­
(
p
 => 
	`Mux
Õ.
	`cÚd
(
c
), 
	`UIÁ
(1 <<….
Ït
-
off£t
), UIÁ(0))).
	`»duû
(
_
|_)

806 
def
 
	`peid
(
c
: 
FPUCŒlSigs
èğ
pes
.
zW™hIndex
.
	`m­
(
p
 => 
	`Mux
Õ.
_1
.
	`cÚd
(c), 
	`UIÁ
Õ.
_2
), UIÁ(0))).
	`»duû
(
_
|_)

807 
v®
 
maxL©’cy
 = 
pes
.
	`m­
(
_
.
Ït
).
max


808 
v®
 
memL©’cyMask
 = 
	`Ï‹ncyMask
(
mem_ù¾
, 2)

810 şas 
	cWBInfo
 
ex‹nds
 
BundË
 {

811 
v®
 
rd
 = 
	`UIÁ
(
width
 = 5)

812 
v®
 
sšgË
 = 
	`BoŞ
()

813 
v®
 
ı
 = 
	`BoŞ
()

814 
v®
 
peid
 = 
	`UIÁ
(
width
 = 
	`log2Ce
(
pes
.
size
))

815 
ov”ride
 
def
 
şÚeTy³
: 
this
.
ty³
 = 
Ãw
 
	`WBInfo
().
asIn¡ªûOf
[this.type]

818 
v®
 
w’
 = 
	`Reg
(
š™
=
	`B™s
(0, 
maxL©’cy
-1))

819 
v®
 
wbInfo
 = 
	`Reg
(
	`Vec
(
maxL©’cy
-1, 
Ãw
 
WBInfo
))

820 
v®
 
mem_w’
 = 
mem_»g_v®id
 && (
mem_ù¾
.
fma
 || mem_ù¾.
ç¡pe
 || mem_ù¾.
äomšt
)

821 
v®
 
wr™e_pÜt_busy
 = 
	`RegEÇbË
(
mem_w’
 && (
memL©’cyMask
 & 
	`Ï‹ncyMask
(
ex_ù¾
, 1)).
ÜR
 || (
w’
 &†©’cyMaskÓx_ù¾, 0)).ÜR, 
»q_v®id
)

822 
	`ccov”
(
mem_»g_v®id
 && 
wr™e_pÜt_busy
, "WB_STRUCTURAL", "structural hazard on writeback")

824 
i
 <- 0 
uÁ
 
maxL©’cy
-2) {

825 
	`wh’
 (
	`w’
(
i
+1)è{ 
	`wbInfo
(i) := wbInfo(i+1) }

827 
w’
 := wen >> 1

828 
	`wh’
 (
mem_w’
) {

829 
	`wh’
 (!
klm
) {

830 
w’
 :ğw’ >> 1 | 
memL©’cyMask


832 
i
 <- 0 
uÁ
 
maxL©’cy
-1) {

833 
	`wh’
 (!
wr™e_pÜt_busy
 && 
	`memL©’cyMask
(
i
)) {

834 
	`wbInfo
(
i
).
ı
 :ğ
mem_ı_v®id


835 
	`wbInfo
(
i
).
sšgË
 :ğ
mem_ù¾
.
sšgËOut


836 
	`wbInfo
(
i
).
peid
 :ğ
	`peid
(
mem_ù¾
)

837 
	`wbInfo
(
i
).
rd
 :ğ
	`mem_»g_š¡
(11,7)

842 
v®
 
waddr
 = 
	`Mux
(
divSq¹_w’
, 
divSq¹_waddr
, 
	`wbInfo
(0).
rd
)

843 
v®
 
wdoubË
 = 
	`Mux
(
divSq¹_w’
, 
divSq¹_ty³Tag
, !
	`wbInfo
(0).
sšgË
)

844 
v®
 
wd©a
 = 
	`box
(
	`Mux
(
divSq¹_w’
, 
divSq¹_wd©a
, (
pes
.
	`m­
(
_
.
»s
.
d©a
): 
Seq
[
UIÁ
])(
	`wbInfo
(0).
peid
)), 
wdoubË
)

845 
v®
 
wexc
 = (
pes
.
	`m­
(
_
.
»s
.
exc
): 
Seq
[
UIÁ
])(
	`wbInfo
(0).
peid
)

846 
	`wh’
 ((!
	`wbInfo
(0).
ı
 && 
	`w’
(0)è|| 
divSq¹_w’
) {

847 
	`as£¹
(
	`cÚsi¡’t
(
wd©a
))

848 
	`»gfe
(
waddr
è:ğ
wd©a


849 ià(
’abËComm™Log
) {

850 
	`´štf
("f%d…%d 0x%x\n", 
waddr
, wadd¸+ 32, 
	`›“
(
wd©a
))

853 
	`wh’
 (
	`wbInfo
(0).
ı
 && 
	`w’
(0)) {

854 
io
.
ı_»¥
.
b™s
.
d©a
 :ğ
wd©a


855 
io
.
ı_»¥
.
v®id
 :ğ
	`BoŞ
(
Œue
)

857 
io
.
ı_»q
.
»ady
 :ğ!
ex_»g_v®id


859 
v®
 
wb_tošt_v®id
 = 
wb_»g_v®id
 && 
wb_ù¾
.
tošt


860 
v®
 
wb_tošt_exc
 = 
	`RegEÇbË
(
åiu
.
io
.
out
.
b™s
.
exc
, 
mem_ù¾
.
tošt
)

861 
io
.
fc¤_æags
.
v®id
 :ğ
wb_tošt_v®id
 || 
divSq¹_w’
 || 
	`w’
(0)

862 
io
.
fc¤_æags
.
b™s
 :=

863 
	`Mux
(
wb_tošt_v®id
, 
wb_tošt_exc
, 
	`UIÁ
(0)) |

864 
	`Mux
(
divSq¹_w’
, 
divSq¹_æags
, 
	`UIÁ
(0)) |

865 
	`Mux
(
	`w’
(0), 
wexc
, 
	`UIÁ
(0))

867 
v®
 
divSq¹_wr™e_pÜt_busy
 = (
mem_ù¾
.
div
 || mem_ù¾.
sq¹
è&& 
w’
.
ÜR


868 
io
.
fc¤_rdy
 :ğ!(
ex_»g_v®id
 && 
ex_ù¾
.
wæags
 || 
mem_»g_v®id
 && 
mem_ù¾
.wæag || 
wb_»g_v®id
 && 
wb_ù¾
.
tošt
 || 
w’
.
ÜR
 || 
divSq¹_šFlight
)

869 
io
.
Çck_mem
 :ğ
wr™e_pÜt_busy
 || 
divSq¹_wr™e_pÜt_busy
 || 
divSq¹_šFlight


870 
io
.
dec
 <> 
å_decod”
.io.
sigs


871 
def
 
	`u£ScÜebßrd
(
f
: ((
Pe
, 
IÁ
)è=> 
BoŞ
èğ
pes
.
zW™hIndex
.
	`f‹r
(
_
.
_1
.
Ït
 > 3).
	`m­
(
x
 => 
	`f
(x)).
	`fŞd
(
	`BoŞ
(
çl£
))(_||_)

872 
io
.
sbßrd_£t
 :ğ
wb_»g_v®id
 && !
wb_ı_v®id
 && 
	`Reg
(
Ãxt
=
	`u£ScÜebßrd
(
_
.
_1
.
	`cÚd
(
mem_ù¾
)è|| mem_ù¾.
div
 || mem_ù¾.
sq¹
)

873 
io
.
sbßrd_şr
 :ğ!
wb_ı_v®id
 && (
divSq¹_w’
 || (
	`w’
(0è&& 
	`u£ScÜebßrd
(
x
 => 
	`wbInfo
(0).
peid
 ==ğ
	`UIÁ
(x.
_2
))))

874 
io
.
sbßrd_ş¿
 :ğ
waddr


875 
	`ccov”
(
io
.
sbßrd_şr
 && 
lßd_wb
, "DUAL_WRITEBACK", "load‡nd FMA writeback on same cycle")

877 
io
.
Ëg®_rm
 :ğio.
	`š¡
(14,12).
	`isOÃOf
(5, 6è|| io.š¡(14,12è==ğ7 && io.
fc¤_rm
 >= 5

879 ià(
cfg
.
divSq¹
) {

880 
v®
 
divSq¹_kËd
 = 
	`Reg
(
	`BoŞ
())

881 
	`ccov”
(
divSq¹_šFlight
 && 
divSq¹_kËd
, "DIV_KILLED", "divide killed‡fter issuedo divider")

882 
	`ccov”
(
divSq¹_šFlight
 && 
mem_»g_v®id
 && (
mem_ù¾
.
div
 || mem_ù¾.
sq¹
), "DIV_BUSY", "divider structural hazard")

883 
	`ccov”
(
mem_»g_v®id
 && 
divSq¹_wr™e_pÜt_busy
, "DIV_WB_STRUCTURAL", "structural hazard on division writeback")

885 
t
 <- 
æßtTy³s
) {

886 
v®
 
g
 = !
mem_ù¾
.
sšgËOut


887 
v®
 
divSq¹
 = 
	`ModuË
(
Ãw
 
h¬dæßt
.
	`DivSq¹RecFN_sm®l
(
t
.
exp
,.
sig
, 0))

888 
divSq¹
.
io
.
šV®id
 :ğ
mem_»g_v®id
 && 
g
 ==ğ
	`ty³Tag
(
t
è&& (
mem_ù¾
.
div
 || mem_ù¾.
sq¹
è&& !
divSq¹_šFlight


889 
divSq¹
.
io
.
sq¹Op
 :ğ
mem_ù¾
.
sq¹


890 
divSq¹
.
io
.
a
 :ğ
maxTy³
.
	`un§ãCÚv”t
(
åiu
.io.
out
.
b™s
.
š
.
š1
, 
t
)

891 
divSq¹
.
io
.
b
 :ğ
maxTy³
.
	`un§ãCÚv”t
(
åiu
.io.
out
.
b™s
.
š
.
š2
, 
t
)

892 
divSq¹
.
io
.
roundšgMode
 :ğ
åiu
.io.
out
.
b™s
.
š
.
rm


893 
divSq¹
.
io
.
d‘eùTššess
 :ğ
h¬dæßt
.
cÚ¡s
.
tššess_aá”Roundšg


895 
	`wh’
 (!
divSq¹
.
io
.
šR—dy
è{ 
divSq¹_šFlight
 :ğ
Œue
 }

897 
	`wh’
 (
divSq¹
.
io
.
šV®id
 && divSq¹.io.
šR—dy
) {

898 
divSq¹_kËd
 :ğ
klm


899 
divSq¹_waddr
 :ğ
	`mem_»g_š¡
(11,7)

902 
	`wh’
 (
divSq¹
.
io
.
outV®id_div
 || divSq¹.io.
outV®id_sq¹
) {

903 
divSq¹_w’
 :ğ!
divSq¹_kËd


904 
divSq¹_wd©a
 :ğ
	`§n™izeNaN
(
divSq¹
.
io
.
out
, 
t
)

905 
divSq¹_æags
 :ğ
divSq¹
.
io
.
exû±iÚFÏgs


906 
divSq¹_ty³Tag
 :ğ
	`ty³Tag
(
t
)

910 
	`wh’
 (
id_ù¾
.
div
 || id_ù¾.
sq¹
è{ 
io
.
Ëg®_rm
 :ğ
Œue
 }

914 
şock_’_»g
 :=

915 
io
.
k“p_şock_’abËd
 ||

916 
io
.
v®id
 ||

917 
»q_v®id
 ||

918 
mem_»g_v®id
 || 
mem_ı_v®id
 ||

919 
wb_»g_v®id
 || 
wb_ı_v®id
 ||

920 
w’
.
ÜR
 || 
divSq¹_šFlight
 ||

921 
io
.
dmem_»¥_v®


923 
	}
}

925 
def
 
	$ccov”
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
desc
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) =

926 
	`cov”
(
cÚd
, 
s
"FPU_$Ïb–", "CÜe;;" + 
desc
)

927 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Interrupts.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 şas 
	cTeIÁ”ru±s
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

13 
v®
 
debug
 = 
	$BoŞ
()

14 
v®
 
mt
 = 
	$BoŞ
()

15 
v®
 
ms
 = 
	$BoŞ
()

16 
v®
 
me
 = 
	$BoŞ
()

17 
v®
 
£
 = 
usšgVM
.
	`İtiÚ
(
	$BoŞ
())

18 
v®
 
l
 = 
	`Vec
(
cÜeP¬ams
.
nLoÿlIÁ”ru±s
, 
	`BoŞ
())

22 
Œa™
 
HasEx‹º®IÁ”ru±s
 { 
this
: 
Ba£Te
 =>

24 
v®
 
štInw¬dNode
 = 
štXb¬
.
šŠode
 :=* 
	`IÁId’t™yNode
()(
	`V®Name
("int_local"))

25 
´Ùeùed
 
v®
 
štSškNode
 = 
	`IÁSškNode
(
	`IÁSškPÜtSim¶e
())

26 
štSškNode
 :ğ
štXb¬
.
šŠode


28 
def
 
ıuDeviû
: 
Deviû


29 
v®
 
štcDeviû
 = 
Ãw
 
DeviûSn³t
 {

30 
ov”ride
 
def
 
·»Á
 = 
	`Some
(
ıuDeviû
)

31 
def
 
	`desüibe
(): 
DesütiÚ
 = {

32 
	`DesütiÚ
("š‹¼u±-cÚŒŞËr", 
	`M­
(

33 "com·tibË" -> "riscv,ıu-štc".
asPrİ”ty
,

34 "š‹¼u±-cÚŒŞËr" -> 
N
,

35 "#š‹¼u±-ûÎs" -> 1.a
sPrİ”ty
))

39 
ResourûBšdšg
 {

40 
štSškNode
.
edges
.
š
.
	`æ©M­
(
_
.
sourû
.
sourûs
).
m­
 { 
s
 =>

41 
i
 <- 
s
.
¿nge
.
¡¬t
 
uÁ
 s.¿nge.
’d
) {

42 
c¤IÁM­
.
	`liá
(
i
).
fÜ—ch
 { 
j
 =>

43 
s
.
»sourûs
.
fÜ—ch
 { 
r
 =>

44 
r
.
	`bšd
(
štcDeviû
, 
	`ResourûIÁ
(
j
))

56 
def
 
c¤IÁM­
: 
Li¡
[
IÁ
] = {

57 
v®
 
Æs
 = 
teP¬ams
.
cÜe
.
nLoÿlIÁ”ru±s


58 
v®
 
£
 = ià(
usšgVM
è
	`Seq
(9è
N


59 
	`Li¡
(65535, 3, 7, 11è++ 
£
 ++ 
Li¡
.
	`buÏ‹
(
Æs
)(
_
 + 16)

63 
def
 
	`decodeCÜeIÁ”ru±s
(
cÜe
: 
TeIÁ”ru±s
) {

64 
v®
 
async_s
 = 
	`Seq
(
cÜe
.
debug
)

65 
v®
 
³rh_s
 = 
	`Seq
(

66 
cÜe
.
ms
,

67 
cÜe
.
mt
,

68 
cÜe
.
me
)

70 
v®
 
£
 = ià(
cÜe
.£.
isDefšed
è
	`Seq
(cÜe.£.
g‘
è
N


72 
v®
 
cÜe_s
 = 
cÜe
.
l


74 
	`v®
 (
š‹¼u±s
, 
_
èğ
štSškNode
.
	`š
(0)

75 (
async_s
 ++ 
³rh_s
 ++ 
£
 ++ 
cÜe_s
).
	`z
(
š‹¼u±s
).
fÜ—ch
 { (
c
, 
i
) => c := i }

77 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/L1Cache.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gP¬am‘”s
, 
	gF›ld
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
CacheBlockBy‹s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
Cl›ÁM‘ad©a


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


12 
Œa™
 
	gL1CacheP¬ams
 {

13 
def
 
	gnS‘s
: 
IÁ


14 
def
 
nWays
: 
IÁ


15 
def
 
rowB™s
: 
IÁ


16 
def
 
nTLBEÁr›s
: 
IÁ


17 
def
 
blockBy‹s
: 
IÁ


20 
Œa™
 
HasL1CacheP¬am‘”s
 
ex‹nds
 
HasTeP¬am‘”s
 {

21 
v®
 
ÿcheP¬ams
: 
L1CacheP¬ams


22 
´iv©e
 
v®
 
bundËP¬ams
 = 
p
(
Sh¬edMemÜyTLEdge
).
bundË


24 
def
 
nS‘s
 = 
ÿcheP¬ams
.nSets

25 
def
 
blockOffB™s
 = 
lgCacheBlockBy‹s


26 
def
 
idxB™s
 = 
log2Up
(
ÿcheP¬ams
.
nS‘s
)

27 
def
 
uÁagB™s
 = 
blockOffB™s
 + 
idxB™s


28 
def
 
gB™s
 = 
bundËP¬ams
.
add»ssB™s
 - (ià(
usšgVM
è
uÁagB™s
 
mš
 
pgIdxB™s
 untagBits)

29 
def
 
nWays
 = 
ÿcheP¬ams
.nWays

30 
def
 
wayB™s
 = 
log2Up
(
nWays
)

31 
def
 
isDM
 = 
nWays
 == 1

32 
def
 
rowB™s
 = 
ÿcheP¬ams
.rowBits

33 
def
 
rowBy‹s
 = 
rowB™s
/8

34 
def
 
rowOffB™s
 = 
log2Up
(
rowBy‹s
)

35 
def
 
nTLBEÁr›s
 = 
ÿcheP¬ams
.nTLBEntries

37 
def
 
ÿcheD©aB™s
 = 
bundËP¬ams
.
d©aB™s


38 
def
 
ÿcheD©aB—ts
 = (
ÿcheBlockBy‹s
 * 8è/ 
ÿcheD©aB™s


39 
def
 
»flCyşes
 = 
ÿcheD©aB—ts


42 
ab¡¿ù
 
şass
 
	$L1CacheModuË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË


43 
w™h
 
HasL1CacheP¬am‘”s


45 
ab¡¿ù
 
şass
 
	$L1CacheBundË
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$P¬am‘”izedBundË
()(
p
)

46 
w™h
 
HasL1CacheP¬am‘”s


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/LazyRoCC.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


6 
impÜt
 
	gChi£l
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
InOrd”Arb™”


15 
objeù
 
BudRoCC
 
ex‹nds
 
	gF›ld
[
Seq
[
P¬am‘”s
 => 
LazyRoCC
]](
N
)

17 şas 
	cRoCCIn¡ruùiÚ
 
ex‹nds
 
BundË
 {

18 
v®
 
funù
 = 
	$B™s
(
width
 = 7)

19 
v®
 
rs2
 = 
	$B™s
(
width
 = 5)

20 
v®
 
rs1
 = 
	$B™s
(
width
 = 5)

21 
v®
 
xd
 = 
	$BoŞ
()

22 
v®
 
xs1
 = 
	$BoŞ
()

23 
v®
 
xs2
 = 
	$BoŞ
()

24 
v®
 
rd
 = 
	$B™s
(
width
 = 5)

25 
v®
 
İcode
 = 
	`B™s
(
width
 = 7)

28 şas 
	cRoCCCommªd
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

29 
v®
 
š¡
 = 
Ãw
 
RoCCIn¡ruùiÚ


30 
v®
 
rs1
 = 
	$B™s
(
width
 = 
xL’
)

31 
v®
 
rs2
 = 
	$B™s
(
width
 = 
xL’
)

32 
v®
 
¡©us
 = 
Ãw
 
MStus


35 şas 
	cRoCCRe¥Ú£
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

36 
v®
 
rd
 = 
	$B™s
(
width
 = 5)

37 
v®
 
d©a
 = 
	`B™s
(
width
 = 
xL’
)

40 şas 
	cRoCCCÜeIO
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$CÜeBundË
()(
p
) {

41 
v®
 
cmd
 = 
	`Decou¶ed
(
Ãw
 
RoCCCommªd
).
æ


42 
v®
 
»¥
 = 
	$Decou¶ed
(
Ãw
 
RoCCRe¥Ú£
)

43 
v®
 
mem
 = 
Ãw
 
H–ÏCacheIO


44 
v®
 
busy
 = 
	$BoŞ
(
OUTPUT
)

45 
v®
 
š‹¼u±
 = 
	$BoŞ
(
OUTPUT
)

46 
v®
 
exû±iÚ
 = 
	`BoŞ
(
INPUT
)

49 şas 
	cRoCCIO
(
v®
 
nPTWPÜts
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$RoCCCÜeIO
()(
p
) {

50 
v®
 
±w
 = 
	$Vec
(
nPTWPÜts
, 
Ãw
 
TLBPTWIO
)

51 
v®
 
åu_»q
 = 
	$Decou¶ed
(
Ãw
 
FPIÅut
)

52 
v®
 
åu_»¥
 = 
	`Decou¶ed
(
Ãw
 
FPResuÉ
).
æ


56 
ab¡¿ù
 
şass
 
	$LazyRoCC
(

57 
v®
 
İcodes
: 
OpcodeS‘
,

58 
v®
 
nPTWPÜts
: 
IÁ
 = 0,

59 
v®
 
u£sFPU
: 
BoŞ—n
 = 
çl£


60 )(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

61 
v®
 
moduË
: 
LazyRoCCModuËImp


62 
v®
 
©lNode
: 
TLNode
 = 
	`TLId’t™yNode
()

63 
v®
 
Node
: 
TLNode
 = 
	`TLId’t™yNode
()

64 
	}
}

66 şas 
	cLazyRoCCModuËImp
(
ou‹r
: 
LazyRoCC
è
ex‹nds
 
	$LazyModuËImp
(
ou‹r
) {

67 
v®
 
io
 = 
	`IO
(
Ãw
 
	`RoCCIO
(
ou‹r
.
nPTWPÜts
))

72 
Œa™
 
HasLazyRoCC
 
ex‹nds
 
CªHavePTW
 { 
this
: 
Ba£Te
 =>

73 
v®
 
roccs
 = 
	`p
(
BudRoCC
).
	`m­
(
	`_
(
p
))

75 
roccs
.
	`m­
(
_
.
©lNode
).
fÜ—ch
 { 
©l
 => 
Ma¡”Xb¬
.
node
 :=*‡tl }

76 
roccs
.
	`m­
(
_
.
Node
).
fÜ—ch
 { 

 => 
Oth”Ma¡”sNode
 :=*l }

78 
nPTWPÜts
 +ğ
roccs
.
	`m­
(
_
.nPTWPÜts).
	`fŞdLeá
(0)(_ + _)

79 
nDCachePÜts
 +ğ
roccs
.
size


80 
	}
}

82 
Œa™
 
HasLazyRoCCModuË
 
ex‹nds
 
CªHavePTWModuË


83 
w™h
 
HasCÜeP¬am‘”s
 { 
this
: 
Rock‘TeModuËImp
 w™h 
HasFpuO±
 =>

85 
v®
 (
»¥Arb
, 
cmdRou‹r
èğif(
ou‹r
.
roccs
.
size
 > 0) {

86 
v®
 
»¥Arb
 = 
ModuË
(
Ãw
 
RRArb™”
Òew 
RoCCRe¥Ú£
()(
ou‹r
.
p
), ou‹r.
roccs
.
size
))

87 
v®
 
	gcmdRou‹r
 = 
ModuË
(
Ãw
 
RoccCommªdRou‹r
(
ou‹r
.
roccs
.
m­
(
_
.
İcodes
))(ou‹r.
p
))

88 
ou‹r
.
roccs
.
zW™hIndex
.
fÜ—ch
 { (
rocc
, 
i
) =>

89 
±wPÜts
 ++ğ
rocc
.
moduË
.
io
.
±w


90 
rocc
.
moduË
.
io
.
cmd
 <> 
cmdRou‹r
.io.
out
(
i
)

91 
v®
 
dcIF
 = 
ModuË
(
Ãw
 
Sim¶eH–ÏCacheIF
()(
ou‹r
.
p
))

92 
dcIF
.
io
.
»que¡Ü
 <> 
rocc
.
moduË
.io.
mem


93 
dÿchePÜts
 +ğ
dcIF
.
io
.
ÿche


94 
»¥Arb
.
io
.
š
(
i
è<> 
Queue
(
rocc
.
moduË
.io.
»¥
)

97 
åuO±
 
	gfÜ—ch
 { 
	gåu
 =>

98 
v®
 
nFPUPÜts
 = 
ou‹r
.
roccs
.
f‹r
(
_
.
u£sFPU
).
size


99 ià(
usšgFPU
 && 
nFPUPÜts
 > 0) {

100 
v®
 
åArb
 = 
ModuË
(
Ãw
 
InOrd”Arb™”
Òew 
FPIÅut
()(
ou‹r
.
p
),‚ew 
FPResuÉ
()(ou‹r.p), 
nFPUPÜts
))

101 
v®
 
	gå_rocc_ios
 = 
ou‹r
.
roccs
.
f‹r
(
_
.
u£sFPU
).
m­
(_.
moduË
.
io
)

102 
åArb
.
io
.
š_»q
 <> 
å_rocc_ios
.
m­
(
_
.
åu_»q
)

103 
å_rocc_ios
.
z
(
åArb
.
io
.
š_»¥
).
fÜ—ch
 {

104 (
rocc
, 
¬b
è=>„occ.
åu_»¥
 <>‡rb

106 
	gåu
.
	gio
.
	gı_»q
 <> 
	gåArb
.io.
out_»q


107 
	gåArb
.
	gio
.
	gout_»¥
 <> 
	gåu
.io.
	gı_»¥


109 
	gåu
.
	gio
.
	gı_»q
.
	gv®id
 :ğ
BoŞ
(
çl£
)

110 
åu
.
io
.
ı_»¥
.
»ady
 :ğ
BoŞ
(
çl£
)

113 (
Some
(
»¥Arb
), Some(
cmdRou‹r
))

115 (
	gNÚe
, None)

119 
şass
 
	$AccumuÏtÜExam¶e
(
İcodes
: 
OpcodeS‘
, 
v®
 
n
: 
IÁ
 = 4)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$LazyRoCC
(
İcodes
) {

120 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`AccumuÏtÜExam¶eModuËImp
(
this
)

121 
	}
}

123 şas 
	cAccumuÏtÜExam¶eModuËImp
(
ou‹r
: 
AccumuÏtÜExam¶e
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$LazyRoCCModuËImp
(
ou‹r
)

124 
w™h
 
HasCÜeP¬am‘”s
 {

125 
v®
 
»gfe
 = 
	`Mem
(
ou‹r
.
n
, 
	$UIÁ
(
width
 = 
xL’
))

126 
v®
 
busy
 = 
	`Reg
(
š™
 = 
Vec
.
	$fl
(
ou‹r
.
n
){
	`BoŞ
(
çl£
)})

128 
v®
 
cmd
 = 
	$Queue
(
io
.
cmd
)

129 
v®
 
funù
 = 
cmd
.
b™s
.
š¡
.funct

130 
v®
 
addr
 = 
cmd
.
b™s
.
	`rs2
(
	`log2Up
(
ou‹r
.
n
)-1,0)

131 
v®
 
doWr™e
 = 
funù
 ==ğ
	$UIÁ
(0)

132 
v®
 
doR—d
 = 
funù
 ==ğ
	$UIÁ
(1)

133 
v®
 
doLßd
 = 
funù
 ==ğ
	$UIÁ
(2)

134 
v®
 
doAccum
 = 
funù
 ==ğ
	$UIÁ
(3)

135 
v®
 
memRe¥Tag
 = 
io
.
mem
.
»¥
.
b™s
.
	`g
(
	`log2Up
(
ou‹r
.
n
)-1,0)

138 
v®
 
add’d
 = 
cmd
.
b™s
.
rs1


139 
v®
 
accum
 = 
	$»gfe
(
addr
)

140 
v®
 
wd©a
 = 
	`Mux
(
doWr™e
, 
add’d
, 
accum
 +‡ddend)

142 
	`wh’
 (
cmd
.
	`fœe
(è&& (
doWr™e
 || 
doAccum
)) {

143 
	`»gfe
(
addr
è:ğ
wd©a


144 
	}
}

146 
	$wh’
 (
io
.
mem
.
»¥
.
v®id
) {

147 
	`»gfe
(
memRe¥Tag
è:ğ
io
.
mem
.
»¥
.
b™s
.
d©a


148 
	`busy
(
memRe¥Tag
è:ğ
	`BoŞ
(
çl£
)

149 
	}
}

152 
wh’
 (
io
.
mem
.
»q
.
	$fœe
()) {

153 
	`busy
(
addr
è:ğ
	`BoŞ
(
Œue
)

154 
	}
}

156 
v®
 
doRe¥
 = 
cmd
.
b™s
.
š¡
.
xd


157 
v®
 
¡®lReg
 = 
	$busy
(
addr
)

158 
v®
 
¡®lLßd
 = 
doLßd
 && !
io
.
mem
.
»q
.
»ady


159 
v®
 
¡®lRe¥
 = 
doRe¥
 && !
io
.
»¥
.
»ady


161 
cmd
.
»ady
 :ğ!
¡®lReg
 && !
¡®lLßd
 && !
¡®lRe¥


165 
io
.
»¥
.
v®id
 :ğ
cmd
.v®id && 
doRe¥
 && !
¡®lReg
 && !
¡®lLßd


167 
io
.
»¥
.
b™s
.
rd
 :ğ
cmd
.b™s.
š¡
.rd

169 
io
.
»¥
.
b™s
.
d©a
 :ğ
accum


172 
io
.
busy
 :ğ
cmd
.
v®id
 || busy.
	`»duû
(
_
||_)

174 
io
.
š‹¼u±
 :ğ
	$BoŞ
(
çl£
)

178 
io
.
mem
.
»q
.
v®id
 :ğ
cmd
.v®id && 
doLßd
 && !
¡®lReg
 && !
¡®lRe¥


179 
io
.
mem
.
»q
.
b™s
.
addr
 :ğ
add’d


180 
io
.
mem
.
»q
.
b™s
.
g
 :ğ
addr


181 
io
.
mem
.
»q
.
b™s
.
cmd
 :ğ
M_XRD


182 
io
.
mem
.
»q
.
b™s
.
typ
 :ğ
MT_D


183 
io
.
mem
.
»q
.
b™s
.
d©a
 :ğ
	$B™s
(0)

184 
io
.
mem
.
»q
.
b™s
.
phys
 :ğ
	`BoŞ
(
çl£
)

185 
	}
}

187 
şass
 
	$T¿n¦©ÜExam¶e
(
İcodes
: 
OpcodeS‘
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$LazyRoCC
(
İcodes
, 
nPTWPÜts
 = 1) {

188 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`T¿n¦©ÜExam¶eModuËImp
(
this
)

189 
	}
}

191 şas 
	cT¿n¦©ÜExam¶eModuËImp
(
ou‹r
: 
T¿n¦©ÜExam¶e
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$LazyRoCCModuËImp
(
ou‹r
)

192 
w™h
 
HasCÜeP¬am‘”s
 {

193 
v®
 
»q_addr
 = 
	`Reg
(
	$UIÁ
(
width
 = 
cÜeMaxAddrB™s
))

194 
v®
 
»q_rd
 = 
	$Reg
(
io
.
»¥
.
b™s
.
rd
)

195 
v®
 
»q_off£t
 = 
	`»q_addr
(
pgIdxB™s
 - 1, 0)

196 
v®
 
»q_v²
 = 
	`»q_addr
(
cÜeMaxAddrB™s
 - 1, 
pgIdxB™s
)

197 
v®
 
±e
 = 
	$Reg
(
Ãw
 
PTE
)

199 
v®
 
s_idË
 :: 
s_±w_»q
 :: 
s_±w_»¥
 :: 
s_»¥
 :: 
N
 = 
	`Enum
(
	`B™s
(), 4)

200 
v®
 
¡©e
 = 
	$Reg
(
š™
 = 
s_idË
)

202 
io
.
cmd
.
»ady
 :ğ(
¡©e
 ==ğ
s_idË
)

204 
	`wh’
 (
io
.
cmd
.
	$fœe
()) {

205 
»q_rd
 :ğ
io
.
cmd
.
b™s
.
š¡
.
rd


206 
»q_addr
 :ğ
io
.
cmd
.
b™s
.
rs1


207 
¡©e
 :ğ
s_±w_»q


210 
´iv©e
 
v®
 
±w
 = 
io
.
	$±w
(0)

212 
	`wh’
 (
±w
.
»q
.
	$fœe
()è{ 
¡©e
 :ğ
s_±w_»¥
 
	}
}

214 
	$wh’
 (
¡©e
 ==ğ
s_±w_»¥
 && 
±w
.
»¥
.
v®id
) {

215 
±e
 :ğ
±w
.
»¥
.
b™s
.pte

216 
¡©e
 :ğ
s_»¥


217 
	}
}

219 
wh’
 (
io
.
»¥
.
	$fœe
()è{ 
¡©e
 :ğ
s_idË
 
	}
}

221 
±w
.
»q
.
v®id
 :ğ(
¡©e
 ==ğ
s_±w_»q
)

222 
±w
.
»q
.
b™s
.
v®id
 :ğ
Œue
.
B


223 
±w
.
»q
.
b™s
.b™s.
addr
 :ğ
»q_v²


225 
io
.
»¥
.
v®id
 :ğ(
¡©e
 ==ğ
s_»¥
)

226 
io
.
»¥
.
b™s
.
rd
 :ğ
»q_rd


227 
io
.
»¥
.
b™s
.
d©a
 :ğ
Mux
(
±e
.
Ëaf
(), 
C©
Õ‹.
µn
, 
»q_off£t
), 
SIÁ
(-1, 
xL’
).
asUIÁ
)

229 
	gio
.
	gbusy
 :ğ(
¡©e
 =/ğ
s_idË
)

230 
io
.
š‹¼u±
 :ğ
	$BoŞ
(
çl£
)

231 
io
.
mem
.
»q
.
v®id
 :ğ
	`BoŞ
(
çl£
)

232 
	}
}

234 şas 
	cCh¬aù”CouÁExam¶e
(
İcodes
: 
OpcodeS‘
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$LazyRoCC
(
İcodes
) {

235 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$Ch¬aù”CouÁExam¶eModuËImp
(
this
)

236 
ov”ride
 
v®
 
©lNode
 = 
	`TLCl›ÁNode
(
	`Seq
(
	`TLCl›ÁPÜtP¬am‘”s
(Seq(
	`TLCl›ÁP¬am‘”s
("CharacterCountRoCC")))))

239 şas 
	cCh¬aù”CouÁExam¶eModuËImp
(
ou‹r
: 
Ch¬aù”CouÁExam¶e
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$LazyRoCCModuËImp
(
ou‹r
)

240 
w™h
 
HasCÜeP¬am‘”s


241 
w™h
 
HasL1CacheP¬am‘”s
 {

242 
v®
 
ÿcheP¬ams
 = 
teP¬ams
.
iÿche
.
g‘


244 
´iv©e
 
v®
 
blockOff£t
 = 
blockOffB™s


245 
´iv©e
 
v®
 
b—tOff£t
 = 
	`log2Up
(
ÿcheD©aB™s
/8)

247 
v®
 
ÃedË
 = 
	`Reg
(
	$UIÁ
(
width
 = 8))

248 
v®
 
addr
 = 
	`Reg
(
	$UIÁ
(
width
 = 
cÜeMaxAddrB™s
))

249 
v®
 
couÁ
 = 
	`Reg
(
	$UIÁ
(
width
 = 
xL’
))

250 
v®
 
»¥_rd
 = 
	$Reg
(
io
.
»¥
.
b™s
.
rd
)

252 
v®
 
addr_block
 = 
	`addr
(
cÜeMaxAddrB™s
 - 1, 
blockOff£t
)

253 
v®
 
off£t
 = 
	`addr
(
blockOff£t
 - 1, 0)

254 
v®
 
Ãxt_addr
 = (
addr_block
 + 
	`UIÁ
(1)è<< 
	$UIÁ
(
blockOff£t
)

256 
v®
 
s_idË
 :: 
s_acq
 :: 
s_gÁ
 :: 
s_check
 :: 
s_»¥
 :: 
N
 = 
	`Enum
(
	`B™s
(), 5)

257 
v®
 
¡©e
 = 
	$Reg
(
š™
 = 
s_idË
)

259 
	`v®
 (
_out
, 
edgesOut
èğ
ou‹r
.
©lNode
.
	$out
(0)

260 
v®
 
gÁ
 = 
_out
.
d
.
b™s


261 
v®
 
»cv_d©a
 = 
	`Reg
(
	$UIÁ
(
width
 = 
ÿcheD©aB™s
))

262 
v®
 
»cv_b—t
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Up
(
ÿcheD©aB—ts
+1)), 
š™
 = 
	$UIÁ
(0))

264 
v®
 
d©a_by‹s
 = 
Vec
.
	`buÏ‹
(
ÿcheD©aB™s
/8è{ 
i
 => 
	`»cv_d©a
(8 * (i + 1) - 1, 8 * i) }

265 
v®
 
z”o_m©ch
 = 
d©a_by‹s
.
	`m­
(
_
 ==ğ
	$UIÁ
(0))

266 
v®
 
ÃedË_m©ch
 = 
d©a_by‹s
.
	$m­
(
_
 ==ğ
ÃedË
)

267 
v®
 
fœ¡_z”o
 = 
	$PriÜ™yEncod”
(
z”o_m©ch
)

269 
v®
 
ch¬s_found
 = 
	`PİCouÁ
(
ÃedË_m©ch
.
zW™hIndex
.
m­
 {

270 (
m©ches
, 
i
) =>

271 
v®
 
idx
 = 
	`C©
(
»cv_b—t
 - 
	`UIÁ
(1), UIÁ(
i
, 
b—tOff£t
))

272 
m©ches
 && 
idx
 >ğ
off£t
 && 
	`UIÁ
(
i
è<ğ
fœ¡_z”o


273 
	}
})

274 
v®
 
	gz”o_found
 = 
z”o_m©ch
.
»duû
(
_
 || _)

275 
v®
 
fšished
 = 
Reg
(
	$BoŞ
())

277 
io
.
cmd
.
»ady
 :ğ(
¡©e
 ==ğ
s_idË
)

278 
io
.
»¥
.
v®id
 :ğ(
¡©e
 ==ğ
s_»¥
)

279 
io
.
»¥
.
b™s
.
rd
 :ğ
»¥_rd


280 
io
.
»¥
.
b™s
.
d©a
 :ğ
couÁ


281 
_out
.
a
.
v®id
 :ğ(
¡©e
 ==ğ
s_acq
)

282 
_out
.
a
.
b™s
 :ğ
edgesOut
.
	`G‘
(

283 
äomSourû
 = 
	`UIÁ
(0),

284 
toAdd»ss
 = 
addr_block
 << 
blockOff£t
,

285 
lgSize
 = 
	`UIÁ
(
lgCacheBlockBy‹s
)).
_2


286 
_out
.
d
.
»ady
 :ğ(
¡©e
 ==ğ
s_gÁ
)

288 
	`wh’
 (
io
.
cmd
.
	$fœe
()) {

289 
addr
 :ğ
io
.
cmd
.
b™s
.
rs1


290 
ÃedË
 :ğ
io
.
cmd
.
b™s
.
rs2


291 
»¥_rd
 :ğ
io
.
cmd
.
b™s
.
š¡
.
rd


292 
couÁ
 :ğ
	`UIÁ
(0)

293 
fšished
 :ğ
	`BoŞ
(
çl£
)

294 
¡©e
 :ğ
s_acq


295 
	}
}

297 
wh’
 (
_out
.
a
.
	$fœe
()è{ 
¡©e
 :ğ
s_gÁ
 
	}
}

299 
wh’
 (
_out
.
d
.
	$fœe
()) {

300 
»cv_b—t
 :ğ»cv_b—ˆ+ 
	`UIÁ
(1)

301 
»cv_d©a
 :ğ
gÁ
.
d©a


302 
¡©e
 :ğ
s_check


303 
	}
}

305 
	$wh’
 (
¡©e
 ==ğ
s_check
) {

306 
	`wh’
 (!
fšished
) {

307 
couÁ
 :ğcouÁ + 
ch¬s_found


309 
	`wh’
 (
z”o_found
è{ 
fšished
 :ğ
	`BoŞ
(
Œue
) }

310 
	`wh’
 (
»cv_b—t
 ==ğ
	`UIÁ
(
ÿcheD©aB—ts
)) {

311 
addr
 :ğ
Ãxt_addr


312 
¡©e
 :ğ
	`Mux
(
z”o_found
 || 
fšished
, 
s_»¥
, 
s_acq
)

313 } .
Ùh”wi£
 {

314 
¡©e
 :ğ
s_gÁ


316 
	}
}

318 
wh’
 (
io
.
»¥
.
	$fœe
()è{ 
¡©e
 :ğ
s_idË
 
	}
}

320 
io
.
busy
 :ğ(
¡©e
 =/ğ
s_idË
)

321 
io
.
š‹¼u±
 :ğ
	$BoŞ
(
çl£
)

322 
io
.
mem
.
»q
.
v®id
 :ğ
	$BoŞ
(
çl£
)

324 
_out
.
b
.
»ady
 :ğ
	$BoŞ
(
Œue
)

325 
_out
.
c
.
v®id
 :ğ
	$BoŞ
(
çl£
)

326 
_out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

327 
	}
}

329 
şass
 
	$OpcodeS‘
(
v®
 
İcodes
: 
Seq
[
UIÁ
]) {

330 
def
 |(
£t
: 
OpcodeS‘
) =

331 
Ãw
 
	`OpcodeS‘
(
this
.
İcodes
 ++ 
£t
.opcodes)

333 
def
 
	`m©ches
(
oc
: 
UIÁ
èğ
İcodes
.
	`m­
(
_
 ==ğoc).
	`»duû
(_ || _)

334 
	}
}

336 
objeù
 
OpcodeS‘
 {

337 
def
 
cu¡om0
 = 
Ãw
 
OpcodeS‘
(
Seq
(
B™s
("b0001011")))

338 
def
 
cu¡om1
 = 
Ãw
 
OpcodeS‘
(
Seq
(
B™s
("b0101011")))

339 
def
 
cu¡om2
 = 
Ãw
 
OpcodeS‘
(
Seq
(
B™s
("b1011011")))

340 
def
 
cu¡om3
 = 
Ãw
 
OpcodeS‘
(
Seq
(
B™s
("b1111011")))

341 
def
 
®l
 = 
cu¡om0
 | 
cu¡om1
 | 
cu¡om2
 | 
cu¡om3


344 
şass
 
	$RoccCommªdRou‹r
(
İcodes
: 
Seq
[
OpcodeS‘
])(
im¶ic™
 
p
: 
P¬am‘”s
)

345 
ex‹nds
 
	$CÜeModuË
()(
p
) {

346 
v®
 
io
 = 
Ãw
 
BundË
 {

347 
v®
 
š
 = 
	`Decou¶ed
(
Ãw
 
RoCCCommªd
).
æ


348 
v®
 
out
 = 
	`Vec
(
İcodes
.
size
, 
	`Decou¶ed
(
Ãw
 
RoCCCommªd
))

349 
v®
 
busy
 = 
	`BoŞ
(
OUTPUT
)

352 
v®
 
cmd
 = 
	`Queue
(
io
.
š
)

353 
v®
 
cmdR—dys
 = 
io
.
out
.
	`z
(
İcodes
).
m­
 { (out, 
İcode
) =>

354 
v®
 
me
 = 
İcode
.
	`m©ches
(
cmd
.
b™s
.
š¡
.opcode)

355 
out
.
v®id
 :ğ
cmd
.v®id && 
me


356 
out
.
b™s
 :ğ
cmd
.bits

357 
out
.
»ady
 && 
me


359 
cmd
.
»ady
 :ğ
cmdR—dys
.
	`»duû
(
_
 || _)

360 
io
.
busy
 :ğ
cmd
.
v®id


362 
	`as£¹
(
	`PİCouÁ
(
cmdR—dys
è<ğ
	`UIÁ
(1),

364 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/RocketTile.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
te


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


15 
şass
 
Rock‘TeP¬ams
(

16 
cÜe
: 
Rock‘CÜeP¬ams
 = RocketCoreParams(),

17 
iÿche
: 
O±iÚ
[
ICacheP¬ams
] = 
Some
(ICacheParams()),

18 
dÿche
: 
O±iÚ
[
DCacheP¬ams
] = 
Some
(DCacheParams()),

19 
btb
: 
O±iÚ
[
BTBP¬ams
] = 
Some
(BTBParams()),

20 
d©aSü©ch·dBy‹s
: 
IÁ
 = 0,

21 
Œaû
: 
BoŞ—n
 = 
çl£
,

22 
hcfOnUncÜ»ùabË
: 
BoŞ—n
 = 
çl£
,

23 
Çme
: 
O±iÚ
[
SŒšg
] = 
Some
("tile"),

24 
h¬tId
: 
IÁ
 = 0,

25 
block”CŒlAddr
: 
O±iÚ
[
BigIÁ
] = 
NÚe
,

26 
bound¬yBufãrs
: 
BoŞ—n
 = 
çl£


27 è
ex‹nds
 
TeP¬ams
 {

28 
»quœe
(
iÿche
.
isDefšed
)

29 
»quœe
(
dÿche
.
isDefšed
)

32 
şass
 
	$Rock‘Te
(

33 
v®
 
rock‘P¬ams
: 
Rock‘TeP¬ams
,

34 
üossšg
: 
ClockCrossšgTy³
)

35 (
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Ba£Te
(
rock‘P¬ams
, 
üossšg
)(
p
)

36 
w™h
 
HasEx‹º®IÁ”ru±s


37 
w™h
 
HasLazyRoCC


38 
w™h
 
HasH–ÏCache


39 
w™h
 
HasICacheFrÚ‹nd
 {

41 
v®
 
štOutw¬dNode
 = 
	`IÁId’t™yNode
()

42 
v®
 
¦aveNode
 = 
	`TLId’t™yNode
()

43 
v®
 
ma¡”Node
 = 
	`TLId’t™yNode
()

45 
v®
 
dtim_ad­‹r
 = 
teP¬ams
.
dÿche
.
æ©M­
 { 
d
 => d.
sü©ch
.
	`m­
(
s
 =>

46 
	`LazyModuË
(
Ãw
 
	`Sü©ch·dSÏvePÜt
(
	`Add»ssS‘
(
s
, 
d
.
d©aSü©ch·dBy‹s
-1), 
xBy‹s
, 
teP¬ams
.
cÜe
.
u£Atomics
 && !teP¬ams.cÜe.
u£AtomicsOÆyFÜIO
)))

48 
dtim_ad­‹r
.
	`fÜ—ch
(
lm
 => 
	`cÚÃùTLSÏve
Öm.
node
, 
xBy‹s
))

50 
v®
 
bus_”rÜ_un™
 = 
teP¬ams
.
cÜe
.
teCÚŒŞAddr
 
m­
 { 
a
 =>

51 
v®
 
beu
 = 
	`LazyModuË
(
Ãw
 
	`BusE¼ÜUn™
Òew 
L1BusE¼Üs
, 
	`BusE¼ÜUn™P¬ams
(
a
)))

52 
štOutw¬dNode
 :ğ
beu
.
štNode


53 
	`cÚÃùTLSÏve
(
beu
.
node
, 
xBy‹s
)

54 
beu


57 
v®
 
te_ma¡”_block”
 =

58 
teP¬ams
.
block”CŒlAddr


59 .
	`m­
(
	`BasicBusBlock”P¬ams
(
_
, 
xBy‹s
, 
ma¡”PÜtB—tBy‹s
, 
d—dlock
 = 
Œue
))

60 .
	`m­
(
bp
 => 
	`LazyModuË
(
Ãw
 
	`BasicBusBlock”
(bp)))

62 
te_ma¡”_block”
.
	`fÜ—ch
(
lm
 => 
	`cÚÃùTLSÏve
Öm.
cÚŒŞNode
, 
xBy‹s
))

65 
Oth”Ma¡”sNode
 :ğ
te_ma¡”_block”
.
m­
 { 
_
.
node
 :ğ
Ma¡”Xb¬
.nod} 
g‘OrEl£
 {lMasterXbar.node }

66 
ma¡”Node
 :=* 
Oth”Ma¡”sNode


67 
Di§bËMÚ™Üs
 { 
im¶ic™
 
p
 => 
SÏveXb¬
.
node
 :*ğ
¦aveNode
 }

69 
def
 
fšdSü©ch·dFromICache
: 
O±iÚ
[
Add»ssS‘
] = 
dtim_ad­‹r
.
m­
 { 
s
 =>

70 
v®
 
fš®Node
 = 
äÚ‹nd
.
ma¡”Node
.
edges
.
out
.
h—d
.
mªag”
.
mªag”s
.
	`fšd
(
_
.
nodeP©h
.
Ï¡
 =ğ
s
.
node
)

71 
	`»quœe
 (
fš®Node
.
isDefšed
, "Could‚ot findhe scratch…ad;‚ot„eachable via icache?")

72 
	`»quœe
 (
fš®Node
.
g‘
.
add»ss
.
size
 == 1, "Scratchpad‡ddress space was fragmented!")

73 
fš®Node
.
g‘
.
	`add»ss
(0)

76 
nDCachePÜts
 +ğ1 + (
dtim_ad­‹r
.
isDefšed
).
toIÁ


78 
v®
 
dtimPrİ”ty
 = 
dtim_ad­‹r
.
	`m­
(
d
 => 
	`M­
(

79 "sifive,dtim" -> 
d
.
deviû
.
asPrİ”ty
)).
	`g‘OrEl£
(
N
)

81 
v®
 
™imPrİ”ty
 = 
teP¬ams
.
iÿche
.
	`æ©M­
(
_
.
™imAddr
.
	`m­
(
i
 => 
	`M­
(

82 "sifive,™im" -> 
äÚ‹nd
.
iÿche
.
deviû
.
asPrİ”ty
))).
	`g‘OrEl£
(
N
)

84 
v®
 
ıuDeviû
 = 
Ãw
 
	`Sim¶eDeviû
("ıu", 
	`Seq
("sifive,rocket0", "riscv")) {

85 
ov”ride
 
def
 
·»Á
 = 
	`Some
(
ResourûAnchÜs
.
ıus
)

86 
ov”ride
 
def
 
	`desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

87 
v®
 
	`DesütiÚ
(
Çme
, 
m­pšg
èğ
su³r
.
	`desüibe
(
»sourûs
)

88 
	`DesütiÚ
(
Çme
, 
m­pšg
 ++ 
ıuPrİ”t›s
 ++ 
ÃxtLev–CachePrİ”ty
 ++ 
tePrİ”t›s
 ++ 
dtimPrİ”ty
 ++ 
™imPrİ”ty
)

92 
ResourûBšdšg
 {

93 
	`Resourû
(
ıuDeviû
, "»g").
	`bšd
(
	`ResourûAdd»ss
(
h¬tId
))

96 
ov”ride
 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`Rock‘TeModuËImp
(
this
)

98 
ov”ride
 
def
 
	`makeMa¡”Bound¬yBufãrs
(
im¶ic™
 
p
: 
P¬am‘”s
) = {

99 ià(!
rock‘P¬ams
.
bound¬yBufãrs
è
su³r
.
makeMa¡”Bound¬yBufãrs


100 
	`TLBufãr
(
BufãrP¬ams
.
nÚe
, BufãrP¬ams.
æow
, BufãrP¬ams.nÚe, BufãrP¬ams.æow, 
	`BufãrP¬ams
(1))

103 
ov”ride
 
def
 
	`makeSÏveBound¬yBufãrs
(
im¶ic™
 
p
: 
P¬am‘”s
) = {

104 ià(!
rock‘P¬ams
.
bound¬yBufãrs
è
su³r
.
makeSÏveBound¬yBufãrs


105 
	`TLBufãr
(
BufãrP¬ams
.
æow
, BufãrP¬ams.
nÚe
, BufferParams.none, BufferParams.none, BufferParams.none)

107 
	}
}

109 şas 
	cRock‘TeModuËImp
(
ou‹r
: 
Rock‘Te
è
ex‹nds
 
	$Ba£TeModuËImp
(
ou‹r
)

110 
w™h
 
HasFpuO±


111 
w™h
 
HasLazyRoCCModuË


112 
w™h
 
HasICacheFrÚ‹ndModuË
 {

113 
AÂÙ©ed
.
	$·¿ms
(
this
, 
ou‹r
.
rock‘P¬ams
)

115 
v®
 
cÜe
 = 
	`ModuË
(
Ãw
 
	$Rock‘
()(
ou‹r
.
p
))

117 
v®
 
uncÜ»ùabË
 = 
	`RegIn™
(
	$BoŞ
(
çl£
))

118 
v®
 
h®t_ªd_ÿtch_fœe
 = 
ou‹r
.
rock‘P¬ams
.
hcfOnUncÜ»ùabË
.
	`İtiÚ
(
	`IO
(
	$BoŞ
(
OUTPUT
)))

120 
ou‹r
.
bus_”rÜ_un™
.
fÜ—ch
 { 
lm
 =>

121 
lm
.
moduË
.
io
.
”rÜs
.
dÿche
 :ğ
ou‹r
.dcache.module.io.errors

122 
lm
.
moduË
.
io
.
”rÜs
.
iÿche
 :ğ
ou‹r
.
äÚ‹nd
.module.io.errors

125 
ou‹r
.
	$decodeCÜeIÁ”ru±s
(
cÜe
.
io
.
š‹¼u±s
)

126 
ou‹r
.
bus_”rÜ_un™
.
fÜ—ch
 { 
beu
 => 
cÜe
.
io
.
š‹¼u±s
.
bu£¼Ü
.
g‘
 :ğbeu.
moduË
.io.
š‹¼u±
 
	}
}

127 
cÜe
.
io
.
h¬tid
 :ğ
cÚ¡ªts
.hartid

128 
Œaû
.
fÜ—ch
 { 
_
 :ğ
cÜe
.
io
.trace }

129 
h®t_ªd_ÿtch_fœe
.
fÜ—ch
 { 
_
 :ğ
uncÜ»ùabË
 }

130 
ou‹r
.
äÚ‹nd
.
moduË
.
io
.
ıu
 <> 
cÜe
.io.
imem


131 
ou‹r
.
äÚ‹nd
.
moduË
.
io
.
»£t_veùÜ
 :ğ
cÚ¡ªts
.reset_vector

132 
ou‹r
.
äÚ‹nd
.
moduË
.
io
.
h¬tid
 :ğ
cÚ¡ªts
.hartid

133 
ou‹r
.
dÿche
.
moduË
.
io
.
h¬tid
 :ğ
cÚ¡ªts
.hartid

134 
dÿchePÜts
 +ğ
cÜe
.
io
.
dmem


135 
åuO±
 
fÜ—ch
 { 
åu
 => 
cÜe
.
io
.fpu <> fpu.io }

141 
cÜe
.
io
.
±w
 <>…tw.io.
d·th


143 ià(
ou‹r
.
roccs
.
size
 > 0) {

144 
cmdRou‹r
.
g‘
.
io
.
š
 <> 
cÜe
.io.
rocc
.
cmd


145 
ou‹r
.
roccs
.
fÜ—ch
(
_
.
moduË
.
io
.
exû±iÚ
 :ğ
cÜe
.io.
rocc
.exception)

146 
cÜe
.
io
.
rocc
.
»¥
 <> 
»¥Arb
.
g‘
.io.
out


147 
cÜe
.
io
.
rocc
.
busy
 <> (
cmdRou‹r
.
g‘
.io.busy || 
ou‹r
.
roccs
.
m­
(
_
.
moduË
.io.busy).
»duû
(_ || _))

148 
cÜe
.
io
.
rocc
.
š‹¼u±
 :ğ
ou‹r
.
roccs
.
m­
(
_
.
moduË
.io.š‹¼u±).
»duû
(_ || _)

152 
ou‹r
.
dtim_ad­‹r
.
fÜ—ch
 { 
lm
 => 
dÿchePÜts
 +ğlm.
moduË
.
io
.
dmem
 }

154 
wh’
(!
uncÜ»ùabË
) { uncorrectable :=

155 
Li¡
(
ou‹r
.
äÚ‹nd
.
moduË
.
io
.
”rÜs
, ou‹r.
dÿche
.module.io.errors)

156 .
	gæ©M­
 { 
	ge
 => 
e
.
uncÜ»ùabË
.
m­
(
_
.
v®id
) }

157 .
»duûO±iÚ
(
_
||_)

158 .
g‘OrEl£
(
çl£
.
B
)

162 
v®
 
	gh
 = 
dÿchePÜts
.
size


163 
v®
 
c
 = 
cÜe
.
dÿcheArbPÜts


164 
v®
 
o
 = 
ou‹r
.
nDCachePÜts


165 
»quœe
(
h
 =ğ
c
, 
s
"port†ist size was $h, coreƒxpected $c")

166 
»quœe
(
h
 =ğ
o
, 
s
"port†ist size was $h, outer counted $o")

168 
	gdÿcheArb
.
	gio
.
	g»que¡Ü
 <> 
dÿchePÜts


169 
	g±w
.
	gio
.
	g»que¡Ü
 <> 
	g±wPÜts


172 
Œa™
 
	gHasFpuO±
 { 
	gthis
: 
Rock‘TeModuËImp
 =>

173 
v®
 
åuO±
 = 
ou‹r
.
teP¬ams
.
cÜe
.
åu
.
m­
(
·¿ms
 => 
ModuË
(
Ãw
 
FPU
Õ¬ams)(ou‹r.
p
)))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AddressAdjuster.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 şas 
	cAdd»ssAdju¡”
(
mask
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

13 
v®
 
b™s
 = 
Add»ssS‘
.
	$’um”©eB™s
(
mask
)

15 
v®
 
ids
 = 
Add»ssS‘
.
	$’um”©eMask
(
mask
)

17 
v®
 
node
 = 
	`TLNexusNode
(

18 
ş›ÁFn
 = { 
ı
 => 
	`ı
(0) },

19 
mªag”Fn
 = { 
mp
 =>

20 
	`»quœe
 (
mp
.
size
 == 2)

21 
v®
 
»mÙe
 = 
	`mp
(0)

22 
v®
 
loÿl
 = 
	`mp
(1)

25 
def
 
	`checkMask
(
m
: 
TLMªag”P¬am‘”s
) = {

26 
v®
 
sÜ‹d
 = 
m
.
add»ss
.sorted

27 
b™s
.
fÜ—ch
 { 
b
 =>

28 
v®
 
æ³d
 = 
m
.
add»ss
.
	`m­
(
a
 => 
	`Add»ssS‘
(×.
ba£
 ^ 
b
è& ~a.
mask
,‡.mask)).
sÜ‹d


29 
	`»quœe
 (
sÜ‹d
 =ğ
æ³d
, 
s
"AddressSets for ${m.name} (${sorted}) do‚ot„epeat with bit ${b} (${flipped})")

32 
loÿl
 .
mªag”s
.
fÜ—ch
 { 
z
 => 
	`checkMask
(z) }

33 
»mÙe
.
mªag”s
.
fÜ—ch
 { 
z
 => 
	`checkMask
(z) }

36 
v®
 
”rÜDevs
 = 
loÿl
.
mªag”s
.
	`f‹r
(
_
.
nodeP©h
.
Ï¡
.
ÏzyModuË
.
şassName
 == "TLError")

37 
	`»quœe
 (!
”rÜDevs
.
isEm±y
, 
s
"There is‚o TLError„eachable from ${name}. One must be instantiated.")

38 
v®
 
”rÜDev
 = 
”rÜDevs
.
h—d


41 
»mÙe
.
mªag”s
.
fÜ—ch
 { 
r
 =>

42 
	`»quœe
 (
”rÜDev
.
suµÜtsAcquœeT
 .
	`cÚšs
(
r
.suµÜtsAcquœeT ), 
s
"Error device cannot cover ${r.name}'s AcquireT")

43 
	`»quœe
 (
”rÜDev
.
suµÜtsAcquœeB
 .
	`cÚšs
(
r
.suµÜtsAcquœeB ), 
s
"Error device cannot cover ${r.name}'s AcquireB")

44 
	`»quœe
 (
”rÜDev
.
suµÜtsAr™hm‘ic
.
	`cÚšs
(
r
.suµÜtsAr™hm‘ic), 
s
"Error device cannot cover ${r.name}'s Arithmetic")

45 
	`»quœe
 (
”rÜDev
.
suµÜtsLogiÿl
 .
	`cÚšs
(
r
.suµÜtsLogiÿÈ), 
s
"Error device cannot cover ${r.name}'s Logical")

46 
	`»quœe
 (
”rÜDev
.
suµÜtsG‘
 .
	`cÚšs
(
r
.suµÜtsG‘ ), 
s
"Error device cannot cover ${r.name}'s Get")

47 
	`»quœe
 (
”rÜDev
.
suµÜtsPutFuÎ
 .
	`cÚšs
(
r
.suµÜtsPutFuÎ ), 
s
"Error device cannot cover ${r.name}'s PutFull")

48 
	`»quœe
 (
”rÜDev
.
suµÜtsPutP¬tŸl
.
	`cÚšs
(
r
.suµÜtsPutP¬tŸl), 
s
"Error device cannot cover ${r.name}'s PutPartial")

49 
	`»quœe
 (
”rÜDev
.
suµÜtsHšt
 .
	`cÚšs
(
r
.suµÜtsHšˆ), 
s
"Error device cannot cover ${r.name}'s Hint")

53 
»mÙe
.
	`»quœeFifo
()

54 
loÿl
.
	`»quœeFifo
()

57 
v®
 
hŞes
 = {

58 
v®
 
¿
 = 
»mÙe
.
mªag”s
.
	`æ©M­
(
_
.
add»ss
).æ©M­(_.
	`š‹r£ù
(
	`Add»ssS‘
(0, ~
mask
)))

59 
v®
 
Ï
 = 
loÿl
 .
mªag”s
.
	`æ©M­
(
_
.
add»ss
).æ©M­(_.
	`š‹r£ù
(
	`Add»ssS‘
(0, ~
mask
)))

60 
Ï
.
	`fŞdLeá
(
¿
è{ (
hŞes
,†aè=> hŞes.
	`æ©M­
(
_
.
	`subŒaù
(la)) }

64 
v®
 
ÃwLoÿl
 = 
loÿl
.
mªag”s
.
m­
 { 
l
 =>

65 
v®
 
cÚš”
 = 
»mÙe
.
mªag”s
.
fšd
 { 
r
 => 
l
.
add»ss
.
fÜ®l
 { 
Ï
 =>„.add»ss.
	`exi¡s
(
_
.
	`cÚšs
(la)) } }

66 
	`»quœe
 (!
cÚš”
.
isEm±y
, 
s
"There is‚o„emote manager which containshe‡ddresses of ${l.name} (${l.address})")

67 
v®
 
r
 = 
cÚš”
.
g‘


68 
	`»quœe
 (
l
.
»giÚTy³
 <ğ
r
.»giÚTy³, 
s
"Device ${l.name} cannot be ${l.regionType} when ${r.name} is ${r.regionType}")

69 
	`»quœe
 (!
l
.
execubË
 || 
r
.execubË, 
s
"Device ${l.name} cannot beƒxecutable if ${r.name} is‚ot")

70 
	`»quœe
 (!
l
.
mayD’yPut
 || 
r
.mayD’yPut, 
s
"Device ${l.name} cannot deny Put if ${r.name} does‚ot")

71 
	`»quœe
 (!
l
.
mayD’yG‘
 || 
r
.mayD’yG‘, 
s
"Device ${l.name} cannot deny Get if ${r.name} does‚ot")

72 
	`»quœe
 (
l
.
®waysG¿ÁsT
 || !
r
.®waysG¿ÁsT, 
s
"Device ${l.name} must‡lways GrantoT if ${r.name} does")

74 
	`»quœe
 (!
l
.
suµÜtsAcquœeT
 || 
r
.suµÜtsAcquœeT, 
s
"Device ${l.name} (${l.address})†oses AcquireT suppport because ${r.name} does‚ot support it")

75 
	`»quœe
 (!
l
.
suµÜtsAcquœeB
 || 
r
.suµÜtsAcquœeB, 
s
"Device ${l.name} (${l.address})†oses AcquireB support because ${r.name} does‚ot support it")

76 
	`»quœe
 (!
l
.
suµÜtsAr™hm‘ic
 || 
r
.suµÜtsAr™hm‘ic, 
s
"Device ${l.name} (${l.address})†oses Arithmetic support because ${r.name} does‚ot support it")

77 
	`»quœe
 (!
l
.
suµÜtsLogiÿl
 || 
r
.suµÜtsLogiÿl, 
s
"Device ${l.name} (${l.address})†oses Logical support because ${r.name} does‚ot support it")

78 
	`»quœe
 (!
l
.
suµÜtsG‘
 || 
r
.suµÜtsG‘, 
s
"Device ${l.name} (${l.address})†oses Get support because ${r.name} does‚ot support it")

79 
	`»quœe
 (!
l
.
suµÜtsPutFuÎ
 || 
r
.suµÜtsPutFuÎ, 
s
"Device ${l.name} (${l.address})†oses PutFull support because ${r.name} does‚ot support it")

80 
	`»quœe
 (!
l
.
suµÜtsPutP¬tŸl
 || 
r
.suµÜtsPutP¬tŸl, 
s
"Device ${l.name} (${l.address})†oses PutPartial support because ${r.name} does‚ot support it")

81 
	`»quœe
 (!
l
.
suµÜtsHšt
 || 
r
.suµÜtsHšt, 
s
"Device ${l.name} (${l.address})†oses Hint support because ${r.name} does‚ot support it")

82 
l
.
	`cİy
(

84 
add»ss
 = 
Add»ssS‘
.
	`unify
(
l
.add»ss.
	`æ©M­
(
_
.
	`š‹r£ù
(
	`Add»ssS‘
(0, ~
mask
))) ++

85 (ià(
l
 =ğ
”rÜDev
è
hŞes
 
N
)),

86 
»giÚTy³
 = 
r
.regionType,

87 
execubË
 = 
r
.executable,

88 
suµÜtsAcquœeT
 = 
r
.supportsAcquireT,

89 
suµÜtsAcquœeB
 = 
r
.supportsAcquireB,

90 
suµÜtsAr™hm‘ic
 = 
r
.supportsArithmetic,

91 
suµÜtsLogiÿl
 = 
r
.supportsLogical,

92 
suµÜtsG‘
 = 
r
.supportsGet,

93 
suµÜtsPutFuÎ
 = 
r
.supportsPutFull,

94 
suµÜtsPutP¬tŸl
 = 
r
.supportsPutPartial,

95 
suµÜtsHšt
 = 
r
.supportsHint,

96 
mayD’yG‘
 = 
r
.mayDenyGet,

97 
mayD’yPut
 = 
r
.mayDenyPut,

98 
®waysG¿ÁsT
 = 
r
.alwaysGrantsT,

99 
fifoId
 = 
	`Some
(0))

102 
v®
 
ÃwRemÙe
 = 
ids
.

.
zW™hIndex
.
æ©M­
 { (
id
, 
i
è=> 
»mÙe
.
mªag”s
.
m­
 { 
r
 =>

103 
r
.
	`cİy
(

104 
add»ss
 = 
Add»ssS‘
.
	`unify
(
r
.add»ss.
	`æ©M­
(
_
.
	`š‹r£ù
(
	`Add»ssS‘
(
id
, ~
mask
)))),

105 
fifoId
 = 
	`Some
(
i
+1))

108 
loÿl
.
	`cİy
(

109 
mªag”s
 = 
ÃwLoÿl
 ++ 
ÃwRemÙe
,

110 
’dSškId
 = 
loÿl
.’dSškId + 
»mÙe
.endSinkId,

111 
mšL©’cy
 = 
loÿl
.mšL©’cy 
mš
 
»mÙe
.minLatency)

112 
	}
})

114 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

115 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

116 
v®
 
loÿl_add»ss
 = 
	`UIÁ
(
b™s
.
size
.
W
)

119 
	`»quœe
 (
node
.
edges
.
š
.
size
 == 1)

120 
	`»quœe
 (
node
.
edges
.
out
.
size
 == 2)

122 
	`v®
 (
·»Á
, 
·»ÁEdge
èğ
node
.
	`š
(0)

123 
	`v®
 (
»mÙe
, 
»mÙeEdge
èğ
node
.
	`out
(0)

124 
	`v®
 (
loÿl
, 
loÿlEdge
èğ
node
.
	`out
(1)

125 
	`»quœe
 (
loÿlEdge
.
mªag”
.
b—tBy‹s
 =ğ
»mÙeEdge
.manager.beatBytes)

128 
v®
 
loÿl_add»ss
 = (
b™s
 
z
 
io
.loÿl_add»ss.
toBoŞs
).
	`fŞdLeá
(0.U) {

129 (
acc
, (
b™
, 
£l
)è=>‡cø| 
	`Mux
(£l, 0.U, b™.
U
)

133 
v®
 
a_loÿl
 = 
loÿl_add»ss
 ==ğ(
·»Á
.
a
.
b™s
.
add»ss
 & 
mask
.
U
)

134 
·»Á
.
a
.
»ady
 :ğ
	`Mux
(
a_loÿl
, 
loÿl
.a.»ady, 
»mÙe
.a.ready)

135 
loÿl
 .
a
.
v®id
 :ğ
·»Á
.a.v®id && 
a_loÿl


136 
»mÙe
.
a
.
v®id
 :ğ
·»Á
.a.v®id && !
a_loÿl


137 
loÿl
 .
a
.
b™s
 :ğ
·»Á
.a.bits

138 
»mÙe
.
a
.
b™s
 :ğ
·»Á
.a.bits

140 
v®
 
a_roubË
 = 
Add»ssS‘
.
	`unify
(
loÿlEdge
.
mªag”
.
mªag”s
.
	`æ©M­
(
_
.
add»ss
))

141 
v®
 
a_cÚšed
 = 
a_roubË
.
	`m­
(
_
.
	`cÚšs
(
·»Á
.
a
.
b™s
.
add»ss
)).
	`»duû
(_ || _)

143 
v®
 
acquœeOk
 =

144 
	`Mux
(
·»Á
.
a
.
b™s
.
·¿m
 ==ğ
TLP”missiÚs
.
toT
,

145 
loÿlEdge
.
mªag”
.
	`suµÜtsAcquœeTFa¡
(
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
),

146 
loÿlEdge
.
mªag”
.
	`suµÜtsAcquœeBFa¡
(
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
))

148 
v®
 
a_suµÜt
 = 
	`VecIn™
(

149 
loÿlEdge
.
mªag”
.
	`suµÜtsPutFuÎFa¡
 (
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
),

150 
loÿlEdge
.
mªag”
.
	`suµÜtsPutP¬tŸlFa¡
(
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
),

151 
loÿlEdge
.
mªag”
.
	`suµÜtsAr™hm‘icFa¡
(
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
),

152 
loÿlEdge
.
mªag”
.
	`suµÜtsLogiÿlFa¡
 (
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
),

153 
loÿlEdge
.
mªag”
.
	`suµÜtsG‘Fa¡
 (
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
),

154 
loÿlEdge
.
mªag”
.
	`suµÜtsHštFa¡
 (
·»Á
.
a
.
b™s
.
add»ss
,…¬’t.a.b™s.
size
),

155 
acquœeOk
,‡cquœeOk)(
·»Á
.
a
.
b™s
.
İcode
)

157 
v®
 
”rÜS‘
 = 
loÿlEdge
.
mªag”
.
mªag”s
.
	`f‹r
(
_
.
nodeP©h
.
Ï¡
.
ÏzyModuË
.
şassName
 =ğ"TLE¼Ü").
h—d
.
add»ss
.head

158 
v®
 
a_”rÜ
 = !
a_cÚšed
 || !
a_suµÜt


159 
loÿl
.
a
.
b™s
.
add»ss
 :ğ
	`C©
(

160 
	`Mux
(!
a_”rÜ
, 
·»Á
.
a
.
b™s
.
add»ss
, 
”rÜS‘
.
ba£
.
U
è>> 
	`log2Ce
Ó¼ÜS‘.
®ignm’t
),

161 
·»Á
.
a
.
b™s
.
	`add»ss
(
	`log2Ce
(
”rÜS‘
.
®ignm’t
)-1, 0))

164 
v®
 
sšk_th»shŞd
 = 
loÿlEdge
.
mªag”
.
’dSškId
.
U


165 
v®
 
loÿl_d
 = 
	`WœeIn™
(
	`chi£lTy³Of
(
·»Á
.
d
), 
loÿl
.d)

166 
v®
 
»mÙe_d
 = 
	`WœeIn™
(
	`chi£lTy³Of
(
·»Á
.
d
), 
»mÙe
.d)

167 
»mÙe_d
.
b™s
.
sšk
 :ğ
»mÙe
.
d
.b™s.sšk + 
sšk_th»shŞd


168 
TLArb™”
.
	`robš
(
·»ÁEdge
, 
·»Á
.
d
, 
loÿl_d
, 
»mÙe_d
)

170 ià(
·»ÁEdge
.
mªag”
.
ªySuµÜtAcquœeB
 &&…¬’tEdge.
ş›Á
.
ªySuµÜtProbe
) {

172 
	`as£¹
 (!
loÿl
 .
b
.
v®id
 || (ÖoÿÈ.b.
b™s
.
add»ss
 & 
mask
.
U
è==ğ
loÿl_add»ss
))

173 
	`as£¹
 (!
»mÙe
.
b
.
v®id
 || (ÔemÙe.b.
b™s
.
add»ss
 & 
mask
.
U
è=/ğ
loÿl_add»ss
))

174 
TLArb™”
.
	`robš
(
·»ÁEdge
, 
·»Á
.
b
, 
loÿl
.b, 
»mÙe
.b)

177 
v®
 
c_loÿl
 = 
loÿl_add»ss
 ==ğ(
·»Á
.
c
.
b™s
.
add»ss
 & 
mask
.
U
)

178 
·»Á
.
c
.
»ady
 :ğ
	`Mux
(
c_loÿl
, 
loÿl
.c.»ady, 
»mÙe
.c.ready)

179 
loÿl
 .
c
.
v®id
 :ğ
·»Á
.c.v®id && 
c_loÿl


180 
»mÙe
.
c
.
v®id
 :ğ
·»Á
.c.v®id && !
c_loÿl


181 
loÿl
 .
c
.
b™s
 :ğ
·»Á
.c.bits

182 
»mÙe
.
c
.
b™s
 :ğ
·»Á
.c.bits

185 
v®
 
e_loÿl
 = 
·»Á
.
e
.
b™s
.
sšk
 < 
sšk_th»shŞd


186 
·»Á
.
e
.
»ady
 :ğ
	`Mux
(
e_loÿl
, 
loÿl
.e.»ady, 
»mÙe
.e.ready)

187 
loÿl
 .
e
.
v®id
 :ğ
·»Á
.e.v®id && 
e_loÿl


188 
»mÙe
.
e
.
v®id
 :ğ
·»Á
.e.v®id && !
e_loÿl


189 
loÿl
 .
e
.
b™s
 :ğ
·»Á
.e.bits

190 
»mÙe
.
e
.
b™s
 :ğ
·»Á
.e.bits

192 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Arbiter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
objeù
 
	gTLArb™”


13 
ty³
 
	gPŞicy
 = (
IÁeg”
, 
	gUIÁ
, 
	gBoŞ
è=> 
UIÁ


15 
v®
 
lowe¡IndexFœ¡
: 
PŞicy
 = (
width
, 
	gv®ids
, 
	g£Ëù
è=> ~(
ËáOR
(
v®ids
) << 1)(width-1, 0)

17 
v®
 
	groundRobš
: 
PŞicy
 = (
width
, 
	gv®ids
, 
	g£Ëù
è=> ià(width =ğ1è
UIÁ
(1, width=1) {

18 
v®
 
v®id
 = 
v®ids
(
width
-1, 0)

19 
as£¹
 (
v®id
 ==ğ
v®ids
)

20 
v®
 
mask
 = 
RegIn™
(~
UIÁ
(0, 
width
=width))

21 
v®
 
f‹r
 = 
C©
(
v®id
 & ~
mask
, valid)

22 
v®
 
	guÄ—dy
 = (
rightOR
(
f‹r
, 
width
*2, widthè>> 1è| (
	gmask
 << 
	gwidth
)

23 
v®
 
	g»adys
 = ~((
uÄ—dy
 >> 
width
) & unready(width-1, 0))

24 
wh’
 (
£Ëù
 && 
v®id
.
ÜR
) {

25 
	gmask
 :ğ
ËáOR
(
»adys
 & 
v®id
, 
width
)

27 
»adys
(
width
-1, 0)

30 
def
 
	glowe¡FromSeq
[
T
 <: 
TLChªÃl
](
edge
: 
TLEdge
, 
	gsšk
: 
Decou¶edIO
[T], 
	gsourûs
: 
Seq
[DecoupledIO[T]]) {

31 
­¶y
(
lowe¡IndexFœ¡
)(
sšk
, 
	gsourûs
.
m­
(
s
 => (
edge
.
numB—ts1
(s.
b™s
), s)):
_
*)

34 
def
 
lowe¡
[
T
 <: 
TLChªÃl
](
edge
: 
TLEdge
, 
	gsšk
: 
Decou¶edIO
[T], 
	gsourûs
: DecoupledIO[T]*) {

35 
­¶y
(
lowe¡IndexFœ¡
)(
sšk
, 
	gsourûs
.
	gtoLi¡
.
m­
(
s
 => (
edge
.
numB—ts1
(s.
b™s
), s)):
_
*)

38 
def
 
robš
[
T
 <: 
TLChªÃl
](
edge
: 
TLEdge
, 
	gsšk
: 
Decou¶edIO
[T], 
	gsourûs
: DecoupledIO[T]*) {

39 
­¶y
(
roundRobš
)(
sšk
, 
	gsourûs
.
	gtoLi¡
.
m­
(
s
 => (
edge
.
numB—ts1
(s.
b™s
), s)):
_
*)

42 
def
 
­¶y
[
T
 <: 
D©a
](
pŞicy
: 
PŞicy
)(
sšk
: 
Decou¶edIO
[T], 
	gsourûs
: (
UIÁ
, 
	gDecou¶edIO
[T])*) {

43 ià(
	gsourûs
.
	gisEm±y
) {

44 
	gsšk
.
	gv®id
 :ğ
BoŞ
(
çl£
)

45 } ià(
sourûs
.
size
 == 1) {

46 
sšk
 <> 
sourûs
.
h—d
.
_2


48 
v®
 
·œs
 = 
sourûs
.
toLi¡


49 
v®
 
b—tsIn
 = 
·œs
.
m­
(
_
.
_1
)

50 
v®
 
sourûsIn
 = 
·œs
.
m­
(
_
.
_2
)

53 
v®
 
b—tsLeá
 = 
RegIn™
(
UIÁ
(0))

54 
v®
 
idË
 = 
b—tsLeá
 ==ğ
UIÁ
(0)

55 
v®
 
Ïtch
 = 
idË
 && 
sšk
.
»ady


58 
v®
 
v®ids
 = 
sourûsIn
.
m­
(
_
.
v®id
)

60 
v®
 
»adys
 = 
Vec
(
pŞicy
(
v®ids
.
size
, 
C©
(v®ids.
»v”£
), 
Ïtch
).
toBoŞs
)

62 
v®
 
	gwšÃr
 = 
Vec
((
»adys
 
z
 
v®ids
è
m­
 { (
r
,
v
) =>„&&v })

65 
»quœe
 (
»adys
.
size
 =ğ
v®ids
.size)

67 
v®
 
´efixOR
 = 
wšÃr
.
sÿnLeá
(
BoŞ
(
çl£
))(
_
||_).
š™


68 
as£¹
((
´efixOR
 
z
 
wšÃr
è
m­
 { (
p
,
w
è=> !°|| !w } 
»duû
 {
_
 && _})

70 
as£¹
 (!
v®ids
.
»duû
(
_
||_è|| 
wšÃr
.reduce(_||_))

73 
v®
 
	gmaskedB—ts
 = (
wšÃr
 
z
 
b—tsIn
è
m­
 { (
w
,
b
è=> 
Mux
(w, b, 
UIÁ
(0)) }

74 
v®
 
	gš™B—ts
 = 
maskedB—ts
.
»duû
(
_
 | _)

75 
b—tsLeá
 :ğ
Mux
(
Ïtch
, 
š™B—ts
, b—tsLeá - 
sšk
.
fœe
())

78 
v®
 
	g¡©e
 = 
RegIn™
(
Vec
.
fl
(
sourûs
.
size
)(
BoŞ
(
çl£
)))

79 
v®
 
muxS‹
 = 
Mux
(
idË
, 
wšÃr
, 
¡©e
)

80 
	g¡©e
 :ğ
muxS‹


82 
v®
 
®lowed
 = 
Mux
(
idË
, 
»adys
, 
¡©e
)

83 (
sourûsIn
 
z
 
	g®lowed
è
	gfÜ—ch
 { (
	gs
, 
	gr
) =>

84 
s
.
»ady
 :ğ
sšk
.»ady && 
r


86 
sšk
.
v®id
 :ğ
Mux
(
idË
, 
v®ids
.
»duû
(
_
||_), 
Mux1H
(
¡©e
, valids))

87 
	gsšk
.
	gb™s
 :ğ
Mux1H
(
muxS‹
, 
sourûsIn
.
m­
(
_
.
b™s
))

93 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


95 
şass
 
	$Te¡Robš
(
txns
: 
IÁ
 = 128, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

96 
v®
 
sourûs
 = 
	`Wœe
(
	`Vec
(6, 
	`Decou¶edIO
(
	`UIÁ
(
width
=3))))

97 
v®
 
sšk
 = 
	`Wœe
(
	`Decou¶edIO
(
	`UIÁ
(
width
=3)))

98 
v®
 
couÁ
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
=8))

100 
v®
 
lf¤
 = 
	`LFSR16
(
	`BoŞ
(
Œue
))

101 
v®
 
v®id
 = 
	`lf¤
(0)

102 
v®
 
»ady
 = 
	`lf¤
(15)

104 
sourûs
.
zW™hIndex
.
m­
 { (
z
, 
i
è=> z.
b™s
 :ğ
	`UIÁ
(i) }

105 
	`sourûs
(0).
v®id
 := valid

106 
	`sourûs
(1).
v®id
 :ğ
	`BoŞ
(
çl£
)

107 
	`sourûs
(2).
v®id
 := valid

108 
	`sourûs
(3).
v®id
 := valid

109 
	`sourûs
(4).
v®id
 :ğ
	`BoŞ
(
çl£
)

110 
	`sourûs
(5).
v®id
 := valid

111 
sšk
.
»ady
 :=„eady

113 
	`TLArb™”
(
TLArb™”
.
roundRobš
)(
sšk
, 
sourûs
.
zW™hIndex
.
m­
 { (
z
, 
i
è=> (
	`UIÁ
(i), zè}:
_
*)

114 
	`wh’
 (
sšk
.
	`fœe
()è{ 
	`´štf
("Te¡Robš: %d\n", sšk.
b™s
) }

115 
	`wh’
 (!
sšk
.
	`fœe
()è{ 
	`´štf
("Te¡Robš: idË (%d %d)\n", 
v®id
, 
»ady
) }

117 
couÁ
 :ğcouÁ + 
	`UIÁ
(1)

118 
io
.
fšished
 :ğ
couÁ
 >ğ
	`UIÁ
(
txns
)

119 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AsyncCrossing.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.
CrossšgW¿µ”


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


12 
şass
 
	$TLAsyncCrossšgSourû
(
sync
: 
O±iÚ
[
IÁ
])(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
def
 
	`this
(
x
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
èğthis(
	`Some
(x))

15 
def
 
	`this
()(
im¶ic™
 
p
: 
P¬am‘”s
èğthis(
NÚe
)

17 
v®
 
node
 = 
	`TLAsyncSourûNode
(
sync
)

19 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

20 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

21 
v®
 
bû
 = 
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeIn.
ş›Á
.
ªySuµÜtProbe


22 
v®
 
psync
 = 
sync
.
	`g‘OrEl£
(
edgeOut
.
mªag”
.
async
.sync)

23 
v®
 
·¿ms
 = 
edgeOut
.
mªag”
.
async
.
	`cİy
(
sync
 = 
psync
)

25 
out
.
a
 <> 
	`ToAsyncBundË
(
š
.a, 
·¿ms
)

26 
š
.
d
 <> 
	`FromAsyncBundË
(
out
.d, 
psync
)

27 
	`cov”
(
š
.
a
, "TL_ASYNC_CROSSING_SOURCE_A", "MemorySystem;;TLAsyncCrossingSource Channel A")

28 
	`cov”
(
š
.
d
, "TL_ASYNC_CROSSING_SOURCE_D", "MemorySystem;;TLAsyncCrossingSource Channel D")

30 ià(
bû
) {

31 
š
.
b
 <> 
	`FromAsyncBundË
(
out
.b, 
psync
)

32 
out
.
c
 <> 
	`ToAsyncBundË
(
š
.c, 
·¿ms
)

33 
out
.
e
 <> 
	`ToAsyncBundË
(
š
.e, 
·¿ms
)

34 
	`cov”
(
š
.
b
, "TL_ASYNC_CROSSING_SOURCE_B", "MemorySystem;;TLAsyncCrossingSource Channel B")

35 
	`cov”
(
š
.
c
, "TL_ASYNC_CROSSING_SOURCE_C", "MemorySystem;;TLAsyncCrossingSource Channel C")

36 
	`cov”
(
š
.
e
, "TL_ASYNC_CROSSING_SOURCE_E", "MemorySystem;;TLAsyncCrossingSource Channel E")

38 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

39 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

40 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

41 
out
.
b
.
ridx
 :ğ
	`UIÁ
(0)

42 
out
.
c
.
widx
 :ğ
	`UIÁ
(0)

43 
out
.
e
.
widx
 :ğ
	`UIÁ
(0)

47 
	}
}

49 
şass
 
TLAsyncCrossšgSšk
(
·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
())(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


51 
v®
 
node
 = 
	`TLAsyncSškNode
(
·¿ms
)

53 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

54 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

55 
v®
 
bû
 = 
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeOut.
ş›Á
.
ªySuµÜtProbe


57 
out
.
a
 <> 
	`FromAsyncBundË
(
š
.a, 
·¿ms
.
sync
)

58 
š
.
d
 <> 
	`ToAsyncBundË
(
out
.d, 
·¿ms
)

59 
	`cov”
(
out
.
a
, "TL_ASYNC_CROSSING_SINK_A", "MemorySystem;;TLAsyncCrossingSink Channel A")

60 
	`cov”
(
out
.
d
, "TL_ASYNC_CROSSING_SINK_D", "MemorySystem;;TLAsyncCrossingSink Channel D")

62 ià(
bû
) {

63 
š
.
b
 <> 
	`ToAsyncBundË
(
out
.b, 
·¿ms
)

64 
out
.
c
 <> 
	`FromAsyncBundË
(
š
.c, 
·¿ms
.
sync
)

65 
out
.
e
 <> 
	`FromAsyncBundË
(
š
.e, 
·¿ms
.
sync
)

66 
	`cov”
(
out
.
b
, "TL_ASYNC_CROSSING_SINK_B", "MemorySystem;;TLAsyncCrossingSinkChannel B")

67 
	`cov”
(
out
.
c
, "TL_ASYNC_CROSSING_SINK_C", "MemorySystem;;TLAsyncCrossingSink Channel C")

68 
	`cov”
(
out
.
e
, "TL_ASYNC_CROSSING_SINK_E", "MemorySystem;;TLAsyncCrossingSink Channel E")

70 
š
.
b
.
widx
 :ğ
	`UIÁ
(0)

71 
š
.
c
.
ridx
 :ğ
	`UIÁ
(0)

72 
š
.
e
.
ridx
 :ğ
	`UIÁ
(0)

73 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

74 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

75 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

79 
	}
}

81 
objeù
 
TLAsyncCrossšgSourû


83 
def
 
­¶y
()(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLAsyncSourûNode
 =‡µly(
NÚe
)

84 
def
 
­¶y
(
sync
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLAsyncSourûNode
 =‡µly(
Some
(sync))

85 
def
 
­¶y
(
sync
: 
O±iÚ
[
IÁ
])(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLAsyncSourûNode
 =

87 
v®
 
asourû
 = 
LazyModuË
(
Ãw
 
TLAsyncCrossšgSourû
(
sync
))

88 
asourû
.
node


92 
objeù
 
TLAsyncCrossšgSšk


94 
def
 
­¶y
(
·¿ms
: 
AsyncQueueP¬ams
 = AsyncQueueP¬ams())(
im¶ic™
 
p
: 
P¬am‘”s
) =

96 
v®
 
asšk
 = 
LazyModuË
(
Ãw
 
TLAsyncCrossšgSšk
(
·¿ms
))

97 
asšk
.
node


101 @
d•»ÿ‹d
("TLAsyncCrossing is fragile. Use TLAsyncCrossingSource‡nd TLAsyncCrossingSink", "rocket-chip 1.2")

102 
şass
 
TLAsyncCrossšg
(
·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
())(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


104 
v®
 
sourû
 = 
	`LazyModuË
(
Ãw
 
	`TLAsyncCrossšgSourû
())

105 
v®
 
sšk
 = 
	`LazyModuË
(
Ãw
 
	`TLAsyncCrossšgSšk
(
·¿ms
))

106 
v®
 
node
 = 
	`NodeHªdË
(
sourû
.node, 
sšk
.node)

108 
sšk
.
node
 :ğ
sourû
.node

110 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

111 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

112 
v®
 
š_şock
 = 
	`Clock
(
INPUT
)

113 
v®
 
š_»£t
 = 
	`BoŞ
(
INPUT
)

114 
v®
 
out_şock
 = 
	`Clock
(
INPUT
)

115 
v®
 
out_»£t
 = 
	`BoŞ
(
INPUT
)

118 
sourû
.
moduË
.
şock
 :ğ
io
.
š_şock


119 
sourû
.
moduË
.
»£t
 :ğ
io
.
š_»£t


120 
sšk
.
moduË
.
şock
 :ğ
io
.
out_şock


121 
sšk
.
moduË
.
»£t
 :ğ
io
.
out_»£t


123 
	}
}

126 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


128 
şass
 
TLRAMAsyncCrossšg
(
txns
: 
IÁ
, 
·¿ms
: 
AsynchrÚousCrossšg
 = 
	$AsynchrÚousCrossšg
())(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

129 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AsyncCrossing"))

130 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

131 
v®
 
i¦ªd
 = 
	`LazyModuË
(
Ãw
 
	`CrossšgW¿µ”
(
·¿ms
))

132 
v®
 
¿m
 = 
i¦ªd
 { 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0x0, 0x3ff))) }

134 
i¦ªd
.
	`üossTLIn
(
¿m
.
node
è:ğ
	`TLF¿gm’‹r
(4, 256è:ğ
	`TLD–ay”
(0.1è:ğ
mod–
.nod:ğ
fuzz
.node

136 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

137 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

140 
v®
 
şocks
 = 
	`ModuË
(
Ãw
 
	`Pow2ClockDivid”
(2))

141 
i¦ªd
.
moduË
.
şock
 :ğ
şocks
.
io
.
şock_out


143 
	}
}

145 
şass
 
	$TLRAMAsyncCrossšgTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

146 
v®
 
dut_wide
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMAsyncCrossšg
(
txns
)).
moduË
)

147 
v®
 
dut_Ç¼ow
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMAsyncCrossšg
(
txns
, 
	`AsynchrÚousCrossšg
(
§ã
 = 
çl£
, 
Ç¼ow
 = 
Œue
))).
moduË
)

148 
io
.
fšished
 :ğ
dut_wide
.io.fšished && 
dut_Ç¼ow
.io.finished

149 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AtomicAutomata.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

13 
şass
 
	$TLAtomicAutom©a
(
logiÿl
: 
BoŞ—n
 = 
Œue
, 
¬™hm‘ic
: BoŞ—ÀğŒue, 
cÚcu¼’cy
: 
IÁ
 = 1, 
·s¡hrough
: BoŞ—ÀğŒue)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


15 
	`»quœe
 (
cÚcu¼’cy
 >= 1)

17 
v®
 
node
 = 
	`TLAd­‹rNode
(

18 
mªag”Fn
 = { 
mp
 => mp.
	`cİy
(
mªag”s
 = mp.mªag”s.
m­
 { 
m
 =>

19 
v®
 
ourSuµÜt
 = 
	`T¿nsãrSizes
(1, 
mp
.
b—tBy‹s
)

20 
def
 
	`wid’
(
x
: 
T¿nsãrSizes
èğià(
·s¡hrough
 && x.
mš
 <ğ2*
mp
.
b—tBy‹s
è
	`T¿nsãrSizes
(1, 
	`max
(mp.b—tBy‹s, x.
max
)è
ourSuµÜt


21 
v®
 
ÿnDo™
 = 
m
.
suµÜtsPutFuÎ
.
	`cÚšs
(
ourSuµÜt
è&& m.
suµÜtsG‘
.contains(ourSupport)

23 
	`»quœe
 (!
m
.
suµÜtsPutFuÎ
 || !m.
suµÜtsG‘
 || 
ÿnDo™
, 
s
"${m.name} has $ourSupport,‚eeded PutFull(${m.supportsPutFull}) or Get(${m.supportsGet})")

24 
m
.
	`cİy
(

25 
suµÜtsAr™hm‘ic
 = ià(!
¬™hm‘ic
 || !
ÿnDo™
è
m
.suµÜtsAr™hm‘iø
	`wid’
(m.supportsArithmetic),

26 
suµÜtsLogiÿl
 = ià(!
logiÿl
 || !
ÿnDo™
è
m
.suµÜtsLogiÿÈ
	`wid’
(m.supportsLogical),

27 
mayD’yG‘
 = 
m
.mayD’yG‘ || m.
mayD’yPut
)

30 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

31 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

32 
v®
 
mªag”s
 = 
edgeOut
.
mªag”
.managers

33 
v®
 
b—tBy‹s
 = 
edgeOut
.
mªag”
.beatBytes

36 
edgeOut
.
mªag”
.
	`fšdT»eViŞ©iÚ
(è
m©ch
 {

37 
NÚe
 => ()

38 
	`Some
(
node
è=> 
	`»quœe
(
edgeOut
.
mªag”
.
isT»e
, 
s
"AtomicAutomata can only be…laced infront of‡ree of diplomatic‚odes (${node.name} has…arents ${node.inputs.map(_._1.name)})")

43 
v®
 
ourSuµÜt
 = 
	`T¿nsãrSizes
(1, 
edgeOut
.
mªag”
.
b—tBy‹s
)

44 
v®
 
mªag”sN“dšgH–p
 = 
mªag”s
.
f‹r
 { 
m
 =>

45 
m
.
suµÜtsPutFuÎ
.
	`cÚšs
(
ourSuµÜt
) &&

46 
m
.
suµÜtsG‘
.
	`cÚšs
(
ourSuµÜt
) &&

47 ((
logiÿl
 && !
m
.
suµÜtsLogiÿl
 .
	`cÚšs
(
ourSuµÜt
)) ||

48 (
¬™hm‘ic
 && !
m
.
suµÜtsAr™hm‘ic
.
	`cÚšs
(
ourSuµÜt
)) ||

49 !
·s¡hrough
)

52 
mªag”sN“dšgH–p
 
fÜ—ch
 { 
m
 => 
	`»quœe
 (m.
fifoId
.
isDefšed
) }

57 
v®
 
domašsN“dšgH–p
 = 
mªag”sN“dšgH–p
.
	`m­
(
_
.
fifoId
.
g‘
).
di¡šù


59 
v®
 
ÿmSize
 = 
	`mš
(
domašsN“dšgH–p
.
size
, 
cÚcu¼’cy
)

61 
def
 
	`ÿmFifoId
(
m
: 
TLMªag”P¬am‘”s
èğm.
fifoId
.
	`m­
(
id
 => 
	`max
(0, 
domašsN“dšgH–p
.
	`šdexOf
(id))).
	`g‘OrEl£
(0)

64 
v®
 
FREE
 = 
	`UIÁ
(0)

65 
v®
 
GET
 = 
	`UIÁ
(3)

66 
v®
 
AMO
 = 
	`UIÁ
(2)

67 
v®
 
ACK
 = 
	`UIÁ
(1)

69 
v®
 
·¿ms
 = 
TLAtomicAutom©a
.
	`CAMP¬ams
(
out
.
a
.
b™s
.·¿ms, 
domašsN“dšgH–p
.
size
)

71 ià(
ÿmSize
 > 0) {

72 
v®
 
š™v®
 = 
	`Wœe
(
Ãw
 
TLAtomicAutom©a
.
	`CAM_S
(
·¿ms
))

73 
š™v®
.
¡©e
 :ğ
FREE


74 
v®
 
ÿm_s
 = 
	`RegIn™
(
Vec
.
	`fl
(
ÿmSize
)(
š™v®
))

75 
v®
 
ÿm_a
 = 
	`Reg
(
	`Vec
(
ÿmSize
, 
Ãw
 
TLAtomicAutom©a
.
	`CAM_A
(
·¿ms
)))

76 
v®
 
ÿm_d
 = 
	`Reg
(
	`Vec
(
ÿmSize
, 
Ãw
 
TLAtomicAutom©a
.
	`CAM_D
(
·¿ms
)))

78 
v®
 
ÿm_ä“
 = 
ÿm_s
.
	`m­
(
_
.
¡©e
 ==ğ
FREE
)

79 
v®
 
ÿm_amo
 = 
ÿm_s
.
	`m­
(
_
.
¡©e
 ==ğ
AMO
)

80 
v®
 
ÿm_abusy
 = 
ÿm_s
.
	`m­
(
e
 =>ƒ.
¡©e
 ==ğ
GET
 ||ƒ.¡©==ğ
AMO
)

81 
v®
 
ÿm_dm©ch
 = 
ÿm_s
.
	`m­
(
e
 =>ƒ.
¡©e
 =/ğ
FREE
)

84 
v®
 
a_add»ss
 = 
edgeIn
.
	`add»ss
(
š
.
a
.
b™s
)

85 
v®
 
a_size
 = 
edgeIn
.
	`size
(
š
.
a
.
b™s
)

86 
v®
 
a_ÿnLogiÿl
 = 
	`BoŞ
(
·s¡hrough
è&& 
edgeOut
.
mªag”
.
	`suµÜtsLogiÿlFa¡
 (
a_add»ss
, 
a_size
)

87 
v®
 
a_ÿnAr™hm‘ic
 = 
	`BoŞ
(
·s¡hrough
è&& 
edgeOut
.
mªag”
.
	`suµÜtsAr™hm‘icFa¡
(
a_add»ss
, 
a_size
)

88 
v®
 
a_isLogiÿl
 = 
š
.
a
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
LogiÿlD©a


89 
v®
 
a_isAr™hm‘ic
 = 
š
.
a
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a


90 
v®
 
a_isSuµÜ‹d
 = 
	`Mux
(
a_isLogiÿl
, 
a_ÿnLogiÿl
, Mux(
a_isAr™hm‘ic
, 
a_ÿnAr™hm‘ic
, 
	`BoŞ
(
Œue
)))

93 
v®
 
a_ÿm_ªy_put
 = 
ÿm_amo
.
	`»duû
(
_
 || _)

94 
v®
 
a_ÿm_pÜ_put
 = 
ÿm_amo
.
	`sÿnLeá
(
	`BoŞ
(
çl£
))(
_
||_).
š™


95 
v®
 
a_ÿm_£l_put
 = (
ÿm_amo
 
z
 
a_ÿm_pÜ_put
è
m­
 { (
a
, 
b
) =>‡ && !b }

96 
v®
 
a_ÿm_a
 = 
	`PriÜ™yMux
(
ÿm_amo
, 
ÿm_a
)

97 
v®
 
a_ÿm_d
 = 
	`PriÜ™yMux
(
ÿm_amo
, 
ÿm_d
)

98 
v®
 
a_a
 = 
a_ÿm_a
.
b™s
.
d©a


99 
v®
 
a_d
 = 
a_ÿm_d
.
d©a


102 
v®
 
a_fifoId
 = 
edgeOut
.
mªag”
.
	`ç¡Prİ”ty
(
a_add»ss
, 
ÿmFifoId
 
_
, (
i
:
IÁ
è=> 
	`UIÁ
(i))

103 
v®
 
a_ÿm_busy
 = (
ÿm_abusy
 
z
 
ÿm_a
.
	`m­
(
_
.
fifoId
 ==ğ
a_fifoId
)è
m­
 { (
a
,
b
è=>‡&&b } 
	`»duû
 (_||_)

106 
v®
 
a_ÿm_ªy_ä“
 = 
ÿm_ä“
.
	`»duû
(
_
 || _)

107 
v®
 
a_ÿm_pÜ_ä“
 = 
ÿm_ä“
.
	`sÿnLeá
(
	`BoŞ
(
çl£
))(
_
||_).
š™


108 
v®
 
a_ÿm_£l_ä“
 = (
ÿm_ä“
 
z
 
a_ÿm_pÜ_ä“
è
m­
 { (
a
,
b
) =>‡ && !b }

111 
v®
 
šdexes
 = 
Seq
.
	`buÏ‹
(
b—tBy‹s
*8è{ 
i
 => 
	`C©
(
	`a_a
(i,i), 
	`a_d
(i,i)) }

112 
v®
 
logic_out
 = 
	`C©
(
šdexes
.
	`m­
(
x
 => 
a_ÿm_a
.
	`lut
(x).
asUIÁ
).
»v”£
)

115 
v®
 ğ
a_ÿm_a
.
b™s
.
	`·¿m
(1)

116 
v®
 
ke_max
 = 
a_ÿm_a
.
b™s
.
	`·¿m
(0)

117 
v®
 
add”
 = 
a_ÿm_a
.
b™s
.
	`·¿m
(2)

118 
v®
 
mask
 = 
a_ÿm_a
.
b™s
.mask

119 
v®
 
signS–
 = ~(~
mask
 | (mask >> 1))

120 
v®
 
signb™s_a
 = 
	`C©
(
Seq
.
	`buÏ‹
(
b—tBy‹s
è{ 
i
 => 
	`a_a
(8*i+7,8*i+7è} .
»v”£
)

121 
v®
 
signb™s_d
 = 
	`C©
(
Seq
.
	`buÏ‹
(
b—tBy‹s
è{ 
i
 => 
	`a_d
(8*i+7,8*i+7è} .
»v”£
)

123 
v®
 
signb™_a
 = ((
signb™s_a
 & 
signS–
è<< 1)(
b—tBy‹s
-1, 0)

124 
v®
 
signb™_d
 = ((
signb™s_d
 & 
signS–
è<< 1)(
b—tBy‹s
-1, 0)

125 
v®
 
sigÃxt_a
 = 
	`FlIÁ”Ëaved
(8, 
	`ËáOR
(
signb™_a
))

126 
v®
 
sigÃxt_d
 = 
	`FlIÁ”Ëaved
(8, 
	`ËáOR
(
signb™_d
))

128 
v®
 
wide_mask
 = 
	`FlIÁ”Ëaved
(8, 
mask
)

129 
v®
 
a_a_ext
 = (
a_a
 & 
wide_mask
è| 
sigÃxt_a


130 
v®
 
a_d_ext
 = (
a_d
 & 
wide_mask
è| 
sigÃxt_d


131 
v®
 
a_d_šv
 = 
	`Mux
(
add”
, 
a_d_ext
, ~a_d_ext)

132 
v®
 
add”_out
 = 
a_a_ext
 + 
a_d_šv


133 
v®
 
h
 = 8*
b—tBy‹s
-1

134 
v®
 
a_bigg”_uÃq
 = ==ğ
	`a_a_ext
(
h
)

135 
v®
 
a_bigg”
 = 
	`Mux
(
	`a_a_ext
(
h
è==ğ
	`a_d_ext
(h), !
	`add”_out
(h), 
a_bigg”_uÃq
)

136 
v®
 
pick_a
 = 
ke_max
 ==ğ
a_bigg”


137 
v®
 
¬™h_out
 = 
	`Mux
(
add”
, 
add”_out
, Mux(
pick_a
, 
a_a
, 
a_d
))

140 
v®
 
amo_d©a
 =

141 ià(!
logiÿl
è
¬™h_out
 

142 ià(!
¬™hm‘ic
è
logic_out
 

143 
	`Mux
(
a_ÿm_a
.
b™s
.
	`İcode
(0), 
logic_out
, 
¬™h_out
)

146 
v®
 
sourû_i
 = 
	`Wœe
(
š
.
a
)

147 
v®
 
a_®low
 = !
a_ÿm_busy
 && (
a_isSuµÜ‹d
 || 
a_ÿm_ªy_ä“
)

148 
š
.
a
.
»ady
 :ğ
sourû_i
.»ady && 
a_®low


149 
sourû_i
.
v®id
 :ğ
š
.
a
.v®id && 
a_®low


150 
sourû_i
.
b™s
 :ğ
š
.
a
.bits

151 
	`wh’
 (!
a_isSuµÜ‹d
) {

152 
sourû_i
.
b™s
.
İcode
 :ğ
TLMes§ges
.
G‘


153 
sourû_i
.
b™s
.
·¿m
 :ğ
	`UIÁ
(0)

157 
v®
 
sourû_c
 = 
	`Wœe
(
š
.
a
)

158 
sourû_c
.
v®id
 :ğ
a_ÿm_ªy_put


159 
sourû_c
.
b™s
 :ğ
edgeOut
.
	`Put
(

160 
äomSourû
 = 
a_ÿm_a
.
b™s
.
sourû
,

161 
toAdd»ss
 = 
edgeIn
.
	`add»ss
(
a_ÿm_a
.
b™s
),

162 
lgSize
 = 
a_ÿm_a
.
b™s
.
size
,

163 
d©a
 = 
amo_d©a
,

164 
cÜru±
 = 
a_ÿm_a
.
b™s
.cÜru± || 
a_ÿm_d
.cÜru±).
_2


167 
	`TLArb™”
(
TLArb™”
.
lowe¡IndexFœ¡
)(
out
.
a
, (
	`UIÁ
(0), 
sourû_c
), (
edgeOut
.
	`numB—ts1
(
š
.a.
b™s
), 
sourû_i
))

170 
	`wh’
 (
sourû_i
.
	`fœe
(è&& !
a_isSuµÜ‹d
) {

171 (
a_ÿm_£l_ä“
 
z
 
ÿm_a
è
fÜ—ch
 { (
’
, 
r
) =>

172 
	`wh’
 (
’
) {

173 
r
.
fifoId
 :ğ
a_fifoId


174 
r
.
b™s
 :ğ
š
.
a
.bits

175 
r
.
lut
 :ğ
	`MuxLookup
(
š
.
a
.
b™s
.
	`·¿m
(1, 0), 
	`UIÁ
(0, 
width
 = 4), 
	`A¼ay
(

176 
TLAtomics
.
AND
 -> 
	`UIÁ
(0x8),

177 
TLAtomics
.
OR
 -> 
	`UIÁ
(0xe),

178 
TLAtomics
.
XOR
 -> 
	`UIÁ
(0x6),

179 
TLAtomics
.
SWAP
 -> 
	`UIÁ
(0xc)))

182 (
a_ÿm_£l_ä“
 
z
 
ÿm_s
è
fÜ—ch
 { (
’
, 
r
) =>

183 
	`wh’
 (
’
) {

184 
r
.
¡©e
 :ğ
GET


190 
	`wh’
 (
sourû_c
.
	`fœe
()) {

191 (
a_ÿm_£l_put
 
z
 
ÿm_s
è
fÜ—ch
 { (
’
, 
r
) =>

192 
	`wh’
 (
’
) {

193 
r
.
¡©e
 :ğ
ACK


199 
v®
 
d_fœ¡
 = 
edgeOut
.
	`fœ¡
(
out
.
d
)

200 
v®
 
d_ÿm_£l_¿w
 = 
ÿm_a
.
	`m­
(
_
.
b™s
.
sourû
 ==ğ
š
.
d
.bits.source)

201 
v®
 
d_ÿm_£l_m©ch
 = (
d_ÿm_£l_¿w
 
z
 
ÿm_dm©ch
è
m­
 { (
a
,
b
) =>‡&&b }

202 
v®
 
d_ÿm_d©a
 = 
	`Mux1H
(
d_ÿm_£l_m©ch
, 
ÿm_d
.
	`m­
(
_
.
d©a
))

203 
v®
 
d_ÿm_d’›d
 = 
	`Mux1H
(
d_ÿm_£l_m©ch
, 
ÿm_d
.
	`m­
(
_
.
d’›d
))

204 
v®
 
d_ÿm_cÜru±
 = 
	`Mux1H
(
d_ÿm_£l_m©ch
, 
ÿm_d
.
	`m­
(
_
.
cÜru±
))

205 
v®
 
d_ÿm_£l_by·ss
 = ià(
edgeOut
.
mªag”
.
mšL©’cy
 > 0è
	`BoŞ
(
çl£
) 

206 
out
.
d
.
b™s
.
sourû
 ==ğ
š
.
a
.b™s.sourû && in.a.
v®id
 && !
a_isSuµÜ‹d


207 
v®
 
d_ÿm_£l
 = (
a_ÿm_£l_ä“
 
z
 
d_ÿm_£l_m©ch
è
m­
 { (
a
,
d
è=> 
	`Mux
(
d_ÿm_£l_by·ss
,‡, d) }

208 
v®
 
d_ÿm_£l_ªy
 = 
d_ÿm_£l_by·ss
 || 
d_ÿm_£l_m©ch
.
	`»duû
(
_
 || _)

209 
v®
 
d_ackd
 = 
out
.
d
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
AcûssAckD©a


210 
v®
 
d_ack
 = 
out
.
d
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
AcûssAck


212 
	`wh’
 (
out
.
d
.
	`fœe
(è&& 
d_fœ¡
) {

213 (
d_ÿm_£l
 
z
 
ÿm_d
è
fÜ—ch
 { (
’
, 
r
) =>

214 
	`wh’
 (
’
 && 
d_ackd
) {

215 
r
.
d©a
 :ğ
out
.
d
.
b™s
.data

216 
r
.
d’›d
 :ğ
out
.
d
.
b™s
.denied

217 
r
.
cÜru±
 :ğ
out
.
d
.
b™s
.corrupt

220 (
d_ÿm_£l
 
z
 
ÿm_s
è
fÜ—ch
 { (
’
, 
r
) =>

221 
	`wh’
 (
’
) {

223 
r
.
¡©e
 :ğ
	`Mux
(
d_ackd
, 
AMO
, 
FREE
)

228 
v®
 
d_drİ
 = 
d_fœ¡
 && 
d_ackd
 && 
d_ÿm_£l_ªy


229 
v®
 
d_»¶aû
 = 
d_fœ¡
 && 
d_ack
 && 
d_ÿm_£l_m©ch
.
	`»duû
(
_
 || _)

231 
š
.
d
.
v®id
 :ğ
out
.d.v®id && !
d_drİ


232 
out
.
d
.
»ady
 :ğ
š
.d.»ady || 
d_drİ


234 
š
.
d
.
b™s
 :ğ
out
.d.bits

235 
	`wh’
 (
d_»¶aû
) {

236 
š
.
d
.
b™s
.
İcode
 :ğ
TLMes§ges
.
AcûssAckD©a


237 
š
.
d
.
b™s
.
d©a
 :ğ
d_ÿm_d©a


238 
š
.
d
.
b™s
.
cÜru±
 :ğ
d_ÿm_cÜru±
 || 
out
.d.b™s.
d’›d


239 
š
.
d
.
b™s
.
d’›d
 :ğ
d_ÿm_d’›d
 || 
out
.d.bits.denied

242 
out
.
a
.
v®id
 :ğ
š
.a.valid

243 
š
.
a
.
»ady
 :ğ
out
.a.ready

244 
out
.
a
.
b™s
 :ğ
š
.a.bits

246 
š
.
d
.
v®id
 :ğ
out
.d.valid

247 
out
.
d
.
»ady
 :ğ
š
.d.ready

248 
š
.
d
.
b™s
 :ğ
out
.d.bits

251 ià(
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 && 
edgeIn
.
ş›Á
.
ªySuµÜtProbe
) {

252 
š
.
b
.
v®id
 :ğ
out
.b.valid

253 
out
.
b
.
»ady
 :ğ
š
.b.ready

254 
š
.
b
.
b™s
 :ğ
out
.b.bits

256 
out
.
c
.
v®id
 :ğ
š
.c.valid

257 
š
.
c
.
»ady
 :ğ
out
.c.ready

258 
out
.
c
.
b™s
 :ğ
š
.c.bits

260 
out
.
e
.
v®id
 :ğ
š
.e.valid

261 
š
.
e
.
»ady
 :ğ
out
.e.ready

262 
out
.
e
.
b™s
 :ğ
š
.e.bits

264 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

265 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

266 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

267 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

268 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

269 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

273 
	}
}

275 
objeù
 
TLAtomicAutom©a


277 
def
 
­¶y
(
logiÿl
: 
BoŞ—n
 = 
Œue
, 
¬™hm‘ic
: BoŞ—ÀğŒue, 
cÚcu¼’cy
: 
IÁ
 = 1, 
·s¡hrough
: BoŞ—ÀğŒue)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

279 
v®
 
©omics
 = 
LazyModuË
(
Ãw
 
TLAtomicAutom©a
(
logiÿl
, 
¬™hm‘ic
, 
cÚcu¼’cy
, 
·s¡hrough
))

280 
	g©omics
.
	gnode


283 
şass
 
CAMP¬ams
(
a
: 
TLBundËP¬am‘”s
, 
domašsN“dšgH–p
: 
IÁ
)

285 şas 
	cCAM_S
(
·¿ms
: 
CAMP¬ams
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
) {

286 
v®
 
¡©e
 = 
	`UIÁ
(
width
 = 2)

287 
	}
}

288 şas 
	cCAM_A
(
·¿ms
: 
CAMP¬ams
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
) {

289 
v®
 
b™s
 = 
Ãw
 
	`TLBundËA
(
·¿ms
.
a
)

290 
v®
 
fifoId
 = 
	`UIÁ
(
width
 = 
	`log2Up
(
·¿ms
.
domašsN“dšgH–p
))

291 
v®
 
lut
 = 
	`UIÁ
(
width
 = 4)

292 
	}
}

293 şas 
	cCAM_D
(
·¿ms
: 
CAMP¬ams
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
) {

294 
v®
 
d©a
 = 
	`UIÁ
(
width
 = 
·¿ms
.
a
.
d©aB™s
)

295 
v®
 
d’›d
 = 
	`BoŞ
()

296 
v®
 
cÜru±
 = 
	`BoŞ
()

297 
	}
}

301 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


303 şas 
	cTLRAMAtomicAutom©a
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

304 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

305 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("AtomicAutomata"))

306 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	$Add»ssS‘
(0x0, 0x3ff)))

309 
impÜt
 
TLMes§ges
.
_


310 
v®
 
‹¡
 = 
Ãw
 
	`Reque¡P©‹º
({
a
: 
TLBundËA
 =>

311 
v®
 
dÛsA
 = 
a
.
İcode
 ==ğ
Ar™hm‘icD©a
 ||‡.İcod==ğ
LogiÿlD©a


312 
v®
 
dÛsR
 = 
a
.
İcode
 ==ğ
G‘
 || 
dÛsA


313 
v®
 
dÛsW
 = 
a
.
İcode
 ==ğ
PutFuÎD©a
 ||‡.İcod==ğ
PutP¬tŸlD©a
 || 
dÛsA


314 (
dÛsR
 && 
Reque¡P©‹º
.
	`ov”Ïps
(
	`Seq
(
	`Add»ssS‘
(0x08, ~0x08)))(
a
)) ||

315 (
dÛsW
 && 
Reque¡P©‹º
.
	`ov”Ïps
(
	`Seq
(
	`Add»ssS‘
(0x10, ~0x10)))(
a
))

318 (
¿m
.
node


319 :ğ
	$TLE¼ÜEv®u©Ü
(
‹¡
)

320 :ğ
	$TLF¿gm’‹r
(4, 256)

321 :ğ
	$TLD–ay”
(0.1)

322 :ğ
	$TLAtomicAutom©a
()

323 :ğ
	$TLD–ay”
(0.1)

324 :ğ
	$TLE¼ÜEv®u©Ü
(
‹¡
, 
‹¡On
=
Œue
, 
‹¡Off
=true)

325 :ğ
mod–
.
node


326 :ğ
fuzz
.
node
)

328 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

329 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

330 
	}
}

333 
şass
 
	$TLRAMAtomicAutom©aTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

334 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMAtomicAutom©a
(
txns
)).
moduË
)

335 
io
.
fšished
 :ğ
dut
.io.finished

336 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Atomics.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gTLMes§ges
.
_


8 
impÜt
 
	gTLP”missiÚs
.
_


10 şas 
	cAtomics
(
·¿ms
: 
TLBundËP¬am‘”s
è
ex‹nds
 
ModuË


12 
v®
 
io
 = 
Ãw
 
BundË
 {

13 
v®
 
wr™e
 = 
	`BoŞ
().
æ


14 
v®
 
a
 = 
Ãw
 
	`TLBundËA
(
·¿ms
).
æ


15 
v®
 
d©a_š
 = 
	`UIÁ
(
width
 = 
·¿ms
.
d©aB™s
).
æ


16 
v®
 
d©a_out
 = 
	`UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

20 
v®
 
add”
 = 
io
.
a
.
	$·¿m
(2)

21 
v®
 ğ
io
.
a
.
	$·¿m
(1)

22 
v®
 
ke_max
 = 
io
.
a
.
	$·¿m
(0)

24 
v®
 
signB™
 = 
io
.
a
.
mask
 & 
	`C©
(
	`UIÁ
(1), ~io.a.mask >> 1)

25 
v®
 
šv_d
 = 
	`Mux
(
add”
, 
io
.
d©a_š
, ~io.data_in)

26 
v®
 
sum
 = (
	`FlIÁ”Ëaved
(8, 
io
.
a
.
mask
è& io.a.
d©a
è+ 
šv_d


27 
def
 
	$sign
(
x
: 
UIÁ
): 
BoŞ
 = (
	`C©
(x.
toBoŞs
.
	`grou³d
(8).
	`m­
(
_
.
Ï¡
).
toLi¡
.
»v”£
è& 
signB™
).
	$ÜR
()

28 
v®
 
sign_a
 = 
	$sign
(
io
.
a
.
d©a
)

29 
v®
 
sign_d
 = 
	$sign
(
io
.
d©a_š
)

30 
v®
 
sign_s
 = 
	$sign
(
sum
)

31 
v®
 
a_bigg”_uÃq
 = ==ğ
sign_a


32 
v®
 
a_bigg”
 = 
	`Mux
(
sign_a
 ==ğ
sign_d
, !
sign_s
, 
a_bigg”_uÃq
)

33 
v®
 
pick_a
 = 
ke_max
 ==ğ
a_bigg”


36 
v®
 
lut
 = 
	`Vec
(
	`Seq
(

37 
	`UIÁ
(0x6),

38 
	`UIÁ
(0xe),

39 
	`UIÁ
(0x8),

40 
	$UIÁ
(0xc)))(

41 
io
.
a
.
	$·¿m
(1,0))

42 
v®
 
logiÿl
 = 
	`C©
((
io
.
a
.
d©a
.
toBoŞs
 
z
 io.
d©a_š
.toBoŞs).
m­
 { ×, 
d
) =>

43 
	`lut
(
	`C©
(
a
, 
d
))

44 
	}
}.
	g»v”£
)

47 
v®
 
	g£Ëù
 = 
Mux
(
io
.
wr™e
, 
UIÁ
(1), 
Vec
(
Seq
(

48 
UIÁ
(1),

49 
UIÁ
(1),

50 
Mux
(
add”
, 
UIÁ
(2), Mux(
pick_a
, UInt(1), UInt(0))),

51 
UIÁ
(3),

52 
UIÁ
(0),

53 
UIÁ
(0),

54 
UIÁ
(0),

55 
	$UIÁ
(0)))(

56 
io
.
a
.
İcode
))

59 
v®
 
£Ëùs
 = 
io
.
a
.
mask
.
toBoŞs
.
	`m­
(
b
 => 
	`Mux
(b, 
£Ëù
, 
	$UIÁ
(0)))

60 
io
.
d©a_out
 :ğ
	`C©
(
£Ëùs
.
zW™hIndex
.
m­
 { (
s
, 
i
) =>

61 
	`Vec
(
	`Seq
(
io
.
d©a_š
, io.
a
.
d©a
, 
sum
, 
logiÿl
).
	`m­
(
	`_
((
i
 + 1è* 8 - 1, i * 8)))(
s
)

62 
	}
}.
	g»v”£
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BankBinder.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 şas 
	cBªkBšd”Node
(
mask
: 
BigIÁ
)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
TLCu¡omNode


11 
´iv©e
 
v®
 
b™
 = 
mask
 & -mask

12 
v®
 
maxXãr
 = 
	`T¿nsãrSizes
(1, ià(
b™
 =ğ0 || b™ > 4096è4096 b™.
toIÁ
)

13 
v®
 
ids
 = 
Add»ssS‘
.
	$’um”©eMask
(
mask
)

15 
def
 
	$»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

16 
v®
 
pÜts
 = 
ids
.
size


17 
v®
 
oSr
 = ià(
oSrs
 =ğ0è0 (
pÜts
 - 
oKnown
) / oStars

18 
v®
 
iSr
 = ià(
iSrs
 =ğ0è0 (
pÜts
 - 
iKnown
) / iStars

19 
	`»quœe
 (
pÜts
 =ğ
iKnown
 + 
iSr
*
iSrs
, 
s
"${name} must have ${ports} inputs, but has ${iKnown} + ${iStar}*${iStars}$lazyModule.line}")

20 
	`»quœe
 (
pÜts
 =ğ
oKnown
 + 
oSr
*
oSrs
, 
s
"${name} must have ${ports} outputs, but has ${iKnown} + ${iStar}*${iStars}$lazyModule.line}")

21 (
iSr
, 
oSr
)

24 
def
 
	$m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
]): Seq[TLClientPortParameters] =

25 (
p
 
z
 
ids
è
m­
 { (
ı
, 
id
è=> cp.
	`cİy
(
ş›Ás
 = cp.ş›Ás.m­ { 
c
 => c.copy(

26 
visib™y
 = 
c
.visib™y.
æ©M­
 { 
a
 =>‡.
	`š‹r£ù
(
	`Add»ssS‘
(
id
, ~
mask
))},

27 
suµÜtsProbe
 = 
c
.suµÜtsProb
š‹r£ù
 
maxXãr
,

28 
suµÜtsAr™hm‘ic
 = 
c
.suµÜtsAr™hm‘iø
š‹r£ù
 
maxXãr
,

29 
suµÜtsLogiÿl
 = 
c
.suµÜtsLogiÿÈ
š‹r£ù
 
maxXãr
,

30 
suµÜtsG‘
 = 
c
.suµÜtsG‘ 
š‹r£ù
 
maxXãr
,

31 
suµÜtsPutFuÎ
 = 
c
.suµÜtsPutFuÎ 
š‹r£ù
 
maxXãr
,

32 
suµÜtsPutP¬tŸl
 = 
c
.suµÜtsPutP¬tŸÈ
š‹r£ù
 
maxXãr
,

33 
suµÜtsHšt
 = 
c
.suµÜtsHšˆ
š‹r£ù
 
maxXãr
)})
	}
}

35 
def
 
	$m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
TLMªag”PÜtP¬am‘”s
]): Seq[TLManagerPortParameters] =

36 (
p
 
z
 
ids
è
m­
 { (
mp
, 
id
è=> mp.
	`cİy
(
mªag”s
 = mp.mªag”s.m­ { 
m
 => m.copy(

37 
add»ss
 = 
m
.add»ss.
æ©M­
 { 
a
 =>‡.
	`š‹r£ù
(
	`Add»ssS‘
(
id
, ~
mask
))},

38 
suµÜtsAcquœeT
 = 
m
.suµÜtsAcquœeT 
š‹r£ù
 
maxXãr
,

39 
suµÜtsAcquœeB
 = 
m
.suµÜtsAcquœeB 
š‹r£ù
 
maxXãr
,

40 
suµÜtsAr™hm‘ic
 = 
m
.suµÜtsAr™hm‘iø
š‹r£ù
 
maxXãr
,

41 
suµÜtsLogiÿl
 = 
m
.suµÜtsLogiÿÈ
š‹r£ù
 
maxXãr
,

42 
suµÜtsG‘
 = 
m
.suµÜtsG‘ 
š‹r£ù
 
maxXãr
,

43 
suµÜtsPutFuÎ
 = 
m
.suµÜtsPutFuÎ 
š‹r£ù
 
maxXãr
,

44 
suµÜtsPutP¬tŸl
 = 
m
.suµÜtsPutP¬tŸÈ
š‹r£ù
 
maxXãr
,

45 
suµÜtsHšt
 = 
m
.suµÜtsHšˆ
š‹r£ù
 
maxXãr
)})
	}
}

49 şas 
	cBªkBšd”
(
mask
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


51 
v®
 
node
 = 
	$BªkBšd”Node
(
mask
)

53 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

54 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

55 
out
 <> 
š


58 
	}
}

60 
objeù
 
	gBªkBšd”


62 
def
 
­¶y
(
mask
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 = {

63 
v®
 
bšd”
 = 
LazyModuË
(
Ãw
 
BªkBšd”
(
mask
))

64 
bšd”
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Broadcast.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

11 
şass
 
	$TLBrßdÿ¡
(
lšeBy‹s
: 
IÁ
, 
numT¿ck”s
: IÁ = 4, 
bufã¾ess
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


13 
	`»quœe
 (
lšeBy‹s
 > 0 && 
	`isPow2
(lineBytes))

14 
	`»quœe
 (
numT¿ck”s
 > 0)

16 
v®
 
node
 = 
	`TLAd­‹rNode
(

17 
ş›ÁFn
 = { 
ı
 =>

18 
ı
.
	`cİy
(
ş›Ás
 = 
	`Seq
(
	`TLCl›ÁP¬am‘”s
(

19 
Çme
 = "TLBroadcast",

20 
sourûId
 = 
	`IdRªge
(0, 1 << 
	`log2Ce
(
ı
.
’dSourûId
*4)))))

22 
mªag”Fn
 = { 
mp
 =>

23 
mp
.
	`cİy
(

24 
’dSškId
 = 
numT¿ck”s
,

25 
mªag”s
 = 
mp
.mªag”s.
m­
 { 
m
 =>

27 
	`»quœe
 (!
m
.
suµÜtsAcquœeB
)

29 ià(
m
.
»giÚTy³
 =ğ
RegiÚTy³
.
UNCACHED
) {

31 
v®
 
low”Bound
 = 
	`max
(
m
.
suµÜtsPutFuÎ
.
mš
, m.
suµÜtsG‘
.min)

32 
	`»quœe
 (!
m
.
suµÜtsPutFuÎ
 || m.suµÜtsPutFuÎ.
	`cÚšs
(
lšeBy‹s
), 
s
"${m.name} only supports PutFull(${m.supportsPutFull}), which does‚ot include $lineBytes")

33 
	`»quœe
 (!
m
.
suµÜtsG‘
 || m.suµÜtsG‘ .
	`cÚšs
(
lšeBy‹s
), 
s
"${m.name} only supports Get(${m.supportsGet}), which does‚ot include $lineBytes")

34 
m
.
	`cİy
(

35 
»giÚTy³
 = 
RegiÚTy³
.
TRACKED
,

36 
suµÜtsAcquœeB
 = 
	`T¿nsãrSizes
(
low”Bound
, 
lšeBy‹s
),

37 
suµÜtsAcquœeT
 = ià(
m
.
suµÜtsPutFuÎ
è
	`T¿nsãrSizes
(
low”Bound
, 
lšeBy‹s
è
T¿nsãrSizes
.
nÚe
,

38 
®waysG¿ÁsT
 = 
çl£
,

40 
suµÜtsPutFuÎ
 = 
	`T¿nsãrSizes
(
m
.suµÜtsPutFuÎ .
mš
, 
	`mš
(m.suµÜtsPutFuÎ .
max
, 
lšeBy‹s
)),

41 
suµÜtsPutP¬tŸl
 = 
	`T¿nsãrSizes
(
m
.suµÜtsPutP¬tŸl.
mš
, 
	`mš
(m.suµÜtsPutP¬tŸl.
max
, 
lšeBy‹s
)),

42 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(
m
.suµÜtsG‘ .
mš
, 
	`mš
(m.suµÜtsG‘ .
max
, 
lšeBy‹s
)),

43 
suµÜtsHšt
 = 
	`T¿nsãrSizes
(
m
.suµÜtsHšˆ.
mš
, 
	`mš
(m.suµÜtsHšˆ.
max
, 
lšeBy‹s
)),

44 
suµÜtsAr™hm‘ic
 = 
	`T¿nsãrSizes
(
m
.suµÜtsAr™hm‘ic.
mš
, 
	`mš
(m.suµÜtsAr™hm‘ic.
max
, 
lšeBy‹s
)),

45 
suµÜtsLogiÿl
 = 
	`T¿nsãrSizes
(
m
.suµÜtsLogiÿÈ.
mš
, 
	`mš
(m.suµÜtsLogiÿÈ.
max
, 
lšeBy‹s
)),

46 
fifoId
 = 
NÚe


49 
m


56 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

57 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

58 
v®
 
ş›Ás
 = 
edgeIn
.
ş›Á
.clients

59 
v®
 
mªag”s
 = 
edgeOut
.
mªag”
.managers

60 
v®
 
lšeShiá
 = 
	`log2Ce
(
lšeBy‹s
)

62 
impÜt
 
TLBrßdÿ¡CÚ¡ªts
.
_


64 
	`»quœe
 (
lšeBy‹s
 >ğ
edgeOut
.
mªag”
.
b—tBy‹s
)

66 
v®
 
ÿches
 = 
ş›Ás
.
	`f‹r
(
_
.
suµÜtsProbe
).
	`m­
(_.
sourûId
)

67 
v®
 
ÿche_rg‘s
 = 
ÿches
.
	`m­
(
c
 => 
	`UIÁ
(c.
¡¬t
))

70 
v®
 
Œack”s
 = 
Seq
.
	`buÏ‹
(
numT¿ck”s
è{ 
id
 =>

71 
	`ModuË
(
Ãw
 
	`TLBrßdÿ¡T¿ck”
(
id
, 
lšeBy‹s
, 
	`log2Up
(
ÿches
.
size
+1), 
bufã¾ess
, 
edgeIn
, 
edgeOut
)).
io


75 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

76 (
Œack”s
 
z
 
	`UIÁToOH
(
š
.
e
.
b™s
.
sšk
).
toBoŞs
è
fÜ—ch
 { (
Œack”
, 
£Ëù
) =>

77 
Œack”
.
e_Ï¡
 :ğ
£Ëù
 && 
š
.
e
.
	`fœe
()

81 
v®
 
d_high
 = 
	`log2Ce
(
edgeIn
.
ş›Á
.
’dSourûId
)

82 
v®
 
d_wh©
 = 
out
.
d
.
b™s
.
	`sourû
(
d_high
+1, d_high)

83 
v®
 
d_drİ
 = 
d_wh©
 ==ğ
DROP


84 
v®
 
d_hasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
b™s
)

85 
v®
 
d_nÜm®
 = 
	`Wœe
(
š
.
d
)

86 
v®
 
d_Œack”OH
 = 
	`Vec
(
Œack”s
.
m­
 { 
t
 => !t.
idË
 &&.
sourû
 ==ğ
d_nÜm®
.
b™s
.sourû }).
asUIÁ


88 
	`as£¹
 (!
out
.
d
.
v®id
 || !
d_drİ
 || out.d.
b™s
.
İcode
 ==ğ
TLMes§ges
.
AcûssAck
)

90 
out
.
d
.
»ady
 :ğ
d_nÜm®
.»ady || 
d_drİ


91 
d_nÜm®
.
v®id
 :ğ
out
.
d
.v®id && !
d_drİ


92 
d_nÜm®
.
b™s
 :ğ
out
.
d
.bits

93 
	`wh’
 (
	`d_wh©
(1)) {

94 
d_nÜm®
.
b™s
.
İcode
 :ğ
	`Mux
(
d_hasD©a
, 
TLMes§ges
.
G¿ÁD©a
, TLMes§ges.
R–—£Ack
)

95 
d_nÜm®
.
b™s
.
·¿m
 :ğ
	`Mux
(
d_hasD©a
, Mux(
	`d_wh©
(0), 
TLP”missiÚs
.
toT
, TLP”missiÚs.
toB
), 
	`UIÁ
(0))

97 
d_nÜm®
.
b™s
.
sšk
 :ğ
	`OHToUIÁ
(
d_Œack”OH
)

98 
	`as£¹
 (!
d_nÜm®
.
v®id
 || (
d_Œack”OH
.
	`ÜR
(è|| d_nÜm®.
b™s
.
İcode
 ==ğ
TLMes§ges
.
R–—£Ack
))

101 
v®
 
d_»¥Ú£
 = 
d_hasD©a
 || !
	`d_wh©
(1)

102 
v®
 
d_Ï¡
 = 
edgeIn
.
	`Ï¡
(
d_nÜm®
)

103 (
Œack”s
 
z
 
d_Œack”OH
.
toBoŞs
è
fÜ—ch
 { (
Œack”
, 
£Ëù
) =>

104 
Œack”
.
d_Ï¡
 :ğ
£Ëù
 && 
d_nÜm®
.
	`fœe
(è&& 
d_»¥Ú£
 && d_last

105 
Œack”
.
´obedack
 :ğ
£Ëù
 && 
out
.
d
.
	`fœe
(è&& 
d_drİ


114 
v®
 
c_´ob—ck
 = 
š
.
c
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
ProbeAck


115 
v®
 
c_´ob—ckd©a
 = 
š
.
c
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
ProbeAckD©a


116 
v®
 
c_»Ëa£d©a
 = 
š
.
c
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
R–—£D©a


117 
v®
 
c_»Ëa£
 = 
š
.
c
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
R–—£


118 
v®
 
c_Œack”OH
 = 
Œack”s
.
m­
 { 
t
 =>.
lše
 ==ğ(
š
.
c
.
b™s
.
add»ss
 >> 
lšeShiá
) }

119 
v®
 
c_Œack”Src
 = 
	`Mux1H
(
c_Œack”OH
, 
Œack”s
.
m­
 { 
_
.
sourû
 })

122 (
Œack”s
 
z
 
c_Œack”OH
è
fÜ—ch
 { (
Œack”
, 
£Ëù
) =>

123 
Œack”
.
´ob’ack
 :ğ
š
.
c
.
	`fœe
(è&& 
c_´ob—ck
 && 
£Ëù


126 
v®
 
»Ëa£ack
 = 
	`Wœe
(
š
.
d
)

127 
v®
 
putfuÎ
 = 
	`Wœe
(
out
.
a
)

129 
š
.
c
.
»ady
 :ğ
c_´ob—ck
 || 
	`Mux
(
c_»Ëa£
, 
»Ëa£ack
.»ady, 
putfuÎ
.ready)

131 
»Ëa£ack
.
v®id
 :ğ
š
.
c
.v®id && 
c_»Ëa£


132 
»Ëa£ack
.
b™s
 :ğ
edgeIn
.
	`R–—£Ack
(
š
.
c
.bits)

134 
v®
 
put_wh©
 = 
	`Mux
(
c_»Ëa£d©a
, 
TRANSFORM_B
, 
DROP
)

135 
v®
 
put_who
 = 
	`Mux
(
c_»Ëa£d©a
, 
š
.
c
.
b™s
.
sourû
, 
c_Œack”Src
)

136 
putfuÎ
.
v®id
 :ğ
š
.
c
.v®id && (
c_´ob—ckd©a
 || 
c_»Ëa£d©a
)

137 
putfuÎ
.
b™s
 :ğ
edgeOut
.
	`Put
(
	`C©
(
put_wh©
, 
put_who
), 
š
.
c
.b™s.
add»ss
, in.c.b™s.
size
, in.c.b™s.
d©a
).
_2


140 
TLArb™”
.
	`lowe¡
(
edgeOut
, 
š
.
d
, 
»Ëa£ack
, 
d_nÜm®
)

142 
TLArb™”
.
	`lowe¡FromSeq
(
edgeOut
, 
out
.
a
, 
putfuÎ
 +: 
Œack”s
.
	`m­
(
_
.
out_a
))

145 
v®
 
´obe_todo
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
	`max
(1, 
ÿches
.
size
)))

146 
v®
 
´obe_lše
 = 
	`Reg
(
	`UIÁ
())

147 
v®
 
´obe_³rms
 = 
	`Reg
(
	`UIÁ
(
width
 = 2))

148 
v®
 
´obe_Ãxt
 = 
´obe_todo
 & ~(
	`ËáOR
(probe_todo) << 1)

149 
v®
 
´obe_busy
 = 
´obe_todo
.
	`ÜR
()

150 
v®
 
´obe_rg‘
 = ià(
ÿches
.
size
 =ğ0è
	`UIÁ
(0è
	`Mux1H
(
´obe_Ãxt
, 
ÿche_rg‘s
)

153 
š
.
b
.
v®id
 :ğ
´obe_busy


154 ià(
ÿches
.
size
 != 0) {

155 
š
.
b
.
b™s
 :ğ
edgeIn
.
	`Probe
(
´obe_lše
 << 
lšeShiá
, 
´obe_rg‘
, 
	`UIÁ
ÖšeShiá), 
´obe_³rms
).
_2


157 
	`wh’
 (
š
.
b
.
	`fœe
()è{ 
´obe_todo
 :ğ´obe_todØ& ~
´obe_Ãxt
 }

160 
v®
 
a_ÿche
 = ià(
ÿches
.
size
 =ğ0è
	`UIÁ
(1è
	`Vec
(ÿches.
	`m­
(
_
.
	`cÚšs
(
š
.
a
.
b™s
.
sourû
))).
asUIÁ


161 
v®
 
a_fœ¡
 = 
edgeIn
.
	`fœ¡
(
š
.
a
)

164 
v®
 
ä“T¿ck”s
 = 
	`Vec
(
Œack”s
.
m­
 { 
t
 =>.
idË
 }).
asUIÁ


165 
v®
 
ä“T¿ck”
 = 
ä“T¿ck”s
.
	`ÜR
()

166 
v®
 
m©chT¿ck”s
 = 
	`Vec
(
Œack”s
.
m­
 { 
t
 =>.
lše
 ==ğ
š
.
a
.
b™s
.
add»ss
 >> 
lšeShiá
 }).
asUIÁ


167 
v®
 
m©chT¿ck”
 = 
m©chT¿ck”s
.
	`ÜR
()

168 
v®
 
®locT¿ck”
 = 
ä“T¿ck”s
 & ~(
	`ËáOR
(freeTrackers) << 1)

169 
v®
 
£ËùT¿ck”
 = 
	`Mux
(
m©chT¿ck”
, 
m©chT¿ck”s
, 
®locT¿ck”
)

171 
v®
 
Œack”R—dy
 = 
	`Vec
(
Œack”s
.
	`m­
(
_
.
š_a
.
»ady
)).
asUIÁ


172 
š
.
a
.
»ady
 :ğ(!
a_fœ¡
 || !
´obe_busy
è&& (
£ËùT¿ck”
 & 
Œack”R—dy
).
	`ÜR
()

173 (
Œack”s
 
z
 
£ËùT¿ck”
.
toBoŞs
è
fÜ—ch
 { (
t
, 
£Ëù
) =>

174 
t
.
š_a
.
v®id
 :ğ
š
.
a
.v®id && 
£Ëù
 && (!
a_fœ¡
 || !
´obe_busy
)

175 
t
.
š_a
.
b™s
 :ğ
š
.
a
.bits

176 
t
.
š_a_fœ¡
 :ğ
a_fœ¡


177 
t
.
´obe
 :ğ(ià(
ÿches
.
size
 =ğ0è
	`UIÁ
(0è
	`Mux
(
a_ÿche
.
	`ÜR
(), UInt(caches.size-1), UInt(caches.size)))

180 
v®
 
acq_³rms
 = 
	`MuxLookup
(
š
.
a
.
b™s
.
·¿m
, 
	`Wœe
(
	`UIÁ
(
width
 = 2)), 
	`A¼ay
(

181 
TLP”missiÚs
.
NtoB
 -> TLP”missiÚs.
toB
,

182 
TLP”missiÚs
.
NtoT
 -> TLP”missiÚs.
toN
,

183 
TLP”missiÚs
.
BtoT
 -> TLP”missiÚs.
toN
))

185 
	`wh’
 (
š
.
a
.
	`fœe
(è&& 
a_fœ¡
) {

186 
´obe_todo
 :ğ~
a_ÿche


187 
´obe_lše
 :ğ
š
.
a
.
b™s
.
add»ss
 >> 
lšeShiá


188 
´obe_³rms
 :ğ
	`MuxLookup
(
š
.
a
.
b™s
.
İcode
, 
	`Wœe
(
	`UIÁ
(
width
 = 2)), 
	`A¼ay
(

189 
TLMes§ges
.
PutFuÎD©a
 -> 
TLP”missiÚs
.
toN
,

190 
TLMes§ges
.
PutP¬tŸlD©a
 -> 
TLP”missiÚs
.
toN
,

191 
TLMes§ges
.
Ar™hm‘icD©a
 -> 
TLP”missiÚs
.
toN
,

192 
TLMes§ges
.
LogiÿlD©a
 -> 
TLP”missiÚs
.
toN
,

193 
TLMes§ges
.
G‘
 -> 
TLP”missiÚs
.
toB
,

194 
TLMes§ges
.
Hšt
 -> 
	`MuxLookup
(
š
.
a
.
b™s
.
·¿m
, 
	`Wœe
(
	`UIÁ
(
width
 = 2)), 
	`A¼ay
(

195 
TLHšts
.
PREFETCH_READ
 -> 
TLP”missiÚs
.
toB
,

196 
TLHšts
.
PREFETCH_WRITE
 -> 
TLP”missiÚs
.
toN
)),

197 
TLMes§ges
.
AcquœeBlock
 -> 
acq_³rms
,

198 
TLMes§ges
.
AcquœeP”m
 -> 
acq_³rms
))

202 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

203 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

204 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

207 
	}
}

209 
objeù
 
TLBrßdÿ¡


211 
def
 
­¶y
(
lšeBy‹s
: 
IÁ
, 
numT¿ck”s
: IÁ = 4, 
bufã¾ess
: 
BoŞ—n
 = 
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

213 
v®
 
brßdÿ¡
 = 
LazyModuË
(
Ãw
 
TLBrßdÿ¡
(
lšeBy‹s
, 
numT¿ck”s
, 
bufã¾ess
))

214 
	gbrßdÿ¡
.
	gnode


218 
şass
 
	$TLBrßdÿ¡T¿ck”
(
id
: 
IÁ
, 
lšeBy‹s
: IÁ, 
´obeCouÁB™s
: IÁ, 
bufã¾ess
: 
BoŞ—n
, 
edgeIn
: 
TLEdgeIn
, 
edgeOut
: 
TLEdgeOut
è
ex‹nds
 
ModuË


220 
v®
 
io
 = 
Ãw
 
BundË
 {

221 
v®
 
š_a_fœ¡
 = 
	`BoŞ
(
INPUT
)

222 
v®
 
š_a
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËA
(
edgeIn
.
bundË
)).
æ


223 
v®
 
out_a
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËA
(
edgeOut
.
bundË
))

224 
v®
 
´obe
 = 
	`UIÁ
(
INPUT
, 
width
 = 
´obeCouÁB™s
)

225 
v®
 
´ob’ack
 = 
	`BoŞ
(
INPUT
)

226 
v®
 
´obedack
 = 
	`BoŞ
(
INPUT
)

227 
v®
 
d_Ï¡
 = 
	`BoŞ
(
INPUT
)

228 
v®
 
e_Ï¡
 = 
	`BoŞ
(
INPUT
)

229 
v®
 
sourû
 = 
	`UIÁ
(
OUTPUT
)

230 
v®
 
lše
 = 
	`UIÁ
(
OUTPUT
)

231 
v®
 
idË
 = 
	`BoŞ
(
OUTPUT
)

234 
v®
 
lšeShiá
 = 
	`log2Ce
(
lšeBy‹s
)

235 
impÜt
 
TLBrßdÿ¡CÚ¡ªts
.
_


239 
v®
 
gÙ_e
 = 
	`RegIn™
(
	`BoŞ
(
Œue
))

240 
v®
 
£Á_d
 = 
	`RegIn™
(
	`BoŞ
(
Œue
))

241 
v®
 
İcode
 = 
	`Reg
(
io
.
š_a
.
b™s
.opcode)

242 
v®
 
·¿m
 = 
	`Reg
(
io
.
š_a
.
b™s
.param)

243 
v®
 
size
 = 
	`Reg
(
io
.
š_a
.
b™s
.size)

244 
v®
 
sourû
 = 
	`Reg
(
io
.
š_a
.
b™s
.source)

245 
v®
 
add»ss
 = 
	`RegIn™
(
	`UIÁ
(
id
 << 
lšeShiá
, 
width
 = 
io
.
š_a
.
b™s
.add»ss.
g‘Width
))

246 
v®
 
couÁ
 = 
	`Reg
(
	`UIÁ
(
width
 = 
´obeCouÁB™s
))

247 
v®
 
idË
 = 
gÙ_e
 && 
£Á_d


249 
	`wh’
 (
io
.
š_a
.
	`fœe
(è&& io.
š_a_fœ¡
) {

250 
	`as£¹
 (
idË
)

251 
£Á_d
 :ğ
	`BoŞ
(
çl£
)

252 
gÙ_e
 :ğ
io
.
š_a
.
b™s
.
İcode
 =/ğ
TLMes§ges
.
AcquœeBlock
 && io.š_a.b™s.İcod=/ğTLMes§ges.
AcquœeP”m


253 
İcode
 :ğ
io
.
š_a
.
b™s
.opcode

254 
·¿m
 :ğ
io
.
š_a
.
b™s
.param

255 
size
 :ğ
io
.
š_a
.
b™s
.size

256 
sourû
 :ğ
io
.
š_a
.
b™s
.source

257 
add»ss
 :ğ
io
.
š_a
.
b™s
.address

258 
couÁ
 :ğ
io
.
´obe


260 
	`wh’
 (
io
.
d_Ï¡
) {

261 
	`as£¹
 (!
£Á_d
)

262 
£Á_d
 :ğ
	`BoŞ
(
Œue
)

264 
	`wh’
 (
io
.
e_Ï¡
) {

265 
	`as£¹
 (!
gÙ_e
)

266 
gÙ_e
 :ğ
	`BoŞ
(
Œue
)

269 
	`wh’
 (
io
.
´ob’ack
 || io.
´obedack
) {

270 
	`as£¹
 (
couÁ
 > 
	`UIÁ
(0))

271 
couÁ
 :ğcouÁ - 
	`Mux
(
io
.
´ob’ack
 && io.
´obedack
, 
	`UIÁ
(2), UInt(1))

274 
io
.
idË
 := idle

275 
io
.
sourû
 := source

276 
io
.
lše
 :ğ
add»ss
 >> 
lšeShiá


278 
v®
 
i_d©a
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`TLBrßdÿ¡D©a
(
edgeIn
.
bundË
)))

279 
v®
 
o_d©a
 = 
	`Queue
(
i_d©a
, ià(
bufã¾ess
è1 (
lšeBy‹s
 / 
edgeIn
.
mªag”
.
b—tBy‹s
), 
pe
=bufferless)

281 
io
.
š_a
.
»ady
 :ğ(
idË
 || !io.
š_a_fœ¡
è&& 
i_d©a
.ready

282 
i_d©a
.
v®id
 :ğ(
idË
 || !
io
.
š_a_fœ¡
è&& io.
š_a
.valid

283 
i_d©a
.
b™s
.
mask
 :ğ
io
.
š_a
.bits.mask

284 
i_d©a
.
b™s
.
d©a
 :ğ
io
.
š_a
.bits.data

286 
v®
 
´obe_dÚe
 = 
couÁ
 ==ğ
	`UIÁ
(0)

287 
v®
 
acquœe
 = 
İcode
 ==ğ
TLMes§ges
.
AcquœeBlock
 || opcod==ğTLMes§ges.
AcquœeP”m


289 
v®
 
ŒªsfÜm
 = 
	`MuxLookup
(
·¿m
, 
	`Wœe
(
	`UIÁ
(
width
 = 2)), 
	`A¼ay
(

290 
TLP”missiÚs
.
NtoB
 -> 
TRANSFORM_B
,

291 
TLP”missiÚs
.
NtoT
 -> 
TRANSFORM_T
,

292 
TLP”missiÚs
.
BtoT
 -> 
TRANSFORM_T
))

294 
o_d©a
.
»ady
 :ğ
io
.
out_a
.»ady && 
´obe_dÚe


295 
io
.
out_a
.
v®id
 :ğ
o_d©a
.v®id && 
´obe_dÚe


296 
io
.
out_a
.
b™s
.
İcode
 :ğ
	`Mux
(
acquœe
, 
TLMes§ges
.
G‘
, opcode)

297 
io
.
out_a
.
b™s
.
·¿m
 :ğ
	`Mux
(
acquœe
, 
	`UIÁ
(0),…aram)

298 
io
.
out_a
.
b™s
.
size
 := size

299 
io
.
out_a
.
b™s
.
sourû
 :ğ
	`C©
(
	`Mux
(
acquœe
, 
ŒªsfÜm
, 
PASS
), source)

300 
io
.
out_a
.
b™s
.
add»ss
 :=‡ddress

301 
io
.
out_a
.
b™s
.
mask
 :ğ
o_d©a
.bits.mask

302 
io
.
out_a
.
b™s
.
d©a
 :ğ
o_d©a
.bits.data

303 
io
.
out_a
.
b™s
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

304 
	}
}

306 
objeù
 
TLBrßdÿ¡CÚ¡ªts


308 
def
 
TRANSFORM_T
 = 
UIÁ
(3)

309 
def
 
TRANSFORM_B
 = 
UIÁ
(2)

310 
def
 
DROP
 = 
UIÁ
(1)

311 
def
 
PASS
 = 
UIÁ
(0)

314 şas 
	cTLBrßdÿ¡D©a
(
·¿ms
: 
TLBundËP¬am‘”s
è
ex‹nds
 
	$TLBundËBa£
(
·¿ms
)

316 
v®
 
mask
 = 
	`UIÁ
(
width
 = 
·¿ms
.
d©aB™s
/8)

317 
v®
 
d©a
 = 
	`UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Buffer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

10 
şass
 
	$TLBufãrNode
 (

11 
a
: 
BufãrP¬ams
,

12 
b
: 
BufãrP¬ams
,

13 
c
: 
BufãrP¬ams
,

14 
d
: 
BufãrP¬ams
,

15 
e
: 
BufãrP¬ams
)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	`TLAd­‹rNode
(

16 
ş›ÁFn
 = { 
p
 =>….
	`cİy
(
mšL©’cy
 =….mšL©’cy + 
b
.
Ï‹ncy
 + 
c
.Ï‹ncyè
	}
},

17 
	gmªag”Fn
 = { 
p
 =>….
cİy
(
mšL©’cy
 =….mšL©’cy + 
a
.
Ï‹ncy
 + 
d
.latency) }

19 
ov”ride
 
Ïzy
 
v®
 
	gnodedebug¡ršg
 = 
s
"a:${a.toString}, b:${b.toString}, c:${c.toString}, d:${d.toString},ƒ:${e.toString}"

23 
şass
 
	$TLBufãr
(

24 
a
: 
BufãrP¬ams
,

25 
b
: 
BufãrP¬ams
,

26 
c
: 
BufãrP¬ams
,

27 
d
: 
BufãrP¬ams
,

28 
e
: 
BufãrP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


30 
def
 
	`this
(
aû
: 
BufãrP¬ams
, 
bd
: BufãrP¬ams)(
im¶ic™
 
p
: 
P¬am‘”s
) =his(ace, bd,‡ce, bd,‡ce)

31 
def
 
	`this
(
abcde
: 
BufãrP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
) =his(abcde,‡bcde)

32 
def
 
	`this
()(
im¶ic™
 
p
: 
P¬am‘”s
èğthis(
BufãrP¬ams
.)

34 
v®
 
node
 = 
Ãw
 
	`TLBufãrNode
(
a
, 
b
, 
c
, 
d
, 
e
)

36 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

37 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

38 
out
.
a
 <> 
	`a
(
š
 .a)

39 
š
 .
d
 <> 
	`d
(
out
.d)

41 ià(
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeOut.
ş›Á
.
ªySuµÜtProbe
) {

42 
š
 .
b
 <> 
	`b
(
out
.b)

43 
out
.
c
 <> 
	`c
(
š
 .c)

44 
out
.
e
 <> 
	`e
(
š
 .e)

46 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

47 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

48 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

49 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

50 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

51 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

55 
	}
}

57 
objeù
 
TLBufãr


59 
def
 
­¶y
(è(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =‡µly(
BufãrP¬ams
.)

60 
def
 
­¶y
(
abcde
: 
BufãrP¬ams
è(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =‡pply(abcde,‡bcde)

61 
def
 
­¶y
(
aû
: 
BufãrP¬ams
, 
bd
: BufãrP¬ams)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =‡pply(ace, bd,‡ce, bd,‡ce)

62 
def
 
­¶y
(

63 
a
: 
BufãrP¬ams
,

64 
b
: 
BufãrP¬ams
,

65 
c
: 
BufãrP¬ams
,

66 
d
: 
BufãrP¬ams
,

67 
e
: 
BufãrP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

69 
v®
 
bufãr
 = 
LazyModuË
(
Ãw
 
TLBufãr
(
a
, 
b
, 
c
, 
d
, 
e
))

70 
	gbufãr
.
	gnode


73 
def
 
chaš
(
d•th
: 
IÁ
, 
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
Seq
[
TLNode
] = {

74 
v®
 
bufãrs
 = 
Seq
.
fl
(
d•th
è{ 
LazyModuË
(
Ãw
 
TLBufãr
()) }

75 
Çme
.
fÜ—ch
 { 
n
 => 
bufãrs
.
zW™hIndex
.fÜ—ch { (
b
, 
i
è=> b.
sugge¡Name
(
s
"${n}_${i}") } }

76 
	gbufãrs
.
m­
(
_
.
node
)

79 
def
 
chašNode
(
d•th
: 
IÁ
, 
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 = {

80 
chaš
(
d•th
, 
Çme
)

81 .
»duûLeáO±iÚ
(
_
 :*=* _)

82 .
g‘OrEl£
(
TLNameNode
("no_buffer"))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Bundles.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.{
	gR—dyV®idIO
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
ab¡¿ù
 cÏs 
	cTLBundËBa£
(
·¿ms
: 
TLBundËP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

16 
objeù
 
TLMes§ges


19 
def
 
PutFuÎD©a
 = 
	$UIÁ
(0)

20 
def
 
PutP¬tŸlD©a
 = 
	$UIÁ
(1)

21 
def
 
Ar™hm‘icD©a
 = 
	$UIÁ
(2)

22 
def
 
LogiÿlD©a
 = 
	$UIÁ
(3)

23 
def
 
G‘
 = 
	$UIÁ
(4)

24 
def
 
Hšt
 = 
	$UIÁ
(5)

25 
def
 
AcquœeBlock
 = 
	$UIÁ
(6)

26 
def
 
AcquœeP”m
 = 
	$UIÁ
(7)

27 
def
 
Probe
 = 
	$UIÁ
(6)

28 
def
 
AcûssAck
 = 
	$UIÁ
(0)

29 
def
 
AcûssAckD©a
 = 
	$UIÁ
(1)

30 
def
 
HštAck
 = 
	$UIÁ
(2)

31 
def
 
ProbeAck
 = 
	$UIÁ
(4)

32 
def
 
ProbeAckD©a
 = 
	$UIÁ
(5)

33 
def
 
R–—£
 = 
	$UIÁ
(6)

34 
def
 
R–—£D©a
 = 
	$UIÁ
(7)

35 
def
 
G¿Á
 = 
	$UIÁ
(4)

36 
def
 
G¿ÁD©a
 = 
	$UIÁ
(5)

37 
def
 
R–—£Ack
 = 
	$UIÁ
(6)

38 
def
 
G¿ÁAck
 = 
	$UIÁ
(0)

40 
def
 
	`isA
(
x
: 
UIÁ
èğx <ğ
AcquœeP”m


41 
def
 
	`isB
(
x
: 
UIÁ
èğx <ğ
Probe


42 
def
 
	`isC
(
x
: 
UIÁ
èğx <ğ
R–—£D©a


43 
def
 
	`isD
(
x
: 
UIÁ
èğx <ğ
R–—£Ack


45 
def
 
adRe¥Ú£
 = 
	$Vec
(
AcûssAck
, AcûssAck, 
AcûssAckD©a
, AcûssAckD©a, AcûssAckD©a, 
HštAck
, 
G¿Á
, Grant)

46 
def
 
bcRe¥Ú£
 = 
	$Vec
(
AcûssAck
, AcûssAck, 
AcûssAckD©a
, AcûssAckD©a, AcûssAckD©a, 
HštAck
, 
ProbeAck
, ProbeAck)

48 
def
 
a
 = 
	`Seq
Ğ("PutFuÎD©a",
TLP”missiÚs
.
P”mMsgRe£rved
),

49 ("PutP¬tŸlD©a",
TLP”missiÚs
.
P”mMsgRe£rved
),

50 ("Ar™hm‘icD©a",
TLAtomics
.
Ar™hMsg
),

51 ("LogiÿlD©a",
TLAtomics
.
LogicMsg
),

52 ("G‘",
TLP”missiÚs
.
P”mMsgRe£rved
),

53 ("Hšt",
TLHšts
.
HštsMsg
),

54 ("AcquœeBlock",
TLP”missiÚs
.
P”mMsgGrow
),

55 ("AcquœeP”m",
TLP”missiÚs
.
P”mMsgGrow
))

57 
def
 
b
 = 
	`Seq
Ğ("PutFuÎD©a",
TLP”missiÚs
.
P”mMsgRe£rved
),

58 ("PutP¬tŸlD©a",
TLP”missiÚs
.
P”mMsgRe£rved
),

59 ("Ar™hm‘icD©a",
TLAtomics
.
Ar™hMsg
),

60 ("LogiÿlD©a",
TLAtomics
.
LogicMsg
),

61 ("G‘",
TLP”missiÚs
.
P”mMsgRe£rved
),

62 ("Hšt",
TLHšts
.
HštsMsg
),

63 ("Probe",
TLP”missiÚs
.
P”mMsgC­
))

65 
def
 
c
 = 
	`Seq
Ğ("AcûssAck",
TLP”missiÚs
.
P”mMsgRe£rved
),

66 ("AcûssAckD©a",
TLP”missiÚs
.
P”mMsgRe£rved
),

67 ("HštAck",
TLP”missiÚs
.
P”mMsgRe£rved
),

68 ("Inv®id Opcode",
TLP”missiÚs
.
P”mMsgRe£rved
),

69 ("ProbeAck",
TLP”missiÚs
.
P”mMsgR•Üt
),

70 ("ProbeAckD©a",
TLP”missiÚs
.
P”mMsgR•Üt
),

71 ("R–—£",
TLP”missiÚs
.
P”mMsgR•Üt
),

72 ("R–—£D©a",
TLP”missiÚs
.
P”mMsgR•Üt
))

74 
def
 
d
 = 
	`Seq
Ğ("AcûssAck",
TLP”missiÚs
.
P”mMsgRe£rved
),

75 ("AcûssAckD©a",
TLP”missiÚs
.
P”mMsgRe£rved
),

76 ("HštAck",
TLP”missiÚs
.
P”mMsgRe£rved
),

77 ("Inv®id Opcode",
TLP”missiÚs
.
P”mMsgRe£rved
),

78 ("G¿Á",
TLP”missiÚs
.
P”mMsgC­
),

79 ("G¿ÁD©a",
TLP”missiÚs
.
P”mMsgC­
),

80 ("R–—£Ack",
TLP”missiÚs
.
P”mMsgRe£rved
))

93 
objeù
 
TLP”missiÚs


95 
v®
 
aWidth
 = 2

96 
v®
 
bdWidth
 = 2

97 
v®
 
cWidth
 = 3

100 
def
 
toT
 = 
	`UIÁ
(0, 
bdWidth
)

101 
def
 
toB
 = 
	`UIÁ
(1, 
bdWidth
)

102 
def
 
toN
 = 
	`UIÁ
(2, 
bdWidth
)

103 
def
 
	`isC­
(
x
: 
UIÁ
èğx <ğ
toN


106 
def
 
NtoB
 = 
	`UIÁ
(0, 
aWidth
)

107 
def
 
NtoT
 = 
	`UIÁ
(1, 
aWidth
)

108 
def
 
BtoT
 = 
	`UIÁ
(2, 
aWidth
)

109 
def
 
	`isGrow
(
x
: 
UIÁ
èğx <ğ
BtoT


112 
def
 
TtoB
 = 
	`UIÁ
(0, 
cWidth
)

113 
def
 
TtoN
 = 
	`UIÁ
(1, 
cWidth
)

114 
def
 
BtoN
 = 
	`UIÁ
(2, 
cWidth
)

115 
def
 
	`isShršk
(
x
: 
UIÁ
èğx <ğ
BtoN


118 
def
 
TtoT
 = 
	`UIÁ
(3, 
cWidth
)

119 
def
 
BtoB
 = 
	`UIÁ
(4, 
cWidth
)

120 
def
 
NtoN
 = 
	`UIÁ
(5, 
cWidth
)

121 
def
 
	`isR•Üt
(
x
: 
UIÁ
èğx <ğ
NtoN


123 
def
 
P”mMsgGrow
:
Seq
[
SŒšg
] = 
	`Seq
("Grow NtoB", "Grow NtoT", "Grow BtoT")

124 
def
 
P”mMsgC­
:
Seq
[
SŒšg
] = 
	`Seq
("CapoT", "CapoB", "CapoN")

125 
def
 
P”mMsgR•Üt
:
Seq
[
SŒšg
] = 
	`Seq
("Shrink TtoB", "Shrink TtoN", "Shrink BtoN", "Report TotT", "Report BtoB", "Report NtoN")

126 
def
 
P”mMsgRe£rved
:
Seq
[
SŒšg
] = 
	`Seq
("Reserved")

127 
	}
}

129 
objeù
 
TLAtomics


131 
v®
 
width
 = 3

134 
def
 
MIN
 = 
UIÁ
(0, 
width
)

135 
def
 
	gMAX
 = 
UIÁ
(1, 
width
)

136 
def
 
	gMINU
 = 
UIÁ
(2, 
width
)

137 
def
 
	gMAXU
 = 
UIÁ
(3, 
width
)

138 
def
 
	gADD
 = 
UIÁ
(4, 
width
)

139 
def
 
isAr™hm‘ic
(
x
: 
UIÁ
èğx <ğ
ADD


142 
def
 
XOR
 = 
UIÁ
(0, 
width
)

143 
def
 
	gOR
 = 
UIÁ
(1, 
width
)

144 
def
 
	gAND
 = 
UIÁ
(2, 
width
)

145 
def
 
	gSWAP
 = 
UIÁ
(3, 
width
)

146 
def
 
isLogiÿl
(
x
: 
UIÁ
èğx <ğ
SWAP


148 
def
 
Ar™hMsg
:
Seq
[
SŒšg
] = Seq("MIN", "MAX", "MIN", "MAXU", "ADD")

149 
def
 
	gLogicMsg
:
Seq
[
SŒšg
] = Seq("XOR", "OR", "AND", "SWAP")

153 
objeù
 
	gTLHšts


155 
v®
 
	gwidth
 = 1

157 
def
 
PREFETCH_READ
 = 
UIÁ
(0, 
width
)

158 
def
 
	gPREFETCH_WRITE
 = 
UIÁ
(1, 
width
)

160 
def
 
	gHštsMsg
:
Seq
[
SŒšg
] = Seq("PrefetchRead", "PrefetchWrite")

163 
£®ed
 
Œa™
 
TLChªÃl
 
ex‹nds
 
	gTLBundËBa£
 {

164 
v®
 
	gchªÃlName
: 
SŒšg


167 
£®ed
 
Œa™
 
TLD©aChªÃl
 
ex‹nds
 
TLChªÃl


168 
£®ed
 
Œa™
 
TLAddrChªÃl
 
ex‹nds
 
TLD©aChªÃl


170 
fš®
 cÏs 
	cTLBundËA
(
·¿ms
: 
TLBundËP¬am‘”s
)

171 
ex‹nds
 
	$TLBundËBa£
(
·¿ms
è
w™h
 
TLAddrChªÃl


173 
v®
 
chªÃlName
 = "'A' channel"

175 
v®
 
İcode
 = 
	$UIÁ
(
width
 = 3)

176 
v®
 
·¿m
 = 
	`UIÁ
(
width
 = 
	`Li¡
(
TLAtomics
.width, 
TLP”missiÚs
.
aWidth
, 
TLHšts
.width).
max
)

177 
v®
 
size
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sizeB™s
)

178 
v®
 
sourû
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sourûB™s
)

179 
v®
 
add»ss
 = 
	$UIÁ
(
width
 = 
·¿ms
.
add»ssB™s
)

181 
v®
 
mask
 = 
	`UIÁ
(
width
 = 
·¿ms
.
d©aB™s
/8)

182 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

183 
v®
 
cÜru±
 = 
	`BoŞ
()

185 
fš®
 cÏs 
	cTLBundËB
(
·¿ms
: 
TLBundËP¬am‘”s
)

186 
ex‹nds
 
	$TLBundËBa£
(
·¿ms
è
w™h
 
TLAddrChªÃl


188 
v®
 
chªÃlName
 = "'B' channel"

190 
v®
 
İcode
 = 
	$UIÁ
(
width
 = 3)

191 
v®
 
·¿m
 = 
	$UIÁ
(
width
 = 
TLP”missiÚs
.
bdWidth
)

192 
v®
 
size
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sizeB™s
)

193 
v®
 
sourû
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sourûB™s
)

194 
v®
 
add»ss
 = 
	$UIÁ
(
width
 = 
·¿ms
.
add»ssB™s
)

196 
v®
 
mask
 = 
	`UIÁ
(
width
 = 
·¿ms
.
d©aB™s
/8)

197 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

198 
v®
 
cÜru±
 = 
	`BoŞ
()

201 
fš®
 cÏs 
	cTLBundËC
(
·¿ms
: 
TLBundËP¬am‘”s
)

202 
ex‹nds
 
	$TLBundËBa£
(
·¿ms
è
w™h
 
TLAddrChªÃl


204 
v®
 
chªÃlName
 = "'C' channel"

206 
v®
 
İcode
 = 
	$UIÁ
(
width
 = 3)

207 
v®
 
·¿m
 = 
	$UIÁ
(
width
 = 
TLP”missiÚs
.
cWidth
)

208 
v®
 
size
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sizeB™s
)

209 
v®
 
sourû
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sourûB™s
)

210 
v®
 
add»ss
 = 
	$UIÁ
(
width
 = 
·¿ms
.
add»ssB™s
)

212 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

213 
v®
 
cÜru±
 = 
	`BoŞ
()

216 
fš®
 cÏs 
	cTLBundËD
(
·¿ms
: 
TLBundËP¬am‘”s
)

217 
ex‹nds
 
	$TLBundËBa£
(
·¿ms
è
w™h
 
TLD©aChªÃl


219 
v®
 
chªÃlName
 = "'D' channel"

221 
v®
 
İcode
 = 
	$UIÁ
(
width
 = 3)

222 
v®
 
·¿m
 = 
	$UIÁ
(
width
 = 
TLP”missiÚs
.
bdWidth
)

223 
v®
 
size
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sizeB™s
)

224 
v®
 
sourû
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sourûB™s
)

225 
v®
 
sšk
 = 
	$UIÁ
(
width
 = 
·¿ms
.
sškB™s
)

226 
v®
 
d’›d
 = 
	$BoŞ
()

228 
v®
 
d©a
 = 
	$UIÁ
(
width
 = 
·¿ms
.
d©aB™s
)

229 
v®
 
cÜru±
 = 
	`BoŞ
()

232 
fš®
 cÏs 
	cTLBundËE
(
·¿ms
: 
TLBundËP¬am‘”s
)

233 
ex‹nds
 
	$TLBundËBa£
(
·¿ms
è
w™h
 
TLChªÃl


235 
v®
 
chªÃlName
 = "'E' channel"

236 
v®
 
sšk
 = 
	`UIÁ
(
width
 = 
·¿ms
.
sškB™s
)

239 şas 
	cTLBundË
(
·¿ms
: 
TLBundËP¬am‘”s
è
ex‹nds
 
	$TLBundËBa£
(
·¿ms
)

241 
v®
 
a
 = 
	`Decou¶ed
(
Ãw
 
	$TLBundËA
(
·¿ms
))

242 
v®
 
b
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËB
(
·¿ms
)).
æ


243 
v®
 
c
 = 
	`Decou¶ed
(
Ãw
 
	$TLBundËC
(
·¿ms
))

244 
v®
 
d
 = 
	`Decou¶ed
(
Ãw
 
	`TLBundËD
(
·¿ms
)).
æ


245 
v®
 
e
 = 
	`Decou¶ed
(
Ãw
 
	$TLBundËE
(
·¿ms
))

247 
def
 
	$t›off
() {

248 
a
.
»ady
.
dœ
 
m©ch
 {

249 
INPUT
 =>

250 
a
.
»ady
 :ğ
	`BoŞ
(
çl£
)

251 
c
.
»ady
 :ğ
	`BoŞ
(
çl£
)

252 
e
.
»ady
 :ğ
	`BoŞ
(
çl£
)

253 
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

254 
d
.
v®id
 :ğ
	`BoŞ
(
çl£
)

255 
OUTPUT
 =>

256 
a
.
v®id
 :ğ
	`BoŞ
(
çl£
)

257 
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

258 
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

259 
b
.
»ady
 :ğ
	`BoŞ
(
çl£
)

260 
d
.
»ady
 :ğ
	`BoŞ
(
çl£
)

261 
_
 =>

264 
	}
}

266 
objeù
 
TLBundË


268 
def
 
­¶y
(
·¿ms
: 
TLBundËP¬am‘”s
èğ
Ãw
 
TLBundË
(params)

271 
fš®
 
şass
 
Decou¶edSnoİ
[+
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË


273 
v®
 
»ady
 = 
BoŞ
()

274 
v®
 
v®id
 = 
BoŞ
()

275 
v®
 
b™s
 = 
g’
.
asOuut


277 
def
 
fœe
(èğ
»ady
 && 
v®id


278 
ov”ride
 
def
 
şÚeTy³
: 
this
.
ty³
 = 
Ãw
 
Decou¶edSnoİ
(
g’
).
asIn¡ªûOf
[this.type]

281 
objeù
 
Decou¶edSnoİ


283 
def
 
­¶y
[
T
 <: 
D©a
](
sourû
: 
Decou¶edIO
[T], 
	gsšk
: DecoupledIO[T]) = {

284 
v®
 
out
 = 
Wœe
(
Ãw
 
Decou¶edSnoİ
(
sšk
.
b™s
))

285 
out
.
»ady
 :ğ
sšk
.ready

286 
out
.
v®id
 :ğ
sourû
.valid

287 
out
.
b™s
 :ğ
sourû
.bits

288 
out


292 şas 
	cTLBundËSnoİ
(
·¿ms
: 
TLBundËP¬am‘”s
è
ex‹nds
 
	$TLBundËBa£
(
·¿ms
)

294 
v®
 
a
 = 
Ãw
 
	`Decou¶edSnoİ
Òew 
	$TLBundËA
(
·¿ms
))

295 
v®
 
b
 = 
Ãw
 
	`Decou¶edSnoİ
Òew 
	$TLBundËB
(
·¿ms
))

296 
v®
 
c
 = 
Ãw
 
	`Decou¶edSnoİ
Òew 
	$TLBundËC
(
·¿ms
))

297 
v®
 
d
 = 
Ãw
 
	`Decou¶edSnoİ
Òew 
	$TLBundËD
(
·¿ms
))

298 
v®
 
e
 = 
Ãw
 
	`Decou¶edSnoİ
Òew 
	`TLBundËE
(
·¿ms
))

301 
objeù
 
TLBundËSnoİ


303 
def
 
	`­¶y
(
sourû
: 
TLBundË
, 
sšk
: TLBundle) = {

304 
v®
 
out
 = 
	`Wœe
(
Ãw
 
	`TLBundËSnoİ
(
sšk
.
·¿ms
))

305 
out
.
a
 :ğ
	`Decou¶edSnoİ
(
sourû
.a, 
sšk
.a)

306 
out
.
b
 :ğ
	`Decou¶edSnoİ
(
sšk
.b, 
sourû
.b)

307 
out
.
c
 :ğ
	`Decou¶edSnoİ
(
sourû
.c, 
sšk
.c)

308 
out
.
d
 :ğ
	`Decou¶edSnoİ
(
sšk
.d, 
sourû
.d)

309 
out
.
e
 :ğ
	`Decou¶edSnoİ
(
sourû
.e, 
sšk
.e)

310 
out


312 
	}
}

314 şas 
	cTLAsyncBundËBa£
(
·¿ms
: 
TLAsyncBundËP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

316 şas 
	cTLAsyncBundË
(
·¿ms
: 
TLAsyncBundËP¬am‘”s
è
ex‹nds
 
	$TLAsyncBundËBa£
(
·¿ms
)

318 
v®
 
a
 = 
Ãw
 
	`AsyncBundË
Òew 
	`TLBundËA
(
·¿ms
.
ba£
),…¬ams.
async
)

319 
v®
 
b
 = 
Ãw
 
	`AsyncBundË
Òew 
	`TLBundËB
(
·¿ms
.
ba£
),…¬ams.
async
).
æ


320 
v®
 
c
 = 
Ãw
 
	`AsyncBundË
Òew 
	`TLBundËC
(
·¿ms
.
ba£
),…¬ams.
async
)

321 
v®
 
d
 = 
Ãw
 
	`AsyncBundË
Òew 
	`TLBundËD
(
·¿ms
.
ba£
),…¬ams.
async
).
æ


322 
v®
 
e
 = 
Ãw
 
	`AsyncBundË
Òew 
	`TLBundËE
(
·¿ms
.
ba£
),…¬ams.
async
)

325 şas 
	cTLR©iÚ®BundË
(
·¿ms
: 
TLBundËP¬am‘”s
è
ex‹nds
 
	$TLBundËBa£
(
·¿ms
)

327 
v®
 
a
 = 
	`R©iÚ®IO
(
Ãw
 
	$TLBundËA
(
·¿ms
))

328 
v®
 
b
 = 
	`R©iÚ®IO
(
Ãw
 
	`TLBundËB
(
·¿ms
)).
æ


329 
v®
 
c
 = 
	`R©iÚ®IO
(
Ãw
 
	$TLBundËC
(
·¿ms
))

330 
v®
 
d
 = 
	`R©iÚ®IO
(
Ãw
 
	`TLBundËD
(
·¿ms
)).
æ


331 
v®
 
e
 = 
	`R©iÚ®IO
(
Ãw
 
	`TLBundËE
(
·¿ms
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BusWrapper.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
Œa™
 
	gHasTLBusP¬ams
 {

12 
def
 
	gb—tBy‹s
: 
IÁ


13 
def
 
blockBy‹s
: 
IÁ


15 
def
 
b—tB™s
: 
IÁ
 = 
b—tBy‹s
 * 8

16 
def
 
blockB™s
: 
IÁ
 = 
blockBy‹s
 * 8

17 
def
 
blockB—ts
: 
IÁ
 = 
blockBy‹s
 / 
b—tBy‹s


18 
def
 
blockOff£t
: 
IÁ
 = 
log2Up
(
blockBy‹s
)

21 
ab¡¿ù
 
şass
 
	$TLBusW¿µ”
(
·¿ms
: 
HasTLBusP¬ams
, 
v®
 
busName
: 
SŒšg
)(
im¶ic™
 
p
: 
P¬am‘”s
)

22 
ex‹nds
 
Sim¶eLazyModuË


23 
w™h
 
LazyScİe


24 
w™h
 
HasTLBusP¬ams
 {

26 
def
 
b—tBy‹s
 = 
·¿ms
.beatBytes

27 
def
 
blockBy‹s
 = 
·¿ms
.blockBytes

28 
	`»quœe
(
blockBy‹s
 % 
b—tBy‹s
 == 0)

30 
def
 
šw¬dNode
: 
TLInw¬dNode


31 
def
 
outw¬dNode
: 
TLOutw¬dNode


33 
def
 
to
[
T
](
Çme
: 
SŒšg
)(
body
: => T): T = {

34 
this
 { 
	`LazyScİe
(
s
"cou¶”_to_${Çme}"è{ 
body
 } }

37 
def
 
äom
[
T
](
Çme
: 
SŒšg
)(
body
: => T): T = {

38 
this
 { 
	`LazyScİe
(
s
"cou¶”_äom_${Çme}"è{ 
body
 } }

41 
def
 
cou¶eTo
[
T
](
Çme
: 
SŒšg
)(
g’
: 
TLOutw¬dNode
 => T): T =

42 
	`to
(
Çme
è{ 
	`g’
(
outw¬dNode
) }

44 
def
 
cou¶eFrom
[
T
](
Çme
: 
SŒšg
)(
g’
: 
TLInw¬dNode
 => T): T =

45 
	`äom
(
Çme
è{ 
	`g’
(
šw¬dNode
) }

46 
	}
}

48 
Œa™
 
CªA‰achTLSÏves
 
ex‹nds
 
HasTLBusP¬ams
 { 
this
: 
TLBusW¿µ”
 =>

49 
def
 
toSÏve
[
D
,
U
,
E
,
B
 <: 
D©a
]

50 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

51 (
g’
: => 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
,
D
,
U
,
E
,
B
] =

52 
TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

53 
to
("¦ave" 
Çmed
 
Çme
è{ 
g’
 :*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode
 }

56 
def
 
toV¬ŸbËWidthSÏveNode
(
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
bufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)(
node
: 
TLInw¬dNode
) {

57 
toV¬ŸbËWidthSÏveNodeO±iÚ
(
Çme
, 
bufãr
)(
Some
(
node
))

60 
def
 
toV¬ŸbËWidthSÏveNodeO±iÚ
(
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
bufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)(
node
: O±iÚ[
TLInw¬dNode
]) {

61 
node
 
fÜ—ch
 { 
n
 => 
to
("¦ave" 
Çmed
 
Çme
) {

62 
n
 :*ğ
TLF¿gm’‹r
(
b—tBy‹s
, 
blockBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode


66 
def
 
toV¬ŸbËWidthSÏve
[
D
,
U
,
E
,
B
 <: 
D©a
]

67 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

68 (
g’
: => 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
,
D
,
U
,
E
,
B
] =

69 
TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

70 
to
("¦ave" 
Çmed
 
Çme
) {

71 
g’
 :*ğ
TLF¿gm’‹r
(
b—tBy‹s
, 
blockBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode


75 
def
 
toFixedWidthSÏveNode
(
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
bufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)(
g’
: 
TLInw¬dNode
) {

76 
to
("¦ave" 
Çmed
 
Çme
è{ 
g’
 :*ğ
TLWidthWidg‘
(
b—tBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode
 }

79 
def
 
toFixedWidthSÏve
[
D
,
U
,
E
,
B
 <: 
D©a
]

80 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

81 (
g’
: => 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
,
D
,
U
,
E
,
B
] =

82 
TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

83 
to
("¦ave" 
Çmed
 
Çme
è{ 
g’
 :*ğ
TLWidthWidg‘
(
b—tBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode
 }

86 
def
 
toFixedWidthSšgËB—tSÏveNode


87 (
widthBy‹s
: 
IÁ
, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

88 (
g’
: 
TLInw¬dNode
) {

89 
to
("¦ave" 
Çmed
 
Çme
) {

90 
g’
 :*ğ
TLF¿gm’‹r
(
widthBy‹s
, 
blockBy‹s
è:*ğ
TLWidthWidg‘
(
b—tBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode


94 
def
 
toFixedWidthSšgËB—tSÏve
[
D
,
U
,
E
,
B
 <: 
D©a
]

95 (
widthBy‹s
: 
IÁ
, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

96 (
g’
: => 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
,
D
,
U
,
E
,
B
] =

97 
TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

98 
to
("¦ave" 
Çmed
 
Çme
) {

99 
g’
 :*ğ
TLF¿gm’‹r
(
widthBy‹s
, 
blockBy‹s
è:*ğ
TLWidthWidg‘
(
b—tBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode


103 
def
 
toL¬geBur¡SÏve
[
D
,
U
,
E
,
B
 <: 
D©a
]

104 (
maxXãrBy‹s
: 
IÁ
, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

105 (
g’
: => 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
,
D
,
U
,
E
,
B
] =

106 
TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

107 
to
("¦ave" 
Çmed
 
Çme
) {

108 
g’
 :*ğ
TLF¿gm’‹r
(
b—tBy‹s
, 
maxXãrBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode


112 
def
 
toFixedWidthPÜt
[
D
,
U
,
E
,
B
 <: 
D©a
]

113 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

114 (
g’
: => 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeIn
,
TLBundË
,
D
,
U
,
E
,
B
] =

115 
TLNameNode
(
Çme
)): 
Outw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

116 
to
("pÜt" 
Çmed
 
Çme
) {

117 
g’
 :ğ
TLWidthWidg‘
(
b—tBy‹s
è:*ğ
TLBufãr
(
bufãr
è:*ğ
outw¬dNode


122 
Œa™
 
CªA‰achTLMa¡”s
 
ex‹nds
 
HasTLBusP¬ams
 { 
this
: 
TLBusW¿µ”
 =>

123 
def
 
äomMa¡”Node


124 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

125 (
g’
: 
TLOutw¬dNode
) {

126 
äom
("ma¡”" 
Çmed
 
Çme
) {

127 
šw¬dNode
 :=* 
TLBufãr
(
bufãr
è:=* 
TLFIFOFix”
(TLFIFOFix”.
®l
è:=* 
g’


131 
def
 
äomMa¡”
[
D
,
U
,
E
,
B
 <: 
D©a
]

132 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

133 (
g’
: => 
NodeHªdË
[
D
,
U
,
E
,
B
,
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeOut
,
TLBundË
] =

134 
TLNameNode
(
Çme
)): 
Inw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

135 
äom
("ma¡”" 
Çmed
 
Çme
) {

136 
šw¬dNode
 :=* 
TLBufãr
(
bufãr
è:=* 
TLFIFOFix”
(TLFIFOFix”.
®l
è:=* 
g’


140 
def
 
äomPÜt
[
D
,
U
,
E
,
B
 <: 
D©a
]

141 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

142 (
g’
: => 
NodeHªdË
[
D
,
U
,
E
,
B
,
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeOut
,
TLBundË
] =

143 
TLNameNode
(
Çme
)): 
Inw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

144 
äom
("pÜt" 
Çmed
 
Çme
) {

145 
šw¬dNode
 :=* 
TLBufãr
(
bufãr
è:=* 
TLFIFOFix”
(TLFIFOFix”.
®l
è:=* 
g’


149 
def
 
äomCoh”’tMa¡”
[
D
,
U
,
E
,
B
 <: 
D©a
]

150 (
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
	gbufãr
: 
BufãrP¬ams
 = BufãrP¬ams.
nÚe
)

151 (
g’
: => 
NodeHªdË
[
D
,
U
,
E
,
B
,
TLCl›ÁPÜtP¬am‘”s
,
TLMªag”PÜtP¬am‘”s
,
TLEdgeOut
,
TLBundË
] =

152 
TLNameNode
(
Çme
)): 
Inw¬dNodeHªdË
[
D
,
U
,
E
,
B
] = {

153 
äom
("coh”’t_ma¡”" 
Çmed
 
Çme
) {

154 
šw¬dNode
 :=* 
TLBufãr
(
bufãr
è:=* 
TLFIFOFix”
(TLFIFOFix”.
®l
è:=* 
g’


159 
Œa™
 
HasTLXb¬Phy
 { 
this
: 
TLBusW¿µ”
 =>

160 
´iv©e
 
v®
 
xb¬
 = 
LazyModuË
(
Ãw
 
TLXb¬
).
sugge¡Name
(
busName
 + "_xbar")

162 
def
 
šw¬dNode
: 
TLInw¬dNode
 = 
xb¬
.
node


163 
def
 
outw¬dNode
: 
TLOutw¬dNode
 = 
xb¬
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CacheCork.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

10 
impÜt
 
	gTLMes§ges
.
_


12 
şass
 
	$TLCacheCÜk
(
un§ã
: 
BoŞ—n
 = 
çl£
, 
sškIds
: 
IÁ
 = 8)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
node
 = 
	`TLAd­‹rNode
(

15 
ş›ÁFn
 = { 
ı
 =>

16 
ı
.
	`cİy
(
ş›Ás
 = cp.ş›Ás.
m­
 { 
c
 => c.copy(

17 
suµÜtsProbe
 = 
T¿nsãrSizes
.
nÚe
,

18 
sourûId
 = 
	`IdRªge
(
c
.sourûId.
¡¬t
*2, c.sourûId.
’d
*2))})},

19 
mªag”Fn
 = { 
mp
 =>

20 
mp
.
	`cİy
(

21 
’dSškId
 = ià(
mp
.
mªag”s
.
	`exi¡s
(
_
.
»giÚTy³
 =ğ
RegiÚTy³
.
UNCACHED
)è
sškIds
 0,

22 
mªag”s
 = 
mp
.mªag”s.
m­
 { 
m
 => m.
	`cİy
(

23 
suµÜtsAcquœeB
 = ià(
m
.
»giÚTy³
 =ğ
RegiÚTy³
.
UNCACHED
èm.
suµÜtsG‘
 m.supportsAcquireB,

24 
suµÜtsAcquœeT
 = ià(
m
.
»giÚTy³
 =ğ
RegiÚTy³
.
UNCACHED
èm.
suµÜtsPutFuÎ
 m.supportsAcquireT,

25 
®waysG¿ÁsT
 = ià(
m
.
»giÚTy³
 =ğ
RegiÚTy³
.
UNCACHED
èm.
suµÜtsPutFuÎ
 m.alwaysGrantsT)})})

27 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

28 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

30 ià(!
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
) {

31 
out
 <> 
š


33 
v®
 
ş›Ás
 = 
edgeIn
.
ş›Á
.clients

34 
v®
 
ÿches
 = 
ş›Ás
.
	`f‹r
(
_
.
suµÜtsProbe
)

35 
	`»quœe
 (
ş›Ás
.
size
 =ğ1 || 
ÿches
.siz=ğ0 || 
un§ã
, 
s
"Only one client can safely use‡ TLCacheCork; ${clients.map(_.name)}")

36 
	`»quœe
 (
ÿches
.
size
 <ğ1 || 
un§ã
, 
s
"Only one caching client‡llowed; ${clients.map(_.name)}")

37 
edgeOut
.
mªag”
.
mªag”s
.
fÜ—ch
 { 
m
 =>

38 
	`»quœe
 (!
m
.
suµÜtsAcquœeB
 || 
un§ã
, 
s
"Cannot support caches beyondhe Cork; ${m.name}")

39 
	`»quœe
 (
m
.
»giÚTy³
 <ğ
RegiÚTy³
.
UNCACHED
)

59 
v®
 
a_a
 = 
	`Wœe
(
out
.
a
)

60 
v®
 
a_d
 = 
	`Wœe
(
š
.
d
)

61 
v®
 
isPut
 = 
š
.
a
.
b™s
.
İcode
 ==ğ
PutFuÎD©a
 || in.a.b™s.İcod==ğ
PutP¬tŸlD©a


62 
v®
 
toD
 = (
š
.
a
.
b™s
.
İcode
 ==ğ
AcquœeBlock
 && in.a.b™s.
·¿m
 ==ğ
TLP”missiÚs
.
BtoT
) ||

63 (
š
.
a
.
b™s
.
İcode
 ==ğ
AcquœeP”m
)

64 
š
.
a
.
»ady
 :ğ
	`Mux
(
toD
, 
a_d
.»ady, 
a_a
.ready)

66 
a_a
.
v®id
 :ğ
š
.
a
.v®id && !
toD


67 
a_a
.
b™s
 :ğ
š
.
a
.bits

68 
a_a
.
b™s
.
sourû
 :ğ
š
.
a
.b™s.sourû << 1 | 
	`Mux
(
isPut
, 
	`UIÁ
(1), UInt(0))

71 
	`wh’
 (
š
.
a
.
b™s
.
İcode
 ==ğ
AcquœeBlock
 || in.a.b™s.İcod==ğ
AcquœeP”m
) {

72 
a_a
.
b™s
.
İcode
 :ğ
G‘


73 
a_a
.
b™s
.
·¿m
 :ğ
	`UIÁ
(0)

74 
a_a
.
b™s
.
sourû
 :ğ
š
.
a
.b™s.sourû << 1 | 
	`UIÁ
(1)

78 
a_d
.
v®id
 :ğ
š
.
a
.v®id && 
toD


79 
a_d
.
b™s
 :ğ
edgeIn
.
	`G¿Á
(

80 
äomSšk
 = 
	`UIÁ
(0),

81 
toSourû
 = 
š
.
a
.
b™s
.
sourû
,

82 
lgSize
 = 
š
.
a
.
b™s
.
size
,

83 
ÿpP”missiÚs
 = 
TLP”missiÚs
.
toT
)

86 
v®
 
c_a
 = 
	`Wœe
(
out
.
a
)

87 
c_a
.
v®id
 :ğ
š
.
c
.v®id && in.c.
b™s
.
İcode
 ==ğ
R–—£D©a


88 
c_a
.
b™s
 :ğ
edgeOut
.
	`Put
(

89 
äomSourû
 = 
š
.
c
.
b™s
.
sourû
 << 1,

90 
toAdd»ss
 = 
š
.
c
.
b™s
.
add»ss
,

91 
lgSize
 = 
š
.
c
.
b™s
.
size
,

92 
d©a
 = 
š
.
c
.
b™s
.data,

93 
cÜru±
 = 
š
.
c
.
b™s
.cÜru±).
_2


96 
v®
 
c_d
 = 
	`Wœe
(
š
.
d
)

97 
c_d
.
v®id
 :ğ
š
.
c
.v®id && in.c.
b™s
.
İcode
 ==ğ
R–—£


98 
c_d
.
b™s
 :ğ
edgeIn
.
	`R–—£Ack
(
š
.
c
.bits)

100 
	`as£¹
 (!
š
.
c
.
v®id
 || in.c.
b™s
.
İcode
 ==ğ
R–—£
 || in.c.b™s.İcod==ğ
R–—£D©a
)

101 
š
.
c
.
»ady
 :ğ
	`Mux
(š.c.
b™s
.
İcode
 ==ğ
R–—£
, 
c_d
.»ady, 
c_a
.ready)

104 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

107 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
çl£
)

108 
	`as£¹
 (!
out
.
b
.
v®id
)

111 
v®
 
poŞ
 = 
	`ModuË
(
Ãw
 
	`IDPoŞ
(
sškIds
))

112 
poŞ
.
io
.
ä“
.
v®id
 :ğ
š
.
e
.
	`fœe
()

113 
poŞ
.
io
.
ä“
.
b™s
 :ğ
š
.
e
.b™s.
sšk


115 
v®
 
š_d
 = 
	`Wœe
(
š
.
d
)

116 
v®
 
d_fœ¡
 = 
edgeOut
.
	`fœ¡
(
š_d
)

117 
v®
 
d_g¿Á
 = 
š_d
.
b™s
.
İcode
 ==ğ
G¿ÁD©a
 || in_d.b™s.İcod==ğ
G¿Á


118 
poŞ
.
io
.
®loc
.
»ady
 :ğ
š
.
d
.
	`fœe
(è&& 
d_fœ¡
 && 
d_g¿Á


119 
š
.
d
.
v®id
 :ğ
š_d
.v®id && (
poŞ
.
io
.
®loc
.v®id || !
d_fœ¡
 || !
d_g¿Á
)

120 
š_d
.
»ady
 :ğ
š
.
d
.»ady && (
poŞ
.
io
.
®loc
.
v®id
 || !
d_fœ¡
 || !
d_g¿Á
)

121 
š
.
d
.
b™s
 :ğ
š_d
.bits

122 
š
.
d
.
b™s
.
sšk
 :ğ
poŞ
.
io
.
®loc
.b™ 
hŞdUÆess
 
d_fœ¡


125 
v®
 
d_d
 = 
	`Wœe
(
š
.
d
)

126 
d_d
 <> 
out
.
d


127 
d_d
.
b™s
.
sourû
 :ğ
out
.
d
.bits.source >> 1

131 
v®
 
wSourûVec
 = 
	`Reg
(
	`Vec
(
edgeIn
.
ş›Á
.
’dSourûId
, 
	`BoŞ
()))

132 
v®
 
aWOk
 = 
edgeIn
.
mªag”
.
	`ç¡Prİ”ty
(
š
.
a
.
b™s
.
add»ss
, !
_
.
suµÜtsPutFuÎ
.
nÚe
, (
b
:
BoŞ—n
è=> 
	`BoŞ
(b))

133 
v®
 
dWOk
 = 
	`wSourûVec
(
d_d
.
b™s
.
sourû
)

134 
v®
 
by·ss
 = 
	`BoŞ
(
edgeIn
.
mªag”
.
mšL©’cy
 =ğ0è&& 
š
.
a
.
v®id
 && in.a.
b™s
.
sourû
 ==ğ
d_d
.bits.source

135 
v®
 
dWH–d
 = 
	`Mux
(
by·ss
, 
aWOk
, 
dWOk
è
hŞdUÆess
 
d_fœ¡


137 
	`wh’
 (
š
.
a
.
	`fœe
()) {

138 
	`wSourûVec
(
š
.
a
.
b™s
.
sourû
è:ğ
aWOk


142 
edgeIn
.
ş›Á
.
unu£dSourûs
.
fÜ—ch
 { 
id
 =>

143 
	`wSourûVec
(
id
è:ğ
	`BoŞ
(
edgeIn
.
mªag”
.
ªySuµÜtPutFuÎ
)

146 
	`wh’
 (
out
.
d
.
b™s
.
İcode
 ==ğ
AcûssAckD©a
 && out.d.b™s.
	`sourû
(0)) {

147 
d_d
.
b™s
.
İcode
 :ğ
G¿ÁD©a


148 
d_d
.
b™s
.
·¿m
 :ğ
	`Mux
(
dWH–d
, 
TLP”missiÚs
.
toT
, TLP”missiÚs.
toB
)

150 
	`wh’
 (
out
.
d
.
b™s
.
İcode
 ==ğ
AcûssAck
 && !out.d.b™s.
	`sourû
(0)) {

151 
d_d
.
b™s
.
İcode
 :ğ
R–—£Ack


155 
	`TLArb™”
(
TLArb™”
.
lowe¡IndexFœ¡
)(
out
.
a
, (
edgeOut
.
	`numB—ts1
(
c_a
.
b™s
), c_a), (edgeOut.numB—ts1(
a_a
.bits),‡_a))

156 
	`TLArb™”
(
TLArb™”
.
lowe¡IndexFœ¡
)(
š_d
, (
edgeIn
 .
	`numB—ts1
(
d_d
.
b™s
), d_d), (
	`UIÁ
(0), 
	`Queue
(
c_d
, 2)), (UIÁ(0), Queue(
a_d
, 2)))

159 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

160 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

161 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

165 
	}
}

167 
objeù
 
TLCacheCÜk


169 
def
 
­¶y
(
un§ã
: 
BoŞ—n
 = 
çl£
, 
sškIds
: 
IÁ
 = 8)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

171 
v®
 
cÜk
 = 
LazyModuË
(
Ãw
 
TLCacheCÜk
(
un§ã
, 
sškIds
))

172 
	gcÜk
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CrossingHelper.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
R©iÚ®DœeùiÚ


9 
şass
 
	$TLInw¬dCrossšgH–³r
(
Çme
: 
SŒšg
, 
scİe
: 
LazyScİe
, 
node
: 
TLInw¬dNode
) {

10 
def
 
	`­¶y
(
xšg
: 
ClockCrossšgTy³
 = 
NoCrossšg
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLInw¬dNode
 = {

11 
xšg
 
m©ch
 {

12 
x
: 
AsynchrÚousCrossšg
 =>

13 
node
 :*=* 
scİe
 { 
	`TLAsyncCrossšgSšk
(
x
.
asSškP¬ams
è:*=* 
	`TLAsyncNameNode
(
Çme
è} :*=* TLAsyncNameNodeÒameè:*=* 
	`TLAsyncCrossšgSourû
(x.
sourûSync
)

14 
	`R©iÚ®Crossšg
(
dœeùiÚ
) =>

15 
node
 :*=* 
scİe
 { 
	`TLR©iÚ®CrossšgSšk
(
dœeùiÚ
.
æ
è:*=* 
	`TLR©iÚ®NameNode
(
Çme
è} :*=* TLR©iÚ®NameNodeÒameè:*=* 
	`TLR©iÚ®CrossšgSourû
()

16 
	`SynchrÚousCrossšg
(
bufãr
) =>

17 
node
 :*=* 
scİe
 { 
	`TLBufãr
(
bufãr
è:*=* 
	`TLNameNode
(
Çme
) } :*=* TLNameNode(name)

20 
	}
}

22 
şass
 
	$TLOutw¬dCrossšgH–³r
(
Çme
: 
SŒšg
, 
scİe
: 
LazyScİe
, 
node
: 
TLOutw¬dNode
) {

23 
def
 
	`­¶y
(
xšg
: 
ClockCrossšgTy³
 = 
NoCrossšg
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLOutw¬dNode
 = {

24 
xšg
 
m©ch
 {

25 
x
: 
AsynchrÚousCrossšg
 =>

26 
	`TLAsyncCrossšgSšk
(
x
.
asSškP¬ams
è:*=* 
	`TLAsyncNameNode
(
Çme
è:*=* 
scİe
 { TLAsyncNameNodeÒameè:*=* 
	`TLAsyncCrossšgSourû
(x.
sourûSync
è} :*=* 
node


27 
	`R©iÚ®Crossšg
(
dœeùiÚ
) =>

28 
	`TLR©iÚ®CrossšgSšk
(
dœeùiÚ
è:*=* 
	`TLR©iÚ®NameNode
(
Çme
è:*=* 
scİe
 { TLR©iÚ®NameNodeÒameè:*=* 
	`TLR©iÚ®CrossšgSourû
(è} :*=* 
node


29 
	`SynchrÚousCrossšg
(
bufãr
) =>

30 
	`TLNameNode
(
Çme
è:*=* 
scİe
 { TLNameNodeÒameè:*=* 
	`TLBufãr
(
bufãr
è} :*=* 
node


33 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Delayer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 şas 
	cTLD–ay”
(
q
: 
DoubË
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


12 
v®
 
node
 = 
	$TLAd­‹rNode
()

13 
	`»quœe
 (0.0 <ğ
q
 && q < 1)

15 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

16 
def
 
ãed
[
T
 <: 
D©a
](
sšk
: 
Decou¶edIO
[T], 
sourû
: Decou¶edIO[T], 
noi£
: T) {

17 
v®
 
®low
 = 
	`UIÁ
((
q
 * 65535.0).
toIÁ
è<ğ
	`LFSRNoi£Mak”
(16, 
sourû
.
v®id
)

18 
sšk
.
v®id
 :ğ
sourû
.v®id && 
®low


19 
sourû
.
»ady
 :ğ
sšk
.»ady && 
®low


20 
sšk
.
b™s
 :ğ
sourû
.bits

21 
	`wh’
 (!
sšk
.
v®id
è{ sšk.
b™s
 :ğ
noi£
 }

24 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
_
), (out, _)) =>

25 
v®
 
ªoi£
 = 
	`Wœe
(
š
.
a
.
b™s
)

26 
ªoi£
.
İcode
 :ğ
	`LFSRNoi£Mak”
(3)

27 
ªoi£
.
·¿m
 :ğ
	`LFSRNoi£Mak”
(3)

28 
ªoi£
.
size
 :ğ
	`LFSRNoi£Mak”
×noi£.
·¿ms
.
sizeB™s
)

29 
ªoi£
.
sourû
 :ğ
	`LFSRNoi£Mak”
×noi£.
·¿ms
.
sourûB™s
)

30 
ªoi£
.
add»ss
 :ğ
	`LFSRNoi£Mak”
×noi£.
·¿ms
.
add»ssB™s
)

31 
ªoi£
.
mask
 :ğ
	`LFSRNoi£Mak”
×noi£.
·¿ms
.
d©aB™s
/8)

32 
ªoi£
.
d©a
 :ğ
	`LFSRNoi£Mak”
×noi£.
·¿ms
.
d©aB™s
)

34 
v®
 
bnoi£
 = 
	`Wœe
(
out
.
b
.
b™s
)

35 
bnoi£
.
İcode
 :ğ
	`LFSRNoi£Mak”
(3)

36 
bnoi£
.
·¿m
 :ğ
	`LFSRNoi£Mak”
(3)

37 
bnoi£
.
size
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
sizeB™s
)

38 
bnoi£
.
sourû
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
sourûB™s
)

39 
bnoi£
.
add»ss
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
add»ssB™s
)

40 
bnoi£
.
mask
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
d©aB™s
/8)

41 
bnoi£
.
d©a
 :ğ
	`LFSRNoi£Mak”
(bnoi£.
·¿ms
.
d©aB™s
)

43 
v®
 
úoi£
 = 
	`Wœe
(
š
.
c
.
b™s
)

44 
úoi£
.
İcode
 :ğ
	`LFSRNoi£Mak”
(3)

45 
úoi£
.
·¿m
 :ğ
	`LFSRNoi£Mak”
(3)

46 
úoi£
.
size
 :ğ
	`LFSRNoi£Mak”
(úoi£.
·¿ms
.
sizeB™s
)

47 
úoi£
.
sourû
 :ğ
	`LFSRNoi£Mak”
(úoi£.
·¿ms
.
sourûB™s
)

48 
úoi£
.
add»ss
 :ğ
	`LFSRNoi£Mak”
(úoi£.
·¿ms
.
add»ssB™s
)

49 
úoi£
.
d©a
 :ğ
	`LFSRNoi£Mak”
(úoi£.
·¿ms
.
d©aB™s
)

50 
úoi£
.
cÜru±
 :ğ
	`LFSRNoi£Mak”
(1)(0)

52 
v®
 
dnoi£
 = 
	`Wœe
(
out
.
d
.
b™s
)

53 
dnoi£
.
İcode
 :ğ
	`LFSRNoi£Mak”
(3)

54 
dnoi£
.
·¿m
 :ğ
	`LFSRNoi£Mak”
(3)

55 
dnoi£
.
size
 :ğ
	`LFSRNoi£Mak”
(dnoi£.
·¿ms
.
sizeB™s
)

56 
dnoi£
.
sourû
 :ğ
	`LFSRNoi£Mak”
(dnoi£.
·¿ms
.
sourûB™s
)

57 
dnoi£
.
sšk
 :ğ
	`LFSRNoi£Mak”
(dnoi£.
·¿ms
.
sškB™s
)

58 
dnoi£
.
d’›d
 :ğ
	`LFSRNoi£Mak”
(1)(0)

59 
dnoi£
.
d©a
 :ğ
	`LFSRNoi£Mak”
(dnoi£.
·¿ms
.
d©aB™s
)

60 
dnoi£
.
cÜru±
 :ğ
	`LFSRNoi£Mak”
(1)(0)

62 
v®
 
’oi£
 = 
	`Wœe
(
š
.
e
.
b™s
)

63 
’oi£
.
sšk
 :ğ
	`LFSRNoi£Mak”
Ónoi£.
·¿ms
.
sškB™s
)

65 
	`ãed
(
out
.
a
, 
š
.a, 
ªoi£
)

66 
	`ãed
(
out
.
c
, 
š
.c, 
úoi£
)

67 
	`ãed
(
out
.
e
, 
š
.e, 
’oi£
)

68 
	`ãed
(
š
.
b
, 
out
.b, 
bnoi£
)

69 
	`ãed
(
š
.
d
, 
out
.d, 
dnoi£
)

72 
	}
}

74 
objeù
 
	gTLD–ay”


76 
def
 
­¶y
(
q
: 
DoubË
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

78 
v®
 
d–ay”
 = 
LazyModuË
(
Ãw
 
TLD–ay”
(
q
))

79 
d–ay”
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Edges.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
şass
 
	$TLEdge
(

12 
ş›Á
: 
TLCl›ÁPÜtP¬am‘”s
,

13 
mªag”
: 
TLMªag”PÜtP¬am‘”s
,

14 
·¿ms
: 
P¬am‘”s
,

15 
sourûInfo
: 
SourûInfo
)

16 
ex‹nds
 
	$TLEdgeP¬am‘”s
(
ş›Á
, 
mªag”
, 
·¿ms
, 
sourûInfo
)

18 
def
 
	`isAligÃd
(
add»ss
: 
UIÁ
, 
lgSize
: UIÁ): 
BoŞ
 = {

19 ià(
maxLgSize
 =ğ0è
	`BoŞ
(
Œue
) {

20 
v®
 
mask
 = 
	`UIÁToOH1
(
lgSize
, 
maxLgSize
)

21 (
add»ss
 & 
mask
è==ğ
	`UIÁ
(0)

25 
def
 
	`mask
(
add»ss
: 
UIÁ
, 
lgSize
: UInt): UInt =

26 
	`MaskG’
(
add»ss
, 
lgSize
, 
mªag”
.
b—tBy‹s
)

28 
def
 
	`¡©icHasD©a
(
bundË
: 
TLChªÃl
): 
O±iÚ
[
BoŞ—n
] = {

29 
bundË
 
m©ch
 {

30 
_
:
TLBundËA
 => {

32 
v®
 
aD©aYes
 = 
mªag”
.
ªySuµÜtAr™hm‘ic
 || mªag”.
ªySuµÜtLogiÿl
 || mªag”.
ªySuµÜtPutFuÎ
 || mªag”.
ªySuµÜtPutP¬tŸl


34 
v®
 
aD©aNo
 = 
mªag”
.
ªySuµÜtAcquœeB
 || mªag”.
ªySuµÜtG‘
 || mªag”.
ªySuµÜtHšt


36 ià(!
aD©aYes
è
	`Some
(
çl£
èià(!
aD©aNo
èSome(
Œue
è
NÚe


38 
_
:
TLBundËB
 => {

40 
v®
 
bD©aYes
 = 
ş›Á
.
ªySuµÜtAr™hm‘ic
 || cl›Á.
ªySuµÜtLogiÿl
 || cl›Á.
ªySuµÜtPutFuÎ
 || cl›Á.
ªySuµÜtPutP¬tŸl


42 
v®
 
bD©aNo
 = 
ş›Á
.
ªySuµÜtProbe
 || cl›Á.
ªySuµÜtG‘
 || cl›Á.
ªySuµÜtHšt


44 ià(!
bD©aYes
è
	`Some
(
çl£
èià(!
bD©aNo
èSome(
Œue
è
NÚe


46 
_
:
TLBundËC
 => {

48 
v®
 
cD©aYes
 = 
ş›Á
.
ªySuµÜtG‘
 || cl›Á.
ªySuµÜtAr™hm‘ic
 || cl›Á.
ªySuµÜtLogiÿl
 || cl›Á.
ªySuµÜtProbe


50 
v®
 
cD©aNo
 = 
ş›Á
.
ªySuµÜtPutFuÎ
 || cl›Á.
ªySuµÜtPutP¬tŸl
 || cl›Á.
ªySuµÜtHšt
 || cl›Á.
ªySuµÜtProbe


51 ià(!
cD©aYes
è
	`Some
(
çl£
èià(!
cD©aNo
èSome(
Œue
è
NÚe


53 
_
:
TLBundËD
 => {

55 
v®
 
dD©aYes
 = 
mªag”
.
ªySuµÜtG‘
 || mªag”.
ªySuµÜtAr™hm‘ic
 || mªag”.
ªySuµÜtLogiÿl
 || mªag”.
ªySuµÜtAcquœeB


57 
v®
 
dD©aNo
 = 
mªag”
.
ªySuµÜtPutFuÎ
 || mªag”.
ªySuµÜtPutP¬tŸl
 || mªag”.
ªySuµÜtHšt
 || mªag”.
ªySuµÜtAcquœeT


58 ià(!
dD©aYes
è
	`Some
(
çl£
èià(!
dD©aNo
èSome(
Œue
è
NÚe


60 
_
:
TLBundËE
 => 
	`Some
(
çl£
)

64 
def
 
	`isReque¡
(
x
: 
TLChªÃl
): 
BoŞ
 = {

65 
x
 
m©ch
 {

66 
a
: 
TLBundËA
 => 
	`BoŞ
(
Œue
)

67 
b
: 
TLBundËB
 => 
	`BoŞ
(
Œue
)

68 
c
: 
TLBundËC
 => c.
	`İcode
(2) && c.opcode(1)

71 
d
: 
TLBundËD
 => d.
	`İcode
(2) && !d.opcode(1)

74 
e
: 
TLBundËE
 => 
	`BoŞ
(
çl£
)

78 
def
 
	`isRe¥Ú£
(
x
: 
TLChªÃl
): 
BoŞ
 = {

79 
x
 
m©ch
 {

80 
a
: 
TLBundËA
 => 
	`BoŞ
(
çl£
)

81 
b
: 
TLBundËB
 => 
	`BoŞ
(
çl£
)

82 
c
: 
TLBundËC
 => !c.
	`İcode
(2) || !c.opcode(1)

85 
d
: 
TLBundËD
 => 
	`BoŞ
(
Œue
)

86 
e
: 
TLBundËE
 => 
	`BoŞ
(
Œue
)

90 
def
 
	`hasD©a
(
x
: 
TLChªÃl
): 
BoŞ
 = {

91 
v®
 
İd©a
 = 
x
 
m©ch
 {

92 
a
: 
TLBundËA
 => !a.
	`İcode
(2)

97 
b
: 
TLBundËB
 => !b.
	`İcode
(2)

102 
c
: 
TLBundËC
 => c.
	`İcode
(0)

106 
d
: 
TLBundËD
 => d.
	`İcode
(0)

109 
e
: 
TLBundËE
 => 
	`BoŞ
(
çl£
)

111 
	`¡©icHasD©a
(
x
).
	`m­
(
	`BoŞ
(
_
)).
	`g‘OrEl£
(
İd©a
)

114 
def
 
	`İcode
(
x
: 
TLD©aChªÃl
): 
UIÁ
 = {

115 
x
 
m©ch
 {

116 
a
: 
TLBundËA
 =>‡.
İcode


117 
b
: 
TLBundËB
 => b.
İcode


118 
c
: 
TLBundËC
 => c.
İcode


119 
d
: 
TLBundËD
 => d.
İcode


123 
def
 
	`·¿m
(
x
: 
TLD©aChªÃl
): 
UIÁ
 = {

124 
x
 
m©ch
 {

125 
a
: 
TLBundËA
 =>‡.
·¿m


126 
b
: 
TLBundËB
 => b.
·¿m


127 
c
: 
TLBundËC
 => c.
·¿m


128 
d
: 
TLBundËD
 => d.
·¿m


132 
def
 
	`size
(
x
: 
TLD©aChªÃl
): 
UIÁ
 = {

133 
x
 
m©ch
 {

134 
a
: 
TLBundËA
 =>‡.
size


135 
b
: 
TLBundËB
 => b.
size


136 
c
: 
TLBundËC
 => c.
size


137 
d
: 
TLBundËD
 => d.
size


141 
def
 
	`d©a
(
x
: 
TLD©aChªÃl
): 
UIÁ
 = {

142 
x
 
m©ch
 {

143 
a
: 
TLBundËA
 =>‡.
d©a


144 
b
: 
TLBundËB
 => b.
d©a


145 
c
: 
TLBundËC
 => c.
d©a


146 
d
: 
TLBundËD
 => d.
d©a


150 
def
 
	`cÜru±
(
x
: 
TLD©aChªÃl
): 
BoŞ
 = {

151 
x
 
m©ch
 {

152 
a
: 
TLBundËA
 =>‡.
cÜru±


153 
b
: 
TLBundËB
 => b.
cÜru±


154 
c
: 
TLBundËC
 => c.
cÜru±


155 
d
: 
TLBundËD
 => d.
cÜru±


159 
def
 
	`mask
(
x
: 
TLAddrChªÃl
): 
UIÁ
 = {

160 
x
 
m©ch
 {

161 
a
: 
TLBundËA
 =>‡.
mask


162 
b
: 
TLBundËB
 => b.
mask


163 
c
: 
TLBundËC
 => 
	`mask
(c.
add»ss
, c.
size
)

167 
def
 
	`fuÎ_mask
(
x
: 
TLAddrChªÃl
): 
UIÁ
 = {

168 
x
 
m©ch
 {

169 
a
: 
TLBundËA
 => 
	`mask
×.
add»ss
,‡.
size
)

170 
b
: 
TLBundËB
 => 
	`mask
(b.
add»ss
, b.
size
)

171 
c
: 
TLBundËC
 => 
	`mask
(c.
add»ss
, c.
size
)

175 
def
 
	`add»ss
(
x
: 
TLAddrChªÃl
): 
UIÁ
 = {

176 
x
 
m©ch
 {

177 
a
: 
TLBundËA
 =>‡.
add»ss


178 
b
: 
TLBundËB
 => b.
add»ss


179 
c
: 
TLBundËC
 => c.
add»ss


183 
def
 
	`sourû
(
x
: 
TLD©aChªÃl
): 
UIÁ
 = {

184 
x
 
m©ch
 {

185 
a
: 
TLBundËA
 =>‡.
sourû


186 
b
: 
TLBundËB
 => b.
sourû


187 
c
: 
TLBundËC
 => c.
sourû


188 
d
: 
TLBundËD
 => d.
sourû


192 
def
 
	`addr_hi
(
x
: 
UIÁ
): UIÁ = x >> 
	`log2Ce
(
mªag”
.
b—tBy‹s
)

193 
def
 
	`addr_lo
(
x
: 
UIÁ
): UInt =

194 ià(
mªag”
.
b—tBy‹s
 =ğ1è
	`UIÁ
(0è
	`x
(
	`log2Ce
(manager.beatBytes)-1, 0)

196 
def
 
	`addr_hi
(
x
: 
TLAddrChªÃl
): 
UIÁ
 =‡ddr_hi(
	`add»ss
(x))

197 
def
 
	`addr_lo
(
x
: 
TLAddrChªÃl
): 
UIÁ
 =‡ddr_lo(
	`add»ss
(x))

199 
def
 
	`numB—ts
(
x
: 
TLChªÃl
): 
UIÁ
 = {

200 
x
 
m©ch
 {

201 
_
: 
TLBundËE
 => 
	`UIÁ
(1)

202 
bundË
: 
TLD©aChªÃl
 => {

203 
v®
 
hasD©a
 = 
this
.
	`hasD©a
(
bundË
)

204 
v®
 
size
 = 
this
.
	`size
(
bundË
)

205 
v®
 
cutoff
 = 
	`log2Ce
(
mªag”
.
b—tBy‹s
)

206 
v®
 
sm®l
 = ià(
mªag”
.
maxT¿nsãr
 <ğmªag”.
b—tBy‹s
è
	`BoŞ
(
Œue
è
size
 <ğ
	`UIÁ
(
cutoff
)

207 
v®
 
decode
 = 
	`UIÁToOH
(
size
, 
maxLgSize
+1è>> 
cutoff


208 
	`Mux
(
hasD©a
, 
decode
 | 
sm®l
.
asUIÁ
, 
	`UIÁ
(1))

213 
def
 
	`numB—ts1
(
x
: 
TLChªÃl
): 
UIÁ
 = {

214 
x
 
m©ch
 {

215 
_
: 
TLBundËE
 => 
	`UIÁ
(0)

216 
bundË
: 
TLD©aChªÃl
 => {

217 ià(
maxLgSize
 == 0) {

218 
	`UIÁ
(0)

220 
v®
 
decode
 = 
	`UIÁToOH1
(
	`size
(
bundË
), 
maxLgSize
è>> 
	`log2Ce
(
mªag”
.
b—tBy‹s
)

221 
	`Mux
(
	`hasD©a
(
bundË
), 
decode
, 
	`UIÁ
(0))

227 
def
 
	`fœ¡Ï¡H–³r
(
b™s
: 
TLChªÃl
, 
fœe
: 
BoŞ
): (BoŞ, BoŞ, BoŞ, 
UIÁ
) = {

228 
v®
 
b—ts1
 = 
	`numB—ts1
(
b™s
)

229 
v®
 
couÁ”
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
	`log2Up
(
maxT¿nsãr
 / 
mªag”
.
b—tBy‹s
)))

230 
v®
 
couÁ”1
 = 
couÁ”
 - 
	`UIÁ
(1)

231 
v®
 
fœ¡
 = 
couÁ”
 ==ğ
	`UIÁ
(0)

232 
v®
 
Ï¡
 = 
couÁ”
 ==ğ
	`UIÁ
(1è|| 
b—ts1
 === UInt(0)

233 
v®
 
dÚe
 = 
Ï¡
 && 
fœe


234 
v®
 
couÁ
 = (
b—ts1
 & ~
couÁ”1
)

235 
	`wh’
 (
fœe
) {

236 
couÁ”
 :ğ
	`Mux
(
fœ¡
, 
b—ts1
, 
couÁ”1
)

238 (
fœ¡
, 
Ï¡
, 
dÚe
, 
couÁ
)

241 
def
 
	`fœ¡
(
b™s
: 
TLChªÃl
, 
fœe
: 
BoŞ
): BoŞ = 
	`fœ¡Ï¡H–³r
(b™s, fœe).
_1


242 
def
 
	`fœ¡
(
x
: 
Decou¶edIO
[
TLChªÃl
]): 
BoŞ
 = fœ¡(x.
b™s
, x.
	`fœe
())

243 
def
 
	`fœ¡
(
x
: 
V®idIO
[
TLChªÃl
]): 
BoŞ
 = fœ¡(x.
b™s
, x.
v®id
)

245 
def
 
	`Ï¡
(
b™s
: 
TLChªÃl
, 
fœe
: 
BoŞ
): BoŞ = 
	`fœ¡Ï¡H–³r
(b™s, fœe).
_2


246 
def
 
	`Ï¡
(
x
: 
Decou¶edIO
[
TLChªÃl
]): 
BoŞ
 =†a¡(x.
b™s
, x.
	`fœe
())

247 
def
 
	`Ï¡
(
x
: 
V®idIO
[
TLChªÃl
]): 
BoŞ
 =†a¡(x.
b™s
, x.
v®id
)

249 
def
 
	`dÚe
(
b™s
: 
TLChªÃl
, 
fœe
: 
BoŞ
): BoŞ = 
	`fœ¡Ï¡H–³r
(b™s, fœe).
_3


250 
def
 
	`dÚe
(
x
: 
Decou¶edIO
[
TLChªÃl
]): 
BoŞ
 = dÚe(x.
b™s
, x.
	`fœe
())

251 
def
 
	`dÚe
(
x
: 
V®idIO
[
TLChªÃl
]): 
BoŞ
 = dÚe(x.
b™s
, x.
v®id
)

253 
def
 
	`fœ¡Ï¡
(
b™s
: 
TLChªÃl
, 
fœe
: 
BoŞ
): (Bool, Bool, Bool) = {

254 
v®
 
r
 = 
	`fœ¡Ï¡H–³r
(
b™s
, 
fœe
)

255 (
r
.
_1
,„.
_2
,„.
_3
)

257 
def
 
	`fœ¡Ï¡
(
x
: 
Decou¶edIO
[
TLChªÃl
]): (
BoŞ
, BoŞ, BoŞèğfœ¡Ï¡(x.
b™s
, x.
	`fœe
())

258 
def
 
	`fœ¡Ï¡
(
x
: 
V®idIO
[
TLChªÃl
]): (
BoŞ
, BoŞ, BoŞèğfœ¡Ï¡(x.
b™s
, x.
v®id
)

260 
def
 
	`couÁ
(
b™s
: 
TLChªÃl
, 
fœe
: 
BoŞ
): (BoŞ, BoŞ, BoŞ, 
UIÁ
) = {

261 
v®
 
r
 = 
	`fœ¡Ï¡H–³r
(
b™s
, 
fœe
)

262 (
r
.
_1
,„.
_2
,„.
_3
,„.
_4
)

264 
def
 
	`couÁ
(
x
: 
Decou¶edIO
[
TLChªÃl
]): (
BoŞ
, BoŞ, BoŞ, 
UIÁ
èğcouÁ(x.
b™s
, x.
	`fœe
())

265 
def
 
	`couÁ
(
x
: 
V®idIO
[
TLChªÃl
]): (
BoŞ
, BoŞ, BoŞ, 
UIÁ
èğcouÁ(x.
b™s
, x.
v®id
)

267 
def
 
	`addr_šc
(
b™s
: 
TLChªÃl
, 
fœe
: 
BoŞ
): (BoŞ, BoŞ, BoŞ, 
UIÁ
) = {

268 
v®
 
r
 = 
	`fœ¡Ï¡H–³r
(
b™s
, 
fœe
)

269 (
r
.
_1
,„.
_2
,„.
_3
,„.
_4
 << 
	`log2Ce
(
mªag”
.
b—tBy‹s
))

271 
def
 
	`addr_šc
(
x
: 
Decou¶edIO
[
TLChªÃl
]): (
BoŞ
, BoŞ, BoŞ, 
UIÁ
èğaddr_šc(x.
b™s
, x.
	`fœe
())

272 
def
 
	`addr_šc
(
x
: 
V®idIO
[
TLChªÃl
]): (
BoŞ
, BoŞ, BoŞ, 
UIÁ
èğaddr_šc(x.
b™s
, x.
v®id
)

275 
def
 
	`šFlight
(
x
: 
TLBundË
): (
UIÁ
, UInt) = {

276 
v®
 
æight
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
	`log2Ce
(3*
ş›Á
.
’dSourûId
+1)))

277 
v®
 
bû
 = 
mªag”
.
ªySuµÜtAcquœeB
 && 
ş›Á
.
ªySuµÜtProbe


279 
	`v®
 (
a_fœ¡
, 
a_Ï¡
, 
_
èğ
	`fœ¡Ï¡
(
x
.
a
)

280 
	`v®
 (
b_fœ¡
, 
b_Ï¡
, 
_
èğ
	`fœ¡Ï¡
(
x
.
b
)

281 
	`v®
 (
c_fœ¡
, 
c_Ï¡
, 
_
èğ
	`fœ¡Ï¡
(
x
.
c
)

282 
	`v®
 (
d_fœ¡
, 
d_Ï¡
, 
_
èğ
	`fœ¡Ï¡
(
x
.
d
)

283 
	`v®
 (
e_fœ¡
, 
e_Ï¡
, 
_
èğ
	`fœ¡Ï¡
(
x
.
e
)

285 
	`v®
 (
a_»que¡
, 
a_»¥Ú£
èğ(
	`isReque¡
(
x
.
a
.
b™s
), 
	`isRe¥Ú£
(x.a.bits))

286 
	`v®
 (
b_»que¡
, 
b_»¥Ú£
èğ(
	`isReque¡
(
x
.
b
.
b™s
), 
	`isRe¥Ú£
(x.b.bits))

287 
	`v®
 (
c_»que¡
, 
c_»¥Ú£
èğ(
	`isReque¡
(
x
.
c
.
b™s
), 
	`isRe¥Ú£
(x.c.bits))

288 
	`v®
 (
d_»que¡
, 
d_»¥Ú£
èğ(
	`isReque¡
(
x
.
d
.
b™s
), 
	`isRe¥Ú£
(x.d.bits))

289 
	`v®
 (
e_»que¡
, 
e_»¥Ú£
èğ(
	`isReque¡
(
x
.
e
.
b™s
), 
	`isRe¥Ú£
(x.e.bits))

291 
v®
 
a_šc
 = 
x
.
a
.
	`fœe
(è&& 
a_fœ¡
 && 
a_»que¡


292 
v®
 
b_šc
 = 
x
.
b
.
	`fœe
(è&& 
b_fœ¡
 && 
b_»que¡


293 
v®
 
c_šc
 = 
x
.
c
.
	`fœe
(è&& 
c_fœ¡
 && 
c_»que¡


294 
v®
 
d_šc
 = 
x
.
d
.
	`fœe
(è&& 
d_fœ¡
 && 
d_»que¡


295 
v®
 
e_šc
 = 
x
.
e
.
	`fœe
(è&& 
e_fœ¡
 && 
e_»que¡


296 
v®
 
šc
 = 
	`C©
(
	`Seq
(
a_šc
, 
d_šc
è++ (ià(
bû
èSeq(
b_šc
, 
c_šc
, 
e_šc
è
N
))

298 
v®
 
a_dec
 = 
x
.
a
.
	`fœe
(è&& 
a_Ï¡
 && 
a_»¥Ú£


299 
v®
 
b_dec
 = 
x
.
b
.
	`fœe
(è&& 
b_Ï¡
 && 
b_»¥Ú£


300 
v®
 
c_dec
 = 
x
.
c
.
	`fœe
(è&& 
c_Ï¡
 && 
c_»¥Ú£


301 
v®
 
d_dec
 = 
x
.
d
.
	`fœe
(è&& 
d_Ï¡
 && 
d_»¥Ú£


302 
v®
 
e_dec
 = 
x
.
e
.
	`fœe
(è&& 
e_Ï¡
 && 
e_»¥Ú£


303 
v®
 
dec
 = 
	`C©
(
	`Seq
(
a_dec
, 
d_dec
è++ (ià(
bû
èSeq(
b_dec
, 
c_dec
, 
e_dec
è
N
))

305 
v®
 
Ãxt_æight
 = 
æight
 + 
	`PİCouÁ
(
šc
è- PİCouÁ(
dec
)

306 
æight
 :ğ
Ãxt_æight


308 (
æight
, 
Ãxt_æight
)

310 
	}
}

312 
şass
 
	$TLEdgeOut
(

313 
ş›Á
: 
TLCl›ÁPÜtP¬am‘”s
,

314 
mªag”
: 
TLMªag”PÜtP¬am‘”s
,

315 
·¿ms
: 
P¬am‘”s
,

316 
sourûInfo
: 
SourûInfo
)

317 
ex‹nds
 
	$TLEdge
(
ş›Á
, 
mªag”
, 
·¿ms
, 
sourûInfo
)

320 
def
 
	`AcquœeBlock
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
growP”missiÚs
: UInt) = {

321 
	`»quœe
 (
mªag”
.
ªySuµÜtAcquœeB
)

322 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsAcquœeBFa¡
(
toAdd»ss
, 
lgSize
)

323 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

324 
a
.
İcode
 :ğ
TLMes§ges
.
AcquœeBlock


325 
a
.
·¿m
 :ğ
growP”missiÚs


326 
a
.
size
 :ğ
lgSize


327 
a
.
sourû
 :ğ
äomSourû


328 
a
.
add»ss
 :ğ
toAdd»ss


329 
a
.
mask
 :ğ
	`mask
(
toAdd»ss
, 
lgSize
)

330 
a
.
d©a
 :ğ
	`UIÁ
(0)

331 
a
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

332 (
Ëg®
, 
a
)

335 
def
 
	`AcquœeP”m
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
growP”missiÚs
: UInt) = {

336 
	`»quœe
 (
mªag”
.
ªySuµÜtAcquœeB
)

337 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsAcquœeBFa¡
(
toAdd»ss
, 
lgSize
)

338 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

339 
a
.
İcode
 :ğ
TLMes§ges
.
AcquœeP”m


340 
a
.
·¿m
 :ğ
growP”missiÚs


341 
a
.
size
 :ğ
lgSize


342 
a
.
sourû
 :ğ
äomSourû


343 
a
.
add»ss
 :ğ
toAdd»ss


344 
a
.
mask
 :ğ
	`mask
(
toAdd»ss
, 
lgSize
)

345 
a
.
d©a
 :ğ
	`UIÁ
(0)

346 
a
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

347 (
Ëg®
, 
a
)

350 
def
 
	`R–—£
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
shrškP”missiÚs
: UIÁ): (
BoŞ
, 
TLBundËC
) = {

351 
	`»quœe
 (
mªag”
.
ªySuµÜtAcquœeB
)

352 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsAcquœeBFa¡
(
toAdd»ss
, 
lgSize
)

353 
v®
 
c
 = 
	`Wœe
(
Ãw
 
	`TLBundËC
(
bundË
))

354 
c
.
İcode
 :ğ
TLMes§ges
.
R–—£


355 
c
.
·¿m
 :ğ
shrškP”missiÚs


356 
c
.
size
 :ğ
lgSize


357 
c
.
sourû
 :ğ
äomSourû


358 
c
.
add»ss
 :ğ
toAdd»ss


359 
c
.
d©a
 :ğ
	`UIÁ
(0)

360 
c
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

361 (
Ëg®
, 
c
)

364 
def
 
	`R–—£
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
shrškP”missiÚs
: UIÁ, 
d©a
: UIÁ, 
cÜru±
: 
BoŞ
): (BoŞ, 
TLBundËC
) = {

365 
	`»quœe
 (
mªag”
.
ªySuµÜtAcquœeB
)

366 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsAcquœeBFa¡
(
toAdd»ss
, 
lgSize
)

367 
v®
 
c
 = 
	`Wœe
(
Ãw
 
	`TLBundËC
(
bundË
))

368 
c
.
İcode
 :ğ
TLMes§ges
.
R–—£D©a


369 
c
.
·¿m
 :ğ
shrškP”missiÚs


370 
c
.
size
 :ğ
lgSize


371 
c
.
sourû
 :ğ
äomSourû


372 
c
.
add»ss
 :ğ
toAdd»ss


373 
c
.
d©a
 := data

374 
c
.
cÜru±
 := corrupt

375 (
Ëg®
, 
c
)

378 
def
 
	`R–—£
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
shrškP”missiÚs
: UIÁ, 
d©a
: UIÁ): (
BoŞ
, 
TLBundËC
) =

379 
	`R–—£
(
äomSourû
, 
toAdd»ss
, 
lgSize
, 
shrškP”missiÚs
, 
d©a
, 
	`BoŞ
(
çl£
))

381 
def
 
	`ProbeAck
(
b
: 
TLBundËB
, 
»pÜtP”missiÚs
: 
UIÁ
): 
TLBundËC
 =

382 
	`ProbeAck
(
b
.
sourû
, b.
add»ss
, b.
size
, 
»pÜtP”missiÚs
)

384 
def
 
	`ProbeAck
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
»pÜtP”missiÚs
: UIÁ): 
TLBundËC
 = {

385 
v®
 
c
 = 
	`Wœe
(
Ãw
 
	`TLBundËC
(
bundË
))

386 
c
.
İcode
 :ğ
TLMes§ges
.
ProbeAck


387 
c
.
·¿m
 :ğ
»pÜtP”missiÚs


388 
c
.
size
 :ğ
lgSize


389 
c
.
sourû
 :ğ
äomSourû


390 
c
.
add»ss
 :ğ
toAdd»ss


391 
c
.
d©a
 :ğ
	`UIÁ
(0)

392 
c
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

393 
c


396 
def
 
	`ProbeAck
(
b
: 
TLBundËB
, 
»pÜtP”missiÚs
: 
UIÁ
, 
d©a
: UIÁ): 
TLBundËC
 =

397 
	`ProbeAck
(
b
.
sourû
, b.
add»ss
, b.
size
, 
»pÜtP”missiÚs
, 
d©a
)

399 
def
 
	`ProbeAck
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
»pÜtP”missiÚs
: UIÁ, 
d©a
: UIÁ, 
cÜru±
: 
BoŞ
): 
TLBundËC
 = {

400 
v®
 
c
 = 
	`Wœe
(
Ãw
 
	`TLBundËC
(
bundË
))

401 
c
.
İcode
 :ğ
TLMes§ges
.
ProbeAckD©a


402 
c
.
·¿m
 :ğ
»pÜtP”missiÚs


403 
c
.
size
 :ğ
lgSize


404 
c
.
sourû
 :ğ
äomSourû


405 
c
.
add»ss
 :ğ
toAdd»ss


406 
c
.
d©a
 := data

407 
c
.
cÜru±
 := corrupt

408 
c


411 
def
 
	`ProbeAck
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
»pÜtP”missiÚs
: UIÁ, 
d©a
: UIÁ): 
TLBundËC
 =

412 
	`ProbeAck
(
äomSourû
, 
toAdd»ss
, 
lgSize
, 
»pÜtP”missiÚs
, 
d©a
, 
	`BoŞ
(
çl£
))

414 
def
 
	`G¿ÁAck
(
d
: 
TLBundËD
): 
TLBundËE
 = G¿ÁAck(d.
sšk
)

415 
def
 
	`G¿ÁAck
(
toSšk
: 
UIÁ
): 
TLBundËE
 = {

416 
v®
 
e
 = 
	`Wœe
(
Ãw
 
	`TLBundËE
(
bundË
))

417 
e
.
sšk
 :ğ
toSšk


418 
e


422 
def
 
	`G‘
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UInt) = {

423 
	`»quœe
 (
mªag”
.
ªySuµÜtG‘
)

424 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsG‘Fa¡
(
toAdd»ss
, 
lgSize
)

425 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

426 
a
.
İcode
 :ğ
TLMes§ges
.
G‘


427 
a
.
·¿m
 :ğ
	`UIÁ
(0)

428 
a
.
size
 :ğ
lgSize


429 
a
.
sourû
 :ğ
äomSourû


430 
a
.
add»ss
 :ğ
toAdd»ss


431 
a
.
mask
 :ğ
	`mask
(
toAdd»ss
, 
lgSize
)

432 
a
.
d©a
 :ğ
	`UIÁ
(0)

433 
a
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

434 (
Ëg®
, 
a
)

437 
def
 
	`Put
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ): (
BoŞ
, 
TLBundËA
) =

438 
	`Put
(
äomSourû
, 
toAdd»ss
, 
lgSize
, 
d©a
, 
	`BoŞ
(
çl£
))

440 
def
 
	`Put
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
cÜru±
: 
BoŞ
): (BoŞ, 
TLBundËA
) = {

441 
	`»quœe
 (
mªag”
.
ªySuµÜtPutFuÎ
)

442 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsPutFuÎFa¡
(
toAdd»ss
, 
lgSize
)

443 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

444 
a
.
İcode
 :ğ
TLMes§ges
.
PutFuÎD©a


445 
a
.
·¿m
 :ğ
	`UIÁ
(0)

446 
a
.
size
 :ğ
lgSize


447 
a
.
sourû
 :ğ
äomSourû


448 
a
.
add»ss
 :ğ
toAdd»ss


449 
a
.
mask
 :ğ
	`mask
(
toAdd»ss
, 
lgSize
)

450 
a
.
d©a
 := data

451 
a
.
cÜru±
 := corrupt

452 (
Ëg®
, 
a
)

455 
def
 
	`Put
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
mask
: UIÁ): (
BoŞ
, 
TLBundËA
) =

456 
	`Put
(
äomSourû
, 
toAdd»ss
, 
lgSize
, 
d©a
, 
mask
, 
	`BoŞ
(
çl£
))

458 
def
 
	`Put
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
mask
: UIÁ, 
cÜru±
: 
BoŞ
): (BoŞ, 
TLBundËA
) = {

459 
	`»quœe
 (
mªag”
.
ªySuµÜtPutP¬tŸl
)

460 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsPutP¬tŸlFa¡
(
toAdd»ss
, 
lgSize
)

461 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

462 
a
.
İcode
 :ğ
TLMes§ges
.
PutP¬tŸlD©a


463 
a
.
·¿m
 :ğ
	`UIÁ
(0)

464 
a
.
size
 :ğ
lgSize


465 
a
.
sourû
 :ğ
äomSourû


466 
a
.
add»ss
 :ğ
toAdd»ss


467 
a
.
mask
 := mask

468 
a
.
d©a
 := data

469 
a
.
cÜru±
 := corrupt

470 (
Ëg®
, 
a
)

473 
def
 
	`Ar™hm‘ic
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
©omic
: UIÁ, 
cÜru±
: 
BoŞ
 = 
	`BoŞ
(
çl£
)): (BoŞ, 
TLBundËA
) = {

474 
	`»quœe
 (
mªag”
.
ªySuµÜtAr™hm‘ic
)

475 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsAr™hm‘icFa¡
(
toAdd»ss
, 
lgSize
)

476 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

477 
a
.
İcode
 :ğ
TLMes§ges
.
Ar™hm‘icD©a


478 
a
.
·¿m
 :ğ
©omic


479 
a
.
size
 :ğ
lgSize


480 
a
.
sourû
 :ğ
äomSourû


481 
a
.
add»ss
 :ğ
toAdd»ss


482 
a
.
mask
 :ğ
	`mask
(
toAdd»ss
, 
lgSize
)

483 
a
.
d©a
 := data

484 
a
.
cÜru±
 := corrupt

485 (
Ëg®
, 
a
)

488 
def
 
	`Logiÿl
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
©omic
: UIÁ, 
cÜru±
: 
BoŞ
 = 
	`BoŞ
(
çl£
)) = {

489 
	`»quœe
 (
mªag”
.
ªySuµÜtLogiÿl
)

490 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsLogiÿlFa¡
(
toAdd»ss
, 
lgSize
)

491 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

492 
a
.
İcode
 :ğ
TLMes§ges
.
LogiÿlD©a


493 
a
.
·¿m
 :ğ
©omic


494 
a
.
size
 :ğ
lgSize


495 
a
.
sourû
 :ğ
äomSourû


496 
a
.
add»ss
 :ğ
toAdd»ss


497 
a
.
mask
 :ğ
	`mask
(
toAdd»ss
, 
lgSize
)

498 
a
.
d©a
 := data

499 
a
.
cÜru±
 := corrupt

500 (
Ëg®
, 
a
)

503 
def
 
	`Hšt
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
·¿m
: UInt) = {

504 
	`»quœe
 (
mªag”
.
ªySuµÜtHšt
)

505 
v®
 
Ëg®
 = 
mªag”
.
	`suµÜtsHštFa¡
(
toAdd»ss
, 
lgSize
)

506 
v®
 
a
 = 
	`Wœe
(
Ãw
 
	`TLBundËA
(
bundË
))

507 
a
.
İcode
 :ğ
TLMes§ges
.
Hšt


508 
a
.
·¿m
 :=…aram

509 
a
.
size
 :ğ
lgSize


510 
a
.
sourû
 :ğ
äomSourû


511 
a
.
add»ss
 :ğ
toAdd»ss


512 
a
.
mask
 :ğ
	`mask
(
toAdd»ss
, 
lgSize
)

513 
a
.
d©a
 :ğ
	`UIÁ
(0)

514 
a
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

515 (
Ëg®
, 
a
)

518 
def
 
	`AcûssAck
(
b
: 
TLBundËB
): 
TLBundËC
 = AcûssAck(b.
sourû
, 
	`add»ss
(b), b.
size
)

519 
def
 
	`AcûssAck
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UInt) = {

520 
v®
 
c
 = 
	`Wœe
(
Ãw
 
	`TLBundËC
(
bundË
))

521 
c
.
İcode
 :ğ
TLMes§ges
.
AcûssAck


522 
c
.
·¿m
 :ğ
	`UIÁ
(0)

523 
c
.
size
 :ğ
lgSize


524 
c
.
sourû
 :ğ
äomSourû


525 
c
.
add»ss
 :ğ
toAdd»ss


526 
c
.
d©a
 :ğ
	`UIÁ
(0)

527 
c
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

528 
c


531 
def
 
	`AcûssAck
(
b
: 
TLBundËB
, 
d©a
: 
UIÁ
): 
TLBundËC
 = AcûssAck(b.
sourû
, 
	`add»ss
(b), b.
size
, data)

532 
def
 
	`AcûssAck
(
b
: 
TLBundËB
, 
d©a
: 
UIÁ
, 
cÜru±
: 
BoŞ
): 
TLBundËC
 = AcûssAck(b.
sourû
, 
	`add»ss
(b), b.
size
, data, corrupt)

533 
def
 
	`AcûssAck
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ): 
TLBundËC
 = AcûssAck(äomSourû,oAdd»ss,†gSize, d©a, 
	`BoŞ
(
çl£
))

534 
def
 
	`AcûssAck
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
cÜru±
: 
BoŞ
) = {

535 
v®
 
c
 = 
	`Wœe
(
Ãw
 
	`TLBundËC
(
bundË
))

536 
c
.
İcode
 :ğ
TLMes§ges
.
AcûssAckD©a


537 
c
.
·¿m
 :ğ
	`UIÁ
(0)

538 
c
.
size
 :ğ
lgSize


539 
c
.
sourû
 :ğ
äomSourû


540 
c
.
add»ss
 :ğ
toAdd»ss


541 
c
.
d©a
 := data

542 
c
.
cÜru±
 := corrupt

543 
c


546 
def
 
	`HštAck
(
b
: 
TLBundËB
): 
TLBundËC
 = HštAck(b.
sourû
, 
	`add»ss
(b), b.
size
)

547 
def
 
	`HštAck
(
äomSourû
: 
UIÁ
, 
toAdd»ss
: UIÁ, 
lgSize
: UInt) = {

548 
v®
 
c
 = 
	`Wœe
(
Ãw
 
	`TLBundËC
(
bundË
))

549 
c
.
İcode
 :ğ
TLMes§ges
.
HštAck


550 
c
.
·¿m
 :ğ
	`UIÁ
(0)

551 
c
.
size
 :ğ
lgSize


552 
c
.
sourû
 :ğ
äomSourû


553 
c
.
add»ss
 :ğ
toAdd»ss


554 
c
.
d©a
 :ğ
	`UIÁ
(0)

555 
c
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

556 
c


558 
	}
}

560 
şass
 
	$TLEdgeIn
(

561 
ş›Á
: 
TLCl›ÁPÜtP¬am‘”s
,

562 
mªag”
: 
TLMªag”PÜtP¬am‘”s
,

563 
·¿ms
: 
P¬am‘”s
,

564 
sourûInfo
: 
SourûInfo
)

565 
ex‹nds
 
	$TLEdge
(
ş›Á
, 
mªag”
, 
·¿ms
, 
sourûInfo
)

568 
def
 
	`Probe
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
ÿpP”missiÚs
: UInt) = {

569 
	`»quœe
 (
ş›Á
.
ªySuµÜtProbe
)

570 
v®
 
Ëg®
 = 
ş›Á
.
	`suµÜtsProbe
(
toSourû
, 
lgSize
)

571 
v®
 
b
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
bundË
))

572 
b
.
İcode
 :ğ
TLMes§ges
.
Probe


573 
b
.
·¿m
 :ğ
ÿpP”missiÚs


574 
b
.
size
 :ğ
lgSize


575 
b
.
sourû
 :ğ
toSourû


576 
b
.
add»ss
 :ğ
äomAdd»ss


577 
b
.
mask
 :ğ
	`mask
(
äomAdd»ss
, 
lgSize
)

578 
b
.
d©a
 :ğ
	`UIÁ
(0)

579 
b
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

580 (
Ëg®
, 
b
)

583 
def
 
	`G¿Á
(
äomSšk
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
ÿpP”missiÚs
: UIÁ): 
TLBundËD
 = G¿Á(äomSšk,oSourû,†gSize, c­P”missiÚs, 
	`BoŞ
(
çl£
))

584 
def
 
	`G¿Á
(
äomSšk
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
ÿpP”missiÚs
: UIÁ, 
d’›d
: 
BoŞ
) = {

585 
v®
 
d
 = 
	`Wœe
(
Ãw
 
	`TLBundËD
(
bundË
))

586 
d
.
İcode
 :ğ
TLMes§ges
.
G¿Á


587 
d
.
·¿m
 :ğ
ÿpP”missiÚs


588 
d
.
size
 :ğ
lgSize


589 
d
.
sourû
 :ğ
toSourû


590 
d
.
sšk
 :ğ
äomSšk


591 
d
.
d’›d
 := denied

592 
d
.
d©a
 :ğ
	`UIÁ
(0)

593 
d
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

594 
d


597 
def
 
	`G¿Á
(
äomSšk
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
ÿpP”missiÚs
: UIÁ, 
d©a
: UIÁ): 
TLBundËD
 = G¿Á(äomSšk,oSourû,†gSize, c­P”missiÚs, d©a, 
	`BoŞ
(
çl£
), Bool(false))

598 
def
 
	`G¿Á
(
äomSšk
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
ÿpP”missiÚs
: UIÁ, 
d©a
: UIÁ, 
d’›d
: 
BoŞ
, 
cÜru±
: Bool) = {

599 
v®
 
d
 = 
	`Wœe
(
Ãw
 
	`TLBundËD
(
bundË
))

600 
d
.
İcode
 :ğ
TLMes§ges
.
G¿ÁD©a


601 
d
.
·¿m
 :ğ
ÿpP”missiÚs


602 
d
.
size
 :ğ
lgSize


603 
d
.
sourû
 :ğ
toSourû


604 
d
.
sšk
 :ğ
äomSšk


605 
d
.
d’›d
 := denied

606 
d
.
d©a
 := data

607 
d
.
cÜru±
 := corrupt

608 
d


611 
def
 
	`R–—£Ack
(
c
: 
TLBundËC
): 
TLBundËD
 = R–—£Ack(c.
sourû
, c.
size
, 
	`BoŞ
(
çl£
))

612 
def
 
	`R–—£Ack
(
toSourû
: 
UIÁ
, 
lgSize
: UIÁ, 
d’›d
: 
BoŞ
): 
TLBundËD
 = {

613 
v®
 
d
 = 
	`Wœe
(
Ãw
 
	`TLBundËD
(
bundË
))

614 
d
.
İcode
 :ğ
TLMes§ges
.
R–—£Ack


615 
d
.
·¿m
 :ğ
	`UIÁ
(0)

616 
d
.
size
 :ğ
lgSize


617 
d
.
sourû
 :ğ
toSourû


618 
d
.
sšk
 :ğ
	`UIÁ
(0)

619 
d
.
d’›d
 := denied

620 
d
.
d©a
 :ğ
	`UIÁ
(0)

621 
d
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

622 
d


626 
def
 
	`G‘
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UInt) = {

627 
	`»quœe
 (
ş›Á
.
ªySuµÜtG‘
)

628 
v®
 
Ëg®
 = 
ş›Á
.
	`suµÜtsG‘
(
toSourû
, 
lgSize
)

629 
v®
 
b
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
bundË
))

630 
b
.
İcode
 :ğ
TLMes§ges
.
G‘


631 
b
.
·¿m
 :ğ
	`UIÁ
(0)

632 
b
.
size
 :ğ
lgSize


633 
b
.
sourû
 :ğ
toSourû


634 
b
.
add»ss
 :ğ
äomAdd»ss


635 
b
.
mask
 :ğ
	`mask
(
äomAdd»ss
, 
lgSize
)

636 
b
.
d©a
 :ğ
	`UIÁ
(0)

637 
b
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

638 (
Ëg®
, 
b
)

641 
def
 
	`Put
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ): (
BoŞ
, 
TLBundËB
) =

642 
	`Put
(
äomAdd»ss
, 
toSourû
, 
lgSize
, 
d©a
, 
	`BoŞ
(
çl£
))

644 
def
 
	`Put
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
cÜru±
: 
BoŞ
): (BoŞ, 
TLBundËB
) = {

645 
	`»quœe
 (
ş›Á
.
ªySuµÜtPutFuÎ
)

646 
v®
 
Ëg®
 = 
ş›Á
.
	`suµÜtsPutFuÎ
(
toSourû
, 
lgSize
)

647 
v®
 
b
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
bundË
))

648 
b
.
İcode
 :ğ
TLMes§ges
.
PutFuÎD©a


649 
b
.
·¿m
 :ğ
	`UIÁ
(0)

650 
b
.
size
 :ğ
lgSize


651 
b
.
sourû
 :ğ
toSourû


652 
b
.
add»ss
 :ğ
äomAdd»ss


653 
b
.
mask
 :ğ
	`mask
(
äomAdd»ss
, 
lgSize
)

654 
b
.
d©a
 := data

655 
b
.
cÜru±
 := corrupt

656 (
Ëg®
, 
b
)

659 
def
 
	`Put
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
mask
: UIÁ): (
BoŞ
, 
TLBundËB
) =

660 
	`Put
(
äomAdd»ss
, 
toSourû
, 
lgSize
, 
d©a
, 
mask
, 
	`BoŞ
(
çl£
))

662 
def
 
	`Put
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
mask
: UIÁ, 
cÜru±
: 
BoŞ
): (BoŞ, 
TLBundËB
) = {

663 
	`»quœe
 (
ş›Á
.
ªySuµÜtPutP¬tŸl
)

664 
v®
 
Ëg®
 = 
ş›Á
.
	`suµÜtsPutP¬tŸl
(
toSourû
, 
lgSize
)

665 
v®
 
b
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
bundË
))

666 
b
.
İcode
 :ğ
TLMes§ges
.
PutP¬tŸlD©a


667 
b
.
·¿m
 :ğ
	`UIÁ
(0)

668 
b
.
size
 :ğ
lgSize


669 
b
.
sourû
 :ğ
toSourû


670 
b
.
add»ss
 :ğ
äomAdd»ss


671 
b
.
mask
 := mask

672 
b
.
d©a
 := data

673 
b
.
cÜru±
 := corrupt

674 (
Ëg®
, 
b
)

677 
def
 
	`Ar™hm‘ic
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
©omic
: UIÁ, 
cÜru±
: 
BoŞ
 = 
	`BoŞ
(
çl£
)) = {

678 
	`»quœe
 (
ş›Á
.
ªySuµÜtAr™hm‘ic
)

679 
v®
 
Ëg®
 = 
ş›Á
.
	`suµÜtsAr™hm‘ic
(
toSourû
, 
lgSize
)

680 
v®
 
b
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
bundË
))

681 
b
.
İcode
 :ğ
TLMes§ges
.
Ar™hm‘icD©a


682 
b
.
·¿m
 :ğ
©omic


683 
b
.
size
 :ğ
lgSize


684 
b
.
sourû
 :ğ
toSourû


685 
b
.
add»ss
 :ğ
äomAdd»ss


686 
b
.
mask
 :ğ
	`mask
(
äomAdd»ss
, 
lgSize
)

687 
b
.
d©a
 := data

688 
b
.
cÜru±
 := corrupt

689 (
Ëg®
, 
b
)

692 
def
 
	`Logiÿl
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
©omic
: UIÁ, 
cÜru±
: 
BoŞ
 = 
	`BoŞ
(
çl£
)) = {

693 
	`»quœe
 (
ş›Á
.
ªySuµÜtLogiÿl
)

694 
v®
 
Ëg®
 = 
ş›Á
.
	`suµÜtsLogiÿl
(
toSourû
, 
lgSize
)

695 
v®
 
b
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
bundË
))

696 
b
.
İcode
 :ğ
TLMes§ges
.
LogiÿlD©a


697 
b
.
·¿m
 :ğ
©omic


698 
b
.
size
 :ğ
lgSize


699 
b
.
sourû
 :ğ
toSourû


700 
b
.
add»ss
 :ğ
äomAdd»ss


701 
b
.
mask
 :ğ
	`mask
(
äomAdd»ss
, 
lgSize
)

702 
b
.
d©a
 := data

703 
b
.
cÜru±
 := corrupt

704 (
Ëg®
, 
b
)

707 
def
 
	`Hšt
(
äomAdd»ss
: 
UIÁ
, 
toSourû
: UIÁ, 
lgSize
: UIÁ, 
·¿m
: UInt) = {

708 
	`»quœe
 (
ş›Á
.
ªySuµÜtHšt
)

709 
v®
 
Ëg®
 = 
ş›Á
.
	`suµÜtsHšt
(
toSourû
, 
lgSize
)

710 
v®
 
b
 = 
	`Wœe
(
Ãw
 
	`TLBundËB
(
bundË
))

711 
b
.
İcode
 :ğ
TLMes§ges
.
Hšt


712 
b
.
·¿m
 :=…aram

713 
b
.
size
 :ğ
lgSize


714 
b
.
sourû
 :ğ
toSourû


715 
b
.
add»ss
 :ğ
äomAdd»ss


716 
b
.
mask
 :ğ
	`mask
(
äomAdd»ss
, 
lgSize
)

717 
b
.
d©a
 :ğ
	`UIÁ
(0)

718 
b
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

719 (
Ëg®
, 
b
)

722 
def
 
	`AcûssAck
(
a
: 
TLBundËA
): 
TLBundËD
 = AcûssAck×.
sourû
,‡.
size
)

723 
def
 
	`AcûssAck
(
a
: 
TLBundËA
, 
d’›d
: 
BoŞ
): 
TLBundËD
 = AcûssAck×.
sourû
,‡.
size
, denied)

724 
def
 
	`AcûssAck
(
toSourû
: 
UIÁ
, 
lgSize
: UIÁ): 
TLBundËD
 = AcûssAckÑoSourû,†gSize, 
	`BoŞ
(
çl£
))

725 
def
 
	`AcûssAck
(
toSourû
: 
UIÁ
, 
lgSize
: UIÁ, 
d’›d
: 
BoŞ
) = {

726 
v®
 
d
 = 
	`Wœe
(
Ãw
 
	`TLBundËD
(
bundË
))

727 
d
.
İcode
 :ğ
TLMes§ges
.
AcûssAck


728 
d
.
·¿m
 :ğ
	`UIÁ
(0)

729 
d
.
size
 :ğ
lgSize


730 
d
.
sourû
 :ğ
toSourû


731 
d
.
sšk
 :ğ
	`UIÁ
(0)

732 
d
.
d’›d
 := denied

733 
d
.
d©a
 :ğ
	`UIÁ
(0)

734 
d
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

735 
d


738 
def
 
	`AcûssAck
(
a
: 
TLBundËA
, 
d©a
: 
UIÁ
): 
TLBundËD
 = AcûssAck×.
sourû
,‡.
size
, data)

739 
def
 
	`AcûssAck
(
a
: 
TLBundËA
, 
d©a
: 
UIÁ
, 
d’›d
: 
BoŞ
, 
cÜru±
: BoŞ): 
TLBundËD
 = AcûssAck×.
sourû
,‡.
size
, data, denied, corrupt)

740 
def
 
	`AcûssAck
(
toSourû
: 
UIÁ
, 
lgSize
: UIÁ, 
d©a
: UIÁ): 
TLBundËD
 = AcûssAckÑoSourû,†gSize, d©a, 
	`BoŞ
(
çl£
), Bool(false))

741 
def
 
	`AcûssAck
(
toSourû
: 
UIÁ
, 
lgSize
: UIÁ, 
d©a
: UIÁ, 
d’›d
: 
BoŞ
, 
cÜru±
: Bool) = {

742 
v®
 
d
 = 
	`Wœe
(
Ãw
 
	`TLBundËD
(
bundË
))

743 
d
.
İcode
 :ğ
TLMes§ges
.
AcûssAckD©a


744 
d
.
·¿m
 :ğ
	`UIÁ
(0)

745 
d
.
size
 :ğ
lgSize


746 
d
.
sourû
 :ğ
toSourû


747 
d
.
sšk
 :ğ
	`UIÁ
(0)

748 
d
.
d’›d
 := denied

749 
d
.
d©a
 := data

750 
d
.
cÜru±
 := corrupt

751 
d


754 
def
 
	`HštAck
(
a
: 
TLBundËA
): 
TLBundËD
 = HštAck×, 
	`BoŞ
(
çl£
))

755 
def
 
	`HštAck
(
a
: 
TLBundËA
, 
d’›d
: 
BoŞ
): 
TLBundËD
 = HštAck×.
sourû
,‡.
size
, denied)

756 
def
 
	`HštAck
(
toSourû
: 
UIÁ
, 
lgSize
: UIÁ): 
TLBundËD
 = HštAckÑoSourû,†gSize, 
	`BoŞ
(
çl£
))

757 
def
 
	`HštAck
(
toSourû
: 
UIÁ
, 
lgSize
: UIÁ, 
d’›d
: 
BoŞ
) = {

758 
v®
 
d
 = 
	`Wœe
(
Ãw
 
	`TLBundËD
(
bundË
))

759 
d
.
İcode
 :ğ
TLMes§ges
.
HštAck


760 
d
.
·¿m
 :ğ
	`UIÁ
(0)

761 
d
.
size
 :ğ
lgSize


762 
d
.
sourû
 :ğ
toSourû


763 
d
.
sšk
 :ğ
	`UIÁ
(0)

764 
d
.
d’›d
 := denied

765 
d
.
d©a
 :ğ
	`UIÁ
(0)

766 
d
.
cÜru±
 :ğ
	`BoŞ
(
çl£
)

767 
d


769 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ErrorEvaluator.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
şass
 
Reque¡P©‹º
(
‹¡
: 
TLBundËA
 => 
BoŞ
)

13 
def
 
­¶y
(
a
: 
TLBundËA
èğ
‹¡
(a)

16 
objeù
 
Reque¡P©‹º


19 
def
 
ov”Ïps
(
·‰”n
: 
Seq
[
Add»ssS‘
])(
a
: 
TLBundËA
) = {

20 
v®
 
amask
 = 
UIÁToOH1
(
a
.
size
,‡.
·¿ms
.
add»ssB™s
)

21 
v®
 
	gaba£
 = 
a
.
add»ss


22 
·‰”n
.
m­
 { 
p
 =>

23 
v®
 
pba£
 = 
UIÁ
(
p
.
ba£
)

24 
v®
 
pmask
 = 
UIÁ
(
p
.
mask
 & ((
BigIÁ
(1è<< 
a
.
·¿ms
.
add»ssB™s
) - 1))

25 (
amask
 | 
pmask
 | ~(
aba£
 ^ 
pba£
)).
ªdR


26 }.
»duû
(
_
 || _)

29 
im¶ic™
 
def
 
­¶y
(
·‰”n
: 
Seq
[
Add»ssS‘
]): 
Reque¡P©‹º
 = 
Ãw
 Reque¡P©‹º(
ov”Ïps
Õ©‹ºè
_
)

37 
şass
 
	$TLE¼ÜEv®u©Ü
(
‹¡
: 
Reque¡P©‹º
, 
‹¡On
: 
BoŞ—n
, 
‹¡Off
: BoŞ—n, 
d’y
: BoŞ—Àğ
çl£
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


39 
v®
 
node
 = 
	`TLAd­‹rNode
(
mªag”Fn
 = { 
mp
 => mp.
	`cİy
(
mªag”s
 =

40 
mp
.
mªag”s
.
m­
 { 
m
 => m.
	`cİy
(
mayD’yPut
 = 
Œue
, 
mayD’yG‘
 = 
d’y
 || m.mayDenyGet) }) })

42 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

43 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

44 
out
 <> 
š


47 
v®
 
šjeù_m­
 = 
	`Mem
(
edgeIn
.
ş›Á
.
’dSourûId
, 
	`BoŞ
())

48 
v®
 
šjeù_now
 = 
	`‹¡
(
š
.
a
.
b™s
)

50 
	`v®
 (
d_fœ¡
, 
d_Ï¡
, 
_
èğ
edgeOut
.
	`fœ¡Ï¡
(
out
.
d
)

51 
v®
 
d_hasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
b™s
)

53 
	`wh’
 (
š
.
a
.
	`fœe
()è{ 
šjeù_m­
.
	`wr™e
(š.a.
b™s
.
sourû
, 
šjeù_now
) }

55 
v®
 
by·ss
 = 
	`BoŞ
(
edgeOut
.
mªag”
.
mšL©’cy
 =ğ0è&& 
š
.
a
.
	`fœe
(è&& in.a.
b™s
.
sourû
 ==ğš.
d
.bits.source

56 
v®
 
d_šjeù
 = 
	`Mux
(
by·ss
, 
šjeù_now
, 
šjeù_m­
.
	`»ad
(
š
.
d
.
b™s
.
sourû
)è
hŞdUÆess
 
d_fœ¡


57 
š
.
d
.
b™s
.
cÜru±
 :ğ
out
.d.b™s.cÜru± || (
d_šjeù
 && 
d_hasD©a
)

58 
š
.
d
.
b™s
.
d’›d
 :ğ
out
.d.b™s.d’›d || (
d_šjeù
 && (!
d_hasD©a
 || 
	`BoŞ
(
d’y
)))

60 
v®
 
r_d‘eù
 = 
	`Reg
(
	`BoŞ
())

61 
v®
 
d_d‘eù
 = (!
d_fœ¡
 && 
r_d‘eù
è|| (
	`BoŞ
(!
d’y
è&& 
out
.
d
.
b™s
.
cÜru±
è|| out.d.b™s.
d’›d


62 
	`wh’
 (
out
.
d
.
	`fœe
()è{ 
r_d‘eù
 :ğ
d_d‘eù
 }

64 
v®
 
d_hšt
 = 
out
.
d
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
HštAck


65 
	`as£¹
 (
	`BoŞ
(!
‹¡On
è|| !
out
.
d
.
	`fœe
(è|| !
d_Ï¡
 || !
d_šjeù
 || 
d_d‘eù
 || 
d_hšt
, "Denied/Corrupt flag was‚ot set!")

66 
	`as£¹
 (
	`BoŞ
(!
‹¡Off
è|| !
out
.
d
.
	`fœe
(è|| !
d_Ï¡
 || 
d_šjeù
 || !
d_d‘eù
, "Denied/Corrupt flag was set!")

69 
	}
}

71 
objeù
 
	gTLE¼ÜEv®u©Ü


73 
def
 
­¶y
(
‹¡
: 
Reque¡P©‹º
, 
‹¡On
: 
BoŞ—n
 = 
çl£
, 
‹¡Off
: BoŞ—Àğçl£, 
d’y
: BoŞ—Àğçl£)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

75 
v®
 
”rÜs
 = 
LazyModuË
(
Ãw
 
TLE¼ÜEv®u©Ü
(
‹¡
, 
‹¡On
, 
‹¡Off
, 
d’y
))

76 
	g”rÜs
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Example.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


9 
şass
 
	$Exam¶eP¬ams
(
num
: 
IÁ
, 
add»ss
: 
BigIÁ
)

11 
Œa™
 
Exam¶eBundË


13 
v®
 
·¿ms
: 
Exam¶eP¬ams


14 
v®
 
gpio
 = 
	`UIÁ
(
width
 = 
·¿ms
.
num
)

15 
	}
}

17 
Œa™
 
Exam¶eModuË
 
ex‹nds
 
HasRegM­


19 
v®
 
·¿ms
: 
Exam¶eP¬ams


20 
v®
 
io
: 
Exam¶eBundË


21 
v®
 
š‹¼u±s
: 
Vec
[
BoŞ
]

23 
v®
 
¡©e
 = 
RegIn™
(
UIÁ
(0, 
width
 = 
·¿ms
.
num
))

24 
v®
 
³ndšg
 = 
RegIn™
(
UIÁ
(0xf, 
width
 = 4))

26 
io
.
gpio
 :ğ
¡©e


27 
š‹¼u±s
 :ğ
³ndšg
.
toBoŞs


29 
»gm­
(

30 0 -> 
Seq
(

31 
RegF›ld
(
·¿ms
.
num
, 
¡©e
,

32 
RegF›ldDesc
("¡©e", "S‹: Exam¶oà¨R/W Regi¡” w™h desütiÚ.", 
»£t
 = 
Some
(0)))),

33 4 -> 
Seq
(

34 
RegF›ld
.
w1ToCË¬
(4, 
³ndšg
, 
¡©e
,

35 
Some
(
RegF›ldDesc
("pending", "Pending: Example of‡ special (W1ToC) Register. " +

38 
»£t
=
Some
(0xF), vŞ©e=
Œue
))))

43 
şass
 
	$TLExam¶e
(
·¿ms
: 
Exam¶eP¬ams
)(
im¶ic™
 
p
: 
P¬am‘”s
)

44 
ex‹nds
 
	`TLRegi¡”Rou‹r
(
·¿ms
.
add»ss
, "somedev", 
	`Seq
("ucbbar,random-interface"), 4)(

45 
Ãw
 
	$TLRegBundË
(
·¿ms
, 
_
è
w™h
 
Exam¶eBundË
)(

46 
Ãw
 
	$TLRegModuË
(
·¿ms
, 
_
, _è
w™h
 
Exam¶eModuË
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/FIFOFixer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
	g´İ”ty
.
_


10 
impÜt
 
	gsÿÏ
.
	gm©h
.
max


12 
şass
 
	$TLFIFOFix”
(
pŞicy
: 
TLFIFOFix”
.
PŞicy
 = TLFIFOFix”.
®l
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
´iv©e
 
def
 
	`fifoM­
(
£q
: 
Seq
[
TLMªag”P¬am‘”s
]) = {

15 
	`v®
 (
æ©Mªag”s
, 
k“pMªag”s
èğ
£q
.
	`·¹™iÚ
(
pŞicy
)

18 
v®
 
æ©Domašs
 = 
	`S‘
(
æ©Mªag”s
.
	`æ©M­
(
_
.
fifoId
):_*)

19 
v®
 
k“pDomašs
 = 
	`S‘
(
k“pMªag”s
.
	`æ©M­
(
_
.
fifoId
):_*è-- 
æ©Domašs


21 
v®
 
æ©M­
 = 
æ©Domašs
.
m­
 { 
x
 => (x, 0è}.
toM­


22 
v®
 
k“pM­
 = 
k“pDomašs
.
	`sÿnLeá
((-1,0)è{ ((
_
,
s
),
x
è=> (x, s+1è}.
toM­


23 
v®
 
m­
 = 
æ©M­
 ++ 
k“pM­


24 
v®
 
fixM­
 = 
£q
.
m­
 { 
m
 => m.
fifoId
 
m©ch
 {

25 
NÚe
 => ià(
	`pŞicy
(
m
)è
	`Some
(0) None

26 
	`Some
(
id
è=> Some(
	`m­
(id))

29 
v®
 
»M­
 = 
æ©Domašs
.
	`sÿnLeá
((-1,-1)è{ ((
_
,
s
),
x
è=> (x, s+1è}.
toM­


30 
v®
 
¥ÏtM­
 = 
£q
.
m­
 { 
m
 => m.
fifoId
 
m©ch
 {

31 
NÚe
 => None

32 
	`Some
(
id
è=> 
»M­
.
	`liá
(id)

34 (
fixM­
, 
¥ÏtM­
)

37 
v®
 
node
 = 
	`TLAd­‹rNode
(

38 
ş›ÁFn
 = { 
ı
 => cp },

39 
mªag”Fn
 = { 
mp
 =>

40 
	`v®
 (
fixM­
, 
_
èğ
	`fifoM­
(
mp
.
mªag”s
)

41 
mp
.
	`cİy
(
mªag”s
 = (
fixM­
 
z
 mp.mªag”sè
m­
 { (
id
, 
m
è=> m.cİy(
fifoId
 = id) })

44 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

45 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

46 
	`v®
 (
fixM­
, 
¥ÏtM­
èğ
	`fifoM­
(
edgeOut
.
mªag”
.
mªag”s
)

49 
v®
 
a_nÙFIFO
 = 
edgeIn
.
mªag”
.
	`ç¡Prİ”ty
(
š
.
a
.
b™s
.
add»ss
, 
_
.
fifoId
 !ğ
	`Some
(0), (
b
:
BoŞ—n
è=> 
	`BoŞ
(b))

51 
v®
 
com·ùed
 = ((
fixM­
 
z
 
¥ÏtM­
èz 
edgeOut
.
mªag”
.
mªag”s
è
æ©M­
 {

52 ((
f
, 
s
), 
m
è=> ià(à=ğ
	`Some
(0)èSome(m.
	`cİy
(
fifoId
 = s)è
NÚe


54 
v®
 
sšks
 = ià(
com·ùed
.
	`exi¡s
(
_
.
suµÜtsAcquœeB
)è
edgeOut
.
mªag”
.
’dSškId
 0

55 
v®
 
a_id
 = ià(
com·ùed
.
isEm±y
è
	`UIÁ
(0) 

56 
edgeOut
.
mªag”
.
	`cİy
(
mªag”s
 = 
com·ùed
, 
’dSškId
 = 
sšks
).
	`fšdFifoIdFa¡
(
š
.
a
.
b™s
.
add»ss
)

57 
v®
 
a_noDomaš
 = 
a_id
 ==ğ
	`UIÁ
(0)

59 ià(
çl£
) {

60 
	`´šn
(
s
"FIFOFixer for: ${edgeIn.client.clients.map(_.name).mkString(", ")}")

61 
	`´šn
(
s
"make FIFO: ${edgeIn.manager.managers.filter(_.fifoId==Some(0)).map(_.name).mkString(", ")}")

62 
	`´šn
(
s
"not FIFO: ${edgeIn.manager.managers.filter(_.fifoId!=Some(0)).map(_.name).mkString(", ")}")

63 
	`´šn
(
s
"domains: ${compacted.groupBy(_.name).mapValues(_.map(_.fifoId))}")

64 
	`´šn
("")

68 
v®
 
a_fœ¡
 = 
edgeIn
.
	`fœ¡
(
š
.
a
)

69 
v®
 
d_fœ¡
 = 
edgeOut
.
	`fœ¡
(
out
.
d
è&& out.d.
b™s
.
İcode
 =/ğ
TLMes§ges
.
R–—£Ack


73 
v®
 
æight
 = 
	`RegIn™
(
Vec
.
	`fl
(
edgeIn
.
ş›Á
.
’dSourûId
è{ 
	`BoŞ
(
çl£
) })

74 
	`wh’
 (
a_fœ¡
 && 
š
.
a
.
	`fœe
()è{ 
	`æight
(š.a.
b™s
.
sourû
è:ğ!
a_nÙFIFO
 }

75 
	`wh’
 (
d_fœ¡
 && 
š
.
d
.
	`fœe
()è{ 
	`æight
(š.d.
b™s
.
sourû
è:ğ
	`BoŞ
(
çl£
) }

77 
v®
 
¡®ls
 = 
edgeIn
.
ş›Á
.
ş›Ás
.
	`f‹r
(
c
 => c.
»que¡Fifo
 && c.
sourûId
.
size
 > 1).
m­
 { c =>

78 
v®
 
a_£l
 = 
c
.
sourûId
.
	`cÚšs
(
š
.
a
.
b™s
.
sourû
)

79 
v®
 
id
 = 
	`RegEÇbË
(
a_id
, 
š
.
a
.
	`fœe
(è&& 
a_£l
 && !
a_nÙFIFO
)

80 
v®
 
Œack
 = 
æight
.
	`¦iû
(
c
.
sourûId
.
¡¬t
, c.sourûId.
’d
)

82 
a_£l
 && 
a_fœ¡
 && 
Œack
.
	`»duû
(
_
 || _è&& (
a_noDomaš
 || 
id
 =/ğ
a_id
)

85 
v®
 
¡®l
 = 
¡®ls
.
	`fŞdLeá
(
	`BoŞ
(
çl£
))(
_
||_)

87 
out
.
a
 <> 
š
.a

88 
š
.
d
 <> 
out
.d

89 
out
.
a
.
v®id
 :ğ
š
.a.v®id && (
a_nÙFIFO
 || !
¡®l
)

90 
š
.
a
.
»ady
 :ğ
out
.a.»ady && (
a_nÙFIFO
 || !
¡®l
)

92 ià(
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeOut.
ş›Á
.
ªySuµÜtProbe
) {

93 
š
 .
b
 <> 
out
.b

94 
out
.
c
 <> 
š
 .c

95 
out
.
e
 <> 
š
 .e

97 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

98 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

99 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

100 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

101 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

102 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

107 
	`cov”
(
š
.
a
.
v®id
 && 
¡®l
, "COVER FIFOFIXER STALL", "Cover: Stall occured for‡ validransaction")

109 
v®
 
SourûIdFIFOed
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
edgeIn
.
ş›Á
.
’dSourûId
))

110 
v®
 
SourûIdS‘
 = 
	`Wœe
(
š™
 = 
	`UIÁ
(0, 
width
 = 
edgeIn
.
ş›Á
.
’dSourûId
))

111 
v®
 
SourûIdCË¬
 = 
	`Wœe
(
š™
 = 
	`UIÁ
(0, 
width
 = 
edgeIn
.
ş›Á
.
’dSourûId
))

113 
	`wh’
 (
a_fœ¡
 && 
š
.
a
.
	`fœe
(è&& !
a_nÙFIFO
) {

114 
SourûIdS‘
 :ğ
	`UIÁToOH
(
š
.
a
.
b™s
.
sourû
)

116 
	`wh’
 (
d_fœ¡
 && 
š
.
d
.
	`fœe
()) {

117 
SourûIdCË¬
 :ğ
	`UIÁToOH
(
š
.
d
.
b™s
.
sourû
)

120 
SourûIdFIFOed
 :ğSourûIdFIFOed | 
SourûIdS‘


121 
v®
 
®lIDs_FIFOed
 = 
SourûIdFIFOed
===
	`Fl
(SourûIdFIFOed.
g‘Width
, 1.U)

123 
	`cov”
(
®lIDs_FIFOed
, "COVER‡ll sources", "Cover: FIFOFIXER covers‡ll Source IDs")

125 
	`cov”
(!(
æight
.
	`»duû
(
_
 || _)), "COVERƒmpty", "Cover: FIFO isƒmpty")

126 
	`cov”
(
SourûIdS‘
 > 0.U, "COVER‡t†east one…ush", "Cover: At†east one Source ID is…ushed")

127 
	`cov”
(
SourûIdCË¬
 > 0.U, "COVER‡t†east one…op", "Cover: At†east one Source ID is…opped")

131 
	}
}

133 
objeù
 
	gTLFIFOFix”


137 
ty³
 
	gPŞicy
 = 
TLMªag”P¬am‘”s
 => 
BoŞ—n


138 
impÜt
 
RegiÚTy³
.
_


140 
v®
 
®l
: 
PŞicy
 = 
m
 => 
Œue


141 
v®
 
®lFIFO
: 
PŞicy
 = 
m
 => m.
fifoId
.
isDefšed


142 
v®
 
®lUnÿch—bË
: 
PŞicy
 = 
m
 => m.
»giÚTy³
 <ğ
UNCACHEABLE


144 
def
 
­¶y
(
pŞicy
: 
PŞicy
 = 
®l
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

146 
v®
 
fix”
 = 
LazyModuË
(
Ãw
 
TLFIFOFix”
(
pŞicy
))

147 
fix”
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Filter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

10 
şass
 
	$TLF‹r
(

11 
mf‹r
: 
TLF‹r
.
Mªag”F‹r
 = TLF‹r.
mId’t™y
,

12 
cf‹r
: 
TLF‹r
.
Cl›ÁF‹r
 = TLF‹r.
cId’t™y


13 )(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


15 
v®
 
node
 = 
	`TLAd­‹rNode
(

16 
ş›ÁFn
 = { 
ı
 => cp.
	`cİy
(
ş›Ás
 = cp.ş›Ás.
æ©M­
 { 
c
 =>

17 
v®
 
out
 = 
	`cf‹r
(
c
)

18 
out
.
m­
 { 
o
 =>

19 
	`»quœe
 (
c
.
sourûId
.
	`cÚšs
(
o
.sourceId))

20 
	`»quœe
 (
c
.
suµÜtsProbe
.
	`cÚšs
(
o
.supportsProbe))

21 
	`»quœe
 (
c
.
suµÜtsAr™hm‘ic
.
	`cÚšs
(
o
.supportsArithmetic))

22 
	`»quœe
 (
c
.
suµÜtsLogiÿl
.
	`cÚšs
(
o
.supportsLogical))

23 
	`»quœe
 (
c
.
suµÜtsG‘
.
	`cÚšs
(
o
.supportsGet))

24 
	`»quœe
 (
c
.
suµÜtsPutFuÎ
.
	`cÚšs
(
o
.supportsPutFull))

25 
	`»quœe
 (
c
.
suµÜtsPutP¬tŸl
.
	`cÚšs
(
o
.supportsPutPartial))

26 
	`»quœe
 (
c
.
suµÜtsHšt
.
	`cÚšs
(
o
.supportsHint))

27 
	`»quœe
 (!
c
.
»que¡Fifo
 || 
o
.requestFifo)

29 
out


31 
mªag”Fn
 = { 
mp
 =>

32 
v®
 
mªag”s
 = 
mp
.mªag”s.
æ©M­
 { 
m
 =>

33 
v®
 
out
 = 
	`mf‹r
(
m
)

34 
out
.
m­
 { 
o
 =>

35 
o
.
add»ss
.
fÜ—ch
 { 
a
 => 
	`»quœe
 (
m
.add»ss.
	`m­
(
_
.
	`cÚšs
×)).
	`»duû
(_||_)) }

36 
	`»quœe
 (
o
.
»giÚTy³
 <ğ
m
.regionType)

38 
	`»quœe
 (
m
.
suµÜtsAcquœeT
.
	`cÚšs
(
o
.supportsAcquireT))

39 
	`»quœe
 (
m
.
suµÜtsAcquœeB
.
	`cÚšs
(
o
.supportsAcquireB))

40 
	`»quœe
 (
m
.
suµÜtsAr™hm‘ic
.
	`cÚšs
(
o
.supportsArithmetic))

41 
	`»quœe
 (
m
.
suµÜtsLogiÿl
.
	`cÚšs
(
o
.supportsLogical))

42 
	`»quœe
 (
m
.
suµÜtsG‘
.
	`cÚšs
(
o
.supportsGet))

43 
	`»quœe
 (
m
.
suµÜtsPutFuÎ
.
	`cÚšs
(
o
.supportsPutFull))

44 
	`»quœe
 (
m
.
suµÜtsPutP¬tŸl
.
	`cÚšs
(
o
.supportsPutPartial))

45 
	`»quœe
 (
m
.
suµÜtsHšt
.
	`cÚšs
(
o
.supportsHint))

46 
	`»quœe
 (!
o
.
fifoId
.
isDefšed
 || 
m
.fifoId == o.fifoId)

48 
out


50 
mp
.
	`cİy
(
mªag”s
 = managers,

51 
’dSškId
 = ià(
mªag”s
.
	`exi¡s
(
_
.
suµÜtsAcquœeB
)è
mp
.endSinkId 0)

54 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

55 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

56 
out
 <> 
š


59 ià(!
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
) {

60 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

61 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

62 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

63 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

64 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

65 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

69 
	}
}

71 
objeù
 
TLF‹r


73 
ty³
 
Mªag”F‹r
 = 
TLMªag”P¬am‘”s
 => 
O±iÚ
[TLManagerParameters]

74 
ty³
 
Cl›ÁF‹r
 = 
TLCl›ÁP¬am‘”s
 => 
O±iÚ
[TLClientParameters]

77 
def
 
mId’t™y
: 
Mªag”F‹r
 = { 
m
 => 
Some
(m) }

79 
def
 
cId’t™y
: 
Cl›ÁF‹r
 = { 
c
 => 
Some
(c) }

81 
def
 
mS–eùIÁ”£ù
(
£Ëù
: 
Add»ssS‘
): 
Mªag”F‹r
 = { 
m
 =>

82 
v®
 
f‹»d
 = 
m
.
add»ss
.
m­
(
_
.
š‹r£ù
(
£Ëù
)).
æ©‹n


83 
v®
 
®ignm’t
 = 
£Ëù
.alignment

84 
v®
 
maxT¿nsãr
 = 1 << 30

85 
v®
 
ÿpT¿nsãr
 = ià(
®ignm’t
 =ğ0 ||‡lignm’ˆ> 
maxT¿nsãr
èmaxT¿nsã¸®ignm’t.
toIÁ


86 
v®
 
ÿp
 = 
T¿nsãrSizes
(1, 
ÿpT¿nsãr
)

87 ià(
	gf‹»d
.
	gisEm±y
è{ 
	gNÚe
 } {

88 
Some
(
m
.
cİy
(

89 
add»ss
 = 
f‹»d
,

90 
suµÜtsAcquœeT
 = 
m
.suµÜtsAcquœeT .
š‹r£ù
(
ÿp
),

91 
suµÜtsAcquœeB
 = 
m
.suµÜtsAcquœeB .
š‹r£ù
(
ÿp
),

92 
suµÜtsAr™hm‘ic
 = 
m
.suµÜtsAr™hm‘ic.
š‹r£ù
(
ÿp
),

93 
suµÜtsLogiÿl
 = 
m
.suµÜtsLogiÿÈ.
š‹r£ù
(
ÿp
),

94 
suµÜtsG‘
 = 
m
.suµÜtsG‘ .
š‹r£ù
(
ÿp
),

95 
suµÜtsPutFuÎ
 = 
m
.suµÜtsPutFuÎ .
š‹r£ù
(
ÿp
),

96 
suµÜtsPutP¬tŸl
 = 
m
.suµÜtsPutP¬tŸl.
š‹r£ù
(
ÿp
),

97 
suµÜtsHšt
 = 
m
.suµÜtsHšˆ.
š‹r£ù
(
ÿp
)))

101 
def
 
mHideCÚšed
(
cÚšedBy
: 
Add»ssS‘
): 
Mªag”F‹r
 = { 
m
 =>

102 
v®
 
f‹»d
 = 
m
.
add»ss
.
f‹rNÙ
(
cÚšedBy
.
cÚšs
(
_
))

103 ià(
f‹»d
.
isEm±y
è
NÚe
 
Some
(
m
.
cİy
(
add»ss
 = filtered))

106 
def
 
mHideCach—bË
: 
Mªag”F‹r
 = { 
m
 =>

107 ià(
m
.
suµÜtsAcquœeB
è
NÚe
 
Some
(m)

110 
def
 
mS–eùCach—bË
: 
Mªag”F‹r
 = { 
m
 =>

111 ià(
m
.
suµÜtsAcquœeB
è
Some
(mè
NÚe


114 
def
 
mMaskCach—bË
: 
Mªag”F‹r
 = { 
m
 =>

115 ià(
m
.
suµÜtsAcquœeB
) {

116 
Some
(
m
.
cİy
(

117 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

118 
suµÜtsAcquœeB
 = 
T¿nsãrSizes
.
nÚe
,

119 
suµÜtsAcquœeT
 = 
T¿nsãrSizes
.
nÚe
,

120 
®waysG¿ÁsT
 = 
çl£
))

121 } { 
Some
(
m
) }

124 
def
 
	gmS–eùAndMaskCach—bË
: 
Mªag”F‹r
 = { 
m
 =>

125 ià(
m
.
suµÜtsAcquœeB
) {

126 
Some
(
m
.
cİy
(

127 
»giÚTy³
 = 
RegiÚTy³
.
UNCACHED
,

128 
suµÜtsAcquœeB
 = 
T¿nsãrSizes
.
nÚe
,

129 
suµÜtsAcquœeT
 = 
T¿nsãrSizes
.
nÚe
,

130 
®waysG¿ÁsT
 = 
çl£
))

131 } { 
	gNÚe
 }

134 
def
 
	gcHideCachšg
: 
Cl›ÁF‹r
 = { 
c
 =>

135 ià(
c
.
suµÜtsProbe
è
NÚe
 
Some
(c)

138 
def
 
cS–eùCachšg
: 
Cl›ÁF‹r
 = { 
c
 =>

139 ià(
c
.
suµÜtsProbe
è
Some
(cè
NÚe


143 
def
 
­¶y
(

144 
mf‹r
: 
Mªag”F‹r
 = 
TLF‹r
.
mId’t™y
,

145 
cf‹r
: 
Cl›ÁF‹r
 = 
TLF‹r
.
cId’t™y


146 )(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

148 
v®
 
f‹r
 = 
LazyModuË
(
Ãw
 
TLF‹r
(
mf‹r
, 
cf‹r
))

149 
	gf‹r
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fragmenter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

11 
objeù
 
	gE¬lyAck
 {

12 
£®ed
 
Œa™
 
T


13 
objeù
 
AÎPuts
 
ex‹nds
 
T


14 
objeù
 
PutFuÎs
 
ex‹nds
 
T


15 
objeù
 
NÚe
 
ex‹nds
 
	gT


26 
şass
 
	$TLF¿gm’‹r
(
v®
 
mšSize
: 
IÁ
, v® 
maxSize
: IÁ, v® 
®waysMš
: 
BoŞ—n
 = 
çl£
, v® 
—¾yAck
: 
E¬lyAck
.
T
 = E¬lyAck.
NÚe
, v® 
hŞdFœ¡D’y
: BoŞ—Àğçl£)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


28 
	`»quœe
(
	`isPow2
 (
maxSize
), 
s
"TLFragmenterƒxpects…ow2(maxSize), but got $maxSize")

29 
	`»quœe
(
	`isPow2
 (
mšSize
), 
s
"TLFragmenterƒxpects…ow2(minSize), but got $minSize")

30 
	`»quœe
(
mšSize
 < 
maxSize
, 
s
"TLFragmenterƒxpects min < max, but got $minSize >= $maxSize")

32 
v®
 
äagm’tB™s
 = 
	`log2Ce
(
maxSize
 / 
mšSize
)

33 
v®
 
fuÎB™s
 = ià(
—¾yAck
 =ğ
E¬lyAck
.
PutFuÎs
) 1 0

34 
v®
 
toggËB™s
 = 1

35 
v®
 
addedB™s
 = 
äagm’tB™s
 + 
toggËB™s
 + 
fuÎB™s


37 
def
 
	`ex·ndT¿nsãr
(
x
: 
T¿nsãrSizes
, 
İ
: 
SŒšg
) = if (!x) x {

39 
	`»quœe
 (
x
.
max
 >ğ
mšSize
, 
s
"TLFragmenter (with…arent $parent) maxransfer size $op(${x.max}) must be >= minransfer size (${minSize})")

40 
	`T¿nsãrSizes
(
x
.
mš
, 
maxSize
)

42 
def
 
	`shrškT¿nsãr
(
x
: 
T¿nsãrSizes
) =

43 ià(!
®waysMš
è
x
 

44 ià(
x
.
mš
 <ğ
mšSize
è
	`T¿nsãrSizes
(x.mš, 
	`mš
(mšSize, x.
max
)) 

45 
T¿nsãrSizes
.
nÚe


46 
def
 
	`m­Mªag”
(
m
: 
TLMªag”P¬am‘”s
èğm.
	`cİy
(

47 
suµÜtsAr™hm‘ic
 = 
	`shrškT¿nsãr
(
m
.supportsArithmetic),

48 
suµÜtsLogiÿl
 = 
	`shrškT¿nsãr
(
m
.supportsLogical),

49 
suµÜtsG‘
 = 
	`ex·ndT¿nsãr
(
m
.supportsGet, "Get"),

50 
suµÜtsPutFuÎ
 = 
	`ex·ndT¿nsãr
(
m
.supportsPutFull, "PutFull"),

51 
suµÜtsPutP¬tŸl
 = 
	`ex·ndT¿nsãr
(
m
.supportsPutPartial, "PutParital"),

52 
suµÜtsHšt
 = 
	`ex·ndT¿nsãr
(
m
.supportsHint, "Hint"))

54 
v®
 
node
 = 
	`TLAd­‹rNode
(

57 
ş›ÁFn
 = { 
c
 => c.
	`cİy
(
ş›Ás
 = 
	`Seq
(
	`TLCl›ÁP¬am‘”s
(

58 
Çme
 = "TLFragmenter",

59 
sourûId
 = 
	`IdRªge
(0, 
c
.
’dSourûId
 << 
addedB™s
),

60 
»que¡Fifo
 = 
Œue
))) },

61 
mªag”Fn
 = { 
m
 => m.
	`cİy
(
mªag”s
 = m.mªag”s.
	`m­
(
m­Mªag”
)) })

63 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

64 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

66 
v®
 
mªag”
 = 
edgeOut
.manager

67 
v®
 
mªag”s
 = 
mªag”
.managers

68 
v®
 
b—tBy‹s
 = 
mªag”
.beatBytes

69 
v®
 
fifoId
 = 
	`mªag”s
(0).fifoId

70 
	`»quœe
 (
fifoId
.
isDefšed
 && 
mªag”s
.
	`m­
(
_
.fifoId =ğfifoId).
	`»duû
(_ && _))

71 
	`»quœe
 (!
mªag”
.
ªySuµÜtAcquœeB
)

73 
	`»quœe
 (
mšSize
 >ğ
b—tBy‹s
, 
s
"TLFragmenter (with…arent $parent) can't support fragmenting ($minSize)o sub-beat ($beatBytes)‡ccesses")

75 
	`»quœe
 (!
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 || !
edgeIn
.
ş›Á
.
ªySuµÜtProbe
)

77 
	`»quœe
 (!
edgeOut
.
mªag”
.
mayD’yG‘
 || 
hŞdFœ¡D’y
, 
s
"TLFragmenter (with…arent $parent) can't support denials without holdFirstDeny=true")

78 
	`»quœe
 (!
edgeOut
.
mªag”
.
mayD’yPut
 || 
—¾yAck
 =ğ
E¬lyAck
.
NÚe
)

145 
v®
 
couÁ”B™s
 = 
	`log2Up
(
maxSize
/
b—tBy‹s
)

146 
v®
 
maxDownSize
 = ià(
®waysMš
è
mšSize
 
	`mš
(
mªag”
.
maxT¿nsãr
, 
maxSize
)

167 
v®
 
acknum
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
couÁ”B™s
))

168 
v®
 
dOrig
 = 
	`Reg
(
	`UIÁ
())

169 
v®
 
dToggË
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

170 
v®
 
dF¿gnum
 = 
out
.
d
.
b™s
.
	`sourû
(
äagm’tB™s
-1, 0)

171 
v®
 
dFœ¡
 = 
acknum
 ==ğ
	`UIÁ
(0)

172 
v®
 
dLa¡
 = 
dF¿gnum
 ==ğ
	`UIÁ
(0)

173 
v®
 
dsizeOH
 = 
	`UIÁToOH
 (
out
.
d
.
b™s
.
size
, 
	`log2Ce
(
maxDownSize
)+1)

174 
v®
 
dsizeOH1
 = 
	`UIÁToOH1
(
out
.
d
.
b™s
.
size
, 
	`log2Up
(
maxDownSize
))

175 
v®
 
dHasD©a
 = 
edgeOut
.
	`hasD©a
(
out
.
d
.
b™s
)

178 
v®
 
acknum_äagm’t
 = 
dF¿gnum
 << 
	`log2Ce
(
mšSize
/
b—tBy‹s
)

179 
v®
 
acknum_size
 = 
dsizeOH1
 >> 
	`log2Ce
(
b—tBy‹s
)

180 
	`as£¹
 (!
out
.
d
.
v®id
 || (
acknum_äagm’t
 & 
acknum_size
è==ğ
	`UIÁ
(0))

181 
v®
 
dFœ¡_acknum
 = 
acknum_äagm’t
 | 
	`Mux
(
dHasD©a
, 
acknum_size
, 
	`UIÁ
(0))

182 
v®
 
ack_deüem’t
 = 
	`Mux
(
dHasD©a
, 
	`UIÁ
(1), 
dsizeOH
 >> 
	`log2Ce
(
b—tBy‹s
))

184 
v®
 
dFœ¡_size
 = 
	`OH1ToUIÁ
((
dF¿gnum
 << 
	`log2Ce
(
mšSize
)è| 
dsizeOH1
)

186 
	`wh’
 (
out
.
d
.
	`fœe
()) {

187 
acknum
 :ğ
	`Mux
(
dFœ¡
, 
dFœ¡_acknum
,‡cknum - 
ack_deüem’t
)

188 
	`wh’
 (
dFœ¡
) {

189 
dOrig
 :ğ
dFœ¡_size


190 
dToggË
 :ğ
out
.
d
.
b™s
.
	`sourû
(
äagm’tB™s
)

195 
v®
 
doE¬lyAck
 = 
—¾yAck
 
m©ch
 {

196 
E¬lyAck
.
AÎPuts
 => 
	`BoŞ
(
Œue
)

197 
E¬lyAck
.
PutFuÎs
 => 
out
.
d
.
b™s
.
	`sourû
(
äagm’tB™s
+1)

198 
E¬lyAck
.
NÚe
 => 
	`BoŞ
(
çl£
)

200 
v®
 
drİ
 = !
dHasD©a
 && !
	`Mux
(
doE¬lyAck
, 
dFœ¡
, 
dLa¡
)

201 
out
.
d
.
»ady
 :ğ
š
.d.»ady || 
drİ


202 
š
.
d
.
v®id
 :ğ
out
.d.v®id && !
drİ


203 
š
.
d
.
b™s
 :ğ
out
.d.bits

204 
š
.
d
.
b™s
.
sourû
 :ğ
out
.d.b™s.sourû >> 
addedB™s


205 
š
.
d
.
b™s
.
size
 :ğ
	`Mux
(
dFœ¡
, 
dFœ¡_size
, 
dOrig
)

207 ià(
edgeOut
.
mªag”
.
mayD’yPut
) {

208 
v®
 
r_d’›d
 = 
	`Reg
(
	`BoŞ
())

209 
v®
 
d_d’›d
 = (!
dFœ¡
 && 
r_d’›d
è|| 
out
.
d
.
b™s
.
d’›d


210 
	`wh’
 (
out
.
d
.
	`fœe
()è{ 
r_d’›d
 :ğ
d_d’›d
 }

211 
š
.
d
.
b™s
.
d’›d
 :ğ
d_d’›d


213 ià(
edgeOut
.
mªag”
.
mayD’yG‘
) {

215 
v®
 
d_d’›d
 = 
out
.
d
.
b™s
.
d’›d
 
hŞdUÆess
 
dFœ¡


216 
	`wh’
 (
dHasD©a
) {

217 
š
.
d
.
b™s
.
d’›d
 :ğ
d_d’›d


222 
v®
 
maxAr™hm‘ics
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsAr™hm‘ic
.
max
)

223 
v®
 
maxLogiÿls
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsLogiÿl
.
max
)

224 
v®
 
maxG‘s
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsG‘
.
max
)

225 
v®
 
maxPutFuÎs
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsPutFuÎ
.
max
)

226 
v®
 
maxPutP¬tŸls
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsPutP¬tŸl
.
max
)

227 
v®
 
maxHšts
 = 
mªag”s
.
	`m­
(
m
 => ià(m.
suµÜtsHšt
è
maxDownSize
 0)

230 
v®
 
lgMšSize
 = 
	`UIÁ
(
	`log2Ce
(
mšSize
))

231 
v®
 
maxLgAr™hm‘ics
 = 
maxAr™hm‘ics
.
	`m­
(
m
 => ià(m =ğ0è
lgMšSize
 
	`UIÁ
(
	`log2Ce
(m)))

232 
v®
 
maxLgLogiÿls
 = 
maxLogiÿls
 .
	`m­
(
m
 => ià(m =ğ0è
lgMšSize
 
	`UIÁ
(
	`log2Ce
(m)))

233 
v®
 
maxLgG‘s
 = 
maxG‘s
 .
	`m­
(
m
 => ià(m =ğ0è
lgMšSize
 
	`UIÁ
(
	`log2Ce
(m)))

234 
v®
 
maxLgPutFuÎs
 = 
maxPutFuÎs
 .
	`m­
(
m
 => ià(m =ğ0è
lgMšSize
 
	`UIÁ
(
	`log2Ce
(m)))

235 
v®
 
maxLgPutP¬tŸls
 = 
maxPutP¬tŸls
.
	`m­
(
m
 => ià(m =ğ0è
lgMšSize
 
	`UIÁ
(
	`log2Ce
(m)))

236 
v®
 
maxLgHšts
 = 
maxHšts
 .
	`m­
(
m
 => ià(m =ğ0è
lgMšSize
 
	`UIÁ
(
	`log2Ce
(m)))

239 
v®
 
»³©”
 = 
	`ModuË
(
Ãw
 
	`R•—‹r
(
š
.
a
.
b™s
))

240 
»³©”
.
io
.
’q
 <> 
š
.
a


241 
v®
 
š_a
 = 
»³©”
.
io
.
deq


244 
v®
 
fšd
 = 
mªag”
.
	`fšdFa¡
(
edgeIn
.
	`add»ss
(
š_a
.
b™s
))

245 
v®
 
maxLgAr™hm‘ic
 = 
	`Mux1H
(
fšd
, 
maxLgAr™hm‘ics
)

246 
v®
 
maxLgLogiÿl
 = 
	`Mux1H
(
fšd
, 
maxLgLogiÿls
)

247 
v®
 
maxLgG‘
 = 
	`Mux1H
(
fšd
, 
maxLgG‘s
)

248 
v®
 
maxLgPutFuÎ
 = 
	`Mux1H
(
fšd
, 
maxLgPutFuÎs
)

249 
v®
 
maxLgPutP¬tŸl
 = 
	`Mux1H
(
fšd
, 
maxLgPutP¬tŸls
)

250 
v®
 
maxLgHšt
 = 
	`Mux1H
(
fšd
, 
maxLgHšts
)

252 
v®
 
lim™
 = ià(
®waysMš
è
lgMšSize
 

253 
	`MuxLookup
(
š_a
.
b™s
.
İcode
, 
lgMšSize
, 
	`A¼ay
(

254 
TLMes§ges
.
PutFuÎD©a
 -> 
maxLgPutFuÎ
,

255 
TLMes§ges
.
PutP¬tŸlD©a
 -> 
maxLgPutP¬tŸl
,

256 
TLMes§ges
.
Ar™hm‘icD©a
 -> 
maxLgAr™hm‘ic
,

257 
TLMes§ges
.
LogiÿlD©a
 -> 
maxLgLogiÿl
,

258 
TLMes§ges
.
G‘
 -> 
maxLgG‘
,

259 
TLMes§ges
.
Hšt
 -> 
maxLgHšt
))

261 
v®
 
aOrig
 = 
š_a
.
b™s
.
size


262 
v®
 
aF¿g
 = 
	`Mux
(
aOrig
 > 
lim™
,†imit,‡Orig)

263 
v®
 
aOrigOH1
 = 
	`UIÁToOH1
(
aOrig
, 
	`log2Ce
(
maxSize
))

264 
v®
 
aF¿gOH1
 = 
	`UIÁToOH1
(
aF¿g
, 
	`log2Up
(
maxDownSize
))

265 
v®
 
aHasD©a
 = 
edgeIn
.
	`hasD©a
(
š_a
.
b™s
)

266 
v®
 
aMask
 = 
	`Mux
(
aHasD©a
, 
	`UIÁ
(0), 
aF¿gOH1
)

268 
v®
 
g’num
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
couÁ”B™s
))

269 
v®
 
aFœ¡
 = 
g’num
 ==ğ
	`UIÁ
(0)

270 
v®
 
Şd_g’num1
 = 
	`Mux
(
aFœ¡
, 
aOrigOH1
 >> 
	`log2Ce
(
b—tBy‹s
), 
g’num
 - 
	`UIÁ
(1))

271 
v®
 
Ãw_g’num
 = ~(~
Şd_g’num1
 | (
aMask
 >> 
	`log2Ce
(
b—tBy‹s
)))

272 
v®
 
aF¿gnum
 = ~(~(
Şd_g’num1
 >> 
	`log2Ce
(
mšSize
/
b—tBy‹s
)è| (
aF¿gOH1
 >>†og2Ceil(minSize)))

273 
v®
 
aLa¡
 = 
aF¿gnum
 ==ğ
	`UIÁ
(0)

274 
v®
 
aToggË
 = !
	`Mux
(
aFœ¡
, 
dToggË
, 
	`RegEÇbË
(dToggle,‡First))

275 
v®
 
aFuÎ
 = ià(
—¾yAck
 =ğ
E¬lyAck
.
PutFuÎs
è
	`Some
(
š_a
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
PutFuÎD©a
è
NÚe


277 
	`wh’
 (
out
.
a
.
	`fœe
()è{ 
g’num
 :ğ
Ãw_g’num
 }

279 
»³©”
.
io
.
»³©
 :ğ!
aHasD©a
 && 
aF¿gnum
 =/ğ
	`UIÁ
(0)

280 
out
.
a
 <> 
š_a


281 
out
.
a
.
b™s
.
add»ss
 :ğ
š_a
.b™s.add»s | ~(
Şd_g’num1
 << 
	`log2Ce
(
b—tBy‹s
è| ~
aOrigOH1
 | 
aF¿gOH1
 | 
	`UIÁ
(
mšSize
-1))

282 
out
.
a
.
b™s
.
sourû
 :ğ
	`C©
(
	`Seq
(
š_a
.b™s.sourûè++ 
aFuÎ
 ++ Seq(
aToggË
.
asUIÁ
, 
aF¿gnum
))

283 
out
.
a
.
b™s
.
size
 :ğ
aF¿g


286 
	`as£¹
 (!
»³©”
.
io
.
fuÎ
 || !
aHasD©a
)

287 
out
.
a
.
b™s
.
d©a
 :ğ
š
.a.bits.data

288 
v®
 
fuÎMask
 = 
	`UIÁ
((
	`BigIÁ
(1è<< 
b—tBy‹s
) - 1)

289 
	`as£¹
 (!
»³©”
.
io
.
fuÎ
 || 
š_a
.
b™s
.
mask
 ==ğ
fuÎMask
)

290 
out
.
a
.
b™s
.
mask
 :ğ
	`Mux
(
»³©”
.
io
.
fuÎ
, 
fuÎMask
, 
š
.a.bits.mask)

293 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

294 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

295 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

296 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

297 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

298 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

301 
	}
}

303 
objeù
 
TLF¿gm’‹r


305 
def
 
­¶y
(
mšSize
: 
IÁ
, 
maxSize
: IÁ, 
®waysMš
: 
BoŞ—n
 = 
çl£
, 
—¾yAck
: 
E¬lyAck
.
T
 = E¬lyAck.
NÚe
, 
hŞdFœ¡D’y
: BoŞ—Àğçl£)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

307 
v®
 
äagm’‹r
 = 
LazyModuË
(
Ãw
 
TLF¿gm’‹r
(
mšSize
, 
maxSize
, 
®waysMš
, 
—¾yAck
, 
hŞdFœ¡D’y
))

308 
	gäagm’‹r
.
	gnode


313 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


315 
şass
 
	$TLRAMF¿gm’‹r
(
¿mB—tBy‹s
: 
IÁ
, 
maxSize
: IÁ, 
txns
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

316 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

317 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("Fragmenter"))

318 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0x0, 0x3ff), 
b—tBy‹s
 = 
¿mB—tBy‹s
))

320 (
¿m
.
node


321 :ğ
	`TLD–ay”
(0.1)

322 :ğ
	`TLBufãr
(
BufãrP¬ams
.
æow
)

323 :ğ
	`TLD–ay”
(0.1)

324 :ğ
	`TLF¿gm’‹r
(
¿mB—tBy‹s
, 
maxSize
, 
—¾yAck
 = 
E¬lyAck
.
AÎPuts
)

325 :ğ
	`TLD–ay”
(0.1)

326 :ğ
	`TLBufãr
(
BufãrP¬ams
.
æow
)

327 :ğ
	`TLF¿gm’‹r
(
¿mB—tBy‹s
, 
maxSize
/2)

328 :ğ
	`TLD–ay”
(0.1)

329 :ğ
	`TLBufãr
(
BufãrP¬ams
.
æow
)

330 :ğ
mod–
.
node


331 :ğ
fuzz
.
node
)

333 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

334 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

336 
	}
}

338 
şass
 
	$TLRAMF¿gm’‹rTe¡
(
¿mB—tBy‹s
: 
IÁ
, 
maxSize
: IÁ, 
txns
: IÁ = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

339 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMF¿gm’‹r
(
¿mB—tBy‹s
,
maxSize
,
txns
)).
moduË
)

340 
io
.
fšished
 :ğ
dut
.io.finished

341 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fuzzer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 şas 
	cIDM­G’”©Ü
(
numIds
: 
IÁ
è
ex‹nds
 
ModuË
 {

11 
	`»quœe
 (
numIds
 > 0)

13 
v®
 
w
 = 
	$log2Up
(
numIds
)

14 
v®
 
io
 = 
Ãw
 
BundË
 {

15 
v®
 
ä“
 = 
	`Decou¶ed
(
	`UIÁ
(
width
 = 
w
)).
æ


16 
v®
 
®loc
 = 
	`Decou¶ed
(
	`UIÁ
(
width
 = 
w
))

19 
io
.
ä“
.
»ady
 :ğ
	$BoŞ
(
Œue
)

22 
v®
 
b™m­
 = 
	`RegIn™
(
	`UIÁ
((
	`BigIÁ
(1è<< 
numIds
è- 1, 
width
 =‚umIds))

24 
v®
 
£Ëù
 = ~(
	`ËáOR
(
b™m­
) << 1) & bitmap

25 
io
.
®loc
.
b™s
 :ğ
	$OHToUIÁ
(
£Ëù
)

26 
io
.
®loc
.
v®id
 :ğ
b™m­
.
	$ÜR
()

28 
v®
 
şr
 = 
	`Wœe
(
š™
 = 
	$UIÁ
(0, 
width
 = 
numIds
))

29 
	`wh’
 (
io
.
®loc
.
	$fœe
()è{ 
şr
 :ğ
	`UIÁToOH
(
io
.
®loc
.
b™s
è
	}
}

31 
v®
 
£t
 = 
Wœe
(
š™
 = 
	$UIÁ
(0, 
width
 = 
numIds
))

32 
	`wh’
 (
io
.
ä“
.
	$fœe
()è{ 
£t
 :ğ
	`UIÁToOH
(
io
.
ä“
.
b™s
è
	}
}

34 
b™m­
 :ğ(b™m­ & ~
şr
è| 
£t


35 
as£¹
 (!
io
.
ä“
.
v®id
 || !(
b™m­
 & ~
şr
)(io.ä“.
b™s
))

38 
objeù
 
LFSR64


40 
def
 
­¶y
(
šüem’t
: 
BoŞ
 = BoŞ(
Œue
)): 
UIÁ
 =

42 
v®
 
wide
 = 64

43 
v®
 
lf¤
 = 
Reg
(
UIÁ
(
width
 = 
wide
))

44 
v®
 
xÜ
 = 
lf¤
(0) ^†fsr(1) ^†fsr(3) ^†fsr(4)

45 
wh’
 (
šüem’t
) {

46 
lf¤
 :ğ
Mux
Öf¤ ==ğ
UIÁ
(0), UIÁ(1), 
C©
(
xÜ
,†f¤(
wide
-1,1)))

48 
	glf¤


52 
Œa™
 
	gHasNoi£Mak”IO


54 
v®
 
	gio
 = 
Ãw
 
BundË
 {

55 
v®
 
šc
 = 
BoŞ
(
INPUT
)

56 
v®
 
¿ndom
 = 
UIÁ
(
OUTPUT
)

60 şas 
	cLFSRNoi£Mak”
(
wide
: 
IÁ
è
ex‹nds
 
ModuË
 
w™h
 
HasNoi£Mak”IO


62 
v®
 
lf¤s
 = 
Seq
.
	`fl
((
wide
+63)/64è{ 
	`LFSR64
(
io
.
šc
) }

63 
io
.
¿ndom
 :ğ
	$C©
(
lf¤s
)(
wide
-1,0)

64 
	}
}

66 
objeù
 
	gLFSRNoi£Mak”
 {

67 
def
 
­¶y
(
wide
: 
IÁ
, 
šüem’t
: 
BoŞ
 = BoŞ(
Œue
)): 
UIÁ
 = {

68 
v®
 
nm
 = 
ModuË
(
Ãw
 
LFSRNoi£Mak”
(
wide
))

69 
nm
.
io
.
šc
 :ğ
šüem’t


70 
nm
.
io
.
¿ndom


81 
şass
 
TLFuzz”
(

82 
nO³¿tiÚs
: 
IÁ
,

83 
šFlight
: 
IÁ
 = 32,

84 
noi£Mak”
: (
IÁ
, 
BoŞ
, IÁè=> 
UIÁ
 = {

85 (
wide
: 
IÁ
, 
šüem’t
: 
BoŞ
, 
abs_v®ues
: Int) =>

86 
LFSRNoi£Mak”
(
wide
=wide, 
šüem’t
=increment)

88 
noModify
: 
BoŞ—n
 = 
çl£
,

89 
ov”rideAdd»ss
: 
O±iÚ
[
Add»ssS‘
] = 
NÚe
,

90 
nOrd”ed
: 
O±iÚ
[
IÁ
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


93 
v®
 
ş›ÁP¬ams
 = ià(
nOrd”ed
.
isDefšed
) {

94 
v®
 
n
 = 
nOrd”ed
.
g‘


95 
»quœe
(
n
 > 0, 
s
"nOrdered must be > 0,‚ot $n")

96 
»quœe
((
šFlight
 % 
n
è=ğ0, 
s
"inFlight (${inFlight}) must beƒvenly divisible by‚Ordered (${nOrdered}).")

97 
	gSeq
.
buÏ‹
(
n
è{
	gi
 =>

98 
TLCl›ÁP¬am‘”s
(
Çme
 =
s
"OrderedFuzzer$i",

99 
sourûId
 = 
IdRªge
(
i
 * (
šFlight
/
n
), (i + 1)*(inFlight/n)),

100 
»que¡Fifo
 = 
Œue
)

103 
Seq
(
TLCl›ÁP¬am‘”s
(

104 
Çme
 = "Fuzzer",

105 
sourûId
 = 
IdRªge
(0,
šFlight
)

109 
v®
 
	gnode
 = 
TLCl›ÁNode
(
Seq
(
TLCl›ÁPÜtP¬am‘”s
(
ş›ÁP¬ams
)))

111 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

112 
v®
 
io
 = 
IO
(
Ãw
 
BundË
 {

113 
v®
 
fšished
 = 
BoŞ
(
OUTPUT
)

116 
v®
 (
out
, 
edge
èğ
node
.out(0)

119 
v®
 
maxT¿nsãr
 = 
edge
.
mªag”
.maxTransfer

120 
v®
 
b—tBy‹s
 = 
edge
.
mªag”
.beatBytes

121 
v®
 
maxLgB—ts
 = 
log2Up
(
maxT¿nsãr
/
b—tBy‹s
)

122 
v®
 
add»ssB™s
 = 
log2Up
(
ov”rideAdd»ss
.
m­
(
_
.
max
).
g‘OrEl£
(
edge
.
mªag”
.
maxAdd»ss
))

123 
v®
 
sizeB™s
 = 
edge
.
bundË
.sizeBits

124 
v®
 
d©aB™s
 = 
edge
.
bundË
.dataBits

127 
v®
 
num_»qs
 = 
Reg
(
š™
 = 
UIÁ
(
nO³¿tiÚs
, 
log2Up
(nOperations+1)))

128 
v®
 
	gnum_»¥s
 = 
Reg
(
š™
 = 
UIÁ
(
nO³¿tiÚs
, 
log2Up
(nOperations+1)))

129 ià(
	gnO³¿tiÚs
>0) {

130 
	gio
.
	gfšished
 :ğ
num_»¥s
 ==ğ
UIÁ
(0)

132 
io
.
fšished
 :ğ
BoŞ
(
çl£
)

136 
v®
 
a
 = 
out
.a.
b™s


137 
v®
 (
a_fœ¡
, 
a_Ï¡
, 
»q_dÚe
èğ
edge
.
fœ¡Ï¡
(
out
.
a
)

139 
v®
 
d
 = 
out
.d.
b™s


140 
v®
 (
d_fœ¡
, 
d_Ï¡
, 
»¥_dÚe
èğ
edge
.
fœ¡Ï¡
(
out
.
d
)

143 
v®
 
idM­
 = 
ModuË
(
Ãw
 
IDM­G’”©Ü
(
šFlight
))

144 
v®
 
¤c
 = 
idM­
.
io
.
®loc
.
b™s
 
hŞdUÆess
 
a_fœ¡


146 
v®
 
šc
 = 
Wœe
(
BoŞ
())

147 
v®
 
šc_b—t
 = 
Wœe
(
BoŞ
())

148 
v®
 
¬th_İ_3
 = 
noi£Mak”
(3, 
šc
, 0)

149 
v®
 
	g¬th_İ
 = 
Mux
(
¬th_İ_3
 > 
UIÁ
(4), UInt(4),‡rth_op_3)

150 
v®
 
	glog_İ
 = 
noi£Mak”
(2, 
šc
, 0)

151 
v®
 
	gamo_size
 = 
UIÁ
(2è+ 
noi£Mak”
(1, 
šc
, 0)

152 
v®
 
	gsize
 = 
noi£Mak”
(
sizeB™s
, 
šc
, 0)

153 
v®
 
	g¿wAddr
 = 
noi£Mak”
(
add»ssB™s
, 
šc
, 2)

154 
v®
 
	gaddr
 = 
ov”rideAdd»ss
.
m­
(
_
.
Ëg®ize
(
¿wAddr
)).
g‘OrEl£
ÔawAddrè& ~
UIÁToOH1
(
size
, 
add»ssB™s
)

155 
v®
 
	gmask
 = 
noi£Mak”
(
b—tBy‹s
, 
šc_b—t
, 2è& 
	gedge
.
mask
(
addr
, 
size
)

156 
v®
 
	gd©a
 = 
noi£Mak”
(
d©aB™s
, 
šc_b—t
, 2)

159 
v®
 (
gËg®
, 
gb™s
èğ
edge
.
G‘
(
¤c
, 
addr
, 
size
)

160 
v®
 (
pæeg®
, 
pfb™s
èğif(
edge
.
mªag”
.
ªySuµÜtPutFuÎ
) {

161 
edge
.
Put
(
¤c
, 
addr
, 
size
, 
d©a
)

162 } { (
gËg®
, 
gb™s
) }

163 
v®
 (
µËg®
, 
µb™s
èğif(
edge
.
mªag”
.
ªySuµÜtPutP¬tŸl
) {

164 
edge
.
Put
(
¤c
, 
addr
, 
size
, 
d©a
, 
mask
)

165 } { (
gËg®
, 
gb™s
) }

166 
v®
 (
®eg®
, 
ab™s
èğif(
edge
.
mªag”
.
ªySuµÜtAr™hm‘ic
) {

167 
edge
.
Ar™hm‘ic
(
¤c
, 
addr
, 
size
, 
d©a
, 
¬th_İ
)

168 } { (
gËg®
, 
gb™s
) }

169 
v®
 (
Îeg®
, 
lb™s
èğif(
edge
.
mªag”
.
ªySuµÜtLogiÿl
) {

170 
edge
.
Logiÿl
(
¤c
, 
addr
, 
size
, 
d©a
, 
log_İ
)

171 } { (
gËg®
, 
gb™s
) }

172 
v®
 (
hËg®
, 
hb™s
èğif(
edge
.
mªag”
.
ªySuµÜtHšt
) {

173 
edge
.
Hšt
(
¤c
, 
addr
, 
size
, 
UIÁ
(0))

174 } { (
gËg®
, 
gb™s
) }

176 
v®
 
Ëg®_de¡
 = 
edge
.
mªag”
.
cÚšsSaã
(
addr
)

179 
v®
 
a_ty³_£l
 = 
noi£Mak”
(3, 
šc
, 0)

181 
v®
 
	gËg®
 = 
Ëg®_de¡
 && 
MuxLookup
(
a_ty³_£l
, 
gËg®
, 
Seq
(

182 
UIÁ
("b000"è-> 
gËg®
,

183 
UIÁ
("b001"è-> (
pæeg®
 && !
BoŞ
(
noModify
)),

184 
UIÁ
("b010"è-> (
µËg®
 && !
BoŞ
(
noModify
)),

185 
UIÁ
("b011"è-> (
®eg®
 && !
BoŞ
(
noModify
)),

186 
UIÁ
("b100"è-> (
Îeg®
 && !
BoŞ
(
noModify
)),

187 
UIÁ
("b101"è-> 
hËg®
))

189 
v®
 
	gb™s
 = 
MuxLookup
(
a_ty³_£l
, 
gb™s
, 
Seq
(

190 
UIÁ
("b000"è-> 
gb™s
,

191 
UIÁ
("b001"è-> 
pfb™s
,

192 
UIÁ
("b010"è-> 
µb™s
,

193 
UIÁ
("b011"è-> 
ab™s
,

194 
UIÁ
("b100"è-> 
lb™s
,

195 
UIÁ
("b101"è-> 
hb™s
))

198 
v®
 
	ga_g’
 = ià(
nO³¿tiÚs
>0è
num_»qs
 =/ğ
UIÁ
(0è
BoŞ
(
Œue
)

199 
out
.
a
.
v®id
 :ğ
a_g’
 && 
Ëg®
 && (!
a_fœ¡
 || 
idM­
.
io
.
®loc
.valid)

200 
idM­
.
io
.
®loc
.
»ady
 :ğ
a_g’
 && 
Ëg®
 && 
a_fœ¡
 && 
out
.
a
.ready

201 
idM­
.
io
.
ä“
.
v®id
 :ğ
d_fœ¡
 && 
out
.
d
.
fœe
()

202 
idM­
.
io
.
ä“
.
b™s
 :ğ
out
.
d
.b™s.
sourû


204 
out
.
a
.
b™s
 := bits

205 
out
.
b
.
»ady
 :ğ
BoŞ
(
Œue
)

206 
out
.
c
.
v®id
 :ğ
BoŞ
(
çl£
)

207 
out
.
d
.
»ady
 :ğ
BoŞ
(
Œue
)

208 
out
.
e
.
v®id
 :ğ
BoŞ
(
çl£
)

211 
šc
 :ğ!
Ëg®
 || 
»q_dÚe


212 
šc_b—t
 :ğ!
Ëg®
 || 
out
.
a
.
fœe
()

214 ià(
nO³¿tiÚs
>0) {

215 
wh’
 (
out
.
a
.
fœe
(è&& 
a_Ï¡
) {

216 
num_»qs
 :ğnum_»q - 
UIÁ
(1)

219 
wh’
 (
out
.
d
.
fœe
(è&& 
d_Ï¡
) {

220 
num_»¥s
 :ğnum_»¥ - 
UIÁ
(1)

226 
objeù
 
TLFuzz”


228 
def
 
­¶y
(

229 
nO³¿tiÚs
: 
IÁ
,

230 
šFlight
: 
IÁ
 = 32,

231 
noi£Mak”
: (
IÁ
, 
BoŞ
, IÁè=> 
UIÁ
 = {

232 (
wide
: 
IÁ
, 
šüem’t
: 
BoŞ
, 
abs_v®ues
: Int) =>

233 
LFSRNoi£Mak”
(
wide
=wide, 
šüem’t
=increment)

235 
noModify
: 
BoŞ—n
 = 
çl£
,

236 
ov”rideAdd»ss
: 
O±iÚ
[
Add»ssS‘
] = 
NÚe
,

237 
nOrd”ed
: 
O±iÚ
[
IÁ
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLOutw¬dNode
 =

239 
v®
 
fuzz”
 = 
LazyModuË
(
Ãw
 
TLFuzz”
(
nO³¿tiÚs
, 
šFlight
, 
noi£Mak”
, 
noModify
, 
ov”rideAdd»ss
, 
nOrd”ed
))

240 
	gfuzz”
.
	gnode


245 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


247 şas 
	cTLFuzzRAM
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


249 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("TLFuzzRAM"))

250 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	$Add»ssS‘
(0x800, 0x7ff)))

251 
v®
 
¿m2
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0, 0x3ff), 
b—tBy‹s
 = 16))

252 
v®
 
gpio
 = 
	`LazyModuË
(
Ãw
 
	$RRTe¡1
(0x400))

253 
v®
 
xb¬
 = 
	$LazyModuË
(
Ãw
 
TLXb¬
)

254 
v®
 
xb¬2
ğ
	$LazyModuË
(
Ãw
 
TLXb¬
)

255 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

257 
xb¬2
.
node
 :ğ
	$TLAtomicAutom©a
(è:ğ
mod–
.
node
 :ğ
fuzz
.node

258 
¿m2
.
node
 :ğ
	$TLF¿gm’‹r
(16, 256è:ğ
xb¬2
.
node


259 
xb¬
.
node
 :ğ
	$TLWidthWidg‘
(16è:ğ
	$TLHštHªdËr
(è:ğ
xb¬2
.
node


260 
¿m
.
node
 :ğ
	$TLF¿gm’‹r
(4, 256è:ğ
	$TLBufãr
(è:ğ
xb¬
.
node


261 
gpio
.
node
 :ğ
	$TLF¿gm’‹r
(4, 32è:ğ
	$TLBufãr
(è:ğ
xb¬
.
node


263 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

264 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

266 
	}
}

268 
şass
 
	$TLFuzzRAMTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

269 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLFuzzRAM
(
txns
)).
moduË
)

270 
io
.
fšished
 :ğ
dut
.io.finished

271 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/HintHandler.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
R•—‹r


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
TLROM


11 
impÜt
 
	gsÿÏ
.
	gm©h
.
mš


14 
şass
 
	$TLHštHªdËr
(
·s¡hrough
: 
BoŞ—n
 = 
Œue
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


16 
v®
 
node
 = 
	`TLAd­‹rNode
(

17 
ş›ÁFn
 = { 
ı
 =>

18 
ı
.
	`cİy
(
ş›Ás
 = cp.ş›Ás.
m­
 { 
c
 => c.copy(

19 
sourûId
 = 
	`IdRªge
(
c
.sourûId.
¡¬t
*2, c.sourûId.
’d
*2))})},

20 
mªag”Fn
 = { 
mp
 =>

21 
mp
.
	`cİy
(
mªag”s
 = mp.mªag”s.
m­
 { 
m
 => m.copy(

22 
suµÜtsHšt
 =

23 ià(
m
.
suµÜtsHšt
 && 
·s¡hrough
) m.supportsHint

24 ià(
m
.
suµÜtsPutP¬tŸl
) m.supportsPutPartial

25 ià(
m
.
»giÚTy³
 !ğ
RegiÚTy³
.
GET_EFFECTS
èm.
suµÜtsG‘


26 
T¿nsãrSizes
.
nÚe
)})})

28 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

29 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

30 
out
 <> 
š


33 
edgeIn
.
mªag”
.
mªag”s
.
fÜ—ch
 { 
m
 =>

34 
	`»quœe
 (
m
.
suµÜtsHšt
, 
s
"No†egal wayo implement Hints for ${m.name}")

37 
v®
 
isHšt
 = 
š
.
a
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
Hšt


38 
def
 
	`u£PP
 (
m
: 
TLMªag”P¬am‘”s
èğ!(
·s¡hrough
 && m.
suµÜtsHšt
è&& m.
suµÜtsPutP¬tŸl


39 
def
 
	`u£G‘
(
m
: 
TLMªag”P¬am‘”s
èğ!(
·s¡hrough
 && m.
suµÜtsHšt
è&& !m.
suµÜtsPutP¬tŸl


42 
v®
 
h–pPP
 = 
isHšt
 && 
edgeOut
.
mªag”
.
	`ç¡Prİ”ty
(
š
.
a
.
b™s
.
add»ss
, 
u£PP
, (
b
:
BoŞ—n
è=> b.
B
)

43 
v®
 
m­PP
 = 
	`WœeIn™
(
h–pPP
)

46 
v®
 
m­G‘
 = 
isHšt
 && 
edgeOut
.
mªag”
.
	`ç¡Prİ”ty
(
š
.
a
.
b™s
.
add»ss
, 
u£G‘
, (
b
:
BoŞ—n
è=> b.
B
)

50 
v®
 
ÃedR•—‹r
 = 
edgeOut
.
mªag”
.
mªag”s
.
exi¡s
 { 
m
 =>

51 !(
·s¡hrough
 && 
m
.
suµÜtsHšt
è&& m.
suµÜtsPutP¬tŸl
.
max
 > 
edgeOut
.
mªag”
.
b—tBy‹s


54 
v®
 
a
 = ià(!
ÃedR•—‹r
è
š
.a {

55 
v®
 
»³©”
 = 
	`ModuË
(
Ãw
 
	`R•—‹r
(
š
.
a
.
b™s
))

56 
v®
 
mux
 = 
	`Wœe
(
	`chi£lTy³Of
(
š
.
a
))

58 
»³©”
.
io
.
»³©
 :ğ
m­PP
 && !
edgeIn
.
	`Ï¡
(
out
.
a
)

59 
»³©”
.
io
.
’q
 <> 
š
.
a


61 
out
.
a
.
b™s
 :ğ
mux
.bits

62 
out
.
a
.
v®id
 :ğ
mux
.valid

63 
mux
.
»ady
 :ğ
out
.
a
.ready

66 
mux
.
b™s
.
İcode
 :ğ
š
.
a
.bits.opcode

67 
mux
.
b™s
.
·¿m
 :ğ
š
.
a
.bits.param

68 
mux
.
b™s
.
size
 :ğ
»³©”
.
io
.
deq
.bits.size

69 
mux
.
b™s
.
sourû
 :ğ
»³©”
.
io
.
deq
.bits.source

70 
mux
.
b™s
.
add»ss
 :ğ
»³©”
.
io
.
deq
.bits.address

71 
mux
.
b™s
.
d©a
 :ğ
š
.
a
.bits.data

72 
mux
.
b™s
.
mask
 :ğ
š
.
a
.bits.mask

73 
mux
.
b™s
.
cÜru±
 :ğ
š
.
a
.bits.corrupt

75 
mux
.
v®id
 :ğ
»³©”
.
io
.
deq
.valid

76 
»³©”
.
io
.
deq
.
»ady
 :ğ
mux
.ready

78 
m­PP
 :ğ
»³©”
.
io
.
fuÎ
 || 
h–pPP


79 
mux


83 
out
.
a
.
b™s
.
İcode
 :ğ
	`Mux
(
m­PP
, 
TLMes§ges
.
PutP¬tŸlD©a
, Mux(
m­G‘
, TLMes§ges.
G‘
,‡.bits.opcode))

84 
out
.
a
.
b™s
.
·¿m
 :ğ
	`Mux
(
m­PP
 | 
m­G‘
, 0.U,‡.bits.param)

85 
out
.
a
.
b™s
.
mask
 :ğ
	`Mux
(
m­PP
, 0.U,‡.bits.mask)

86 
out
.
a
.
b™s
.
sourû
 :ğa.b™s.sourû << 1 | (
m­PP
|
m­G‘
)

89 
v®
 
ÃedsDrİ
 = 
edgeOut
.
mªag”
.
mªag”s
.
exi¡s
 { 
m
 =>

90 !(
·s¡hrough
 && 
m
.
suµÜtsHšt
è&& !m.
suµÜtsPutP¬tŸl
 &&

91 
m
.
suµÜtsG‘
.
max
 > 
edgeOut
.
mªag”
.
b—tBy‹s


94 
v®
 
ŒªsfÜm
 = 
out
.
d
.
b™s
.
	`sourû
(0)

95 
v®
 
drİ
 = ià(!
ÃedsDrİ
è
çl£
.
B
 {

97 
v®
 
Ï¡
 = 
edgeOut
.
	`Ï¡
(
out
.
d
)

98 !
Ï¡
 && 
ŒªsfÜm


102 
š
.
d
.
b™s
.
sourû
 :ğ
out
.d.bits.source >> 1

103 
š
.
d
.
b™s
.
İcode
 :ğ
	`Mux
(
ŒªsfÜm
, 
TLMes§ges
.
HštAck
, 
out
.d.bits.opcode)

104 
š
.
d
.
v®id
 :ğ
out
.d.v®id && !
drİ


105 
out
.
d
.
»ady
 :ğ
š
.d.»ady || 
drİ


107 ià(
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 && 
edgeIn
.
ş›Á
.
ªySuµÜtProbe
) {

108 
š
.
b
.
b™s
.
sourû
 :ğ
out
.b.bits.source >> 1

109 
out
.
c
.
b™s
.
sourû
 :ğ
š
.c.bits.source << 1

113 
	}
}

115 
objeù
 
TLHštHªdËr


117 
def
 
­¶y
(
·s¡hrough
: 
BoŞ—n
 = 
Œue
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

119 
v®
 
hšts
 = 
LazyModuË
(
Ãw
 
TLHštHªdËr
(
·s¡hrough
))

120 
hšts
.
node


125 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


129 şas 
	cTLRAMHštHªdËr
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

130 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

131 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("HintHandler"))

132 
v®
 
¿m1
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	$Add»ssS‘
(0x0, 0x3ff)))

133 
v®
 
¿m2
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	$Add»ssS‘
(0x400, 0x3ff)))

134 
v®
 
rom
 = 
	`LazyModuË
(
Ãw
 
	`TLROM
(0x800, 0x400, 
Seq
.
	$fl
(128) { 0 }))

135 
v®
 
xb¬
 = 
	$LazyModuË
(
Ãw
 
TLXb¬
)

137 (
¿m1
.
node


138 :ğ
	$TLD–ay”
(0.1)

139 :ğ
	$TLHštHªdËr
()

140 :ğ
	$TLD–ay”
(0.1)

141 :ğ
	$TLHštHªdËr
()

142 :ğ
	$TLD–ay”
(0.1)

143 :ğ
	$TLF¿gm’‹r
(4, 64)

144 :ğ
xb¬
.
node
)

145 (
¿m2
.
node


146 :ğ
	$TLF¿gm’‹r
(4, 64)

147 :ğ
	$TLD–ay”
(0.1)

148 :ğ
xb¬
.
node
)

149 (
rom
.
node


150 :ğ
	$TLF¿gm’‹r
(4, 64)

151 :ğ
xb¬
.
node
)

152 (
xb¬
.
node


153 :ğ
	$TLD–ay”
(0.1)

154 :ğ
	$TLHštHªdËr
()

155 :ğ
	$TLD–ay”
(0.1)

156 :ğ
mod–
.
node


157 :ğ
fuzz
.
node
)

159 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

160 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

161 
	}
}

164 
şass
 
	$TLRAMHštHªdËrTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

165 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMHštHªdËr
(
txns
)).
moduË
)

166 
io
 <> 
dut
.io

167 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Isolation.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
AsyncBundË


11 
şass
 
TLIsŞ©iÚ
(
fOut
: (
BoŞ
, 
UIÁ
è=> UIÁ, 
fIn
: (BoŞ, UIÁè=> UIÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


13 
v®
 
node
 = 
TLAsyncAd­‹rNode
()

15 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

16 
v®
 
io
 = 
IO
(
Ãw
 
BundË
 {

17 
v®
 
iso_out
 = 
BoŞ
(
INPUT
)

18 
v®
 
iso_š
 = 
BoŞ
(
INPUT
)

21 
def
 
ISOo
[
T
 <: 
D©a
](
x
: T): T = x.
äomB™s
(
fOut
(
io
.
iso_out
, x.
asUIÁ
))

22 
def
 
	gISOi
[
T
 <: 
D©a
](
x
: T): T = x.
äomB™s
(
fIn
 (
io
.
iso_š
, x.
asUIÁ
))

24 
def
 
	gABo
[
T
 <: 
D©a
](
x
: 
AsyncBundË
[T], 
	gy
: AsyncBundle[T]) {

25 
x
.
mem
 :ğ
ISOo
(
y
.mem)

26 
x
.
widx
 :ğ
ISOo
(
y
.widx)

27 
y
.
ridx
 :ğ
ISOi
(
x
.ridx)

28 (
x
.
šdex
 
z
 
y
.šdexè
fÜ—ch
 { (x, yè=> y :ğ
ISOi
(x) }

29 (
x
.
§ã
 
z
 
y
.§ãè
fÜ—ch
 { (x, 
	gy
) =>

30 
x
.
widx_v®id
 :ğ
ISOo
(
y
.widx_valid)

31 
x
.
sourû_»£t_n
 :ğ
ISOo
(
y
.source_reset_n)

32 
y
.
ridx_v®id
 :ğ
ISOi
(
x
.ridx_valid)

33 
y
.
sšk_»£t_n
 :ğ
ISOi
(
x
.sink_reset_n)

37 
def
 
ABi
[
T
 <: 
D©a
](
x
: 
AsyncBundË
[T], 
	gy
: AsyncBundle[T]) {

38 
x
.
mem
 :ğ
ISOi
(
y
.mem)

39 
x
.
widx
 :ğ
ISOi
(
y
.widx)

40 
y
.
ridx
 :ğ
ISOo
(
x
.ridx)

41 (
x
.
šdex
 
z
 
y
.šdexè
fÜ—ch
 { (x, yè=> y :ğ
ISOo
(x) }

42 (
x
.
§ã
 
z
 
y
.§ãè
fÜ—ch
 { (x, 
	gy
) =>

43 
x
.
widx_v®id
 :ğ
ISOi
(
y
.widx_valid)

44 
x
.
sourû_»£t_n
 :ğ
ISOi
(
y
.source_reset_n)

45 
y
.
ridx_v®id
 :ğ
ISOo
(
x
.ridx_valid)

46 
y
.
sšk_»£t_n
 :ğ
ISOo
(
x
.sink_reset_n)

50 
def
 
ABz
[
T
 <: 
D©a
](
x
: 
AsyncBundË
[T], 
	gy
: AsyncBundle[T]) {

51 
x
.
widx
 :ğ
UIÁ
(0)

52 
y
.
ridx
 :ğ
UIÁ
(0)

53 (
x
.
šdex
 
z
 
y
.šdexè
fÜ—ch
 { (
_
, yè=> y :ğ
UIÁ
(0) }

54 (
x
.
§ã
 
z
 
y
.§ãè
fÜ—ch
 { (x, 
	gy
) =>

55 
x
.
widx_v®id
 :ğ
BoŞ
(
çl£
)

56 
x
.
sourû_»£t_n
 :ğ
BoŞ
(
çl£
)

57 
y
.
ridx_v®id
 :ğ
BoŞ
(
çl£
)

58 
y
.
sšk_»£t_n
 :ğ
BoŞ
(
çl£
)

62 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
	gedgeIn
), (
	gout
, 
	gedgeOut
)) =>

63 
ABo
(
out
.
a
, 
š
 .a)

64 
ABi
(
š
 .
d
, 
out
.d)

66 ià(
	gedgeOut
.
	gmªag”
.
	gba£
.
	gªySuµÜtAcquœeB
 &&ƒdgeOut.
	gş›Á
.ba£.
	gªySuµÜtProbe
) {

67 
ABi
(
š
 .
b
, 
out
.b)

68 
ABo
(
out
.
c
, 
š
 .c)

69 
ABo
(
out
.
e
, 
š
 .e)

71 
ABz
(
š
 .
b
, 
out
.b)

72 
ABz
(
out
.
c
, 
š
 .c)

73 
ABz
(
out
.
e
, 
š
 .e)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Map.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

12 
şass
 
TLM­
(
â
: 
Add»ssS‘
 => 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
node
 = 
TLAd­‹rNode
(

15 
ş›ÁFn
 = { 
ı
 => cp },

16 
mªag”Fn
 = { 
mp
 =>

17 
mp
.
cİy
(
mªag”s
 = mp.mªag”s.
m­
(
m
 =>

18 
m
.
cİy
(
add»ss
 = m.add»ss.
m­
(
a
 =>

19 
Add»ssS‘
(
â
(
a
),‡.
mask
)))))})

21 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

22 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

23 
out
 <> 
š


24 
v®
 
cÚv”t
 = 
edgeIn
.
mªag”
.
mªag”s
.
æ©M­
(
_
.
add»ss
è
z
 
edgeOut
.manager.managers.flatMap(_.address)

25 
def
 
fÜw¬d
(
x
: 
UIÁ
) =

26 
cÚv”t
.
m­
 { (
i
, 
o
è=> 
Mux
(i.
cÚšs
(
x
), 
UIÁ
(o.
ba£
è| (x & UIÁ(o.
mask
)), UIÁ(0)è}.
»duû
(
_
 | _)

27 
def
 
backw¬d
(
x
: 
UIÁ
) =

28 
cÚv”t
.
m­
 { (
i
, 
o
è=> 
Mux
(o.
cÚšs
(
x
), 
UIÁ
(i.
ba£
è| (x & UIÁ(i.
mask
)), UIÁ(0)è}.
»duû
(
_
 | _)

30 
	gout
.
	ga
.
	gb™s
.
	gadd»ss
 :ğ
fÜw¬d
(
š
.
a
.
b™s
.
add»ss
)

31 ià(
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeOut.
ş›Á
.
ªySuµÜtProbe
) {

32 
out
.
c
.
b™s
.
add»ss
 :ğ
fÜw¬d
(
š
.c.bits.address)

33 
š
.
b
.
b™s
.
add»ss
 :ğ
backw¬d
(
out
.b.bits.address)

39 
objeù
 
TLM­


41 
def
 
­¶y
(
â
: 
Add»ssS‘
 => 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

43 
v®
 
m­
 = 
LazyModuË
(
Ãw
 
TLM­
(
â
))

44 
m­
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Metadata.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	grock‘
.
	gcÚ¡ªts
.
MemÜyOpCÚ¡ªts


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
objeù
 
	gCl›ÁS‹s
 {

12 
v®
 
	gwidth
 = 2

14 
def
 
NÙhšg
 = 
UIÁ
(0, 
width
)

15 
def
 
	gB¿nch
 = 
UIÁ
(1, 
width
)

16 
def
 
	gTrunk
 = 
UIÁ
(2, 
width
)

17 
def
 
	gDœty
 = 
UIÁ
(3, 
width
)

19 
def
 
hasR—dP”missiÚ
(
¡©e
: 
UIÁ
): 
BoŞ
 = s‹ > 
NÙhšg


20 
def
 
hasWr™eP”missiÚ
(
¡©e
: 
UIÁ
): 
BoŞ
 = s‹ > 
B¿nch


23 
objeù
 
MemÜyOpC©egÜ›s
 
ex‹nds
 
MemÜyOpCÚ¡ªts
 {

24 
def
 
wr
 = 
C©
(
BoŞ
(
Œue
), Bool(true))

25 
def
 
	gwi
 = 
C©
(
BoŞ
(
çl£
), BoŞ(
Œue
))

26 
def
 
	grd
 = 
C©
(
BoŞ
(
çl£
), Bool(false))

28 
def
 
ÿ‹gÜize
(
cmd
: 
UIÁ
): UInt = {

29 
v®
 
ÿt
 = 
C©
(
isWr™e
(
cmd
), 
isWr™eIÁ’t
(cmd))

31 
	gÿt


40 şas 
	cCl›ÁM‘ad©a
 
ex‹nds
 
	mBundË
 {

42 
v®
 
	m¡©e
 = 
	$UIÁ
(
width
 = 
Cl›ÁS‹s
.width)

45 
def
 ===(
rhs
: 
UIÁ
): 
BoŞ
 = 
¡©e
 ===„hs

46 
def
 ===(
rhs
: 
Cl›ÁM‘ad©a
): 
BoŞ
 = 
¡©e
 ===„hs.state

47 
def
 =/=(
rhs
: 
Cl›ÁM‘ad©a
): 
BoŞ
 = !
this
.===(rhs)

50 
def
 
	$isV®id
(
dummy
: 
IÁ
 = 0): 
BoŞ
 = 
¡©e
 > 
Cl›ÁS‹s
.
NÙhšg


53 
´iv©e
 
def
 
	$growS¹”
(
cmd
: 
UIÁ
): (
BoŞ
, UInt) = {

54 
impÜt
 
MemÜyOpC©egÜ›s
.
_


55 
impÜt
 
TLP”missiÚs
.
_


56 
impÜt
 
Cl›ÁS‹s
.
_


57 
v®
 
c
 = 
	`ÿ‹gÜize
(
cmd
)

58 
	`MuxTLookup
(
	`C©
(
c
, 
¡©e
), (
	`BoŞ
(
çl£
), 
	`UIÁ
(0)), 
	`Seq
(

60 
	`C©
(
rd
, 
Dœty
è-> (
	`BoŞ
(
Œue
), Dirty),

61 
	`C©
(
rd
, 
Trunk
è-> (
	`BoŞ
(
Œue
), Trunk),

62 
	`C©
(
rd
, 
B¿nch
è-> (
	`BoŞ
(
Œue
), Branch),

63 
	`C©
(
wi
, 
Dœty
è-> (
	`BoŞ
(
Œue
), Dirty),

64 
	`C©
(
wi
, 
Trunk
è-> (
	`BoŞ
(
Œue
), Trunk),

65 
	`C©
(
wr
, 
Dœty
è-> (
	`BoŞ
(
Œue
), Dirty),

66 
	`C©
(
wr
, 
Trunk
è-> (
	`BoŞ
(
Œue
), 
Dœty
),

68 
	`C©
(
rd
, 
NÙhšg
è-> (
	`BoŞ
(
çl£
), 
NtoB
),

69 
	`C©
(
wi
, 
B¿nch
è-> (
	`BoŞ
(
çl£
), 
BtoT
),

70 
	`C©
(
wi
, 
NÙhšg
è-> (
	`BoŞ
(
çl£
), 
NtoT
),

71 
	`C©
(
wr
, 
B¿nch
è-> (
	`BoŞ
(
çl£
), 
BtoT
),

72 
	`C©
(
wr
, 
NÙhšg
è-> (
	`BoŞ
(
çl£
), 
NtoT
)))

78 
´iv©e
 
def
 
	$growFšish”
(
cmd
: 
UIÁ
, 
·¿m
: UInt): UInt = {

79 
impÜt
 
MemÜyOpC©egÜ›s
.
_


80 
impÜt
 
TLP”missiÚs
.
_


81 
impÜt
 
Cl›ÁS‹s
.
_


82 
v®
 
c
 = 
	`ÿ‹gÜize
(
cmd
)

84 
	`MuxLookup
(
	`C©
(
c
, 
·¿m
), 
NÙhšg
, 
	`Seq
(

86 
	`C©
(
rd
, 
toB
è-> 
B¿nch
,

87 
	`C©
(
rd
, 
toT
è-> 
Trunk
,

88 
	`C©
(
wi
, 
toT
è-> 
Trunk
,

89 
	`C©
(
wr
, 
toT
è-> 
Dœty
))

90 
	}
}

94 
def
 
	$ÚAcûss
(
cmd
: 
UIÁ
): (
BoŞ
, UIÁ, 
Cl›ÁM‘ad©a
) = {

95 
v®
 
r
 = 
	`growS¹”
(
cmd
)

96 (
r
.
_1
,„.
_2
, 
	`Cl›ÁM‘ad©a
(r._2))

97 
	}
}

100 
def
 
	$ÚSecÚd¬yAcûss
(
fœ¡_cmd
: 
UIÁ
, 
£cÚd_cmd
: UIÁ): (
BoŞ
, BoŞ, UIÁ, 
Cl›ÁM‘ad©a
, UInt) = {

101 
impÜt
 
MemÜyOpC©egÜ›s
.
_


102 
v®
 
r1
 = 
	`growS¹”
(
fœ¡_cmd
)

103 
v®
 
r2
 = 
	`growS¹”
(
£cÚd_cmd
)

104 
v®
 
Ãeds_£cÚd_acq
 = 
	`isWr™eIÁ’t
(
£cÚd_cmd
è&& !isWr™eIÁ’t(
fœ¡_cmd
)

105 
v®
 
h™_agaš
 = 
r1
.
_1
 && 
r2
._1

106 
v®
 
dœt›s
 = 
	`ÿ‹gÜize
(
£cÚd_cmd
è==ğ
wr


107 
v®
 
bigge¡_grow_·¿m
 = 
	`Mux
(
dœt›s
, 
r2
.
_2
, 
r1
._2)

108 
v®
 
dœt›¡_¡©e
 = 
	`Cl›ÁM‘ad©a
(
bigge¡_grow_·¿m
)

109 
v®
 
dœt›¡_cmd
 = 
	`Mux
(
dœt›s
, 
£cÚd_cmd
, 
fœ¡_cmd
)

110 (
Ãeds_£cÚd_acq
, 
h™_agaš
, 
bigge¡_grow_·¿m
, 
dœt›¡_¡©e
, 
dœt›¡_cmd
)

111 
	}
}

114 
def
 
	$ÚG¿Á
(
cmd
: 
UIÁ
, 
·¿m
: UIÁ): 
Cl›ÁM‘ad©a
 = 
	`Cl›ÁM‘ad©a
(
	$growFšish”
(
cmd
, 
·¿m
))

117 
´iv©e
 
def
 
	$shrškH–³r
(
·¿m
: 
UIÁ
): (
BoŞ
, UInt, UInt) = {

118 
impÜt
 
Cl›ÁS‹s
.
_


119 
impÜt
 
TLP”missiÚs
.
_


120 
	`MuxTLookup
(
	`C©
(
·¿m
, 
¡©e
), (
	`BoŞ
(
çl£
), 
	`UIÁ
(0), UIÁ(0)), 
	`Seq
(

122 
	`C©
(
toT
, 
Dœty
è-> (
	`BoŞ
(
Œue
), 
TtoT
, 
Trunk
),

123 
	`C©
(
toT
, 
Trunk
è-> (
	`BoŞ
(
çl£
), 
TtoT
, Trunk),

124 
	`C©
(
toT
, 
B¿nch
è-> (
	`BoŞ
(
çl£
), 
BtoB
, Branch),

125 
	`C©
(
toT
, 
NÙhšg
è-> (
	`BoŞ
(
çl£
), 
NtoN
, Nothing),

126 
	`C©
(
toB
, 
Dœty
è-> (
	`BoŞ
(
Œue
), 
TtoB
, 
B¿nch
),

127 
	`C©
(
toB
, 
Trunk
è-> (
	`BoŞ
(
çl£
), 
TtoB
, 
B¿nch
),

128 
	`C©
(
toB
, 
B¿nch
è-> (
	`BoŞ
(
çl£
), 
BtoB
, Branch),

129 
	`C©
(
toB
, 
NÙhšg
è-> (
	`BoŞ
(
çl£
), 
BtoN
, Nothing),

130 
	`C©
(
toN
, 
Dœty
è-> (
	`BoŞ
(
Œue
), 
TtoN
, 
NÙhšg
),

131 
	`C©
(
toN
, 
Trunk
è-> (
	`BoŞ
(
çl£
), 
TtoN
, 
NÙhšg
),

132 
	`C©
(
toN
, 
B¿nch
è-> (
	`BoŞ
(
çl£
), 
BtoN
, 
NÙhšg
),

133 
	`C©
(
toN
, 
NÙhšg
è-> (
	`BoŞ
(
çl£
), 
NtoN
, Nothing)))

134 
	}
}

137 
´iv©e
 
def
 
	$cmdToP”mC­
(
cmd
: 
UIÁ
): UInt = {

138 
impÜt
 
MemÜyOpC©egÜ›s
.
_


139 
impÜt
 
TLP”missiÚs
.
_


140 
	`MuxLookup
(
cmd
, 
toN
, 
	`Seq
(

141 
M_FLUSH
 -> 
toN
,

142 
M_PRODUCE
 -> 
toB
,

143 
M_CLEAN
 -> 
toT
))

144 
	}
}

146 
def
 
	$ÚCacheCÚŒŞ
(
cmd
: 
UIÁ
): (
BoŞ
, UIÁ, 
Cl›ÁM‘ad©a
) = {

147 
v®
 
r
 = 
	`shrškH–³r
(
	`cmdToP”mC­
(
cmd
))

148 (
r
.
_1
,„.
_2
, 
	`Cl›ÁM‘ad©a
Ô.
_3
))

149 
	}
}

151 
def
 
	$ÚProbe
(
·¿m
: 
UIÁ
): (
BoŞ
, UIÁ, 
Cl›ÁM‘ad©a
) = {

152 
v®
 
r
 = 
	`shrškH–³r
(
·¿m
)

153 (
r
.
_1
,„.
_2
, 
	`Cl›ÁM‘ad©a
Ô.
_3
))

154 
	}
}

158 
objeù
 
	gCl›ÁM‘ad©a
 {

159 
def
 
­¶y
(
³rm
: 
UIÁ
) = {

160 
v®
 
m‘a
 = 
Wœe
(
Ãw
 
Cl›ÁM‘ad©a
)

161 
m‘a
.
¡©e
 :ğ
³rm


162 
m‘a


164 
def
 
ÚRe£t
 = 
Cl›ÁM‘ad©a
(
Cl›ÁS‹s
.
NÙhšg
)

165 
def
 
maximum
 = 
Cl›ÁM‘ad©a
(
Cl›ÁS‹s
.
Dœty
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Monitor.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.{
	gSourûInfo
, 
	gSourûLše
}

7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gH‘”og’eousBag
, 
	gPlusArg
}

11 şas 
	cTLMÚ™ÜArgs
(
edge
: 
TLEdge
)

13 
ab¡¿ù
 cÏs 
	cTLMÚ™ÜBa£
(
¬gs
: 
TLMÚ™ÜArgs
è
ex‹nds
 
ModuË


15 
v®
 
io
 = 
Ãw
 
BundË
 {

16 
v®
 
š
 = 
Ãw
 
	`TLBundËSnoİ
(
¬gs
.
edge
.
bundË
).
æ


19 
def
 
	$Ëg®ize
(
bundË
: 
TLBundËSnoİ
, 
edge
: 
TLEdge
, 
»£t
: 
BoŞ
): 
Un™


20 
	`Ëg®ize
(
io
.
š
, 
¬gs
.
edge
, 
»£t
)

21 
	}
}

23 şas 
	cTLMÚ™Ü
(
¬gs
: 
TLMÚ™ÜArgs
è
ex‹nds
 
	$TLMÚ™ÜBa£
(
¬gs
)

25 
def
 
exŒa
 = {

26 
¬gs
.
edge
.
sourûInfo
 
m©ch
 {

27 
	`SourûLše
(
f’ame
, 
lše
, 
cŞ
è=> 
s
" (connected‡t $filename:$line:$col)"

28 
_
 => ""

32 
def
 
	`visibË
(
add»ss
: 
UIÁ
, 
sourû
: UIÁ, 
edge
: 
TLEdge
) =

33 
edge
.
ş›Á
.
ş›Ás
.
m­
 { 
c
 =>

34 !
c
.
sourûId
.
	`cÚšs
(
sourû
) ||

35 
c
.
visib™y
.
	`m­
(
_
.
	`cÚšs
(
add»ss
)).
	`»duû
(_ || _)

36 
	}
}.
	$»duû
(
_
 && _)

38 
def
 
	$Ëg®izeFÜm©A
(
bundË
: 
TLBundËA
, 
edge
: 
TLEdge
) {

39 
	`as£¹
 (
TLMes§ges
.
	`isA
(
bundË
.
İcode
), "'A' chªÃÈha šv®id opcode" + 
exŒa
)

42 
v®
 
sourû_ok
 = 
edge
.
ş›Á
.
	`cÚšs
(
bundË
.
sourû
)

43 
v®
 
is_®igÃd
 = 
edge
.
	`isAligÃd
(
bundË
.
add»ss
, bundË.
size
)

44 
v®
 
mask
 = 
edge
.
	`fuÎ_mask
(
bundË
)

46 
	`as£¹
 (
	`visibË
(
edge
.
	`add»ss
(
bundË
), bundË.
sourû
,ƒdge), "'A' channel carries‡n‡ddress illegal forhe specified bank visibility")

48 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
AcquœeBlock
) {

49 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsAcquœeBSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› AcquœeBlocky³ unsuµÜ‹d by mªag”" + 
exŒa
)

50 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsProbe
Ódge.
	`sourû
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› AcquœeBlock from‡ cl›Á which dÛ nÙ suµÜˆProbe" + 
exŒa
)

51 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈAcquœeBlock c¬r› šv®id sourû ID" + 
exŒa
)

52 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'A' chªÃÈAcquœeBlock sm®Ë¸thª‡ b—t" + 
exŒa
)

53 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈAcquœeBlock‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

54 
	`as£¹
 (
TLP”missiÚs
.
	`isGrow
(
bundË
.
·¿m
), "'A' chªÃÈAcquœeBlock c¬r› šv®id grow…¬am" + 
exŒa
)

55 
	`as£¹
 (~
bundË
.
mask
 ==ğ
	`UIÁ
(0), "'A' chªÃÈAcquœeBlock cÚš šv®id mask" + 
exŒa
)

56 
	`as£¹
 (!
bundË
.
cÜru±
, "'A' chªÃÈAcquœeBlock i cÜru±" + 
exŒa
)

59 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
AcquœeP”m
) {

60 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsAcquœeBSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› AcquœeP”my³ unsuµÜ‹d by mªag”" + 
exŒa
)

61 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsProbe
Ódge.
	`sourû
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› AcquœeP”m from‡ cl›Á which dÛ nÙ suµÜˆProbe" + 
exŒa
)

62 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈAcquœeP”m c¬r› šv®id sourû ID" + 
exŒa
)

63 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'A' chªÃÈAcquœeP”m sm®Ë¸thª‡ b—t" + 
exŒa
)

64 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈAcquœeP”m‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

65 
	`as£¹
 (
TLP”missiÚs
.
	`isGrow
(
bundË
.
·¿m
), "'A' chªÃÈAcquœeP”m c¬r› šv®id grow…¬am" + 
exŒa
)

66 
	`as£¹
 (
bundË
.
·¿m
 =/ğ
TLP”missiÚs
.
NtoB
, "'A' chªÃÈAcquœeP”m„eque¡ NtoB" + 
exŒa
)

67 
	`as£¹
 (~
bundË
.
mask
 ==ğ
	`UIÁ
(0), "'A' chªÃÈAcquœeP”m cÚš šv®id mask" + 
exŒa
)

68 
	`as£¹
 (!
bundË
.
cÜru±
, "'A' chªÃÈAcquœeP”m i cÜru±" + 
exŒa
)

71 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
G‘
) {

72 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsG‘Saã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› G‘y³ unsuµÜ‹d by mªag”" + 
exŒa
)

73 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈG‘ c¬r› šv®id sourû ID" + 
exŒa
)

74 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈG‘‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

75 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'A' chªÃÈG‘ c¬r› šv®id…¬am" + 
exŒa
)

76 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'A' chªÃÈG‘ cÚš šv®id mask" + 
exŒa
)

77 
	`as£¹
 (!
bundË
.
cÜru±
, "'A' chªÃÈG‘ i cÜru±" + 
exŒa
)

80 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
PutFuÎD©a
) {

81 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsPutFuÎSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› PutFuÎy³ unsuµÜ‹d by mªag”" + 
exŒa
)

82 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈPutFuÎ c¬r› šv®id sourû ID" + 
exŒa
)

83 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈPutFuÎ‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

84 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'A' chªÃÈPutFuÎ c¬r› šv®id…¬am" + 
exŒa
)

85 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'A' chªÃÈPutFuÎ cÚš šv®id mask" + 
exŒa
)

88 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
PutP¬tŸlD©a
) {

89 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsPutP¬tŸlSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› PutP¬tŸÈty³ unsuµÜ‹d by mªag”" + 
exŒa
)

90 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈPutP¬tŸÈÿ¼› šv®id sourû ID" + 
exŒa
)

91 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈPutP¬tŸÈadd»s nÙ‡ligÃdØsize" + 
exŒa
)

92 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'A' chªÃÈPutP¬tŸÈÿ¼› šv®id…¬am" + 
exŒa
)

93 
	`as£¹
 ((
bundË
.
mask
 & ~maskè==ğ
	`UIÁ
(0), "'A' chªÃÈPutP¬tŸÈcÚš šv®id mask" + 
exŒa
)

96 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a
) {

97 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsAr™hm‘icSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› Ar™hm‘iøty³ unsuµÜ‹d by mªag”" + 
exŒa
)

98 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈAr™hm‘iøÿ¼› šv®id sourû ID" + 
exŒa
)

99 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈAr™hm‘iøadd»s nÙ‡ligÃdØsize" + 
exŒa
)

100 
	`as£¹
 (
TLAtomics
.
	`isAr™hm‘ic
(
bundË
.
·¿m
), "'A' chªÃÈAr™hm‘iøÿ¼› šv®id opcod·¿m" + 
exŒa
)

101 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'A' chªÃÈAr™hm‘iøcÚš šv®id mask" + 
exŒa
)

104 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
LogiÿlD©a
) {

105 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsLogiÿlSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› LogiÿÈty³ unsuµÜ‹d by mªag”" + 
exŒa
)

106 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈLogiÿÈÿ¼› šv®id sourû ID" + 
exŒa
)

107 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈLogiÿÈadd»s nÙ‡ligÃdØsize" + 
exŒa
)

108 
	`as£¹
 (
TLAtomics
.
	`isLogiÿl
(
bundË
.
·¿m
), "'A' chªÃÈLogiÿÈÿ¼› šv®id opcod·¿m" + 
exŒa
)

109 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'A' chªÃÈLogiÿÈcÚš šv®id mask" + 
exŒa
)

112 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
Hšt
) {

113 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsHštSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'A' chªÃÈÿ¼› Hšˆty³ unsuµÜ‹d by mªag”" + 
exŒa
)

114 
	`as£¹
 (
sourû_ok
, "'A' chªÃÈHšˆÿ¼› šv®id sourû ID" + 
exŒa
)

115 
	`as£¹
 (
is_®igÃd
, "'A' chªÃÈHšˆadd»s nÙ‡ligÃdØsize" + 
exŒa
)

116 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'A' chªÃÈHšˆcÚš šv®id mask" + 
exŒa
)

117 
	`as£¹
 (!
bundË
.
cÜru±
, "'A' chªÃÈHšˆi cÜru±" + 
exŒa
)

119 
	}
}

121 
def
 
	$Ëg®izeFÜm©B
(
bundË
: 
TLBundËB
, 
edge
: 
TLEdge
) {

122 
	`as£¹
 (
TLMes§ges
.
	`isB
(
bundË
.
İcode
), "'B' chªÃÈha šv®id opcode" + 
exŒa
)

124 
	`as£¹
 (
	`visibË
(
edge
.
	`add»ss
(
bundË
), bundË.
sourû
,ƒdge), "'B' channel carries‡n‡ddress illegal forhe specified bank visibility")

127 
v®
 
add»ss_ok
 = 
edge
.
mªag”
.
	`cÚšsSaã
Ódge.
	`add»ss
(
bundË
))

128 
v®
 
is_®igÃd
 = 
edge
.
	`isAligÃd
(
bundË
.
add»ss
, bundË.
size
)

129 
v®
 
mask
 = 
edge
.
	`fuÎ_mask
(
bundË
)

130 
v®
 
Ëg®_sourû
 = 
	`Mux1H
(
edge
.
ş›Á
.
	`fšd
(
bundË
.
sourû
),ƒdge.ş›Á.
ş›Ás
.
	`m­
(
c
 => 
	`UIÁ
(c.
sourûId
.
¡¬t
))) === bundle.source

132 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
Probe
) {

133 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsProbe
(
bundË
.
sourû
, bundË.
size
), "'B' chªÃÈÿ¼› Probty³ unsuµÜ‹d by cl›Á" + 
exŒa
)

134 
	`as£¹
 (
add»ss_ok
, "'B' chªÃÈProbÿ¼› unmªaged‡dd»ss" + 
exŒa
)

135 
	`as£¹
 (
Ëg®_sourû
, "'B' chªÃÈProbÿ¼› sourûh© i nÙ fœ¡ sourû" + 
exŒa
)

136 
	`as£¹
 (
is_®igÃd
, "'B' chªÃÈProbadd»s nÙ‡ligÃdØsize" + 
exŒa
)

137 
	`as£¹
 (
TLP”missiÚs
.
	`isC­
(
bundË
.
·¿m
), "'B' chªÃÈProbÿ¼› šv®id c­…¬am" + 
exŒa
)

138 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'B' chªÃÈProbcÚš šv®id mask" + 
exŒa
)

139 
	`as£¹
 (!
bundË
.
cÜru±
, "'B' chªÃÈProbi cÜru±" + 
exŒa
)

142 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
G‘
) {

143 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsG‘
(
bundË
.
sourû
, bundË.
size
), "'B' chªÃÈÿ¼› G‘y³ unsuµÜ‹d by cl›Á" + 
exŒa
)

144 
	`as£¹
 (
add»ss_ok
, "'B' chªÃÈG‘ c¬r› unmªaged‡dd»ss" + 
exŒa
)

145 
	`as£¹
 (
Ëg®_sourû
, "'B' chªÃÈG‘ c¬r› sourûh© i nÙ fœ¡ sourû" + 
exŒa
)

146 
	`as£¹
 (
is_®igÃd
, "'B' chªÃÈG‘‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

147 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'B' chªÃÈG‘ c¬r› šv®id…¬am" + 
exŒa
)

148 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'B' chªÃÈG‘ cÚš šv®id mask" + 
exŒa
)

149 
	`as£¹
 (!
bundË
.
cÜru±
, "'B' chªÃÈG‘ i cÜru±" + 
exŒa
)

152 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
PutFuÎD©a
) {

153 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsPutFuÎ
(
bundË
.
sourû
, bundË.
size
), "'B' chªÃÈÿ¼› PutFuÎy³ unsuµÜ‹d by cl›Á" + 
exŒa
)

154 
	`as£¹
 (
add»ss_ok
, "'B' chªÃÈPutFuÎ c¬r› unmªaged‡dd»ss" + 
exŒa
)

155 
	`as£¹
 (
Ëg®_sourû
, "'B' chªÃÈPutFuÎ c¬r› sourûh© i nÙ fœ¡ sourû" + 
exŒa
)

156 
	`as£¹
 (
is_®igÃd
, "'B' chªÃÈPutFuÎ‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

157 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'B' chªÃÈPutFuÎ c¬r› šv®id…¬am" + 
exŒa
)

158 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'B' chªÃÈPutFuÎ cÚš šv®id mask" + 
exŒa
)

161 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
PutP¬tŸlD©a
) {

162 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsPutP¬tŸl
(
bundË
.
sourû
, bundË.
size
), "'B' chªÃÈÿ¼› PutP¬tŸÈty³ unsuµÜ‹d by cl›Á" + 
exŒa
)

163 
	`as£¹
 (
add»ss_ok
, "'B' chªÃÈPutP¬tŸÈÿ¼› unmªaged‡dd»ss" + 
exŒa
)

164 
	`as£¹
 (
Ëg®_sourû
, "'B' chªÃÈPutP¬tŸÈÿ¼› sourûh© i nÙ fœ¡ sourû" + 
exŒa
)

165 
	`as£¹
 (
is_®igÃd
, "'B' chªÃÈPutP¬tŸÈadd»s nÙ‡ligÃdØsize" + 
exŒa
)

166 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'B' chªÃÈPutP¬tŸÈÿ¼› šv®id…¬am" + 
exŒa
)

167 
	`as£¹
 ((
bundË
.
mask
 & ~maskè==ğ
	`UIÁ
(0), "'B' chªÃÈPutP¬tŸÈcÚš šv®id mask" + 
exŒa
)

170 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a
) {

171 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsAr™hm‘ic
(
bundË
.
sourû
, bundË.
size
), "'B' chªÃÈÿ¼› Ar™hm‘iøty³ unsuµÜ‹d by cl›Á" + 
exŒa
)

172 
	`as£¹
 (
add»ss_ok
, "'B' chªÃÈAr™hm‘iøÿ¼› unmªaged‡dd»ss" + 
exŒa
)

173 
	`as£¹
 (
Ëg®_sourû
, "'B' chªÃÈAr™hm‘iøÿ¼› sourûh© i nÙ fœ¡ sourû" + 
exŒa
)

174 
	`as£¹
 (
is_®igÃd
, "'B' chªÃÈAr™hm‘iøadd»s nÙ‡ligÃdØsize" + 
exŒa
)

175 
	`as£¹
 (
TLAtomics
.
	`isAr™hm‘ic
(
bundË
.
·¿m
), "'B' chªÃÈAr™hm‘iøÿ¼› šv®id opcod·¿m" + 
exŒa
)

176 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'B' chªÃÈAr™hm‘iøcÚš šv®id mask" + 
exŒa
)

179 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
LogiÿlD©a
) {

180 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsLogiÿl
(
bundË
.
sourû
, bundË.
size
), "'B' chªÃÈÿ¼› LogiÿÈty³ unsuµÜ‹d by cl›Á" + 
exŒa
)

181 
	`as£¹
 (
add»ss_ok
, "'B' chªÃÈLogiÿÈÿ¼› unmªaged‡dd»ss" + 
exŒa
)

182 
	`as£¹
 (
Ëg®_sourû
, "'B' chªÃÈLogiÿÈÿ¼› sourûh© i nÙ fœ¡ sourû" + 
exŒa
)

183 
	`as£¹
 (
is_®igÃd
, "'B' chªÃÈLogiÿÈadd»s nÙ‡ligÃdØsize" + 
exŒa
)

184 
	`as£¹
 (
TLAtomics
.
	`isLogiÿl
(
bundË
.
·¿m
), "'B' chªÃÈLogiÿÈÿ¼› šv®id opcod·¿m" + 
exŒa
)

185 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'B' chªÃÈLogiÿÈcÚš šv®id mask" + 
exŒa
)

188 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
Hšt
) {

189 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsHšt
(
bundË
.
sourû
, bundË.
size
), "'B' chªÃÈÿ¼› Hšˆty³ unsuµÜ‹d by cl›Á" + 
exŒa
)

190 
	`as£¹
 (
add»ss_ok
, "'B' chªÃÈHšˆÿ¼› unmªaged‡dd»ss" + 
exŒa
)

191 
	`as£¹
 (
Ëg®_sourû
, "'B' chªÃÈHšˆÿ¼› sourûh© i nÙ fœ¡ sourû" + 
exŒa
)

192 
	`as£¹
 (
is_®igÃd
, "'B' chªÃÈHšˆadd»s nÙ‡ligÃdØsize" + 
exŒa
)

193 
	`as£¹
 (
bundË
.
mask
 ==ğmask, "'B' chªÃÈHšˆcÚš šv®id mask" + 
exŒa
)

194 
	`as£¹
 (!
bundË
.
cÜru±
, "'B' chªÃÈHšˆi cÜru±" + 
exŒa
)

196 
	}
}

198 
def
 
	$Ëg®izeFÜm©C
(
bundË
: 
TLBundËC
, 
edge
: 
TLEdge
) {

199 
	`as£¹
 (
TLMes§ges
.
	`isC
(
bundË
.
İcode
), "'C' chªÃÈha šv®id opcode" + 
exŒa
)

201 
v®
 
sourû_ok
 = 
edge
.
ş›Á
.
	`cÚšs
(
bundË
.
sourû
)

202 
v®
 
is_®igÃd
 = 
edge
.
	`isAligÃd
(
bundË
.
add»ss
, bundË.
size
)

203 
v®
 
add»ss_ok
 = 
edge
.
mªag”
.
	`cÚšsSaã
Ódge.
	`add»ss
(
bundË
))

205 
	`as£¹
 (
	`visibË
(
edge
.
	`add»ss
(
bundË
), bundË.
sourû
,ƒdge), "'C' channel carries‡n‡ddress illegal forhe specified bank visibility")

207 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
ProbeAck
) {

208 
	`as£¹
 (
add»ss_ok
, "'C' chªÃÈProbeAck c¬r› unmªaged‡dd»ss" + 
exŒa
)

209 
	`as£¹
 (
sourû_ok
, "'C' chªÃÈProbeAck c¬r› šv®id sourû ID" + 
exŒa
)

210 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'C' chªÃÈProbeAck sm®Ë¸thª‡ b—t" + 
exŒa
)

211 
	`as£¹
 (
is_®igÃd
, "'C' chªÃÈProbeAck‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

212 
	`as£¹
 (
TLP”missiÚs
.
	`isR•Üt
(
bundË
.
·¿m
), "'C' chªÃÈProbeAck c¬r› šv®id„•Üˆ·¿m" + 
exŒa
)

213 
	`as£¹
 (!
bundË
.
cÜru±
, "'C' chªÃÈProbeAck i cÜru±" + 
exŒa
)

216 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
ProbeAckD©a
) {

217 
	`as£¹
 (
add»ss_ok
, "'C' chªÃÈProbeAckD©¨ÿ¼› unmªaged‡dd»ss" + 
exŒa
)

218 
	`as£¹
 (
sourû_ok
, "'C' chªÃÈProbeAckD©¨ÿ¼› šv®id sourû ID" + 
exŒa
)

219 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'C' chªÃÈProbeAckD©¨sm®Ë¸thª‡ b—t" + 
exŒa
)

220 
	`as£¹
 (
is_®igÃd
, "'C' chªÃÈProbeAckD©¨add»s nÙ‡ligÃdØsize" + 
exŒa
)

221 
	`as£¹
 (
TLP”missiÚs
.
	`isR•Üt
(
bundË
.
·¿m
), "'C' chªÃÈProbeAckD©¨ÿ¼› šv®id„•Üˆ·¿m" + 
exŒa
)

224 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
R–—£
) {

225 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsAcquœeBSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'C' chªÃÈÿ¼› R–—£y³ unsuµÜ‹d by mªag”" + 
exŒa
)

226 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsProbe
Ódge.
	`sourû
(
bundË
), bundË.
size
), "'C' chªÃÈÿ¼› R–—£ from‡ cl›Á which dÛ nÙ suµÜˆProbe" + 
exŒa
)

227 
	`as£¹
 (
sourû_ok
, "'C' chªÃÈR–—£ c¬r› šv®id sourû ID" + 
exŒa
)

228 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'C' chªÃÈR–—£ sm®Ë¸thª‡ b—t" + 
exŒa
)

229 
	`as£¹
 (
is_®igÃd
, "'C' chªÃÈR–—£‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

230 
	`as£¹
 (
TLP”missiÚs
.
	`isShršk
(
bundË
.
·¿m
), "'C' chªÃÈR–—£ c¬r› šv®id shršk…¬am" + 
exŒa
)

231 
	`as£¹
 (!
bundË
.
cÜru±
, "'C' chªÃÈR–—£ i cÜru±" + 
exŒa
)

234 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
R–—£D©a
) {

235 
	`as£¹
 (
edge
.
mªag”
.
	`suµÜtsAcquœeBSaã
Ódge.
	`add»ss
(
bundË
), bundË.
size
), "'C' chªÃÈÿ¼› R–—£D©¨ty³ unsuµÜ‹d by mªag”" + 
exŒa
)

236 
	`as£¹
 (
edge
.
ş›Á
.
	`suµÜtsProbe
Ódge.
	`sourû
(
bundË
), bundË.
size
), "'C' chªÃÈÿ¼› R–—£ from‡ cl›Á which dÛ nÙ suµÜˆProbe" + 
exŒa
)

237 
	`as£¹
 (
sourû_ok
, "'C' chªÃÈR–—£D©¨ÿ¼› šv®id sourû ID" + 
exŒa
)

238 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'C' chªÃÈR–—£D©¨sm®Ë¸thª‡ b—t" + 
exŒa
)

239 
	`as£¹
 (
is_®igÃd
, "'C' chªÃÈR–—£D©¨add»s nÙ‡ligÃdØsize" + 
exŒa
)

240 
	`as£¹
 (
TLP”missiÚs
.
	`isShršk
(
bundË
.
·¿m
), "'C' chªÃÈR–—£D©¨ÿ¼› šv®id shršk…¬am" + 
exŒa
)

243 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
AcûssAck
) {

244 
	`as£¹
 (
add»ss_ok
, "'C' chªÃÈAcûssAck c¬r› unmªaged‡dd»ss" + 
exŒa
)

245 
	`as£¹
 (
sourû_ok
, "'C' chªÃÈAcûssAck c¬r› šv®id sourû ID" + 
exŒa
)

246 
	`as£¹
 (
is_®igÃd
, "'C' chªÃÈAcûssAck‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

247 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'C' chªÃÈAcûssAck c¬r› šv®id…¬am" + 
exŒa
)

248 
	`as£¹
 (!
bundË
.
cÜru±
, "'C' chªÃÈAcûssAck i cÜru±" + 
exŒa
)

251 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
AcûssAckD©a
) {

252 
	`as£¹
 (
add»ss_ok
, "'C' chªÃÈAcûssAckD©¨ÿ¼› unmªaged‡dd»ss" + 
exŒa
)

253 
	`as£¹
 (
sourû_ok
, "'C' chªÃÈAcûssAckD©¨ÿ¼› šv®id sourû ID" + 
exŒa
)

254 
	`as£¹
 (
is_®igÃd
, "'C' chªÃÈAcûssAckD©¨add»s nÙ‡ligÃdØsize" + 
exŒa
)

255 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'C' chªÃÈAcûssAckD©¨ÿ¼› šv®id…¬am" + 
exŒa
)

258 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
HštAck
) {

259 
	`as£¹
 (
add»ss_ok
, "'C' chªÃÈHštAck c¬r› unmªaged‡dd»ss" + 
exŒa
)

260 
	`as£¹
 (
sourû_ok
, "'C' chªÃÈHštAck c¬r› šv®id sourû ID" + 
exŒa
)

261 
	`as£¹
 (
is_®igÃd
, "'C' chªÃÈHštAck‡dd»s nÙ‡ligÃdØsize" + 
exŒa
)

262 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'C' chªÃÈHštAck c¬r› šv®id…¬am" + 
exŒa
)

263 
	`as£¹
 (!
bundË
.
cÜru±
, "'C' chªÃÈHštAck i cÜru±" + 
exŒa
)

265 
	}
}

267 
def
 
	$Ëg®izeFÜm©D
(
bundË
: 
TLBundËD
, 
edge
: 
TLEdge
) {

268 
	`as£¹
 (
TLMes§ges
.
	`isD
(
bundË
.
İcode
), "'D' chªÃÈha šv®id opcode" + 
exŒa
)

270 
v®
 
sourû_ok
 = 
edge
.
ş›Á
.
	`cÚšs
(
bundË
.
sourû
)

271 
v®
 
sšk_ok
 = 
bundË
.
sšk
 < 
	`UIÁ
(
edge
.
mªag”
.
’dSškId
)

272 
v®
 
d’y_put_ok
 = 
	`BoŞ
(
edge
.
mªag”
.
mayD’yPut
)

273 
v®
 
d’y_g‘_ok
 = 
	`BoŞ
(
edge
.
mªag”
.
mayD’yG‘
)

275 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
R–—£Ack
) {

276 
	`as£¹
 (
sourû_ok
, "'D' chªÃÈR–—£Ack c¬r› šv®id sourû ID" + 
exŒa
)

277 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'D' chªÃÈR–—£Ack sm®Ë¸thª‡ b—t" + 
exŒa
)

278 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'D' chªÃÈR–—£eAck c¬r› šv®id…¬am" + 
exŒa
)

279 
	`as£¹
 (!
bundË
.
cÜru±
, "'D' chªÃÈR–—£Ack i cÜru±" + 
exŒa
)

280 
	`as£¹
 (!
bundË
.
d’›d
, "'D' chªÃÈR–—£Ack i d’›d" + 
exŒa
)

283 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
G¿Á
) {

284 
	`as£¹
 (
sourû_ok
, "'D' chªÃÈG¿Á c¬r› šv®id sourû ID" + 
exŒa
)

285 
	`as£¹
 (
sšk_ok
, "'D' chªÃÈG¿Á c¬r› šv®id sšk ID" + 
exŒa
)

286 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'D' chªÃÈG¿Á sm®Ë¸thª‡ b—t" + 
exŒa
)

287 
	`as£¹
 (
TLP”missiÚs
.
	`isC­
(
bundË
.
·¿m
), "'D' chªÃÈG¿Á c¬r› šv®id c­…¬am" + 
exŒa
)

288 
	`as£¹
 (
bundË
.
·¿m
 =/ğ
TLP”missiÚs
.
toN
, "'D' chªÃÈG¿Á c¬r› toN…¬am" + 
exŒa
)

289 
	`as£¹
 (!
bundË
.
cÜru±
, "'D' chªÃÈG¿Á i cÜru±" + 
exŒa
)

290 
	`as£¹
 (
d’y_put_ok
 || !
bundË
.
d’›d
, "'D' chªÃÈG¿Á i d’›d" + 
exŒa
)

293 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
G¿ÁD©a
) {

294 
	`as£¹
 (
sourû_ok
, "'D' chªÃÈG¿ÁD©¨ÿ¼› šv®id sourû ID" + 
exŒa
)

295 
	`as£¹
 (
sšk_ok
, "'D' chªÃÈG¿ÁD©¨ÿ¼› šv®id sšk ID" + 
exŒa
)

296 
	`as£¹
 (
bundË
.
size
 >ğ
	`UIÁ
(
	`log2Ce
(
edge
.
mªag”
.
b—tBy‹s
)), "'D' chªÃÈG¿ÁD©¨sm®Ë¸thª‡ b—t" + 
exŒa
)

297 
	`as£¹
 (
TLP”missiÚs
.
	`isC­
(
bundË
.
·¿m
), "'D' chªÃÈG¿ÁD©¨ÿ¼› šv®id c­…¬am" + 
exŒa
)

298 
	`as£¹
 (
bundË
.
·¿m
 =/ğ
TLP”missiÚs
.
toN
, "'D' chªÃÈG¿ÁD©¨ÿ¼› toN…¬am" + 
exŒa
)

299 
	`as£¹
 (!
bundË
.
d’›d
 || bundË.
cÜru±
, "'D' chªÃÈG¿ÁD©¨i d’›d buˆnÙ cÜru±" + 
exŒa
)

300 
	`as£¹
 (
d’y_g‘_ok
 || !
bundË
.
d’›d
, "'D' chªÃÈG¿ÁD©¨i d’›d" + 
exŒa
)

303 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
AcûssAck
) {

304 
	`as£¹
 (
sourû_ok
, "'D' chªÃÈAcûssAck c¬r› šv®id sourû ID" + 
exŒa
)

306 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'D' chªÃÈAcûssAck c¬r› šv®id…¬am" + 
exŒa
)

307 
	`as£¹
 (!
bundË
.
cÜru±
, "'D' chªÃÈAcûssAck i cÜru±" + 
exŒa
)

308 
	`as£¹
 (
d’y_put_ok
 || !
bundË
.
d’›d
, "'D' chªÃÈAcûssAck i d’›d" + 
exŒa
)

311 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
AcûssAckD©a
) {

312 
	`as£¹
 (
sourû_ok
, "'D' chªÃÈAcûssAckD©¨ÿ¼› šv®id sourû ID" + 
exŒa
)

314 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'D' chªÃÈAcûssAckD©¨ÿ¼› šv®id…¬am" + 
exŒa
)

315 
	`as£¹
 (!
bundË
.
d’›d
 || bundË.
cÜru±
, "'D' chªÃÈAcûssAckD©¨i d’›d buˆnÙ cÜru±" + 
exŒa
)

316 
	`as£¹
 (
d’y_g‘_ok
 || !
bundË
.
d’›d
, "'D' chªÃÈAcûssAckD©¨i d’›d" + 
exŒa
)

319 
	`wh’
 (
bundË
.
İcode
 ==ğ
TLMes§ges
.
HštAck
) {

320 
	`as£¹
 (
sourû_ok
, "'D' chªÃÈHštAck c¬r› šv®id sourû ID" + 
exŒa
)

322 
	`as£¹
 (
bundË
.
·¿m
 ==ğ
	`UIÁ
(0), "'D' chªÃÈHštAck c¬r› šv®id…¬am" + 
exŒa
)

323 
	`as£¹
 (!
bundË
.
cÜru±
, "'D' chªÃÈHštAck i cÜru±" + 
exŒa
)

324 
	`as£¹
 (
d’y_put_ok
 || !
bundË
.
d’›d
, "'D' chªÃÈHštAck i d’›d" + 
exŒa
)

326 
	}
}

328 
def
 
	$Ëg®izeFÜm©E
(
bundË
: 
TLBundËE
, 
edge
: 
TLEdge
) {

329 
v®
 
sšk_ok
 = 
bundË
.
sšk
 < 
	`UIÁ
(
edge
.
mªag”
.
’dSškId
)

330 
	`as£¹
 (
sšk_ok
, "'E' chªÃl ÿ¼› šv®id sšk ID" + 
exŒa
)

331 
	}
}

333 
def
 
Ëg®izeFÜm©
(
bundË
: 
TLBundËSnoİ
, 
edge
: 
TLEdge
) = {

334 
wh’
 (
bundË
.
a
.
v®id
è{ 
Ëg®izeFÜm©A
(bundË.a.
b™s
, 
edge
) }

335 
wh’
 (
bundË
.
d
.
v®id
è{ 
Ëg®izeFÜm©D
(bundË.d.
b™s
, 
edge
) }

336 ià(
edge
.
ş›Á
.
ªySuµÜtProbe
 &&ƒdge.
mªag”
.
ªySuµÜtAcquœeB
) {

337 
wh’
 (
bundË
.
b
.
v®id
è{ 
Ëg®izeFÜm©B
(bundË.b.
b™s
, 
edge
) }

338 
wh’
 (
bundË
.
c
.
v®id
è{ 
Ëg®izeFÜm©C
(bundË.c.
b™s
, 
edge
) }

339 
wh’
 (
bundË
.
e
.
v®id
è{ 
Ëg®izeFÜm©E
(bundË.e.
b™s
, 
edge
) }

341 
as£¹
 (!
bundË
.
b
.
v®id
, "'B' chªÃÈv®id‡nd‚Ù TL-C" + 
exŒa
)

342 
as£¹
 (!
bundË
.
c
.
v®id
, "'C' chªÃÈv®id‡nd‚Ù TL-C" + 
exŒa
)

343 
as£¹
 (!
bundË
.
e
.
v®id
, "'E' chªÃÈv®id‡nd‚Ù TL-C" + 
exŒa
)

347 
def
 
	$Ëg®izeMuÉib—tA
(
a
: 
Decou¶edSnoİ
[
TLBundËA
], 
edge
: 
TLEdge
) {

348 
v®
 
a_fœ¡
 = 
edge
.
	`fœ¡
(
a
.
b™s
,‡.
	`fœe
())

349 
v®
 
İcode
 = 
	`Reg
(
	`UIÁ
())

350 
v®
 
·¿m
 = 
	`Reg
(
	`UIÁ
())

351 
v®
 
size
 = 
	`Reg
(
	`UIÁ
())

352 
v®
 
sourû
 = 
	`Reg
(
	`UIÁ
())

353 
v®
 
add»ss
 = 
	`Reg
(
	`UIÁ
())

354 
	`wh’
 (
a
.
v®id
 && !
a_fœ¡
) {

355 
	`as£¹
 (
a
.
b™s
.
İcode
 ==ğİcode, "'A' chªÃÈİcodchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

356 
	`as£¹
 (
a
.
b™s
.
·¿m
 ==ğ·¿m, "'A' chªÃÈ·¿m chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

357 
	`as£¹
 (
a
.
b™s
.
size
 ==ğsize, "'A' chªÃÈsizchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

358 
	`as£¹
 (
a
.
b™s
.
sourû
 ==ğsourû, "'A' chªÃÈsourû chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

359 
	`as£¹
 (
a
.
b™s
.
add»ss
==ğadd»ss,"'A' chªÃÈadd»s chªged w™h muÉib—ˆİ”©iÚ" + 
exŒa
)

361 
	`wh’
 (
a
.
	`fœe
(è&& 
a_fœ¡
) {

362 
İcode
 :ğ
a
.
b™s
.opcode

363 
·¿m
 :ğ
a
.
b™s
.param

364 
size
 :ğ
a
.
b™s
.size

365 
sourû
 :ğ
a
.
b™s
.source

366 
add»ss
 :ğ
a
.
b™s
.address

368 
	}
}

370 
def
 
	$Ëg®izeMuÉib—tB
(
b
: 
Decou¶edSnoİ
[
TLBundËB
], 
edge
: 
TLEdge
) {

371 
v®
 
b_fœ¡
 = 
edge
.
	`fœ¡
(
b
.
b™s
, b.
	`fœe
())

372 
v®
 
İcode
 = 
	`Reg
(
	`UIÁ
())

373 
v®
 
·¿m
 = 
	`Reg
(
	`UIÁ
())

374 
v®
 
size
 = 
	`Reg
(
	`UIÁ
())

375 
v®
 
sourû
 = 
	`Reg
(
	`UIÁ
())

376 
v®
 
add»ss
 = 
	`Reg
(
	`UIÁ
())

377 
	`wh’
 (
b
.
v®id
 && !
b_fœ¡
) {

378 
	`as£¹
 (
b
.
b™s
.
İcode
 ==ğİcode, "'B' chªÃÈİcodchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

379 
	`as£¹
 (
b
.
b™s
.
·¿m
 ==ğ·¿m, "'B' chªÃÈ·¿m chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

380 
	`as£¹
 (
b
.
b™s
.
size
 ==ğsize, "'B' chªÃÈsizchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

381 
	`as£¹
 (
b
.
b™s
.
sourû
 ==ğsourû, "'B' chªÃÈsourû chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

382 
	`as£¹
 (
b
.
b™s
.
add»ss
==ğadd»ss,"'B' chªÃÈadd»ss chªged w™h muÉib—ˆİ”©iÚ" + 
exŒa
)

384 
	`wh’
 (
b
.
	`fœe
(è&& 
b_fœ¡
) {

385 
İcode
 :ğ
b
.
b™s
.opcode

386 
·¿m
 :ğ
b
.
b™s
.param

387 
size
 :ğ
b
.
b™s
.size

388 
sourû
 :ğ
b
.
b™s
.source

389 
add»ss
 :ğ
b
.
b™s
.address

391 
	}
}

393 
def
 
	$Ëg®izeMuÉib—tC
(
c
: 
Decou¶edSnoİ
[
TLBundËC
], 
edge
: 
TLEdge
) {

394 
v®
 
c_fœ¡
 = 
edge
.
	`fœ¡
(
c
.
b™s
, c.
	`fœe
())

395 
v®
 
İcode
 = 
	`Reg
(
	`UIÁ
())

396 
v®
 
·¿m
 = 
	`Reg
(
	`UIÁ
())

397 
v®
 
size
 = 
	`Reg
(
	`UIÁ
())

398 
v®
 
sourû
 = 
	`Reg
(
	`UIÁ
())

399 
v®
 
add»ss
 = 
	`Reg
(
	`UIÁ
())

400 
	`wh’
 (
c
.
v®id
 && !
c_fœ¡
) {

401 
	`as£¹
 (
c
.
b™s
.
İcode
 ==ğİcode, "'C' chªÃÈİcodchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

402 
	`as£¹
 (
c
.
b™s
.
·¿m
 ==ğ·¿m, "'C' chªÃÈ·¿m chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

403 
	`as£¹
 (
c
.
b™s
.
size
 ==ğsize, "'C' chªÃÈsizchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

404 
	`as£¹
 (
c
.
b™s
.
sourû
 ==ğsourû, "'C' chªÃÈsourû chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

405 
	`as£¹
 (
c
.
b™s
.
add»ss
==ğadd»ss,"'C' chªÃÈadd»s chªged w™h muÉib—ˆİ”©iÚ" + 
exŒa
)

407 
	`wh’
 (
c
.
	`fœe
(è&& 
c_fœ¡
) {

408 
İcode
 :ğ
c
.
b™s
.opcode

409 
·¿m
 :ğ
c
.
b™s
.param

410 
size
 :ğ
c
.
b™s
.size

411 
sourû
 :ğ
c
.
b™s
.source

412 
add»ss
 :ğ
c
.
b™s
.address

414 
	}
}

416 
def
 
	$Ëg®izeMuÉib—tD
(
d
: 
Decou¶edSnoİ
[
TLBundËD
], 
edge
: 
TLEdge
) {

417 
v®
 
d_fœ¡
 = 
edge
.
	`fœ¡
(
d
.
b™s
, d.
	`fœe
())

418 
v®
 
İcode
 = 
	`Reg
(
	`UIÁ
())

419 
v®
 
·¿m
 = 
	`Reg
(
	`UIÁ
())

420 
v®
 
size
 = 
	`Reg
(
	`UIÁ
())

421 
v®
 
sourû
 = 
	`Reg
(
	`UIÁ
())

422 
v®
 
sšk
 = 
	`Reg
(
	`UIÁ
())

423 
v®
 
d’›d
 = 
	`Reg
(
	`BoŞ
())

424 
	`wh’
 (
d
.
v®id
 && !
d_fœ¡
) {

425 
	`as£¹
 (
d
.
b™s
.
İcode
 ==ğİcode, "'D' chªÃÈİcodchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

426 
	`as£¹
 (
d
.
b™s
.
·¿m
 ==ğ·¿m, "'D' chªÃÈ·¿m chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

427 
	`as£¹
 (
d
.
b™s
.
size
 ==ğsize, "'D' chªÃÈsizchªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

428 
	`as£¹
 (
d
.
b™s
.
sourû
 ==ğsourû, "'D' chªÃÈsourû chªged w™hš muÉib—ˆİ”©iÚ" + 
exŒa
)

429 
	`as£¹
 (
d
.
b™s
.
sšk
 ==ğsšk, "'D' chªÃÈsšk chªged w™h muÉib—ˆİ”©iÚ" + 
exŒa
)

430 
	`as£¹
 (
d
.
b™s
.
d’›d
 ==ğd’›d, "'D' chªÃÈd’›d chªged w™h muÉib—ˆİ”©iÚ" + 
exŒa
)

432 
	`wh’
 (
d
.
	`fœe
(è&& 
d_fœ¡
) {

433 
İcode
 :ğ
d
.
b™s
.opcode

434 
·¿m
 :ğ
d
.
b™s
.param

435 
size
 :ğ
d
.
b™s
.size

436 
sourû
 :ğ
d
.
b™s
.source

437 
sšk
 :ğ
d
.
b™s
.sink

438 
d’›d
 :ğ
d
.
b™s
.denied

440 
	}
}

442 
def
 
	$Ëg®izeMuÉib—t
(
bundË
: 
TLBundËSnoİ
, 
edge
: 
TLEdge
) {

443 
	`Ëg®izeMuÉib—tA
(
bundË
.
a
, 
edge
)

444 
	`Ëg®izeMuÉib—tD
(
bundË
.
d
, 
edge
)

445 ià(
edge
.
ş›Á
.
ªySuµÜtProbe
 &&ƒdge.
mªag”
.
ªySuµÜtAcquœeB
) {

446 
	`Ëg®izeMuÉib—tB
(
bundË
.
b
, 
edge
)

447 
	`Ëg®izeMuÉib—tC
(
bundË
.
c
, 
edge
)

449 
	}
}

451 
def
 
	$Ëg®izeADSourû
(
bundË
: 
TLBundËSnoİ
, 
edge
: 
TLEdge
) {

452 
v®
 
šæight
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
edge
.
ş›Á
.
’dSourûId
))

454 
v®
 
a_fœ¡
 = 
edge
.
	`fœ¡
(
bundË
.
a
.
b™s
, bundË.a.
	`fœe
())

455 
v®
 
d_fœ¡
 = 
edge
.
	`fœ¡
(
bundË
.
d
.
b™s
, bundË.d.
	`fœe
())

457 
v®
 
a_£t
 = 
	`Wœe
(
š™
 = 
	`UIÁ
(0, 
width
 = 
edge
.
ş›Á
.
’dSourûId
))

458 
	`wh’
 (
bundË
.
a
.
	`fœe
(è&& 
a_fœ¡
 && 
edge
.
	`isReque¡
(bundË.a.
b™s
)) {

459 
a_£t
 :ğ
	`UIÁToOH
(
bundË
.
a
.
b™s
.
sourû
)

460 
	`as£¹
(!
	`šæight
(
bundË
.
a
.
b™s
.
sourû
), "'A' chªÃÈ»-u£d‡ sourû ID" + 
exŒa
)

463 
v®
 
d_şr
 = 
	`Wœe
(
š™
 = 
	`UIÁ
(0, 
width
 = 
edge
.
ş›Á
.
’dSourûId
))

464 
v®
 
d_»Ëa£_ack
 = 
bundË
.
d
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
R–—£Ack


465 
	`wh’
 (
bundË
.
d
.
	`fœe
(è&& 
d_fœ¡
 && 
edge
.
	`isRe¥Ú£
(bundË.d.
b™s
è&& !
d_»Ëa£_ack
) {

466 
d_şr
 :ğ
	`UIÁToOH
(
bundË
.
d
.
b™s
.
sourû
)

467 
	`as£¹
((
a_£t
 | 
šæight
)(
bundË
.
d
.
b™s
.
sourû
), "'D' chªÃÈacknowËdged fÜ‚Ùhšg inæight" + 
exŒa
)

470 ià(
edge
.
mªag”
.
mšL©’cy
 > 0) {

471 
	`as£¹
(
a_£t
 =/ğ
d_şr
 || !a_£t.
ÜR
, 
s
"'A'‡nd 'D' cÚcu¼’t, de¥™mšÏ‹ncy ${edge.mªag”.mšL©’cy}" + 
exŒa
)

474 
šæight
 :ğ(šæighˆ| 
a_£t
è& ~
d_şr


476 
v®
 
w©chdog
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 32))

477 
v®
 
lim™
 = 
	`PlusArg
("tilelink_timeout",

478 
doc¡ršg
="Killƒmulation‡fter INT waiting TileLink cycles. Off if 0.")

479 
	`as£¹
 (!
šæight
.
ÜR
 || 
lim™
 ==ğ
	`UIÁ
(0è|| 
w©chdog
 <†im™, "TeLškimeouˆexpœed" + 
exŒa
)

481 
w©chdog
 :ğw©chdog + 
	`UIÁ
(1)

482 
	`wh’
 (
bundË
.
a
.
	`fœe
(è|| bundË.
d
.fœe()è{ 
w©chdog
 :ğ
	`UIÁ
(0) }

483 
	}
}

485 
def
 
	$Ëg®izeDESšk
(
bundË
: 
TLBundËSnoİ
, 
edge
: 
TLEdge
) {

486 
v®
 
šæight
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
edge
.
mªag”
.
’dSškId
))

488 
v®
 
d_fœ¡
 = 
edge
.
	`fœ¡
(
bundË
.
d
.
b™s
, bundË.d.
	`fœe
())

489 
v®
 
e_fœ¡
 = 
	`BoŞ
(
Œue
)

491 
v®
 
d_£t
 = 
	`Wœe
(
š™
 = 
	`UIÁ
(0, 
width
 = 
edge
.
mªag”
.
’dSškId
))

492 
	`wh’
 (
bundË
.
d
.
	`fœe
(è&& 
d_fœ¡
 && 
edge
.
	`isReque¡
(bundË.d.
b™s
)) {

493 
d_£t
 :ğ
	`UIÁToOH
(
bundË
.
d
.
b™s
.
sšk
)

494 
	`as£¹
(!
	`šæight
(
bundË
.
d
.
b™s
.
sšk
), "'D' chªÃÈ»-u£d‡ sšk ID" + 
exŒa
)

497 
v®
 
e_şr
 = 
	`Wœe
(
š™
 = 
	`UIÁ
(0, 
width
 = 
edge
.
mªag”
.
’dSškId
))

498 
	`wh’
 (
bundË
.
e
.
	`fœe
(è&& 
e_fœ¡
 && 
edge
.
	`isRe¥Ú£
(bundË.e.
b™s
)) {

499 
e_şr
 :ğ
	`UIÁToOH
(
bundË
.
e
.
b™s
.
sšk
)

500 
	`as£¹
((
d_£t
 | 
šæight
)(
bundË
.
e
.
b™s
.
sšk
), "'E' chªÃÈacknowËdged fÜ‚Ùhšg inæight" + 
exŒa
)

505 
šæight
 :ğ(šæighˆ| 
d_£t
è& ~
e_şr


506 
	}
}

508 
def
 
	$Ëg®izeUnique
(
bundË
: 
TLBundËSnoİ
, 
edge
: 
TLEdge
) {

509 
v®
 
sourûB™s
 = 
	`log2Ce
(
edge
.
ş›Á
.
’dSourûId
)

510 
v®
 
tooBig
 = 14

511 ià(
sourûB™s
 > 
tooBig
) {

512 
	`´šn
(
s
"WARNING: TLMonitor instantiated on‡ bus with source bits (${sourceBits}) > ${tooBig}; A=>Dransaction flight will‚ot be checked")

514 
	`Ëg®izeADSourû
(
bundË
, 
edge
)

516 ià(
edge
.
ş›Á
.
ªySuµÜtProbe
 &&ƒdge.
mªag”
.
ªySuµÜtAcquœeB
) {

518 
v®
 
sškB™s
 = 
	`log2Ce
(
edge
.
mªag”
.
’dSškId
)

519 ià(
sškB™s
 > 
tooBig
) {

520 
	`´šn
(
s
"WARNING: TLMonitor instantiated on‡ bus with sink bits (${sinkBits}) > ${tooBig}; D=>Eransaction flight will‚ot be checked")

522 
	`Ëg®izeDESšk
(
bundË
, 
edge
)

525 
	}
}

527 
def
 
	$Ëg®ize
(
bundË
: 
TLBundËSnoİ
, 
edge
: 
TLEdge
, 
»£t
: 
BoŞ
) {

528 
	`Ëg®izeFÜm©
 (
bundË
, 
edge
)

529 
	`Ëg®izeMuÉib—t
(
bundË
, 
edge
)

530 
	`Ëg®izeUnique
 (
bundË
, 
edge
)

531 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/NodeNumberer.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
şass
 
	$TLNodeNumb””Node
(
nodeAdd»ssOff£t
: 
O±iÚ
[
IÁ
] = 
NÚe
)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
TLCu¡omNode


11 
def
 
	`»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

12 
	`»quœe
 (
oSrs
 + 
iSrs
 <ğ1, 
s
"${name} (a custom‡dapter)‡ppears†eft of‡ :*= ${iStars}imes‡nd„ight of‡ :=* ${oStars}imes;‡t most once is‡llowed${lazyModule.line}")

13 ià(
oSrs
 > 0) {

14 
	`»quœe
 (
iKnown
 >ğ
oKnown
, 
s
"${name} (a custom‡dapter) has ${oKnown} outputs‡nd ${iKnown} inputs; cannot‡ssign ${iKnown-oKnown}ƒdgeso„esolve :=*${lazyModule.line}")

15 (0, 
iKnown
 - 
oKnown
)

17 
	`»quœe
 (
oKnown
 >ğ
iKnown
, 
s
"${name} (a custom‡dapter) has ${oKnown} outputs‡nd ${iKnown} inputs; cannot‡ssign ${oKnown-iKnown}ƒdgeso„esolve :*=${lazyModule.line}")

18 (
oKnown
 - 
iKnown
, 0)

22 
def
 
	`m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
]): Seq[TLClientPortParameters] = {

23 
	`»quœe
(
n
 =ğ
p
.
size
, 
s
"${name} has ${p.size} inputs‡nd ${n} outputs;hey must match${lazyModule.line}")

24 
p


27 
def
 
	`m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
TLMªag”PÜtP¬am‘”s
]): Seq[TLManagerPortParameters] = {

28 
	`»quœe
(
n
 =ğ
p
.
size
, 
s
"${name} has ${n} inputs‡nd ${p.size} outputs;hey must match${lazyModule.line}")

29 
v®
 
mšNodeOff£t
 = 
	`log2Ce
(
p
.
	`m­
(
_
.
maxAdd»ss
).
max
)

30 
v®
 
nodeOff£t
 = 
nodeAdd»ssOff£t
.
	`g‘OrEl£
(
mšNodeOff£t
)

31 
	`»quœe
 (
nodeOff£t
 >ğ
mšNodeOff£t
)

33 
p
.
zW™hIndex
.
m­
 { (
mp
, 
i
) =>

34 
v®
 
nodeIndex
 = 
	`BigIÁ
(
i
+1è<< 
nodeOff£t


35 
mp
.
	`cİy
(
mªag”s
 = mp.mªag”s.
	`m­
(
m
 => m.cİy(
add»ss
 = m.add»ss.m­(
a
 =>‡.cİy(
ba£
 =‡.ba£ | 
nodeIndex
)))))

38 
	}
}

40 
şass
 
	$TLNodeNumb””
(
nodeAdd»ssOff£t
: 
O±iÚ
[
IÁ
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


42 
v®
 
node
 = 
	`TLNodeNumb””Node
(
nodeAdd»ssOff£t
)

44 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

45 
v®
 
mšNodeOff£t
 = 
	`log2Ce
(
node
.
edges
.
out
.
	`m­
(
_
.
mªag”
.
maxAdd»ss
).
max
)

46 
v®
 
nodeOff£t
 = 
nodeAdd»ssOff£t
.
	`g‘OrEl£
(
mšNodeOff£t
)

48 (
node
.
š
 
z
‚ode.
out
).
zW™hIndex
 
fÜ—ch
 { (((š, 
_
), (out, _)), 
i
) =>

49 
out
 <> 
š


51 
š
.
b
.
b™s
.
add»ss
 :ğ(
	`UIÁ
(
i
+1è<< 
nodeOff£t
è| 
out
.b.bits.address

54 
	}
}

56 
objeù
 
TLNodeNumb””


58 
def
 
­¶y
(
nodeAdd»ssOff£t
: 
O±iÚ
[
IÁ
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

60 
v®
 
numb””
 = 
LazyModuË
(
Ãw
 
TLNodeNumb””
(
nodeAdd»ssOff£t
))

61 
numb””
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Nodes.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gAsyncQueueP¬ams
,
	gR©iÚ®DœeùiÚ
}

10 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.
Li¡Bufãr


12 
objeù
 
TLMÚ™ÜBud”
 
ex‹nds
 
	gF›ld
[
TLMÚ™ÜArgs
 => 
TLMÚ™ÜBa£
](
¬gs
 => 
Ãw
 
	$TLMÚ™Ü
(
¬gs
))

14 
objeù
 
TLImp
 
ex‹nds
 
NodeImp
[
TLCl›ÁPÜtP¬am‘”s
, 
TLMªag”PÜtP¬am‘”s
, 
TLEdgeOut
, 
TLEdgeIn
, 
TLBundË
]

16 
def
 
	`edgeO
(
pd
: 
TLCl›ÁPÜtP¬am‘”s
, 
pu
: 
TLMªag”PÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
Ãw
 
	`TLEdgeOut
(pd,…u,…, sourceInfo)

17 
def
 
	`edgeI
(
pd
: 
TLCl›ÁPÜtP¬am‘”s
, 
pu
: 
TLMªag”PÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
Ãw
 
	`TLEdgeIn
 (pd,…u,…, sourceInfo)

19 
def
 
	`bundËO
(
eo
: 
TLEdgeOut
èğ
	`TLBundË
Óo.
bundË
)

20 
def
 
	`bundËI
(
ei
: 
TLEdgeIn
èğ
	`TLBundË
Ói.
bundË
)

22 
def
 
	`»nd”
(
ei
: 
TLEdgeIn
èğ
	`R’d”edEdge
(
cŞour
 = "#000000" , 
Ïb–
 = (ei.
mªag”
.
b—tBy‹s
 * 8).
toSŒšg
)

24 
ov”ride
 
def
 
	`mÚ™Ü
(
bundË
: 
TLBundË
, 
edge
: 
TLEdgeIn
) {

25 
v®
 
mÚ™Ü
 = 
	`ModuË
(
edge
.
	`·¿ms
(
TLMÚ™ÜBud”
)(
	`TLMÚ™ÜArgs
(edge)))

26 
mÚ™Ü
.
io
.
š
 :ğ
	`TLBundËSnoİ
(
bundË
, bundle)

29 
ov”ride
 
def
 
	`mixO
(
pd
: 
TLCl›ÁPÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[TLCl›ÁPÜtP¬am‘”s, 
TLMªag”PÜtP¬am‘”s
, 
TLBundË
]): TLClientPortParameters =

30 
pd
.
	`cİy
(
ş›Ás
 =…d.ş›Ás.
m­
 { 
c
 => c.cİy (
nodeP©h
 = 
node
 +: c.nodePath) })

31 
ov”ride
 
def
 
	`mixI
(
pu
: 
TLMªag”PÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
TLCl›ÁPÜtP¬am‘”s
, TLMªag”PÜtP¬am‘”s, 
TLBundË
]): TLManagerPortParameters =

32 
pu
.
	`cİy
(
mªag”s
 =…u.mªag”s.
m­
 { 
m
 => m.cİy (
nodeP©h
 = 
node
 +: m.nodePath) })

33 
	}
}

35 
şass
 
	$TLCl›ÁNode
(
pÜtP¬ams
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SourûNode
(
TLImp
)(
pÜtP¬ams
)

36 
şass
 
	$TLMªag”Node
(
pÜtP¬ams
: 
Seq
[
TLMªag”PÜtP¬am‘”s
])(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$SškNode
(
TLImp
)(
pÜtP¬ams
)

38 
şass
 
	`TLAd­‹rNode
(

39 
ş›ÁFn
: 
TLCl›ÁPÜtP¬am‘”s
 => TLCl›ÁPÜtP¬am‘” ğ{ 
s
 => s 
	}
},

40 
	gmªag”Fn
: 
TLMªag”PÜtP¬am‘”s
 => TLMªag”PÜtP¬am‘” ğ{ 
s
 => s })(

41 
im¶ic™
 
v®Name
: 
V®Name
)

42 
ex‹nds
 
	$Ad­‹rNode
(
TLImp
)(
ş›ÁFn
, 
mªag”Fn
)

44 şas 
	cTLId’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$Id’t™yNode
(
TLImp
)()

46 
objeù
 
TLNameNode
 {

47 
def
 
	`­¶y
(
Çme
: 
V®Name
èğ
	$TLId’t™yNode
()(
Çme
)

48 
def
 
	$­¶y
(
Çme
: 
O±iÚ
[
SŒšg
]): 
TLId’t™yNode
 = 
	`­¶y
(
	`V®Name
Òame.
	`g‘OrEl£
("with_no_name")))

49 
def
 
	$­¶y
(
Çme
: 
SŒšg
): 
TLId’t™yNode
 = 
	`­¶y
(
	`Some
(name))

52 
şass
 
	`TLNexusNode
(

53 
ş›ÁFn
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
] => TLClientPortParameters,

54 
mªag”Fn
: 
Seq
[
TLMªag”PÜtP¬am‘”s
] => TLManagerPortParameters)(

55 
im¶ic™
 
v®Name
: 
V®Name
)

56 
ex‹nds
 
	$NexusNode
(
TLImp
)(
ş›ÁFn
, 
mªag”Fn
)

58 
ab¡¿ù
 
şass
 
	$TLCu¡omNode
(
im¶ic™
 
v®Name
: 
V®Name
)

59 
ex‹nds
 
	$Cu¡omNode
(
TLImp
)

63 
objeù
 
TLAsyncImp
 
ex‹nds
 
Sim¶eNodeImp
[
TLAsyncCl›ÁPÜtP¬am‘”s
, 
TLAsyncMªag”PÜtP¬am‘”s
, 
TLAsyncEdgeP¬am‘”s
, 
TLAsyncBundË
]

65 
def
 
	`edge
(
pd
: 
TLAsyncCl›ÁPÜtP¬am‘”s
, 
pu
: 
TLAsyncMªag”PÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
	`TLAsyncEdgeP¬am‘”s
(pd,…u,…, sourceInfo)

66 
def
 
	`bundË
(
e
: 
TLAsyncEdgeP¬am‘”s
èğ
Ãw
 
	`TLAsyncBundË
Ó.
bundË
)

67 
def
 
	`»nd”
(
e
: 
TLAsyncEdgeP¬am‘”s
èğ
	`R’d”edEdge
(
cŞour
 = "#ff0000" , 
Ïb–
 =ƒ.
mªag”
.
async
.
d•th
.
toSŒšg
)

69 
ov”ride
 
def
 
	`mixO
(
pd
: 
TLAsyncCl›ÁPÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[TLAsyncCl›ÁPÜtP¬am‘”s, 
TLAsyncMªag”PÜtP¬am‘”s
, 
TLAsyncBundË
]): TLAsyncClientPortParameters =

70 
pd
.
	`cİy
(
ba£
 =…d.ba£.cİy(
ş›Ás
 =…d.ba£.ş›Ás.
m­
 { 
c
 => c.cİy (
nodeP©h
 = 
node
 +: c.nodePath) }))

71 
ov”ride
 
def
 
	`mixI
(
pu
: 
TLAsyncMªag”PÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
TLAsyncCl›ÁPÜtP¬am‘”s
, TLAsyncMªag”PÜtP¬am‘”s, 
TLAsyncBundË
]): TLAsyncManagerPortParameters =

72 
pu
.
	`cİy
(
ba£
 =…u.ba£.cİy(
mªag”s
 =…u.ba£.mªag”s.
m­
 { 
m
 => m.cİy (
nodeP©h
 = 
node
 +: m.nodePath) }))

73 
	}
}

75 
şass
 
TLAsyncAd­‹rNode
(

76 
ş›ÁFn
: 
TLAsyncCl›ÁPÜtP¬am‘”s
 => TLAsyncCl›ÁPÜtP¬am‘” ğ{ 
s
 => s },

77 
mªag”Fn
: 
TLAsyncMªag”PÜtP¬am‘”s
 => TLAsyncMªag”PÜtP¬am‘” ğ{ 
s
 => s })(

78 
im¶ic™
 
v®Name
: 
V®Name
)

79 
ex‹nds
 
	$Ad­‹rNode
(
TLAsyncImp
)(
ş›ÁFn
, 
mªag”Fn
)

81 şas 
	cTLAsyncId’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$Id’t™yNode
(
TLAsyncImp
)()

83 
objeù
 
TLAsyncNameNode
 {

84 
def
 
	`­¶y
(
Çme
: 
V®Name
èğ
	$TLAsyncId’t™yNode
()(
Çme
)

85 
def
 
	$­¶y
(
Çme
: 
O±iÚ
[
SŒšg
]): 
TLAsyncId’t™yNode
 = 
	`­¶y
(
	`V®Name
Òame.
	`g‘OrEl£
("with_no_name")))

86 
def
 
	$­¶y
(
Çme
: 
SŒšg
): 
TLAsyncId’t™yNode
 = 
	`­¶y
(
	`Some
(name))

89 
şass
 
	$TLAsyncSourûNode
(
sync
: 
O±iÚ
[
IÁ
])(
im¶ic™
 
v®Name
: 
V®Name
)

90 
ex‹nds
 
	$MixedAd­‹rNode
(
TLImp
, 
TLAsyncImp
)(

91 
dFn
 = { 
p
 => 
	`TLAsyncCl›ÁPÜtP¬am‘”s
Õè
	}
},

92 
	guFn
 = { 
p
 =>….
ba£
.
cİy
(
mšL©’cy
 =….ba£.mšL©’cy + 
sync
.
g‘OrEl£
Õ.
async
.sync)) })

94 
şass
 
	$TLAsyncSškNode
(
async
: 
AsyncQueueP¬ams
)(
im¶ic™
 
v®Name
: 
V®Name
)

95 
ex‹nds
 
	$MixedAd­‹rNode
(
TLAsyncImp
, 
TLImp
)(

96 
dFn
 = { 
p
 =>….
ba£
.
	`cİy
(
mšL©’cy
 =….ba£.mšL©’cy + 
async
.
sync
è
	}
},

97 
	guFn
 = { 
p
 => 
TLAsyncMªag”PÜtP¬am‘”s
(
async
,…) })

101 
objeù
 
TLR©iÚ®Imp
 
ex‹nds
 
	gSim¶eNodeImp
[
TLR©iÚ®Cl›ÁPÜtP¬am‘”s
, 
TLR©iÚ®Mªag”PÜtP¬am‘”s
, 
TLR©iÚ®EdgeP¬am‘”s
, 
TLR©iÚ®BundË
]

103 
def
 
edge
(
pd
: 
TLR©iÚ®Cl›ÁPÜtP¬am‘”s
, 
pu
: 
TLR©iÚ®Mªag”PÜtP¬am‘”s
, 
p
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
èğ
TLR©iÚ®EdgeP¬am‘”s
(pd,…u,…, sourceInfo)

104 
def
 
bundË
(
e
: 
TLR©iÚ®EdgeP¬am‘”s
èğ
Ãw
 
TLR©iÚ®BundË
(e.bundle)

105 
def
 
»nd”
(
e
: 
TLR©iÚ®EdgeP¬am‘”s
èğ
R’d”edEdge
(
cŞour
 = "#00ff00" )

107 
ov”ride
 
def
 
mixO
(
pd
: 
TLR©iÚ®Cl›ÁPÜtP¬am‘”s
, 
node
: 
Outw¬dNode
[TLR©iÚ®Cl›ÁPÜtP¬am‘”s, 
TLR©iÚ®Mªag”PÜtP¬am‘”s
, 
TLR©iÚ®BundË
]): TLRationalClientPortParameters =

108 
pd
.
cİy
(
ba£
 =…d.ba£.cİy(
ş›Ás
 =…d.ba£.ş›Ás.
m­
 { 
c
 => c.cİy (
nodeP©h
 = 
node
 +: c.nodePath) }))

109 
ov”ride
 
def
 
mixI
(
pu
: 
TLR©iÚ®Mªag”PÜtP¬am‘”s
, 
node
: 
Inw¬dNode
[
TLR©iÚ®Cl›ÁPÜtP¬am‘”s
, TLR©iÚ®Mªag”PÜtP¬am‘”s, 
TLR©iÚ®BundË
]): TLRationalManagerPortParameters =

110 
pu
.
cİy
(
ba£
 =…u.ba£.cİy(
mªag”s
 =…u.ba£.mªag”s.
m­
 { 
m
 => m.cİy (
nodeP©h
 = 
node
 +: m.nodePath) }))

113 
şass
 
TLR©iÚ®Ad­‹rNode
(

114 
ş›ÁFn
: 
TLR©iÚ®Cl›ÁPÜtP¬am‘”s
 => TLR©iÚ®Cl›ÁPÜtP¬am‘” ğ{ 
s
 => s },

115 
mªag”Fn
: 
TLR©iÚ®Mªag”PÜtP¬am‘”s
 => TLR©iÚ®Mªag”PÜtP¬am‘” ğ{ 
s
 => s })(

116 
im¶ic™
 
v®Name
: 
V®Name
)

117 
ex‹nds
 
	$Ad­‹rNode
(
TLR©iÚ®Imp
)(
ş›ÁFn
, 
mªag”Fn
)

119 şas 
	cTLR©iÚ®Id’t™yNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$Id’t™yNode
(
TLR©iÚ®Imp
)()

121 
objeù
 
TLR©iÚ®NameNode
 {

122 
def
 
	`­¶y
(
Çme
: 
V®Name
èğ
	$TLR©iÚ®Id’t™yNode
()(
Çme
)

123 
def
 
	$­¶y
(
Çme
: 
O±iÚ
[
SŒšg
]): 
TLR©iÚ®Id’t™yNode
 = 
	`­¶y
(
	`V®Name
Òame.
	`g‘OrEl£
("with_no_name")))

124 
def
 
	$­¶y
(
Çme
: 
SŒšg
): 
TLR©iÚ®Id’t™yNode
 = 
	`­¶y
(
	`Some
(name))

127 
şass
 
	$TLR©iÚ®SourûNode
()(
im¶ic™
 
v®Name
: 
V®Name
)

128 
ex‹nds
 
	$MixedAd­‹rNode
(
TLImp
, 
TLR©iÚ®Imp
)(

129 
dFn
 = { 
p
 => 
	`TLR©iÚ®Cl›ÁPÜtP¬am‘”s
Õè
	}
},

130 
	guFn
 = { 
p
 =>….
ba£
.
cİy
(
mšL©’cy
 = 1) })

132 
şass
 
	$TLR©iÚ®SškNode
(
dœeùiÚ
: 
R©iÚ®DœeùiÚ
)(
im¶ic™
 
v®Name
: 
V®Name
)

133 
ex‹nds
 
	$MixedAd­‹rNode
(
TLR©iÚ®Imp
, 
TLImp
)(

134 
dFn
 = { 
p
 =>….
ba£
.
	`cİy
(
mšL©’cy
 = 1è
	}
},

135 
	guFn
 = { 
p
 => 
TLR©iÚ®Mªag”PÜtP¬am‘”s
(
dœeùiÚ
,…) })

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Parameters.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gR©iÚ®DœeùiÚ
,
	gAsyncQueueP¬ams
}

10 
impÜt
 
	gsÿÏ
.
	gm©h
.
max


12 
şass
 
TLMªag”P¬am‘”s
(

13 
add»ss
: 
Seq
[
Add»ssS‘
],

14 
»sourûs
: 
Seq
[
Resourû
] = Seq(),

15 
»giÚTy³
: 
RegiÚTy³
.
T
 = RegiÚTy³.
GET_EFFECTS
,

16 
execubË
: 
BoŞ—n
 = 
çl£
,

17 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

19 
suµÜtsAcquœeT
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

20 
suµÜtsAcquœeB
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

21 
suµÜtsAr™hm‘ic
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

22 
suµÜtsLogiÿl
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

23 
suµÜtsG‘
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

24 
suµÜtsPutFuÎ
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

25 
suµÜtsPutP¬tŸl
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

26 
suµÜtsHšt
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

28 
mayD’yG‘
: 
BoŞ—n
 = 
çl£
,

29 
mayD’yPut
: 
BoŞ—n
 = 
çl£
,

31 
®waysG¿ÁsT
: 
BoŞ—n
 = 
çl£
,

34 
fifoId
: 
O±iÚ
[
IÁ
] = 
NÚe
)

36 
»quœe
 (!
add»ss
.
isEm±y
, "Address cannot beƒmpty")

37 
add»ss
.
fÜ—ch
 { 
a
 => 
»quœe
 (a.
fš™e
, "Address must be finite") }

39 
	gadd»ss
.
combš©iÚs
(2).
	gfÜ—ch
 { 
Seq
(
x
,
y
è=> 
»quœe
 (!x.
ov”Ïps
(y), 
s
"$x‡nd $y overlap.") }

40 
»quœe
 (
suµÜtsPutFuÎ
.
cÚšs
(
suµÜtsPutP¬tŸl
), 
s
"PutFull($supportsPutFull) < PutPartial($supportsPutPartial)")

41 
»quœe
 (
suµÜtsPutFuÎ
.
cÚšs
(
suµÜtsAr™hm‘ic
), 
s
"PutFull($supportsPutFull) < Arithmetic($supportsArithmetic)")

42 
»quœe
 (
suµÜtsPutFuÎ
.
cÚšs
(
suµÜtsLogiÿl
), 
s
"PutFull($supportsPutFull) < Logical($supportsLogical)")

43 
»quœe
 (
suµÜtsG‘
.
cÚšs
(
suµÜtsAr™hm‘ic
), 
s
"Get($supportsGet) < Arithmetic($supportsArithmetic)")

44 
»quœe
 (
suµÜtsG‘
.
cÚšs
(
suµÜtsLogiÿl
), 
s
"Get($supportsGet) < Logical($supportsLogical)")

45 
»quœe
 (
suµÜtsAcquœeB
.
cÚšs
(
suµÜtsAcquœeT
), 
s
"AcquireB($supportsAcquireB) < AcquireT($supportsAcquireT)")

46 
»quœe
 (!
®waysG¿ÁsT
 || 
suµÜtsAcquœeT
, 
s
"Must supportAcquireT if…romisingo‡lways grantT")

49 
»quœe
 (!
suµÜtsAcquœeB
 || 
»giÚTy³
 >ğ
RegiÚTy³
.
UNCACHED
)

50 
»quœe
 (
»giÚTy³
 <ğ
RegiÚTy³
.
UNCACHED
 || 
suµÜtsAcquœeB
)

51 
»quœe
 (
»giÚTy³
 !ğ
RegiÚTy³
.
UNCACHED
 || 
suµÜtsG‘
)

53 
v®
 
Çme
 = 
nodeP©h
.
Ï¡O±iÚ
.
m­
(
_
.
ÏzyModuË
.Çme).
g‘OrEl£
("disconnected")

54 
v®
 
maxT¿nsãr
 = 
Li¡
(

55 
suµÜtsAcquœeT
.
max
,

56 
suµÜtsAcquœeB
.
max
,

57 
suµÜtsAr™hm‘ic
.
max
,

58 
suµÜtsLogiÿl
.
max
,

59 
suµÜtsG‘
.
max
,

60 
suµÜtsPutFuÎ
.
max
,

61 
suµÜtsPutP¬tŸl
.
max
).max

62 
v®
 
	gmaxAdd»ss
 = 
add»ss
.
m­
(
_
.
max
).max

63 
v®
 
mšAlignm’t
 = 
add»ss
.
m­
(
_
.
®ignm’t
).
mš


66 
»quœe
 (
mšAlignm’t
 >ğ
maxT¿nsãr
, 
s
"Bad $address: minAlignment ($minAlignment) must be >= maxTransfer ($maxTransfer)")

68 
def
 
	gtoResourû
: 
ResourûAdd»ss
 = {

69 
ResourûAdd»ss
(
add»ss
, 
ResourûP”missiÚs
(

70 
r
 = 
suµÜtsAcquœeB
 || 
suµÜtsG‘
,

71 
w
 = 
suµÜtsAcquœeT
 || 
suµÜtsPutFuÎ
,

72 
x
 = 
execubË
,

73 
c
 = 
suµÜtsAcquœeB
,

74 
a
 = 
suµÜtsAr™hm‘ic
 && 
suµÜtsLogiÿl
))

77 
def
 
fšdT»eViŞ©iÚ
(èğ
nodeP©h
.
fšd
 {

78 
_
: 
MixedAd­‹rNode
[_, _, _, _, _, _, _, _] => 
çl£


79 
_
: 
SškNode
[_, _, _, _, _] => 
çl£


80 
node
 =>‚ode.
šputs
.
size
 != 1

82 
def
 
	gisT»e
 = 
fšdT»eViŞ©iÚ
(è=ğ
NÚe


85 
şass
 
	$TLMªag”PÜtP¬am‘”s
(

86 
mªag”s
: 
Seq
[
TLMªag”P¬am‘”s
],

87 
b—tBy‹s
: 
IÁ
,

88 
’dSškId
: 
IÁ
 = 0,

89 
mšL©’cy
: 
IÁ
 = 0)

91 
	`»quœe
 (!
mªag”s
.
isEm±y
, "Manager…orts must have managers")

92 
	`»quœe
 (
	`isPow2
(
b—tBy‹s
), "Data channel width must be‡…ower of 2")

93 
	`»quœe
 (
’dSškId
 >= 0, "Sink ids cannot be‚egative")

94 
	`»quœe
 (
mšL©’cy
 >= 0, "Minimum„equired†atency cannot be‚egative")

96 
def
 
	`»quœeFifo
(èğ
mªag”s
.
fÜ—ch
 { 
m
 =>

97 
	`»quœe
(
m
.
fifoId
.
isDefšed
 && m.fifoId =ğ
mªag”s
.
h—d
.fifoId, 
s
"${m.name} had fifoId ${m.fifoId}, which was‚ot homogeneous (${managers.map(s => (s.name, s.fifoId))}) ")

101 
def
 
maxAdd»ss
 = 
mªag”s
.
	`m­
(
_
.maxAdd»ss).
max


102 
def
 
maxT¿nsãr
 = 
mªag”s
.
	`m­
(
_
.maxT¿nsãr).
max


103 
def
 
mayD’yG‘
 = 
mªag”s
.
	`exi¡s
(
_
.mayDenyGet)

104 
def
 
mayD’yPut
 = 
mªag”s
.
	`exi¡s
(
_
.mayDenyPut)

107 
v®
 
®lSuµÜtAcquœeT
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsAcquœeT
è.
	`»duû
(_ 
š‹r£ù
 _)

108 
v®
 
®lSuµÜtAcquœeB
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsAcquœeB
è.
	`»duû
(_ 
š‹r£ù
 _)

109 
v®
 
®lSuµÜtAr™hm‘ic
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsAr™hm‘ic
).
	`»duû
(_ 
š‹r£ù
 _)

110 
v®
 
®lSuµÜtLogiÿl
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsLogiÿl
è.
	`»duû
(_ 
š‹r£ù
 _)

111 
v®
 
®lSuµÜtG‘
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsG‘
è.
	`»duû
(_ 
š‹r£ù
 _)

112 
v®
 
®lSuµÜtPutFuÎ
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsPutFuÎ
è.
	`»duû
(_ 
š‹r£ù
 _)

113 
v®
 
®lSuµÜtPutP¬tŸl
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsPutP¬tŸl
).
	`»duû
(_ 
š‹r£ù
 _)

114 
v®
 
®lSuµÜtHšt
 = 
mªag”s
.
	`m­
(
_
.
suµÜtsHšt
è.
	`»duû
(_ 
š‹r£ù
 _)

117 
v®
 
ªySuµÜtAcquœeT
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsAcquœeT
.
nÚe
è.
	`»duû
(_ || _)

118 
v®
 
ªySuµÜtAcquœeB
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsAcquœeB
.
nÚe
è.
	`»duû
(_ || _)

119 
v®
 
ªySuµÜtAr™hm‘ic
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsAr™hm‘ic
.
nÚe
).
	`»duû
(_ || _)

120 
v®
 
ªySuµÜtLogiÿl
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsLogiÿl
.
nÚe
è.
	`»duû
(_ || _)

121 
v®
 
ªySuµÜtG‘
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsG‘
.
nÚe
è.
	`»duû
(_ || _)

122 
v®
 
ªySuµÜtPutFuÎ
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsPutFuÎ
.
nÚe
è.
	`»duû
(_ || _)

123 
v®
 
ªySuµÜtPutP¬tŸl
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsPutP¬tŸl
.
nÚe
).
	`»duû
(_ || _)

124 
v®
 
ªySuµÜtHšt
 = 
mªag”s
.
	`m­
(!
_
.
suµÜtsHšt
.
nÚe
è.
	`»duû
(_ || _)

127 
	`»quœe
 ((
’dSškId
 =ğ0è=ğ!
ªySuµÜtAcquœeB
)

130 
def
 
	`fšd
(
add»ss
: 
BigIÁ
èğ
mªag”s
.fšd(
_
.add»ss.
	`exi¡s
(_.
	`cÚšs
(address)))

133 
def
 
	`fšdSaã
(
add»ss
: 
UIÁ
èğ
	`Vec
(
mªag”s
.
	`m­
(
_
.add»ss.m­(_.
	`cÚšs
×dd»ss)).
	`»duû
(_ || _)))

135 
def
 
	`fšdFa¡
(
add»ss
: 
UIÁ
) = {

136 
v®
 
routšgMask
 = 
	`Add»ssDecod”
(
mªag”s
.
	`m­
(
_
.
add»ss
))

137 
	`Vec
(
mªag”s
.
	`m­
(
_
.
add»ss
.m­(_.
	`wid’
(~
routšgMask
)).
di¡šù
.m­(_.
	`cÚšs
×dd»ss)).
	`»duû
(_ || _)))

141 
def
 
ç¡Prİ”tyGroup
[
K
](
p
: 
TLMªag”P¬am‘”s
 => K): 
M­
[K, 
Seq
[
Add»ssS‘
]] = {

142 
v®
 
groups
 = 
mªag”s
.
	`m­
(
m
 => (
	`p
(m), m.
add»ss
)).
	`groupBy
(
_
.
_1
).
	`m­V®ues
(_.
	`æ©M­
(_.
_2
))

143 
v®
 
»duùiÚMask
 = 
	`Add»ssDecod”
(
groups
.
v®ues
.
toLi¡
)

144 
groups
.
	`m­V®ues
(
£q
 => 
Add»ssS‘
.
	`unify
(£q.
	`m­
(
_
.
	`wid’
(~
»duùiÚMask
)).
di¡šù
))

147 
def
 
ç¡Prİ”ty
[
K
, 
D
 <: 
D©a
](
add»ss
: 
UIÁ
, 
p
: 
TLMªag”P¬am‘”s
 => K, 
d
: K => D): D =

148 
	`Mux1H
(
	`ç¡Prİ”tyGroup
(
p
).
m­
 { (
v
, 
a
è=> (a.
	`m­
(
_
.
	`cÚšs
(
add»ss
)).
	`»duû
(_||_), 
	`d
(v)) })

151 
def
 
	`fšdFifoIdFa¡
(
add»ss
: 
UIÁ
èğ
	`ç¡Prİ”ty
×dd»ss, 
_
.
fifoId
.
	`m­
(_+1).
	`g‘OrEl£
(0), (
i
:
IÁ
è=> 
	`UIÁ
(i))

152 
def
 
	`hasFifoIdFa¡
(
add»ss
: 
UIÁ
èğ
	`ç¡Prİ”ty
×dd»ss, 
_
.
fifoId
.
isDefšed
, (
b
:
BoŞ—n
è=> 
	`BoŞ
(b))

155 
def
 
	`cÚšsSaã
(
add»ss
: 
UIÁ
èğ
	`fšdSaã
×dd»ss).
	`»duû
(
_
 || _)

157 
´iv©e
 
def
 
	`suµÜtH–³r
(

158 
§ã
: 
BoŞ—n
,

159 
memb”
: 
TLMªag”P¬am‘”s
 => 
T¿nsãrSizes
,

160 
add»ss
: 
UIÁ
,

161 
lgSize
: 
UIÁ
,

162 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
]): 
BoŞ
 = {

163 
def
 
	`Œim
(
x
: 
T¿nsãrSizes
èğ
¿nge
.
	`m­
(
_
.
	`š‹r£ù
(x)).
	`g‘OrEl£
(x)

164 
v®
 
suµÜtCa£s
 = 
mªag”s
.
	`groupBy
(
m
 => 
	`Œim
(
	`memb”
(m))).
	`m­V®ues
(
_
.
	`æ©M­
(_.
add»ss
))

165 
v®
 
mask
 = ià(
§ã
è~
	`BigIÁ
(0è
	`Add»ssDecod”
(
suµÜtCa£s
.
v®ues
.
toLi¡
)

166 
v®
 
sim¶if›d
 = 
suµÜtCa£s
.
	`m­V®ues
(
£q
 => 
Add»ssS‘
.
	`unify
(£q.
	`m­
(
_
.
	`wid’
(~
mask
)).
di¡šù
))

167 
sim¶if›d
.
m­
 { (
s
, 
a
) =>

168 (
	`BoŞ
(
	`Some
(
s
è=ğ
¿nge
è|| s.
	`cÚšsLg
(
lgSize
)) &&

169 
a
.
	`m­
(
_
.
	`cÚšs
(
add»ss
)).
	`»duû
(_||_)

170 }.
	`fŞdLeá
(
	`BoŞ
(
çl£
))(
_
||_)

174 
def
 
	`suµÜtsAcquœeTSaã
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsAcquœeT
,‡ddress,†gSize,„ange)

175 
def
 
	`suµÜtsAcquœeBSaã
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsAcquœeB
,‡ddress,†gSize,„ange)

176 
def
 
	`suµÜtsAr™hm‘icSaã
(
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsAr™hm‘ic
,‡ddress,†gSize,„ange)

177 
def
 
	`suµÜtsLogiÿlSaã
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsLogiÿl
,‡ddress,†gSize,„ange)

178 
def
 
	`suµÜtsG‘Saã
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsG‘
,‡ddress,†gSize,„ange)

179 
def
 
	`suµÜtsPutFuÎSaã
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsPutFuÎ
,‡ddress,†gSize,„ange)

180 
def
 
	`suµÜtsPutP¬tŸlSaã
(
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsPutP¬tŸl
,‡ddress,†gSize,„ange)

181 
def
 
	`suµÜtsHštSaã
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
Œue
, 
_
.
suµÜtsHšt
,‡ddress,†gSize,„ange)

183 
def
 
	`suµÜtsAcquœeTFa¡
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsAcquœeT
,‡ddress,†gSize,„ange)

184 
def
 
	`suµÜtsAcquœeBFa¡
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsAcquœeB
,‡ddress,†gSize,„ange)

185 
def
 
	`suµÜtsAr™hm‘icFa¡
(
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsAr™hm‘ic
,‡ddress,†gSize,„ange)

186 
def
 
	`suµÜtsLogiÿlFa¡
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsLogiÿl
,‡ddress,†gSize,„ange)

187 
def
 
	`suµÜtsG‘Fa¡
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsG‘
,‡ddress,†gSize,„ange)

188 
def
 
	`suµÜtsPutFuÎFa¡
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsPutFuÎ
,‡ddress,†gSize,„ange)

189 
def
 
	`suµÜtsPutP¬tŸlFa¡
(
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsPutP¬tŸl
,‡ddress,†gSize,„ange)

190 
def
 
	`suµÜtsHštFa¡
 (
add»ss
: 
UIÁ
, 
lgSize
: UIÁ, 
¿nge
: 
O±iÚ
[
T¿nsãrSizes
] = 
NÚe
èğ
	`suµÜtH–³r
(
çl£
, 
_
.
suµÜtsHšt
,‡ddress,†gSize,„ange)

192 
def
 
	`fšdT»eViŞ©iÚ
(èğ
mªag”s
.
	`æ©M­
(
_
.fšdT»eViŞ©iÚ()).
h—dO±iÚ


193 
def
 
isT»e
 = !
mªag”s
.
	`exi¡s
(!
_
.isTree)

194 
	}
}

196 
şass
 
TLCl›ÁP¬am‘”s
(

197 
Çme
: 
SŒšg
,

198 
sourûId
: 
IdRªge
 = IdRange(0,1),

199 
nodeP©h
: 
Seq
[
Ba£Node
] = Seq(),

200 
»que¡Fifo
: 
BoŞ—n
 = 
çl£
,

201 
visib™y
: 
Seq
[
Add»ssS‘
] = Seq(AddressSet(0, ~0)),

203 
suµÜtsProbe
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

204 
suµÜtsAr™hm‘ic
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

205 
suµÜtsLogiÿl
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

206 
suµÜtsG‘
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

207 
suµÜtsPutFuÎ
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

208 
suµÜtsPutP¬tŸl
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
,

209 
suµÜtsHšt
: 
T¿nsãrSizes
 = T¿nsãrSizes.
nÚe
)

211 
»quœe
 (!
sourûId
.
isEm±y
)

212 
»quœe
 (!
visib™y
.
isEm±y
)

213 
»quœe
 (
suµÜtsPutFuÎ
.
cÚšs
(
suµÜtsPutP¬tŸl
))

215 
»quœe
 (
suµÜtsProbe
.
cÚšs
(
suµÜtsAr™hm‘ic
))

216 
»quœe
 (
suµÜtsProbe
.
cÚšs
(
suµÜtsLogiÿl
))

217 
»quœe
 (
suµÜtsProbe
.
cÚšs
(
suµÜtsG‘
))

218 
»quœe
 (
suµÜtsProbe
.
cÚšs
(
suµÜtsPutFuÎ
))

219 
»quœe
 (
suµÜtsProbe
.
cÚšs
(
suµÜtsPutP¬tŸl
))

220 
»quœe
 (
suµÜtsProbe
.
cÚšs
(
suµÜtsHšt
))

222 
visib™y
.
combš©iÚs
(2).
fÜ—ch
 { 
Seq
(
x
,
y
è=> 
»quœe
 (!x.
ov”Ïps
(y), 
s
"$x‡nd $y overlap.") }

224 
v®
 
	gmaxT¿nsãr
 = 
Li¡
(

225 
suµÜtsProbe
.
max
,

226 
suµÜtsAr™hm‘ic
.
max
,

227 
suµÜtsLogiÿl
.
max
,

228 
suµÜtsG‘
.
max
,

229 
suµÜtsPutFuÎ
.
max
,

230 
suµÜtsPutP¬tŸl
.
max
).
	gmax


233 
şass
 
	$TLCl›ÁPÜtP¬am‘”s
(

234 
ş›Ás
: 
Seq
[
TLCl›ÁP¬am‘”s
],

235 
mšL©’cy
: 
IÁ
 = 0)

237 
	`»quœe
 (!
ş›Ás
.
isEm±y
)

238 
	`»quœe
 (
mšL©’cy
 >= 0)

241 
IdRªge
.
	`ov”Ïps
(
ş›Ás
.
	`m­
(
_
.
sourûId
)).
fÜ—ch
 { (
x
, 
y
) =>

242 
	`»quœe
 (!
x
.
	`ov”Ïps
(
y
), 
s
"TLClientParameters.sourceId ${x} overlaps ${y}")

246 
def
 
’dSourûId
 = 
ş›Ás
.
	`m­
(
_
.
sourûId
.
’d
).
max


247 
def
 
maxT¿nsãr
 = 
ş›Ás
.
	`m­
(
_
.maxT¿nsãr).
max


250 
def
 
unu£dSourûs
: 
Seq
[
IÁ
] = {

251 
v®
 
u£dSourûs
 = 
ş›Ás
.
	`m­
(
_
.
sourûId
).
	`sÜtBy
(_.
¡¬t
)

252 ((
	`Seq
(0è++ 
u£dSourûs
.
	`m­
(
_
.
’d
)è
z
 u£dSourûs.m­(_.
¡¬t
)è
æ©M­
 { (end, start) =>

253 
’d
 
uÁ
 
¡¬t


258 
v®
 
®lSuµÜtProbe
 = 
ş›Ás
.
	`m­
(
_
.
suµÜtsProbe
è.
	`»duû
(_ 
š‹r£ù
 _)

259 
v®
 
®lSuµÜtAr™hm‘ic
 = 
ş›Ás
.
	`m­
(
_
.
suµÜtsAr™hm‘ic
).
	`»duû
(_ 
š‹r£ù
 _)

260 
v®
 
®lSuµÜtLogiÿl
 = 
ş›Ás
.
	`m­
(
_
.
suµÜtsLogiÿl
è.
	`»duû
(_ 
š‹r£ù
 _)

261 
v®
 
®lSuµÜtG‘
 = 
ş›Ás
.
	`m­
(
_
.
suµÜtsG‘
è.
	`»duû
(_ 
š‹r£ù
 _)

262 
v®
 
®lSuµÜtPutFuÎ
 = 
ş›Ás
.
	`m­
(
_
.
suµÜtsPutFuÎ
è.
	`»duû
(_ 
š‹r£ù
 _)

263 
v®
 
®lSuµÜtPutP¬tŸl
 = 
ş›Ás
.
	`m­
(
_
.
suµÜtsPutP¬tŸl
).
	`»duû
(_ 
š‹r£ù
 _)

264 
v®
 
®lSuµÜtHšt
 = 
ş›Ás
.
	`m­
(
_
.
suµÜtsHšt
è.
	`»duû
(_ 
š‹r£ù
 _)

267 
v®
 
ªySuµÜtProbe
 = 
ş›Ás
.
	`m­
(!
_
.
suµÜtsProbe
.
nÚe
è.
	`»duû
(_ || _)

268 
v®
 
ªySuµÜtAr™hm‘ic
 = 
ş›Ás
.
	`m­
(!
_
.
suµÜtsAr™hm‘ic
.
nÚe
).
	`»duû
(_ || _)

269 
v®
 
ªySuµÜtLogiÿl
 = 
ş›Ás
.
	`m­
(!
_
.
suµÜtsLogiÿl
.
nÚe
è.
	`»duû
(_ || _)

270 
v®
 
ªySuµÜtG‘
 = 
ş›Ás
.
	`m­
(!
_
.
suµÜtsG‘
.
nÚe
è.
	`»duû
(_ || _)

271 
v®
 
ªySuµÜtPutFuÎ
 = 
ş›Ás
.
	`m­
(!
_
.
suµÜtsPutFuÎ
.
nÚe
è.
	`»duû
(_ || _)

272 
v®
 
ªySuµÜtPutP¬tŸl
 = 
ş›Ás
.
	`m­
(!
_
.
suµÜtsPutP¬tŸl
.
nÚe
).
	`»duû
(_ || _)

273 
v®
 
ªySuµÜtHšt
 = 
ş›Ás
.
	`m­
(!
_
.
suµÜtsHšt
.
nÚe
è.
	`»duû
(_ || _)

276 
def
 
	`fšd
(
id
: 
IÁ
èğ
ş›Ás
.fšd(
_
.
sourûId
.
	`cÚšs
(id))

279 
def
 
	`fšd
(
id
: 
UIÁ
èğ
	`Vec
(
ş›Ás
.
	`m­
(
_
.
sourûId
.
	`cÚšs
(id)))

280 
def
 
	`cÚšs
(
id
: 
UIÁ
èğ
	`fšd
(id).
	`»duû
(
_
 || _)

282 
def
 
	`»que¡Fifo
(
id
: 
UIÁ
èğ
	`Mux1H
(
	`fšd
(id), 
ş›Ás
.
	`m­
(
c
 => 
	`BoŞ
(c.
»que¡Fifo
)))

284 
´iv©e
 
def
 
	`§ãty_h–³r
(
memb”
: 
TLCl›ÁP¬am‘”s
 => 
T¿nsãrSizes
)(
id
: 
UIÁ
, 
lgSize
: UInt) = {

285 
v®
 
®lSame
 = 
ş›Ás
.
	`m­
(
	`memb”
(
_
è=ğmemb”(
	`ş›Ás
(0))).
	`»duû
(_ && _)

286 ià(
®lSame
è
	`memb”
(
	`ş›Ás
(0)).
	`cÚšsLg
(
lgSize
) {

287 
	`Mux1H
(
	`fšd
(
id
), 
ş›Ás
.
	`m­
(
	`memb”
(
_
).
	`cÚšsLg
(
lgSize
)))

292 
v®
 
suµÜtsProbe
 = 
	`§ãty_h–³r
(
_
.supportsProbe) _

293 
v®
 
suµÜtsAr™hm‘ic
 = 
	`§ãty_h–³r
(
_
.supportsArithmetic) _

294 
v®
 
suµÜtsLogiÿl
 = 
	`§ãty_h–³r
(
_
.supportsLogical) _

295 
v®
 
suµÜtsG‘
 = 
	`§ãty_h–³r
(
_
.supportsGet) _

296 
v®
 
suµÜtsPutFuÎ
 = 
	`§ãty_h–³r
(
_
.supportsPutFull) _

297 
v®
 
suµÜtsPutP¬tŸl
 = 
	`§ãty_h–³r
(
_
.supportsPutPartial) _

298 
v®
 
suµÜtsHšt
 = 
	`§ãty_h–³r
(
_
.supportsHint) _

299 
	}
}

301 
şass
 
	$TLBundËP¬am‘”s
(

302 
add»ssB™s
: 
IÁ
,

303 
d©aB™s
: 
IÁ
,

304 
sourûB™s
: 
IÁ
,

305 
sškB™s
: 
IÁ
,

306 
sizeB™s
: 
IÁ
)

309 
	`»quœe
 (
add»ssB™s
 >= 1)

310 
	`»quœe
 (
d©aB™s
 >= 8)

311 
	`»quœe
 (
sourûB™s
 >= 1)

312 
	`»quœe
 (
sškB™s
 >= 1)

313 
	`»quœe
 (
sizeB™s
 >= 1)

314 
	`»quœe
 (
	`isPow2
(
d©aB™s
))

316 
v®
 
addrLoB™s
 = 
	`log2Up
(
d©aB™s
/8)

318 
def
 (
x
: 
TLBundËP¬am‘”s
) =

319 
	`TLBundËP¬am‘”s
(

320 
	`max
(
add»ssB™s
, 
x
.addressBits),

321 
	`max
(
d©aB™s
, 
x
.dataBits),

322 
	`max
(
sourûB™s
, 
x
.sourceBits),

323 
	`max
(
sškB™s
, 
x
.sinkBits),

324 
	`max
(
sizeB™s
, 
x
.sizeBits))

325 
	}
}

327 
objeù
 
	gTLBundËP¬am‘”s


329 
v®
 
	gem±yBundËP¬ams
 = 
TLBundËP¬am‘”s
(

330 
add»ssB™s
 = 1,

331 
d©aB™s
 = 8,

332 
sourûB™s
 = 1,

333 
sškB™s
 = 1,

334 
sizeB™s
 = 1)

336 
def
 (
x
: 
Seq
[
TLBundËP¬am‘”s
]èğx.
fŞdLeá
(
em±yBundËP¬ams
)((x,
	gy
è=> x.(
y
))

338 
def
 
­¶y
(
ş›Á
: 
TLCl›ÁPÜtP¬am‘”s
, 
mªag”
: 
TLMªag”PÜtP¬am‘”s
) =

339 
Ãw
 
TLBundËP¬am‘”s
(

340 
add»ssB™s
 = 
log2Up
(
mªag”
.
maxAdd»ss
 + 1),

341 
d©aB™s
 = 
mªag”
.
b—tBy‹s
 * 8,

342 
sourûB™s
 = 
log2Up
(
ş›Á
.
’dSourûId
),

343 
sškB™s
 = 
log2Up
(
mªag”
.
’dSškId
),

344 
sizeB™s
 = 
log2Up
(
log2Ce
(
max
(
ş›Á
.
maxT¿nsãr
, 
mªag”
.maxTransfer))+1))

347 
şass
 
	$TLEdgeP¬am‘”s
(

348 
ş›Á
: 
TLCl›ÁPÜtP¬am‘”s
,

349 
mªag”
: 
TLMªag”PÜtP¬am‘”s
,

350 
·¿ms
: 
P¬am‘”s
,

351 
sourûInfo
: 
SourûInfo
)

353 
v®
 
maxT¿nsãr
 = 
	`max
(
ş›Á
.maxT¿nsãr, 
mªag”
.maxTransfer)

354 
v®
 
maxLgSize
 = 
	`log2Ce
(
maxT¿nsãr
)

357 
	`»quœe
 (
maxT¿nsãr
 >ğ
mªag”
.
b—tBy‹s
, 
s
"Link's maxransfer (${maxTransfer}) < ${manager.managers.map(_.name)}'s beatBytes (${manager.beatBytes})")

359 
v®
 
bundË
 = 
	`TLBundËP¬am‘”s
(
ş›Á
, 
mªag”
)

360 
	}
}

362 
şass
 
	$TLAsyncMªag”PÜtP¬am‘”s
(
async
: 
AsyncQueueP¬ams
, 
ba£
: 
TLMªag”PÜtP¬am‘”s
)

363 
şass
 
	$TLAsyncCl›ÁPÜtP¬am‘”s
(
ba£
: 
TLCl›ÁPÜtP¬am‘”s
)

364 
şass
 
	$TLAsyncBundËP¬am‘”s
(
async
: 
AsyncQueueP¬ams
, 
ba£
: 
TLBundËP¬am‘”s
)

365 
şass
 
	$TLAsyncEdgeP¬am‘”s
(
ş›Á
: 
TLAsyncCl›ÁPÜtP¬am‘”s
, 
mªag”
: 
TLAsyncMªag”PÜtP¬am‘”s
, 
·¿ms
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
)

367 
v®
 
bundË
 = 
	`TLAsyncBundËP¬am‘”s
(
mªag”
.
async
, 
	`TLBundËP¬am‘”s
(
ş›Á
.
ba£
, manager.base))

368 
	}
}

370 
şass
 
	$TLR©iÚ®Mªag”PÜtP¬am‘”s
(
dœeùiÚ
: 
R©iÚ®DœeùiÚ
, 
ba£
: 
TLMªag”PÜtP¬am‘”s
)

371 
şass
 
	$TLR©iÚ®Cl›ÁPÜtP¬am‘”s
(
ba£
: 
TLCl›ÁPÜtP¬am‘”s
)

373 
şass
 
	$TLR©iÚ®EdgeP¬am‘”s
(
ş›Á
: 
TLR©iÚ®Cl›ÁPÜtP¬am‘”s
, 
mªag”
: 
TLR©iÚ®Mªag”PÜtP¬am‘”s
, 
·¿ms
: 
P¬am‘”s
, 
sourûInfo
: 
SourûInfo
)

375 
v®
 
bundË
 = 
	`TLBundËP¬am‘”s
(
ş›Á
.
ba£
, 
mªag”
.base)

376 
	}
}

378 
objeù
 
	gMªag”UnifiÿtiÚ


380 
def
 
­¶y
(
mªag”s
: 
Seq
[
TLMªag”P¬am‘”s
]) = {

382 
şass
 
TLMªag”Key
(

383 
»sourûs
: 
Seq
[
Resourû
],

384 
»giÚTy³
: 
RegiÚTy³
.
T
,

385 
execubË
: 
BoŞ—n
,

386 
suµÜtsAcquœeT
: 
T¿nsãrSizes
,

387 
suµÜtsAcquœeB
: 
T¿nsãrSizes
,

388 
suµÜtsAr™hm‘ic
: 
T¿nsãrSizes
,

389 
suµÜtsLogiÿl
: 
T¿nsãrSizes
,

390 
suµÜtsG‘
: 
T¿nsãrSizes
,

391 
suµÜtsPutFuÎ
: 
T¿nsãrSizes
,

392 
suµÜtsPutP¬tŸl
: 
T¿nsãrSizes
,

393 
suµÜtsHšt
: 
T¿nsãrSizes
)

394 
def
 
key
(
x
: 
TLMªag”P¬am‘”s
èğ
TLMªag”Key
(

395 
»sourûs
 = 
x
.resources,

396 
»giÚTy³
 = 
x
.regionType,

397 
execubË
 = 
x
.executable,

398 
suµÜtsAcquœeT
 = 
x
.supportsAcquireT,

399 
suµÜtsAcquœeB
 = 
x
.supportsAcquireB,

400 
suµÜtsAr™hm‘ic
 = 
x
.supportsArithmetic,

401 
suµÜtsLogiÿl
 = 
x
.supportsLogical,

402 
suµÜtsG‘
 = 
x
.supportsGet,

403 
suµÜtsPutFuÎ
 = 
x
.supportsPutFull,

404 
suµÜtsPutP¬tŸl
 = 
x
.supportsPutPartial,

405 
suµÜtsHšt
 = 
x
.supportsHint)

406 
v®
 
m­
 = 
sÿÏ
.
cŞËùiÚ
.
mubË
.
HashM­
[
TLMªag”Key
, 
TLMªag”P¬am‘”s
]()

407 
	gmªag”s
.
	gfÜ—ch
 { 
	gm
 =>

408 
v®
 
k
 = 
key
(
m
)

409 
m­
.
g‘
(
k
è
m©ch
 {

410 
NÚe
 => 
m­
.
upd©e
(
k
, 
m
)

411 
Some
(
n
) => {

412 
m­
.
upd©e
(
k
, 
m
.
cİy
(

413 
add»ss
 = 
m
.add»s ++ 
n
.address,

414 
fifoId
 = 
NÚe
))

418 
	gm­
.
	gv®ues
.
m­
(
m
 => m.
cİy
(
add»ss
 = 
Add»ssS‘
.
unify
(m.add»ss))).
toLi¡


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/PatternPusher.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.
SourûInfo


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
Œa™
 
	gP©‹º
 {

12 
def
 
	gadd»ss
: 
BigIÁ


13 
def
 
size
: 
IÁ


14 
def
 
b™s
(
edge
: 
TLEdgeOut
): (
BoŞ
, 
	gTLBundËA
)

15 
def
 
	gd©aIn
: 
O±iÚ
[
BigIÁ
] = 
NÚe


16 
»quœe
 ((
add»ss
 & ((
BigIÁ
(1è<< 
size
) - 1)) == 0)

19 
şass
 
	$Wr™eP©‹º
(
add»ss
: 
BigIÁ
, 
size
: 
IÁ
, 
d©a
: BigIÁè
ex‹nds
 
P©‹º


21 
	`»quœe
 (0 <ğ
d©a
 && d©¨< (
	`BigIÁ
(1è<< (8 << 
size
)))

22 
def
 
	`b™s
(
edge
: 
TLEdgeOut
èğedge.
	`Put
(
	`UIÁ
(0), UIÁ(
add»ss
), UIÁ(
size
), UIÁ(
d©a
 << (8*×dd»s %ƒdge.
mªag”
.
b—tBy‹s
).
toIÁ
)))

23 
	}
}

25 
şass
 
	$R—dP©‹º
(
add»ss
: 
BigIÁ
, 
size
: 
IÁ
è
ex‹nds
 
P©‹º


27 
def
 
	`b™s
(
edge
: 
TLEdgeOut
èğedge.
	`G‘
(
	`UIÁ
(0), UIÁ(
add»ss
), UIÁ(
size
))

28 
	}
}

30 
şass
 
	$R—dEx³ùP©‹º
(
add»ss
: 
BigIÁ
, 
size
: 
IÁ
, 
d©a
: BigIÁè
ex‹nds
 
P©‹º


32 
def
 
	`b™s
(
edge
: 
TLEdgeOut
èğedge.
	`G‘
(
	`UIÁ
(0), UIÁ(
add»ss
), UIÁ(
size
))

33 
ov”ride
 
def
 
d©aIn
 = 
	`Some
(
d©a
)

34 
	}
}

36 
şass
 
	$TLP©‹ºPush”
(
Çme
: 
SŒšg
, 
·‰”n
: 
Seq
[
P©‹º
])(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


38 
v®
 
node
 = 
	`TLCl›ÁNode
(
	`Seq
(
	`TLCl›ÁPÜtP¬am‘”s
(Seq(
	`TLCl›ÁP¬am‘”s
(
Çme
 =‚ame)))))

40 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

41 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

42 
v®
 
run
 = 
	`BoŞ
(
INPUT
)

43 
v®
 
dÚe
 = 
	`BoŞ
(
OUTPUT
)

46 
	`v®
 (
_out
, 
edgeOut
èğ
node
.
	`out
(0)

47 
·‰”n
.
fÜ—ch
 { 
p
 =>

48 
	`»quœe
 (
p
.
size
 <ğ
	`log2Ce
(
edgeOut
.
mªag”
.
b—tBy‹s
), "Patterns must fit in‡ single beat")

51 
v®
 
¡•
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
	`log2Ce
(
·‰”n
.
size
+1)))

52 
v®
 
æight
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

53 
v®
 
»ady
 = 
	`RegNext
(
	`BoŞ
(
Œue
), BoŞ(
çl£
))

55 
v®
 
’d
 = 
¡•
 ==ğ
	`UIÁ
(
·‰”n
.
size
)

56 
io
.
dÚe
 :ğ
’d
 && !
æight


58 
v®
 
a
 = 
_out
.a

59 
v®
 
d
 = 
_out
.d

62 
v®
 
check
 = 
	`Vec
(
·‰”n
.
	`m­
(
p
 => 
	`BoŞ
Õ.
d©aIn
.
isDefšed
)))(
¡•
è
hŞdUÆess
 
a
.
	`fœe
()

63 
v®
 
ex³ù
 = 
	`Vec
(
·‰”n
.
	`m­
(
p
 => 
	`UIÁ
Õ.
d©aIn
.
	`g‘OrEl£
(
	`BigIÁ
(0)))))(
¡•
è
hŞdUÆess
 
a
.
	`fœe
()

64 
	`as£¹
 (!
check
 || !
d
.
	`fœe
(è|| 
ex³ù
 ==ğd.
b™s
.
d©a
)

66 
	`wh’
 (
a
.
	`fœe
()) {

67 
æight
 :ğ
	`BoŞ
(
Œue
)

68 
¡•
 :ğ¡• + 
	`UIÁ
(1)

70 
	`wh’
 (
d
.
	`fœe
()) {

71 
æight
 :ğ
	`BoŞ
(
çl£
)

74 
	`v®
 (
¶eg®
, 
pb™s
èğ
·‰”n
.
	`m­
(
_
.
	`b™s
(
edgeOut
)).
unz


75 
	`as£¹
 (
’d
 || 
	`Vec
(
¶eg®
)(
¡•
), 
s
"Pattern…usher ${name}riedo…ush‡n illegal„equest")

77 
a
.
v®id
 :ğ
io
.
run
 && 
»ady
 && !
’d
 && !
æight


78 
a
.
b™s
 :ğ
	`Vec
(
pb™s
)(
¡•
)

79 
d
.
»ady
 :ğ
	`BoŞ
(
Œue
)

82 
_out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

83 
_out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

84 
_out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

86 
	}
}

88 
objeù
 
TLP©‹ºPush”


90 
def
 
­¶y
(
Çme
: 
SŒšg
, 
·‰”n
: 
Seq
[
P©‹º
])(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLOutw¬dNode
 =

92 
v®
 
push”
 = 
LazyModuË
(
Ãw
 
TLP©‹ºPush”
(
Çme
, 
·‰”n
))

93 
	gpush”
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ProbePicker.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 şas 
	cProbePick”
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


13 
v®
 
node
 = 
	`TLAd­‹rNode
(

14 
ş›ÁFn
 = { 
p
 =>

17 
def
 
	`combše
(
Ãxt
: 
TLCl›ÁP¬am‘”s
, 
·œ
: (TLCl›ÁP¬am‘”s, 
Seq
[TLClientParameters])) = {

18 
	`v®
 (
h—d
, 
ouut
èğ
·œ


19 ià(
h—d
.
visib™y
.
	`exi¡s
(
x
 => 
Ãxt
.visib™y.exi¡s(
_
.
	`ov”Ïps
(x)))) {

20 (
Ãxt
, 
h—d
 +: 
ouut
)

22 
def
 
	`»daù
(
x
: 
TLCl›ÁP¬am‘”s
èğx.
	`cİy
(
sourûId
 = 
	`IdRªge
(0,1), 
nodeP©h
 = 
N
, 
visib™y
 = 
	`Seq
(
	`Add»ssS‘
(0, ~0)))

23 
	`»quœe
 (
	`»daù
(
Ãxt
è=ğ»daù(
h—d
))

24 
v®
 
m”ge
 = 
h—d
.
	`cİy
(

25 
sourûId
 = 
	`IdRªge
(

26 
h—d
.
sourûId
.
¡¬t
 
mš
 
Ãxt
.sourceId.start,

27 
h—d
.
sourûId
.
’d
 
max
 
Ãxt
.sourceId.end),

28 
visib™y
 = 
Add»ssS‘
.
	`unify
(
h—d
.visib™y ++ 
Ãxt
.visibility))

29 (
m”ge
, 
ouut
)

32 
v®
 
myN
: 
Seq
[
TLCl›ÁP¬am‘”s
] = 
N


33 
	`v®
 (
h—d
, 
ouut
èğ
p
.
ş›Ás
.
š™
.
	`fŞdRight
(Õ.ş›Ás.
Ï¡
, 
myN
))(
combše
)

34 
p
.
	`cİy
(
ş›Ás
 = 
h—d
 +: 
ouut
)

36 
mªag”Fn
 = { 
p
 =>… 
	}
})

38 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

39 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

40 
out
 <> 
š


43 ià(
edgeIn
.
ş›Á
.
ş›Ás
.
size
 !ğ
edgeOut
.client.clients.size) {

44 
š
.
b
.
b™s
.
sourû
 :ğ
	`Mux1H
(

45 
edgeOut
.
ş›Á
.
ş›Ás
.
	`m­
(
_
.
sourûId
 
cÚšs
 
out
.
b
.
b™s
.
sourû
),

46 
edgeOut
.
ş›Á
.
ş›Ás
.
m­
 { 
c
 =>

47 
v®
 
bªks
 = 
edgeIn
.
ş›Á
.
ş›Ás
.
	`f‹r
(
c
.
sourûId
 
cÚšs
 
_
.sourceId)

48 ià(
bªks
.
size
 == 1) {

49 
out
.
b
.
b™s
.
sourû


51 
	`Mux1H
(

52 
bªks
.
	`m­
(
_
.
visib™y
.m­(_ 
cÚšs
 
out
.
b
.
b™s
.
add»ss
).
	`»duû
(_ || _)),

53 
bªks
.
	`m­
(
_
.
sourûId
.
¡¬t
.
U
))

59 
	}
}

62 
objeù
 
	gProbePick”


64 
def
 
­¶y
()(
im¶ic™
 
	gp
: 
P¬am‘”s
): 
TLNode
 = {

65 
v®
 
pick”
 = 
LazyModuË
(
Ãw
 
ProbePick”
)

66 
pick”
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RAMModel.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


25 
şass
 
TLRAMMod–
(
log
: 
SŒšg
 = "", 
ignÜeCÜru±D©a
: 
BoŞ—n
 = 
çl£
, 
ignÜeD’›dD©a
: BoŞ—Àğ
Œue
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


27 
v®
 
node
 = 
TLAd­‹rNode
()

29 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
LazyModuËImp
(
this
) {

30 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

31 
v®
 
edge
 = 
edgeIn


32 
v®
 
’dAdd»ss
 = 
edge
.
mªag”
.
maxAdd»ss
 + 1

33 
v®
 
’dSourûId
 = 
edge
.
ş›Á
.endSourceId

34 
v®
 
maxT¿nsãr
 = 
edge
.
mªag”
.maxTransfer

35 
v®
 
b—tBy‹s
 = 
edge
.
mªag”
.beatBytes

36 
v®
 
’dAdd»ssHi
 = (
’dAdd»ss
 / 
b—tBy‹s
).
štV®ue


37 
v®
 
maxLgB—ts
 = 
log2Up
(
maxT¿nsãr
/
b—tBy‹s
)

38 
v®
 
shiá
 = 
log2Ce
(
b—tBy‹s
)

39 
v®
 
decT»es
 = 
log2Up
(
maxT¿nsãr
/
b—tBy‹s
)

40 
v®
 
add»ssB™s
 = 
log2Up
(
’dAdd»ss
)

41 
v®
 
couÁB™s
 = 
log2Up
(
’dSourûId
)

42 
v®
 
sizeB™s
 = 
edge
.
bundË
.sizeBits

43 
v®
 
divisÜ
 = 
CRC
.
CRC_16F_4_2


46 
v®
 
weIndex
 = 
RegIn™
(
UIÁ
(0, 
width
 = 
log2Ce
(
’dAdd»ssHi
) + 1))

47 
v®
 
we
 = !
weIndex
(
log2Ce
(
’dAdd»ssHi
))

48 
weIndex
 :ğweIndex + 
we
.
asUIÁ


51 
š
.
a
.
»ady
 :ğ
out
.a.»ady && !
we


52 
out
.
a
.
v®id
 :ğ
š
.a.v®id && !
we


53 
out
.
a
.
b™s
 :ğ
š
.a.bits

54 
out
.
d
.
»ady
 :ğ
š
.d.»ady && !
we


55 
š
.
d
.
v®id
 :ğ
out
.d.v®id && !
we


56 
š
.
d
.
b™s
 :ğ
out
.d.bits

59 
š
.
b
.
v®id
 :ğ
BoŞ
(
çl£
)

60 
out
.
c
.
v®id
 :ğ
BoŞ
(
çl£
)

61 
out
.
e
.
v®id
 :ğ
BoŞ
(
çl£
)

62 
out
.
b
.
»ady
 :ğ
BoŞ
(
Œue
)

63 
š
.
c
.
»ady
 :ğ
BoŞ
(
Œue
)

64 
š
.
e
.
»ady
 :ğ
BoŞ
(
Œue
)

66 
v®
 
·¿ms
 = 
TLRAMMod–
.
MÚ™ÜP¬am‘”s
(
add»ssB™s
, 
sizeB™s
)

69 
v®
 
	gshadow
 = 
Seq
.
fl
(
b—tBy‹s
è{ 
Mem
(
’dAdd»ssHi
, 
Ãw
 
TLRAMMod–
.
By‹MÚ™Ü
(
·¿ms
)) }

70 
v®
 
šc_by‹s
 = 
Seq
.
fl
(
b—tBy‹s
è{ 
Mem
(
’dAdd»ssHi
, 
UIÁ
(
width
 = 
couÁB™s
)) }

71 
v®
 
	gdec_by‹s
 = 
Seq
.
fl
(
b—tBy‹s
è{ 
Mem
(
’dAdd»ssHi
, 
UIÁ
(
width
 = 
couÁB™s
)) }

72 
v®
 
	gšc_Œ“s
 = 
Seq
.
buÏ‹
(
decT»es
è{ 
i
 => 
Mem
(
’dAdd»ssHi
 >> (i+1), 
UIÁ
(
width
 = 
couÁB™s
)) }

73 
v®
 
	gdec_Œ“s
 = 
Seq
.
buÏ‹
(
decT»es
è{ 
i
 => 
Mem
(
’dAdd»ssHi
 >> (i+1), 
UIÁ
(
width
 = 
couÁB™s
)) }

75 
v®
 
	gshadow_w’
 = 
Wœe
(
š™
 = 
Fl
(
b—tBy‹s
, 
we
))

76 
v®
 
	gšc_by‹s_w’
 = 
Wœe
(
š™
 = 
Fl
(
b—tBy‹s
, 
we
))

77 
v®
 
	gdec_by‹s_w’
 = 
Wœe
(
š™
 = 
Fl
(
b—tBy‹s
, 
we
))

78 
v®
 
	gšc_Œ“s_w’
 = 
Wœe
(
š™
 = 
Fl
(
decT»es
, 
we
))

79 
v®
 
	gdec_Œ“s_w’
 = 
Wœe
(
š™
 = 
Fl
(
decT»es
, 
we
))

82 
v®
 
	gæight
 = 
Reg
(
Vec
(
’dSourûId
, 
Ãw
 
TLRAMMod–
.
FlightMÚ™Ü
(
·¿ms
)))

83 
v®
 
	gv®id
 = 
Reg
(
Vec
(
’dSourûId
, 
BoŞ
()))

86 
v®
 
	ga_æight
 = 
Wœe
(
Ãw
 
TLRAMMod–
.
FlightMÚ™Ü
(
·¿ms
))

87 
a_æight
.
ba£
 :ğ
edge
.
add»ss
(
š
.
a
.
b™s
)

88 
a_æight
.
size
 :ğ
edge
.size(
š
.
a
.
b™s
)

89 
a_æight
.
İcode
 :ğ
š
.
a
.
b™s
.opcode

91 
wh’
 (
š
.
a
.
fœe
()è{ 
æight
(š.a.
b™s
.
sourû
è:ğ
a_æight
 }

92 
v®
 
by·ss
 = ià(
edge
.
mªag”
.
mšL©’cy
 > 0è
BoŞ
(
çl£
è
š
.
a
.
v®id
 && in.a.
b™s
.
sourû
 ==ğ
out
.
d
.bits.source

93 
v®
 
d_æight
 = 
RegEÇbË
(
Mux
(
by·ss
, 
a_æight
, 
æight
(
out
.
d
.
b™s
.
sourû
)), 
edge
.
fœ¡
(out.d))

96 
v®
 
	ga
 = 
Reg
(
Ãxt
 = 
š
.
a
.
b™s
)

97 
v®
 
a_fœe
 = 
Reg
(
Ãxt
 = 
š
.
a
.
fœe
(), 
š™
 = 
BoŞ
(
çl£
))

98 
v®
 (
a_fœ¡
, 
a_Ï¡
, 
_
, 
a_add»ss_šc
èğ
edge
.
addr_šc
(
a
, 
a_fœe
)

99 
v®
 
	ga_size
 = 
edge
.
size
(
a
)

100 
v®
 
a_sizeOH
 = 
UIÁToOH
(
a_size
)

101 
v®
 
a_add»ss
 = 
a
.
add»ss
 | 
a_add»ss_šc


102 
v®
 
a_addr_hi
 = 
edge
.
addr_hi
(
a_add»ss
)

103 
v®
 
a_ba£
 = 
edge
.
add»ss
(
a
)

104 
v®
 
a_mask
 = 
edge
.
mask
(
a_ba£
, 
a_size
)

105 
v®
 
	ga_fifo
 = 
edge
.
mªag”
.
hasFifoIdFa¡
(
a_ba£
è&&ƒdge.
ş›Á
.
»que¡Fifo
(
a
.
sourû
)

108 
v®
 
a_šc_by‹s
 = 
šc_by‹s
.
m­
(
_
.
»ad
(
a_addr_hi
))

109 
v®
 
a_dec_by‹s
 = 
dec_by‹s
.
m­
(
_
.
»ad
(
a_addr_hi
))

110 
v®
 
a_šc_Œ“s
 = 
šc_Œ“s
.
zW™hIndex
.
m­
{ (
m
, 
i
è=> m.
»ad
(
a_addr_hi
 >> (i+1)) }

111 
v®
 
	ga_dec_Œ“s
 = 
dec_Œ“s
.
zW™hIndex
.
m­
{ (
m
, 
i
è=> m.
»ad
(
a_addr_hi
 >> (i+1)) }

112 
v®
 
	ga_šc_Œ“
 = 
a_šc_Œ“s
.
fŞd
(
UIÁ
(0))(
_
 + _)

113 
v®
 
a_dec_Œ“
 = 
a_dec_Œ“s
.
fŞd
(
UIÁ
(0))(
_
 + _)

114 
v®
 
a_šc
 = 
a_šc_by‹s
.
m­
(
_
 + 
a_šc_Œ“
)

115 
v®
 
a_dec
 = 
a_dec_by‹s
.
m­
(
_
 + 
a_dec_Œ“
)

117 
wh’
 (
a_fœe
) {

119 
as£¹
 (
a
.
İcode
 =/ğ
TLMes§ges
.
AcquœeBlock
 &&‡.İcod=/ğTLMes§ges.
AcquœeP”m
)

122 
v®id
(
a
.
sourû
è:ğ
BoŞ
(
Œue
)

125 
wh’
 (
a_fœ¡
 && 
a
.
İcode
 =/ğ
TLMes§ges
.
Hšt
 &&‡.İcod=/ğTLMes§ges.
G‘
) {

126 
wh’
 (
a_size
 <ğ
UIÁ
(
shiá
)) {

127 
šc_by‹s_w’
 :ğ
a_mask


129 
šc_Œ“s_w’
 :ğ
a_sizeOH
 >> (
shiá
+1)

132 
wh’
 (
a
.
İcode
 ==ğ
TLMes§ges
.
PutFuÎD©a
 ||‡.İcod==ğTLMes§ges.
PutP¬tŸlD©a
 ||

133 
a
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a
 ||‡.İcod==ğTLMes§ges.
LogiÿlD©a
) {

134 
shadow_w’
 :ğ
a
.
mask


135 
i
 <- 0 
uÁ
 
b—tBy‹s
) {

136 
v®
 
busy
 = 
a_šc
(
i
è- 
a_dec
(iè- (!
a_fœ¡
).
asUIÁ


137 
v®
 
by‹
 = 
a
.
d©a
(8*(
i
+1)-1, 8*i)

138 
wh’
 (
a
.
mask
(
i
)) {

139 
´štf
(
log
 + " ")

140 
wh’
 (
a
.
İcode
 ==ğ
TLMes§ges
.
PutFuÎD©a
è{ 
´štf
("PF") }

141 
wh’
 (
a
.
İcode
 ==ğ
TLMes§ges
.
PutP¬tŸlD©a
è{ 
´štf
("PP") }

142 
wh’
 (
a
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a
è{ 
´štf
("A ") }

143 
wh’
 (
a
.
İcode
 ==ğ
TLMes§ges
.
LogiÿlD©a
è{ 
´štf
("L ") }

144 
´štf
(" 0x%x :ğ0x%x #%d %x\n", 
a_addr_hi
 << 
shiá
 | 
UIÁ
(
i
), 
by‹
, 
busy
, 
a
.
·¿m
)

149 
wh’
 (
a
.
İcode
 ==ğ
TLMes§ges
.
G‘
) {

150 
´štf
(
log
 + " G 0x%x - 0x%x\n", 
a_ba£
,‡_ba£ | 
UIÁToOH1
(
a_size
, 
add»ssB™s
))

154 
v®
 
	ga_waddr
 = 
Mux
(
we
, 
weIndex
, 
a_addr_hi
)

155 
v®
 
	ga_shadow
 = 
shadow
.
m­
(
_
.
»ad
(
a_waddr
))

156 
v®
 
a_known_Şd
 = !(
C©
(
a_shadow
.
m­
(!
_
.
v®id
).
»v”£
è& 
a_mask
).
ÜR


157 
v®
 
®u
 = 
ModuË
(
Ãw
 
Atomics
(
a
.
·¿ms
))

158 
®u
.
io
.
wr™e
 :ğ
BoŞ
(
çl£
)

159 
®u
.
io
.
a
 :=‡

160 
®u
.
io
.
d©a_š
 :ğ
C©
(
a_shadow
.
m­
(
_
.
v®ue
).
»v”£
)

162 
v®
 
üc
 = 
Mem
(
’dSourûId
, 
UIÁ
(
width
 = 16))

163 
v®
 
üc_v®id
 = 
Mem
(
’dSourûId
, 
BoŞ
())

164 
v®
 
	ga_üc_acc
 = 
Mux
(
a_fœ¡
, 
UIÁ
(0), 
üc
(
a
.
sourû
))

165 
v®
 
	ga_üc_Ãw
 = 
C©
(
a_shadow
.
zW™hIndex
.
m­
 { (
z
, 
i
è=> 
Mux
(
a_mask
(i), z.
v®ue
, 
UIÁ
(0)è}.
»v”£
)

166 
v®
 
	ga_üc
 = 
CRC
(
divisÜ
, 
C©
(
a_üc_acc
, 
a_üc_Ãw
), 16 + 
b—tBy‹s
*8)

167 
v®
 
	ga_üc_v®id
 = 
a_known_Şd
 && 
Mux
(
a_fœ¡
, 
BoŞ
(
Œue
), 
üc_v®id
(
a
.
sourû
))

168 
wh’
 (
a_fœe
) {

169 
	güc
.
wr™e
(
a
.
sourû
, 
a_üc
)

170 
	güc_v®id
.
wr™e
(
a
.
sourû
, 
a_üc_v®id
)

173 
	gi
 <- 0 
uÁ
 
	gb—tBy‹s
) {

174 
v®
 
	gd©a
 = 
Wœe
(
Ãw
 
TLRAMMod–
.
By‹MÚ™Ü
(
·¿ms
))

175 
v®
 
busy
 = 
a_šc
(
i
è=/ğ
a_dec
(iè+ (!
a_fœ¡
).
asUIÁ


176 
v®
 
amo
 = 
a
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a
 ||‡.İcod==ğTLMes§ges.
LogiÿlD©a


177 
v®
 
b—t_amo
 = 
a
.
size
 <ğ
UIÁ
(
log2Ce
(
b—tBy‹s
))

178 
d©a
.
v®id
 :ğ
Mux
(
we
, 
BoŞ
(
çl£
), (!
busy
 || 
a_fifo
è&& (!
amo
 || (
a_known_Şd
 && 
b—t_amo
)))

179 
	gd©a
.
	gv®ue
 :ğ
®u
.
io
.
d©a_out
(8*(
i
+1)-1, 8*i)

180 
wh’
 (
shadow_w’
(
i
)) {

181 
shadow
(
i
).
wr™e
(
a_waddr
, 
d©a
)

185 
	gi
 <- 0 
uÁ
 
	gb—tBy‹s
) {

186 
v®
 
	gd©a
 = 
Mux
(
we
, 
UIÁ
(0), 
a_šc_by‹s
(
i
) + UInt(1))

187 
wh’
 (
šc_by‹s_w’
(
i
)) {

188 
šc_by‹s
(
i
).
wr™e
(
a_waddr
, 
d©a
)

192 
	gi
 <- 0 
uÁ
 
	gšc_Œ“s
.
	gsize
) {

193 
v®
 
	gd©a
 = 
Mux
(
we
, 
UIÁ
(0), 
a_šc_Œ“s
(
i
) + UInt(1))

194 
wh’
 (
šc_Œ“s_w’
(
i
)) {

195 
šc_Œ“s
(
i
).
wr™e
(
a_waddr
 >> (i+1), 
d©a
)

200 
v®
 
	gd
 = 
RegNext
(
out
.
d
.
b™s
)

201 
v®
 
d_fœe
 = 
Reg
(
Ãxt
 = 
out
.
d
.
fœe
(), 
š™
 = 
BoŞ
(
çl£
))

202 
v®
 (
d_fœ¡
, 
d_Ï¡
, 
_
, 
d_add»ss_šc
èğ
edge
.
addr_šc
(
d
, 
d_fœe
)

203 
v®
 
	gd_size
 = 
edge
.
size
(
d
)

204 
v®
 
d_sizeOH
 = 
UIÁToOH
(
d_size
)

205 
v®
 
d_ba£
 = 
d_æight
.
ba£


206 
v®
 
d_add»ss
 = 
d_ba£
 | 
d_add»ss_šc


207 
v®
 
d_addr_hi
 = 
edge
.
addr_hi
(
d_add»ss
)

208 
v®
 
d_mask
 = 
edge
.
mask
(
d_ba£
, 
d_size
)

209 
v®
 
	gd_fifo
 = 
edge
.
mªag”
.
hasFifoIdFa¡
(
d_æight
.
ba£
è&&ƒdge.
ş›Á
.
»que¡Fifo
(
d
.
sourû
)

212 
v®
 
d_šc_by‹s
 = 
šc_by‹s
.
m­
(
_
.
»ad
(
d_addr_hi
))

213 
v®
 
d_dec_by‹s
 = 
dec_by‹s
.
m­
(
_
.
»ad
(
d_addr_hi
))

214 
v®
 
d_šc_Œ“s
 = 
šc_Œ“s
.
zW™hIndex
.
m­
{ (
m
, 
i
è=> m.
»ad
(
d_addr_hi
 >> (i+1)) }

215 
v®
 
	gd_dec_Œ“s
 = 
dec_Œ“s
.
zW™hIndex
.
m­
{ (
m
, 
i
è=> m.
»ad
(
d_addr_hi
 >> (i+1)) }

216 
v®
 
	gd_šc_Œ“
 = 
d_šc_Œ“s
.
fŞd
(
UIÁ
(0))(
_
 + _)

217 
v®
 
d_dec_Œ“
 = 
d_dec_Œ“s
.
fŞd
(
UIÁ
(0))(
_
 + _)

218 
v®
 
d_šc
 = 
d_šc_by‹s
.
m­
(
_
 + 
d_šc_Œ“
)

219 
v®
 
d_dec
 = 
d_dec_by‹s
.
m­
(
_
 + 
d_dec_Œ“
)

220 
v®
 
d_shadow
 = 
shadow
.
m­
(
_
.
»ad
(
d_addr_hi
))

221 
v®
 
d_v®id
 = 
v®id
(
d
.
sourû
è
hŞdUÆess
 
d_fœ¡


224 
v®
 
d_üc_»g
 = 
Reg
(
UIÁ
(
width
 = 16))

225 
v®
 
d_üc_acc
 = 
Mux
(
d_fœ¡
, 
UIÁ
(0), 
d_üc_»g
)

226 
v®
 
	gd_üc_Ãw
 = 
FlIÁ”Ëaved
(8, 
d_mask
è& 
	gd
.
d©a


227 
v®
 
	gd_üc
 = 
CRC
(
divisÜ
, 
C©
(
d_üc_acc
, 
d_üc_Ãw
), 16 + 
b—tBy‹s
*8)

228 
v®
 
	güc_by·ss
 = ià(
edge
.
mªag”
.
mšL©’cy
 > 0è
BoŞ
(
çl£
è
a_fœe
 && 
a
.
sourû
 ==ğ
d
.source

229 
v®
 
d_üc_v®id
 = 
Mux
(
üc_by·ss
, 
a_üc_v®id
, 
üc_v®id
.
»ad
(
d
.
sourû
)è
hŞdUÆess
 
d_fœ¡


230 
v®
 
	gd_üc_check
 = 
Mux
(
üc_by·ss
, 
a_üc
, 
üc
.
»ad
(
d
.
sourû
)è
hŞdUÆess
 
d_fœ¡


232 
v®
 
	gd_no_¿û_»g
 = 
Reg
(
BoŞ
())

233 
v®
 
d_no_¿û
 = 
Wœe
(
š™
 = 
d_no_¿û_»g
)

235 
wh’
 (
d_fœe
) {

236 
d_üc_»g
 :ğ
d_üc


237 
d_no_¿û_»g
 :ğ
d_no_¿û


240 
as£¹
 (
d_size
 ==ğ
d_æight
.
size
)

243 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
Hšt
) {

244 
as£¹
 (
d
.
İcode
 ==ğ
TLMes§ges
.
HštAck
)

248 
wh’
 (
d_Ï¡
 && 
d_æight
.
İcode
 =/ğ
TLMes§ges
.
Hšt
 && d_æight.İcod=/ğTLMes§ges.
G‘
) {

249 
wh’
 (
d_size
 <ğ
UIÁ
(
shiá
)) {

250 
dec_by‹s_w’
 :ğ
d_mask


252 
dec_Œ“s_w’
 :ğ
d_sizeOH
 >> (
shiá
+1)

254 
i
 <- 0 
uÁ
 
’dSourûId
) {

256 
v®
 
f_ba£
 = 
æight
(
i
).
ba£


257 
v®
 
f_size
 = 
æight
(
i
).
size


258 
v®
 
f_b™s
 = 
UIÁToOH1
(
f_size
, 
add»ssB™s
)

259 
v®
 
	gd_b™s
 = 
UIÁToOH1
(
d_size
, 
add»ssB™s
)

260 
v®
 
	gov”Ïp
 = ~(~(
f_ba£
 ^ 
d_ba£
è| (
f_b™s
 | 
d_b™s
)è==ğ
UIÁ
(0)

261 
wh’
 (
ov”Ïp
è{ 
v®id
(
i
è:ğ
BoŞ
(
çl£
) }

265 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
PutFuÎD©a
 || d_æight.İcod==ğTLMes§ges.
PutP¬tŸlD©a
) {

266 
as£¹
 (
d
.
İcode
 ==ğ
TLMes§ges
.
AcûssAck
)

267 
´štf
(
log
 + " ")

268 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
PutFuÎD©a
è{ 
´štf
("pf") }

269 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
PutP¬tŸlD©a
è{ 
´štf
("pp") }

270 
´štf
(" 0x%x - 0x%x\n", 
d_ba£
, d_ba£ | 
UIÁToOH1
(
d_size
, 
add»ssB™s
))

273 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
G‘
 || d_æight.İcod==ğTLMes§ges.
Ar™hm‘icD©a
 || d_æight.İcod==ğTLMes§ges.
LogiÿlD©a
) {

274 
as£¹
 (
d
.
İcode
 ==ğ
TLMes§ges
.
AcûssAckD©a
)

275 
i
 <- 0 
uÁ
 
b—tBy‹s
) {

276 
v®
 
gÙ
 = 
d
.
d©a
(8*(
i
+1)-1, 8*i)

277 
v®
 
	gshadow
 = 
Wœe
(
š™
 = 
d_shadow
(
i
))

278 
wh’
 (
d_mask
(
i
)) {

279 
v®
 
d_addr
 = 
d_addr_hi
 << 
shiá
 | 
UIÁ
(
i
)

280 
´štf
(
log
 + " ")

281 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
G‘
è{ 
´štf
("g ") }

282 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a
è{ 
´štf
("a ") }

283 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
LogiÿlD©a
è{ 
´štf
("l ") }

284 
´štf
(" 0x%x :ğ0x%x", 
d_addr
, 
gÙ
)

285 
wh’
 (!
shadow
.
v®id
) {

286 
´štf
(", undefined (uninitialized or…rior overlapping…uts)\n")

287 } .
–£wh’
 (
d_šc
(
i
è=/ğ
d_dec
(i)) {

288 
´štf
(", undefšed (cÚcu¼’ˆšcom¶‘put #%d)\n", 
d_šc
(
i
è- 
d_dec
(i))

289 } .
–£wh’
 (!
d_fifo
 && !
d_v®id
) {

290 
´štf
(", undefined (concurrent completed…ut)\n")

291 } .
–£wh’
 (
BoŞ
(
ignÜeD’›dD©a
è&& 
d
.
d’›d
) {

292 
´štf
(", undefined (denied„esult)\n")

293 } .
–£wh’
 (
BoŞ
(
ignÜeCÜru±D©a
è&& 
d
.
cÜru±
) {

294 
´štf
(", undefined (corrupt„esult)\n")

295 } .
Ùh”wi£
 {

296 
´štf
("\n")

297 
wh’
 (
shadow
.
v®ue
 =/ğ
gÙ
è{ 
´štf
("EXPECTED: 0x%x\n", shadow.value) }

298 
as£¹
 (
shadow
.
v®ue
 ==ğ
gÙ
)

304 
wh’
 (
d_æight
.
İcode
 ==ğ
TLMes§ges
.
Ar™hm‘icD©a
 || d_æight.İcod==ğTLMes§ges.
LogiÿlD©a
) {

305 
v®
 
¿û
 = (
d_šc
 
z
 
d_dec
è
m­
 { (
i
, 
d
è=> i - d =/ğ
UIÁ
(1) }

306 
wh’
 (
d_fœ¡
è{ 
	gd_no_¿û
 :ğ
BoŞ
(
Œue
) }

307 
wh’
 ((
C©
(
¿û
.
»v”£
è& 
d_mask
).
ÜR
è{ 
d_no_¿û
 :ğ
BoŞ
(
çl£
) }

308 
wh’
 (
d_Ï¡
) {

309 
v®
 
mu¡_m©ch
 = 
d_üc_v®id
 && (
d_fifo
 || (
d_v®id
 && 
d_no_¿û
))

310 
v®
 
cÜru±
 = (
BoŞ
(
ignÜeCÜru±D©a
è&& 
d
.cÜru±è|| (BoŞ(
ignÜeD’›dD©a
è&& d.
d’›d
)

311 
´štf
(
log
 + " crøğ0x%x %d\n", 
d_üc
, 
mu¡_m©ch
.
asUIÁ
)

312 
wh’
 (!
cÜru±
 && 
mu¡_m©ch
 && 
d_üc
 =/ğ
d_üc_check
è{ 
´štf
("EXPECTED: 0x%x\n", d_crc_check) }

313 
as£¹
 (
cÜru±
 || !
mu¡_m©ch
 || 
d_üc
 ==ğ
d_üc_check
)

318 
v®
 
	gd_waddr
 = 
Mux
(
we
, 
weIndex
, 
d_addr_hi
)

319 
	gi
 <- 0 
uÁ
 
	gb—tBy‹s
) {

320 
v®
 
	gd©a
 = 
Mux
(
we
, 
UIÁ
(0), 
d_dec_by‹s
(
i
) + UInt(1))

321 
wh’
 (
dec_by‹s_w’
(
i
)) {

322 
dec_by‹s
(
i
).
wr™e
(
d_waddr
, 
d©a
)

326 
	gi
 <- 0 
uÁ
 
	gdec_Œ“s
.
	gsize
) {

327 
v®
 
	gd©a
 = 
Mux
(
we
, 
UIÁ
(0), 
d_dec_Œ“s
(
i
) + UInt(1))

328 
wh’
 (
dec_Œ“s_w’
(
i
)) {

329 
dec_Œ“s
(
i
).
wr™e
(
d_waddr
 >> (i+1), 
d©a
)

336 
objeù
 
	gTLRAMMod–


338 
def
 
­¶y
(
log
: 
SŒšg
 = "", 
ignÜeCÜru±D©a
: 
BoŞ—n
 = 
çl£
, 
ignÜeD’›dD©a
: BoŞ—Àğ
Œue
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

340 
v®
 
mod–
 = 
LazyModuË
(
Ãw
 
TLRAMMod–
(
log
, 
ignÜeCÜru±D©a
, 
ignÜeD’›dD©a
))

341 
	gmod–
.
	gnode


344 
şass
 
MÚ™ÜP¬am‘”s
(
add»ssB™s
: 
IÁ
, 
sizeB™s
: Int)

346 şas 
	cBy‹MÚ™Ü
(
·¿ms
: 
MÚ™ÜP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
) {

347 
v®
 
v®id
 = 
	`BoŞ
()

348 
v®
 
v®ue
 = 
	`UIÁ
(
width
 = 8)

349 
	}
}

350 şas 
	cFlightMÚ™Ü
(
·¿ms
: 
MÚ™ÜP¬am‘”s
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
) {

351 
v®
 
ba£
 = 
	`UIÁ
(
width
 = 
·¿ms
.
add»ssB™s
)

352 
v®
 
size
 = 
	`UIÁ
(
width
 = 
·¿ms
.
sizeB™s
)

353 
v®
 
İcode
 = 
	`UIÁ
(
width
 = 3)

354 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RationalCrossing.scala

10 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


12 
impÜt
 
	gChi£l
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


15 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


17 şas 
	cTLR©iÚ®CrossšgSourû
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


19 
v®
 
node
 = 
	$TLR©iÚ®SourûNode
()

21 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

22 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

23 
v®
 
bû
 = 
edgeIn
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeIn.
ş›Á
.
ªySuµÜtProbe


24 
v®
 
dœeùiÚ
 = 
edgeOut
.
mªag”
.direction

26 
out
.
a
 <> 
	`ToR©iÚ®
(
š
.a, 
dœeùiÚ
)

27 
š
.
d
 <> 
	`FromR©iÚ®
(
out
.d, 
dœeùiÚ
.
æ
)

29 ià(
bû
) {

30 
š
.
b
 <> 
	`FromR©iÚ®
(
out
.b, 
dœeùiÚ
.
æ
)

31 
out
.
c
 <> 
	`ToR©iÚ®
(
š
.c, 
dœeùiÚ
)

32 
out
.
e
 <> 
	`ToR©iÚ®
(
š
.e, 
dœeùiÚ
)

34 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

35 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

36 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

37 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

38 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

39 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

40 
out
.
b
.
sšk
 :ğ
	`UIÁ
(0)

41 
out
.
c
.
sourû
 :ğ
	`UIÁ
(0)

42 
out
.
e
.
sourû
 :ğ
	`UIÁ
(0)

46 
	}
}

48 
şass
 
	$TLR©iÚ®CrossšgSšk
(
dœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


50 
v®
 
node
 = 
	`TLR©iÚ®SškNode
(
dœeùiÚ
)

52 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

53 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

54 
v®
 
bû
 = 
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 &&ƒdgeOut.
ş›Á
.
ªySuµÜtProbe


55 
v®
 
dœeùiÚ
 = 
edgeIn
.
mªag”
.direction

57 
out
.
a
 <> 
	`FromR©iÚ®
(
š
.a, 
dœeùiÚ
)

58 
š
.
d
 <> 
	`ToR©iÚ®
(
out
.d, 
dœeùiÚ
.
æ
)

60 ià(
bû
) {

61 
š
.
b
 <> 
	`ToR©iÚ®
(
out
.b, 
dœeùiÚ
.
æ
)

62 
out
.
c
 <> 
	`FromR©iÚ®
(
š
.c, 
dœeùiÚ
)

63 
out
.
e
 <> 
	`FromR©iÚ®
(
š
.e, 
dœeùiÚ
)

65 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

66 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

67 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

68 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

69 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

70 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

71 
š
.
b
.
sourû
 :ğ
	`UIÁ
(0)

72 
š
.
c
.
sšk
 :ğ
	`UIÁ
(0)

73 
š
.
e
.
sšk
 :ğ
	`UIÁ
(0)

77 
	}
}

79 
objeù
 
TLR©iÚ®CrossšgSourû


81 
def
 
­¶y
()(
im¶ic™
 
p
: 
P¬am‘”s
) =

83 
v®
 
rsourû
 = 
LazyModuË
(
Ãw
 
TLR©iÚ®CrossšgSourû
)

84 
rsourû
.
node


88 
objeù
 
TLR©iÚ®CrossšgSšk


90 
def
 
­¶y
(
dœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
)(
im¶ic™
 
p
: 
P¬am‘”s
) =

92 
v®
 
rsšk
 = 
LazyModuË
(
Ãw
 
TLR©iÚ®CrossšgSšk
(
dœeùiÚ
))

93 
rsšk
.
node


97 @
d•»ÿ‹d
("TLRationalCrossing is fragile. Use TLRationalCrossingSource‡nd TLRationalCrossingSink", "rocket-chip 1.2")

98 
şass
 
	$TLR©iÚ®Crossšg
(
dœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


100 
v®
 
sourû
 = 
	`LazyModuË
(
Ãw
 
TLR©iÚ®CrossšgSourû
)

101 
v®
 
sšk
 = 
	`LazyModuË
(
Ãw
 
	`TLR©iÚ®CrossšgSšk
(
dœeùiÚ
))

102 
v®
 
node
 = 
	`NodeHªdË
(
sourû
.node, 
sšk
.node)

104 
sšk
.
node
 :ğ
sourû
.node

106 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

107 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

108 
v®
 
š_şock
 = 
	`Clock
(
INPUT
)

109 
v®
 
š_»£t
 = 
	`BoŞ
(
INPUT
)

110 
v®
 
out_şock
 = 
	`Clock
(
INPUT
)

111 
v®
 
out_»£t
 = 
	`BoŞ
(
INPUT
)

114 
sourû
.
moduË
.
şock
 :ğ
io
.
š_şock


115 
sourû
.
moduË
.
»£t
 :ğ
io
.
š_»£t


116 
sšk
.
moduË
.
şock
 :ğ
io
.
out_şock


117 
sšk
.
moduË
.
»£t
 :ğ
io
.
out_»£t


119 
	}
}

122 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


124 
şass
 
	$TLRAMR©iÚ®CrossšgSourû
(
Çme
: 
SŒšg
, 
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

125 
v®
 
node
 = 
	`TLR©iÚ®Id’t™yNode
()

126 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

127 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
(
Çme
))

129 (
node


130 :ğ
	`TLR©iÚ®CrossšgSourû
()

131 :ğ
	`TLD–ay”
(0.25)

132 :ğ
mod–
.
node


133 :ğ
fuzz
.
node
)

135 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

136 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

137 
v®
 
fšished
 = 
	`BoŞ
(
OUTPUT
)

139 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

141 
	}
}

143 şas 
	cTLRAMR©iÚ®CrossšgSšk
(
dœeùiÚ
: 
R©iÚ®DœeùiÚ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

144 
v®
 
node
 = 
	$TLR©iÚ®Id’t™yNode
()

145 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	$Add»ssS‘
(0x0, 0x3ff)))

147 (
¿m
.
node


148 :ğ
	$TLF¿gm’‹r
(4, 256)

149 :ğ
	$TLD–ay”
(0.25)

150 :ğ
	$TLR©iÚ®CrossšgSšk
(
dœeùiÚ
)

151 :ğ
node
)

153 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) { }

154 
	}
}

156 şas 
	cTLRAMR©iÚ®Crossšg
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

157 
v®
 
sym_ç¡_sourû
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMR©iÚ®CrossšgSourû
("R©iÚ®Crossšg sym_ç¡", 
txns
))

158 
v®
 
sym_¦ow_sšk
 = 
	`LazyModuË
(
Ãw
 
	$TLRAMR©iÚ®CrossšgSšk
(
Symm‘ric
))

159 
sym_¦ow_sšk
.
node
 :ğ
sym_ç¡_sourû
.node

161 
v®
 
sym_¦ow_sourû
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMR©iÚ®CrossšgSourû
("R©iÚ®Crossšg sym_¦ow", 
txns
))

162 
v®
 
sym_ç¡_sšk
 = 
	`LazyModuË
(
Ãw
 
	$TLRAMR©iÚ®CrossšgSšk
(
Symm‘ric
))

163 
sym_ç¡_sšk
.
node
 :ğ
sym_¦ow_sourû
.node

165 
v®
 
fix_ç¡_sourû
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMR©iÚ®CrossšgSourû
("R©iÚ®Crossšg fa¡", 
txns
))

166 
v®
 
fix_¦ow_sšk
 = 
	`LazyModuË
(
Ãw
 
	$TLRAMR©iÚ®CrossšgSšk
(
Fa¡ToSlow
))

167 
fix_¦ow_sšk
.
node
 :ğ
fix_ç¡_sourû
.node

169 
v®
 
fix_¦ow_sourû
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMR©iÚ®CrossšgSourû
("R©iÚ®Crossšg slow", 
txns
))

170 
v®
 
fix_ç¡_sšk
 = 
	`LazyModuË
(
Ãw
 
	$TLRAMR©iÚ®CrossšgSšk
(
SlowToFa¡
))

171 
fix_ç¡_sšk
.
node
 :ğ
fix_¦ow_sourû
.node

173 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

174 
io
.
fšished
 :=

175 
sym_ç¡_sourû
.
moduË
.
io
.
fšished
 &&

176 
sym_¦ow_sourû
.
moduË
.
io
.
fšished
 &&

177 
fix_ç¡_sourû
.
moduË
.
io
.
fšished
 &&

178 
fix_¦ow_sourû
.
moduË
.
io
.
fšished


181 
v®
 
ç¡
 = 
	`ModuË
(
Ãw
 
	`Pow2ClockDivid”
(1))

182 
sym_ç¡_sourû
.
moduË
.
şock
 :ğ
ç¡
.
io
.
şock_out


183 
sym_ç¡_sšk
 .
moduË
.
şock
 :ğ
ç¡
.
io
.
şock_out


184 
fix_ç¡_sourû
.
moduË
.
şock
 :ğ
ç¡
.
io
.
şock_out


185 
fix_ç¡_sšk
 .
moduË
.
şock
 :ğ
ç¡
.
io
.
şock_out


188 
v®
 
¦ow
 = 
	`ModuË
(
Ãw
 
	`Pow2ClockDivid”
(2))

189 
fix_¦ow_sourû
.
moduË
.
şock
 :ğ
¦ow
.
io
.
şock_out


190 
fix_¦ow_sšk
 .
moduË
.
şock
 :ğ
¦ow
.
io
.
şock_out


192 
v®
 
odd
 = 
	`ModuË
(
Ãw
 
ClockDivid”3
)

193 
odd
.
io
.
şk_š
 :ğ
şock


194 
sym_¦ow_sourû
.
moduË
.
şock
 :ğ
odd
.
io
.
şk_out


195 
sym_¦ow_sšk
 .
moduË
.
şock
 :ğ
odd
.
io
.
şk_out


197 
	}
}

199 
şass
 
	$TLRAMR©iÚ®CrossšgTe¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

200 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMR©iÚ®Crossšg
(
txns
)).
moduË
)

201 
io
.
fšished
 :ğ
dut
.io.finished

202 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegionReplication.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
şass
 
	$RegiÚR•liÿtÜ
(
mask
: 
BigIÁ
 = 0)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

12 
def
 
ids
 = 
Add»ssS‘
.
	`’um”©eMask
(
mask
)

14 
v®
 
node
 = 
	`TLAd­‹rNode
(

15 
ş›ÁFn
 = { 
ı
 => cp },

16 
mªag”Fn
 = { 
mp
 => mp.
	`cİy
(
mªag”s
 = mp.mªag”s.
m­
 { 
m
 => m.copy(

17 
add»ss
 = 
m
.add»ss.
æ©M­
 { 
a
 => 
ids
.
m­
 { 
id
 =>

18 
	`Add»ssS‘
(
a
.
ba£
 | 
id
,‡.
mask
) } })})})

20 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

21 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

22 
out
 <> 
š


23 
out
.
a
.
b™s
.
add»ss
 :ğ~(~
š
.a.b™s.add»s | 
mask
.
U
)

26 
edgeOut
.
mªag”
.
mªag”s
.
fÜ—ch
 { 
m
 =>

27 
	`»quœe
 (
m
.
»giÚTy³
 < 
RegiÚTy³
.
TRACKED
, 
s
"${m.name} has„egionType ${m.regionType}, which„equires Probe support‡ RegionReplicator cannot…rovide")

31 
	}
}

33 
objeù
 
	gRegiÚR•liÿtÜ
 {

34 
def
 
­¶y
(
mask
: 
BigIÁ
 = 0)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 = {

35 
v®
 
»¶iÿtÜ
 = 
LazyModuË
(
Ãw
 
RegiÚR•liÿtÜ
(
mask
))

36 
»¶iÿtÜ
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
RawModuË


7 
impÜt
 
	gfœ¹l
.
	gªnÙ©iÚs
.
ModuËName


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gš‹¼u±s
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gEÏbÜ©iÚA¹eçùs
, 
	gG’RegDescsAÂo
, 
	gH‘”og’eousBag
}

14 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmax
, 
	gmš
}

16 
şass
 
TLRegi¡”Node
(

17 
add»ss
: 
Seq
[
Add»ssS‘
],

18 
deviû
: 
Deviû
,

19 
deviûKey
: 
SŒšg
 = "reg/control",

20 
cÚcu¼’cy
: 
IÁ
 = 0,

21 
b—tBy‹s
: 
IÁ
 = 4,

22 
undefZ”o
: 
BoŞ—n
 = 
Œue
,

23 
execubË
: 
BoŞ—n
 = 
çl£
)(

24 
im¶ic™
 
v®Name
: 
V®Name
)

25 
ex‹nds
 
	$SškNode
(
TLImp
)(
	`Seq
(
	`TLMªag”PÜtP¬am‘”s
(

26 
	`Seq
(
	`TLMªag”P¬am‘”s
(

27 
add»ss
 =‡ddress,

28 
»sourûs
 = 
	`Seq
(
	`Resourû
(
deviû
, 
deviûKey
)),

29 
execubË
 =ƒxecutable,

30 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

31 
suµÜtsPutP¬tŸl
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

32 
suµÜtsPutFuÎ
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

33 
fifoId
 = 
	`Some
(0))),

34 
b—tBy‹s
 = beatBytes,

35 
mšL©’cy
 = 
	$mš
(
cÚcu¼’cy
, 1))))

37 
v®
 
size
 = 1 << 
	`log2Ce
(1 + 
add»ss
.
	`m­
(
_
.
max
).max -‡dd»ss.m­(_.
ba£
).
mš
)

38 
	`»quœe
 (
size
 >ğ
b—tBy‹s
)

39 
add»ss
.
fÜ—ch
 { 
a
 =>

40 
	`»quœe
 (
a
.
	`wid’
(
size
-1).
ba£
 =ğ
add»ss
.
h—d
.widen(size-1).base,

41 
s
"TLRegisterNode‡ddresses (${address}) must be‡lignedo its size ${size}")

46 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*) = {

47 
	`v®
 (
bundËIn
, 
edge
èğ
this
.
	`š
(0)

48 
v®
 
a
 = 
bundËIn
.a

49 
v®
 
d
 = 
bundËIn
.d

52 
v®
 
ba£End
 = 0

53 
	`v®
 (
sizeEnd
, 
sizeOff
èğ(
edge
.
bundË
.
sizeB™s
 + 
ba£End
, baseEnd)

54 
	`v®
 (
sourûEnd
, 
sourûOff
èğ(
edge
.
bundË
.
sourûB™s
 + 
sizeEnd
, sizeEnd)

56 
v®
 
·¿ms
 = 
	`RegM­³rP¬ams
(
	`log2Up
(
size
/
b—tBy‹s
), b—tBy‹s, 
sourûEnd
)

57 
v®
 
š
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`RegM­³rIÅut
(
·¿ms
)))

58 
š
.
b™s
.
»ad
 :ğ
a
.b™s.
İcode
 ==ğ
TLMes§ges
.
G‘


59 
š
.
b™s
.
šdex
 :ğ
edge
.
	`addr_hi
(
a
.bits)

60 
š
.
b™s
.
d©a
 :ğ
a
.bits.data

61 
š
.
b™s
.
mask
 :ğ
a
.bits.mask

62 
š
.
b™s
.
exŒa
 :ğ
	`C©
(
a
.b™s.
sourû
,‡.b™s.
size
)

65 
v®
 
out
 = 
	`RegM­³r
(
b—tBy‹s
, 
cÚcu¼’cy
, 
undefZ”o
, 
š
, 
m­pšg
:
_
*)

68 
š
.
v®id
 :ğ
a
.valid

69 
a
.
»ady
 :ğ
š
.ready

70 
d
.
v®id
 :ğ
out
.valid

71 
out
.
»ady
 :ğ
d
.ready

74 
d
.
b™s
 :ğ
edge
.
	`AcûssAck
(

75 
toSourû
 = 
out
.
b™s
.
	`exŒa
(
sourûEnd
-1, 
sourûOff
),

76 
lgSize
 = 
out
.
b™s
.
	`exŒa
(
sizeEnd
-1, 
sizeOff
))

79 
d
.
b™s
.
d©a
 :ğ
out
.bits.data

80 
d
.
b™s
.
İcode
 :ğ
	`Mux
(
out
.b™s.
»ad
, 
TLMes§ges
.
AcûssAckD©a
, TLMes§ges.
AcûssAck
)

83 
bundËIn
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

84 
bundËIn
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

85 
bundËIn
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

87 
	`g’RegDescsJsÚ
(
m­pšg
:
_
*)

91 
def
 
	`g’RegDescsJsÚ
(
m­pšg
: 
RegF›ld
.
M­
*) {

93 
v®
 
ba£
 = 
add»ss
.
h—d
.base

94 
v®
 
ba£Hex
 = 
s
"0x${base.toInt.toHexString}"

95 
v®
 
Çme
 = 
s
"deviceAt${baseHex}"

96 
v®
 
jsÚ
 = 
G’RegDescsAÂo
.
	`£rŸlize
(
ba£
, 
Çme
, 
m­pšg
:
_
*)

97 
v¬
 
suffix
 = 0

98  
EÏbÜ©iÚA¹eçùs
.
	`cÚšs
(
s
"${baseHex}.${suffix}.regmap.json")) {

99 
suffix
 = suffix + 1

101 
EÏbÜ©iÚA¹eçùs
.
	`add
(
s
"${ba£Hex}.${suffix}.»gm­.jsÚ", 
jsÚ
)

103 
v®
 
moduË
 = 
ModuË
.
cu¼’tModuË
.
g‘
.
asIn¡ªûOf
[
RawModuË
]

104 
G’RegDescsAÂo
.
	`ªno
(

105 
moduË
,

106 
ba£
,

107 
m­pšg
:
_
*)

110 
	}
}

114 
ab¡¿ù
 
şass
 
	$TLRegi¡”Rou‹rBa£
(
devÇme
: 
SŒšg
, 
devcom·t
: 
Seq
[SŒšg], 
v®
 
add»ss
: 
Add»ssS‘
, 
š‹¼u±s
: 
IÁ
, 
cÚcu¼’cy
: IÁ, 
b—tBy‹s
: IÁ, 
undefZ”o
: 
BoŞ—n
, 
execubË
: BoŞ—n)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


117 
def
 
	`exŒaResourûs
(
»sourûs
: 
ResourûBšdšgs
èğ
M­
[
SŒšg
, 
Seq
[
ResourûV®ue
]]()

118 
v®
 
deviû
 = 
Ãw
 
	`Sim¶eDeviû
(
devÇme
, 
devcom·t
) {

119 
ov”ride
 
def
 
	`desüibe
(
»sourûs
: 
ResourûBšdšgs
): 
DesütiÚ
 = {

120 
v®
 
	`DesütiÚ
(
Çme
, 
m­pšg
èğ
su³r
.
	`desüibe
(
»sourûs
)

121 
	`DesütiÚ
(
Çme
, 
m­pšg
 ++ 
	`exŒaResourûs
(
»sourûs
))

125 
v®
 
node
 = 
	`TLRegi¡”Node
(
	`Seq
(
add»ss
), 
deviû
, "»g/cÚŒŞ", 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

126 
v®
 
šŠode
 = 
	`IÁSourûNode
(
	`IÁSourûPÜtSim¶e
(
num
 = 
š‹¼u±s
, 
»sourûs
 = 
	`Seq
(
	`Resourû
(
deviû
, "int"))))

127 
	}
}

129 şas 
	cTLRegBundËArg
()(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
)

131 şas 
	cTLRegBundËBa£
(
¬g
: 
TLRegBundËArg
è
ex‹nds
 
BundË


133 
im¶ic™
 
v®
 
p
 = 
¬g
.p

136 
şass
 
TLRegBundË
[
P
](
v®
 
·¿ms
: P, v® 
¬g
: 
TLRegBundËArg
è
ex‹nds
 
	$TLRegBundËBa£
(
¬g
)

138 
şass
 
TLRegModuË
[
P
, 
B
 <: 
TLRegBundËBa£
](
v®
 
·¿ms
: P, 
bundËBud”
: => B, 
rou‹r
: 
TLRegi¡”Rou‹rBa£
)

139 
ex‹nds
 
	$LazyModuËImp
(
rou‹r
è
w™h
 
HasRegM­


141 
v®
 
io
 = 
	`IO
(
bundËBud”
)

142 
v®
 
š‹¼u±s
 = ià(
rou‹r
.
šŠode
.
out
.
isEm±y
è
	`Vec
(0, 
	`BoŞ
()èrou‹r.šŠode.
	`out
(0).
_1


143 
v®
 
add»ss
 = 
rou‹r
.address

144 
def
 
	`»gm­
(
m­pšg
: 
RegF›ld
.
M­
*èğ
rou‹r
.
node
.»gm­(m­pšg:
_
*)

145 
	}
}

147 
şass
 
TLRegi¡”Rou‹r
[
B
 <: 
TLRegBundËBa£
, 
M
 <: 
LazyModuËImp
](

148 
v®
 
ba£
: 
BigIÁ
,

149 
v®
 
	gdevÇme
: 
SŒšg
,

150 
v®
 
	gdevcom·t
: 
Seq
[
SŒšg
],

151 
v®
 
	gš‹¼u±s
: 
IÁ
 = 0,

152 
v®
 
	gsize
: 
BigIÁ
 = 4096,

153 
v®
 
	gcÚcu¼’cy
: 
IÁ
 = 0,

154 
v®
 
	gb—tBy‹s
: 
IÁ
 = 4,

155 
v®
 
	gundefZ”o
: 
BoŞ—n
 = 
Œue
,

156 
v®
 
	gexecubË
: 
BoŞ—n
 = 
çl£
)

157 (
bundËBud”
: 
TLRegBundËArg
 => 
B
)

158 (
moduËBud”
: (=> 
B
, 
	gTLRegi¡”Rou‹rBa£
è=> 
M
)(
im¶ic™
 
p
: 
P¬am‘”s
)

159 
ex‹nds
 
TLRegi¡”Rou‹rBa£
(
devÇme
, 
devcom·t
, 
Add»ssS‘
(
ba£
, 
size
-1), 
š‹¼u±s
, 
cÚcu¼’cy
, 
b—tBy‹s
, 
undefZ”o
, 
execubË
)

161 
»quœe
 (
isPow2
(
size
))

164 
Ïzy
 
v®
 
	gmoduË
 = 
moduËBud”
(
bundËBud”
(
TLRegBundËArg
()), 
this
)

170 
Œa™
 
	gHasTLCÚŒŞRegM­
 { 
	gthis
: 
Regi¡”Rou‹r
[
_
] =>

171 
´Ùeùed
 
v®
 
cÚŒŞNode
 = 
TLRegi¡”Node
(

172 
add»ss
 =‡ddress,

173 
deviû
 = device,

174 
deviûKey
 = "reg/control",

175 
cÚcu¼’cy
 = concurrency,

176 
b—tBy‹s
 = beatBytes,

177 
undefZ”o
 = undefZero,

178 
execubË
 =ƒxecutable)

181 
v®
 
cÚŒŞXšg
: 
TLInw¬dCrossšgH–³r
 = 
this
.
üossIn
(
cÚŒŞNode
)

184 
´Ùeùed
 
def
 
»gm­
(
m­pšg
: 
RegF›ld
.
M­
*è{ 
cÚŒŞNode
.»gm­(m­pšg:
_
*) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouterTest.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
MuÉiIOModuË


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.{
	gPow2ClockDivid”
}

13 
objeù
 
	gLFSR16S“d


15 
def
 
­¶y
(
£ed
: 
IÁ
): 
UIÁ
 =

17 
v®
 
width
 = 16

18 
v®
 
lf¤
 = 
Reg
(
š™
=
UIÁ
((
£ed
*0x7231è% 65536, 
width
))

19 
	glf¤
 :ğ
C©
(
lf¤
(0)^lf¤(2)^lf¤(3)^lf¤(5),†f¤(
width
-1,1))

20 
	glf¤


24 
şass
 
RRTe¡Combš©iÚ®
(
v®
 
b™s
: 
IÁ
, 
rv®id
: 
BoŞ
 => BoŞ, 
w»ady
: BoŞ => BoŞè
ex‹nds
 
ModuË


26 
v®
 
io
 = 
Ãw
 
BundË
 {

27 
v®
 
rv®id
 = 
BoŞ
(
OUTPUT
)

28 
v®
 
¼—dy
 = 
BoŞ
(
INPUT
)

29 
v®
 
rd©a
 = 
UIÁ
(
OUTPUT
, 
width
 = 
b™s
)

30 
v®
 
wv®id
 = 
BoŞ
(
INPUT
)

31 
v®
 
w»ady
 = 
BoŞ
(
OUTPUT
)

32 
v®
 
wd©a
 = 
UIÁ
(
INPUT
, 
width
 = 
b™s
)

35 
v®
 
	g»g
 = 
RegIn™
(
UIÁ
(0, 
width
 = 
b™s
))

37 
v®
 
rv®id_s
 = 
rv®id
(
io
.
¼—dy
)

38 
v®
 
w»ady_s
 = 
w»ady
(
io
.
wv®id
)

39 
io
.
rv®id
 :ğ
rv®id_s


40 
io
.
w»ady
 :ğ
w»ady_s


42 
io
.
rd©a
 :ğ
Mux
(
rv®id_s
 && io.
¼—dy
, 
»g
, 
UIÁ
(0))

43 
wh’
 (
io
.
wv®id
 && 
w»ady_s
è{ 
	g»g
 :ğio.
wd©a
 }

46 
objeù
 
RRTe¡Combš©iÚ®


48 
´iv©e
 
v¬
 
£ed
 = 42

50 
def
 
®ways
: 
BoŞ
 => BoŞ = 
_
 => BoŞ(
Œue
)

52 
def
 
¿ndom
: 
BoŞ
 => BoŞ = { 
»ady
 =>

53 
£ed
 = seed + 1

54 
LFSR16S“d
(
£ed
)(0)

57 
def
 
d–ay
(
x
: 
IÁ
): 
BoŞ
 => BoŞ = { 
»ady
 =>

58 
v®
 
»g
 = 
RegIn™
(
UIÁ
(0, 
width
 = 
log2Ce
(
x
+1)))

59 
v®
 
v®id
 = 
»g
 ==ğ
UIÁ
(0)

60 
»g
 :ğ
Mux
(
»ady
 && 
v®id
, 
UIÁ
(
x
), Mux(valid, UInt(0),„eg - UInt(1)))

61 
	gv®id


64 
def
 
combo
(
b™s
: 
IÁ
, 
rv®id
: 
BoŞ
 => BoŞ, 
w»ady
: BoŞ => BoŞ): 
RegF›ld
 = {

65 
v®
 
combo
 = 
ModuË
(
Ãw
 
RRTe¡Combš©iÚ®
(
b™s
, 
rv®id
, 
w»ady
))

66 
RegF›ld
(
b™s
,

67 
RegR—dFn
 { 
»ady
 => 
combo
.
io
.
¼—dy
 :ğ»ady; (combo.io.
rv®id
, combo.io.
rd©a
) },

68 
RegWr™eFn
 { (
v®id
, 
d©a
è=> 
combo
.
io
.
wv®id
 :ğv®id; combo.io.
wd©a
 :ğd©a; combo.io.
w»ady
 })

72 
şass
 
RRTe¡Reque¡
(
v®
 
b™s
: 
IÁ
,

73 
ræow
: (
BoŞ
, BoŞ, 
UIÁ
) => (Bool, Bool, UInt),

74 
wæow
: (
BoŞ
, BoŞ, 
UIÁ
è=> (BoŞ, BoŞ, UIÁ)è
ex‹nds
 
	gModuË


76 
v®
 
	gio
 = 
Ãw
 
BundË
 {

77 
v®
 
riv®id
 = 
BoŞ
(
INPUT
)

78 
v®
 
rœ—dy
 = 
BoŞ
(
OUTPUT
)

79 
v®
 
rov®id
 = 
BoŞ
(
OUTPUT
)

80 
v®
 
rÜ—dy
 = 
BoŞ
(
INPUT
)

81 
v®
 
rd©a
 = 
UIÁ
(
OUTPUT
, 
width
 = 
b™s
)

82 
v®
 
wiv®id
 = 
BoŞ
(
INPUT
)

83 
v®
 
wœ—dy
 = 
BoŞ
(
OUTPUT
)

84 
v®
 
wov®id
 = 
BoŞ
(
OUTPUT
)

85 
v®
 
wÜ—dy
 = 
BoŞ
(
INPUT
)

86 
v®
 
wd©a
 = 
UIÁ
(
INPUT
, 
width
 = 
b™s
)

89 
v®
 (
rœ—dy
, 
rov®id
, 
_
èğ
ræow
(
io
.
riv®id
, io.
rÜ—dy
, 
UIÁ
(0, 
width
 = 1))

90 
v®
 (
wœ—dy
, 
wov®id
, 
wd©a
èğ
wæow
(
io
.
wiv®id
, io.
wÜ—dy
, io.wdata)

91 
v®
 
	g»g
 = 
RegIn™
(
UIÁ
(0, 
width
 = 
b™s
))

93 
io
.
rœ—dy
 :=„iready

94 
io
.
rov®id
 :=„ovalid

95 
io
.
wœ—dy
 := wiready

96 
io
.
wov®id
 := wovalid

98 
v®
 
rofœe
 = 
io
.
rÜ—dy
 && 
rov®id


99 
v®
 
wofœe
 = 
io
.
wÜ—dy
 && 
wov®id


101 
io
.
rd©a
 :ğ
Mux
(
rofœe
, 
»g
, 
UIÁ
(0))

102 
wh’
 (
wofœe
è{ 
	g»g
 :ğ
wd©a
 }

105 
objeù
 
RRTe¡Reque¡


107 
´iv©e
 
v¬
 
£ed
 = 1231

108 
def
 
pe
(
x
: 
IÁ
): (
BoŞ
, 
	gBoŞ
, 
	gUIÁ
è=> (BoŞ, BoŞ, UIÁèğ{ (
iv®id
, 
Ü—dy
, 
id©a
) =>

109 
v®
 
fuÎ
 = 
RegIn™
(
Vec
.
fl
(
x
)(
BoŞ
(
çl£
)))

110 
v®
 
»ady
 = 
Wœe
(
Vec
(
x
, 
BoŞ
()))

111 
v®
 
	gd©a
 = 
Reg
(
Vec
(
x
, 
UIÁ
(
width
 = 
id©a
.
g‘Width
)))

113 
»ady
(
x
-1è:ğ
Ü—dy
 || !
fuÎ
(x-1)

114 
wh’
 (
»ady
(0)è{ 
d©a
(0è:ğ
id©a
 }

115 
wh’
 (
»ady
(0)è{ 
fuÎ
(0è:ğ
iv®id
 }

116 ((
»ady
.
š™
 
z
„—dy.

èz 
fuÎ
.š™è
fÜ—ch
 { ((
£lf
, 
	gÃxt
), 
	gfuÎ
) =>

117 
£lf
 :ğ
Ãxt
 || !
fuÎ


119 ((
d©a
.
š™
 
z
 d©a.

èz 
»ady
.è
fÜ—ch
 { ((
´ev
, 
	g£lf
), 
	g»ady
) =>

120 
wh’
 (
»ady
è{ 
£lf
 :ğ
´ev
 }

122 ((
fuÎ
.
š™
 
z
 fuÎ.

èz 
»ady
.è
fÜ—ch
 { ((
´ev
, 
	g£lf
), 
	g»ady
) =>

123 
wh’
 (
»ady
è{ 
£lf
 :ğ
´ev
 }

125 (
»ady
(0), 
fuÎ
(
x
-1), 
d©a
(x-1))

128 
def
 
	gbusy
: (
BoŞ
, 
	gBoŞ
, 
	gUIÁ
) => (Bool, Bool, UInt) = {

129 
£ed
 = seed + 1

130 (
iv®id
, 
	gÜ—dy
, 
	gid©a
) => {

131 
v®
 
lf¤
 = 
LFSR16S“d
(
£ed
)

132 
v®
 
busy
 = 
RegIn™
(
BoŞ
(
çl£
))

133 
v®
 
d©a
 = 
Reg
(
UIÁ
(
width
 = 
id©a
.
g‘Width
))

134 
v®
 
´og»ss
 = 
lf¤
(0)

135 
v®
 
œ—dy
 = 
´og»ss
 && !
busy


136 
v®
 
ov®id
 = 
´og»ss
 && 
busy


137 
wh’
 (
´og»ss
) {

138 
busy
 :ğ
Mux
(busy, !
Ü—dy
, 
iv®id
)

140 
wh’
 (
iv®id
 && 
œ—dy
è{ 
	gd©a
 :ğ
id©a
 }

141 (
œ—dy
, 
	gov®id
, 
	gd©a
)

145 
def
 
»que¡
(
b™s
: 
IÁ
,

146 
ræow
: (
BoŞ
, BoŞ, 
UIÁ
) => (Bool, Bool, UInt),

147 
wæow
: (
BoŞ
, BoŞ, 
UIÁ
è=> (BoŞ, BoŞ, UIÁ)): 
RegF›ld
 = {

148 
v®
 
»que¡
 = 
ModuË
(
Ãw
 
RRTe¡Reque¡
(
b™s
, 
ræow
, 
wæow
))

149 
RegF›ld
(
b™s
,

150 
RegR—dFn
 { (
riv®id
, 
rÜ—dy
) =>

151 
»que¡
.
io
.
riv®id
 :=„ivalid

152 
»que¡
.
io
.
rÜ—dy
 :=„oready

153 (
»que¡
.
io
.
rœ—dy
,„eque¡.io.
rov®id
,„eque¡.io.
rd©a
) },

154 
RegWr™eFn
 { (
wiv®id
, 
wÜ—dy
, 
wd©a
) =>

155 
»que¡
.
io
.
wiv®id
 := wivalid

156 
»que¡
.
io
.
wÜ—dy
 := woready

157 
»que¡
.
io
.
wd©a
 := wdata

158 (
»que¡
.
io
.
wœ—dy
,„eque¡.io.
wov®id
) })

162 
objeù
 
	gRRTe¡0M­


164 
impÜt
 
	gRRTe¡Combš©iÚ®
.
_


166 
def
 
¯
(
b™s
: 
IÁ
èğ
combo
(b™s, 
®ways
,‡lways)

167 
def
 
¬
(
b™s
: 
IÁ
èğ
combo
(b™s, 
®ways
, 
¿ndom
)

168 
def
 
ad
(
b™s
: 
IÁ
èğ
combo
(b™s, 
®ways
, 
d–ay
(11))

169 
def
 
«
(
b™s
: 
IÁ
èğ
combo
(b™s, 
®ways
, 
d–ay
(5))

170 
def
 
¿
(
b™s
: 
IÁ
èğ
combo
(b™s, 
¿ndom
, 
®ways
)

171 
def
 
¼
(
b™s
: 
IÁ
èğ
combo
(b™s, 
¿ndom
,„andom)

172 
def
 
rd
(
b™s
: 
IÁ
èğ
combo
(b™s, 
¿ndom
, 
d–ay
(11))

173 
def
 
»
(
b™s
: 
IÁ
èğ
combo
(b™s, 
¿ndom
, 
d–ay
(5))

174 
def
 
da
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(5), 
®ways
)

175 
def
 
dr
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(5), 
¿ndom
)

176 
def
 
dd
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(5), delay(5))

177 
def
 
de
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(5), delay(11))

178 
def
 
—
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(11), 
®ways
)

179 
def
 
”
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(11), 
¿ndom
)

180 
def
 
ed
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(11), delay(5))

181 
def
 
“
(
b™s
: 
IÁ
èğ
combo
(b™s, 
d–ay
(11), delay(11))

184 
def
 
	gm­
 = 
Seq
(

185 0 -> 
Seq
(
¯
(8), 
¬
(8), 
ad
(8), 
«
(8)),

186 4 -> 
Seq
(
¿
(8), 
¼
(8), 
rd
(8), 
»
(8)),

187 8 -> 
Seq
(
da
(8), 
dr
(8), 
dd
(8), 
de
(8)),

188 12 -> 
Seq
(
—
(8), 
”
(8), 
ed
(8), 
“
(8)),

189 16 -> 
Seq
(
¯
(3), 
¬
(5), 
ad
(1), 
«
(7), 
¿
(2), 
¼
(6), 
rd
(4), 
»
(4)),

190 20 -> 
Seq
(
da
(3), 
dr
(5), 
dd
(1), 
de
(7), 
—
(2), 
”
(6), 
ed
(4), 
“
(4)),

191 24 -> 
Seq
(
¯
(8), 
¼
(8), 
dd
(8), 
“
(8)),

192 28 -> 
Seq
(
¬
(8), 
rd
(8), 
de
(8), 
—
(8)))

195 
objeù
 
	gRRTe¡1M­


197 
impÜt
 
	gRRTe¡Reque¡
.
_


199 
def
 
µ
(
b™s
: 
IÁ
èğ
»que¡
(b™s, 
pe
(3),…ipe(3))

200 
def
 
pb
(
b™s
: 
IÁ
èğ
»que¡
(b™s, 
pe
(3), 
busy
)

201 
def
 
bp
(
b™s
: 
IÁ
èğ
»que¡
(b™s, 
busy
, 
pe
(3))

202 
def
 
bb
(
b™s
: 
IÁ
èğ
»que¡
(b™s, 
busy
, busy)

204 
def
 
	gm­
 = 
RRTe¡0M­
.
m­
.
ke
(6è++ 
Seq
(

205 24 -> 
Seq
(
µ
(8), 
pb
(8), 
bp
(8), 
bb
(8)),

206 28 -> 
Seq
(
µ
(3), 
pb
(5), 
bp
(1), 
bb
(7),…b(5), bp(3),…p(4), bb(4)))

209 
Œa™
 
	gRRTe¡0BundË


213 
Œa™
 
RRTe¡0ModuË
 
ex‹nds
 
	gHasRegM­


215 
»gm­
(
RRTe¡0M­
.
m­
:
_
*)

218 
şass
 
	$RRTe¡0
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	`TLRegi¡”Rou‹r
×dd»ss, "‹¡0", 
N
, 0, 32, 0, 4)(

219 
Ãw
 
	`TLRegBundË
((), 
_
è
w™h
 
RRTe¡0BundË
)(

220 
Ãw
 
	`TLRegModuË
((), 
_
, _è
w™h
 
RRTe¡0ModuË
)

222 
Œa™
 
RRTe¡1BundË


224 
	}
}

226 
Œa™
 
RRTe¡1ModuË
 
ex‹nds
 
MuÉiIOModuË
 
w™h
 
	gHasRegM­


228 
v®
 
	gşocks
 = 
ModuË
(
Ãw
 
Pow2ClockDivid”
(2))

230 
def
 
x
(
b™s
: 
IÁ
) = {

231 
v®
 
f›ld
 = 
UIÁ
(
width
 = 
b™s
)

233 
v®
 
»adCross
 = 
ModuË
(
Ãw
 
Regi¡”R—dCrossšg
(
f›ld
))

234 
»adCross
.
io
.
ma¡”_şock
 :ğ
şock


235 
»adCross
.
io
.
ma¡”_»£t
 :ğ
»£t


236 
»adCross
.
io
.
ma¡”_by·ss
 :ğ
BoŞ
(
çl£
)

237 
»adCross
.
io
.
¦ave_şock
 :ğ
şocks
.io.
şock_out


238 
»adCross
.
io
.
¦ave_»£t
 :ğ
»£t


240 
v®
 
wr™eCross
 = 
ModuË
(
Ãw
 
Regi¡”Wr™eCrossšg
(
f›ld
))

241 
wr™eCross
.
io
.
ma¡”_şock
 :ğ
şock


242 
wr™eCross
.
io
.
ma¡”_»£t
 :ğ
»£t


243 
wr™eCross
.
io
.
ma¡”_by·ss
 :ğ
BoŞ
(
çl£
)

244 
wr™eCross
.
io
.
¦ave_şock
 :ğ
şocks
.io.
şock_out


245 
wr™eCross
.
io
.
¦ave_»£t
 :ğ
»£t


247 
»adCross
.
io
.
¦ave_»gi¡”
 :ğ
wr™eCross
.io.slave_register

248 
RegF›ld
(
b™s
, 
»adCross
.
io
.
ma¡”_pÜt
, 
wr™eCross
.io.master_port)

251 
v®
 
	gm­
 = 
RRTe¡1M­
.
m­
.
drİ
(1è++ 
Seq
(0 -> Seq(
x
(8), x(8), x(8), x(8)))

252 
»gm­
(
m­
:
_
*)

255 
şass
 
	$RRTe¡1
(
add»ss
: 
BigIÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	`TLRegi¡”Rou‹r
×dd»ss, "‹¡1", 
N
, 0, 32, 6, 4)(

256 
Ãw
 
	`TLRegBundË
((), 
_
è
w™h
 
RRTe¡1BundË
)(

257 
Ãw
 
	`TLRegModuË
((), 
_
, _è
w™h
 
RRTe¡1ModuË
)

259 şas 
	cFuzzRRTe¡0
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

260 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

261 
v®
 
¼Œ
 = 
	`LazyModuË
(
Ãw
 
	$RRTe¡0
(0x400))

263 
¼Œ
.
node
 :ğ
	$TLF¿gm’‹r
(4, 32è:ğ
	$TLD–ay”
(0.1è:ğ
fuzz
.
node


265 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

266 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

268 
	}
}

270 
şass
 
	$TLRR0Te¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

271 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`FuzzRRTe¡0
(
txns
)).
moduË
)

272 
io
.
fšished
 :ğ
dut
.io.finished

273 
	}
}

275 şas 
	cFuzzRRTe¡1
(
txns
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

276 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	$TLFuzz”
(
txns
))

277 
v®
 
¼Œ
 = 
	`LazyModuË
(
Ãw
 
	$RRTe¡1
(0x400))

279 
¼Œ
.
node
 :ğ
	$TLF¿gm’‹r
(4, 32è:ğ
	$TLD–ay”
(0.1è:ğ
fuzz
.
node


281 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

282 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

284 
	}
}

286 
şass
 
	$TLRR1Te¡
(
txns
: 
IÁ
 = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

287 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`FuzzRRTe¡1
(
txns
)).
moduË
)

288 
io
.
fšished
 :ğ
dut
.io.finished

289 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SRAM.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
chi£lName


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


11 
şass
 
	$TLRAM
(

12 
add»ss
: 
Add»ssS‘
,

13 
ÿch—bË
: 
BoŞ—n
 = 
Œue
,

14 
execubË
: 
BoŞ—n
 = 
Œue
,

15 
b—tBy‹s
: 
IÁ
 = 4,

16 
eccBy‹s
: 
IÁ
 = 1,

17 
devName
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

18 
code
: 
Code
 = 
Ãw
 
Id’t™yCode
)

19 (
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Dlom©icSRAM
(
add»ss
, 
b—tBy‹s
, 
devName
)

21 
	`»quœe
 (
eccBy‹s
 >ğ1 && 
	`isPow2
(eccBytes))

22 
	`»quœe
 (
b—tBy‹s
 >ğ1 && 
	`isPow2
(beatBytes))

23 
	`»quœe
 (
eccBy‹s
 <ğ
b—tBy‹s
, 
s
"TLRAMƒccBytes (${eccBytes}) > beatBytes (${beatBytes}). Use‡ WidthWidget=>Fragmenter=>SRAM if you‚eed high density‡nd‚arrow ECC; it will do burstsƒfficiently")

25 
v®
 
node
 = 
	`TLMªag”Node
(
	`Seq
(
	`TLMªag”PÜtP¬am‘”s
(

26 
	`Seq
(
	`TLMªag”P¬am‘”s
(

27 
add»ss
 = 
	`Li¡
(address),

28 
»sourûs
 = 
deviû
.
	`»g
("mem"),

29 
»giÚTy³
 = ià(
ÿch—bË
è
RegiÚTy³
.
UNCACHED
 RegiÚTy³.
UNCACHEABLE
,

30 
execubË
 =ƒxecutable,

31 
suµÜtsG‘
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

32 
suµÜtsPutP¬tŸl
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

33 
suµÜtsPutFuÎ
 = 
	`T¿nsãrSizes
(1, 
b—tBy‹s
),

34 
fifoId
 = 
	`Some
(0))),

35 
b—tBy‹s
 = beatBytes,

36 
mšL©’cy
 = 1)))

38 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

39 
	`v®
 (
š
, 
edge
èğ
node
.
	`š
(0)

41 
v®
 
width
 = 
code
.
	`width
(
eccBy‹s
*8)

42 
v®
 
ÏÃs
 = 
b—tBy‹s
/
eccBy‹s


43 
v®
 
addrB™s
 = (
mask
 
z
 
edge
.
	`addr_hi
(
š
.
a
.
b™s
).
toBoŞs
).
	`f‹r
(
_
.
_1
).
	`m­
(_.
_2
)

44 
v®
 
mem
 = 
	`makeSšgËPÜ‹dBy‹Wr™eSeqMem
(1 << 
addrB™s
.
size
, 
ÏÃs
, 
width
)

58 
v®
 
d_fuÎ
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

59 
v®
 
d_¿m_v®id
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

60 
v®
 
d_size
 = 
	`Reg
(
	`UIÁ
())

61 
v®
 
d_sourû
 = 
	`Reg
(
	`UIÁ
())

62 
v®
 
d_»ad
 = 
	`Reg
(
	`BoŞ
())

63 
v®
 
d_add»ss
 = 
	`Reg
(
	`UIÁ
(
width
 = 
addrB™s
.
size
))

64 
v®
 
d_rmw_mask
 = 
	`Reg
(
	`UIÁ
(
width
 = 
b—tBy‹s
))

65 
v®
 
d_rmw_d©a
 = 
	`Reg
(
	`UIÁ
(
width
 = 8*
b—tBy‹s
))

66 
v®
 
d_poisÚ
 = 
	`Reg
(
	`BoŞ
())

69 
v®
 
d_¿w_d©a
 = 
	`Wœe
(
	`Vec
(
ÏÃs
, 
	`B™s
(
width
 = width)))

70 
v®
 
d_decoded
 = 
d_¿w_d©a
.
	`m­
(
ÏÃ
 => 
code
.
	`decode
(lane))

71 
v®
 
d_cÜ»ùed
 = 
	`C©
(
d_decoded
.
	`m­
(
_
.
cÜ»ùed
).
»v”£
)

72 
v®
 
d_uncÜ»ùed
 = 
	`C©
(
d_decoded
.
	`m­
(
_
.
uncÜ»ùed
).
»v”£
)

73 
v®
 
d_cÜ»ùabË
 = 
d_decoded
.
	`m­
(
_
.
cÜ»ùabË
)

74 
v®
 
d_uncÜ»ùabË
 = 
d_decoded
.
	`m­
(
_
.
uncÜ»ùabË
)

75 
v®
 
d_Ãed_fix
 = 
d_cÜ»ùabË
.
	`»duû
(
_
 || _)

76 
v®
 
d_”rÜ
 = 
d_uncÜ»ùabË
.
	`»duû
(
_
 || _)

79 
v®
 
d_wb_d©a
 = 
	`Vec
(
Seq
.
	`buÏ‹
(
b—tBy‹s
è{ 
i
 =>

80 
v®
 
upd
 = 
	`d_rmw_mask
(
i
)

81 
v®
 
rmw
 = 
	`d_rmw_d©a
 (8*(
i
+1)-1, 8*i)

82 
v®
 
fix
 = 
	`d_cÜ»ùed
(8*(
i
+1)-1, 8*i)

83 
	`Mux
(
upd
, 
rmw
, 
fix
)

84 }.
	`grou³d
(
eccBy‹s
).
	`m­
(
ÏÃ
 => 
	`C©
Öªe.
»v”£
)).
toLi¡
)

85 
	`v®
 (
d_wb_ÏÃs
, 
d_wb_poisÚ
èğ
Seq
.
	`buÏ‹
(
ÏÃs
è{ 
i
 =>

86 
v®
 
upd
 = 
	`d_rmw_mask
(
eccBy‹s
*(
i
+1)-1,ƒccBytes*i)

87 (
upd
.
ÜR
 || 
	`d_cÜ»ùabË
(
i
),

88 (!
upd
.
ªdR
 && 
	`d_uncÜ»ùabË
(
i
)è|| 
d_poisÚ
)

89 }.
unz


90 
v®
 
d_wb
 = 
d_rmw_mask
.
ÜR
 || (
d_¿m_v®id
 && 
d_Ãed_fix
)

93 
v®
 
d_h–d_d©a
 = 
	`RegEÇbË
(
d_cÜ»ùed
, 
d_¿m_v®id
)

94 
v®
 
d_h–d_”rÜ
 = 
	`RegEÇbË
(
d_”rÜ
, 
d_¿m_v®id
)

96 
š
.
d
.
b™s
.
İcode
 :ğ
	`Mux
(
d_»ad
, 
TLMes§ges
.
AcûssAckD©a
, TLMes§ges.
AcûssAck
)

97 
š
.
d
.
b™s
.
·¿m
 :ğ
	`UIÁ
(0)

98 
š
.
d
.
b™s
.
size
 :ğ
d_size


99 
š
.
d
.
b™s
.
sourû
 :ğ
d_sourû


100 
š
.
d
.
b™s
.
sšk
 :ğ
	`UIÁ
(0)

101 
š
.
d
.
b™s
.
d’›d
 :ğ
	`BoŞ
(
çl£
)

103 
š
.
d
.
b™s
.
d©a
 :ğ
	`Mux
(
d_¿m_v®id
, 
d_uncÜ»ùed
, 
d_h–d_d©a
)

104 
š
.
d
.
b™s
.
cÜru±
 :ğ
	`Mux
(
d_¿m_v®id
, 
d_”rÜ
, 
d_h–d_”rÜ
è&& 
d_»ad


107 
v®
 
d_·u£
 = 
d_»ad
 && 
d_¿m_v®id
 && 
d_Ãed_fix


108 
š
.
d
.
v®id
 :ğ
d_fuÎ
 && !
d_·u£


109 
š
.
a
.
»ady
 :ğ!
d_fuÎ
 || (š.
d
.»ady && !
d_·u£
 && !
d_wb
)

111 
v®
 
a_add»ss
 = 
	`C©
(
addrB™s
.
»v”£
)

112 
v®
 
a_»ad
 = 
š
.
a
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
G‘


113 
v®
 
a_d©a
 = 
	`Vec
(
Seq
.
	`buÏ‹
(
ÏÃs
è{ 
i
 => 
š
.
a
.
b™s
.
	`d©a
(
eccBy‹s
*8*(i+1)-1,ƒccBytes*8*i) })

121 
v®
 
a_subÏÃ
 = ià(
eccBy‹s
 =ğ1è
	`BoŞ
(
çl£
) 

122 
š
.
a
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
PutP¬tŸlD©a
 ||

123 
š
.
a
.
b™s
.
size
 < 
	`UIÁ
(
	`log2Ce
(
eccBy‹s
))

124 
v®
 
a_»n
 = 
a_»ad
 || 
a_subÏÃ


125 
v®
 
a_ÏÃs
 = 
Seq
.
	`buÏ‹
(
ÏÃs
è{ 
i
 => 
š
.
a
.
b™s
.
	`mask
(
eccBy‹s
*(i+1)-1,ƒccBy‹s*i).
ÜR
 }

127 
	`wh’
 (
š
.
d
.
	`fœe
()è{ 
d_fuÎ
 :ğ
	`BoŞ
(
çl£
) }

128 
d_¿m_v®id
 :ğ
	`BoŞ
(
çl£
)

129 
d_rmw_mask
 :ğ
	`UIÁ
(0)

130 
	`wh’
 (
š
.
a
.
	`fœe
()) {

131 
d_fuÎ
 :ğ
	`BoŞ
(
Œue
)

132 
d_¿m_v®id
 :ğ
a_»n


133 
d_size
 :ğ
š
.
a
.
b™s
.
size


134 
d_sourû
 :ğ
š
.
a
.
b™s
.
sourû


135 
d_»ad
 :ğ
a_»ad


136 
d_add»ss
 :ğ
a_add»ss


137 
d_rmw_mask
 :ğ
	`UIÁ
(0)

138 
d_poisÚ
 :ğ
š
.
a
.
b™s
.
cÜru±


139 
	`wh’
 (!
a_»ad
 && 
a_subÏÃ
) {

140 
d_rmw_mask
 :ğ
š
.
a
.
b™s
.
mask


141 
d_rmw_d©a
 :ğ
š
.
a
.
b™s
.
d©a


143 
d_h–d_”rÜ
:ğ
	`BoŞ
(
çl£
)

147 
v®
 
a_fœe
 = 
š
.
a
.
	`fœe
()

148 
v®
 
w’
 = 
d_wb
 || (
a_fœe
 && !
a_»n
)

150 
v®
 
»n
 = !
w’
 && 
a_fœe


152 
v®
 
addr
 = 
	`Mux
(
d_wb
, 
d_add»ss
, 
a_add»ss
)

153 
v®
 
£l
 = 
	`Mux
(
d_wb
, 
	`Vec
(
d_wb_ÏÃs
), Vec(
a_ÏÃs
))

154 
v®
 
d©
 = 
	`Mux
(
d_wb
, 
d_wb_d©a
, 
a_d©a
)

155 
v®
 
poisÚ
 = 
	`Mux
(
d_wb
, 
	`Vec
(
d_wb_poisÚ
), 
Vec
.
	`fl
(
ÏÃs
è{ 
š
.
a
.
b™s
.
cÜru±
 })

156 
v®
 
coded
 = 
	`Vec
((
d©
 
z
 
poisÚ
è
m­
 { (
d
, 
p
) =>

157 ià(
code
.
ÿnD‘eù
ècode.
	`’code
(
d
, 
p
) code.encode(d)

160 
d_¿w_d©a
 :ğ
mem
.
	`»ad
(
addr
, 
»n
)

161 
	`wh’
 (
w’
è{ 
mem
.
	`wr™e
(
addr
, 
coded
, 
£l
) }

164 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

165 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

166 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

168 
	}
}

170 
objeù
 
TLRAM


172 
def
 
­¶y
(

173 
add»ss
: 
Add»ssS‘
,

174 
ÿch—bË
: 
BoŞ—n
 = 
Œue
,

175 
execubË
: 
BoŞ—n
 = 
Œue
,

176 
b—tBy‹s
: 
IÁ
 = 4,

177 
eccBy‹s
: 
IÁ
 = 1,

178 
devName
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

179 
code
: 
Code
 = 
Ãw
 
Id’t™yCode
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLInw¬dNode
 =

181 
v®
 
¿m
 = 
LazyModuË
(
Ãw
 
TLRAM
(
add»ss
, 
ÿch—bË
, 
execubË
, 
b—tBy‹s
, 
eccBy‹s
, 
devName
, 
code
))

182 
	g¿m
.
	gnode


187 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


189 
şass
 
	$TLRAMSim¶e
(
¿mB—tBy‹s
: 
IÁ
, 
txns
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

190 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

191 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("SRAMSimple"))

192 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0x0, 0x3ff), 
b—tBy‹s
 = 
¿mB—tBy‹s
))

194 
¿m
.
node
 :ğ
	`TLD–ay”
(0.25è:ğ
mod–
.nod:ğ
fuzz
.node

196 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

197 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

199 
	}
}

201 
şass
 
	$TLRAMSim¶eTe¡
(
¿mB—tBy‹s
: 
IÁ
, 
txns
: IÁ = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

202 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMSim¶e
(
¿mB—tBy‹s
, 
txns
)).
moduË
)

203 
io
.
fšished
 :ğ
dut
.io.finished

204 
	}
}

206 
şass
 
	$TLRAMECC
(
¿mB—tBy‹s
: 
IÁ
, 
eccBy‹s
: IÁ, 
txns
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

207 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

208 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("SRAMSimple"))

209 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0x0, 0x3ff), 
b—tBy‹s
 = 
¿mB—tBy‹s
, 
eccBy‹s
 =ƒccBy‹s, 
code
 =‚ew 
SECDEDCode
))

211 
¿m
.
node
 :ğ
	`TLD–ay”
(0.25è:ğ
mod–
.nod:ğ
fuzz
.node

213 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

214 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

216 
	}
}

218 
şass
 
	$TLRAMECCTe¡
(
¿mB—tBy‹s
: 
IÁ
, 
eccBy‹s
: IÁ, 
txns
: IÁ = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

219 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMECC
(
¿mB—tBy‹s
, 
eccBy‹s
, 
txns
)).
moduË
)

220 
io
.
fšished
 :ğ
dut
.io.finished

221 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SourceShrinker.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

11 şas 
	cTLSourûShršk”
(
maxInFlight
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


13 
	`»quœe
 (
maxInFlight
 > 0)

16 
´iv©e
 
v®
 
ş›Á
 = 
	`TLCl›ÁP¬am‘”s
(

17 
Çme
 = "TLSourceShrinker",

18 
sourûId
 = 
	$IdRªge
(0, 
maxInFlight
))

19 
v®
 
node
 = 
	`TLAd­‹rNode
(

21 
ş›ÁFn
 = { 
ı
 => 
	`TLCl›ÁPÜtP¬am‘”s
(
ş›Ás
 = 
	`Seq
(
ş›Á
.
	`cİy
(
»que¡Fifo
 = cp.ş›Ás.
	`exi¡s
(
_
.requestFifo)))) },

22 
mªag”Fn
 = { 
mp
 => mp.
	`cİy
(
mªag”s
 = mp.mªag”s.
	`m­
(
m
 => m.cİy(
fifoId
 = ià(
maxInFlight
==1è
	`Some
(0èm.fifoId))è
	}
})

24 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

25 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

27 
	`»quœe
 (!
edgeIn
.
ş›Á
.
ªySuµÜtProbe
 ||

28 !
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
)

30 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

31 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

32 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

33 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

34 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

35 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

37 ià(
maxInFlight
 >ğ
edgeIn
.
ş›Á
.
’dSourûId
) {

38 
out
.
a
 <> 
š
.a

39 
š
.
d
 <> 
out
.d

42 
v®
 
sourûIdM­
 = 
	`Mem
(
maxInFlight
, 
š
.
a
.
b™s
.
sourû
)

43 
v®
 
®loÿ‹d
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
maxInFlight
))

44 
v®
 
ÃxtF»eOH
 = ~(
	`ËáOR
(~
®loÿ‹d
) << 1) & ~allocated

45 
v®
 
ÃxtF»e
 = 
	`OHToUIÁ
(
ÃxtF»eOH
)

46 
v®
 
fuÎ
 = 
®loÿ‹d
.
	`ªdR
()

48 
v®
 
a_fœ¡
 = 
edgeIn
.
	`fœ¡
(
š
.
a
)

49 
v®
 
d_Ï¡
 = 
edgeIn
.
	`Ï¡
(
š
.
d
)

51 
v®
 
block
 = 
a_fœ¡
 && 
fuÎ


52 
š
.
a
.
»ady
 :ğ
out
.a.»ady && !
block


53 
out
.
a
.
v®id
 :ğ
š
.a.v®id && !
block


54 
out
.
a
.
b™s
 :ğ
š
.a.bits

55 
out
.
a
.
b™s
.
sourû
 :ğ
ÃxtF»e
 
hŞdUÆess
 
a_fœ¡


57 
v®
 
by·ss
 = 
	`BoŞ
(
edgeOut
.
mªag”
.
mšL©’cy
 =ğ0è&& 
š
.
a
.
v®id
 && !
fuÎ
 && 
a_fœ¡
 && 
ÃxtF»e
 ==ğ
out
.
d
.
b™s
.
sourû


58 
š
.
d
 <> 
out
.d

59 
š
.
d
.
b™s
.
sourû
 :ğ
	`Mux
(
by·ss
, in.
a
.b™s.sourû, 
	`sourûIdM­
(
out
.d.bits.source))

61 
	`wh’
 (
a_fœ¡
 && 
š
.
a
.
	`fœe
()) {

62 
	`sourûIdM­
(
ÃxtF»e
è:ğ
š
.
a
.
b™s
.
sourû


65 
v®
 
®loc
 = 
a_fœ¡
 && 
š
.
a
.
	`fœe
()

66 
v®
 
ä“
 = 
d_Ï¡
 && 
š
.
d
.
	`fœe
()

67 
v®
 
®loc_id
 = 
	`Mux
(
®loc
, 
ÃxtF»eOH
, 
	`UIÁ
(0))

68 
v®
 
ä“_id
 = 
	`Mux
(
ä“
, 
	`UIÁToOH
(
out
.
d
.
b™s
.
sourû
), 
	`UIÁ
(0))

69 
®loÿ‹d
 :ğ×Îoÿ‹d | 
®loc_id
è& ~
ä“_id


72 
	}
}

75 
objeù
 
TLSourûShršk”


77 
def
 
­¶y
(
maxInFlight
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

79 
v®
 
shršk”
 = 
LazyModuË
(
Ãw
 
TLSourûShršk”
(
maxInFlight
))

80 
shršk”
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Splitter.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
şass
 
	gS¶™‹rArg
[
T
](
	gÃwSize
: 
IÁ
, 
	gpÜts
: 
Seq
[T])

10 
şass
 
TLS¶™‹rNode
(

11 
ş›ÁFn
: 
S¶™‹rArg
[
TLCl›ÁPÜtP¬am‘”s
] => 
Seq
[TLClientPortParameters],

12 
mªag”Fn
: 
S¶™‹rArg
[
TLMªag”PÜtP¬am‘”s
] => 
Seq
[TLManagerPortParameters])(

13 
im¶ic™
 
v®Name
: 
V®Name
)

14 
ex‹nds
 
TLCu¡omNode


16 
def
 
»sŞveSr
(
iKnown
: 
IÁ
, 
oKnown
: IÁ, 
iSrs
: IÁ, 
oSrs
: Int): (Int, Int) = {

17 
»quœe
 (
oKnown
 =ğ0, 
s
"${name} (a splitter)‡ppears„ight of‡ := or :*=; use‡ :=* instead${lazyModule.line}")

18 
»quœe
 (
iSrs
 =ğ0, 
s
"${name} (a splitter) cannot‡ppear†eft of‡ :*=; did you mean :=*?${lazyModule.line}")

19 (0, 
	giKnown
)

21 
def
 
m­P¬amsD
(
n
: 
IÁ
, 
p
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
]): Seq[TLClientPortParameters] = {

22 
»quœe
 (
p
.
size
 =ğ0 || 
n
 %….siz=ğ0, 
s
"Diplomacy bug; splitter inputs do‚ot divide outputs")

23 
v®
 
	gout
 = 
ş›ÁFn
(
S¶™‹rArg
(
n
, 
p
))

24 
»quœe
 (
out
.
size
 =ğ
n
, 
s
"${name} createdhe wrong‚umber of outputs from inputs${lazyModule.line}")

25 
	gout


27 
def
 
m­P¬amsU
(
n
: 
IÁ
, 
p
: 
Seq
[
TLMªag”PÜtP¬am‘”s
]): Seq[TLManagerPortParameters] = {

28 
»quœe
 (
n
 =ğ0 || 
p
.
size
 %‚ =ğ0, 
s
"Diplomacy bug; splitter outputs indivisable by inputs")

29 
v®
 
	gout
 = 
mªag”Fn
(
S¶™‹rArg
(
n
, 
p
))

30 
»quœe
 (
out
.
size
 =ğ
n
, 
s
"${name} createdhe wrong‚umber of inputs from outputs${lazyModule.line}")

31 
	gout


35 
şass
 
	$TLS¶™‹r
(
pŞicy
: 
TLArb™”
.
PŞicy
 = TLArb™”.
roundRobš
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


37 
v®
 
node
 = 
	`TLS¶™‹rNode
(

38 
ş›ÁFn
 = { 
	`S¶™‹rArg
(
ÃwSize
, 
pÜts
) =>

39 ià(
ÃwSize
 =ğ0è
N
 

40 
Seq
.
	`fl
(
ÃwSize
 / 
pÜts
.
size
è{…Üt }.
æ©‹n


42 
mªag”Fn
 = { 
	`S¶™‹rArg
(
ÃwSize
, 
pÜts
) =>

43 ià(
ÃwSize
 =ğ0è
N
 

44 
pÜts
.
	`grou³d
(
ÃwSize
).
toLi¡
.
Œª¥o£
.
m­
 { 
£q
 =>

45 
v®
 
fifoIdFaùÜy
 = 
TLXb¬
.
	`»Ïb–”
()

46 
	`£q
(0).
	`cİy
(

47 
mšL©’cy
 = 
£q
.
	`m­
(
_
.mšL©’cy).
mš
,

48 
’dSškId
 = 
TLXb¬
.
	`m­OuutIds
(
£q
).
	`m­
(
_
.
’d
).
max
,

49 
mªag”s
 = 
£q
.
æ©M­
 { 
pÜt
 =>

50 
	`»quœe
 (
pÜt
.
b—tBy‹s
 =ğ
	`£q
(0).beatBytes,

51 
s
"Splitter data widths don't match: ${port.managers.map(_.name)} has ${port.beatBytes}B vs ${seq(0).managers.map(_.name)} has ${seq(0).beatBytes}B")

52 
v®
 
fifoIdM­³r
 = 
	`fifoIdFaùÜy
()

53 
pÜt
.
mªag”s
 
m­
 { 
mªag”
 => mªag”.
	`cİy
(

54 
fifoId
 = 
mªag”
.fifoId.
	`m­
(
	`fifoIdM­³r
(
_
))

61 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

62 
def
 
group
[
T
](
x
: 
Seq
[T]) =

63 ià(
x
.
isEm±y
è
N
 x.
	`grou³d
(
node
.
š
.
size
).
toLi¡
.
Œª¥o£


65 ià(
node
.
out
.
size
 =ğnode.
š
.size) {

66 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((
i
, 
_
), (
o
, _)) => o <> i }

67 } (
node
.
š
 
z
 
	`group
Òode.
out
)è
fÜ—ch
 {

68 ((
io_š
, 
edgeIn
), 
£q
) =>

69 
	`v®
 (
io_out
, 
edgesOut
èğ
£q
.
unz


72 
v®
 
ouutIdRªges
 = 
TLXb¬
.
	`m­OuutIds
(
edgesOut
.
	`m­
(
_
.
mªag”
))

75 
v®
 
pÜt_addrs
 = 
edgesOut
.
	`m­
(
_
.
mªag”
.
mªag”s
.m­(_.
add»ss
).
æ©‹n
)

76 
v®
 
routšgMask
 = 
	`Add»ssDecod”
(
pÜt_addrs
)

77 
v®
 
rou‹_addrs
 = 
pÜt_addrs
.
	`m­
(
£q
 => 
Add»ssS‘
.
	`unify
(£q.m­(
_
.
	`wid’
(~
routšgMask
)).
di¡šù
))

78 
v®
 
ouutPÜts
 = 
rou‹_addrs
.
	`m­
(
£q
 => (
addr
: 
UIÁ
è=> seq.m­(
_
.
	`cÚšs
×ddr)).
	`»duû
(_ || _))

81 
v®
 
wide_bundË
 = 
TLBundËP¬am‘”s
.(
	`Seq
(
io_š
.
·¿ms
è++ 
io_out
.
	`m­
(
_
.params))

84 
v®
 
š
 = 
	`Wœe
(
	`TLBundË
(
wide_bundË
))

85 
š
.
a
 <> 
io_š
.a

86 
io_š
.
d
 <> 
š
.d

88 ià(
edgeIn
.
ş›Á
.
ªySuµÜtProbe
 && 
edgesOut
.
	`exi¡s
(
_
.
mªag”
.
ªySuµÜtAcquœeB
)) {

89 
š
.
c
 <> 
io_š
.c

90 
š
.
e
 <> 
io_š
.e

91 
io_š
.
b
 <> 
š
.b

93 
š
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

94 
š
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

95 
š
.
b
.
»ady
 :ğ
	`BoŞ
(
çl£
)

96 
io_š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

97 
io_š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

98 
io_š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

102 
def
 
	`Œim
(
id
: 
UIÁ
, 
size
: 
IÁ
èğià(siz<ğ1è
	`UIÁ
(0è
	`id
(
	`log2Ce
(size)-1, 0)

105 
v®
 
out
 = 
	`Wœe
(
	`Vec
(
io_out
.
size
, 
	`TLBundË
(
wide_bundË
)))

106 
i
 <- 0 
uÁ
 
out
.
size
) {

107 
v®
 
r
 = 
	`ouutIdRªges
(
i
)

109 
	`io_out
(
i
).
a
 <> 
	`out
(i).a

110 
	`out
(
i
).
d
 <> 
	`io_out
(i).d

111 
	`out
(
i
).
d
.
b™s
.
sšk
 :ğ
	`io_out
(i).d.b™s.sšk | 
	`UIÁ
(
r
.
¡¬t
)

113 ià(
	`edgesOut
(
i
).
mªag”
.
ªySuµÜtAcquœeB
 && 
edgeIn
.
ş›Á
.
ªySuµÜtProbe
) {

114 
	`io_out
(
i
).
c
 <> 
	`out
(i).c

115 
	`io_out
(
i
).
e
 <> 
	`out
(i).e

116 
	`out
(
i
).
b
 <> 
	`io_out
(i).b

117 
	`io_out
(
i
).
e
.
b™s
.
sšk
 :ğ
	`Œim
(
	`out
(i).e.b™s.sšk, 
r
.
size
)

119 
	`out
(
i
).
c
.
»ady
 :ğ
	`BoŞ
(
çl£
)

120 
	`out
(
i
).
e
.
»ady
 :ğ
	`BoŞ
(
çl£
)

121 
	`out
(
i
).
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

122 
	`io_out
(
i
).
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

123 
	`io_out
(
i
).
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

124 
	`io_out
(
i
).
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

128 
v®
 
»que¡A
 = 
	`Vec
(
ouutPÜts
.
m­
 { 
o
 => 
	`o
(
š
.
a
.
b™s
.
add»ss
) })

129 
v®
 
»que¡C
 = 
	`Vec
(
ouutPÜts
.
m­
 { 
o
 => 
	`o
(
š
.
c
.
b™s
.
add»ss
) })

130 
v®
 
»que¡E
 = 
	`Vec
(
ouutIdRªges
.
m­
 { 
o
 => o.
	`cÚšs
(
š
.
e
.
b™s
.
sšk
) })

131 (
out
.
	`m­
(
_
.
a
è
z
 
TLXb¬
.
	`çnout
(
š
.a, 
»que¡A
)è
fÜ—ch
 { (
o
, 
i
) => o <> i }

132 (
out
.
	`m­
(
_
.
c
è
z
 
TLXb¬
.
	`çnout
(
š
.c, 
»que¡C
)è
fÜ—ch
 { (
o
, 
i
) => o <> i }

133 (
out
.
	`m­
(
_
.
e
è
z
 
TLXb¬
.
	`çnout
(
š
.e, 
»que¡E
)è
fÜ—ch
 { (
o
, 
i
) => o <> i }

135 
v®
 
b—tsB
 = 
	`Vec
((
out
 
z
 
edgesOut
è
m­
 { (
o
, 
e
è=>ƒ.
	`numB—ts1
(o.
b
.
b™s
) })

136 
v®
 
b—tsD
 = 
	`Vec
((
out
 
z
 
edgesOut
è
m­
 { (
o
, 
e
è=>ƒ.
	`numB—ts1
(o.
d
.
b™s
) })

137 
	`TLArb™”
(
pŞicy
)(
š
.
b
, (
b—tsB
 
z
 
out
.
	`m­
(
_
.b)):_*)

138 
	`TLArb™”
(
pŞicy
)(
š
.
d
, (
b—tsD
 
z
 
out
.
	`m­
(
_
.d)):_*)

141 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAHB.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	gahb
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
, 
	gmax
}

11 
impÜt
 
	gAHBP¬am‘”s
.
_


13 
şass
 
	$TLToAHBNode
(
suµÜtHšts
: 
BoŞ—n
)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$MixedAd­‹rNode
(
TLImp
, 
AHBImp
)(

14 
dFn
 = { 
	`TLCl›ÁPÜtP¬am‘”s
(
ş›Ás
, 
mšL©’cy
) =>

15 
v®
 
ma¡”s
 = 
ş›Ás
.
m­
 { 
c
 => 
	`AHBMa¡”P¬am‘”s
(
Çme
 = c.Çme, 
nodeP©h
 = c.nodePath) }

16 
	`AHBMa¡”PÜtP¬am‘”s
(
ma¡”s
)

17 
	}
},

18 
	guFn
 = { 
AHBSÏvePÜtP¬am‘”s
(
¦aves
, 
b—tBy‹s
) =>

19 
v®
 
mªag”s
 = 
¦aves
.
m­
 { 
s
 =>

20 
TLMªag”P¬am‘”s
(

21 
add»ss
 = 
s
.address,

22 
»sourûs
 = 
s
.resources,

23 
»giÚTy³
 = 
s
.regionType,

24 
execubË
 = 
s
.executable,

25 
nodeP©h
 = 
s
.nodePath,

26 
suµÜtsG‘
 = 
s
.
suµÜtsR—d
,

27 
suµÜtsPutFuÎ
 = 
s
.
suµÜtsWr™e
,

28 
suµÜtsHšt
 = ià(!
suµÜtHšts
è
T¿nsãrSizes
.
nÚe
 

29 ià(
s
.
suµÜtsR—d
) s.supportsRead 

30 ià(
s
.
suµÜtsWr™e
) s.supportsWrite 

31 
T¿nsãrSizes
(1, 
b—tBy‹s
),

32 
fifoId
 = 
Some
(0),

33 
mayD’yPut
 = 
Œue
)

35 
TLMªag”PÜtP¬am‘”s
(
mªag”s
, 
b—tBy‹s
, 0, 1)

38 şas 
	cAHBCÚŒŞBundË
(
·¿ms
: 
TLEdge
è
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

40 
v®
 
fuÎ
 = 
	$BoŞ
()

41 
v®
 
£nd
 = 
	$BoŞ
()

42 
v®
 
fœ¡
 = 
	$BoŞ
()

43 
v®
 
Ï¡
 = 
	$BoŞ
()

44 
v®
 
hšt
 = 
	$BoŞ
()

45 
v®
 
wr™e
 = 
	$BoŞ
()

46 
v®
 
size
 = 
	$UIÁ
(
width
 = 
·¿ms
.
bundË
.
sizeB™s
)

47 
v®
 
sourû
 = 
	$UIÁ
(
width
 = 
·¿ms
.
bundË
.
sourûB™s
)

48 
v®
 
hsize
 = 
	$UIÁ
(
width
 = 
AHBP¬am‘”s
.
sizeB™s
)

49 
v®
 
hbur¡
 = 
	$UIÁ
(
width
 = 
AHBP¬am‘”s
.
bur¡B™s
)

50 
v®
 
addr
 = 
	$UIÁ
(
width
 = 
·¿ms
.
bundË
.
add»ssB™s
)

51 
v®
 
d©a
 = 
	`UIÁ
(
width
 = 
·¿ms
.
bundË
.
d©aB™s
)

56 
şass
 
	$TLToAHB
(
v®
 
aFlow
: 
BoŞ—n
 = 
çl£
, v® 
suµÜtHšts
: BoŞ—Àğ
Œue
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


58 
v®
 
node
 = 
	`TLToAHBNode
(
suµÜtHšts
)

60 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

61 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

62 
v®
 
b—tBy‹s
 = 
edgeOut
.
¦ave
.beatBytes

63 
v®
 
maxT¿nsãr
 = 
edgeOut
.
¦ave
.maxTransfer

64 
v®
 
lgMax
 = 
	`log2Ce
(
maxT¿nsãr
)

65 
v®
 
lgBy‹s
 = 
	`log2Ce
(
b—tBy‹s
)

68 
v®
 
»£tS‹
 = 
	`Wœe
(
Ãw
 
	`AHBCÚŒŞBundË
(
edgeIn
))

69 
»£tS‹
.
fuÎ
 :ğ
	`BoŞ
(
çl£
)

70 
»£tS‹
.
£nd
 :ğ
	`BoŞ
(
çl£
)

71 
»£tS‹
.
fœ¡
 :ğ
	`BoŞ
(
Œue
)

73 
»£tS‹
.
hsize
 :ğ
	`UIÁ
(0)

74 
»£tS‹
.
hbur¡
:ğ
	`UIÁ
(0)

75 
»£tS‹
.
addr
 :ğ
	`UIÁ
(0)

78 
v®
 
»g
 = 
	`RegIn™
(
»£tS‹
)

79 
v®
 
£nd
 = 
	`Wœe
(
š™
 = 
»g
)

80 
v®
 
¡•
 = 
	`Wœe
(
š™
 = 
£nd
)

81 
v®
 
Ãxt
 = 
	`Wœe
(
š™
 = 
¡•
)

82 
»g
 :ğ
Ãxt


85 
v®
 
a_æow
 = 
	`Wœe
(
	`BoŞ
())

88 
	`wh’
 (
£nd
.£nd && !
a_æow
) {

89 
¡•
.
fuÎ
 :ğ
	`BoŞ
(
Œue
)

90 
¡•
.
£nd
 :ğ
	`BoŞ
(
Œue
)

91 } .
	`–£wh’
 (
£nd
.
fuÎ
 && !send.send) {

92 
¡•
.
fuÎ
 :ğ
	`BoŞ
(
Œue
)

93 
¡•
.
£nd
 :ğ
	`BoŞ
(
çl£
)

94 } .
	`–£wh’
 (
£nd
.
fuÎ
 && !£nd.
Ï¡
) {

95 
¡•
.
fuÎ
 :ğ
	`BoŞ
(
Œue
)

96 
¡•
.
£nd
 :ğ
	`BoŞ
(
çl£
)

97 
¡•
.
fœ¡
 :ğ
	`BoŞ
(
çl£
)

98 
¡•
.
Ï¡
 :ğ(ià(
lgBy‹s
 + 1 >ğ
lgMax
è
	`BoŞ
(
Œue
) 

99 !((
	`UIÁToOH1
(
£nd
.
size
, 
lgMax
è& ~£nd.
addr
è>> (
lgBy‹s
 + 1)).
	`ÜR
())

100 
¡•
.
addr
 :ğ
	`C©
(
£nd
.
	`addr
(
edgeIn
.
bundË
.
add»ssB™s
-1, 
lgMax
), s’d.addrÖgMax-1, 0è+ 
	`UIÁ
(
b—tBy‹s
))

101 } .
Ùh”wi£
 {

102 
¡•
.
fuÎ
 :ğ
	`BoŞ
(
çl£
)

103 
¡•
.
£nd
 :ğ
	`BoŞ
(
çl£
)

104 
¡•
.
fœ¡
 :ğ
	`BoŞ
(
Œue
)

107 
v®
 
d_block
 = 
	`Wœe
(
	`BoŞ
())

108 
v®
 
´e
 = ià(
aFlow
è
»g
 
¡•


109 
v®
 
po¡
 = ià(
aFlow
è
£nd
 
Ãxt


112 
v®
 
a_sizeD–
 = 
	`C©
(
	`UIÁ
(0, 
width
 = 1), 
š
.
a
.
b™s
.
size
è- UIÁ(
lgBy‹s
+1)

113 
v®
 
a_hšt
 = 
š
.
a
.
b™s
.
İcode
 ==ğ
TLMes§ges
.
Hšt
 && 
	`BoŞ
(
suµÜtHšts
)

114 
v®
 
a_sšgËB—t
 = 
a_hšt
 || 
	`BoŞ
(
lgBy‹s
 >ğ
lgMax
è|| 
	`a_sizeD–
(
edgeIn
.
bundË
.
sizeB™s
)

115 
v®
 
a_logB—ts1
 = 
	`a_sizeD–
(
edgeIn
.
bundË
.
sizeB™s
-1, 0)

118 
v®
 
a_comm™
 = 
	`Wœe
(
	`BoŞ
())

121 
	`wh’
 (
´e
.
£nd
) {

122 
a_comm™
 :ğ
	`BoŞ
(
çl£
)

123 
š
.
a
.
»ady
 :ğ
	`BoŞ
(
çl£
)

124 } .
	`–£wh’
 (
´e
.
fuÎ
) {

125 
po¡
.
£nd
 :ğ!
d_block
 && (!
´e
.
wr™e
 || 
š
.
a
.
v®id
)

126 
po¡
.
d©a
 :ğ
š
.
a
.
b™s
.data

127 
a_comm™
 :ğ!
d_block
 && !
´e
.
wr™e


128 
š
.
a
.
»ady
 :ğ!
d_block
 && 
´e
.
wr™e


129 } .
Ùh”wi£
 {

130 
a_comm™
 :ğ
š
.
a
.
	`fœe
()

131 
š
.
a
.
»ady
 :ğ!
d_block


132 
	`wh’
 (
š
.
a
.
	`fœe
()) {

133 
po¡
.
fuÎ
 :ğ
	`BoŞ
(
Œue
)

134 
po¡
.
£nd
 :ğ
	`BoŞ
(
Œue
)

135 
po¡
.
Ï¡
 :ğ
a_sšgËB—t


136 
po¡
.
hšt
 :ğ
a_hšt


137 
po¡
.
size
 :ğ
š
.
a
.
b™s
.size

138 
po¡
.
sourû
:ğ
š
.
a
.
b™s
.source

140 
	`wh’
 (
š
.
a
.
	`fœe
(è&& !
a_hšt
) {

141 
po¡
.
wr™e
 :ğ
edgeIn
.
	`hasD©a
(
š
.
a
.
b™s
)

142 
po¡
.
hsize
 :ğ
	`Mux
(
a_sšgËB—t
, 
š
.
a
.
b™s
.
size
, 
	`UIÁ
(
lgBy‹s
))

143 
po¡
.
hbur¡
:ğ
	`Mux
(
a_sšgËB—t
, 
BURST_SINGLE
, (
a_logB—ts1
<<1è| 
	`UIÁ
(1))

144 
po¡
.
addr
 :ğ
š
.
a
.
b™s
.
add»ss


145 
po¡
.
d©a
 :ğ
š
.
a
.
b™s
.data

149 
out
.
hma¡lock
 :ğ
	`BoŞ
(
çl£
)

150 
out
.
hŒªs
 :ğ
	`Mux
(
£nd
.£nd && !£nd.
hšt
,

151 
	`Mux
(
£nd
.
fœ¡
, 
TRANS_NONSEQ
, 
TRANS_SEQ
),

152 
	`Mux
(
£nd
.
fœ¡
, 
TRANS_IDLE
, 
TRANS_BUSY
))

153 
out
.
h£l
 :ğ(
£nd
.£nd && !£nd.
hšt
è|| !£nd.
fœ¡


154 
out
.
h»ady
 :ğout.
h»adyout


155 
out
.
hwr™e
 :ğ
£nd
.
wr™e


156 
out
.
haddr
 :ğ
£nd
.
addr


157 
out
.
hsize
 :ğ
£nd
.hsize

158 
out
.
hbur¡
 :ğ
£nd
.hburst

159 
out
.
h´Ù
 :ğ
PROT_DEFAULT


160 
out
.
hwd©a
 :ğ
	`RegEÇbË
(
£nd
.
d©a
, out.
h»adyout
)

168 
v®
 
d•th
 = ià(
aFlow
) 2 3

169 
v®
 
d
 = 
	`Wœe
(
š
.d)

170 
š
.
d
 <> 
	`Queue
(d, 
d•th
, 
æow
=
Œue
)

171 
	`as£¹
 (!
d
.
v®id
 || d.
»ady
)

173 
v®
 
d_æight
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 2))

174 
	`as£¹
 (
d_æight
 <ğ
	`UIÁ
(
d•th
))

175 
d_æight
 :ğd_æighˆ+ 
a_comm™
.
asUIÁ
 - 
š
.
d
.
	`fœe
().asUInt

176 
d_block
 :ğ
d_æight
 >ğ
	`UIÁ
(
d•th
)

178 
v®
 
d_v®id
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

179 
v®
 
d_d’›d
 = 
	`Reg
(
	`BoŞ
())

180 
v®
 
d_hšt
 = 
	`RegEÇbË
(
£nd
.
hšt
, 
a_æow
 && send.send)

181 
v®
 
d_wr™e
 = 
	`RegEÇbË
(
£nd
.
wr™e
, 
a_æow
 && send.send)

182 
v®
 
d_sourû
 = 
	`RegEÇbË
(
£nd
.
sourû
, 
a_æow
 && send.send)

183 
v®
 
d_size
 = 
	`RegEÇbË
(
£nd
.
size
, 
a_æow
 && send.send)

185 
	`wh’
 (
out
.
h»adyout
) {

186 
d_v®id
 :ğ
£nd
.£nd && (£nd.
Ï¡
 || !£nd.
wr™e
)

187 
	`wh’
 (
out
.
h»¥
è{ 
d_d’›d
 :ğ
	`BoŞ
(
Œue
) }

188 
	`wh’
 (
£nd
.
fœ¡
è{ 
d_d’›d
 :ğ
	`BoŞ
(
çl£
) }

189 } .
	`–£wh’
 (
d_hšt
) {

190 
d_v®id
 :ğ
	`BoŞ
(
çl£
)

193 
d
.
v®id
 :ğ
d_v®id
 && (
out
.
h»adyout
 || 
d_hšt
)

194 
d
.
b™s
 :ğ
edgeIn
.
	`AcûssAck
(
d_sourû
, 
d_size
, 
out
.
hrd©a
)

195 
d
.
b™s
.
İcode
 :ğ
	`Mux
(
d_hšt
, 
TLMes§ges
.
HštAck
, Mux(
d_wr™e
, TLMes§ges.
AcûssAck
, TLMes§ges.
AcûssAckD©a
))

196 
d
.
b™s
.
d’›d
 :ğ(
out
.
h»¥
 || 
d_d’›d
è&& 
d_wr™e
 && !
d_hšt


197 
d
.
b™s
.
cÜru±
 :ğ
out
.
h»¥
 && !
d_wr™e
 && !
d_hšt


200 
v®
 
sk
 = 
	`BoŞ
(
suµÜtHšts
è&& 
£nd
.
hšt
 && (!
d_v®id
 || 
d_hšt
)

201 
a_æow
 :ğ
out
.
h»adyout
 || 
sk


204 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

205 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

206 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

209 
	}
}

211 
objeù
 
TLToAHB


213 
def
 
­¶y
(
aFlow
: 
BoŞ—n
 = 
Œue
, 
suµÜtHšts
: BoŞ—ÀğŒue)(
im¶ic™
 
p
: 
P¬am‘”s
) =

215 
v®
 
2ahb
 = 
LazyModuË
(
Ãw
 
TLToAHB
(
aFlow
, 
suµÜtHšts
))

216 
	g2ahb
.
	gnode


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAPB.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	g­b
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
, 
	gmax
}

10 
impÜt
 
	gAPBP¬am‘”s
.
_


12 
şass
 
	$TLToAPBNode
()(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$MixedAd­‹rNode
(
TLImp
, 
APBImp
)(

13 
dFn
 = { 
	`TLCl›ÁPÜtP¬am‘”s
(
ş›Ás
, 
mšL©’cy
) =>

14 
v®
 
ma¡”s
 = 
ş›Ás
.
m­
 { 
c
 => 
	`APBMa¡”P¬am‘”s
(
Çme
 = c.Çme, 
nodeP©h
 = c.nodePath) }

15 
	`APBMa¡”PÜtP¬am‘”s
(
ma¡”s
)

16 
	}
},

17 
	guFn
 = { 
APBSÏvePÜtP¬am‘”s
(
¦aves
, 
b—tBy‹s
) =>

18 
v®
 
mªag”s
 = 
¦aves
.
m­
 { 
s
 =>

19 
TLMªag”P¬am‘”s
(

20 
add»ss
 = 
s
.address,

21 
»sourûs
 = 
s
.resources,

22 
»giÚTy³
 = 
s
.regionType,

23 
execubË
 = 
s
.executable,

24 
nodeP©h
 = 
s
.nodePath,

25 
suµÜtsG‘
 = ià(
s
.
suµÜtsR—d
è
T¿nsãrSizes
(1, 
b—tBy‹s
èT¿nsãrSizes.
nÚe
,

26 
suµÜtsPutP¬tŸl
 = ià(
s
.
suµÜtsWr™e
è
T¿nsãrSizes
(1, 
b—tBy‹s
èT¿nsãrSizes.
nÚe
,

27 
suµÜtsPutFuÎ
 = ià(
s
.
suµÜtsWr™e
è
T¿nsãrSizes
(1, 
b—tBy‹s
èT¿nsãrSizes.
nÚe
,

28 
fifoId
 = 
Some
(0),

29 
mayD’yPut
 = 
Œue
)

31 
TLMªag”PÜtP¬am‘”s
(
mªag”s
, 
b—tBy‹s
, 0, 1)

36 
şass
 
	$TLToAPB
(
v®
 
aFlow
: 
BoŞ—n
 = 
Œue
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


38 
v®
 
node
 = 
	`TLToAPBNode
()

40 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

41 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

42 
v®
 
b—tBy‹s
 = 
edgeOut
.
¦ave
.beatBytes

43 
v®
 
lgBy‹s
 = 
	`log2Ce
(
b—tBy‹s
)

46 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

47 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

48 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

56 
v®
 
d
 = 
	`Wœe
(
š
.d)

57 
š
.
d
 <> 
	`Queue
(d, 1, 
æow
 = 
Œue
)

60 
v®
 
a
 = 
	`Queue
(
š
.a, 1, 
æow
 = 
aFlow
, 
pe
 = !aFlow)

62 
v®
 
a_’abË
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

63 
v®
 
a_£l
 = 
a
.
v®id
 && 
	`RegNext
(!
š
.
d
.v®id || in.d.
»ady
)

64 
v®
 
a_wr™e
 = 
edgeIn
.
	`hasD©a
(
a
.
b™s
)

66 
v®
 
’abË_d
 = 
a_£l
 && !
a_’abË


67 
v®
 
d_wr™e
 = 
	`RegEÇbË
(
a_wr™e
, 
’abË_d
)

68 
v®
 
d_sourû
 = 
	`RegEÇbË
(
a
.
b™s
.
sourû
, 
’abË_d
)

69 
v®
 
d_size
 = 
	`RegEÇbË
(
a
.
b™s
.
size
, 
’abË_d
)

71 
	`wh’
 (
a_£l
è{ 
a_’abË
 :ğ
	`BoŞ
(
Œue
) }

72 
	`wh’
 (
d
.
	`fœe
()è{ 
a_’abË
 :ğ
	`BoŞ
(
çl£
) }

74 
out
.
p£l
 :ğ
a_£l


75 
out
.
³ÇbË
 :ğ
a_’abË


76 
out
.
pwr™e
 :ğ
a_wr™e


77 
out
.
·ddr
 :ğ
a
.
b™s
.
add»ss


78 
out
.
µrÙ
 :ğ
PROT_DEFAULT


79 
out
.
pwd©a
 :ğ
a
.
b™s
.
d©a


80 
out
.
p¡rb
 :ğ
	`Mux
(
a_wr™e
, 
a
.
b™s
.
mask
, 
	`UIÁ
(0))

82 
a
.
»ady
 :ğ
a_’abË
 && 
out
.
´—dy


83 
d
.
v®id
 :ğ
a_’abË
 && 
out
.
´—dy


84 
	`as£¹
 (!
d
.
v®id
 || d.
»ady
)

86 
d
.
b™s
.
İcode
 :ğ
	`Mux
(
d_wr™e
, 
TLMes§ges
.
AcûssAck
, TLMes§ges.
AcûssAckD©a
)

87 
d
.
b™s
.
·¿m
 :ğ
	`UIÁ
(0)

88 
d
.
b™s
.
size
 :ğ
d_size


89 
d
.
b™s
.
sourû
 :ğ
d_sourû


90 
d
.
b™s
.
sšk
 :ğ
	`UIÁ
(0)

91 
d
.
b™s
.
d’›d
 :ğ
d_wr™e
 && 
out
.
p¦v”r


92 
d
.
b™s
.
d©a
 :ğ
out
.
´d©a


93 
d
.
b™s
.
cÜru±
 :ğ!
d_wr™e
 && 
out
.
p¦v”r


96 
	}
}

98 
objeù
 
TLToAPB


100 
def
 
­¶y
(
aFlow
: 
BoŞ—n
 = 
Œue
)(
im¶ic™
 
p
: 
P¬am‘”s
) =

102 
v®
 
2­b
 = 
LazyModuË
(
Ãw
 
TLToAPB
(
aFlow
))

103 
2­b
.
node


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAXI4.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	gaxi4
.
_


10 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
, 
	gmax
}

12 
şass
 
	$TLtoAXI4IdM­
(

: 
TLCl›ÁPÜtP¬am‘”s
, 
axi4
: 
AXI4Ma¡”PÜtP¬am‘”s
) {

13 
´iv©e
 
v®
 
axiDig™s
 = 
SŒšg
.
	`v®ueOf
(
axi4
.
’dId
-1).
	`Ëngth
()

14 
´iv©e
 
v®
 
Dig™s
 = 
SŒšg
.
	`v®ueOf
(

.
’dSourûId
-1).
	`Ëngth
()

15 
´iv©e
 
v®
 
fmt
 = 
s
"\t[%${axiDigits}d, %${axiDigits}d) <= [%${tlDigits}d, %${tlDigits}d) %s%s%s"

16 
´iv©e
 
v®
 
sÜ‹d
 = 

.
ş›Ás
.
	`sÜtW™h
(
TLToAXI4
.
sÜtByTy³
)

18 
v®
 
m­pšg
: 
Seq
[
TLToAXI4IdM­EÁry
] = (
sÜ‹d
 
z
 
axi4
.
ma¡”s
è
m­
 { (
c
, 
m
) =>

19 
	`TLToAXI4IdM­EÁry
(
m
.
id
, 
c
.
sourûId
, c.
Çme
, c.
suµÜtsProbe
, c.
»que¡Fifo
)

22 
def
 
´‘ty
: 
SŒšg
 = 
m­pšg
.
	`m­
(
_
.
	`´‘ty
(
fmt
)).
	`mkSŒšg
(",\n")

23 
	}
}

25 
şass
 
	$TLToAXI4IdM­EÁry
(
axi4Id
: 
IdRªge
, 
Id
: IdRªge, 
Çme
: 
SŒšg
, 
isCache
: 
BoŞ—n
, 
»que¡Fifo
: Boolean) {

26 
def
 
	`´‘ty
(
fmt
: 
SŒšg
èğfmt.
	`fÜm©
(

27 
axi4Id
.
¡¬t
,

28 
axi4Id
.
’d
,

29 
Id
.
¡¬t
,

30 
Id
.
’d
,

31 
s
""""
$Çme
"""",

32 ià(
isCache
) " [CACHE]" "",

33 ià(
»que¡Fifo
) " [FIFO]" "")

34 
	}
}

36 
şass
 
	$TLToAXI4Node
(
¡rB™s
: 
IÁ
 = 0)(
im¶ic™
 
v®Name
: 
V®Name
è
ex‹nds
 
	$MixedAd­‹rNode
(
TLImp
, 
AXI4Imp
)(

37 
dFn
 = { 
p
 =>

38 
p
.
ş›Ás
.
fÜ—ch
 { 
c
 =>

39 
	`»quœe
 (
c
.
sourûId
.
¡¬t
 % (1 << 
¡rB™s
) == 0 &&

40 
c
.
sourûId
.
’d
 % (1 << 
¡rB™s
) == 0,

41 
s
"Cannot strip bits of‡ligned client ${c.name}: ${c.sourceId}")

43 
v®
 
ş›Ás
 = 
p
.ş›Ás.
	`sÜtW™h
(
TLToAXI4
.
sÜtByTy³
 
_
)

44 
v®
 
idSize
 = 
ş›Ás
.
m­
 { 
c
 => ià(c.
»que¡Fifo
è1 (c.
sourûId
.
size
 >> 
¡rB™s
) }

45 
v®
 
idS¹
 = 
idSize
.
	`sÿnLeá
(0)(
_
+_).
š™


46 
v®
 
ma¡”s
 = ((
idS¹
 
z
 
idSize
èz 
ş›Ás
è
m­
 { ((
¡¬t
, 
size
), 
c
) =>

47 
	`AXI4Ma¡”P¬am‘”s
(

48 
Çme
 = 
c
.name,

49 
id
 = 
	`IdRªge
(
¡¬t
, s¹+
size
),

50 
®igÃd
 = 
Œue
,

51 
maxFlight
 = 
	`Some
(ià(
c
.
»que¡Fifo
èc.
sourûId
.
size
 (1 << 
¡rB™s
)),

52 
nodeP©h
 = 
c
.nodePath)

54 
	`AXI4Ma¡”PÜtP¬am‘”s
(

55 
ma¡”s
 = masters,

56 
u£rB™s
 = 
	`log2Ce
(
p
.
’dSourûId
) + 4)

57 
	}
},

58 
	guFn
 = { 
p
 => 
TLMªag”PÜtP¬am‘”s
(

59 
mªag”s
 = 
p
.
¦aves
.
m­
 { 
s
 =>

60 
TLMªag”P¬am‘”s
(

61 
add»ss
 = 
s
.address,

62 
»sourûs
 = 
s
.resources,

63 
»giÚTy³
 = 
s
.regionType,

64 
execubË
 = 
s
.executable,

65 
nodeP©h
 = 
s
.nodePath,

66 
suµÜtsG‘
 = 
s
.
suµÜtsR—d
,

67 
suµÜtsPutFuÎ
 = 
s
.
suµÜtsWr™e
,

68 
suµÜtsPutP¬tŸl
 = 
s
.
suµÜtsWr™e
,

69 
fifoId
 = 
Some
(0),

70 
mayD’yPut
 = 
Œue
,

71 
mayD’yG‘
 = 
Œue
)},

72 
b—tBy‹s
 = 
p
.beatBytes,

73 
mšL©’cy
 = 
p
.minLatency)

76 
şass
 
	$TLToAXI4
(
v®
 
combš©iÚ®
: 
BoŞ—n
 = 
Œue
, v® 
ad­‹rName
: 
O±iÚ
[
SŒšg
] = 
NÚe
, v® 
¡rB™s
: 
IÁ
 = 0)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


78 
v®
 
node
 = 
	`TLToAXI4Node
(
¡rB™s
)

80 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

81 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

82 
v®
 
¦aves
 = 
edgeOut
.
¦ave
.slaves

85 
	`»quœe
 (
	`¦aves
(0).
š‹¾—vedId
.
isDefšed
)

86 
¦aves
.
fÜ—ch
 { 
s
 => 
	`»quœe
 (s.
š‹¾—vedId
 =ğ
	`¦aves
(0).interleavedId) }

89 
v®
 
m­
 = 
Ãw
 
	`TLtoAXI4IdM­
(
edgeIn
.
ş›Á
, 
edgeOut
.
ma¡”
)

90 
v®
 
sourûSÎ
 = 
	`Wœe
(
	`Vec
(
edgeIn
.
ş›Á
.
’dSourûId
, 
	`BoŞ
()))

91 
v®
 
sourûTabË
 = 
	`Wœe
(
	`Vec
(
edgeIn
.
ş›Á
.
’dSourûId
, 
out
.
aw
.
b™s
.
id
))

92 
v®
 
idSÎ
 = 
	`Wœe
(
š™
 = 
Vec
.
	`fl
(
edgeOut
.
ma¡”
.
’dId
è{ 
	`BoŞ
(
çl£
) })

93 
v¬
 
idCouÁ
 = 
A¼ay
.
	`fl
(
edgeOut
.
ma¡”
.
’dId
è{ 
NÚe
:
O±iÚ
[
IÁ
] }

95 
AÂÙ©ed
.
	`idM­pšg
(
this
, 
m­
.
m­pšg
).
fÜ—ch
 { 
	`TLToAXI4IdM­EÁry
(
axi4Id
, 
Id
, 
_
, _, 
fifo
) =>

96 
i
 <- 0 
uÁ
 
Id
.
size
) {

97 
v®
 
id
 = 
axi4Id
.
¡¬t
 + (ià(
fifo
è0 (
i
 >> 
¡rB™s
))

98 
	`sourûSÎ
(
Id
.
¡¬t
 + 
i
è:ğ
	`idSÎ
(
id
)

99 
	`sourûTabË
(
Id
.
¡¬t
 + 
i
è:ğ
	`UIÁ
(
id
)

101 ià(
fifo
è{ 
	`idCouÁ
(
axi4Id
.
¡¬t
èğ
	`Some
(
Id
.
size
) }

104 
ad­‹rName
.
fÜ—ch
 { 
n
 =>

105 
	`´šn
(
s
"$n AXI4-ID <= TL-Source mapping:\n${map.pretty}\n")

106 
EÏbÜ©iÚA¹eçùs
.
	`add
(
s
"$n.axi4.jsÚ", s"""{"
m­pšg
":[${map.mapping.mkString(",")}]}""")

113 
v®
 
sourûB™s
 = 
	`log2Ce
(
edgeIn
.
ş›Á
.
’dSourûId
)

114 
v®
 
sizeB™s
 = 
	`log2Ce
(
edgeIn
.
maxLgSize
+1)

115 
v®
 
¡©eB™s
 = 
sizeB™s
 + 
sourûB™s


116 
	`»quœe
 (
¡©eB™s
 <ğ
out
.
aw
.
b™s
.
·¿ms
.
u£rB™s
)

118 
v®
 
a_add»ss
 = 
edgeIn
.
	`add»ss
(
š
.
a
.
b™s
)

119 
v®
 
a_sourû
 = 
š
.
a
.
b™s
.
sourû


120 
v®
 
a_size
 = 
edgeIn
.
	`size
(
š
.
a
.
b™s
)

121 
v®
 
a_isPut
 = 
edgeIn
.
	`hasD©a
(
š
.
a
.
b™s
)

122 
	`v®
 (
a_fœ¡
, 
a_Ï¡
, 
_
èğ
edgeIn
.
	`fœ¡Ï¡
(
š
.
a
)

125 
	`as£¹
 (
a_sourû
 < 
	`UIÁ
(
	`BigIÁ
(1è<< 
sourûB™s
))

126 
	`as£¹
 (
a_size
 < 
	`UIÁ
(
	`BigIÁ
(1è<< 
sizeB™s
))

129 
v®
 
ba£End
 = 0

130 
	`v®
 (
sourûEnd
, 
sourûOff
èğ(
sourûB™s
 + 
ba£End
, baseEnd)

131 
	`v®
 (
sizeEnd
, 
sizeOff
èğ(
sizeB™s
 + 
sourûEnd
, sourceEnd)

132 
	`»quœe
 (
sizeEnd
 =ğ
¡©eB™s
)

134 
v®
 
a_¡©e
 = (
a_sourû
 << 
sourûOff
è| (
a_size
 << 
sizeOff
)

136 
v®
 
r_¡©e
 = 
out
.
r
.
b™s
.
u£r
.
	`g‘OrEl£
(
	`UIÁ
(0))

137 
v®
 
r_sourû
 = ià(
sourûB™s
 > 0è
	`r_¡©e
(
sourûEnd
-1, 
sourûOff
è
	`UIÁ
(0)

138 
v®
 
r_size
 = ià(
sizeB™s
 > 0è
	`r_¡©e
(
sizeEnd
 -1, 
sizeOff
è
	`UIÁ
(0)

140 
v®
 
b_¡©e
 = 
out
.
b
.
b™s
.
u£r
.
	`g‘OrEl£
(
	`UIÁ
(0))

141 
v®
 
b_sourû
 = ià(
sourûB™s
 > 0è
	`b_¡©e
(
sourûEnd
-1, 
sourûOff
è
	`UIÁ
(0)

142 
v®
 
b_size
 = ià(
sizeB™s
 > 0è
	`b_¡©e
(
sizeEnd
 -1, 
sizeOff
è
	`UIÁ
(0)

145 
v®
 
d•th
 = ià(
combš©iÚ®
) 1 2

146 
v®
 
out_¬w
 = 
	`Wœe
(
	`Decou¶ed
(
Ãw
 
	`AXI4BundËARW
(
out
.
·¿ms
)))

147 
v®
 
out_w
 = 
	`Wœe
(
out
.
w
)

148 
out
.
w
 <> 
Queue
.
	`œ»voÿbË
(
out_w
, 
’Œ›s
=
d•th
, 
æow
=
combš©iÚ®
)

149 
v®
 
queue_¬w
 = 
Queue
.
	`œ»voÿbË
(
out_¬w
, 
’Œ›s
=
d•th
, 
æow
=
combš©iÚ®
)

152 
out
.
¬
.
b™s
 :ğ
queue_¬w
.bits

153 
out
.
aw
.
b™s
 :ğ
queue_¬w
.bits

154 
out
.
¬
.
v®id
 :ğ
queue_¬w
.v®id && !queue_¬w.
b™s
.
w’


155 
out
.
aw
.
v®id
 :ğ
queue_¬w
.v®id && queue_¬w.
b™s
.
w’


156 
queue_¬w
.
»ady
 :ğ
	`Mux
(queue_¬w.
b™s
.
w’
, 
out
.
aw
.»ady, out.
¬
.ready)

158 
v®
 
b—tBy‹s
 = 
edgeIn
.
mªag”
.beatBytes

159 
v®
 
maxSize
 = 
	`UIÁ
(
	`log2Ce
(
b—tBy‹s
))

160 
v®
 
dÚeAW
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

161 
	`wh’
 (
š
.
a
.
	`fœe
()è{ 
dÚeAW
 :ğ!
a_Ï¡
 }

163 
v®
 
¬w
 = 
out_¬w
.
b™s


164 
¬w
.
w’
 :ğ
a_isPut


165 
¬w
.
id
 :ğ
	`sourûTabË
(
a_sourû
)

166 
¬w
.
addr
 :ğ
a_add»ss


167 
¬w
.
Ën
 :ğ
	`UIÁToOH1
(
a_size
, 
AXI4P¬am‘”s
.
ËnB™s
 + 
	`log2Ce
(
b—tBy‹s
)) >>†og2Ceil(beatBytes)

168 
¬w
.
size
 :ğ
	`Mux
(
a_size
 >ğ
maxSize
, maxSize,‡_size)

169 
¬w
.
bur¡
 :ğ
AXI4P¬am‘”s
.
BURST_INCR


170 
¬w
.
lock
 :ğ
	`UIÁ
(0)

171 
¬w
.
ÿche
 :ğ
	`UIÁ
(0)

172 
¬w
.
´Ù
 :ğ
AXI4P¬am‘”s
.
PROT_PRIVILEDGED


173 
¬w
.
qos
 :ğ
	`UIÁ
(0)

174 
¬w
.
u£r
.
fÜ—ch
 { 
_
 :ğ
a_¡©e
 }

176 
v®
 
¡®l
 = 
	`sourûSÎ
(
š
.
a
.
b™s
.
sourû
è&& 
a_fœ¡


177 
š
.
a
.
»ady
 :ğ!
¡®l
 && 
	`Mux
(
a_isPut
, (
dÚeAW
 || 
out_¬w
.»adyè&& 
out_w
.ready, out_arw.ready)

178 
out_¬w
.
v®id
 :ğ!
¡®l
 && 
š
.
a
.v®id && 
	`Mux
(
a_isPut
, !
dÚeAW
 && 
out_w
.
»ady
, 
	`BoŞ
(
Œue
))

180 
out_w
.
v®id
 :ğ!
¡®l
 && 
š
.
a
.v®id && 
a_isPut
 && (
dÚeAW
 || 
out_¬w
.
»ady
)

181 
out_w
.
b™s
.
d©a
 :ğ
š
.
a
.bits.data

182 
out_w
.
b™s
.
¡rb
 :ğ
š
.
a
.b™s.
mask


183 
out_w
.
b™s
.
Ï¡
 :ğ
a_Ï¡


184 
out_w
.
b™s
.
cÜru±
.
fÜ—ch
 { 
_
 :ğ
š
.
a
.bits.corrupt }

187 
v®
 
r_hŞds_d
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

188 
	`wh’
 (
out
.
r
.
	`fœe
()è{ 
r_hŞds_d
 :ğ!out.r.
b™s
.
Ï¡
 }

190 
v®
 
r_wšs
 = 
out
.
r
.
v®id
 || 
r_hŞds_d


192 
out
.
r
.
»ady
 :ğ
š
.
d
.ready

193 
out
.
b
.
»ady
 :ğ
š
.
d
.»ady && !
r_wšs


194 
š
.
d
.
v®id
 :ğ
	`Mux
(
r_wšs
, 
out
.
r
.v®id, out.
b
.valid)

199 
v®
 
r_fœ¡
 = 
	`RegIn™
(
	`BoŞ
(
Œue
))

200 
	`wh’
 (
out
.
r
.
	`fœe
()è{ 
r_fœ¡
 :ğout.r.
b™s
.
Ï¡
 }

201 
v®
 
r_d’›d
 = 
out
.
r
.
b™s
.
»¥
 ==ğ
AXI4P¬am‘”s
.
RESP_DECERR
 
hŞdUÆess
 
r_fœ¡


202 
v®
 
r_cÜru±
 = 
out
.
r
.
b™s
.
»¥
 =/ğ
AXI4P¬am‘”s
.
RESP_OKAY


203 
v®
 
b_d’›d
 = 
out
.
b
.
b™s
.
»¥
 =/ğ
AXI4P¬am‘”s
.
RESP_OKAY


205 
v®
 
r_d
 = 
edgeIn
.
	`AcûssAck
(
r_sourû
, 
r_size
, 
	`UIÁ
(0), 
d’›d
 = 
r_d’›d
, 
cÜru±
 = 
r_cÜru±
 ||„_denied)

206 
v®
 
b_d
 = 
edgeIn
.
	`AcûssAck
(
b_sourû
, 
b_size
, 
d’›d
 = 
b_d’›d
)

208 
š
.
d
.
b™s
 :ğ
	`Mux
(
r_wšs
, 
r_d
, 
b_d
)

209 
š
.
d
.
b™s
.
d©a
 :ğ
out
.
r
.bits.data

213 
v®
 
a_£l
 = 
	`UIÁToOH
(
¬w
.
id
, 
edgeOut
.
ma¡”
.
’dId
).
toBoŞs


214 
v®
 
d_£l
 = 
	`UIÁToOH
(
	`Mux
(
r_wšs
, 
out
.
r
.
b™s
.
id
, out.
b
.b™s.id), 
edgeOut
.
ma¡”
.
’dId
).
toBoŞs


215 
v®
 
d_Ï¡
 = 
	`Mux
(
r_wšs
, 
out
.
r
.
b™s
.
Ï¡
, 
	`BoŞ
(
Œue
))

217 (
a_£l
 
z
 
d_£l
 z 
idSÎ
 z 
idCouÁ
è
fÜ—ch
 { (((
as
, 
ds
), 
s
), 
n
) =>

224 
v®
 
maxCouÁ
 = 
n
.
	`g‘OrEl£
(1)

225 
v®
 
couÁ
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
	`log2Ce
(
maxCouÁ
 + 1)))

226 
v®
 
wr™e
 = 
	`Reg
(
	`BoŞ
())

227 
v®
 
idË
 = 
couÁ
 ==ğ
	`UIÁ
(0)

229 
v®
 
šc
 = 
as
 && 
out_¬w
.
	`fœe
()

230 
v®
 
dec
 = 
ds
 && 
d_Ï¡
 && 
š
.
d
.
	`fœe
()

231 
couÁ
 :ğcouÁ + 
šc
.
asUIÁ
 - 
dec
.asUInt

233 
	`as£¹
 (!
dec
 || 
couÁ
 =/ğ
	`UIÁ
(0))

234 
	`as£¹
 (!
šc
 || 
couÁ
 =/ğ
	`UIÁ
(
maxCouÁ
))

236 
	`wh’
 (
šc
è{ 
wr™e
 :ğ
¬w
.
w’
 }

238 
v®
 
mism©ch
 = ià(
maxCouÁ
 > 1è{ 
wr™e
 =/ğ
¬w
.
w’
 } { 
	`BoŞ
(
çl£
) }

239 
s
 :ğ(!
idË
 && 
mism©ch
è|| (
couÁ
 ==ğ
	`UIÁ
(
maxCouÁ
))

243 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

244 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

245 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

248 
	}
}

250 
objeù
 
TLToAXI4


252 
def
 
­¶y
(
combš©iÚ®
: 
BoŞ—n
 = 
Œue
, 
ad­‹rName
: 
O±iÚ
[
SŒšg
] = 
NÚe
, 
¡rB™s
: 
IÁ
 = 0)(
im¶ic™
 
p
: 
P¬am‘”s
) =

254 
v®
 
2axi4
 = 
LazyModuË
(
Ãw
 
TLToAXI4
(
combš©iÚ®
, 
ad­‹rName
, 
¡rB™s
))

255 
	g2axi4
.
	gnode


258 
def
 
sÜtByTy³
(
a
: 
TLCl›ÁP¬am‘”s
, 
b
: TLCl›ÁP¬am‘”s): 
BoŞ—n
 = {

259 iàĞ
a
.
suµÜtsProbe
 && !
b
.suµÜtsProbeè 
çl£


260 ià(!
a
.
suµÜtsProbe
 && 
b
.suµÜtsProbeè 
Œue


261 iàĞ
a
.
»que¡Fifo
 && !
b
.»que¡FifØè 
çl£


262 ià(!
a
.
»que¡Fifo
 && 
b
.»que¡FifØè 
Œue


263  
çl£


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/WidthWidget.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


9 
impÜt
 
	gsÿÏ
.
	gm©h
.{
	gmš
,
	gmax
}

12 şas 
	cTLWidthWidg‘
(
šÃrB—tBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


14 
v®
 
node
 = 
	`TLAd­‹rNode
(

15 
ş›ÁFn
 = { 
c
 => c },

16 
mªag”Fn
 = { 
m
 => m.
	`cİy
(
b—tBy‹s
 = 
šÃrB—tBy‹s
è
	}
})

18 
Ïzy
 
v®
 
	gmoduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

19 
def
 
m”ge
[
T
 <: 
TLD©aChªÃl
](
edgeIn
: 
TLEdge
, 
š
: 
Decou¶edIO
[T], 
edgeOut
: TLEdge, 
out
: DecoupledIO[T]) = {

20 
v®
 
šBy‹s
 = 
edgeIn
.
mªag”
.
b—tBy‹s


21 
v®
 
outBy‹s
 = 
edgeOut
.
mªag”
.
b—tBy‹s


22 
v®
 
¿tio
 = 
outBy‹s
 / 
šBy‹s


23 
v®
 
k“pB™s
 = 
	`log2Ce
(
outBy‹s
)

24 
v®
 
drİB™s
 = 
	`log2Ce
(
šBy‹s
)

25 
v®
 
couÁB™s
 = 
	`log2Ce
(
¿tio
)

27 
v®
 
size
 = 
edgeIn
.
	`size
(
š
.
b™s
)

28 
v®
 
hasD©a
 = 
edgeIn
.
	`hasD©a
(
š
.
b™s
)

29 
v®
 
lim™
 = 
	`UIÁToOH1
(
size
, 
k“pB™s
è>> 
drİB™s


31 
v®
 
couÁ
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
couÁB™s
))

32 
v®
 
fœ¡
 = 
couÁ
 ==ğ
	`UIÁ
(0)

33 
v®
 
Ï¡
 = 
couÁ
 ==ğ
lim™
 || !
hasD©a


34 
v®
 
’abË
 = 
Seq
.
	`buÏ‹
(
¿tio
è{ 
i
 => !((
couÁ
 ^ 
	`UIÁ
(i)è& 
lim™
).
ÜR
 }

36 
v®
 
cÜru±_»g
 = 
	`RegIn™
(
	`BoŞ
(
çl£
))

37 
v®
 
cÜru±_š
 = 
edgeIn
.
	`cÜru±
(
š
.
b™s
)

38 
v®
 
cÜru±_out
 = 
cÜru±_š
 || 
cÜru±_»g


40 
	`wh’
 (
š
.
	`fœe
()) {

41 
couÁ
 :ğcouÁ + 
	`UIÁ
(1)

42 
cÜru±_»g
 :ğ
cÜru±_out


43 
	`wh’
 (
Ï¡
) {

44 
couÁ
 :ğ
	`UIÁ
(0)

45 
cÜru±_»g
 :ğ
	`BoŞ
(
çl£
)

49 
def
 
	`h–³r
(
id©a
: 
UIÁ
): UInt = {

50 
v®
 
od©a
 = 
Seq
.
	`fl
(
¿tio
è{ 
id©a
 }

51 
v®
 
rd©a
 = 
	`Reg
(
	`Vec
(
¿tio
-1, 
id©a
))

52 
v®
 
pd©a
 = 
rd©a
 :+ 
id©a


53 
v®
 
md©a
 = (
’abË
 
	`z
 (
od©a
 
z
 
pd©a
)è
m­
 { (
e
, (
o
, 
p
)è=> 
	`Mux
(e, o,…) }

54 
	`wh’
 (
š
.
	`fœe
(è&& !
Ï¡
) {

55 (
rd©a
 
z
 
md©a
è
fÜ—ch
 { (
r
, 
m
) =>„ := m }

57 
	`C©
(
md©a
.
»v”£
)

60 
š
.
»ady
 :ğ
out
.»ady || !
Ï¡


61 
out
.
v®id
 :ğ
š
.v®id && 
Ï¡


62 
out
.
b™s
 :ğ
š
.bits

65 
edgeOut
.
	`d©a
(
out
.
b™s
è:ğ(ià(
edgeIn
.
	`¡©icHasD©a
(
š
.b™sè=ğ
	`Some
(
çl£
)è
	`UIÁ
(0è
	`h–³r
(edgeIn.data(in.bits)))

66 
edgeOut
.
	`cÜru±
(
out
.
b™s
è:ğ
cÜru±_out


68 (
out
.
b™s
, 
š
.b™sè
m©ch
 {

69 (
o
: 
TLBundËA
, 
i
: TLBundËAè=> o.
mask
 :ğ
edgeOut
.
	`mask
(o.
add»ss
, o.
size
è& 
	`Mux
(
hasD©a
, 
	`h–³r
(i.mask), ~
	`UIÁ
(0, 
width
=
outBy‹s
))

70 (
o
: 
TLBundËB
, 
i
: TLBundËBè=> o.
mask
 :ğ
edgeOut
.
	`mask
(o.
add»ss
, o.
size
è& 
	`Mux
(
hasD©a
, 
	`h–³r
(i.mask), ~
	`UIÁ
(0, 
width
=
outBy‹s
))

71 (
o
: 
TLBundËC
, 
i
: TLBundleC) => ()

72 (
o
: 
TLBundËD
, 
i
: TLBundleD) => ()

73 
_
 => 
	`»quœe
(
çl£
, "Impossible bundle combination in WidthWidget")

77 
def
 
¥l™
[
T
 <: 
TLD©aChªÃl
](
edgeIn
: 
TLEdge
, 
š
: 
Decou¶edIO
[T], 
edgeOut
: TLEdge, 
out
: Decou¶edIO[T], 
sourûM­
: 
UIÁ
 => UInt) = {

78 
v®
 
šBy‹s
 = 
edgeIn
.
mªag”
.
b—tBy‹s


79 
v®
 
outBy‹s
 = 
edgeOut
.
mªag”
.
b—tBy‹s


80 
v®
 
¿tio
 = 
šBy‹s
 / 
outBy‹s


81 
v®
 
k“pB™s
 = 
	`log2Ce
(
šBy‹s
)

82 
v®
 
drİB™s
 = 
	`log2Ce
(
outBy‹s
)

83 
v®
 
couÁB™s
 = 
	`log2Ce
(
¿tio
)

85 
v®
 
size
 = 
edgeIn
.
	`size
(
š
.
b™s
)

86 
v®
 
hasD©a
 = 
edgeIn
.
	`hasD©a
(
š
.
b™s
)

87 
v®
 
lim™
 = 
	`UIÁToOH1
(
size
, 
k“pB™s
è>> 
drİB™s


89 
v®
 
couÁ
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
 = 
couÁB™s
))

90 
v®
 
fœ¡
 = 
couÁ
 ==ğ
	`UIÁ
(0)

91 
v®
 
Ï¡
 = 
couÁ
 ==ğ
lim™
 || !
hasD©a


93 
	`wh’
 (
out
.
	`fœe
()) {

94 
couÁ
 :ğcouÁ + 
	`UIÁ
(1)

95 
	`wh’
 (
Ï¡
è{ 
couÁ
 :ğ
	`UIÁ
(0) }

99 
v®
 
£l
 = 
š
.
b™s
 
m©ch
 {

100 
a
: 
TLBundËA
 =>‡.
	`add»ss
(
k“pB™s
-1, 
drİB™s
)

101 
b
: 
TLBundËB
 => b.
	`add»ss
(
k“pB™s
-1, 
drİB™s
)

102 
c
: 
TLBundËC
 => c.
	`add»ss
(
k“pB™s
-1, 
drİB™s
)

103 
d
: 
TLBundËD
 => {

104 
v®
 
£l
 = 
	`sourûM­
(
d
.
sourû
)

105 
v®
 
hŞd
 = 
	`Mux
(
fœ¡
, 
£l
, 
	`RegEÇbË
(sel, first))

106 
hŞd
 & ~
lim™


110 
v®
 
šdex
 = 
£l
 | 
couÁ


111 
def
 
	`h–³r
(
id©a
: 
UIÁ
, 
width
: 
IÁ
): UInt = {

112 
v®
 
mux
 = 
Vec
.
	`buÏ‹
(
¿tio
è{ 
i
 => 
	`id©a
((i+1)*
outBy‹s
*
width
-1, i*outBytes*width) }

113 
	`mux
(
šdex
)

116 
out
 <> 
š


119 
edgeOut
.
	`d©a
(
out
.
b™s
è:ğ(ià(
edgeIn
.
	`¡©icHasD©a
(
š
.b™sè=ğ
	`Some
(
çl£
)è
	`UIÁ
(0è
	`h–³r
(edgeIn.data(in.bits), 8))

121 (
out
.
b™s
, 
š
.b™sè
m©ch
 {

122 (
o
: 
TLBundËA
, 
i
: TLBundËAè=> o.
mask
 :ğ
	`h–³r
(i.mask, 1)

123 (
o
: 
TLBundËB
, 
i
: TLBundËBè=> o.
mask
 :ğ
	`h–³r
(i.mask, 1)

124 (
o
: 
TLBundËC
, 
i
: TLBundleC) => ()

125 (
o
: 
TLBundËD
, 
i
: TLBundleD) => ()

126 
_
 => 
	`»quœe
(
çl£
, "Impossbile bundle combination in WidthWidget")

130 !
Ï¡


133 
def
 
¥liû
[
T
 <: 
TLD©aChªÃl
](
edgeIn
: 
TLEdge
, 
š
: 
Decou¶edIO
[T], 
edgeOut
: TLEdge, 
out
: Decou¶edIO[T], 
sourûM­
: 
UIÁ
 => UInt) = {

134 ià(
edgeIn
.
mªag”
.
b—tBy‹s
 =ğ
edgeOut
.manager.beatBytes) {

136 
out
 <> 
š


137 } ià(
edgeIn
.
mªag”
.
b—tBy‹s
 > 
edgeOut
.manager.beatBytes) {

139 
v®
 
»³©
 = 
	`Wœe
(
	`BoŞ
())

140 
v®
 
»³©ed
 = 
	`R•—‹r
(
š
, 
»³©
)

141 
v®
 
ÿ‹d
 = 
	`Wœe
(
»³©ed
)

142 
ÿ‹d
 <> 
»³©ed


143 
edgeIn
.
	`d©a
(
ÿ‹d
.
b™s
è:ğ
	`C©
(

144 
edgeIn
.
	`d©a
(
»³©ed
.
b™s
)ÓdgeIn.
mªag”
.
b—tBy‹s
*8-1, 
edgeOut
.manager.beatBytes*8),

145 
edgeIn
.
	`d©a
(
š
.
b™s
)(
edgeOut
.
mªag”
.
b—tBy‹s
*8-1, 0))

146 
»³©
 :ğ
	`¥l™
(
edgeIn
, 
ÿ‹d
, 
edgeOut
, 
out
, 
sourûM­
)

149 
	`m”ge
(
edgeIn
, 
š
, 
edgeOut
, 
out
)

153 (
node
.
š
 
z
‚ode.
out
è
fÜ—ch
 { ((š, 
edgeIn
), (out, 
edgeOut
)) =>

162 
def
 
	`sourûM­
(
sourû
: 
UIÁ
) = {

163 
	`»quœe
 (
edgeOut
.
mªag”
.
b—tBy‹s
 > 
edgeIn
.manager.beatBytes)

164 
v®
 
k“pB™s
 = 
	`log2Ce
(
edgeOut
.
mªag”
.
b—tBy‹s
)

165 
v®
 
drİB™s
 = 
	`log2Ce
(
edgeIn
.
mªag”
.
b—tBy‹s
)

166 
v®
 
sourûs
 = 
	`Reg
(
	`Vec
(
edgeIn
.
ş›Á
.
’dSourûId
, 
	`UIÁ
(
width
 = 
k“pB™s
-
drİB™s
)))

167 
v®
 
a_£l
 = 
š
.
a
.
b™s
.
	`add»ss
(
k“pB™s
-1, 
drİB™s
)

168 
	`wh’
 (
š
.
a
.
	`fœe
()) {

169 
	`sourûs
(
š
.
a
.
b™s
.
sourû
è:ğ
a_£l


173 
edgeIn
.
ş›Á
.
unu£dSourûs
.
fÜ—ch
 { 
id
 => 
	`sourûs
(idè:ğ
	`UIÁ
(0) }

175 
v®
 
by·ss
 = 
	`BoŞ
(
edgeIn
.
mªag”
.
mšL©’cy
 =ğ0è&& 
š
.
a
.
v®id
 && in.a.
b™s
.
sourû
 === source

176 
	`Mux
(
by·ss
, 
a_£l
, 
	`sourûs
(
sourû
))

179 
	`¥liû
(
edgeIn
, 
š
.
a
, 
edgeOut
, 
out
.a, 
sourûM­
)

180 
	`¥liû
(
edgeOut
, 
out
.
d
, 
edgeIn
, 
š
.d, 
sourûM­
)

182 ià(
edgeOut
.
mªag”
.
ªySuµÜtAcquœeB
 && 
edgeIn
.
ş›Á
.
ªySuµÜtProbe
) {

183 
	`¥liû
(
edgeOut
, 
out
.
b
, 
edgeIn
, 
š
.b, 
sourûM­
)

184 
	`¥liû
(
edgeIn
, 
š
.
c
, 
edgeOut
, 
out
.c, 
sourûM­
)

185 
out
.
e
 <> 
š
.e

187 
š
.
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

188 
š
.
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

189 
š
.
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

190 
out
.
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

191 
out
.
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

192 
out
.
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

195 
	}
}

198 
objeù
 
TLWidthWidg‘


200 
def
 
­¶y
(
šÃrB—tBy‹s
: 
IÁ
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

202 
v®
 
widg‘
 = 
LazyModuË
(
Ãw
 
TLWidthWidg‘
(
šÃrB—tBy‹s
))

203 
widg‘
.
node


208 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


210 
şass
 
	$TLRAMWidthWidg‘
(
fœ¡
: 
IÁ
, 
£cÚd
: IÁ, 
txns
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

211 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

212 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("WidthWidget"))

213 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0x0, 0x3ff)))

215 (
¿m
.
node


216 :ğ
	`TLD–ay”
(0.1)

217 :ğ
	`TLF¿gm’‹r
(4, 256)

218 :ğ
	`TLWidthWidg‘
(
£cÚd
)

219 :ğ
	`TLWidthWidg‘
(
fœ¡
)

220 :ğ
	`TLD–ay”
(0.1)

221 :ğ
mod–
.
node


222 :ğ
fuzz
.
node
)

224 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

225 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

227 
	}
}

229 
şass
 
	$TLRAMWidthWidg‘Te¡
(
l™e
: 
IÁ
, 
big
: IÁ, 
txns
: IÁ = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

230 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMWidthWidg‘
(
l™e
,
big
,
txns
)).
moduË
)

231 
io
.
fšished
 :ğ
dut
.io.finished

232 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Xbar.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


10 
objeù
 
	gFÜûFªout


12 
def
 
	g­¶y
[
T
](

13 
	ga
: 
TriS‹V®ue
 = TriS‹V®ue.
un£t
,

14 
	gb
: 
TriS‹V®ue
 = TriS‹V®ue.
un£t
,

15 
	gc
: 
TriS‹V®ue
 = TriS‹V®ue.
un£t
,

16 
	gd
: 
TriS‹V®ue
 = TriS‹V®ue.
un£t
,

17 
	ge
: 
TriS‹V®ue
 = TriS‹V®ue.
un£t
)(
body
: 
P¬am‘”s
 => 
T
)(
im¶ic™
 
p
: Parameters) =

19 
body
(
p
.
®‹rP¬tŸl
 {

20 
FÜûFªoutKey
 => 
p
(FÜûFªoutKeyè
m©ch
 {

21 
FÜûFªoutP¬ams
(
·
, 
pb
, 
pc
, 
pd
, 
³
) =>

22 
FÜûFªoutP¬ams
(
a
.
upd©e
(
·
), 
b
.upd©e(
pb
), 
c
.upd©e(
pc
), 
d
.upd©e(
pd
), 
e
.upd©e(
³
))

28 
´iv©e
 
şass
 
	$FÜûFªoutP¬ams
(
a
: 
BoŞ—n
, 
b
: BoŞ—n, 
c
: BoŞ—n, 
d
: BoŞ—n, 
e
: Boolean)

29 
´iv©e
 
objeù
 
FÜûFªoutKey
 
ex‹nds
 
	`F›ld
(
	$FÜûFªoutP¬ams
(
çl£
, false, false, false, false))

31 
şass
 
	$TLXb¬
(
pŞicy
: 
TLArb™”
.
PŞicy
 = TLArb™”.
roundRobš
)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


33 
v®
 
node
 = 
	`TLNexusNode
(

34 
ş›ÁFn
 = { 
£q
 =>

35 
	`£q
(0).
	`cİy
(

36 
mšL©’cy
 = 
£q
.
	`m­
(
_
.mšL©’cy).
mš
,

37 
ş›Ás
 = (
TLXb¬
.
	`m­IÅutIds
(
£q
è
z
 seqè
æ©M­
 { (
¿nge
, 
pÜt
) =>

38 
pÜt
.
ş›Ás
 
m­
 { 
ş›Á
 => cl›Á.
	`cİy
(

39 
sourûId
 = 
ş›Á
.sourûId.
	`shiá
(
¿nge
.
¡¬t
)

44 
mªag”Fn
 = { 
£q
 =>

45 
v®
 
fifoIdFaùÜy
 = 
TLXb¬
.
	`»Ïb–”
()

46 
	`£q
(0).
	`cİy
(

47 
mšL©’cy
 = 
£q
.
	`m­
(
_
.mšL©’cy).
mš
,

48 
’dSškId
 = 
TLXb¬
.
	`m­OuutIds
(
£q
).
	`m­
(
_
.
’d
).
max
,

49 
mªag”s
 = 
£q
.
æ©M­
 { 
pÜt
 =>

50 
	`»quœe
 (
pÜt
.
b—tBy‹s
 =ğ
	`£q
(0).beatBytes,

51 
s
"Xbar data widths don't match: ${port.managers.map(_.name)} has ${port.beatBytes}B vs ${seq(0).managers.map(_.name)} has ${seq(0).beatBytes}B")

52 
v®
 
fifoIdM­³r
 = 
	`fifoIdFaùÜy
()

53 
pÜt
.
mªag”s
 
m­
 { 
mªag”
 => mªag”.
	`cİy
(

54 
fifoId
 = 
mªag”
.fifoId.
	`m­
(
	`fifoIdM­³r
(
_
))

60 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
) {

61 ià((
node
.
š
.
size
 *‚ode.
out
.size) > (8*32)) {

62 
	`´šn
 (
s
"!!! WARNING !!!")

63 
	`´šn
 (
s
" Your TLXbar ($name) is very†arge, with ${node.in.size} Masters‡nd ${node.out.size} Slaves.")

64 
	`´šn
 (
s
"!!! WARNING !!!")

67 
	`v®
 (
io_š
, 
edgesIn
èğ
node
.
š
.
unz


68 
	`v®
 (
io_out
, 
edgesOut
èğ
node
.
out
.
unz


71 
v®
 
»achabËIO
 = 
edgesIn
.
m­
 { 
ı
 => 
edgesOut
.m­ { 
mp
 =>

72 
ı
.
ş›Á
.
ş›Ás
.
exi¡s
 { 
c
 => 
mp
.
mªag”
.
mªag”s
.exi¡ { 
m
 =>

73 
c
.
visib™y
.
exi¡s
 { 
ÿ
 => 
m
.
add»ss
.exi¡ { 
ma
 =>

74 
ÿ
.
	`ov”Ïps
(
ma
)}}}}

75 }.
toVeùÜ
}.toVector

76 
v®
 
´obeIO
 = (
edgesIn
 
z
 
»achabËIO
).
m­
 { (
ı
, 
»achabËO
) =>

77 (
edgesOut
 
z
 
»achabËO
).
m­
 { (
mp
, 
»achabË
) =>

78 
»achabË
 && 
ı
.
ş›Á
.
ªySuµÜtProbe
 && 
mp
.
mªag”
.
mªag”s
.
	`exi¡s
(
_
.
»giÚTy³
 >ğ
RegiÚTy³
.
TRACKED
)

79 }.
toVeùÜ
}.toVector

80 
v®
 
»Ëa£IO
 = (
edgesIn
 
z
 
»achabËIO
).
m­
 { (
ı
, 
»achabËO
) =>

81 (
edgesOut
 
z
 
»achabËO
).
m­
 { (
mp
, 
»achabË
) =>

82 
»achabË
 && 
ı
.
ş›Á
.
ªySuµÜtProbe
 && 
mp
.
mªag”
.
ªySuµÜtAcquœeB


83 }.
toVeùÜ
}.toVector

85 
v®
 
cÚÃùAIO
 = 
»achabËIO


86 
v®
 
cÚÃùBIO
 = 
´obeIO


87 
v®
 
cÚÃùCIO
 = 
»Ëa£IO


88 
v®
 
cÚÃùDIO
 = 
»achabËIO


89 
v®
 
cÚÃùEIO
 = 
»Ëa£IO


91 
def
 
Œª¥o£
[
T
](
x
: 
Seq
[Seq[T]]èğià(x.
isEm±y
è
N
 
VeùÜ
.
	`buÏ‹
(
	`x
(0).
size
è{ 
i
 => VeùÜ.buÏ‹(x.sizeè{ 
j
 => x(j)(i) } }

92 
v®
 
cÚÃùAOI
 = 
	`Œª¥o£
(
cÚÃùAIO
)

93 
v®
 
cÚÃùBOI
 = 
	`Œª¥o£
(
cÚÃùBIO
)

94 
v®
 
cÚÃùCOI
 = 
	`Œª¥o£
(
cÚÃùCIO
)

95 
v®
 
cÚÃùDOI
 = 
	`Œª¥o£
(
cÚÃùDIO
)

96 
v®
 
cÚÃùEOI
 = 
	`Œª¥o£
(
cÚÃùEIO
)

99 
v®
 
šputIdRªges
 = 
TLXb¬
.
	`m­IÅutIds
(
edgesIn
.
	`m­
(
_
.
ş›Á
))

100 
v®
 
ouutIdRªges
 = 
TLXb¬
.
	`m­OuutIds
(
edgesOut
.
	`m­
(
_
.
mªag”
))

103 
v®
 
wide_bundË
 = 
TLBundËP¬am‘”s
.(
io_š
.
	`m­
(
_
.
·¿ms
è++ 
io_out
.map(_.params))

106 
def
 
	`Œim
(
id
: 
UIÁ
, 
size
: 
IÁ
èğià(siz<ğ1è
	`UIÁ
(0è
	`id
(
	`log2Ce
(size)-1, 0)

109 
v®
 
š
 = 
	`Wœe
(
	`Vec
(
io_š
.
size
, 
	`TLBundË
(
wide_bundË
)))

110 
i
 <- 0 
uÁ
 
š
.
size
) {

111 
v®
 
r
 = 
	`šputIdRªges
(
i
)

113 ià(
	`cÚÃùAIO
(
i
).
	`exi¡s
(
x
=>x)) {

114 
	`š
(
i
).
a
 <> 
	`io_š
(i).a

115 
	`š
(
i
).
a
.
b™s
.
sourû
 :ğ
	`io_š
(i).a.b™s.sourû | 
	`UIÁ
(
r
.
¡¬t
)

117 
	`š
(
i
).
a
.
v®id
 :ğ
	`BoŞ
(
çl£
)

118 
	`io_š
(
i
).
a
.
»ady
 :ğ
	`BoŞ
(
Œue
)

121 ià(
	`cÚÃùBIO
(
i
).
	`exi¡s
(
x
=>x)) {

122 
	`io_š
(
i
).
b
 <> 
	`š
(i).b

123 
	`io_š
(
i
).
b
.
b™s
.
sourû
 :ğ
	`Œim
(
	`š
(i).b.b™s.sourû, 
r
.
size
)

125 
	`š
(
i
).
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

126 
	`io_š
(
i
).
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

129 ià(
	`cÚÃùCIO
(
i
).
	`exi¡s
(
x
=>x)) {

130 
	`š
(
i
).
c
 <> 
	`io_š
(i).c

131 
	`š
(
i
).
c
.
b™s
.
sourû
 :ğ
	`io_š
(i).c.b™s.sourû | 
	`UIÁ
(
r
.
¡¬t
)

133 
	`š
(
i
).
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

134 
	`io_š
(
i
).
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

137 ià(
	`cÚÃùDIO
(
i
).
	`exi¡s
(
x
=>x)) {

138 
	`io_š
(
i
).
d
 <> 
	`š
(i).d

139 
	`io_š
(
i
).
d
.
b™s
.
sourû
 :ğ
	`Œim
(
	`š
(i).d.b™s.sourû, 
r
.
size
)

141 
	`š
(
i
).
d
.
»ady
 :ğ
	`BoŞ
(
Œue
)

142 
	`io_š
(
i
).
d
.
v®id
 :ğ
	`BoŞ
(
çl£
)

145 ià(
	`cÚÃùEIO
(
i
).
	`exi¡s
(
x
=>x)) {

146 
	`š
(
i
).
e
 <> 
	`io_š
(i).e

148 
	`š
(
i
).
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

149 
	`io_š
(
i
).
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

154 
v®
 
out
 = 
	`Wœe
(
	`Vec
(
io_out
.
size
, 
	`TLBundË
(
wide_bundË
)))

155 
o
 <- 0 
uÁ
 
out
.
size
) {

156 
v®
 
r
 = 
	`ouutIdRªges
(
o
)

158 ià(
	`cÚÃùAOI
(
o
).
	`exi¡s
(
x
=>x)) {

159 
	`io_out
(
o
).
a
 <> 
	`out
(o).a

161 
	`out
(
o
).
a
.
»ady
 :ğ
	`BoŞ
(
Œue
)

162 
	`io_out
(
o
).
a
.
v®id
 :ğ
	`BoŞ
(
çl£
)

165 ià(
	`cÚÃùBOI
(
o
).
	`exi¡s
(
x
=>x)) {

166 
	`out
(
o
).
b
 <> 
	`io_out
(o).b

168 
	`out
(
o
).
b
.
v®id
 :ğ
	`BoŞ
(
çl£
)

169 
	`io_out
(
o
).
b
.
»ady
 :ğ
	`BoŞ
(
Œue
)

172 ià(
	`cÚÃùCOI
(
o
).
	`exi¡s
(
x
=>x)) {

173 
	`io_out
(
o
).
c
 <> 
	`out
(o).c

175 
	`out
(
o
).
c
.
»ady
 :ğ
	`BoŞ
(
Œue
)

176 
	`io_out
(
o
).
c
.
v®id
 :ğ
	`BoŞ
(
çl£
)

179 ià(
	`cÚÃùDOI
(
o
).
	`exi¡s
(
x
=>x)) {

180 
	`out
(
o
).
d
 <> 
	`io_out
(o).d

181 
	`out
(
o
).
d
.
b™s
.
sšk
 :ğ
	`io_out
(o).d.b™s.sšk | 
	`UIÁ
(
r
.
¡¬t
)

183 
	`out
(
o
).
d
.
v®id
 :ğ
	`BoŞ
(
çl£
)

184 
	`io_out
(
o
).
d
.
»ady
 :ğ
	`BoŞ
(
Œue
)

187 ià(
	`cÚÃùEOI
(
o
).
	`exi¡s
(
x
=>x)) {

188 
	`io_out
(
o
).
e
 <> 
	`out
(o).e

189 
	`io_out
(
o
).
e
.
b™s
.
sšk
 :ğ
	`Œim
(
	`out
(o).e.b™s.sšk, 
r
.
size
)

191 
	`out
(
o
).
e
.
»ady
 :ğ
	`BoŞ
(
Œue
)

192 
	`io_out
(
o
).
e
.
v®id
 :ğ
	`BoŞ
(
çl£
)

197 
def
 
f‹r
[
T
](
d©a
: 
Seq
[T], 
mask
: Seq[
BoŞ—n
]èğ(d©¨
z
 mask).
	`f‹r
(
_
.
_2
).
	`m­
(_.
_1
)

200 
v®
 
»quœedAC
 = (
cÚÃùAIO
 ++ 
cÚÃùCIO
).
di¡šù


201 
v®
 
ouutPÜtFns
: 
M­
[
VeùÜ
[
BoŞ—n
], 
Seq
[
UIÁ
 => 
BoŞ
]] = 
»quœedAC
.
m­
 { 
cÚÃùO
 =>

202 
v®
 
pÜt_addrs
 = 
edgesOut
.
	`m­
(
_
.
mªag”
.
mªag”s
.
	`æ©M­
(_.
add»ss
))

203 
v®
 
routšgMask
 = 
	`Add»ssDecod”
(
	`f‹r
(
pÜt_addrs
, 
cÚÃùO
))

204 
v®
 
rou‹_addrs
 = 
pÜt_addrs
.
	`m­
(
£q
 => 
Add»ssS‘
.
	`unify
(£q.m­(
_
.
	`wid’
(~
routšgMask
)).
di¡šù
))

207 ià(
çl£
) {

208 
	`´šn
("Xbar mapping:")

209 
rou‹_addrs
.
fÜ—ch
 { 
p
 =>

210 
	`´št
(" ")

211 
p
.
fÜ—ch
 { 
a
 => 
	`´št
(
s
" ${a}") }

212 
	`´šn
("")

214 
	`´šn
("--")

217 (
cÚÃùO
, 
rou‹_addrs
.
	`m­
(
£q
 => (
addr
: 
UIÁ
è=> seq.m­(
_
.
	`cÚšs
×ddr)).
	`»duû
(_ || _)))

218 }.
toM­


221 ià(
çl£
) {

222 
	`´šn
(
s
"XBar ${name} mapping:")

223 (
edgesIn
 
z
 
šputIdRªges
).
zW™hIndex
.
fÜ—ch
 { ((
edge
, 
id
), 
i
) =>

224 
	`´šn
(
s
"\t$i‡ssigned ${id} for ${edge.client.clients.map(_.name).mkString(", ")}")

226 
	`´šn
("")

229 
v®
 
add»ssA
 = (
š
 
z
 
edgesIn
è
m­
 { (
i
, 
e
è=>ƒ.
	`add»ss
(i.
a
.
b™s
) }

230 
v®
 
add»ssC
 = (
š
 
z
 
edgesIn
è
m­
 { (
i
, 
e
è=>ƒ.
	`add»ss
(i.
c
.
b™s
) }

232 
def
 
	`unique
(
x
: 
VeùÜ
[
BoŞ—n
]èğ
	`BoŞ
(x.
	`f‹r
(x=>x).
size
 <= 1)

233 
v®
 
»que¡AIO
 = (
cÚÃùAIO
 
z
 
add»ssA
è
m­
 { (
c
, 
i
è=> 
	`ouutPÜtFns
(c).m­ { 
o
 => 
	`unique
(cè|| 
	`o
(i) } }

234 
v®
 
»que¡CIO
 = (
cÚÃùCIO
 
z
 
add»ssC
è
m­
 { (
c
, 
i
è=> 
	`ouutPÜtFns
(c).m­ { 
o
 => 
	`unique
(cè|| 
	`o
(i) } }

235 
v®
 
»que¡BOI
 = 
out
.
m­
 { 
o
 => 
šputIdRªges
.m­ { 
i
 => i.
	`cÚšs
(o.
b
.
b™s
.
sourû
) } }

236 
v®
 
»que¡DOI
 = 
out
.
m­
 { 
o
 => 
šputIdRªges
.m­ { 
i
 => i.
	`cÚšs
(o.
d
.
b™s
.
sourû
) } }

237 
v®
 
»que¡EIO
 = 
š
.
m­
 { 
i
 => 
ouutIdRªges
.m­ { 
o
 => o.
	`cÚšs
(i.
e
.
b™s
.
sšk
) } }

239 
v®
 
b—tsAI
 = (
š
 
z
 
edgesIn
è
m­
 { (
i
, 
e
è=>ƒ.
	`numB—ts1
(i.
a
.
b™s
) }

240 
v®
 
b—tsBO
 = (
out
 
z
 
edgesOut
è
m­
 { (
o
, 
e
è=>ƒ.
	`numB—ts1
(o.
b
.
b™s
) }

241 
v®
 
b—tsCI
 = (
š
 
z
 
edgesIn
è
m­
 { (
i
, 
e
è=>ƒ.
	`numB—ts1
(i.
c
.
b™s
) }

242 
v®
 
b—tsDO
 = (
out
 
z
 
edgesOut
è
m­
 { (
o
, 
e
è=>ƒ.
	`numB—ts1
(o.
d
.
b™s
) }

243 
v®
 
b—tsEI
 = (
š
 
z
 
edgesIn
è
m­
 { (
i
, 
e
è=>ƒ.
	`numB—ts1
(i.e.
b™s
) }

246 
v®
 
pÜtsAOI
 = 
	`Œª¥o£
((
š
 
z
 
»que¡AIO
è
m­
 { (
i
, 
r
è=> 
TLXb¬
.
	`çnout
(i.
a
,„, 
edgesOut
.
	`m­
(
_
.
	`·¿ms
(
FÜûFªoutKey
).a)) })

247 
v®
 
pÜtsBIO
 = 
	`Œª¥o£
((
out
 
z
 
»que¡BOI
è
m­
 { (
o
, 
r
è=> 
TLXb¬
.
	`çnout
(o.
b
,„, 
edgesIn
 .
	`m­
(
_
.
	`·¿ms
(
FÜûFªoutKey
).b)) })

248 
v®
 
pÜtsCOI
 = 
	`Œª¥o£
((
š
 
z
 
»que¡CIO
è
m­
 { (
i
, 
r
è=> 
TLXb¬
.
	`çnout
(i.
c
,„, 
edgesOut
.
	`m­
(
_
.
	`·¿ms
(
FÜûFªoutKey
).c)) })

249 
v®
 
pÜtsDIO
 = 
	`Œª¥o£
((
out
 
z
 
»que¡DOI
è
m­
 { (
o
, 
r
è=> 
TLXb¬
.
	`çnout
(o.
d
,„, 
edgesIn
 .
	`m­
(
_
.
	`·¿ms
(
FÜûFªoutKey
).d)) })

250 
v®
 
pÜtsEOI
 = 
	`Œª¥o£
((
š
 
z
 
»que¡EIO
è
m­
 { (
i
, 
r
è=> 
TLXb¬
.
	`çnout
(i.
e
,„, 
edgesOut
.
	`m­
(
_
.
	`·¿ms
(
FÜûFªoutKey
).e)) })

253 
o
 <- 0 
uÁ
 
out
.
size
) {

254 
	`TLArb™”
(
pŞicy
)(
	`out
(
o
).
a
, 
	`f‹r
(
b—tsAI
 
z
 
	`pÜtsAOI
(o), 
	`cÚÃùAOI
(o)):
_
*)

255 
	`TLArb™”
(
pŞicy
)(
	`out
(
o
).
c
, 
	`f‹r
(
b—tsCI
 
z
 
	`pÜtsCOI
(o), 
	`cÚÃùCOI
(o)):
_
*)

256 
	`TLArb™”
(
pŞicy
)(
	`out
(
o
).
e
, 
	`f‹r
(
b—tsEI
 
z
 
	`pÜtsEOI
(o), 
	`cÚÃùEOI
(o)):
_
*)

259 
i
 <- 0 
uÁ
 
š
.
size
) {

260 
	`TLArb™”
(
pŞicy
)(
	`š
(
i
).
b
, 
	`f‹r
(
b—tsBO
 
z
 
	`pÜtsBIO
(i), 
	`cÚÃùBIO
(i)):
_
*)

261 
	`TLArb™”
(
pŞicy
)(
	`š
(
i
).
d
, 
	`f‹r
(
b—tsDO
 
z
 
	`pÜtsDIO
(i), 
	`cÚÃùDIO
(i)):
_
*)

264 
	}
}

266 
objeù
 
TLXb¬


268 
def
 
­¶y
(
pŞicy
: 
TLArb™”
.
PŞicy
 = TLArb™”.
roundRobš
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
TLNode
 =

270 
v®
 
xb¬
 = 
LazyModuË
(
Ãw
 
TLXb¬
(
pŞicy
))

271 
xb¬
.
node


274 
def
 
m­IÅutIds
 (
pÜts
: 
Seq
[
TLCl›ÁPÜtP¬am‘”s
 ]èğ
assignRªges
ÕÜts.
m­
(
_
.
’dSourûId
))

275 
def
 
m­OuutIds
(
pÜts
: 
Seq
[
TLMªag”PÜtP¬am‘”s
]èğ
assignRªges
ÕÜts.
m­
(
_
.
’dSškId
))

277 
def
 
assignRªges
(
sizes
: 
Seq
[
IÁ
]) = {

278 
v®
 
pow2Sizes
 = 
sizes
.
m­
 { 
z
 => ià(z =ğ0è0 1 << 
log2Ce
(z) }

279 
v®
 
tu¶es
 = 
pow2Sizes
.
zW™hIndex
.
sÜtBy
(
_
.
_1
)

280 
v®
 
¡¬ts
 = 
tu¶es
.
sÿnRight
(0)(
_
.
_1
 + _).



281 
v®
 
¿nges
 = (
tu¶es
 
z
 
¡¬ts
è
m­
 { ((
sz
, 
i
), 
¡
) =>

282 (ià(
sz
 =ğ0è
IdRªge
(0,0èIdRªge(
¡
, st+sz), 
	gi
)

284 
	g¿nges
.
sÜtBy
(
_
.
_2
).
m­
(_.
_1
)

287 
def
 
»Ïb–”
() = {

288 
v¬
 
idFaùÜy
 = 0

290 
v®
 
fifoM­
 = 
sÿÏ
.
cŞËùiÚ
.
mubË
.
HashM­
.
em±y
[
IÁ
, Int]

291 (
	gx
: 
IÁ
) => {

292 ià(
fifoM­
.
cÚšs
(
x
)) fifoMap(x) {

293 
v®
 
out
 = 
idFaùÜy


294 
idFaùÜy
 = idFactory + 1

295 
fifoM­
 +ğ(
x
 -> 
out
)

296 
out


303 
def
 
çnout
[
T
 <: 
TLChªÃl
](
šput
: 
Decou¶edIO
[T], 
	g£Ëù
: 
Seq
[
BoŞ
], 
	gfÜû
: Seq[
BoŞ—n
] = 
N
): Seq[DecoupledIO[T]] = {

304 
v®
 
f‹»d
 = 
Wœe
(
Vec
(
£Ëù
.
size
, 
šput
))

305 
	gi
 <- 0 
uÁ
 
	g£Ëù
.
	gsize
) {

306 
f‹»d
(
i
).
	gb™s
 :ğ(ià(
fÜû
.
liá
(i).
g‘OrEl£
(
çl£
)è
Id’t™yModuË
(
šput
.
b™s
) input.bits)

307 
f‹»d
(
i
).
v®id
 :ğ
šput
.v®id && (
£Ëù
(iè|| 
BoŞ
(£Ëù.
size
 == 1))

309 
šput
.
»ady
 :ğ
Mux1H
(
£Ëù
, 
f‹»d
.
m­
(
_
.ready))

310 
	gf‹»d


315 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
_


317 
şass
 
	$TLRAMXb¬
(
nMªag”s
: 
IÁ
, 
txns
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

318 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

319 
v®
 
mod–
 = 
	`LazyModuË
(
Ãw
 
	`TLRAMMod–
("Xbar"))

320 
v®
 
xb¬
 = 
	`LazyModuË
(
Ãw
 
TLXb¬
)

322 
xb¬
.
node
 :ğ
	`TLD–ay”
(0.1è:ğ
mod–
.nod:ğ
fuzz
.node

323 (0 
uÁ
 
nMªag”s
è
fÜ—ch
 { 
n
 =>

324 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0x0+0x400*
n
, 0x3ff)))

325 
¿m
.
node
 :ğ
	`TLF¿gm’‹r
(4, 256è:ğ
	`TLD–ay”
(0.1è:ğ
xb¬
.node

328 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

329 
io
.
fšished
 :ğ
fuzz
.
moduË
.io.finished

331 
	}
}

333 
şass
 
	$TLRAMXb¬Te¡
(
nMªag”s
: 
IÁ
, 
txns
: IÁ = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

334 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLRAMXb¬
(
nMªag”s
,
txns
)).
moduË
)

335 
io
.
fšished
 :ğ
dut
.io.finished

336 
	}
}

338 
şass
 
	$TLMuÉiş›ÁXb¬
(
nMªag”s
: 
IÁ
, 
nCl›Ás
: IÁ, 
txns
: IÁ)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË
 {

339 
v®
 
xb¬
 = 
	`LazyModuË
(
Ãw
 
TLXb¬
)

341 
v®
 
fuzz”s
 = (0 
uÁ
 
nCl›Ás
è
m­
 { 
n
 =>

342 
v®
 
fuzz
 = 
	`LazyModuË
(
Ãw
 
	`TLFuzz”
(
txns
))

343 
xb¬
.
node
 :ğ
	`TLD–ay”
(0.1è:ğ
fuzz
.node

344 
fuzz


347 (0 
uÁ
 
nMªag”s
è
fÜ—ch
 { 
n
 =>

348 
v®
 
¿m
 = 
	`LazyModuË
(
Ãw
 
	`TLRAM
(
	`Add»ssS‘
(0x0+0x400*
n
, 0x3ff)))

349 
¿m
.
node
 :ğ
	`TLF¿gm’‹r
(4, 256è:ğ
	`TLD–ay”
(0.1è:ğ
xb¬
.node

352 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	`LazyModuËImp
(
this
è
w™h
 
Un™Te¡ModuË
 {

353 
io
.
fšished
 :ğ
fuzz”s
.
Ï¡
.
moduË
.io.finished

355 
	}
}

357 
şass
 
	$TLMuÉiş›ÁXb¬Te¡
(
nMªag”s
: 
IÁ
, 
nCl›Ás
: IÁ, 
txns
: IÁ = 5000, 
timeout
: IÁ = 500000)(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

358 
v®
 
dut
 = 
	`ModuË
(
	`LazyModuË
(
Ãw
 
	`TLMuÉiş›ÁXb¬
(
nMªag”s
, 
nCl›Ás
, 
txns
)).
moduË
)

359 
io
.
fšished
 :ğ
dut
.io.finished

360 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


8 
·ckage
 
objeù
 
	gt–šk


10 
ty³
 
	gTLInw¬dNode
 = 
Inw¬dNodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
, 
TLMªag”PÜtP¬am‘”s
, 
TLEdgeIn
, 
TLBundË
]

11 
ty³
 
	gTLOutw¬dNode
 = 
Outw¬dNodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
, 
TLMªag”PÜtP¬am‘”s
, 
TLEdgeOut
, 
TLBundË
]

12 
ty³
 
	gTLNode
 = 
NodeHªdË
[
TLCl›ÁPÜtP¬am‘”s
, 
TLMªag”PÜtP¬am‘”s
, 
TLEdgeIn
, 
TLBundË
, TLCl›ÁPÜtP¬am‘”s, TLMªag”PÜtP¬am‘”s, 
TLEdgeOut
, TLBundle]

14 
im¶ic™
 cÏs 
	cTLClockDomašCrossšg
(
v®
 
x
: 
HasClockDomašCrossšg
è
ex‹nds
 
AnyV®
 {

15 
def
 
	`üossIn
 (
n
: 
TLInw¬dNode
è(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`TLInw¬dCrossšgH–³r
 (v®Name.
Çme
, 
x
,‚)

16 
def
 
	`üossOut
(
n
: 
TLOutw¬dNode
)(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`TLOutw¬dCrossšgH–³r
(v®Name.
Çme
, 
x
,‚)

17 
def
 
	`üoss
(
n
: 
TLInw¬dNode
è(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`üossIn
(n)

18 
def
 
	`üoss
(
n
: 
TLOutw¬dNode
)(
im¶ic™
 
v®Name
: 
V®Name
èğ
	`üossOut
(n)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Configs.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
un™‹¡


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	gahb
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	g­b
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	gaxi4
.
_


9 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsubsy¡em
.{
	gBa£Subsy¡emCÚfig
}

11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdeviûs
.
	gt–šk
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


15 
objeù
 
Te¡Du¿tiÚMuÉl›r
 
ex‹nds
 
	gF›ld
[
IÁ
]

17 
şass
 
	$W™hTe¡Du¿tiÚ
(
x
: 
IÁ
è
ex‹nds
 
	`CÚfig
((
s™e
, 
h”e
, 
up
) => {

18 
Te¡Du¿tiÚMuÉl›r
 => 
x


19 
	}
})

21 
şass
 
W™hAMBAUn™Te¡s
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

22 
Un™Te¡s
 => (
q
: 
P¬am‘”s
) => {

23 
im¶ic™
 
v®
 
p
 = 
q


24 
v®
 
txns
 = 100 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

25 
v®
 
timeout
 = 50000 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

26 
Seq
(

27 
ModuË
(
Ãw
 
AHBBridgeTe¡
(
Œue
, 
txns
=8*txns, 
timeout
=timeout)),

28 
ModuË
(
Ãw
 
AHBN©iveTe¡
(
Œue
, 
txns
=6*txns, 
timeout
=timeout)),

29 
ModuË
(
Ãw
 
AHBN©iveTe¡
(
çl£
,
txns
=6*txns, 
timeout
=timeout)),

30 
ModuË
(
Ãw
 
APBBridgeTe¡
(
Œue
, 
txns
=6*txns, 
timeout
=timeout)),

31 
ModuË
(
Ãw
 
APBBridgeTe¡
(
çl£
,
txns
=6*txns, 
timeout
=timeout)),

32 
ModuË
(
Ãw
 
AXI4L™eFuzzRAMTe¡
(
txns
=6*txns, 
timeout
=timeout)),

33 
ModuË
(
Ãw
 
AXI4FuÎFuzzRAMTe¡
(
txns
=3*txns, 
timeout
=timeout)),

34 
ModuË
(
Ãw
 
AXI4BridgeTe¡
Ğ
txns
=3*txns, 
timeout
=timeout)),

35 
ModuË
(
Ãw
 
AXI4Xb¬Te¡
Ğ
txns
=1*txns, 
timeout
=timeout)),

36 
ModuË
(
Ãw
 
AXI4RAMAsyncCrossšgTe¡
(
txns
=3*txns, 
timeout
=timeout))) }

39 
şass
 
W™hTLSim¶eUn™Te¡s
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

40 
Un™Te¡s
 => (
q
: 
P¬am‘”s
) => {

41 
im¶ic™
 
v®
 
p
 = 
q


42 
v®
 
txns
 = 100 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

43 
v®
 
timeout
 = 50000 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

44 
Seq
(

45 
ModuË
(
Ãw
 
TLRAMSim¶eTe¡
(1, 
txns
=15*txns, 
timeout
=timeout)),

46 
ModuË
(
Ãw
 
TLRAMSim¶eTe¡
(4, 
txns
=15*txns, 
timeout
=timeout)),

47 
ModuË
(
Ãw
 
TLRAMSim¶eTe¡
(16, 
txns
=15*txns, 
timeout
=timeout)),

48 
ModuË
(
Ãw
 
TLRAMZ”oD–ayTe¡
(4, 
txns
=15*txns, 
timeout
=timeout)),

49 
ModuË
(
Ãw
 
TLRAMHštHªdËrTe¡
Ğ
txns
=15*txns, 
timeout
=timeout)),

50 
ModuË
(
Ãw
 
TLFuzzRAMTe¡
Ğ
txns
ğ3*txns, 
timeout
=timeout)),

51 
ModuË
(
Ãw
 
TLRR0Te¡
Ğ
txns
ğ3*txns, 
timeout
=timeout)),

52 
ModuË
(
Ãw
 
TLRR1Te¡
Ğ
txns
ğ3*txns, 
timeout
=timeout)),

53 
ModuË
(
Ãw
 
TLRAMR©iÚ®CrossšgTe¡
(
txns
ğ3*txns, 
timeout
=timeout)),

54 
ModuË
(
Ãw
 
TLRAMAsyncCrossšgTe¡
Ğ
txns
ğ5*txns, 
timeout
=timeout)),

55 
ModuË
(
Ãw
 
TLRAMAtomicAutom©aTe¡
Ğ
txns
=10*txns, 
timeout
=timeout)),

56 
ModuË
(
Ãw
 
TLRAMECCTe¡
(8, 4, 
txns
=15*txns, 
timeout
=timeout)),

57 
ModuË
(
Ãw
 
TLRAMECCTe¡
(4, 1, 
txns
=15*txns, 
timeout
=timeout)),

58 
ModuË
(
Ãw
 
TLRAMECCTe¡
(1, 1, 
txns
=15*txns, 
timeout
=timeout)) ) }

61 
şass
 
W™hTLWidthUn™Te¡s
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

62 
Un™Te¡s
 => (
q
: 
P¬am‘”s
) => {

63 
im¶ic™
 
v®
 
p
 = 
q


64 
v®
 
txns
 = 100 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

65 
v®
 
timeout
 = 50000 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

66 
Seq
(

67 
ModuË
(
Ãw
 
TLRAMF¿gm’‹rTe¡
Ğ4, 256, 
txns
ğ5*txns, 
timeout
=timeout)),

68 
ModuË
(
Ãw
 
TLRAMF¿gm’‹rTe¡
(16, 64, 
txns
=15*txns, 
timeout
=timeout)),

69 
ModuË
(
Ãw
 
TLRAMF¿gm’‹rTe¡
Ğ4, 16, 
txns
=15*txns, 
timeout
=timeout)),

70 
ModuË
(
Ãw
 
TLRAMWidthWidg‘Te¡
Ğ1, 1, 
txns
ğ1*txns, 
timeout
=timeout)),

71 
ModuË
(
Ãw
 
TLRAMWidthWidg‘Te¡
Ğ4, 64, 
txns
ğ4*txns, 
timeout
=timeout)),

72 
ModuË
(
Ãw
 
TLRAMWidthWidg‘Te¡
(64, 4, 
txns
ğ5*txns, 
timeout
=timeout)) ) }

75 
şass
 
W™hTLXb¬Un™Te¡s
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

76 
Un™Te¡s
 => (
q
: 
P¬am‘”s
) => {

77 
im¶ic™
 
v®
 
p
 = 
q


78 
v®
 
txns
 = 100 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

79 
v®
 
timeout
 = 50000 * 
s™e
(
Te¡Du¿tiÚMuÉl›r
)

80 
Seq
(

81 
ModuË
(
Ãw
 
TLRAMXb¬Te¡
(1, 
txns
=5*txns, 
timeout
=timeout)),

82 
ModuË
(
Ãw
 
TLRAMXb¬Te¡
(2, 
txns
=5*txns, 
timeout
=timeout)),

83 
ModuË
(
Ãw
 
TLRAMXb¬Te¡
(8, 
txns
=5*txns, 
timeout
=timeout)),

84 
ModuË
(
Ãw
 
TLMuÉiş›ÁXb¬Te¡
(4,4, 
txns
=2*txns, 
timeout
=timeout)),

85 
ModuË
(
Ãw
 
TLMa¡”MuxTe¡
Ğ
txns
=5*txns, 
timeout
=timeout)) ) }

88 
şass
 
W™hECCTe¡s
 
ex‹nds
 
CÚfig
((
s™e
, 
h”e
, 
up
) => {

89 
Un™Te¡s
 => (
q
: 
P¬am‘”s
) => {

90 
Seq
(

92 
ModuË
(
Ãw
 
ECCTe¡
(1)),

93 
ModuË
(
Ãw
 
ECCTe¡
(4)),

94 
ModuË
(
Ãw
 
ECCTe¡
(11)),

96 
ModuË
(
Ãw
 
ECCTe¡
(2)),

97 
ModuË
(
Ãw
 
ECCTe¡
(5)),

98 
ModuË
(
Ãw
 
ECCTe¡
(12)),

100 
ModuË
(
Ãw
 
ECCTe¡
(3)),

101 
ModuË
(
Ãw
 
ECCTe¡
(10)),

103 
ModuË
(
Ãw
 
ECCTe¡
(8)) ) }

106 
şass
 
AMBAUn™Te¡CÚfig
 
ex‹nds
 
CÚfig
(
Ãw
 
W™hAMBAUn™Te¡s
 ++‚ew 
W™hTe¡Du¿tiÚ
(10è++‚ew 
Ba£Subsy¡emCÚfig
)

107 
şass
 
TLSim¶eUn™Te¡CÚfig
 
ex‹nds
 
CÚfig
(
Ãw
 
W™hTLSim¶eUn™Te¡s
 ++‚ew 
W™hTe¡Du¿tiÚ
(10è++‚ew 
Ba£Subsy¡emCÚfig
)

108 
şass
 
TLWidthUn™Te¡CÚfig
 
ex‹nds
 
CÚfig
(
Ãw
 
W™hTLWidthUn™Te¡s
 ++‚ew 
W™hTe¡Du¿tiÚ
(10è++‚ew 
Ba£Subsy¡emCÚfig
)

109 
şass
 
TLXb¬Un™Te¡CÚfig
 
ex‹nds
 
CÚfig
(
Ãw
 
W™hTLXb¬Un™Te¡s
 ++‚ew 
W™hTe¡Du¿tiÚ
(10è++‚ew 
Ba£Subsy¡emCÚfig
)

110 
şass
 
ECCUn™Te¡CÚfig
 
ex‹nds
 
CÚfig
(
Ãw
 
W™hECCTe¡s
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Generator.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
un™‹¡


5 
objeù
 
G’”©Ü
 
ex‹nds
 
	gä“chs
.
	grock‘ch
.
	gut
.
	gG’”©ÜAµ
 {

6 
v®
 
	glÚgName
 = 
Çmes
.
tİModuËProjeù
 + "." +‚ames.
cÚfigs


7 
g’”©eFœ¹l


8 
g’”©eAÂo


9 
g’”©eTe¡Su™eMakeäags


10 
g’”©eA¹eçùs


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestGenerator.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
un™‹¡


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


9 
ab¡¿ù
 cÏs 
	cLazyUn™Te¡
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
LazyModuË


10 { 
£lf
 =>

11 
´Ùeùed
 
def
 
fšished
: 
BoŞ


13 
Ïzy
 
v®
 
moduË
 = 
Ãw
 
	$LazyModuËImp
(
this
) {

14 
v®
 
fšished
 = 
	`IO
(
	`BoŞ
(
OUTPUT
))

15 
fšished
 :ğ
£lf
.finished

17 
	}
}

20 
şass
 
Te¡G’”©Ü
(
g’
: 
LazyModuË
 => 
Seq
[
LazyUn™Te¡
])

22 
def
 
­¶y
(
lm
: 
LazyModuË
èğ
g’
(lm)

23 
def
 ++ (
Ùh”
: 
Te¡G’”©Ü
èğ
Ãw
 Te¡G’”©Ü(
g’
 = 
lm
 => gen(lm) ++ other(lm))

26 
objeù
 
Te¡G’”©Ü


28 
def
 
­¶y
(
m©ch”
: 
P¬tŸlFunùiÚ
[
LazyModuË
, 
Seq
[
LazyUn™Te¡
]]): 
Te¡G’”©Ü
 =

29 
Ãw
 
Te¡G’”©Ü
(
g’
 = 
m©ch”
.
liá
(
_
).
g‘OrEl£
(
N
))

30 
def
 
»cur£
(
Ùh”
: 
Te¡G’”©Ü
): TestGenerator = {

31 
def
 
h–³r
(
lm
: 
LazyModuË
, 

: 
Seq
[
LazyUn™Te¡
]): Seq[LazyUnitTest] =

32 
lm
.
g‘Chd»n
.
fŞdLeá
(
Ùh”
Ömè++ 

è{ Ña, 
chd
è=> 
h–³r
(child,ail) }

33 
Ãw
 
Te¡G’”©Ü
(
g’
 = 
h–³r
(
_
, 
N
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestHarness.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
un™‹¡


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 şas 
	cTe¡H¬Ãss
(
im¶ic™
 
v®
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

9 
v®
 
io
 = 
Ãw
 
BundË
 { v® 
sucûss
 = 
	`BoŞ
(
OUTPUT
) }

10 
io
.
sucûss
 :ğ
	`ModuË
(
Ãw
 
Un™Te¡Su™e
).io.
fšished


11 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/UnitTest.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
un™‹¡


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
MuÉiIOModuË


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
_


10 
Œa™
 
	gUn™Te¡IO
 {

11 
v®
 
	gfšished
 = 
BoŞ
(
OUTPUT
)

12 
v®
 
¡¬t
 = 
BoŞ
(
INPUT
)

15 
Œa™
 
	gHasUn™Te¡IO
 {

16 
v®
 
	gio
: 
Un™Te¡IO


19 
Œa™
 
Un™Te¡LegacyModuË
 
ex‹nds
 
HasUn™Te¡IO
 {

20 
v®
 
io
 = 
Ãw
 
BundË
 
w™h
 
Un™Te¡IO


23 
Œa™
 
Un™Te¡ModuË
 
ex‹nds
 
MuÉiIOModuË
 
w™h
 
HasUn™Te¡IO
 {

24 
v®
 
io
 = 
IO
(
Ãw
 
BundË
 
w™h
 
Un™Te¡IO
)

25 
EÏbÜ©iÚA¹eçùs
.
add
("¶usArgs", 
PlusArgA¹eçùs
.
£rŸlize_cH—d”
)

28 
ab¡¿ù
 
şass
 
	$Un™Te¡
(
v®
 
timeout
: 
IÁ
 = 4096è
ex‹nds
 
ModuË
 
w™h
 
Un™Te¡LegacyModuË
 {

29 
v®
 
‹¡Name
 = 
this
.
g‘CÏss
.
g‘Sim¶eName


31 
	`wh’
 (
io
.
¡¬t
è{ 
	`´štf
(
s
"Started UnitTest $testName\n") }

33 
v®
 
timed_out
 = 
	`Sim¶eTim”
(
timeout
, 
io
.
¡¬t
, io.
fšished
)

34 
	`as£¹
(!
timed_out
, 
s
"UnitTest $testNameimed out")

35 
	}
}

37 
objeù
 
Un™Te¡s
 
ex‹nds
 
	gF›ld
[
P¬am‘”s
 => 
Seq
[
Un™Te¡
]]

39 şas 
	cUn™Te¡Su™e
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

40 
v®
 
io
 = 
Ãw
 
BundË
 {

41 
v®
 
fšished
 = 
	`BoŞ
(
OUTPUT
)

44 
v®
 
‹¡s
 = 
	$p
(
Un™Te¡s
)(
p
)

46 
v®
 
s_idË
 :: 
s_¡¬t
 :: 
s_busy
 :: 
s_dÚe
 :: 
N
 = 
	`Enum
(
	`B™s
(), 4)

47 
v®
 
¡©e
 = 
	$Reg
(
š™
 = 
s_idË
)

48 
v®
 
‹¡s_fšished
 = 
	`Vec
(
‹¡s
.
	`m­
(
_
.
io
.
fšished
)).
	$»duû
(
_
&&_)

50 
‹¡s
.
fÜ—ch
 { 
_
.
io
.
¡¬t
 :ğ(
¡©e
 ==ğ
s_¡¬t
è
	}
}

51 
io
.
fšished
 :ğ(
¡©e
 ==ğ
s_dÚe
)

53 
	$wh’
 (
¡©e
 ==ğ
s_idË
è{ s‹ :ğ
s_¡¬t
 
	}
}

54 
	$wh’
 (
¡©e
 ==ğ
s_¡¬t
è{ s‹ :ğ
s_busy
 
	}
}

55 
	$wh’
 (
¡©e
 ==ğ
s_busy
 && 
‹¡s_fšished
è{ s‹ :ğ
s_dÚe
 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
impÜt
 
	gChi£l
.
_


7 
·ckage
 
objeù
 
	gun™‹¡


9 
im¶ic™
 
şass
 
LazyUn™Te¡Seq
(
v®
 
£q
: 
Seq
[
LazyUn™Te¡
]) {

10 
def
 
fšished
 = 
£q
.
m­
(
_
.
moduË
.fšished).
fŞdLeá
(
BoŞ
(
Œue
))(_ && _)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Annotations.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
In¡ªûId


7 
impÜt
 
	gchi£l3
.
	gex³rim’l
.{
	gªnÙ©e
, 
	gChi£lAÂÙ©iÚ
, 
	gRawModuË
}

8 
impÜt
 
	gfœ¹l
.
	gªnÙ©iÚs
.
_


10 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	g»gm­³r
.
_


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gt–šk
.
TLToAXI4IdM­EÁry


14 
impÜt
 
	gÜg
.
	gjsÚ4s
.
	gJsÚDSL
.
_


15 
impÜt
 
	gÜg
.
	gjsÚ4s
.
	gjacksÚ
.
	gJsÚM‘hods
.{
	g´‘ty
, 
	g»nd”
}

18 
şass
 
	$SRAMAÂÙ©iÚ
(
rg‘
: 
Named
,

19 
add»ss_width
: 
IÁ
,

20 
Çme
: 
SŒšg
,

21 
d©a_width
: 
IÁ
,

22 
d•th
: 
IÁ
,

23 
desütiÚ
: 
SŒšg
,

24 
wr™e_mask_g¿nuÏr™y
: 
IÁ
è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[
Named
] {

25 
def
 
	`du¶iÿ‹
(
n
: 
Named
èğ
this
.
	`cİy
(n)

26 
	}
}

29 
şass
 
	$IÁ”ru±sPÜtAÂÙ©iÚ
(
rg‘
: 
Named
, 
Çme
: 
SŒšg
, 
š‹¼u±Indexes
: 
Seq
[
IÁ
]è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[Named] {

30 
def
 
	`du¶iÿ‹
(
n
: 
Named
èğ
this
.
	`cİy
(n)

31 
	}
}

34 
şass
 
	$Glob®CÚ¡ªtsAÂÙ©iÚ
(
rg‘
: 
Named
, 
xL’
: 
IÁ
è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[Named] {

35 
def
 
	`du¶iÿ‹
(
n
: 
Named
èğ
this
.
	`cİy
(n)

36 
	}
}

38 
şass
 
Glob®CÚ¡ªtsChi£lAÂÙ©iÚ
[
T
 <: 
Produù
](
rg‘
: 
In¡ªûId
, 
	gxL’
: 
IÁ
è
ex‹nds
 
Chi£lAÂÙ©iÚ
 {

39 
def
 
toFœ¹l
 = 
Glob®CÚ¡ªtsAÂÙ©iÚ
(
rg‘
.
toNamed
, 
xL’
)

43 
şass
 
	$P¬amsAÂÙ©iÚ
(
rg‘
: 
Named
, 
·¿msCÏssName
: 
SŒšg
, 
·¿ms
: 
M­
[SŒšg,
Any
]è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[Named] {

44 
def
 
	`du¶iÿ‹
(
n
: 
Named
èğ
this
.
	`cİy
(n)

45 
	}
}

47 
şass
 
P¬amsChi£lAÂÙ©iÚ
[
T
 <: 
Produù
](
rg‘
: 
In¡ªûId
, 
	g·¿ms
: Tè
ex‹nds
 
Chi£lAÂÙ©iÚ
 {

48 
´iv©e
 
v®
 
·¿mM­
 = 
·¿ms
.
g‘CÏss
.
g‘Deş¬edF›lds
.
m­
(
_
.
g‘Name
).
z
Õ¬ams.
´oduùI‹¿tÜ
.
to
).
toM­


49 
def
 
toFœ¹l
 = 
P¬amsAÂÙ©iÚ
(
rg‘
.
toNamed
, 
·¿ms
.
g‘CÏss
.
g‘Name
, 
·¿mM­
)

53 
şass
 
	$Add»ssM­AÂÙ©iÚ
(
rg‘
: 
Named
, 
m­pšg
: 
Seq
[
Add»ssM­EÁry
], 
Ïb–
: 
SŒšg
è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[Named] {

54 
def
 
	`du¶iÿ‹
(
n
: 
Named
èğ
this
.
	`cİy
(n)

56 
def
 
toUVM
: 
SŒšg
 =

57 
s
"// Instance Name: ${target.serialize}\n" +

58 
m­pšg
.
	`m­
(
_
.
¿nge
.
toUVM
).
	`mkSŒšg
("\n")

60 
def
 
toJSON
: 
SŒšg
 =

61 
s
"""{\À "
$
{
Ïb–
}": [\n""" +

62 
m­pšg
.
	`m­
(
_
.
¿nge
.
toJSON
).
	`mkSŒšg
(",\n") +

64 
	}
}

67 
şass
 
	$TLToAXI4IdM­AÂÙ©iÚ
(
rg‘
: 
Named
, 
m­pšg
: 
Seq
[
TLToAXI4IdM­EÁry
]è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[Named] {

68 
def
 
	`du¶iÿ‹
(
n
: 
Named
èğ
this
.
	`cİy
(n)

69 
	}
}

72 
şass
 
	$R‘imeModuËAÂÙ©iÚ
(
rg‘
: 
ModuËName
è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[ModuleName] {

73 
def
 
	`du¶iÿ‹
(
n
: 
ModuËName
èğ
this
.
	`cİy
(n)

74 
	}
}

77 
şass
 
	$SÏveAdd»ssM­Chi£lAÂÙ©iÚ
(

78 
rg‘
: 
In¡ªûId
,

79 
add»s£s
: 
Seq
[
Add»ssS‘
],

80 
³rms
: 
ResourûP”missiÚs
è
ex‹nds
 
Chi£lAÂÙ©iÚ
 {

81 
´iv©e
 
v®
 
¿nge
 = 
Add»ssRªge
.
	`äomS‘s
(
add»s£s
)

82 
def
 
toFœ¹l
 = 
	`Add»ssM­AÂÙ©iÚ
(

83 
rg‘
 =¬g‘.
toNamed
,

84 
m­pšg
 = 
¿nge
.
m­
 { 
r
 => 
	`Add»ssM­EÁry
Ô, 
³rms
, 
N
) },

85 
Ïb–
 = "slaves")

86 
	}
}

89 
şass
 
	$TİLev–PÜtAÂÙ©iÚ
(

90 
rg‘
: 
CompÚ’tName
,

91 
´ÙocŞ
: 
SŒšg
,

92 
gs
: 
Seq
[
SŒšg
],

93 
Çmes
: 
Seq
[
SŒšg
],

94 
width
: 
IÁ
,

95 
add»ss
: 
Seq
[
Add»ssS‘
]è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[
CompÚ’tName
] {

96 
def
 
	`du¶iÿ‹
(
n
: 
CompÚ’tName
): 
TİLev–PÜtAÂÙ©iÚ
 = 
this
.
	`cİy
(n)

97 
	}
}

100 
şass
 
	$Re£tVeùÜAÂÙ©iÚ
(
rg‘
: 
Named
, 
»£tVec
: 
BigIÁ
è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[Named] {

101 
def
 
	`du¶iÿ‹
(
n
: 
Named
): 
Re£tVeùÜAÂÙ©iÚ
 = 
this
.
	`cİy
(n)

102 
	}
}

105 
objeù
 
AÂÙ©ed
 {

107 
def
 
¤ams
(

108 
compÚ’t
: 
In¡ªûId
,

109 
Çme
: 
SŒšg
,

110 
add»ss_width
: 
IÁ
,

111 
d©a_width
: 
IÁ
,

112 
d•th
: 
IÁ
,

113 
desütiÚ
: 
SŒšg
,

114 
wr™e_mask_g¿nuÏr™y
: 
IÁ
): 
Un™
 = {

115 
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 {
def
 
toFœ¹l
: 
AÂÙ©iÚ
 = 
SRAMAÂÙ©iÚ
(

116 
compÚ’t
.
toNamed
,

117 
add»ss_width
 =‡ddress_width,

118 
Çme
 =‚ame,

119 
d©a_width
 = data_width,

120 
d•th
 = depth,

121 
desütiÚ
 = description,

122 
wr™e_mask_g¿nuÏr™y
 = write_mask_granularity

125 
def
 
š‹¼u±s
(
compÚ’t
: 
In¡ªûId
, 
Çme
: 
SŒšg
, iÁ”ru±s: 
Seq
[
IÁ
]): 
Un™
 = {

126 
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 {
def
 
toFœ¹l
: 
AÂÙ©iÚ
 = 
IÁ”ru±sPÜtAÂÙ©iÚ
(

127 
compÚ’t
.
toNamed
,

128 
Çme
,

129 
š‹¼u±s


133 
def
 
»£tVeùÜ
(
compÚ’t
: 
In¡ªûId
, 
»£tVec
: 
BigIÁ
): 
Un™
 = {

134 
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 {
def
 
toFœ¹l
: 
AÂÙ©iÚ
 = 
Re£tVeùÜAÂÙ©iÚ
(
compÚ’t
.
toNamed
, 
»£tVec
)})

137 
def
 
cÚ¡ªts
(
compÚ’t
: 
In¡ªûId
, 
xL’
: 
IÁ
): 
Un™
 = {

138 
ªnÙ©e
(
Glob®CÚ¡ªtsChi£lAÂÙ©iÚ
(
compÚ’t
, 
xL’
 ))

141 
def
 
·¿ms
[
T
 <: 
Produù
](
compÚ’t
: 
In¡ªûId
, 
	g·¿ms
: T): T = {

142 
ªnÙ©e
(
P¬amsChi£lAÂÙ©iÚ
(
compÚ’t
, 
·¿ms
))

143 
·¿ms


146 
def
 
add»ssM­pšg
(
compÚ’t
: 
In¡ªûId
, 
m­pšg
: 
Seq
[
Add»ssM­EÁry
]): Seq[AddressMapEntry] = {

147 
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 { 
def
 
toFœ¹l
 = 
Add»ssM­AÂÙ©iÚ
(
compÚ’t
.
toNamed
, 
m­pšg
, "mapping") })

148 
	gm­pšg


151 
def
 
idM­pšg
(
compÚ’t
: 
In¡ªûId
, 
m­pšg
: 
Seq
[
TLToAXI4IdM­EÁry
]): Seq[TLToAXI4IdMapEntry] = {

152 
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 { 
def
 
toFœ¹l
 = 
TLToAXI4IdM­AÂÙ©iÚ
(
compÚ’t
.
toNamed
, 
m­pšg
) })

153 
	gm­pšg


156 
def
 
	gpÜt
[
T
 <: 
D©a
](

157 
d©a
: 
T
,

158 
	g´ÙocŞ
: 
SŒšg
,

159 
	ggs
: 
Seq
[
SŒšg
],

160 
	gÇmes
: 
Seq
[
SŒšg
],

161 
	gwidth
: 
IÁ
,

162 
	gadd»ss
: 
Seq
[
Add»ssS‘
] = 
N
): 
T
 = {

163 
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 { 
def
 
toFœ¹l
 = 
TİLev–PÜtAÂÙ©iÚ
(
d©a
.
toNamed
, 
´ÙocŞ
, 
gs
, 
Çmes
, 
width
, 
add»ss
) })

164 
	gd©a


169 
Œa™
 
	gDÚtTouch
 { 
	g£lf
: 
RawModuË
 =>

172 
def
 
dÚtTouch
(
d©a
: 
D©a
): 
Un™
 = d©¨
m©ch
 {

173 
agg
: 
Agg»g©e
 =>‡gg.
g‘EËm’ts
.
fÜ—ch
(
dÚtTouch
)

174 
–t
: 
EËm’t
 => 
chi£l3
.
cÜe
.
dÚtTouch
(elt)

182 
def
 
dÚtTouchPÜts
(): 
this
.
ty³
 = {

183 
£lf
.
g‘ModuËPÜts
.
fÜ—ch
(
dÚtTouch
(
_
))

184 
£lf


187 
def
 
dÚtTouchPÜtsExû±
(
f
: 
D©a
 => 
BoŞ—n
): 
this
.
ty³
 = {

188 
£lf
.
g‘ModuËPÜts
.
f‹rNÙ
(
f
).
fÜ—ch
(
dÚtTouch
(
_
))

189 
£lf


194 
Œa™
 
ShouldBeR‘imed
 { 
£lf
: 
RawModuË
 =>

195 
chi£l3
.
ex³rim’l
.
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 { 
def
 
toFœ¹l
: 
R‘imeModuËAÂÙ©iÚ
 = R‘imeModuËAÂÙ©iÚ(
£lf
.
toNamed
) })

198 
şass
 
	$RegF›ldDescM­pšgAÂÙ©iÚ
(

199 
rg‘
: 
ModuËName
,

200 
»gM­pšgS”
: 
Regi¡”sS”
è
ex‹nds
 
SšgËT¬g‘AÂÙ©iÚ
[
ModuËName
] {

201 
def
 
	`du¶iÿ‹
(
n
: 
ModuËName
): 
RegF›ldDescM­pšgAÂÙ©iÚ
 = 
this
.
	`cİy
(
rg‘
 =‚)

202 
	}
}

204 
objeù
 
IÁ”ru±sPÜtAÂÙ©iÚ
 {

205 
v®
 
GLOBAL_EXTERNAL_INTERRUPTS
 = "global-external-interrupts"

206 
v®
 
LOCAL_EXTERNAL_INTERRUPTS
 = "local-external-interrupts"

207 
v®
 
LOCAL_INTERRUPTS_STARTING_NUMBER
 = 16

212 
objeù
 
G’RegDescsAÂo
 {

214 
def
 
makeRegM­pšgS”
(

215 
¿wModuË
: 
RawModuË
,

216 
moduËName
: 
SŒšg
,

217 
ba£Add»ss
: 
BigIÁ
,

218 
width
: 
IÁ
,

219 
by‹Off£t
: 
IÁ
,

220 
b™Off£t
: 
IÁ
,

221 
»gF›ld
: 
RegF›ld
): 
RegF›ldDescS”
 = {

223 
v®
 
ªÚRegF›ldName
 = 
s
"unnamedRegField${byteOffset.toHexString}_${bitOffset}"

224 
v®
 
£ËùedRegF›ldName
 = 
»gF›ld
.
desc
.
m­
(
_
.
Çme
).
g‘OrEl£
(
ªÚRegF›ldName
)

226 
v®
 
m­
 = 
M­
[
BigIÁ
, (
SŒšg
, String)]()

234 
v®
 
	gdesc
 = 
»gF›ld
.
desc


236 
v®
 
»gF›ldDescS”
 = 
RegF›ldDescS”
(

237 
by‹Off£t
 = 
s
"0x${byteOffset.toInt.toHexString}",

238 
b™Off£t
 = bitOffset,

239 
b™Width
 = 
width
,

240 
Çme
 = 
£ËùedRegF›ldName
,

241 
desc
 = desc.
m­
 {
_
.desc}.
g‘OrEl£
("None"),

242 
group
 = 
desc
.
m­
 {
_
.group.
g‘OrEl£
("None")}.getOrElse("None"),

243 
groupDesc
 = 
desc
.
m­
 {
_
.groupDesc.
g‘OrEl£
("None")}.getOrElse("None"),

244 
acûssTy³
 = 
desc
.
m­
 {
_
.
acûss
.
toSŒšg
}.
g‘OrEl£
("None"),

245 
wrTy³
 = 
desc
.
m­
(
_
.wrTy³.
toSŒšg
).
g‘OrEl£
("None"),

246 
rdAùiÚ
 = 
desc
.
m­
(
_
.rdAùiÚ.
toSŒšg
).
g‘OrEl£
("None"),

247 vŞ©ğ
desc
.
m­
(
_
.vŞ©e).
g‘OrEl£
(
çl£
),

248 
hasRe£t
 = 
desc
.
m­
 {
_
.
»£t
 !ğ
NÚe
 }.
g‘OrEl£
(
çl£
),

249 
»£tV®ue
 = 
desc
.
m­
{
_
.
»£t
.
g‘OrEl£
(
BigIÁ
(0))}.getOrElse(BigInt(0)),

250 
’um”©iÚs
 = 
m­


253 
»gF›ldDescS”


257 
def
 
ªno
(

258 
¿wModuË
: 
RawModuË
,

259 
ba£Add»ss
: 
BigIÁ
,

260 
m­pšg
: 
RegF›ld
.
M­
*): 
Seq
[RegField.Map] = {

262 
v®
 
moduËName
 = 
¿wModuË
.
Çme


263 
v®
 
ba£Hex
 = 
s
"0x${baseAddress.toInt.toHexString}"

264 
v®
 
di¥ÏyName
 = 
s
"${moduleName}.${baseHex}"

266 
v®
 
»gF›ldS”s
 = 
m­pšg
.
æ©M­
 {

267 (
by‹Off£t
, 
£q
) =>

268 
£q
.
m­
(
_
.
width
).
sÿnLeá
(0)(_ + _).
z
(£q).m­ { (
b™Off£t
, 
»gF›ld
) =>

269 
makeRegM­pšgS”
(

270 
¿wModuË
,

271 
moduËName
,

272 
ba£Add»ss
,

273 
»gF›ld
.
width
,

274 
by‹Off£t
,

275 
b™Off£t
,

276 
»gF›ld


281 
v®
 
	g»gi¡”sS”
 = 
Regi¡”sS”
(

282 
di¥ÏyName
 = 
moduËName
,

283 
deviûName
 = 
moduËName
,

284 
ba£Add»ss
 = baseAddress,

285 
»gF›lds
 = 
»gF›ldS”s


289 
ªnÙ©e
(
Ãw
 
Chi£lAÂÙ©iÚ
 { 
def
 
toFœ¹l
 = 
RegF›ldDescM­pšgAÂÙ©iÚ
(
¿wModuË
.
toNamed
, 
»gi¡”sS”
) })

291 
	gm­pšg


295 
def
 
£rŸlize
(
ba£
: 
BigIÁ
, 
Çme
: 
SŒšg
, 
m­pšg
: 
RegF›ld
.
M­
*): String = {

298 
v®
 
»gDescs
 = 
m­pšg
.
æ©M­
 { (
by‹
, 
£q
) =>

299 
£q
.
m­
(
_
.
width
).
sÿnLeá
(0)(_ + _).
z
(£q).m­ { (
b™
, 
f
) =>

300 
v®
 
ªÚName
 = 
s
"unnamedRegField${byte.toHexString}_${bit}"

301 (
f
.
desc
.
m­
{ 
_
.
Çme
}.
g‘OrEl£
(
ªÚName
)è-> f.
toJsÚ
(
by‹
, 
b™
)

305 
´‘ty
(
»nd”
(

307 ("di¥ÏyName" -> 
Çme
) ~

308 ("ba£Add»ss" -> 
s
"0x${base.toInt.toHexString}") ~

309 ("»gf›lds" -> 
»gDescs
)))))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Arbiters.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


10 
ab¡¿ù
 
şass
 
	gH–ÏLockšgArb™”
[
T
 <: 
D©a
](
typ
: T, 
	g¬bN
: 
IÁ
, 
	g¼
: 
BoŞ—n
 = 
çl£
)

11 
ex‹nds
 
ModuË
 {

13 
v®
 
io
 = 
Ãw
 
BundË
 {

14 
v®
 
š
 = 
Vec
(
¬bN
, 
Decou¶ed
(
typ
.
şÚeTy³
)).
æ


15 
v®
 
	gout
 = 
Decou¶ed
(
typ
.
şÚeTy³
)

18 
def
 
	grÙ©eLeá
[
T
 <: 
D©a
](
nÜm
: 
Vec
[T], 
	grÙ
: 
UIÁ
): Vec[T] = {

19 
v®
 
n
 = 
nÜm
.
size


20 
Vec
.
buÏ‹
(
n
è{ 
i
 =>

21 
Mux
(
rÙ
 < 
UIÁ
(
n
 - 
i
), 
nÜm
(UInt(i) +„ot),‚orm(rot - UInt(n - i)))

25 
v®
 
	glockIdx
 = 
Reg
(
š™
 = 
UIÁ
(0, 
log2Up
(
¬bN
)))

26 
v®
 
	glocked
 = 
Reg
(
š™
 = 
BoŞ
(
çl£
))

28 
v®
 
choiû
 = ià(
¼
) {

29 
PriÜ™yMux
(

30 
rÙ©eLeá
(
Vec
(
io
.
š
.
m­
(
_
.
v®id
)), 
lockIdx
 + 
UIÁ
(1)),

31 
rÙ©eLeá
(
Vec
((0 
uÁ
 
¬bN
).
m­
(
UIÁ
(
_
))), 
lockIdx
 + UInt(1)))

33 
PriÜ™yEncod”
(
io
.
š
.
m­
(
_
.
v®id
))

36 
v®
 
cho£n
 = 
Mux
(
locked
, 
lockIdx
, 
choiû
)

38 
	gi
 <- 0 
uÁ
 
	g¬bN
) {

39 
	gio
.
š
(
i
).
	g»ady
 :ğ
io
.
out
.
»ady
 && 
cho£n
 ==ğ
UIÁ
(i)

42 
io
.
out
.
v®id
 :ğio.
š
(
cho£n
).valid

43 
io
.
out
.
b™s
 :ğio.
š
(
cho£n
).bits

48 
şass
 
H–ÏP“kšgArb™”
[
T
 <: 
D©a
](

49 
typ
: 
T
, 
	g¬bN
: 
IÁ
,

50 
	gÿnUÆock
: 
T
 => 
BoŞ
,

51 
	gÃedsLock
: 
O±iÚ
[
T
 => 
BoŞ
] = 
NÚe
,

52 
	g¼
: 
BoŞ—n
 = 
çl£
)

53 
ex‹nds
 
	$H–ÏLockšgArb™”
(
typ
, 
¬bN
, 
¼
) {

55 
def
 
	`»®N“dsLock
(
d©a
: 
T
): 
BoŞ
 =

56 
ÃedsLock
.
	`m­
(
	`_
(
d©a
)).
	`g‘OrEl£
(
	`BoŞ
(
Œue
))

58 
	`wh’
 (
io
.
out
.
	`fœe
()) {

59 
	`wh’
 (!
locked
 && 
	`»®N“dsLock
(
io
.
out
.
b™s
)) {

60 
lockIdx
 :ğ
choiû


61 
locked
 :ğ
	`BoŞ
(
Œue
)

64 
	`wh’
 (
	`ÿnUÆock
(
io
.
out
.
b™s
)) {

65 
locked
 :ğ
	`BoŞ
(
çl£
)

68 
	}
}

71 
şass
 
H–ÏCouÁšgArb™”
[
T
 <: 
D©a
](

72 
typ
: 
T
, 
	g¬bN
: 
IÁ
, 
	gcouÁ
: Int,

73 
v®
 
	gÃedsLock
: 
O±iÚ
[
T
 => 
BoŞ
] = 
NÚe
,

74 
	g¼
: 
BoŞ—n
 = 
çl£
)

75 
ex‹nds
 
	$H–ÏLockšgArb™”
(
typ
, 
¬bN
, 
¼
) {

77 
def
 
	`»®N“dsLock
(
d©a
: 
T
): 
BoŞ
 =

78 
ÃedsLock
.
	`m­
(
	`_
(
d©a
)).
	`g‘OrEl£
(
	`BoŞ
(
Œue
))

81 
	`»quœe
(
couÁ
 > 1, "CountingArbiter cannot have count <= 1")

83 
v®
 
lock_ùr
 = 
	`CouÁ”
(
couÁ
)

85 
	`wh’
 (
io
.
out
.
	`fœe
()) {

86 
	`wh’
 (!
locked
 && 
	`»®N“dsLock
(
io
.
out
.
b™s
)) {

87 
lockIdx
 :ğ
choiû


88 
locked
 :ğ
	`BoŞ
(
Œue
)

89 
lock_ùr
.
	`šc
()

92 
	`wh’
 (
locked
) {

93 
	`wh’
 (
lock_ùr
.
	`šc
()è{ 
locked
 :ğ
	`BoŞ
(
çl£
) }

96 
	}
}

99 
şass
 
InOrd”Arb™”
[
T
 <: 
D©a
, 
U
 <: D©a](
»qTyp
: T, 
	g»¥Typ
: U, 
	gn
: 
IÁ
)

100 (
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
ModuË
 {

101 
v®
 
io
 = 
Ãw
 
BundË
 {

102 
v®
 
š_»q
 = 
Vec
(
n
, 
Decou¶ed
(
»qTyp
)).
æ


103 
v®
 
	gš_»¥
 = 
Vec
(
n
, 
Decou¶ed
(
»¥Typ
))

104 
v®
 
	gout_»q
 = 
Decou¶ed
(
»qTyp
)

105 
v®
 
out_»¥
 = 
Decou¶ed
(
»¥Typ
).
æ


108 ià(
	gn
 > 1) {

109 
v®
 
	grou‹_q
 = 
ModuË
(
Ãw
 
Queue
(
UIÁ
(
width
 = 
log2Up
(
n
)), 2))

110 
v®
 
	g»q_¬b
 = 
ModuË
(
Ãw
 
RRArb™”
(
»qTyp
, 
n
))

111 
	g»q_¬b
.
	gio
.
	gš
 <> io.
š_»q


113 
v®
 
	g»q_h–³r
 = 
Decou¶edH–³r
(

114 
»q_¬b
.
io
.
out
.
v®id
,

115 
rou‹_q
.
io
.
’q
.
»ady
,

116 
io
.
out_»q
.
»ady
)

118 
	gio
.
	gout_»q
.
	gb™s
 :ğ
»q_¬b
.
io
.
out
.
b™s


119 
io
.
out_»q
.
v®id
 :ğ
»q_h–³r
.
fœe
(io.out_»q.
»ady
)

121 
rou‹_q
.
io
.
’q
.
b™s
 :ğ
»q_¬b
.io.
cho£n


122 
rou‹_q
.
io
.
’q
.
v®id
 :ğ
»q_h–³r
.
fœe
Ôou‹_q.io.’q.
»ady
)

124 
»q_¬b
.
io
.
out
.
»ady
 :ğ
»q_h–³r
.
fœe
Ôeq_¬b.io.out.
v®id
)

126 
v®
 
»¥_£l
 = 
rou‹_q
.
io
.
deq
.
b™s


127 
v®
 
»¥_»ady
 = 
io
.
š_»¥
(
»¥_£l
).
»ady


128 
v®
 
»¥_h–³r
 = 
Decou¶edH–³r
(

129 
»¥_»ady
,

130 
rou‹_q
.
io
.
deq
.
v®id
,

131 
io
.
out_»¥
.
v®id
)

133 
v®
 
	g»¥_v®id
 = 
»¥_h–³r
.
fœe
(
»¥_»ady
)

134 
i
 <- 0 
uÁ
 
n
) {

135 
io
.
š_»¥
(
i
).
b™s
 :ğio.
out_»¥
.bits

136 
io
.
š_»¥
(
i
).
v®id
 :ğ
»¥_v®id
 && 
»¥_£l
 ==ğ
UIÁ
(i)

139 
rou‹_q
.
io
.
deq
.
»ady
 :ğ
»¥_h–³r
.
fœe
Ôou‹_q.io.deq.
v®id
)

140 
io
.
out_»¥
.
»ady
 :ğ
»¥_h–³r
.
fœe
(io.out_»¥.
v®id
)

142 
io
.
out_»q
 <> io.
š_»q
.
h—d


143 
io
.
š_»¥
.
h—d
 <> io.
out_»¥


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncQueue.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
_


8 
şass
 
	$AsyncQueueP¬ams
(

9 
d•th
: 
IÁ
 = 8,

10 
sync
: 
IÁ
 = 3,

11 
§ã
: 
BoŞ—n
 = 
Œue
,

14 
Ç¼ow
: 
BoŞ—n
 = 
çl£
)

19 
	`»quœe
 (
d•th
 > 0 && 
	`isPow2
(depth))

20 
	`»quœe
 (
sync
 >= 2)

22 
v®
 
b™s
 = 
	`log2Ce
(
d•th
)

23 
v®
 
wœes
 = ià(
Ç¼ow
è1 
d•th


24 
	}
}

26 
objeù
 
AsyncQueueP¬ams
 {

28 
def
 
sšgËtÚ
(
sync
: 
IÁ
 = 3, 
§ã
: 
BoŞ—n
 = 
Œue
èğ
AsyncQueueP¬ams
(1, sync, saã, 
çl£
)

31 şas 
	cAsyncBundËSaãty
 
ex‹nds
 
	mBundË
 {

32 
v®
 
	mridx_v®id
 = 
IÅut
 (
	$BoŞ
())

33 
v®
 
widx_v®id
 = 
	`Ouut
(
	$BoŞ
())

34 
v®
 
sourû_»£t_n
 = 
	`Ouut
(
	$BoŞ
())

35 
v®
 
sšk_»£t_n
 = 
	`IÅut
 (
	`BoŞ
())

38 
şass
 
AsyncBundË
[
T
 <: 
D©a
](
´iv©e
 
v®
 
g’
: T, v® 
·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
()è
ex‹nds
 
BundË
 {

40 
v®
 
mem
 = 
	`Ouut
(
	`Vec
(
·¿ms
.
wœes
, 
g’
))

41 
v®
 
ridx
 = 
	`IÅut
 (
	`UIÁ
((
·¿ms
.
b™s
+1).
W
))

42 
v®
 
widx
 = 
	`Ouut
(
	`UIÁ
((
·¿ms
.
b™s
+1).
W
))

43 
v®
 
šdex
 = 
·¿ms
.
Ç¼ow
.
	`İtiÚ
(
	`IÅut
(
	`UIÁ
Õ¬ams.
b™s
.
W
)))

46 
v®
 
§ã
 = 
·¿ms
.§ã.
	`İtiÚ
(
Ãw
 
AsyncBundËSaãty
)

47 
	}
}

49 
objeù
 
	gG¿yCouÁ”
 {

50 
def
 
­¶y
(
b™s
: 
IÁ
, 
šüem’t
: 
BoŞ
 = 
Œue
.
B
, 
ş—r
: BoŞ = 
çl£
.B, 
Çme
: 
SŒšg
 = "bš¬y"): 
UIÁ
 = {

51 
v®
 
šüem’‹d
 = 
Wœe
(
UIÁ
(
b™s
.
W
))

52 
v®
 
bš¬y
 = 
AsyncRe£tReg
(
šüem’‹d
, 
Çme
)

53 
	gšüem’‹d
 :ğ
Mux
(
ş—r
, 0.U, 
bš¬y
 + 
šüem’t
.
asUIÁ
())

54 
	gšüem’‹d
 ^ (incremented >> 1)

58 
şass
 
	$AsyncV®idSync
(
sync
: 
IÁ
, 
desc
: 
SŒšg
è
ex‹nds
 
ModuË
 {

59 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

60 
v®
 
š
 = 
	`IÅut
(
	`BoŞ
())

61 
v®
 
out
 = 
	`Ouut
(
	`BoŞ
())

63 
io
.
out
 :ğ
	`AsyncRe£tSynchrÚiz”ShiáReg
(io.
š
, 
sync
, 
	`Some
(
desc
))

64 
	}
}

66 
şass
 
	gAsyncQueueSourû
[
T
 <: 
D©a
](
g’
: T, 
	g·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
()è
ex‹nds
 
ModuË
 {

67 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

69 
v®
 
’q
 = 
	`Fl³d
(
	`Decou¶ed
(
g’
))

71 
v®
 
async
 = 
Ãw
 
	`AsyncBundË
(
g’
, 
·¿ms
)

74 
v®
 
b™s
 = 
·¿ms
.bits

75 
v®
 
sšk_»ady
 = 
	`WœeIn™
(
Œue
.
B
)

76 
v®
 
mem
 = 
	`Reg
(
	`Vec
(
·¿ms
.
d•th
, 
g’
))

77 
v®
 
widx
 = 
	`G¿yCouÁ”
(
b™s
+1, 
io
.
’q
.
	`fœe
(), !
sšk_»ady
, "widx_bin")

78 
v®
 
ridx
 = 
	`AsyncRe£tSynchrÚiz”ShiáReg
(
io
.
async
.ridx, 
·¿ms
.
sync
, 
	`Some
("ridx_gray"))

79 
v®
 
»ady
 = 
sšk_»ady
 && 
widx
 =/ğ(
ridx
 ^ (
·¿ms
.
d•th
 |…¬ams.d•th >> 1).
U
)

81 
v®
 
šdex
 = ià(
b™s
 =ğ0è0.U 
io
.
async
.
	`widx
(bits-1, 0) ^ (io.async.widx(bits, bits) << (bits-1))

82 
	`wh’
 (
io
.
’q
.
	`fœe
()è{ 
	`mem
(
šdex
è:ğio.’q.
b™s
 }

84 
v®
 
»ady_»g
 = 
	`AsyncRe£tReg
(
»ady
.
asUIÁ
, "ready_reg")(0)

85 
io
.
’q
.
»ady
 :ğ
»ady_»g
 && 
sšk_»ady


87 
v®
 
widx_»g
 = 
	`AsyncRe£tReg
(
widx
, "widx_gray")

88 
io
.
async
.
widx
 :ğ
widx_»g


90 
io
.
async
.
šdex
 
m©ch
 {

91 
	`Some
(
šdex
è=> 
io
.
async
.
	`mem
(0) := mem(index)

92 
NÚe
 => 
io
.
async
.
mem
 := mem

95 
io
.
async
.
§ã
.
fÜ—ch
 { 
sio
 =>

96 
v®
 
sourû_v®id
 = 
	`ModuË
(
Ãw
 
	`AsyncV®idSync
(
·¿ms
.
sync
+1, "source_valid"))

97 
v®
 
sšk_ex‹nd
 = 
	`ModuË
(
Ãw
 
	`AsyncV®idSync
(1, "sink_extend"))

98 
v®
 
sšk_v®id
 = 
	`ModuË
(
Ãw
 
	`AsyncV®idSync
(
·¿ms
.
sync
, "sink_valid"))

99 
sourû_v®id
.
»£t
 :ğ»£t.
toBoŞ
 || !
sio
.
sšk_»£t_n


100 
sšk_ex‹nd
 .
»£t
 :ğ»£t.
toBoŞ
 || !
sio
.
sšk_»£t_n


102 
sourû_v®id
.
io
.
š
 :ğ
Œue
.
B


103 
sio
.
widx_v®id
 :ğ
sourû_v®id
.
io
.
out


104 
sšk_ex‹nd
.
io
.
š
 :ğ
sio
.
ridx_v®id


105 
sšk_v®id
.
io
.
š
 :ğ
sšk_ex‹nd
.io.
out


106 
sšk_»ady
 :ğ
sšk_v®id
.
io
.
out


107 
sio
.
sourû_»£t_n
 :ğ!
»£t
.
toBoŞ


118 
	}
}

120 
şass
 
AsyncQueueSšk
[
T
 <: 
D©a
](
g’
: T, 
	g·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
()è
ex‹nds
 
ModuË
 {

121 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

123 
v®
 
deq
 = 
	`Decou¶ed
(
g’
)

125 
v®
 
async
 = 
	`Fl³d
(
Ãw
 
	`AsyncBundË
(
g’
, 
·¿ms
))

128 
v®
 
b™s
 = 
·¿ms
.bits

129 
v®
 
sourû_»ady
 = 
	`WœeIn™
(
Œue
.
B
)

130 
v®
 
ridx
 = 
	`G¿yCouÁ”
(
b™s
+1, 
io
.
deq
.
	`fœe
(), !
sourû_»ady
, "ridx_bin")

131 
v®
 
widx
 = 
	`AsyncRe£tSynchrÚiz”ShiáReg
(
io
.
async
.widx, 
·¿ms
.
sync
, 
	`Some
("widx_gray"))

132 
v®
 
v®id
 = 
sourû_»ady
 && 
ridx
 =/ğ
widx


138 
v®
 
šdex
 = ià(
b™s
 =ğ0è0.U 
	`ridx
(bits-1, 0) ^ (ridx(bits, bits) << (bits-1))

139 
io
.
async
.
šdex
.
fÜ—ch
 { 
_
 := index }

144 
v®
 
deq_b™s_nxt
 = 
	`Mux
(
v®id
, 
io
.
async
.
	`mem
(ià(
·¿ms
.
Ç¼ow
è0.U 
šdex
), io.
deq
.
b™s
)

145 
io
.
deq
.
b™s
 :ğ
	`SynchrÚiz”ShiáReg
(
deq_b™s_nxt
, 
sync
 = 1, 
Çme
 = 
	`Some
("deq_bits_reg"))

147 
v®
 
v®id_»g
 = 
	`AsyncRe£tReg
(
v®id
.
asUIÁ
, "valid_reg")(0)

148 
io
.
deq
.
v®id
 :ğ
v®id_»g
 && 
sourû_»ady


150 
v®
 
ridx_»g
 = 
	`AsyncRe£tReg
(
ridx
, "ridx_gray")

151 
io
.
async
.
ridx
 :ğ
ridx_»g


153 
io
.
async
.
§ã
.
fÜ—ch
 { 
sio
 =>

154 
v®
 
sšk_v®id
 = 
	`ModuË
(
Ãw
 
	`AsyncV®idSync
(
·¿ms
.
sync
+1, "sink_valid"))

155 
v®
 
sourû_ex‹nd
 = 
	`ModuË
(
Ãw
 
	`AsyncV®idSync
(1, "source_extend"))

156 
v®
 
sourû_v®id
 = 
	`ModuË
(
Ãw
 
	`AsyncV®idSync
(
·¿ms
.
sync
, "source_valid"))

157 
sšk_v®id
 .
»£t
 :ğ»£t.
toBoŞ
 || !
sio
.
sourû_»£t_n


158 
sourû_ex‹nd
.
»£t
 :ğ»£t.
toBoŞ
 || !
sio
.
sourû_»£t_n


160 
sšk_v®id
.
io
.
š
 :ğ
Œue
.
B


161 
sio
.
ridx_v®id
 :ğ
sšk_v®id
.
io
.
out


162 
sourû_ex‹nd
.
io
.
š
 :ğ
sio
.
widx_v®id


163 
sourû_v®id
.
io
.
š
 :ğ
sourû_ex‹nd
.io.
out


164 
sourû_»ady
 :ğ
sourû_v®id
.
io
.
out


165 
sio
.
sšk_»£t_n
 :ğ!
»£t
.
toBoŞ


167 
v®
 
»£t_ªd_ex‹nd
 = !
sourû_»ady
 || !
sio
.
sourû_»£t_n
 || 
»£t
.
toBoŞ


168 
v®
 
»£t_ªd_ex‹nd_´ev
 = 
	`RegNext
(
»£t_ªd_ex‹nd
, 
Œue
.
B
)

169 
v®
 
»£t_ri£
 = !
»£t_ªd_ex‹nd_´ev
 && 
»£t_ªd_ex‹nd


170 
v®
 
´ev_idx_m©ch
 = 
	`AsyncRe£tReg
(
upd©eD©a
=(
io
.
async
.
widx
===io.async.
ridx
), 
»£tD©a
=0)

176 
	}
}

178 
objeù
 
	gFromAsyncBundË


181 
def
 
	g­¶y
[
T
 <: 
D©a
](
x
: 
AsyncBundË
[T]): 
Decou¶edIO
[T] = 
­¶y
(x, x.
·¿ms
.
sync
)

182 
def
 
	g­¶y
[
T
 <: 
D©a
](
x
: 
AsyncBundË
[T], 
	gsync
: 
IÁ
): 
Decou¶edIO
[T] = {

183 
v®
 
sšk
 = 
ModuË
(
Ãw
 
AsyncQueueSšk
(
chi£lTy³Of
(
x
.
mem
(0)), x.
·¿ms
.
cİy
(
sync
 = sync)))

184 
sšk
.
io
.
async
 <> 
x


185 
sšk
.
io
.
deq


189 
objeù
 
	gToAsyncBundË


191 
def
 
	g­¶y
[
T
 <: 
D©a
](
x
: 
R—dyV®idIO
[T], 
	g·¿ms
: 
AsyncQueueP¬ams
 = AsyncQueueP¬ams()): 
AsyncBundË
[T] = {

192 
v®
 
sourû
 = 
ModuË
(
Ãw
 
AsyncQueueSourû
(
chi£lTy³Of
(
x
.
b™s
), 
·¿ms
))

193 
	gsourû
.
	gio
.
	g’q
 <> 
x


194 
	gsourû
.
	gio
.
	gasync


198 
şass
 
	gAsyncQueue
[
T
 <: 
D©a
](
g’
: T, 
	g·¿ms
: 
AsyncQueueP¬ams
 = 
	$AsyncQueueP¬ams
()è
ex‹nds
 
Crossšg
[
T
] {

199 
v®
 
io
 = 
	`IO
(
Ãw
 
	`CrossšgIO
(
g’
))

200 
v®
 
sourû
 = 
	`ModuË
(
Ãw
 
	`AsyncQueueSourû
(
g’
, 
·¿ms
))

201 
v®
 
sšk
 = 
	`ModuË
(
Ãw
 
	`AsyncQueueSšk
 (
g’
, 
·¿ms
))

203 
sourû
.
şock
 :ğ
io
.
’q_şock


204 
sourû
.
»£t
 :ğ
io
.
’q_»£t


205 
sšk
.
şock
 :ğ
io
.
deq_şock


206 
sšk
.
»£t
 :ğ
io
.
deq_»£t


208 
sourû
.
io
.
’q
 <> io.enq

209 
io
.
deq
 <> 
sšk
.io.deq

210 
sšk
.
io
.
async
 <> 
sourû
.io.async

211 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncResetReg.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
HasBÏckBoxResourû


7 
impÜt
 
	gchi£l3
.
	gcÜe
.
IÁP¬am


35 
şass
 
	$AsyncRe£tReg
(
»£tV®ue
: 
IÁ
 = 0)

36 
ex‹nds
 
	`BÏckBox
(
	`M­
("RESET_VALUE" -> 
	$IÁP¬am
(
»£tV®ue
))è
w™h
 
HasBÏckBoxResourû


38 
v®
 
io
 = 
Ãw
 
BundË
 {

39 
v®
 
d
 = 
	`BoŞ
(
INPUT
)

40 
v®
 
q
 = 
	`BoŞ
(
OUTPUT
)

41 
v®
 
’
 = 
	`BoŞ
(
INPUT
)

43 
v®
 
şk
 = 
	`Clock
(
INPUT
)

44 
v®
 
r¡
 = 
	`BoŞ
(
INPUT
)

47 
	`£tResourû
("/vsrc/AsyncResetReg.v")

48 
	}
}

50 şas 
	cSim¶eRegIO
(
v®
 
w
: 
IÁ
è
ex‹nds
 
BundË
{

51 
v®
 
d
 = 
	$UIÁ
(
INPUT
, 
width
 = 
w
)

52 
v®
 
q
 = 
	$UIÁ
(
OUTPUT
, 
width
 = 
w
)

53 
v®
 
’
 = 
	`BoŞ
(
INPUT
)

56 
şass
 
	$AsyncRe£tRegVec
(
v®
 
w
: 
IÁ
, v® 
š™
: 
BigIÁ
è
ex‹nds
 
ModuË
 {

57 
v®
 
io
 = 
Ãw
 
	`Sim¶eRegIO
(
w
)

59 
v®
 
async_»gs
 = 
Li¡
.
	`buÏ‹
(
w
è{ 
idx
 =>

60 
v®
 
Ú
 = ià(
š™
.
	`‹¡B™
(
idx
)) 1 0

61 
	`ModuË
(
Ãw
 
	`AsyncRe£tReg
(
Ú
))

64 
v®
 
q
 = (
»g
, 
idx
è<- 
async_»gs
.
zW™hIndex
è
y›ld
 {

65 
»g
.
io
.
şk
 :ğ
şock


66 
»g
.
io
.
r¡
 :ğ
»£t


67 
»g
.
io
.
d
 :ğio.
	`d
(
idx
)

68 
»g
.
io
.
’
 := io.en

69 
»g
.
	`sugge¡Name
(
s
"reg_$idx")

70 
»g
.
io
.
q


73 
io
.
q
 :ğq.
asUIÁ


75 
ov”ride
 
def
 
desœedName
 = 
s
"AsyncResetRegVec_w${w}_i${init}"

77 
	}
}

79 
objeù
 
AsyncRe£tReg
 {

81 
def
 
­¶y
(
d
: 
BoŞ
, 
şk
: 
Clock
, 
r¡
: BoŞ, 
š™
: 
BoŞ—n
, 
Çme
: 
O±iÚ
[
SŒšg
]): Bool = {

82 
v®
 
»g
 = 
ModuË
(
Ãw
 
AsyncRe£tReg
(ià(
š™
) 1 0))

83 
»g
.
io
.
d
 := d

84 
»g
.
io
.
şk
 := clk

85 
»g
.
io
.
r¡
 :=„st

86 
»g
.
io
.
’
 :ğ
BoŞ
(
Œue
)

87 
Çme
.
fÜ—ch
(
»g
.
sugge¡Name
(
_
))

88 
»g
.
io
.
q


91 
def
 
­¶y
(
d
: 
BoŞ
, 
şk
: 
Clock
, 
r¡
: BoŞ): BoŞ =‡µly(d, clk,„¡, 
çl£
, 
NÚe
)

92 
def
 
­¶y
(
d
: 
BoŞ
, 
şk
: 
Clock
, 
r¡
: BoŞ, 
Çme
: 
SŒšg
): BoŞ =‡µly(d, clk,„¡, 
çl£
, 
Some
(name))

95 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
, 
»£tD©a
: 
BigIÁ
, 
’abË
: 
BoŞ
, 
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): UInt = {

96 
v®
 
w
 = 
upd©eD©a
.
g‘Width
 
max
 
»£tD©a
.
b™L’gth


97 
v®
 
»g
 = 
ModuË
(
Ãw
 
AsyncRe£tRegVec
(
w
, 
»£tD©a
))

98 
	gÇme
.
fÜ—ch
(
»g
.
sugge¡Name
(
_
))

99 
	g»g
.
	gio
.
	gd
 :ğ
upd©eD©a


100 
»g
.
io
.
’
 :ğ
’abË


101 
»g
.
io
.
q


103 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
, 
»£tD©a
: 
BigIÁ
, 
’abË
: 
BoŞ
, 
Çme
: 
SŒšg
): UInt =‡pply(updateData,

104 
»£tD©a
, 
’abË
, 
Some
(
Çme
))

107 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
, 
»£tD©a
: 
BigIÁ
): UIÁ =‡µly(upd©eD©a,„e£tD©a, 
’abË
=
BoŞ
(
Œue
))

108 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
, 
»£tD©a
: 
BigIÁ
, 
Çme
: 
SŒšg
): UIÁ =‡µly(upd©eD©a,„e£tD©a, 
’abË
=
BoŞ
(
Œue
), 
Some
(name))

110 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
, 
’abË
: 
BoŞ
): UIÁ =‡µly(upd©eD©a, 
»£tD©a
=
BigIÁ
(0),ƒnable)

111 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
, 
’abË
: 
BoŞ
, 
Çme
: 
SŒšg
): UIÁ =‡µly(upd©eD©a, 
»£tD©a
=
BigIÁ
(0),ƒÇbË, 
Some
(name))

113 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
): UIÁ =‡µly(upd©eD©a, 
»£tD©a
=
BigIÁ
(0), 
’abË
=
BoŞ
(
Œue
))

114 
def
 
­¶y
(
upd©eD©a
: 
UIÁ
, 
Çme
:
SŒšg
): UIÁ =‡µly(upd©eD©a, 
»£tD©a
=
BigIÁ
(0), 
’abË
=
BoŞ
(
Œue
), 
Some
(name))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Broadcaster.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


11 
şass
 
	gBrßdÿ¡”
[
T
 <: 
D©a
](
typ
: T, 
	gn
: 
IÁ
è
ex‹nds
 
ModuË
 {

12 
v®
 
io
 = 
Ãw
 
BundË
 {

13 
v®
 
š
 = 
Decou¶ed
(
typ
).
æ


14 
v®
 
out
 = 
Vec
(
n
, 
Decou¶ed
(
typ
))

17 
»quœe
 (
n
 > 0)

19 ià(
	gn
 == 1) {

20 
io
.
out
.
h—d
 <> io.
š


22 
v®
 
idx
 = 
Reg
(
š™
 = 
UIÁ
(0, 
log2Up
(
n
)))

23 
v®
 
	g§ve
 = 
Reg
(
typ
)

25 
io
.
out
.
h—d
.
v®id
 :ğ
idx
 ==ğ
UIÁ
(0è&& io.
š
.valid

26 
io
.
out
.
h—d
.
b™s
 :ğio.
š
.bits

27 
i
 <- 1 
uÁ
 
n
) {

28 
io
.
out
(
i
).
v®id
 :ğ
idx
 ==ğ
UIÁ
(i)

29 
io
.
out
(
i
).
b™s
 :ğ
§ve


31 
io
.
š
.
»ady
 :ğio.
out
.
h—d
.»ady && 
idx
 ==ğ
UIÁ
(0)

33 
wh’
 (
io
.
š
.
fœe
()è{ 
§ve
 :ğio.š.
b™s
 }

35 
wh’
 (
io
.
out
(
idx
).
fœe
()) {

36 
wh’
 (
idx
 ==ğ
UIÁ
(
n
 - 1)) { idx := UInt(0) }

37 .
Ùh”wi£
 { 
idx
 :ğidx + 
UIÁ
(1) }

42 
objeù
 
Brßdÿ¡”
 {

43 
def
 
­¶y
[
T
 <: 
D©a
](
š
: 
Decou¶edIO
[T], 
	gn
: 
IÁ
): 
Vec
[DecoupledIO[T]] = {

44 
v®
 
¥l™
 = 
ModuË
(
Ãw
 
Brßdÿ¡”
(
š
.
b™s
, 
n
))

45 
	g¥l™
.
	gio
.
	gš
 <> 
š


46 
	g¥l™
.
	gio
.
	gout


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/BundleMonitorKey.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


7 
impÜt
 
	gChi£l
.
_


12 
objeù
 
BundËMÚ™ÜKey
 
ex‹nds
 
	gF›ld
[
O±iÚ
[(
SŒšg
, 
BundË
è=> 
Un™
]] (
NÚe
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/CRC.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


7 
objeù
 
	gCRC


13 
def
 
­¶y
(
divisÜ
: 
BigIÁ
, 
cÛffic›Á
: 
UIÁ
, 
width
: 
IÁeg”
): UInt = {

14 
»quœe
 (
divisÜ
 > 0 && divisÜ.
‹¡B™
(0))

15 
»quœe
 (
width
 > 0)

16 
as£¹
 (
cÛffic›Á
 >> 
width
 ==ğ
UIÁ
(0))

17 
v®
 
n
 = 
log2FloÜ
(
divisÜ
)

18 
v®
 
m
 = 
width


19 ià(
m
 <ğ
n
è 
cÛffic›Á


22 
v®
 
¬¿y
 = 
A¼ay
.
buÏ‹
(
m
è{ 
BigIÁ
(1è<< 
_
 }

25 
i
 <- (
n
 
uÁ
 
m
).
»v”£


26 
j
 <- 0 
to
 
n


27 
divisÜ
.
‹¡B™
(
j
)

28 } 
¬¿y
(
i
-(
n
-
j
)) ^=‡rray(i)

30 
C©
(
Seq
.
buÏ‹
(
n
è{ 
i
 => (
UIÁ
(
¬¿y
(i)è& 
cÛffic›Á
).
xÜR
 } .
»v”£
)

34 
v®
 
CRC_16F_4_2
 = 
BigIÁ
(0x1a2eb)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockDivider.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
HasBÏckBoxResourû


7 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
w™hClock


18 şas 
	cClockDivid”2
 
ex‹nds
 
BÏckBox
 
w™h
 
	mHasBÏckBoxResourû
 {

19 
v®
 
	mio
 = 
Ãw
 
BundË
 {

20 
v®
 
şk_out
 = 
Clock
(
OUTPUT
)

21 
v®
 
şk_š
 = 
Clock
(
INPUT
)

24 
£tResourû
("/vsrc/ClockDivider2.v")

26 şas 
	cClockDivid”3
 
ex‹nds
 
BÏckBox
 
w™h
 
	mHasBÏckBoxResourû
 {

27 
v®
 
	mio
 = 
Ãw
 
BundË
 {

28 
v®
 
şk_out
 = 
Clock
(
OUTPUT
)

29 
v®
 
şk_š
 = 
Clock
(
INPUT
)

32 
£tResourû
("/vsrc/ClockDivider3.v")

37 şas 
	cPow2ClockDivid”
(
pow2
: 
IÁ
è
ex‹nds
 
ModuË
 {

38 
v®
 
io
 = 
Ãw
 
BundË
 {

39 
v®
 
şock_out
 = 
	`Clock
(
OUTPUT
)

42 ià(
pow2
 == 0) {

43 
io
.
şock_out
 :ğ
şock


44 
	}
} {

45 
v®
 
divid”s
 = 
Seq
.
fl
(
pow2
è{ 
ModuË
(
Ãw
 
ClockDivid”2
) }

47 
divid”s
.
š™
.
z
(divid”s.

).
m­
 { (
Ï¡
, 
Ãxt
) =>

48 
Ãxt
.
io
.
şk_š
 :ğ
Ï¡
.io.
şk_out


51 
divid”s
.
h—d
.
io
.
şk_š
 :ğ
şock


52 
io
.
şock_out
 :ğ
divid”s
.
Ï¡
.io.
şk_out


56 
objeù
 
Pow2ClockDivid”
 {

57 
def
 
­¶y
(
pow2
: 
IÁ
): 
Clock
 = 
ModuË
(
Ãw
 
Pow2ClockDivid”
Õow2)).
io
.
şock_out


58 
def
 
­¶y
(
şock_š
: 
Clock
, 
pow2
: 
IÁ
): Clock = 
w™hClock
(clock_in) {‡pply(pow2) }

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockGate.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.{
	gF›ld
, 
	gP¬am‘”s
}

8 
objeù
 
ClockG©eIm¶
 
ex‹nds
 
	gF›ld
[(è=> 
ClockG©e
]((è=> 
Ãw
 
EICG_w¿µ”
)

10 
ab¡¿ù
 cÏs 
	cClockG©e
 
ex‹nds
 
BÏckBox
 {

11 
v®
 
io
 = 
IO
(
Ãw
 
BundË
{

12 
v®
 
š
 = 
IÅut
(
Clock
())

13 
v®
 
’
 = 
IÅut
(
BoŞ
())

14 
v®
 
out
 = 
Ouut
(
Clock
())

18 
objeù
 
	gClockG©e
 {

19 
def
 
	g­¶y
[
T
 <: 
ClockG©e
](

20 
š
: 
Clock
,

21 
	g’
: 
BoŞ
,

22 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
Clock
 = {

23 
v®
 
cg
 = 
ModuË
(
p
(
ClockG©eIm¶
)())

24 
Çme
.
fÜ—ch
(
cg
.
sugge¡Name
(
_
))

25 
cg
.
io
.
š
 := in

26 
cg
.
io
.
’
 :=ƒn

27 
cg
.
io
.
out


30 
def
 
­¶y
[
T
 <: 
ClockG©e
](

31 
š
: 
Clock
,

32 
	g’
: 
BoŞ
,

33 
	gÇme
: 
SŒšg
)(
im¶ic™
 
p
: 
P¬am‘”s
): 
Clock
 =

34 
­¶y
(
š
, 
’
, 
Some
(
Çme
))

38 
şass
 
EICG_w¿µ”
 
ex‹nds
 
	gClockG©e


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Counters.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gsÿÏ
.
	gm©h
.
max


10 şas 
	cZCouÁ”
(
v®
 
n
: 
IÁ
) {

11 
v®
 
v®ue
 = 
	`Reg
(
š™
=
	`UIÁ
(0, 
	$log2Ce
(
n
)))

12 
def
 
	$šc
(): 
BoŞ
 = {

13 ià(
n
 =ğ1è
	`BoŞ
(
Œue
)

15 
v®
 
w¿p
 = 
v®ue
 ==ğ
	`UIÁ
(
n
-1)

16 
v®ue
 :ğ
	`Mux
(
	`BoŞ
(!
	`isPow2
(
n
)è&& 
w¿p
, 
	`UIÁ
(0), value + UInt(1))

17 
w¿p


20 
	}
}

22 
objeù
 
	gZCouÁ”
 {

23 
def
 
­¶y
(
n
: 
IÁ
èğ
Ãw
 
ZCouÁ”
(n)

24 
def
 
­¶y
(
cÚd
: 
BoŞ
, 
n
: 
IÁ
): (
UIÁ
, 
	gBoŞ
) = {

25 
v®
 
c
 = 
Ãw
 
ZCouÁ”
(
n
)

26 
v¬
 
w¿p
: 
BoŞ
 = 
nuÎ


27 
wh’
 (
cÚd
è{ 
w¿p
 = 
c
.
šc
() }

28 (
c
.
v®ue
, 
	gcÚd
 && 
	gw¿p
)

32 
objeù
 
	gTwoWayCouÁ”
 {

33 
def
 
­¶y
(
up
: 
BoŞ
, 
down
: BoŞ, 
max
: 
IÁ
): 
UIÁ
 = {

34 
v®
 
út
 = 
Reg
(
š™
 = 
UIÁ
(0, 
log2Up
(
max
+1)))

35 
wh’
 (
up
 && !
down
è{ 
	gút
 :ğ
út
 + 
UIÁ
(1) }

36 
wh’
 (
down
 && !
up
è{ 
út
 :ğúˆ- 
UIÁ
(1) }

37 
út


42 
şass
 
WideCouÁ”
(
width
: 
IÁ
, 
šc
: 
UIÁ
 = UIÁ(1), 
»£t
: 
BoŞ—n
 = 
Œue
)

44 
´iv©e
 
v®
 
isWide
 = 
width
 > 2*
šc
.
g‘Width


45 
´iv©e
 
v®
 
sm®lWidth
 = ià(
isWide
è
šc
.
g‘Width
 
max
 
log2Up
(
width
) width

46 
´iv©e
 
v®
 
sm®l
 = ià(
»£t
è
Reg
(
š™
=
UIÁ
(0, 
sm®lWidth
)èReg(UIÁ(
width
 = smallWidth))

47 
´iv©e
 
v®
 
ÃxtSm®l
 = 
sm®l
 +& 
šc


48 
sm®l
 :ğ
ÃxtSm®l


50 
´iv©e
 
v®
 
Ïrge
 = ià(
isWide
) {

51 
v®
 
r
 = ià(
»£t
è
Reg
(
š™
=
UIÁ
(0, 
width
 - 
sm®lWidth
)) Reg(UInt(width = width - smallWidth))

52 
wh’
 (
ÃxtSm®l
(
sm®lWidth
)è{ 
r
 :ğ¸+ 
UIÁ
(1) }

53 
r


54 } 
nuÎ


56 
v®
 
v®ue
 = ià(
isWide
è
C©
(
Ïrge
, 
sm®l
) small

57 
Ïzy
 
v®
 
	gÿ¼yOut
 = {

58 
v®
 
lo
 = (
sm®l
 ^ 
ÃxtSm®l
) >> 1

59 ià(!
isWide
è
lo
 {

60 
v®
 
hi
 = 
Mux
(
ÃxtSm®l
(
sm®lWidth
), 
Ïrge
 ^ (Ïrg+& 
UIÁ
(1)), UInt(0)) >> 1

61 
C©
(
hi
, 
lo
)

65 
	gdef
 :ğ(
x
: 
UIÁ
) = {

66 
sm®l
 :ğ
x


67 ià(
isWide
è
Ïrge
 :ğ
x
 >> 
sm®lWidth


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Crossing.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.{
	gDecou¶edIO
, 
	gDecou¶ed
, 
	gI¼evoÿbË
, 
	gI¼evoÿbËIO
, 
	gR—dyV®idIO
}

8 
şass
 
	gCrossšgIO
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË
 {

10 
v®
 
’q_şock
 = 
Clock
(
INPUT
)

11 
v®
 
’q_»£t
 = 
BoŞ
(
INPUT
)

12 
v®
 
’q
 = 
Decou¶ed
(
g’
).
æ


14 
v®
 
deq_şock
 = 
Clock
(
INPUT
)

15 
v®
 
deq_»£t
 = 
BoŞ
(
INPUT
)

16 
v®
 
deq
 = 
Decou¶ed
(
g’
)

19 
ab¡¿ù
 
şass
 
Crossšg
[
T
 <: 
D©a
] 
ex‹nds
 
ModuË
 {

20 
v®
 
io
: 
CrossšgIO
[
T
]

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/DescribedSRAM.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
In¡ªûId


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gut
.
AÂÙ©ed


8 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
Dlom©icSRAM


9 
impÜt
 
	gChi£l
.
_


10 
impÜt
 
	gchi£l3
.
SyncR—dMem


11 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gamba
.
	gaxi4
.
AXI4RAM


13 
impÜt
 
	gsÿÏ
.
	gm©h
.
log10


15 
objeù
 
	gDesüibedSRAM
 {

16 
def
 
	g­¶y
[
T
 <: 
D©a
](

17 
Çme
: 
SŒšg
,

18 
	gdesc
: 
SŒšg
,

19 
	gsize
: 
IÁ
,

20 
	gd©a
: 
T


21 ): 
SyncR—dMem
[
T
] = {

23 
v®
 
mem
 = 
SeqMem
(
size
, 
d©a
)

25 
	gmem
.
sugge¡Name
(
Çme
)

27 
v®
 
	gg¿nWidth
 = 
d©a
 
m©ch
 {

28 
v
: 
Vec
[
_
] => v.
h—d
.
g‘Width


29 
d
 => d.
g‘Width


32 
AÂÙ©ed
.
¤ams
(

33 
compÚ’t
 = 
mem
,

34 
Çme
 =‚ame,

35 
add»ss_width
 = 
log2Ce
(
size
),

36 
d©a_width
 = 
d©a
.
g‘Width
,

37 
d•th
 = 
size
,

38 
desütiÚ
 = 
desc
,

39 
wr™e_mask_g¿nuÏr™y
 = 
g¿nWidth
)

41 
mem


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ECC.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


7 
ab¡¿ù
 cÏs 
	cDecodšg


9 
def
 
	muncÜ»ùed
: 
UIÁ


10 
def
 
cÜ»ùed
: 
UIÁ


11 
def
 
cÜ»ùabË
: 
BoŞ


12 
def
 
uncÜ»ùabË
: 
BoŞ


13 
def
 
”rÜ
 = 
cÜ»ùabË
 || 
uncÜ»ùabË


16 
ab¡¿ù
 cÏs 
	cCode


18 
def
 
ÿnD‘eù
: 
BoŞ—n


19 
def
 
ÿnCÜ»ù
: 
BoŞ—n


21 
def
 
	$width
(
w0
: 
IÁ
): Int

27 
def
 
	`’code
(
x
: 
UIÁ
, 
poisÚ
: 
BoŞ
 = 
	$BoŞ
(
çl£
)): 
UIÁ


28 
def
 
	$decode
(
x
: 
UIÁ
): 
Decodšg


35 
def
 
	$swizzË
(
x
: 
UIÁ
): UInt

38 şas 
	cId’t™yCode
 
ex‹nds
 
Code


40 
def
 
ÿnD‘eù
 = 
çl£


41 
def
 
ÿnCÜ»ù
 = 
çl£


43 
def
 
	`width
(
w0
: 
IÁ
) = w0

44 
def
 
	`’code
(
x
: 
UIÁ
, 
poisÚ
: 
BoŞ
 = 
	`BoŞ
(
çl£
)) = {

45 
	`»quœe
 (
poisÚ
.
isL™
 &&…oisÚ.
l™V®ue
 == 0, "IdentityCode can‚ot be…oisoned")

46 
x


48 
def
 
	`swizzË
(
x
: 
UIÁ
) = x

49 
def
 
	`decode
(
y
: 
UIÁ
èğ
Ãw
 
Decodšg
 {

50 
def
 
uncÜ»ùed
 = 
y


51 
def
 
cÜ»ùed
 = 
y


52 
def
 
cÜ»ùabË
 = 
	`BoŞ
(
çl£
)

53 
def
 
uncÜ»ùabË
 = 
	`BoŞ
(
çl£
)

54 
	}
}

57 şas 
	cP¬™yCode
 
ex‹nds
 
Code


59 
def
 
ÿnD‘eù
 = 
Œue


60 
def
 
ÿnCÜ»ù
 = 
çl£


62 
def
 
width
(
w0
: 
IÁ
) = w0+1

63 
def
 
’code
(
x
: 
UIÁ
, 
poisÚ
: 
BoŞ
 = BoŞ(
çl£
)èğ
C©
(x.
xÜR
 ^…oison, x)

64 
def
 
swizzË
(
x
: 
UIÁ
èğ
	$C©
(
çl£
.
B
, 
x
)

65 
def
 
	`decode
(
y
: 
UIÁ
èğ
Ãw
 
Decodšg
 {

66 
v®
 
uncÜ»ùed
 = 
	`y
(
y
.
g‘Width
-2,0)

67 
v®
 
cÜ»ùed
 = 
uncÜ»ùed


68 
v®
 
cÜ»ùabË
 = 
	`BoŞ
(
çl£
)

69 
v®
 
uncÜ»ùabË
 = 
y
.
xÜR


71 
	}
}

73 şas 
	cSECCode
 
ex‹nds
 
	mCode


75 
def
 
	mÿnD‘eù
 = 
Œue


76 
def
 
ÿnCÜ»ù
 = 
Œue


80 
def
 
poisÚous
(
n
: 
IÁ
èğ!
isPow2
(n+1)

82 
def
 
width
(
k
: 
IÁ
) = {

83 
v®
 
m
 = 
log2FloÜ
(
k
) + 1

84 
k
 + 
m
 + (if((1 << m) < m+k+1) 1 0)

86 
def
 
swizzË
(
x
: 
UIÁ
) = {

87 
v®
 
k
 = 
x
.
g‘Width


88 
v®
 
n
 = 
width
(
k
)

89 
C©
(
UIÁ
(0, 
width
=
n
-
k
), 
x
)

100 
´iv©e
 
def
 
im¶
(
n
: 
IÁ
, 
k
: Int) = {

101 
»quœe
 (
n
 >ğ3 && 
k
 >ğ1 && !
isPow2
(n))

102 
v®
 
hamm2sys
 = 
IndexedSeq
.
buÏ‹
(
n
+1è{ 
i
 =>

103 ià(
i
 == 0) {

104 
n


105 } ià(
isPow2
(
i
)) {

106 
k
 + 
log2Ce
(
i
)

108 
i
 - 1 - 
log2Ce
(i)

111 
v®
 
sys2hamm
 = 
hamm2sys
.
zW™hIndex
.
sÜtBy
(
_
.
_1
).
m­
(_.
_2
).
toIndexedSeq


112 
def
 
syndrome
(
j
: 
IÁ
) = {

113 
v®
 
b™
 = 1 << 
j


114 
UIÁ
("b" + 
Seq
.
buÏ‹
(
n
è{ 
i
 =>

115 ià((
sys2hamm
(
i
è& 
b™
) != 0) "1" "0"

116 }.
»v”£
.
mkSŒšg
)

118 (
hamm2sys
, 
	gsys2hamm
, 
syndrome
 
	g_
)

121 
def
 
’code
(
x
: 
UIÁ
, 
poisÚ
: 
BoŞ
 = BoŞ(
çl£
)) = {

122 
v®
 
k
 = 
x
.
g‘Width


123 
v®
 
n
 = 
width
(
k
)

124 
v®
 (
_
, _, 
syndrome
èğ
im¶
(
n
, 
k
)

126 
»quœe
 ((
poisÚ
.
isL™
 &&…oisÚ.
l™V®ue
 =ğ0è|| 
poisÚous
(
n
), 
s
"SEC code of†ength ${n} cannot be…oisoned")

129 
v®
 
	gsyndromeUIÁ
 = 
Vec
.
buÏ‹
(
n
-
k
è{ 
j
 => (
syndrome
(j)(k-1, 0è& 
	gx
).
	gxÜR
 ^ 
	gpoisÚ
 }.
asUIÁ


130 
C©
(
syndromeUIÁ
, 
x
)

133 
def
 
decode
(
y
: 
UIÁ
èğ
Ãw
 
Decodšg
 {

134 
v®
 
n
 = 
y
.
g‘Width


135 
v®
 
k
 = 
n
 - 
log2Ce
(n)

136 
v®
 (
_
, 
sys2hamm
, 
syndrome
èğ
im¶
(
n
, 
k
)

138 
v®
 
	gsyndromeUIÁ
 = 
Vec
.
buÏ‹
(
n
-
k
è{ 
j
 => (
syndrome
(jè& 
y
).
xÜR
 }.
asUIÁ


140 
v®
 
	ghammBadB™OH
 = 
UIÁToOH
(
syndromeUIÁ
, 
n
+1)

141 
v®
 
	gsysBadB™OH
 = 
Vec
.
buÏ‹
(
k
è{ 
i
 => 
hammBadB™OH
(
sys2hamm
(i)è}.
asUIÁ


143 
v®
 
	guncÜ»ùed
 = 
y
(
k
-1, 0)

144 
v®
 
	gcÜ»ùed
 = 
uncÜ»ùed
 ^ 
sysBadB™OH


145 
v®
 
cÜ»ùabË
 = 
syndromeUIÁ
.
ÜR


146 
v®
 
uncÜ»ùabË
 = ià(
poisÚous
(
n
)è{ 
syndromeUIÁ
 > 
UIÁ
Òè} { 
BoŞ
(
çl£
) }

150 şas 
	cSECDEDCode
 
ex‹nds
 
	mCode


152 
def
 
	mÿnD‘eù
 = 
Œue


153 
def
 
ÿnCÜ»ù
 = 
Œue


155 
´iv©e
 
v®
 
£c
 = 
Ãw
 
SECCode


156 
´iv©e
 
v®
 
·r
 = 
Ãw
 
P¬™yCode


158 
def
 
width
(
k
: 
IÁ
èğ
£c
.width(k)+1

159 
def
 
’code
(
x
: 
UIÁ
, 
poisÚ
: 
BoŞ
 = BoŞ(
çl£
)) = {

165 
v®
 
toggË_lo
 = 
C©
(
poisÚ
.
asUIÁ
,…oison.asUInt)

166 
v®
 
	mtoggË_hi
 = 
toggË_lo
 << (
£c
.
width
(
x
.
g‘Width
)-1)

167 
·r
.
’code
(
£c
.’code(
x
)è^ 
toggË_hi


169 
def
 
swizzË
(
x
: 
UIÁ
èğ
·r
.swizzË(
£c
.
	$swizzË
(
x
))

170 
def
 
	`decode
(
x
: 
UIÁ
èğ
Ãw
 
Decodšg
 {

171 
v®
 
£cdec
 = 
£c
.
	`decode
(
	`x
(
x
.
g‘Width
-2,0))

172 
v®
 
·rdec
 = 
·r
.
	`decode
(
x
)

174 
v®
 
uncÜ»ùed
 = 
£cdec
.uncorrected

175 
v®
 
cÜ»ùed
 = 
£cdec
.corrected

176 
v®
 
cÜ»ùabË
 = 
·rdec
.
uncÜ»ùabË


177 
v®
 
uncÜ»ùabË
 = !
·rdec
.uncÜ»ùabË && 
£cdec
.
cÜ»ùabË


178 
	}
}

181 
objeù
 
	gE¼G’


184 
def
 
­¶y
(
width
: 
IÁ
, 
f
: IÁ): 
UIÁ
 = {

185 
»quœe
(
width
 > 0 && 
f
 >ğ0 && 
log2Up
(width) + f <= 16)

186 
UIÁToOH
(
LFSR16
()(
log2Up
(
width
)+
f
-1,0))(
	gwidth
-1,0)

188 
def
 
­¶y
(
x
: 
UIÁ
, 
f
: 
IÁ
): UIÁ = x ^‡µly(x.
g‘Width
, f)

191 
Œa™
 
CªHaveE¼Üs
 
ex‹nds
 
	gBundË
 {

192 
v®
 
	gcÜ»ùabË
: 
O±iÚ
[
V®idIO
[
UIÁ
]]

193 
v®
 
uncÜ»ùabË
: 
O±iÚ
[
V®idIO
[
UIÁ
]]

196 
objeù
 
Code
 {

197 
def
 
äomSŒšg
(
s
: 
O±iÚ
[
SŒšg
]): 
Code
 = fromSŒšg(s.
g‘OrEl£
("none"))

198 
def
 
äomSŒšg
(
s
: 
SŒšg
): 
Code
 = s.
toLow”Ca£
 
m©ch
 {

199 "nÚe" => 
Ãw
 
Id’t™yCode


200 "id’t™y" => 
Ãw
 
Id’t™yCode


201 "·r™y" => 
Ãw
 
P¬™yCode


202 "£c" => 
Ãw
 
SECCode


203 "£cded" => 
Ãw
 
SECDEDCode


204 
_
 => 
throw
 
Ãw
 
IÎeg®Argum’tExû±iÚ
("Unknown ECCype")

209 
impÜt
 
ä“chs
.
rock‘ch
.
un™‹¡
.
_


211 
şass
 
	$ECCTe¡
(
k
: 
IÁ
, 
timeout
: IÁ = 500000è
ex‹nds
 
	$Un™Te¡
(
timeout
) {

212 
v®
 
code
 = 
Ãw
 
SECDEDCode


213 
v®
 
n
 = 
code
.
	`width
(
k
)

216 
v®
 
‹¡
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
=
n
+1))

217 
v®
 
Ï¡
 = 
	`‹¡
(
n
)

218 
‹¡
 :ğ‹¡ + !
Ï¡


219 
io
.
fšished
 :ğ
	`RegNext
(
Ï¡
, 
	`BoŞ
(
çl£
))

222 
v®
 
decoded
 = 
code
.
	`decode
(
	`‹¡
(
n
-1, 0))

223 
v®
 
»coded
 = 
code
.
	`’code
(
decoded
.
cÜ»ùed
)

224 
v®
 
di¡ªû
 = 
	`PİCouÁ
(
»coded
 ^ 
‹¡
)

227 
v®
 
cÜ»ù
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
=
n
))

228 
v®
 
cÜ»ùabË
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
=
n
))

229 
v®
 
uncÜ»ùabË
 = 
	`RegIn™
(
	`UIÁ
(0, 
width
=
n
))

231 
	`wh’
 (!
Ï¡
) {

232 
	`wh’
 (
decoded
.
uncÜ»ùabË
) {

233 
	`as£¹
 (
di¡ªû
 >ğ
	`UIÁ
(2))

234 
uncÜ»ùabË
 :ğuncÜ»ùabË + 
	`UIÁ
(1)

235 } .
	`–£wh’
 (
decoded
.
cÜ»ùabË
) {

236 
	`as£¹
 (
	`di¡ªû
(0))

237 
cÜ»ùabË
 :ğcÜ»ùabË + 
	`UIÁ
(1)

238 } .
Ùh”wi£
 {

239 
	`as£¹
 (
di¡ªû
 ==ğ
	`UIÁ
(0))

240 
	`as£¹
 (
decoded
.
uncÜ»ùed
 ==ğdecoded.
cÜ»ùed
)

241 
cÜ»ù
 :ğcÜ»ù + 
	`UIÁ
(1)

246 
v®
 
nCodes
 = 
	`BigIÁ
(1è<< 
n


247 
v®
 
nCÜ»ù
 = 
	`BigIÁ
(1è<< 
k


248 
v®
 
nCÜ»ùabË
 = 
nCodes
 / 2

249 
v®
 
nUncÜ»ùabË
 = 
nCodes
 - 
nCÜ»ùabË
 - 
nCÜ»ù


251 
	`wh’
 (
Ï¡
) {

252 
	`as£¹
 (
cÜ»ù
 ==ğ
	`UIÁ
(
nCÜ»ù
))

253 
	`as£¹
 (
cÜ»ùabË
 ==ğ
	`UIÁ
(
nCÜ»ùabË
))

254 
	`as£¹
 (
uncÜ»ùabË
 ==ğ
	`UIÁ
(
nUncÜ»ùabË
))

256 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Frequency.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


12 
objeù
 
	gF»qu’cy
 {

13 
def
 
­¶y
(
di¡
 : 
Li¡
[(
IÁ
, 
B™s
)]) : Bits = {

15 
»quœe
(
di¡
.
Ëngth
 > 0)

18 
v®
 (
äeqs
, 
v®s
èğ
di¡
.
unz


19 
v®
 
tÙ®
 = 
äeqs
.
sum


20 
»quœe
(
isPow2
(
tÙ®
))

23 
v®
 (
fœ¡F»q
, 
fœ¡V®
èğ
di¡
.
h—d


26 
v®
 
»suÉ
 = 
Wœe
(
B™s
(
width
 = 
fœ¡V®
.
g‘Width
))

27 
»suÉ
 :ğ
UIÁ
(0)

30 
v®
 
¿ndV®
 = 
LCG
(
log2Up
(
tÙ®
))

33 
v¬
 
couÁ
 = 
fœ¡F»q


34 
v¬
 
£Ëù
 = 
wh’
 (
¿ndV®
 < 
UIÁ
(
fœ¡F»q
)è{ 
»suÉ
 :ğ
fœ¡V®
 }

35 
p
 <- 
di¡
.
drİ
(1)) {

36 
couÁ
 = couÁ + 
p
.
_1


37 
£Ëù
 = s–eù.
–£wh’
(
¿ndV®
 < 
UIÁ
(
couÁ
)è{ 
»suÉ
 :ğ
p
.
_2
 }

40  
»suÉ


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GeneratorUtils.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.
RawModuË


7 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gfœ¹l
.
Cœcu™


9 
impÜt
 
	gjava
.
	gio
.{
	gFe
, 
	gFeWr™”
}

11 
impÜt
 
	gfœ¹l
.
	gªnÙ©iÚs
.
JsÚPrÙocŞ


12 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


13 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gdlomacy
.
_


14 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gsy¡em
.{
	gDeçuÉTe¡Su™es
, 
	gTe¡G’”©iÚ
}

17 
şass
 
	$P¬£dIÅutNames
(

18 
rg‘Dœ
: 
SŒšg
,

19 
tİModuËProjeù
: 
SŒšg
,

20 
tİModuËCÏss
: 
SŒšg
,

21 
cÚfigProjeù
: 
SŒšg
,

22 
cÚfigs
: 
SŒšg
) {

23 
v®
 
cÚfigCÏs£s
: 
Seq
[
SŒšg
] = 
cÚfigs
.
	`¥l™
('_')

24 
v®
 
fuÎCÚfigCÏs£s
: 
Seq
[
SŒšg
] = 
cÚfigCÏs£s
.
	`m­
(
cÚfigProjeù
 + "." + 
_
)

25 
v®
 
fuÎTİModuËCÏss
: 
SŒšg
 = 
tİModuËProjeù
 + "." + 
tİModuËCÏss


26 
	}
}

31 
Œa™
 
HasG’”©ÜUt™›s
 {

32 
def
 
g‘CÚfig
(
fuÎCÚfigCÏssNames
: 
Seq
[
SŒšg
]): 
CÚfig
 = {

33 
Ãw
 
CÚfig
(
fuÎCÚfigCÏssNames
.
fŞdRight
(
P¬am‘”s
.
em±y
è{ (
cu¼’tName
, 
cÚfig
) =>

34 
v®
 
cu¼’tCÚfig
 = 
Œy
 {

35 
CÏss
.
fÜName
(
cu¼’tName
).
ÃwIn¡ªû
.
asIn¡ªûOf
[
CÚfig
]

36 } 
ÿtch
 {

37 
e
: 
java
.
Ïng
.
CÏssNÙFoundExû±iÚ
 =>

38 
throwExû±iÚ
(
s
"""UÇbËØfšd…¬ˆ"
$cu¼’tName
" from "
$fuÎCÚfigCÏssNames
", did you mis¥–È™?""", 
e
)

40 
cu¼’tCÚfig
 ++ 
cÚfig


44 
def
 
g‘P¬am‘”s
(
Çmes
: 
Seq
[
SŒšg
]): 
P¬am‘”s
 = g‘P¬am‘”s(
g‘CÚfig
(names))

46 
def
 
g‘P¬am‘”s
(
cÚfig
: 
CÚfig
): 
P¬am‘”s
 = cÚfig.
toIn¡ªû


48 
def
 
–abÜ©e
(
fuÎTİModuËCÏssName
: 
SŒšg
, 
·¿ms
: 
P¬am‘”s
): 
Cœcu™
 = {

49 
v®
 
tİ
 = () =>

50 
CÏss
.
fÜName
(
fuÎTİModuËCÏssName
)

51 .
g‘CÚ¡ruùÜ
(
şassOf
[
P¬am‘”s
])

52 .
ÃwIn¡ªû
(
·¿ms
è
m©ch
 {

53 
m
: 
RawModuË
 => m

54 
l
: 
LazyModuË
 => LazyModuËÖ).
moduË


57 
Driv”
.
–abÜ©e
(
tİ
)

60 
def
 
’um”©eROMs
(
cœcu™
: 
Cœcu™
): 
SŒšg
 = {

61 
v®
 
»s
 = 
Ãw
 
SŒšgBud”


62 
v®
 
cÚfigs
 =

63 
cœcu™
.
compÚ’ts
 
æ©M­
 { 
m
 =>

64 
m
.
id
 
m©ch
 {

65 
rom
: 
BÏckBoxedROM
 => 
Some
(Ôom.
Çme
, 
ROMG’”©Ü
.
lookup
(rom)))

66 
	g_
 => 
NÚe


69 
cÚfigs
 
	gfÜ—ch
 { (
	gÇme
, 
	gc
) =>

70 
»s
 
­³nd
 
s
"name ${name} depth ${c.depth} width ${c.width}\n"

72 
	g»s
.
	gtoSŒšg


77 
Œa™
 
G’”©ÜAµ
 
ex‹nds
 
Aµ
 
w™h
 
	gHasG’”©ÜUt™›s
 {

78 
Ïzy
 
v®
 
	gÇmes
: 
P¬£dIÅutNames
 = {

79 
»quœe
(
¬gs
.
size
 == 5, "Usage: sbt> " +

82 
P¬£dIÅutNames
(

83 
rg‘Dœ
 = 
¬gs
(0),

84 
tİModuËProjeù
 = 
¬gs
(1),

85 
tİModuËCÏss
 = 
¬gs
(2),

86 
cÚfigProjeù
 = 
¬gs
(3),

87 
cÚfigs
 = 
¬gs
(4))

91 
Ïzy
 
v®
 
	gtd
: 
SŒšg
 = 
Çmes
.
rg‘Dœ


92 
Ïzy
 
v®
 
cÚfig
: 
CÚfig
 = 
g‘CÚfig
(
Çmes
.
fuÎCÚfigCÏs£s
)

93 
Ïzy
 
v®
 
·¿ms
: 
P¬am‘”s
 = 
cÚfig
.
toIn¡ªû


94 
Ïzy
 
v®
 
cœcu™
: 
Cœcu™
 = 
–abÜ©e
(
Çmes
.
fuÎTİModuËCÏss
, 
·¿ms
)

96 
v®
 
	glÚgName
: 
SŒšg


99 
def
 
g’”©eFœ¹l
 {

100 
Driv”
.
dumpFœ¹l
(
cœcu™
, 
Some
(
Ãw
 
Fe
(
td
, 
s
"$longName.fir")))

103 
def
 
	gg’”©eAÂo
 {

104 
v®
 
	gªnÙ©iÚFe
 = 
Ãw
 
Fe
(
td
, 
s
"$longName.anno.json")

105 
v®
 
	gaf
 = 
Ãw
 
FeWr™”
(
ªnÙ©iÚFe
)

106 
af
.
wr™e
(
JsÚPrÙocŞ
.
£rŸlize
(
cœcu™
.
ªnÙ©iÚs
.
m­
(
_
.
toFœ¹l
)))

107 
af
.
şo£
()

111 
def
 
	gg’”©eTe¡Su™eMakeäags
 {

112 
addTe¡Su™es


113 
wr™eOuutFe
(
td
, 
s
"$lÚgName.d", 
Te¡G’”©iÚ
.
g’”©eMakeäag
)

116 
def
 
	gaddTe¡Su™es
 {

117 
	gTe¡G’”©iÚ
.
addSu™e
(
DeçuÉTe¡Su™es
.
ground‹¡64
("p"))

118 
	gTe¡G’”©iÚ
.
addSu™e
(
DeçuÉTe¡Su™es
.
em±yBm¬ks
)

119 
	gTe¡G’”©iÚ
.
addSu™e
(
DeçuÉTe¡Su™es
.
sšgËReg»ssiÚ
)

122 
def
 
	gg’”©eROMs
 {

123 
wr™eOuutFe
(
td
, 
s
"$lÚgName.rom.cÚf", 
’um”©eROMs
(
cœcu™
))

127 
def
 
	gg’”©eA¹eçùs
 {

128 
	gEÏbÜ©iÚA¹eçùs
.
	gfes
.
	gfÜ—ch
 { (
	gex‹nsiÚ
, 
	gcÚ‹Ás
) =>

129 
wr™eOuutFe
(
td
, 
s
"$lÚgName.$ex‹nsiÚ", 
cÚ‹Ás
 ())

133 
def
 
wr™eOuutFe
(
rg‘Dœ
: 
SŒšg
, 
âame
: SŒšg, 
cÚ‹Ás
: SŒšg): 
Fe
 = {

134 
v®
 
f
 = 
Ãw
 
Fe
(
rg‘Dœ
, 
âame
)

135 
v®
 
	gfw
 = 
Ãw
 
FeWr™”
(
f
)

136 
fw
.
wr™e
(
cÚ‹Ás
)

137 
fw
.
şo£


138 
f


142 
objeù
 
	gEÏbÜ©iÚA¹eçùs
 {

143 
v¬
 
	gfes
: 
Seq
[(
SŒšg
, (è=> SŒšg)] = 
N


145 
def
 
add
(
ex‹nsiÚ
: 
SŒšg
, 
cÚ‹Ás
: => String) {

146 
fes
 = (
ex‹nsiÚ
, (è=> 
cÚ‹Ás
) +: files

149 
def
 
cÚšs
(
ex‹nsiÚ
: 
SŒšg
): 
BoŞ—n
 = {

150 
fes
.
fŞdLeá
(
çl£
)((
t
, 
s
è=> {s.
_1
 =ğ
ex‹nsiÚ
 |})

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GenericParameterizedBundle.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


7 
ab¡¿ù
 
şass
 
	gG’”icP¬am‘”izedBundË
[+
T
 <: 
Objeù
](
v®
 
·¿ms
: Tè
ex‹nds
 
BundË


9 
ov”ride
 
def
 
şÚeTy³
 = {

10 
Œy
 {

11 
this
.
g‘CÏss
.
g‘CÚ¡ruùÜs
.
h—d
.
ÃwIn¡ªû
(
·¿ms
).
asIn¡ªûOf
[this.
ty³
]

12 } 
ÿtch
 {

13 
e
: 
java
.
Ïng
.
IÎeg®Argum’tExû±iÚ
 =>

14 
throw
 
Ãw
 
Exû±iÚ
("Unableo use GenericParameterizedBundle.cloneType on " +

15 
this
.
g‘CÏss
 + ",…robably because " +his.getClass +

17 "şÚeTy³(èÚ " + 
this
.
g‘CÏss
, 
e
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HellaQueue.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


7 
şass
 
	gH–ÏFlowQueue
[
T
 <: 
D©a
](
v®
 
’Œ›s
: 
IÁ
)(
d©a
: => Tè
ex‹nds
 
ModuË
 {

8 
v®
 
io
 = 
Ãw
 
QueueIO
(
d©a
, 
’Œ›s
)

9 
»quœe
(
’Œ›s
 > 1)

11 
v®
 
	gdo_æow
 = 
Wœe
(
BoŞ
())

12 
v®
 
do_’q
 = 
io
.
’q
.
fœe
(è&& !
do_æow


13 
v®
 
do_deq
 = 
io
.
deq
.
fœe
(è&& !
do_æow


15 
v®
 
maybe_fuÎ
 = 
Reg
(
š™
=
BoŞ
(
çl£
))

16 
v®
 
’q_±r
 = 
CouÁ”
(
do_’q
, 
’Œ›s
).
_1


17 
v®
 (
deq_±r
, 
deq_dÚe
èğ
CouÁ”
(
do_deq
, 
’Œ›s
)

18 
wh’
 (
do_’q
 =/ğ
do_deq
è{ 
maybe_fuÎ
 := do_enq }

20 
v®
 
±r_m©ch
 = 
’q_±r
 ==ğ
deq_±r


21 
v®
 
em±y
 = 
±r_m©ch
 && !
maybe_fuÎ


22 
v®
 
fuÎ
 = 
±r_m©ch
 && 
maybe_fuÎ


23 
v®
 
©L—¡Two
 = 
fuÎ
 || 
’q_±r
 - 
deq_±r
 >ğ
UIÁ
(2)

24 
do_æow
 :ğ
em±y
 && 
io
.
deq
.
»ady


26 
v®
 
¿m
 = 
SeqMem
(
’Œ›s
, 
d©a
)

27 
wh’
 (
do_’q
è{ 
	g¿m
.
wr™e
(
’q_±r
, 
io
.
’q
.
b™s
) }

29 
v®
 
	g»n
 = 
io
.
deq
.
»ady
 && (
©L—¡Two
 || !io.deq.
v®id
 && !
em±y
)

30 
v®
 
¿ddr
 = 
Mux
(
io
.
deq
.
v®id
, Mux(
deq_dÚe
, 
UIÁ
(0), 
deq_±r
 + UInt(1)), deq_ptr)

31 
v®
 
	g¿m_out_v®id
 = 
Reg
(
Ãxt
 = 
»n
)

33 
io
.
deq
.
v®id
 :ğ
Mux
(
em±y
, io.
’q
.v®id, 
¿m_out_v®id
)

34 
	gio
.
	g’q
.
	g»ady
 :ğ!
fuÎ


35 
io
.
deq
.
b™s
 :ğ
Mux
(
em±y
, io.
’q
.b™s, 
¿m
.
»ad
(
¿ddr
, 
»n
))

38 
şass
 
	gH–ÏQueue
[
T
 <: 
D©a
](
v®
 
’Œ›s
: 
IÁ
)(
d©a
: => Tè
ex‹nds
 
ModuË
 {

39 
v®
 
io
 = 
Ãw
 
QueueIO
(
d©a
, 
’Œ›s
)

41 
v®
 
	gfq
 = 
ModuË
(
Ãw
 
H–ÏFlowQueue
(
’Œ›s
)(
d©a
))

42 
fq
.
io
.
’q
 <> io.enq

43 
io
.
deq
 <> 
Queue
(
fq
.io.deq, 1, 
pe
 = 
Œue
)

46 
objeù
 
	gH–ÏQueue
 {

47 
def
 
	g­¶y
[
T
 <: 
D©a
](
’q
: 
Decou¶edIO
[T], 
	g’Œ›s
: 
IÁ
) = {

48 
v®
 
q
 = 
ModuË
((
Ãw
 
H–ÏQueue
(
’Œ›s
)è{ 
’q
.
b™s
 })

49 
q
.
io
.
’q
.
v®id
 :=ƒnq.valid

50 
q
.
io
.
’q
.
b™s
 :=ƒnq.bits

51 
’q
.
»ady
 :ğ
q
.
io
.enq.ready

52 
q
.
io
.
deq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HeterogeneousBag.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gcÜe
.
RecÜd


7 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gimmubË
.
Li¡M­


9 
fš®
 
şass
 
	gH‘”og’eousBag
[
T
 <: 
D©a
](
–ts
: 
Seq
[T]è
ex‹nds
 
RecÜd
 
w™h
 
cŞËùiÚ
.
IndexedSeq
[T] {

10 
def
 
­¶y
(
x
: 
IÁ
èğ
–ts
(x)

11 
def
 
Ëngth
 = 
–ts
.length

13 
v®
 
–em’ts
 = 
Li¡M­
(
–ts
.
zW™hIndex
.
m­
 { (
n
,
i
è=> (i.
toSŒšg
,‚è}:
_
*)

14 
ov”ride
 
def
 
şÚeTy³
: 
this
.
ty³
 = (
Ãw
 
H‘”og’eousBag
(
–ts
.
m­
(
_
.
chi£lClÚeTy³
))).
asIn¡ªûOf
[this.type]

17 
ov”ride
 
def
 
hashCode
: 
IÁ
 = 
su³r
[
RecÜd
].hashCode

18 
ov”ride
 
def
 
equ®s
(
th©
: 
Any
): 
BoŞ—n
 = 
su³r
[
RecÜd
].equals(that)

21 
objeù
 
H‘”og’eousBag


23 
def
 
äomNode
[
D
 <: 
D©a
, 
E
](
	g–ts
: 
Seq
[(D, E)]èğ
Ãw
 
H‘”og’eousBag
(
–ts
.
m­
(
_
.
_1
.
şÚeTy³
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IDPool.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gchi£l3
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
_


8 şas 
	cIDPoŞ
(
numIds
: 
IÁ
è
ex‹nds
 
ModuË
 {

9 
	`»quœe
 (
numIds
 > 0)

10 
v®
 
idWidth
 = 
	$log2Up
(
numIds
)

12 
v®
 
io
 = 
	`IO
(
Ãw
 
BundË
 {

13 
v®
 
ä“
 = 
	`Fl³d
(
	`V®id
(
	`UIÁ
(
idWidth
.
W
)))

14 
v®
 
®loc
 = 
	`I¼evoÿbË
(
	`UIÁ
(
idWidth
.
W
))

18 
v®
 
b™m­
 = 
	`RegIn™
(~0.U(
numIds
.
W
))

19 
v®
 
£Ëù
 = 
	`RegIn™
(0.U(
idWidth
.
W
))

20 
v®
 
v®id
 = 
	$RegIn™
(
Œue
.
B
)

22 
io
.
®loc
.
v®id
 := valid

23 
io
.
®loc
.
b™s
 :ğ
£Ëù


25 
v®
 
k’
 = (
io
.
®loc
.
»ady
 << io.®loc.
b™s
)(
numIds
-1, 0)

26 
v®
 
giv’
 = (
io
.
ä“
 .
v®id
 << io.ä“ .
b™s
)(
numIds
-1, 0)

27 
v®
 
b™m­1
 = (
b™m­
 & ~
k’
è| 
giv’


28 
v®
 
£Ëù1
 = 
	`OHToUIÁ
(~(
	`ËáOR
(
b™m­1
, 
numIds
) << 1) & bitmap1,‚umIds)

29 
v®
 
v®id1
 = 
b™m­1
.
ÜR


32 
	`wh’
 (
io
.
®loc
.
»ady
 || io.
ä“
.
v®id
) {

33 
b™m­
 :ğ
b™m­1


34 
v®id
 :ğ
v®id1


35 
	}
}

38 
wh’
 (
io
.
®loc
.
»ady
 || (!io.®loc.
v®id
 && io.
ä“
.valid)) {

39 
£Ëù
 :ğ
£Ëù1


43 
as£¹
 (!
io
.
ä“
.
v®id
 || !(
b™m­
 & ~
k’
)(io.ä“.
b™s
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IdentityModule.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
t–šk


5 
impÜt
 
	gChi£l
.
_


7 
şass
 
	gId’t™yModuË
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
ModuË


9 
v®
 
io
 = 
Ãw
 
BundË
 {

10 
v®
 
š
 = 
g’
.
şÚeTy³
.
æ


11 
v®
 
out
 = 
g’
.
şÚeTy³


14 
io
.
out
 :ğio.
š


17 
objeù
 
Id’t™yModuË


19 
def
 
­¶y
[
T
 <: 
D©a
](
x
: T): T = {

20 
v®
 
id’t™y
 = 
ModuË
(
Ãw
 
Id’t™yModuË
(
x
))

21 
id’t™y
.
io
.
š
 :ğ
x


22 
id’t™y
.
io
.
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LCG.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


14 şas 
	cLCG16
 
ex‹nds
 
	mModuË
 {

15 
v®
 
	mio
 = 
Ãw
 
BundË
 {

16 
v®
 
out
 = 
UIÁ
(
OUTPUT
, 16)

17 
v®
 
	mšc
 = 
BoŞ
(
INPUT
)

19 
v®
 
	g¡©e
 = 
Reg
(
	$UIÁ
(
width
 = 32))

20 
	$wh’
 (
io
.
šc
) {

21 
¡©e
 :ğ¡©* 
	`UIÁ
(1103515245, 32) + UInt(12345, 32)

22 
	}
}

23 
	gio
.
	gout
 :ğ
¡©e
(30, 15)

29 şas 
	cLCG
(
v®
 
w
: 
IÁ
è
ex‹nds
 
ModuË
 {

30 
v®
 
io
 = 
Ãw
 
BundË
 {

31 
v®
 
out
 = 
	`UIÁ
(
OUTPUT
, 
w
)

32 
v®
 
šc
 = 
	`BoŞ
(
INPUT
)

34 
	`»quœe
(
w
 > 0)

35 
v®
 
numLCG16s
 : 
IÁ
 = (
w
+15)/16

36 
v®
 
outs
 = 
Seq
.
	$fl
(
numLCG16s
è{ 
	`LCG16
(
io
.
šc
è
	}
}

37 
io
.
out
 :ğ
C©
(
outs
)

40 
objeù
 
LCG16
 {

41 
def
 
­¶y
(
šc
: 
BoŞ
 = BoŞ(
Œue
)): 
UIÁ
 = {

42 
v®
 
lcg
 = 
ModuË
(
Ãw
 
LCG16
)

43 
lcg
.
io
.
šc
 := inc

44 
lcg
.
io
.
out


48 
objeù
 
LCG
 {

49 
def
 
­¶y
(
w
: 
IÁ
, 
šc
: 
BoŞ
 = BoŞ(
Œue
)): 
UIÁ
 = {

50 
v®
 
lcg
 = 
ModuË
(
Ãw
 
LCG
(
w
))

51 
lcg
.
io
.
šc
 := inc

52 
lcg
.
io
.
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LatencyPipe.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


7 
şass
 
	gL©’cyPe
[
T
 <: 
D©a
](
typ
: T, 
	gÏ‹ncy
: 
IÁ
è
ex‹nds
 
ModuË
 {

8 
v®
 
io
 = 
Ãw
 
BundË
 {

9 
v®
 
š
 = 
Decou¶ed
(
typ
).
æ


10 
v®
 
out
 = 
Decou¶ed
(
typ
)

13 
def
 
doN
[
T
](
n
: 
IÁ
, 
	gfunc
: T => T, 
	gš
: T): T =

14 (0 
uÁ
 
n
).
fŞdLeá
(
š
)((
Ï¡
, 
	g_
è=> 
func
(last))

16 
io
.
out
 <> 
doN
(
Ï‹ncy
, (
Ï¡
: 
Decou¶edIO
[
T
]è=> 
Queue
Öa¡, 1, 
pe
=
Œue
), io.
š
)

19 
objeù
 
	gL©’cyPe
 {

20 
def
 
	g­¶y
[
T
 <: 
D©a
](
š
: 
Decou¶edIO
[T], 
	gÏ‹ncy
: 
IÁ
): DecoupledIO[T] = {

21 
v®
 
pe
 = 
ModuË
(
Ãw
 
L©’cyPe
(
š
.
b™s
, 
Ï‹ncy
))

22 
	gpe
.
	gio
.
	gš
 <> 
š


23 
	gpe
.
	gio
.
	gout


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Misc.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


7 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
P¬am‘”s


8 
impÜt
 
	gsÿÏ
.
	gm©h
.
_


10 şas 
	cP¬am‘”izedBundË
(
im¶ic™
 
p
: 
P¬am‘”s
è
ex‹nds
 
BundË


12 
Œa™
 
Clocked
 
ex‹nds
 
BundË
 {

13 
v®
 
şock
 = 
	$Clock
()

14 
v®
 
»£t
 = 
	`BoŞ
()

17 
Œa™
 
CªH®tAndC©chFœe
 
ex‹nds
 
BundË
 {

18 
v®
 
h®t_ªd_ÿtch_fœe
: 
O±iÚ
[
BoŞ
]

19 
	}
}

21 
objeù
 
Decou¶edH–³r
 {

22 
def
 
­¶y
(
rvs
: 
BoŞ
*èğ
Ãw
 
Decou¶edH–³r
(rvs)

25 
şass
 
	$Decou¶edH–³r
(
v®
 
rvs
: 
Seq
[
BoŞ
]) {

26 
def
 
	`fœe
(
exşude
: 
BoŞ
, 
šşudes
: Bool*) = {

27 
	`»quœe
(
rvs
.
	`cÚšs
(
exşude
), "Excluded Bool‚ot…resent in DecoupledHelper! Notehat DecoupledHelper uses„eferentialƒquality forƒxclusion! If you don't wantoƒxclude‡nything, use fire()!")

28 (
rvs
.
	`f‹r
(
_
 
Ã
 
exşude
è++ 
šşudes
).
	`»duû
(_ && _)

30 
def
 
	`fœe
() = {

31 
rvs
.
	`»duû
(
_
 && _)

33 
	}
}

35 
objeù
 
	gMuxT
 {

36 
def
 
	g­¶y
[
T
 <: 
D©a
, 
U
 <: D©a](
cÚd
: 
BoŞ
, 
	gcÚ
: (T, 
	gU
), 
	g®t
: (T, U)): (T, U) =

37 (
Mux
(
cÚd
, 
cÚ
.
_1
, 
®t
._1), Mux(cÚd, cÚ.
_2
,‡lt._2))

39 
def
 
	g­¶y
[
T
 <: 
D©a
, 
U
 <: D©a, 
W
 <: D©a](
cÚd
: 
BoŞ
, 
	gcÚ
: (T, 
	gU
, 
	gW
), 
	g®t
: (T, U, W)): (T, U, W) =

40 (
Mux
(
cÚd
, 
cÚ
.
_1
, 
®t
._1), Mux(cÚd, cÚ.
_2
,‡É._2), Mux(cÚd, cÚ.
_3
,‡lt._3))

42 
def
 
	g­¶y
[
T
 <: 
D©a
, 
U
 <: D©a, 
W
 <: D©a, 
X
 <: D©a](
cÚd
: 
BoŞ
, 
	gcÚ
: (T, 
	gU
, 
	gW
, 
	gX
), 
	g®t
: (T, U, W, X)): (T, U, W, X) =

43 (
Mux
(
cÚd
, 
cÚ
.
_1
, 
®t
._1), Mux(cÚd, cÚ.
_2
,‡É._2), Mux(cÚd, cÚ.
_3
,‡É._3), Mux(cÚd, cÚ.
_4
,‡lt._4))

47 
objeù
 
	gMuxTLookup
 {

48 
def
 
	g­¶y
[
S
 <: 
UIÁ
, 
T
 <: 
D©a
, 
U
 <: D©a](
key
: S, : (T, 
	gU
), 
	gm­pšg
: 
Seq
[(S, (T, U))]): (T, U) = {

49 
v¬
 
»s
 = 

50 (
k
, 
	gv
è<- 
	gm­pšg
.
	g»v”£
)

51 
	g»s
 = 
MuxT
(
k
 ==ğ
key
, 
v
, 
»s
)

52 
	g»s


55 
def
 
	g­¶y
[
S
 <: 
UIÁ
, 
T
 <: 
D©a
, 
U
 <: D©a, 
W
 <: D©a](
key
: S, : (T, 
	gU
, 
	gW
), 
	gm­pšg
: 
Seq
[(S, (T, U, W))]): (T, U, W) = {

56 
v¬
 
»s
 = 

57 (
k
, 
	gv
è<- 
	gm­pšg
.
	g»v”£
)

58 
	g»s
 = 
MuxT
(
k
 ==ğ
key
, 
v
, 
»s
)

59 
	g»s


63 
objeù
 
	gV®idMux
 {

64 
def
 
	g­¶y
[
T
 <: 
D©a
](
v1
: 
V®idIO
[T], 
	gv2
: ValidIO[T]*): ValidIO[T] = {

65 
­¶y
(
v1
 +: 
v2
.
toSeq
)

67 
def
 
­¶y
[
T
 <: 
D©a
](
v®ids
: 
Seq
[
V®idIO
[T]]): ValidIO[T] = {

68 
v®
 
out
 = 
Wœe
(
V®id
(
v®ids
.
h—d
.
b™s
.
şÚeTy³
))

69 
out
.
v®id
 :ğ
v®ids
.
m­
(
_
.v®id).
»duû
(_ || _)

70 
out
.
b™s
 :ğ
MuxCa£
(
v®ids
.
h—d
.bits,

71 
v®ids
.
m­
(
v
 => (v.
v®id
 -> v.
b™s
)))

72 
out


76 
objeù
 
	gSŒ


78 
def
 
­¶y
(
s
: 
SŒšg
): 
UIÁ
 = {

79 
v¬
 
i
 = 
BigIÁ
(0)

80 
»quœe
(
s
.
fÜ®l
(
v®idCh¬
 
_
))

81 
c
 <- 
s
)

82 
i
 = (˜<< 8è| 
c


83 
UIÁ
(
i
, 
s
.
Ëngth
*8)

85 
def
 
­¶y
(
x
: 
Ch¬
): 
UIÁ
 = {

86 
»quœe
(
v®idCh¬
(
x
))

87 
UIÁ
(
x
.
toIÁ
, 8)

89 
def
 
­¶y
(
x
: 
UIÁ
): UInt =‡pply(x, 10)

90 
def
 
­¶y
(
x
: 
UIÁ
, 
¿dix
: 
IÁ
): UInt = {

91 
v®
 
¿d
 = 
UIÁ
(
¿dix
)

92 
v®
 
w
 = 
x
.
g‘Width


93 
»quœe
(
w
 > 0)

95 
v¬
 
q
 = 
x


96 
v¬
 
s
 = 
dig™
(
q
 % 
¿d
)

97 
i
 <- 1 
uÁ
 
û
(
log
(2)/log(
¿dix
)*
w
).
toIÁ
) {

98 
q
 = q / 
¿d


99 
s
 = 
C©
(
Mux
(
BoŞ
(
¿dix
 =ğ10è&& 
q
 ==ğ
UIÁ
(0), 
SŒ
(' '), 
dig™
(q % 
¿d
)), s)

101 
	gs


103 
def
 
­¶y
(
x
: 
SIÁ
): 
UIÁ
 =‡pply(x, 10)

104 
def
 
­¶y
(
x
: 
SIÁ
, 
¿dix
: 
IÁ
): 
UIÁ
 = {

105 
v®
 
Ãg
 = 
x
 < 
SIÁ
(0)

106 
v®
 
abs
 = 
x
.abs.
asUIÁ


107 ià(
¿dix
 != 10) {

108 
C©
(
Mux
(
Ãg
, 
SŒ
('-'), SŒ(' ')), SŒ(
abs
, 
¿dix
))

110 
v®
 
¿d
 = 
UIÁ
(
¿dix
)

111 
v®
 
w
 = 
abs
.
g‘Width


112 
»quœe
(
w
 > 0)

114 
v¬
 
q
 = 
abs


115 
v¬
 
s
 = 
dig™
(
q
 % 
¿d
)

116 
v¬
 
ÃedSign
 = 
Ãg


117 
i
 <- 1 
uÁ
 
û
(
log
(2)/log(
¿dix
)*
w
).
toIÁ
) {

118 
q
 = q / 
¿d


119 
v®
 
¶aûS·û
 = 
q
 ==ğ
UIÁ
(0)

120 
v®
 
¥aû
 = 
Mux
(
ÃedSign
, 
SŒ
('-'), Str(' '))

121 
	gÃedSign
 = 
ÃedSign
 && !
¶aûS·û


122 
s
 = 
C©
(
Mux
(
¶aûS·û
, 
¥aû
, 
dig™
(
q
 % 
¿d
)), s)

124 
C©
(
Mux
(
ÃedSign
, 
SŒ
('-'), SŒ(' ')), 
s
)

128 
´iv©e
 
def
 
dig™
(
d
: 
UIÁ
): UIÁ = 
Mux
(d < UIÁ(10), 
SŒ
('0')+d, SŒ(('a'-10).
toCh¬
)+d)(7,0)

129 
´iv©e
 
def
 
v®idCh¬
(
x
: 
Ch¬
) = x == (x & 0xFF)

132 
objeù
 
S¶™


134 
def
 
­¶y
(
x
: 
UIÁ
, 
n0
: 
IÁ
) = {

135 
v®
 
w
 = 
x
.
g‘Width


136 (
x
.
exŒaù
(
w
-1,
n0
), 
	gx
.extract(n0-1,0))

138 
def
 
­¶y
(
x
: 
UIÁ
, 
n1
: 
IÁ
, 
n0
: Int) = {

139 
v®
 
w
 = 
x
.
g‘Width


140 (
x
.
exŒaù
(
w
-1,
n1
), 
	gx
.exŒaùÒ1-1,
n0
), x.extract(n0-1,0))

142 
def
 
­¶y
(
x
: 
UIÁ
, 
n2
: 
IÁ
, 
n1
: IÁ, 
n0
: Int) = {

143 
v®
 
w
 = 
x
.
g‘Width


144 (
x
.
exŒaù
(
w
-1,
n2
), 
	gx
.exŒaùÒ2-1,
n1
), x.exŒaùÒ1-1,
n0
), x.extract(n0-1,0))

148 
objeù
 
	gRªdom


150 
def
 
­¶y
(
mod
: 
IÁ
, 
¿ndom
: 
UIÁ
): UInt = {

151 ià(
isPow2
(
mod
)è
¿ndom
(
log2Up
(mod)-1,0)

152 
PriÜ™yEncod”
(
·¹™iÚ
(
­¶y
(1 << 
log2Up
(
mod
*8), 
¿ndom
), mod))

154 
def
 
­¶y
(
mod
: 
IÁ
): 
UIÁ
 =‡µly(mod, 
¿ndomiz”
)

155 
def
 
ÚeHÙ
(
mod
: 
IÁ
, 
¿ndom
: 
UIÁ
): UInt = {

156 ià(
isPow2
(
mod
)è
UIÁToOH
(
¿ndom
(
log2Up
(mod)-1,0))

157 
PriÜ™yEncod”OH
(
·¹™iÚ
(
­¶y
(1 << 
log2Up
(
mod
*8), 
¿ndom
), mod)).
asUIÁ


159 
def
 
ÚeHÙ
(
mod
: 
IÁ
): 
UIÁ
 = oÃHÙ(mod, 
¿ndomiz”
)

161 
´iv©e
 
def
 
	g¿ndomiz”
 = 
LFSR16
()

162 
´iv©e
 
def
 
round
(
x
: 
DoubË
): 
IÁ
 =

163 ià(
x
.
toIÁ
.
toDoubË
 == x) x.toInt (x.toInt + 1) & -2

164 
´iv©e
 
def
 
·¹™iÚ
(
v®ue
: 
UIÁ
, 
¦iûs
: 
IÁ
) =

165 
Seq
.
buÏ‹
(
¦iûs
)(
i
 => 
v®ue
 < 
UIÁ
(
round
((˜<< v®ue.
g‘Width
).
toDoubË
 / slices)))

168 
objeù
 
MajÜ™y
 {

169 
def
 
­¶y
(
š
: 
S‘
[
BoŞ
]): Bool = {

170 
v®
 
n
 = (
š
.
size
 >> 1) + 1

171 
v®
 
şau£s
 = 
š
.
sub£ts
(
n
).
m­
(
_
.
»duû
(_ && _))

172 
şau£s
.
»duû
(
_
 || _)

175 
def
 
­¶y
(
š
: 
Seq
[
BoŞ
]): BoŞ =‡µly(š.
toS‘
)

177 
def
 
­¶y
(
š
: 
UIÁ
): 
BoŞ
 =‡µly(š.
toBoŞs
.
toS‘
)

180 
objeù
 
PİCouÁAtL—¡
 {

181 
´iv©e
 
def
 
two
(
x
: 
UIÁ
): (
BoŞ
, 
	gBoŞ
èğx.
g‘Width
 
m©ch
 {

182 1 => (
x
.
toBoŞ
, 
BoŞ
(
çl£
))

183 
	gn
 =>

184 
v®
 
h®f
 = 
x
.
g‘Width
 / 2

185 
v®
 (
ËáOÃ
, 
ËáTwo
èğ
two
(
x
(
h®f
 - 1, 0))

186 
v®
 (
rightOÃ
, 
rightTwo
èğ
two
(
x
(x.
g‘Width
 - 1, 
h®f
))

187 (
	gËáOÃ
 || 
	grightOÃ
, 
	gËáTwo
 || 
	grightTwo
 || (leftOne &&„ightOne))

189 
def
 
­¶y
(
x
: 
UIÁ
, 
n
: 
IÁ
): 
BoŞ
 =‚ 
m©ch
 {

190 0 => 
BoŞ
(
Œue
)

191 1 => 
x
.
ÜR


192 2 => 
two
(
x
).
_2


193 3 => 
PİCouÁ
(
x
è>ğ
UIÁ
(
n
)

201 
objeù
 
MaskG’
 {

202 
def
 
­¶y
(
addr_lo
: 
UIÁ
, 
lgSize
: UIÁ, 
b—tBy‹s
: 
IÁ
, 
groupBy
: Int = 1): UInt = {

203 
»quœe
 (
groupBy
 >ğ1 && 
b—tBy‹s
 >= groupBy)

204 
»quœe
 (
isPow2
(
b—tBy‹s
è&& isPow2(
groupBy
))

205 
v®
 
lgBy‹s
 = 
log2Ce
(
b—tBy‹s
)

206 
v®
 
sizeOH
 = 
UIÁToOH
(
lgSize
 | 0.U(
log2Up
(
b—tBy‹s
).
W
),†og2Up(b—tBy‹s)è| 
UIÁ
(
groupBy
*2 - 1)

208 
def
 
h–³r
(
i
: 
IÁ
): 
Seq
[(
BoŞ
, Bool)] = {

209 ià(
i
 == 0) {

210 
Seq
((
lgSize
 >ğ
UIÁ
(
lgBy‹s
), 
BoŞ
(
Œue
)))

212 
v®
 
	gsub
 = 
h–³r
(
i
-1)

213 
v®
 
size
 = 
sizeOH
(
lgBy‹s
 - 
i
)

214 
v®
 
b™
 = 
addr_lo
(
lgBy‹s
 - 
i
)

215 
v®
 
nb™
 = !
b™


216 
Seq
.
buÏ‹
 (1 << 
i
è{ 
j
 =>

217 
v®
 (
sub_acc
, 
sub_eq
èğ
sub
(
j
/2)

218 
v®
 
eq
 = 
sub_eq
 && (ià(
j
 % 2 =ğ1è
b™
 
nb™
)

219 
v®
 
acc
 = 
sub_acc
 || (
size
 && 
eq
)

220 (
acc
, 
	geq
)

225 ià(
	ggroupBy
 =ğ
b—tBy‹s
è
UIÁ
(1) 

226 
C©
(
h–³r
(
lgBy‹s
-
log2Ce
(
groupBy
)).
m­
(
_
.
_1
).
»v”£
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MultiWidthFifo.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gun™‹¡
.
Un™Te¡


8 
şass
 
	$MuÉiWidthFifo
(
šW
: 
IÁ
, 
outW
: IÁ, 
n
: IÁè
ex‹nds
 
ModuË
 {

9 
v®
 
io
 = 
Ãw
 
BundË
 {

10 
v®
 
š
 = 
	`Decou¶ed
(
	`B™s
(
width
 = 
šW
)).
æ


11 
v®
 
out
 = 
	`Decou¶ed
(
	`B™s
(
width
 = 
outW
))

12 
v®
 
couÁ
 = 
	`UIÁ
(
OUTPUT
, 
	`log2Up
(
n
 + 1))

15 ià(
šW
 =ğ
outW
) {

16 
v®
 
q
 = 
	`ModuË
(
Ãw
 
	`Queue
(
	`B™s
(
width
 = 
šW
), 
n
))

17 
q
.
io
.
’q
 <> io.
š


18 
io
.
out
 <> 
q
.io.
deq


19 
io
.
couÁ
 :ğ
q
.io.count

20 } ià(
šW
 > 
outW
) {

21 
v®
 
nB—ts
 = 
šW
 / 
outW


23 
	`»quœe
(
šW
 % 
outW
 =ğ0, 
s
"MultiWidthFifo: in: $inW‚ot divisible by out: $outW")

24 
	`»quœe
(
n
 % 
nB—ts
 =ğ0, 
s
"Cannot store $n output words when output beats is $nBeats")

26 
v®
 
wd©a
 = 
	`Reg
(
	`Vec
(
n
 / 
nB—ts
, 
	`B™s
(
width
 = 
šW
)))

27 
v®
 
rd©a
 = 
	`Vec
(
wd©a
.
æ©M­
 { 
šd©
 =>

28 (0 
uÁ
 
nB—ts
).
	`m­
(
i
 => 
	`šd©
(
outW
 * (i + 1) - 1, outW * i)) })

30 
v®
 
h—d
 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
	`log2Up
(
n
 / 
nB—ts
)))

31 
v®
 

 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
	`log2Up
(
n
)))

32 
v®
 
size
 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
	`log2Up
(
n
 + 1)))

34 
	`wh’
 (
io
.
š
.
	`fœe
()) {

35 
	`wd©a
(
h—d
è:ğ
io
.
š
.
b™s


36 
h—d
 :ğh—d + 
	`UIÁ
(1)

39 
	`wh’
 (
io
.
out
.
	`fœe
()è{ 

 :ğ + 
	`UIÁ
(1) }

41 
size
 :ğ
	`MuxCa£
(size, 
	`Seq
(

42 (
io
.
š
.
	`fœe
(è&& io.
out
.fœe()è-> (
size
 + 
	`UIÁ
(
nB—ts
 - 1)),

43 
io
.
š
.
	`fœe
(è-> (
size
 + 
	`UIÁ
(
nB—ts
)),

44 
io
.
out
.
	`fœe
(è-> (
size
 - 
	`UIÁ
(1))))

46 
io
.
out
.
v®id
 :ğ
size
 > 
	`UIÁ
(0)

47 
io
.
out
.
b™s
 :ğ
	`rd©a
(

)

48 
io
.
š
.
»ady
 :ğ
size
 < 
	`UIÁ
(
n
)

49 
io
.
couÁ
 :ğ
size


51 
v®
 
nB—ts
 = 
outW
 / 
šW


53 
	`»quœe
(
outW
 % 
šW
 =ğ0, 
s
"MultiWidthFifo: out: $outW‚ot divisible by in: $inW")

55 
v®
 
wd©a
 = 
	`Reg
(
	`Vec
(
n
 * 
nB—ts
, 
	`B™s
(
width
 = 
šW
)))

56 
v®
 
rd©a
 = 
Vec
.
	`buÏ‹
(
n
è{ 
i
 =>

57 
	`C©
(
wd©a
.
	`¦iû
(
i
 * 
nB—ts
, (˜+ 1è*‚B—ts).
»v”£
)}

59 
v®
 
h—d
 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
	`log2Up
(
n
 * 
nB—ts
)))

60 
v®
 

 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
	`log2Up
(
n
)))

61 
v®
 
size
 = 
	`Reg
(
š™
 = 
	`UIÁ
(0, 
	`log2Up
(
n
 * 
nB—ts
 + 1)))

63 
	`wh’
 (
io
.
š
.
	`fœe
()) {

64 
	`wd©a
(
h—d
è:ğ
io
.
š
.
b™s


65 
h—d
 :ğh—d + 
	`UIÁ
(1)

68 
	`wh’
 (
io
.
out
.
	`fœe
()è{ 

 :ğ + 
	`UIÁ
(1) }

70 
size
 :ğ
	`MuxCa£
(size, 
	`Seq
(

71 (
io
.
š
.
	`fœe
(è&& io.
out
.fœe()è-> (
size
 - 
	`UIÁ
(
nB—ts
 - 1)),

72 
io
.
š
.
	`fœe
(è-> (
size
 + 
	`UIÁ
(1)),

73 
io
.
out
.
	`fœe
(è-> (
size
 - 
	`UIÁ
(
nB—ts
))))

75 
io
.
couÁ
 :ğ
size
 >> 
	`UIÁ
(
	`log2Up
(
nB—ts
))

76 
io
.
out
.
v®id
 :ğio.
couÁ
 > 
	`UIÁ
(0)

77 
io
.
out
.
b™s
 :ğ
	`rd©a
(

)

78 
io
.
š
.
»ady
 :ğ
size
 < 
	`UIÁ
(
n
 * 
nB—ts
)

80 
	}
}

82 şas 
	cMuÉiWidthFifoTe¡
 
ex‹nds
 
Un™Te¡
 {

83 
v®
 
big2l™e
 = 
ModuË
(
Ãw
 
	$MuÉiWidthFifo
(16, 8, 8))

84 
v®
 
l™e2big
 = 
	`ModuË
(
Ãw
 
	$MuÉiWidthFifo
(8, 16, 4))

86 
v®
 
bl_£nd
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

87 
v®
 
lb_£nd
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

88 
v®
 
bl_»cv
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

89 
v®
 
lb_»cv
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

90 
v®
 
bl_fšished
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

91 
v®
 
lb_fšished
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

93 
v®
 
bl_d©a
 = 
Vec
.
	$buÏ‹
(4){
i
 => 
	`UIÁ
((2 * i + 1) * 256 + 2 * i, 16)}

94 
v®
 
lb_d©a
 = 
Vec
.
	$buÏ‹
(8){
i
 => 
	`UIÁ
(i, 8)
	}
}

96 
v®
 (
bl_£nd_út
, 
bl_£nd_dÚe
èğ
CouÁ”
(
big2l™e
.
io
.
š
.
fœe
(), 4)

97 
v®
 (
lb_£nd_út
, 
lb_£nd_dÚe
èğ
CouÁ”
(
l™e2big
.
io
.
š
.
fœe
(), 8)

99 
v®
 (
bl_»cv_út
, 
bl_»cv_dÚe
èğ
CouÁ”
(
big2l™e
.
io
.
out
.
fœe
(), 8)

100 
v®
 (
lb_»cv_út
, 
lb_»cv_dÚe
èğ
CouÁ”
(
l™e2big
.
io
.
out
.
fœe
(), 4)

102 
	gbig2l™e
.
	gio
.
	gš
.
	gv®id
 :ğ
bl_£nd


103 
big2l™e
.
io
.
š
.
b™s
 :ğ
	$bl_d©a
(
bl_£nd_út
)

104 
big2l™e
.
io
.
out
.
»ady
 :ğ
bl_»cv


106 
l™e2big
.
io
.
š
.
v®id
 :ğ
lb_£nd


107 
l™e2big
.
io
.
š
.
b™s
 :ğ
	$lb_d©a
(
lb_£nd_út
)

108 
l™e2big
.
io
.
out
.
»ady
 :ğ
lb_»cv


110 
v®
 
bl_»cv_d©a_idx
 = 
bl_»cv_út
 >> 
	$UIÁ
(1)

111 
v®
 
bl_»cv_d©a
 = 
	`Mux
(
	`bl_»cv_út
(0),

112 
	`bl_d©a
(
bl_»cv_d©a_idx
)(15, 8),

113 
	`bl_d©a
(
bl_»cv_d©a_idx
)(7, 0))

115 
v®
 
lb_»cv_d©a
 = 
	`C©
(

116 
	`lb_d©a
(
	`C©
(
lb_»cv_út
, 
	`UIÁ
(1, 1))),

117 
	`lb_d©a
(
	`C©
(
lb_»cv_út
, 
	$UIÁ
(0, 1))))

119 
	$wh’
 (
io
.
¡¬t
) {

120 
bl_£nd
 :ğ
	`BoŞ
(
Œue
)

121 
lb_£nd
 :ğ
	`BoŞ
(
Œue
)

122 
	}
}

124 
	$wh’
 (
bl_£nd_dÚe
) {

125 
bl_£nd
 :ğ
	`BoŞ
(
çl£
)

126 
bl_»cv
 :ğ
	`BoŞ
(
Œue
)

127 
	}
}

129 
	$wh’
 (
lb_£nd_dÚe
) {

130 
lb_£nd
 :ğ
	`BoŞ
(
çl£
)

131 
lb_»cv
 :ğ
	`BoŞ
(
Œue
)

132 
	}
}

134 
	$wh’
 (
bl_»cv_dÚe
) {

135 
bl_»cv
 :ğ
	`BoŞ
(
çl£
)

136 
bl_fšished
 :ğ
	`BoŞ
(
Œue
)

137 
	}
}

139 
	$wh’
 (
lb_»cv_dÚe
) {

140 
lb_»cv
 :ğ
	`BoŞ
(
çl£
)

141 
lb_fšished
 :ğ
	`BoŞ
(
Œue
)

142 
	}
}

144 
io
.
fšished
 :ğ
bl_fšished
 && 
lb_fšished


146 
v®
 
bl_¡¬t_»cv
 = 
	$Reg
(
Ãxt
 = 
bl_£nd_dÚe
)

147 
v®
 
lb_¡¬t_»cv
 = 
	$Reg
(
Ãxt
 = 
lb_£nd_dÚe
)

149 
	`as£¹
(!
l™e2big
.
io
.
out
.
v®id
 ||†™e2big.io.out.
b™s
 ==ğ
lb_»cv_d©a
,

151 
	`as£¹
(!
big2l™e
.
io
.
out
.
v®id
 || big2l™e.io.out.
b™s
 ==ğ
bl_»cv_d©a
,

154 
	`as£¹
(!
lb_¡¬t_»cv
 || 
l™e2big
.
io
.
couÁ
 ==ğ
	`UIÁ
(4),

156 
	`as£¹
(!
bl_¡¬t_»cv
 || 
big2l™e
.
io
.
couÁ
 ==ğ
	`UIÁ
(8),

158 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MuxLiteral.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gsÿÏ
.
	g»æeù
.
CÏssTag


11 
objeù
 
	gMuxL™”®


13 
def
 
	g­¶y
[
T
 <: 
D©a
:
CÏssTag
](
šdex
: 
UIÁ
, : T, 
	gfœ¡
: (UIÁ, 
	gT
), 
	g»¡
: (UInt, T)*): T =

14 
­¶y
(
šdex
, , 
fœ¡
 :: 
»¡
.
toLi¡
)

15 
def
 
­¶y
[
T
 <: 
D©a
:
CÏssTag
](
šdex
: 
UIÁ
, : T, 
	gÿ£s
: 
Seq
[(UInt, T)]): T =

16 
MuxTabË
(
šdex
, , 
ÿ£s
.
m­
 { (
k
, 
v
è=> (k.
l™V®ue
, v) })

19 
objeù
 
	gMuxSeq


21 
def
 
	g­¶y
[
T
 <: 
D©a
:
CÏssTag
](
šdex
: 
UIÁ
, : T, 
	gfœ¡
: T, 
	g»¡
: T*): T =

22 
­¶y
(
šdex
, , 
fœ¡
 :: 
»¡
.
toLi¡
)

23 
def
 
­¶y
[
T
 <: 
D©a
:
CÏssTag
](
šdex
: 
UIÁ
, : T, 
	gÿ£s
: 
Seq
[T]): T =

24 
MuxTabË
(
šdex
, , 
ÿ£s
.
zW™hIndex
.
m­
 { (
v
, 
i
è=> (
BigIÁ
(i), v) })

27 
objeù
 
	gMuxTabË


29 
def
 
	g­¶y
[
T
 <: 
D©a
:
CÏssTag
](
šdex
: 
UIÁ
, : T, 
	gfœ¡
: (
BigIÁ
, 
	gT
), 
	g»¡
: (BigInt, T)*): T =

30 
­¶y
(
šdex
, , 
fœ¡
 :: 
»¡
.
toLi¡
)

31 
def
 
­¶y
[
T
 <: 
D©a
:
CÏssTag
](
šdex
: 
UIÁ
, : T, 
	gÿ£s
: 
Seq
[(
BigIÁ
, T)]): T = {

33 
ÿ£s
.
fÜ—ch
 { (
k
, 
_
è=> 
»quœe
 (k >= 0) }

34 
»quœe
 (
ÿ£s
.
m­
(
_
.
_1
).
di¡šù
.
size
 == cases.size)

37 
v®
 
sim¶e
 = 
ÿ£s
.
f‹r
 { (
k
, 
v
è=> !.
isL™
 || !v.isL™ || v.
l™V®ue
 != .litValue }

39 
v®
 
	gmaxKey
 = (
BigIÁ
(0è+: 
sim¶e
.
m­
(
_
.
_1
)).
max


40 
v®
 
’dIndex
 = 
BigIÁ
(1è<< 
log2Ce
(
maxKey
+1)

42 ià(
sim¶e
.
isEm±y
) {

44 } ià(
’dIndex
 <ğ2*
sim¶e
.
size
) {

46 
v®
 
bË
 = 
A¼ay
.
fl
(
’dIndex
.
toIÁ
) {  }

47 
sim¶e
.
fÜ—ch
 { (
k
, 
v
è=> 
bË
(k.
toIÁ
) = v }

48 
Mux
(
šdex
 >ğ
UIÁ
(
’dIndex
), , 
Vec
(
bË
)(index))

51 
v®
 
	gout
 = 
Wœe
(
š™
 = )

52 
sim¶e
.
fŞdLeá
(
Ãw
 
chi£l3
.
ut
.
Sw™chCÚ‹xt
(
šdex
, 
NÚe
, 
S‘
.
em±y
)è{ (
	gacc
, (
	gk
, 
	gv
)) =>

53 
acc
.
is
 (
UIÁ
(
k
)è{ 
out
 :ğ
v
 }

55 
out


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PSDTestMode.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gä“chs
.
	grock‘ch
.
	gcÚfig
.
_


8 
objeù
 
InşudePSDTe¡
 
ex‹nds
 
	gF›ld
[
BoŞ—n
](
	gçl£
)

10 şas 
	cPSDTe¡Mode
 
ex‹nds
 
	mBundË
 {

11 
v®
 
	m‹¡_mode
 = 
	$BoŞ
()

12 
v®
 
‹¡_mode_»£t
 = 
	`BoŞ
()

16 
Œa™
 
CªHavePSDTe¡ModeIO
 {

17 
im¶ic™
 
v®
 
p
: 
P¬am‘”s


18 
v®
 
psd
 = 
	`p
(
InşudePSDTe¡
).
	`İtiÚ
(
Ãw
 
	`PSDTe¡Mode
().
asIÅut
)

19 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PlusArg.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gut
.
HasBÏckBoxResourû


8 
şass
 
	$PlusArgInfo
(: 
IÁ
, 
doc¡ršg
: 
SŒšg
)

10 
şass
 
	$¶u§rg_»ad”
(
v®
 
fÜm©
: 
SŒšg
, v® : 
IÁ
, v® 
doc¡ršg
: SŒšgè
ex‹nds
 
	`BÏckBox
(
	`M­
(

11 "FORMAT" -> 
chi£l3
.
cÜe
.
	`SŒšgP¬am
(
fÜm©
),

12 "DEFAULT" -> 
chi£l3
.
cÜe
.
	$IÁP¬am
())è
w™h
 
HasBÏckBoxResourû
 {

13 
v®
 
io
 = 
Ãw
 
BundË
 {

14 
v®
 
out
 = 
	`UIÁ
(
OUTPUT
, 
width
 = 32)

17 
	`£tResourû
("/vsrc/plusarg_reader.v")

18 
	}
}

21 
şass
 
	$PlusArgTimeout
(
v®
 
fÜm©
: 
SŒšg
, v® : 
IÁ
, v® 
doc¡ršg
: SŒšgè
ex‹nds
 
ModuË
 {

22 
v®
 
io
 = 
Ãw
 
BundË
 {

23 
v®
 
couÁ
 = 
	`UIÁ
(
INPUT
, 
width
 = 32)

25 
v®
 
max
 = 
	`ModuË
(
Ãw
 
	`¶u§rg_»ad”
(
fÜm©
, , 
doc¡ršg
)).
io
.
out


27 
	`wh’
 (
max
 > 
	`UIÁ
(0)) {

28 
	`as£¹
 (
io
.
couÁ
 < 
max
, 
s
"Timeoutƒxceeded: $docstring")

30 
	}
}

32 
objeù
 
	gPlusArg


40 
def
 
­¶y
(
Çme
: 
SŒšg
, : 
IÁ
 = 0, 
doc¡ršg
: SŒšg = ""): 
UIÁ
 = {

41 
PlusArgA¹eçùs
.
­³nd
(
Çme
, , 
doc¡ršg
)

42 
ModuË
(
Ãw
 
¶u§rg_»ad”
(
Çme
 + "=%d", , 
doc¡ršg
)).
io
.
out


49 
def
 
timeout
(
Çme
: 
SŒšg
, : 
IÁ
 = 0, 
doc¡ršg
: SŒšg = "")(
couÁ
: 
UIÁ
) {

50 
PlusArgA¹eçùs
.
­³nd
(
Çme
, , 
doc¡ršg
)

51 
ModuË
(
Ãw
 
PlusArgTimeout
(
Çme
 + "=%d", , 
doc¡ršg
)).
io
.
couÁ
 := count

55 
objeù
 
PlusArgA¹eçùs
 {

56 
´iv©e
 
v¬
 
¬‹çùs
: 
M­
[
SŒšg
, 
PlusArgInfo
] = M­.
em±y


59 
def
 
­³nd
(
Çme
: 
SŒšg
, : 
IÁ
, 
doc¡ršg
: SŒšg): 
Un™
 =

60 
¬‹çùs
 =‡¹eçù ++ 
M­
(
Çme
 -> 
PlusArgInfo
(, 
doc¡ršg
))

63 
´iv©e
 
def
 
£rŸlizeH–p_cH—d”
(
b
: 
SŒšg
 = ""): SŒšg = 
¬‹çùs


64 .
m­
{ (
¬g
, 
PlusArgInfo
(, 
doc¡ršg
)) =>

65 
s
"""|$tab+$arg=INT\\n\\

66 |
$b$
{" "*20}
$doc¡ršg
\\
n
\\

67 |
$b$
{" "*22}(=
$deçuÉ
)""".stripMargin }.toSeq

68 .
mkSŒšg
("\\n\\\n") ++ "\""

71 
´iv©e
 
def
 
£rŸlizeA¼ay_cH—d”
(
b
: 
SŒšg
 = ""): String = {

72 
v®
 
´‘tyTab
 = 
b
 + " " * 44

73 
s
"${tab}static const char * verilog_plusargs [] = {\\\n" ++

74 
¬‹çùs


75 .
m­
{ (
¬g
, 
_
è=> 
s
"""$´‘tyTab"
$¬g
",\\\n""" }

76 .
mkSŒšg
("")++

77 
	gs
"${prettyTab}0};"

82 
def
 
£rŸlize_cH—d”
(): 
SŒšg
 =

83 
s
"""|#define PLUSARG_USAGE_OPTIONS \"EMULATOR VERILOG PLUSARGS\\n\\

84 |
$
{
£rŸlizeH–p_cH—d”
(" "*7)}

85 |
$
{
£rŸlizeA¼ay_cH—d”
()}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PositionalMultiQueue.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


7 
şass
 
	gPos™iÚ®MuÉiQueueP¬am‘”s
[
T
 <: 
D©a
](
g’
: T, 
	gpos™iÚs
: 
IÁ
, 
	gways
: Int)

9 
şass
 
Pos™iÚ®MuÉiQueueEÁry
[
T
 <: 
D©a
](
·¿ms
: 
Pos™iÚ®MuÉiQueueP¬am‘”s
[T])

10 
ex‹nds
 
	$G’”icP¬am‘”izedBundË
(
·¿ms
)

12 
v®
 
d©a
 = 
·¿ms
.
g’
.
asOuut


13 
v®
 
pos
 = 
	`UIÁ
(
width
 = 
	`log2Up
(
·¿ms
.
pos™iÚs
))

14 
	}
}

16 
şass
 
Pos™iÚ®MuÉiQueuePush
[
T
 <: 
D©a
](
·¿ms
: 
Pos™iÚ®MuÉiQueueP¬am‘”s
[T])

17 
ex‹nds
 
	$Pos™iÚ®MuÉiQueueEÁry
(
·¿ms
)

19 
v®
 
way
 = 
	`UIÁ
(
width
 = 
	`log2Up
(
·¿ms
.
ways
))

20 
	}
}

29 
şass
 
Pos™iÚ®MuÉiQueue
[
T
 <: 
D©a
](
·¿ms
: 
Pos™iÚ®MuÉiQueueP¬am‘”s
[T], 
	gcombš©iÚ®
: 
BoŞ—n
è
ex‹nds
 
ModuË


31 
v®
 
io
 = 
Ãw
 
BundË
 {

32 
v®
 
’q
 = 
V®id
(
Ãw
 
Pos™iÚ®MuÉiQueuePush
(
·¿ms
)).
æ


33 
v®
 
deq
 = 
Vec
(
·¿ms
.
ways
, 
Decou¶ed
(
Ãw
 
Pos™iÚ®MuÉiQueueEÁry
(params)))

36 
v®
 
	gem±y
 = 
RegIn™
(
Vec
.
fl
(
·¿ms
.
ways
è{ 
BoŞ
(
Œue
) })

37 
v®
 
h—d
 = 
Reg
(
Vec
(
·¿ms
.
ways
, 
UIÁ
(
width
 = 
log2Up
Õ¬ams.
pos™iÚs
))))

38 
v®
 

 = 
Reg
(
Vec
(
·¿ms
.
ways
, 
UIÁ
(
width
 = 
log2Up
Õ¬ams.
pos™iÚs
))))

39 
v®
 
Ãxt
 = 
Mem
(
·¿ms
.
pos™iÚs
, 
UIÁ
(
width
 = 
log2Up
(params.positions)))

40 
v®
 
d©a
 = 
Mem
(
·¿ms
.
pos™iÚs
,…¬ams.
g’
)

42 
v®
 
	ggu¬d
 = 
RegIn™
(
UIÁ
(0, 
width
 = 
·¿ms
.
pos™iÚs
))

44 
wh’
 (
io
.
’q
.
fœe
()) {

45 
d©a
(
io
.
’q
.
b™s
.
pos
) := io.enq.bits.data

47 
as£¹
 (!
gu¬d
(
io
.
’q
.
b™s
.
pos
))

49 
wh’
 (!
em±y
(
io
.
’q
.
b™s
.
way
)) {

50 
Ãxt
(

(
io
.
’q
.
b™s
.
way
)è:ğio.’q.b™s.
pos


53 
v®
 
£tGu¬d
 = 
io
.
’q
.
fœe
(è<< io.’q.
b™s
.
pos


55 
v®
 
deq
 = 
Wœe
(
io
.deq)

56 
io
.
deq
 <> deq

58 
v®
 
wayS–eù
 = 
UIÁToOH
(
io
.
’q
.
b™s
.
way
, 
·¿ms
.
ways
)

59 
v¬
 
	gşrGu¬d
 = 
UIÁ
(0)

60 
i
 <- 0 
uÁ
 
·¿ms
.
ways
) {

61 
v®
 
’q
 = 
io
.’q.
fœe
(è&& 
wayS–eù
(
i
)

62 
v®
 
Ï¡
 = 
h—d
(
i
è==ğ

(i)

64 
wh’
 (
’q
) {

65 

(
i
è:ğ
io
.
’q
.
b™s
.
pos


66 
wh’
 (
em±y
(
i
)) {

67 
h—d
(
i
è:ğ
io
.
’q
.
b™s
.
pos


71 ià(
combš©iÚ®
) {

72 
deq
(
i
).
v®id
 :ğ!
em±y
(iè|| 
’q


73 
deq
(
i
).
b™s
.
pos
 :ğ
Mux
(
em±y
(i), 
io
.
’q
.b™s.pos, 
h—d
(i))

74 
deq
(
i
).
	gb™s
.
	gd©a
 :ğ
Mux
(
em±y
(i), 
io
.
’q
.
b™s
.
d©a
, d©a(
h—d
(i)))

76 
deq
(
i
).
	gv®id
 :ğ!
em±y
(i)

77 
deq
(
i
).
b™s
.
pos
 :ğ
h—d
(i)

78 
deq
(
i
).
b™s
.
d©a
 :ğd©a(
h—d
(i))

81 
wh’
 (
deq
(
i
).
fœe
()) {

82 
h—d
(
i
è:ğ
Mux
(
Ï¡
, 
io
.
’q
.
b™s
.
pos
, 
Ãxt
(head(i)))

84 
	gşrGu¬d
 = 
şrGu¬d
 | (
deq
(
i
).
fœe
(è<< deq(i).
b™s
.
pos
)

86 
wh’
 (
’q
 =/ğ
deq
(
i
).
fœe
()) {

87 
em±y
(
i
è:ğ
deq
(i).
fœe
(è&& 
Ï¡


91 
gu¬d
 :ğ(gu¬d | 
£tGu¬d
è& ~
şrGu¬d


94 
objeù
 
Pos™iÚ®MuÉiQueue


96 
def
 
­¶y
[
T
 <: 
D©a
](
g’
: T, 
	gpos™iÚs
: 
IÁ
, 
	gways
: IÁ = 1, 
	gcombš©iÚ®
: 
BoŞ—n
 = 
Œue
) = {

97 
ModuË
(
Ãw
 
Pos™iÚ®MuÉiQueue
(
Pos™iÚ®MuÉiQueueP¬am‘”s
(
g’
, 
pos™iÚs
, 
ways
), 
combš©iÚ®
))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Property.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
	gut
.
´İ”ty


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gš‹º®
.
	gsourûšfo
.{
	gSourûInfo
, 
	gSourûLše
}

7 
impÜt
 
	gchi£l3
.
	gut
.{
	gR—dyV®idIO
}

9 
£®ed
 
ab¡¿ù
 cÏs 
	cPrİ”tyTy³
(
Çme
: 
SŒšg
) {

10 
ov”ride
 
def
 
toSŒšg
: 
SŒšg
 = 
Çme


13 
objeù
 
Prİ”tyTy³
 {

14 
objeù
 
As£¹
 
ex‹nds
 
	`Prİ”tyTy³
("Assert")

15 
objeù
 
Assume
 
ex‹nds
 
	`Prİ”tyTy³
("Assume")

16 
objeù
 
Cov”
 
ex‹nds
 
	`Prİ”tyTy³
("Cover")

17 
	}
}

19 
Œa™
 
Ba£Prİ”tyP¬am‘”s
 {

20 
v®
 
pTy³
: 
Prİ”tyTy³


21 
v®
 
cÚd
: 
BoŞ


22 
v®
 
Ïb–
: 
SŒšg


23 
v®
 
mes§ge
: 
SŒšg


26 
şass
 
Cov”Prİ”tyP¬am‘”s
(

27 
cÚd
: 
BoŞ
,

28 
Ïb–
: 
SŒšg
 = "",

29 
mes§ge
: 
SŒšg
 = ""è
ex‹nds
 
Ba£Prİ”tyP¬am‘”s
 {

30 
v®
 
pTy³
 = 
Prİ”tyTy³
.
Cov”


33 
ab¡¿ù
 cÏs 
	cBa£Prİ”tyLib¿ry
 {

34 
def
 
	$g’”©ePrİ”ty
(
´İ_·¿m
: 
Ba£Prİ”tyP¬am‘”s
)(
im¶ic™
 
sourûInfo
: 
SourûInfo
)

37 şas 
	cDeçuÉPrİ”tyLib¿ry
 
ex‹nds
 
Ba£Prİ”tyLib¿ry
 {

38 
def
 
	$g’”©ePrİ”ty
(
´İ_·¿m
: 
Ba£Prİ”tyP¬am‘”s
)(
im¶ic™
 
sourûInfo
: 
SourûInfo
) {

40 
Un™


42 
	}
}

44 
ab¡¿ù
 cÏs 
	cBa£Prİ”ty
 {

45 
def
 
	$g’”©ePrİ”t›s
(): 
Seq
[
Ba£Prİ”tyP¬am‘”s
]

48 
şass
 
	$Cov”BoŞ—n
(
cÚd
: 
BoŞ
, 
Ïb–s
: 
Seq
[
SŒšg
]) {

49 
	}
}

75 
şass
 
	$CrossPrİ”ty
(
cÚd
: 
Seq
[Seq[
Cov”BoŞ—n
]], 
exşude
: Seq[Seq[
SŒšg
]], 
mes§ge
: SŒšgè
ex‹nds
 
Ba£Prİ”ty
 {

76 
def
 
	`li¡Prİ”t›s
(
c1
: 
Cov”BoŞ—n
, 
c2
: 
Seq
[CoverBoolean]): Seq[CoverBoolean] = {

77 ià(
c2
.
isEm±y
) {

78 
	`Seq
(
c1
)

80 
c2
.
	`m­
Ğ(
c
: 
Cov”BoŞ—n
) => {

81 
Ãw
 
	`Cov”BoŞ—n
(
c1
.
cÚd
 && 
c
.cÚd, c1.
Ïb–s
 ++ c.labels)

86 
def
 
	`üossPrİ”t›s
(
cÚd
: 
Seq
[Seq[
Cov”BoŞ—n
]]): Seq[CoverBoolean] = {

87 ià(
cÚd
.
isEm±y
) {

88 
	`Seq
()

90 
cÚd
.
h—d
.
	`m­
Ğ(
c1
: 
Cov”BoŞ—n
) => {

91 
	`li¡Prİ”t›s
(
c1
, 
	`üossPrİ”t›s
(
cÚd
.

))

92 }).
	`»duû
(
_
 ++ _)

95 
def
 
	`šSequ’û
(
£¬ch
: 
Seq
[
SŒšg
], 
fšd
: Seq[SŒšg]): 
BoŞ—n
 = {

96 ià(
fšd
.
isEm±y
) {

97 
Œue


99 
fšd
.
	`m­
Ğ(
s
:
SŒšg
) => {

100 
£¬ch
.
	`cÚšs
(
s
)

101 }).
	`»duû
Ğ
_
 && _ )

104 
def
 
	`SeqsšSequ’û
(
£¬ch
: 
Seq
[
SŒšg
], 
fšd
: Seq[Seq[SŒšg]]): 
BoŞ—n
 = {

105 ià(
fšd
.
isEm±y
) {

106 
çl£


108 
fšd
.
	`m­
Ğ(
s
: 
Seq
[
SŒšg
]) => {

109 
	`šSequ’û
(
£¬ch
, 
s
)

110 }).
	`»duû
 (
_
 || _)

114 
def
 
	`g’”©ePrİ”t›s
(): 
Seq
[
Cov”Prİ”tyP¬am‘”s
] = {

115 
	`üossPrİ”t›s
(
cÚd
).
	`m­
Ğ(
c
: 
Cov”BoŞ—n
) => {

116 ià(!
	`SeqsšSequ’û
(
c
.
Ïb–s
, 
exşude
)) {

117 
Ãw
 
	`Cov”Prİ”tyP¬am‘”s
(

118 
cÚd
 = 
c
.cond,

119 
Ïb–
 = 
c
.
Ïb–s
.
	`»duû
Ğ(
s1
: 
SŒšg
, 
s2
: String) => {s1 + "_" + s2} ),

120 
mes§ge
 = mes§g+ " " + 
c
.
Ïb–s
.
	`m­
("<" + 
_
 + ">").
	`»duû
 ( (
s1
: 
SŒšg
, 
s2
: String) => { s1 + " X " + s2 }))

122 
Ãw
 
	`Cov”Prİ”tyP¬am‘”s
(

123 
cÚd
 = 
Œue
.
B
,

124 
Ïb–
 = 
c
.
Ïb–s
.
	`»duû
Ğ(
s1
: 
SŒšg
, 
s2
: String) => {s1 + "_" + s2} ) + "_EXCLUDE",

125 
mes§ge
 = mes§g+ " " + 
c
.
Ïb–s
.
	`m­
("<" + 
_
 + ">").
	`»duû
 ( (
s1
: 
SŒšg
, 
s2
: String) => { s1 + " X " + s2 }))

130 
	}
}

134 
objeù
 
cov”
 {

135 
´iv©e
 
v¬
 
´İLib
: 
Ba£Prİ”tyLib¿ry
 = 
Ãw
 
DeçuÉPrİ”tyLib¿ry


136 
def
 
£tPrİLib
(
lib
: 
Ba£Prİ”tyLib¿ry
): 
Un™
 = 
this
.
synchrÚized
 {

137 
´İLib
 = 
lib


139 
def
 
­¶y
(
cÚd
: 
BoŞ
)(
im¶ic™
 
sourûInfo
: 
SourûInfo
): 
Un™
 = {

140 
´İLib
.
g’”©ePrİ”ty
(
Cov”Prİ”tyP¬am‘”s
(
cÚd
))

142 
def
 
­¶y
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
)(
im¶ic™
 
sourûInfo
: 
SourûInfo
): 
Un™
 = {

143 
´İLib
.
g’”©ePrİ”ty
(
Cov”Prİ”tyP¬am‘”s
(
cÚd
, 
Ïb–
))

145 
def
 
­¶y
(
cÚd
: 
BoŞ
, 
Ïb–
: 
SŒšg
, 
mes§ge
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
): 
Un™
 = {

146 
´İLib
.
g’”©ePrİ”ty
(
Cov”Prİ”tyP¬am‘”s
(
cÚd
, 
Ïb–
, 
mes§ge
))

148 
def
 
­¶y
(
´İ
: 
Ba£Prİ”ty
)(
im¶ic™
 
sourûInfo
: 
SourûInfo
): 
Un™
 = {

149 
´İ
.
g’”©ePrİ”t›s
().
fÜ—ch
Ğ(
µ
: 
Ba£Prİ”tyP¬am‘”s
) => {

150 ià(
µ
.
pTy³
 =ğ
Prİ”tyTy³
.
Cov”
) {

151 
´İLib
.
g’”©ePrİ”ty
(
Cov”Prİ”tyP¬am‘”s
(
µ
.
cÚd
,…p.
Ïb–
,…p.
mes§ge
))

155 
def
 
	g­¶y
[
T
 <: 
D©a
](
rv
: 
R—dyV®idIO
[T], 
	gÏb–
: 
SŒšg
, 
	gmes§ge
: SŒšg)(
im¶ic™
 
sourûInfo
: 
SourûInfo
): 
Un™
 = {

156 
­¶y
Ğ
rv
.
v®id
 &&„v.
»ady
, 
Ïb–
 + "_FIRE", 
mes§ge
 + ": valid‡nd„eady")

157 
­¶y
Ğ
rv
.
v®id
 && !rv.
»ady
, 
Ïb–
 + "_STALL", 
mes§ge
 + ": valid‡nd‚ot„eady")

158 
­¶y
(!
rv
.
v®id
 &&„v.
»ady
, 
Ïb–
 + "_IDLE", 
mes§ge
 + ":‚ot valid‡nd„eady")

159 
­¶y
(!
rv
.
v®id
 && !rv.
»ady
, 
Ïb–
 + "_FULL", 
mes§ge
 + ":‚ot valid‡nd‚ot„eady")

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ROMGenerator.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gsÿÏ
.
	gcŞËùiÚ
.
	gmubË
.{
	gHashM­
}

8 
şass
 
	$ROMCÚfig
(
Çme
: 
SŒšg
, 
d•th
: 
IÁ
, 
width
: Int)

10 şas 
	cBÏckBoxedROM
(
c
: 
ROMCÚfig
è
ex‹nds
 
BÏckBox
 {

11 
v®
 
io
 = 
Ãw
 
BundË
 {

12 
v®
 
şock
 = 
	`Clock
(
INPUT
)

13 
v®
 
add»ss
 = 
	`UIÁ
(
INPUT
, 
	`log2Ce
(
c
.
d•th
))

14 
v®
 
Û
 = 
	`BoŞ
(
INPUT
)

15 
v®
 
me
 = 
	`BoŞ
(
INPUT
)

16 
v®
 
q
 = 
	`UIÁ
(
OUTPUT
, 
c
.
width
)

19 
ov”ride
 
def
 
desœedName
: 
SŒšg
 = 
c
.
Çme


20 
	}
}

22 
objeù
 
ROMG’”©Ü
 {

23 
´iv©e
 
v¬
 
fš®ized
 = 
çl£


24 
´iv©e
 
v®
 
roms
 = 
HashM­
[
BÏckBoxedROM
, 
ROMCÚfig
]()

25 
def
 
­¶y
(
c
: 
ROMCÚfig
): 
BÏckBoxedROM
 = {

26 
»quœe
(!
fš®ized
)

27 
v®
 
m
 = 
ModuË
(
Ãw
 
BÏckBoxedROM
(
c
))

28 
roms
(
m
èğ
c


29 
m


31 
def
 
lookup
(
m
: 
BÏckBoxedROM
): 
ROMCÚfig
 = {

32 
fš®ized
 = 
Œue


33 
roms
(
m
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/RationalCrossing.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


14 
£®ed
 
Œa™
 
	gR©iÚ®DœeùiÚ
 {

15 
def
 
	gæ
: 
R©iÚ®DœeùiÚ


23 
objeù
 
Symm‘ric
 
ex‹nds
 
R©iÚ®DœeùiÚ
 {

24 
def
 
æ
 = 
Symm‘ric


32 
objeù
 
FËxibË
 
ex‹nds
 
R©iÚ®DœeùiÚ
 {

33 
def
 
æ
 = 
FËxibË


39 
objeù
 
Fa¡ToSlow
 
ex‹nds
 
R©iÚ®DœeùiÚ
 {

40 
def
 
æ
 = 
SlowToFa¡


46 
objeù
 
SlowToFa¡
 
ex‹nds
 
R©iÚ®DœeùiÚ
 {

47 
def
 
æ
 = 
Fa¡ToSlow


50 
fš®
 
şass
 
R©iÚ®IO
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
BundË


52 
v®
 
b™s0
 = 
g’
.
chi£lClÚeTy³


53 
v®
 
b™s1
 = 
g’
.
chi£lClÚeTy³


54 
v®
 
v®id
 = 
BoŞ
()

55 
v®
 
sourû
 = 
UIÁ
(
width
 = 2)

56 
v®
 
»ady
 = 
BoŞ
().
æ


57 
v®
 
sšk
 = 
UIÁ
(
width
 = 2).
æ


59 
ov”ride
 
def
 
şÚeTy³
: 
this
.
ty³
 = 
Ãw
 
R©iÚ®IO
(
g’
).
asIn¡ªûOf
[this.type]

62 
objeù
 
R©iÚ®IO


64 
def
 
­¶y
[
T
 <: 
D©a
](
g’
: Tèğ
Ãw
 
R©iÚ®IO
(gen)

67 
şass
 
R©iÚ®CrossšgSourû
[
T
 <: 
D©a
](
g’
: T, 
	gdœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
è
ex‹nds
 
ModuË


69 
v®
 
io
 = 
Ãw
 
BundË
 {

70 
v®
 
’q
 = 
Decou¶edIO
(
g’
).
æ


71 
v®
 
deq
 = 
R©iÚ®IO
(
g’
)

74 
v®
 
deq
 = 
io
.deq

75 
v®
 
’q
 = 
dœeùiÚ
 
m©ch
 {

76 
Symm‘ric
 => 
ShiáQueue
(
io
.
’q
, 1, 
æow
=
Œue
)

77 
FËxibË
 => 
ShiáQueue
(
io
.
’q
, 2)

78 
	gFa¡ToSlow
 => 
io
.
’q


79 
SlowToFa¡
 => 
ShiáQueue
(
io
.
’q
, 2)

82 
v®
 
	gcouÁ
 = 
RegIn™
(
UIÁ
(0, 
width
 = 2))

83 
v®
 
equ®
 = 
couÁ
 ==ğ
deq
.
sšk


85 
deq
.
v®id
 :ğ
’q
.valid

86 
deq
.
sourû
 :ğ
couÁ


87 
deq
.
b™s0
 :ğ
’q
.
b™s


88 
deq
.
b™s1
 :ğ
RegEÇbË
(
’q
.
b™s
, 
equ®
)

89 
	g’q
.
	g»ady
 :ğ
Mux
(
equ®
, 
deq
.
»ady
, 
couÁ
(1è=/ğdeq.
sšk
(0))

91 
wh’
 (
’q
.
fœe
()è{ 
couÁ
 :ğ
C©
(count(0), !count(1)) }

94 
dœeùiÚ
 
	gm©ch
 {

95 
	gSymm‘ric
 => ()

96 
FËxibË
 => ()

97 
Fa¡ToSlow
 => 
as£¹
 (
equ®
 || 
couÁ
(1è==ğ
deq
.
sšk
(0))

98 
SlowToFa¡
 => 
as£¹
 (
equ®
 || 
couÁ
(1è=/ğ
deq
.
sšk
(0))

102 
şass
 
	gR©iÚ®CrossšgSšk
[
T
 <: 
D©a
](
g’
: T, 
	gdœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
è
ex‹nds
 
ModuË


104 
v®
 
io
 = 
Ãw
 
BundË
 {

105 
v®
 
’q
 = 
R©iÚ®IO
(
g’
).
æ


106 
v®
 
deq
 = 
Decou¶edIO
(
g’
)

109 
v®
 
’q
 = 
io
.enq

110 
v®
 
deq
 = 
Wœe
(
io
.deq)

111 
dœeùiÚ
 
m©ch
 {

112 
Symm‘ric
 => 
io
.
deq
 <> 
ShiáQueue
(deq, 1, 
pe
=
Œue
)

113 
FËxibË
 => 
io
.
deq
 <> 
ShiáQueue
(deq, 2)

114 
	gFa¡ToSlow
 => 
io
.
deq
 <> 
ShiáQueue
(deq, 2)

115 
	gSlowToFa¡
 => 
io
.
deq
 <> deq

118 
v®
 
	gcouÁ
 = 
RegIn™
(
UIÁ
(0, 
width
 = 2))

119 
v®
 
equ®
 = 
couÁ
 ==ğ
’q
.
sourû


121 
’q
.
»ady
 :ğ
deq
.ready

122 
’q
.
sšk
 :ğ
couÁ


123 
deq
.
b™s
 :ğ
Mux
(
equ®
, 
’q
.
b™s0
,ƒnq.
b™s1
)

124 
	gdeq
.
	gv®id
 :ğ
Mux
(
equ®
, 
’q
.
v®id
, 
couÁ
(1è=/ğ’q.
sourû
(0))

126 
wh’
 (
deq
.
fœe
()è{ 
couÁ
 :ğ
C©
(count(0), !count(1)) }

129 
dœeùiÚ
 
	gm©ch
 {

130 
	gSymm‘ric
 => ()

131 
FËxibË
 => ()

132 
Fa¡ToSlow
 => 
as£¹
 (
equ®
 || 
couÁ
(1è=/ğ
’q
.
sourû
(0))

133 
SlowToFa¡
 => 
as£¹
 (
equ®
 || 
couÁ
(1è==ğ
’q
.
sourû
(0))

137 
şass
 
	gR©iÚ®CrossšgFuÎ
[
T
 <: 
D©a
](
g’
: T, 
	gdœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
è
ex‹nds
 
ModuË


139 
v®
 
io
 = 
Ãw
 
CrossšgIO
(
g’
)

141 
v®
 
sourû
 = 
ModuË
(
Ãw
 
R©iÚ®CrossšgSourû
(
g’
, 
dœeùiÚ
))

142 
v®
 
	gsšk
 = 
ModuË
(
Ãw
 
R©iÚ®CrossšgSšk
(
g’
, 
dœeùiÚ
))

144 
	gsourû
.
	gşock
 :ğ
io
.
’q_şock


145 
sourû
.
»£t
 :ğ
io
.
’q_»£t


146 
sšk
 .
şock
 :ğ
io
.
deq_şock


147 
sšk
 .
»£t
 :ğ
io
.
deq_»£t


149 
sourû
.
io
.
’q
 <> io.enq

150 
io
.
deq
 <> 
sšk
.io.deq

153 
objeù
 
ToR©iÚ®


155 
def
 
­¶y
[
T
 <: 
D©a
](
x
: 
Decou¶edIO
[T], 
	gdœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
): 
R©iÚ®IO
[T] = {

156 
v®
 
sourû
 = 
ModuË
(
Ãw
 
R©iÚ®CrossšgSourû
(
x
.
b™s
, 
dœeùiÚ
))

157 
	gsourû
.
	gio
.
	g’q
 <> 
x


158 
	gsourû
.
	gio
.
	gdeq


162 
objeù
 
	gFromR©iÚ®


164 
def
 
	g­¶y
[
T
 <: 
D©a
](
x
: 
R©iÚ®IO
[T], 
	gdœeùiÚ
: 
R©iÚ®DœeùiÚ
 = 
Symm‘ric
): 
Decou¶edIO
[T] = {

165 
v®
 
sšk
 = 
ModuË
(
Ãw
 
R©iÚ®CrossšgSšk
(
x
.
b™s0
, 
dœeùiÚ
))

166 
	gsšk
.
	gio
.
	g’q
 <> 
x


167 
	gsšk
.
	gio
.
	gdeq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReduceOthers.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


7 
objeù
 
	gReduûOth”s
 {

10 
def
 
­¶y
(
x
: 
Seq
[
BoŞ
]): Seq[Bool] = {

11 
v®
 (
l™”®s
, 
v¬ŸbËs
èğ
x
.
·¹™iÚ
(
_
.
isL™
)

13 
v®
 
çl£s
 = 
l™”®s
.
couÁ
(
_
.
l™V®ue
 == 0)

14 ià(
çl£s
 > 2) {

15 
Seq
.
fl
(
x
.
size
è{ 
BoŞ
(
çl£
) }

16 } ià(
çl£s
 == 1) {

17 
x
.
m­
 { 
b
 =>

18 ià(
b
.
isL™
 && b.
l™V®ue
 == 0) {

19 
v¬ŸbËs
.
fŞdLeá
(
BoŞ
(
Œue
))(
_
 && _)

21 
BoŞ
(
çl£
)

25 
v¬
 (
out
, 
®l
èğ
h–³r
(
v¬ŸbËs
)

26 
x
.
m­
 { 
b
 =>

27 ià(
b
.
isL™
) {

28 
®l


30 
v®
 
£l
 = 
out
.
h—d


31 
out
 = out.



32 
£l


38 
def
 
­¶y
(
x
: 
Seq
[(
BoŞ
, Bool)]) {

39 (
	gx
.
m­
(
_
.
_1
è
z
 
­¶y
(
x
.m­(_.
_2
))è
	gfÜ—ch
 { (
	gw
, xè=> 
w
 := x }

41 
´iv©e
 
def
 
h–³r
(
x
: 
Seq
[
BoŞ
]): (Seq[BoŞ], 
	gBoŞ
) = {

42 ià(
x
.
size
 <= 1) {

43 (
Seq
.
fl
(
x
.
size
è{ 
BoŞ
(
Œue
è}, x.
h—dO±iÚ
.
g‘OrEl£
(Bool(true)))

44 } ià(
x
.
size
 <= 3) {

45 (
Seq
.
buÏ‹
(
x
.
size
è{ 
i
 =>

46 (
x
.
ke
(
i
è++ x.
drİ
(i+1)).
»duû
(
_
 && _)

47 }, 
	gx
.
»duû
(
_
 && _))

49 
v®
 (
h®f
, 
®l
èğ
h–³r
(
x
.
grou³d
(2).
m­
(
_
.
»duû
(_ && _)).
toLi¡
)

50 (
Seq
.
buÏ‹
(
x
.
size
è{ 
i
 =>

51 ià((
i
 ^ 1è>ğ
x
.
size
è
h®f
(i/2) x(i ^ 1) && half(i / 2)

52 }, 
	g®l
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReorderQueue.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


8 
şass
 
	gReÜd”QueueWr™e
[
T
 <: 
D©a
](
dTy³
: T, 
	ggWidth
: 
IÁ
è
ex‹nds
 
BundË
 {

9 
v®
 
d©a
 = 
dTy³
.
şÚeTy³


10 
v®
 
g
 = 
UIÁ
(
width
 = 
gWidth
)

12 
ov”ride
 
def
 
şÚeTy³
 =

13 
Ãw
 
ReÜd”QueueWr™e
(
dTy³
, 
gWidth
).
	gasIn¡ªûOf
[
this
.
ty³
]

16 
şass
 
	gReÜd”EnqueueIO
[
T
 <: 
D©a
](
dTy³
: T, 
	ggWidth
: 
IÁ
)

17 
ex‹nds
 
Decou¶edIO
(
Ãw
 
	$ReÜd”QueueWr™e
(
dTy³
, 
gWidth
)) {

19 
ov”ride
 
def
 
şÚeTy³
 =

20 
Ãw
 
	`ReÜd”EnqueueIO
(
dTy³
, 
gWidth
).
asIn¡ªûOf
[
this
.
ty³
]

21 
	}
}

23 
şass
 
	gReÜd”DequeueIO
[
T
 <: 
D©a
](
dTy³
: T, 
	ggWidth
: 
IÁ
è
ex‹nds
 
BundË
 {

24 
v®
 
v®id
 = 
BoŞ
(
INPUT
)

25 
v®
 
g
 = 
UIÁ
(
INPUT
, 
gWidth
)

26 
v®
 
	gd©a
 = 
dTy³
.
şÚeTy³
.
asOuut


27 
v®
 
m©ches
 = 
BoŞ
(
OUTPUT
)

29 
ov”ride
 
def
 
şÚeTy³
 =

30 
Ãw
 
ReÜd”DequeueIO
(
dTy³
, 
gWidth
).
	gasIn¡ªûOf
[
this
.
ty³
]

33 
şass
 
	gReÜd”Queue
[
T
 <: 
D©a
](
dTy³
: T, 
	ggWidth
: 
IÁ
, 
	gsize
: 
O±iÚ
[IÁ] = 
NÚe
)

34 
ex‹nds
 
ModuË
 {

35 
v®
 
io
 = 
Ãw
 
BundË
 {

36 
v®
 
’q
 = 
Ãw
 
ReÜd”EnqueueIO
(
dTy³
, 
gWidth
).
æ


37 
v®
 
	gdeq
 = 
Ãw
 
ReÜd”DequeueIO
(
dTy³
, 
gWidth
)

40 
v®
 
	ggS·ûSize
 = 1 << 
gWidth


41 
v®
 
aùu®Size
 = 
size
.
g‘OrEl£
(
gS·ûSize
)

43 ià(
gS·ûSize
 > 
aùu®Size
) {

44 
v®
 
roq_d©a
 = 
Reg
(
Vec
(
aùu®Size
, 
dTy³
))

45 
v®
 
	groq_gs
 = 
Reg
(
Vec
(
aùu®Size
, 
UIÁ
(
width
 = 
gWidth
)))

46 
v®
 
roq_ä“
 = 
Reg
(
š™
 = 
Vec
.
fl
(
aùu®Size
)(
BoŞ
(
Œue
)))

48 
v®
 
roq_’q_addr
 = 
PriÜ™yEncod”
(
roq_ä“
)

49 
v®
 
roq_m©ches
 = 
roq_gs
.
z
(
roq_ä“
)

50 .
m­
 { (
g
, 
ä“
è=>ag ==ğ
io
.
deq
.tag && !free }

51 
v®
 
	groq_deq_ÚehÙ
 = 
PriÜ™yEncod”OH
(
roq_m©ches
)

53 
io
.
’q
.
»ady
 :ğ
roq_ä“
.
»duû
(
_
 || _)

54 
io
.
deq
.
d©a
 :ğ
Mux1H
(
roq_deq_ÚehÙ
, 
roq_d©a
)

55 
	gio
.
	gdeq
.
	gm©ches
 :ğ
roq_m©ches
.
»duû
(
_
 || _)

57 
wh’
 (
io
.
’q
.
v®id
 && io.’q.
»ady
) {

58 
roq_d©a
(
roq_’q_addr
è:ğ
io
.
’q
.
b™s
.
d©a


59 
roq_gs
(
roq_’q_addr
è:ğ
io
.
’q
.
b™s
.
g


60 
roq_ä“
(
roq_’q_addr
è:ğ
BoŞ
(
çl£
)

63 
wh’
 (
io
.
deq
.
v®id
) {

64 
roq_ä“
(
OHToUIÁ
(
roq_deq_ÚehÙ
)è:ğ
BoŞ
(
Œue
)

67 
´šn
(
s
"Warning - using‡ CAM for ReorderQueue,agBits: ${tagWidth} size: ${actualSize}")

69 
v®
 
roq_d©a
 = 
Mem
(
gS·ûSize
, 
dTy³
)

70 
v®
 
	groq_ä“
 = 
Reg
(
š™
 = 
Vec
.
fl
(
gS·ûSize
)(
BoŞ
(
Œue
)))

72 
io
.
’q
.
»ady
 :ğ
roq_ä“
(io.’q.
b™s
.
g
)

73 
io
.
deq
.
d©a
 :ğ
roq_d©a
(io.deq.
g
)

74 
io
.
deq
.
m©ches
 :ğ!
roq_ä“
(io.deq.
g
)

76 
wh’
 (
io
.
’q
.
v®id
 && io.’q.
»ady
) {

77 
roq_d©a
(
io
.
’q
.
b™s
.
g
è:ğio.’q.b™s.
d©a


78 
roq_ä“
(
io
.
’q
.
b™s
.
g
è:ğ
BoŞ
(
çl£
)

81 
wh’
 (
io
.
deq
.
v®id
) {

82 
roq_ä“
(
io
.
deq
.
g
è:ğ
BoŞ
(
Œue
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Repeater.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


9 
şass
 
	gR•—‹r
[
T
 <: 
D©a
](
g’
: Tè
ex‹nds
 
ModuË


11 
v®
 
io
 = 
Ãw
 
BundË
 {

12 
v®
 
»³©
 = 
BoŞ
(
INPUT
)

13 
v®
 
fuÎ
 = 
BoŞ
(
OUTPUT
)

14 
v®
 
’q
 = 
Decou¶ed
(
g’
).
æ


15 
v®
 
deq
 = 
Decou¶ed
(
g’
)

18 
v®
 
fuÎ
 = 
RegIn™
(
BoŞ
(
çl£
))

19 
v®
 
§ved
 = 
Reg
(
g’
)

22 
io
.
deq
.
v®id
 :ğio.
’q
.v®id || 
fuÎ


23 
io
.
’q
.
»ady
 :ğio.
deq
.»ady && !
fuÎ


24 
io
.
deq
.
b™s
 :ğ
Mux
(
fuÎ
, 
§ved
, io.
’q
.bits)

25 
	gio
.
	gfuÎ
 :ğ
fuÎ


27 
wh’
 (
io
.
’q
.
fœe
(è&& io.
»³©
è{ 
fuÎ
 :ğ
BoŞ
(
Œue
); 
	g§ved
 :ğio.’q.
b™s
 }

28 
wh’
 (
io
.
deq
.
fœe
(è&& !io.
»³©
è{ 
fuÎ
 :ğ
BoŞ
(
çl£
) }

31 
objeù
 
R•—‹r


33 
def
 
­¶y
[
T
 <: 
D©a
](
’q
: 
Decou¶edIO
[T], 
	g»³©
: 
BoŞ
): DecoupledIO[T] = {

34 
v®
 
»³©”
 = 
ModuË
(
Ãw
 
R•—‹r
(
’q
.
b™s
))

35 
»³©”
.
io
.
»³©
 :=„epeat

36 
»³©”
.
io
.
’q
 :=ƒnq

37 
»³©”
.
io
.
deq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Replacement.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


8 
ab¡¿ù
 cÏs 
	cR•Ïûm’tPŞicy
 {

9 
def
 
	mway
: 
UIÁ


10 
def
 
miss
: 
Un™


11 
def
 
h™
: 
Un™


14 şas 
	cRªdomR•Ïûm’t
(
ways
: 
IÁ
è
ex‹nds
 
R•Ïûm’tPŞicy
 {

15 
´iv©e
 
v®
 
»¶aû
 = 
	`Wœe
(
	$BoŞ
())

16 
»¶aû
 :ğ
	$BoŞ
(
çl£
)

17 
v®
 
lf¤
 = 
	$LFSR16
(
»¶aû
)

19 
def
 
way
 = if(
ways
 =ğ1è
	$UIÁ
(0è
	`lf¤
(
	`log2Up
(
ways
)-1,0)

20 
def
 
miss
 = 
»¶aû
 :ğ
	$BoŞ
(
Œue
)

21 
def
 
h™
 = {}

22 
	}
}

24 
ab¡¿ù
 cÏs 
	cSeqR•Ïûm’tPŞicy
 {

25 
def
 
	$acûss
(
£t
: 
UIÁ
): 
Un™


26 
def
 
	$upd©e
(
v®id
: 
BoŞ
, 
h™
: BoŞ, 
£t
: 
UIÁ
, 
way
: UIÁ): 
Un™


27 
def
 
way
: 
UIÁ


30 şas 
	cSeqRªdom
(
n_ways
: 
IÁ
è
ex‹nds
 
SeqR•Ïûm’tPŞicy
 {

31 
v®
 
logic
 = 
Ãw
 
	$RªdomR•Ïûm’t
(
n_ways
)

32 
def
 
	`acûss
(
£t
: 
UIÁ
) = { }

33 
def
 
	`upd©e
(
v®id
: 
BoŞ
, 
h™
: BoŞ, 
£t
: 
UIÁ
, 
way
: UInt) = {

34 
	`wh’
 (
v®id
 && !
h™
è{ 
logic
.
miss
 }

35 
	}
}

36 
def
 
way
 = 
logic
.way

39 şas 
	cP£udoLRU
(
n
: 
IÁ
)

41 
´iv©e
 
v®
 
¡©e_»g
 = 
	`Reg
(
	`UIÁ
(
width
 = 
n
-1))

42 
def
 
	$acûss
(
way
: 
UIÁ
) {

43 
¡©e_»g
 :ğ
	`g‘_Ãxt_¡©e
(¡©e_»g,
way
)

45 
def
 
	`g‘_Ãxt_¡©e
(
¡©e
: 
UIÁ
, 
way
: UInt) = {

46 
v¬
 
Ãxt_¡©e
 = 
¡©e
 << 1

47 
v¬
 
idx
 = 
	`UIÁ
(1,1)

48 
i
 <- 
	`log2Up
(
n
)-1 
to
 0 
by
 -1) {

49 
v®
 
b™
 = 
	`way
(
i
)

50 
Ãxt_¡©e
 =‚ext_¡©e.
	`b™S‘
(
idx
, !
b™
)

51 
idx
 = 
	`C©
(idx, 
b™
)

53 
Ãxt_¡©e
.
	`exŒaù
(
n
-1, 1)

54 
	}
}

55 
def
 
	g»¶aû
 = 
	$g‘_»¶aû_way
(
¡©e_»g
)

56 
def
 
	`g‘_»¶aû_way
(
¡©e
: 
UIÁ
) = {

57 
v®
 
shiáed_¡©e
 = 
¡©e
 << 1

58 
v¬
 
idx
 = 
	`UIÁ
(1,1)

59 
i
 <- 
	`log2Up
(
n
)-1 
to
 0 
by
 -1) {

60 
v®
 
š_bounds
 = 
	`C©
(
idx
, 
	`UIÁ
(
	`BigIÁ
(1è<< 
i
))(
	`log2Up
(
n
)-1, 0) < UInt(n)

61 
idx
 = 
	`C©
(idx, 
š_bounds
 && 
	`shiáed_¡©e
(idx))

63 
	`idx
(
	`log2Up
(
n
)-1,0)

64 
	}
}

67 
şass
 
	$SeqPLRU
(
n_£ts
: 
IÁ
, 
n_ways
: IÁè
ex‹nds
 
SeqR•Ïûm’tPŞicy
 {

68 
v®
 
¡©e
 = 
	`SeqMem
(
n_£ts
, 
	`UIÁ
(
width
 = 
n_ways
-1))

69 
v®
 
logic
 = 
Ãw
 
	`P£udoLRU
(
n_ways
)

70 
v®
 
cu¼’t_¡©e
 = 
	`Wœe
(
	`UIÁ
())

71 
v®
 
¶ru_way
 = 
logic
.
	`g‘_»¶aû_way
(
cu¼’t_¡©e
)

72 
v®
 
Ãxt_¡©e
 = 
	`Wœe
(
	`UIÁ
())

74 
def
 
	`acûss
(
£t
: 
UIÁ
) = {

75 
cu¼’t_¡©e
 :ğ
¡©e
.
	`»ad
(
£t
)

78 
def
 
	`upd©e
(
v®id
: 
BoŞ
, 
h™
: BoŞ, 
£t
: 
UIÁ
, 
way
: UInt) = {

79 
v®
 
upd©e_way
 = 
	`Mux
(
h™
, 
way
, 
¶ru_way
)

80 
Ãxt_¡©e
 :ğ
logic
.
	`g‘_Ãxt_¡©e
(
cu¼’t_¡©e
, 
upd©e_way
)

81 
	`wh’
 (
v®id
è{ 
¡©e
.
	`wr™e
(
£t
, 
Ãxt_¡©e
) }

84 
def
 
way
 = 
¶ru_way


85 
	}
}

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ResetCatchAndSync.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gchi£l3
.
	gex³rim’l
.{
	gw™hClockAndRe£t
, 
	gw™hRe£t
}

13 
şass
 
	$Re£tC©chAndSync
 (
sync
: 
IÁ
 = 3è
ex‹nds
 
ModuË
 {

15 
ov”ride
 
def
 
desœedName
 = 
s
"ResetCatchAndSync_d${sync}"

17 
v®
 
io
 = 
Ãw
 
BundË
 {

18 
v®
 
sync_»£t
 = 
	`BoŞ
(
OUTPUT
)

19 
v®
 
psd
 = 
Ãw
 
	`PSDTe¡Mode
().
asIÅut


26 
v®
 
po¡_psd_»£t
 = 
	`Mux
(
io
.
psd
.
‹¡_mode
, io.psd.
‹¡_mode_»£t
, 
»£t
)

27 
	`w™hRe£t
(
po¡_psd_»£t
) {

28 
io
.
sync_»£t
 :ğ
	`Mux
(io.
psd
.
‹¡_mode
, io.psd.
‹¡_mode_»£t
,

29 ~
	`AsyncRe£tSynchrÚiz”ShiáReg
(
	`BoŞ
(
Œue
), 
sync
))

31 
	}
}

33 
objeù
 
	gRe£tC©chAndSync
 {

35 
def
 
­¶y
(
şk
: 
Clock
, 
r¡
: 
BoŞ
, 
sync
: 
IÁ
 = 3, 
Çme
: 
O±iÚ
[
SŒšg
] = 
NÚe
,

36 
psd
: 
O±iÚ
[
PSDTe¡Mode
] = 
NÚe
): 
BoŞ
 = {

38 
w™hClockAndRe£t
(
şk
, 
r¡
) {

39 
v®
 
ÿtch”
 = 
ModuË
 (
Ãw
 
Re£tC©chAndSync
(
sync
))

40 ià(
Çme
.
isDefšed
è{
ÿtch”
.
sugge¡Name
Òame.
g‘
)}

41 
ÿtch”
.
io
.
psd
 <>…sd.
g‘OrEl£
(
Wœe
(
Ãw
 
PSDTe¡Mode
()).
äomB™s
(
UIÁ
(0)))

42 
ÿtch”
.
io
.
sync_»£t


46 
def
 
­¶y
(
şk
: 
Clock
, 
r¡
: 
BoŞ
, 
sync
: 
IÁ
, 
Çme
: 
SŒšg
): BoŞ =‡µly(şk,„¡, sync, 
Some
(name))

47 
def
 
­¶y
(
şk
: 
Clock
, 
r¡
: 
BoŞ
, 
Çme
: 
SŒšg
): BoŞ =‡µly(şk,„¡,‚amğ
Some
(name))

49 
def
 
­¶y
(
şk
: 
Clock
, 
r¡
: 
BoŞ
, 
sync
: 
IÁ
, 
Çme
: 
SŒšg
, 
psd
: 
PSDTe¡Mode
): Bool =

50 
­¶y
(
şk
, 
r¡
, 
sync
, 
Some
(
Çme
), Some(
psd
))

51 
def
 
­¶y
(
şk
: 
Clock
, 
r¡
: 
BoŞ
, 
Çme
: 
SŒšg
, 
psd
: 
PSDTe¡Mode
): Bool =

52 
­¶y
(
şk
, 
r¡
, 
Çme
 = 
Some
Òame), 
psd
 = Some(psd))

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/SeededRandom.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


9 
objeù
 
	gS“dedRªdom
 {

10 
v®
 
	gäomS“d
 = 
Ãw
 
sÿÏ
.
ut
.
Rªdom
(42)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftQueue.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


11 
şass
 
	gShiáQueue
[
T
 <: 
D©a
](
g’
: T,

12 
v®
 
	g’Œ›s
: 
IÁ
,

13 
	gpe
: 
BoŞ—n
 = 
çl£
,

14 
	gæow
: 
BoŞ—n
 = 
çl£
)

15 
ex‹nds
 
ModuË
 {

16 
v®
 
io
 = 
IO
(
Ãw
 
QueueIO
(
g’
, 
’Œ›s
) {

17 
v®
 
mask
 = 
UIÁ
(
OUTPUT
, 
’Œ›s
)

20 
´iv©e
 
v®
 
	gv®id
 = 
RegIn™
(
Vec
.
fl
(
’Œ›s
è{ 
BoŞ
(
çl£
) })

21 
´iv©e
 
v®
 
–ts
 = 
Reg
(
Vec
(
’Œ›s
, 
g’
))

23 
	gi
 <- 0 
uÁ
 
	g’Œ›s
) {

24 
def
 
·ddedV®id
(
i
: 
IÁ
èğià(˜=ğ-1è
Œue
.
B
 ià(˜=ğ
’Œ›s
è
çl£
.B 
v®id
(i)

26 
v®
 
wd©a
 = ià(
i
 =ğ
’Œ›s
-1è
io
.
’q
.
b™s
 
Mux
(
v®id
(i+1), 
–ts
(i+1), io.enq.bits)

27 
v®
 
	gw’
 =

28 
Mux
(
io
.
deq
.
»ady
,

29 
·ddedV®id
(
i
+1è|| 
io
.
’q
.
fœe
(è&& (
BoŞ
(˜=ğ0 && !
æow
è|| 
v®id
(i)),

30 
io
.
’q
.
fœe
(è&& 
·ddedV®id
(
i
-1è&& !
v®id
(i))

31 
wh’
 (
w’
è{ 
–ts
(
i
è:ğ
wd©a
 }

33 
v®id
(
i
) :=

34 
Mux
(
io
.
deq
.
»ady
,

35 
·ddedV®id
(
i
+1è|| 
io
.
’q
.
fœe
(è&& (
BoŞ
(˜=ğ0 && !
æow
è|| 
v®id
(i)),

36 
io
.
’q
.
fœe
(è&& 
·ddedV®id
(
i
-1è|| 
v®id
(i))

39 
	gio
.
	g’q
.
	g»ady
 :ğ!
v®id
(
’Œ›s
-1)

40 
io
.
deq
.
v®id
 := valid(0)

41 
io
.
deq
.
b™s
 :ğ
–ts
.
h—d


43 ià(
æow
) {

44 
wh’
 (
io
.
’q
.
v®id
è{ io.
deq
.v®id :ğ
Œue
.
B
 }

45 
wh’
 (!
v®id
(0)è{ 
io
.
deq
.
b™s
 :ğio.
’q
.bits }

48 ià(
pe
) {

49 
wh’
 (
io
.
deq
.
»ady
è{ io.
’q
.»ady :ğ
Œue
.
B
 }

52 
io
.
mask
 :ğ
v®id
.
asUIÁ


53 
io
.
couÁ
 :ğ
PİCouÁ
(io.
mask
)

56 
objeù
 
ShiáQueue


58 
def
 
­¶y
[
T
 <: 
D©a
](
’q
: 
Decou¶edIO
[T], 
	g’Œ›s
: 
IÁ
 = 2, 
	gpe
: 
BoŞ—n
 = 
çl£
, 
	gæow
: Boolean = false): DecoupledIO[T] = {

59 
v®
 
q
 = 
ModuË
(
Ãw
 
ShiáQueue
(
’q
.
b™s
.
şÚeTy³
, 
’Œ›s
, 
pe
, 
æow
))

60 
	gq
.
	gio
.
	g’q
 <> 
’q


61 
	gq
.
	gio
.
	gdeq


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftReg.scala

3 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


5 
impÜt
 
	gChi£l
.
_


10 
objeù
 
	gShiáRegIn™
 {

11 
def
 
	g­¶y
[
T
 <: 
D©a
](
š
: T, 
	gn
: 
IÁ
, 
	gš™
: T, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): T =

13 (0 
uÁ
 
n
).
fŞdRight
(
š
) {

14 (
i
, 
Ãxt
) => {

15 
v®
 
r
 = 
Reg
(
Ãxt
,‚exˆğÃxt, 
š™
 = init)

16 
Çme
.
fÜ—ch
 { 
Ç
 => 
r
.
sugge¡Name
(
s
"${na}_${i}") }

17 
	gr


38 
ab¡¿ù
 
şass
 
	$Ab¡¿ùP–šeReg
(
w
: 
IÁ
 = 1è
ex‹nds
 
ModuË
 {

39 
v®
 
io
 = 
Ãw
 
BundË
 {

40 
v®
 
d
 = 
	`UIÁ
(
INPUT
, 
width
 = 
w
)

41 
v®
 
q
 = 
	`UIÁ
(
OUTPUT
, 
width
 = 
w
)

43 
	}
}

45 
objeù
 
	gAb¡¿ùP–šeReg
 {

46 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
g’
: => 
Ab¡¿ùP–šeReg
, 
	gš
: T, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): T = {

47 
v®
 
chaš
 = 
ModuË
(
g’
)

48 
Çme
.
fÜ—ch
{ 
chaš
.
sugge¡Name
(
_
) }

49 
chaš
.
io
.
d
 :ğ
š
.
asUIÁ


50 
chaš
.
io
.
q
.
asTy³Of
(
š
)

54 
şass
 
AsyncRe£tShiáReg
(
w
: 
IÁ
 = 1, 
d•th
: IÁ = 1, 
š™
: IÁ = 0, 
Çme
: 
SŒšg
 = "pe"è
ex‹nds
 
	$Ab¡¿ùP–šeReg
(
w
) {

55 
	`»quœe
(
d•th
 > 0, "Depth must be greaterhan 0.")

57 
ov”ride
 
def
 
desœedName
 = 
s
"AsyncResetShiftReg_w${w}_d${depth}_i${init}"

59 
v®
 
chaš
 = 
Li¡
.
	`buÏ‹
(
d•th
è{ 
i
 =>

60 
	`ModuË
 (
Ãw
 
	`AsyncRe£tRegVec
(
w
, 
š™
)).
	`sugge¡Name
(
s
"${name}_${i}")

63 
chaš
.
Ï¡
.
io
.
d
 := io.d

64 
chaš
.
Ï¡
.
io
.
’
 :ğ
	`BoŞ
(
Œue
)

66 (
chaš
.
š™
 
z
 chaš.

).
fÜ—ch
 { (
sšk
, 
sourû
) =>

67 
sšk
.
io
.
d
 :ğ
sourû
.io.
q


68 
sšk
.
io
.
’
 :ğ
	`BoŞ
(
Œue
)

70 
io
.
q
 :ğ
chaš
.
h—d
.io.q

71 
	}
}

73 
objeù
 
AsyncRe£tShiáReg
 {

74 
def
 
­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gš™
: IÁ = 0, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): T =

75 
Ab¡¿ùP–šeReg
(
Ãw
 
AsyncRe£tShiáReg
(
š
.
g‘Width
, 
d•th
, 
š™
), in, 
Çme
)

77 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gÇme
: 
O±iÚ
[
SŒšg
]): T =

78 
­¶y
(
š
, 
d•th
, 0, 
Çme
)

80 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gš™
: T, 
	gÇme
: 
O±iÚ
[
SŒšg
]): T =

81 
­¶y
(
š
, 
d•th
, 
š™
.
l™V®ue
.
toIÁ
, 
Çme
)

83 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gš™
: T): T =

84 
­¶y
 (
š
, 
d•th
, 
š™
.
l™V®ue
.
toIÁ
, 
NÚe
)

89 
şass
 
	$AsyncRe£tSynchrÚiz”ShiáReg
(
w
: 
IÁ
 = 1, 
sync
: IÁ = 3, 
š™
: IÁ = 0è
ex‹nds
 
	`AsyncRe£tShiáReg
(w, 
d•th
 = sync, in™, 
Çme
 = "sync") {

90 
	`»quœe
(
sync
 > 0, "Sync must be greaterhan 0.")

91 
ov”ride
 
def
 
desœedName
 = 
s
"AsyncResetSynchronizerShiftReg_w${w}_d${sync}_i${init}"

92 
	}
}

94 
objeù
 
	gAsyncRe£tSynchrÚiz”ShiáReg
 {

95 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gš™
: IÁ = 0, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): T =

96 
Ab¡¿ùP–šeReg
(
Ãw
 
AsyncRe£tSynchrÚiz”ShiáReg
(
š
.
g‘Width
, 
d•th
, 
š™
), in, 
Çme
)

98 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gÇme
: 
O±iÚ
[
SŒšg
]): T =

99 
­¶y
(
š
, 
d•th
, 0, 
Çme
)

101 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gš™
: T, 
	gÇme
: 
O±iÚ
[
SŒšg
]): T =

102 
­¶y
(
š
, 
d•th
, 
š™
.
l™V®ue
.
toIÁ
, 
Çme
)

104 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gd•th
: 
IÁ
, 
	gš™
: T): T =

105 
­¶y
 (
š
, 
d•th
, 
š™
.
l™V®ue
.
toIÁ
, 
NÚe
)

108 
şass
 
	$SynchrÚiz”ShiáReg
(
w
: 
IÁ
 = 1, 
sync
: IÁ = 3è
ex‹nds
 
	$Ab¡¿ùP–šeReg
(
w
) {

109 
	`»quœe
(
sync
 > 0, "Sync must be greaterhan 0.")

111 
ov”ride
 
def
 
desœedName
 = 
s
"SynchronizerShiftReg_w${w}_d${sync}"

113 
v®
 
syncv
 = 
Li¡
.
	`buÏ‹
(
sync
è{ 
i
 =>

114 
v®
 
r
 = 
	`Reg
(
	`UIÁ
(
width
 = 
w
))

115 
r
.
	`sugge¡Name
(
s
"sync_${i}")

118 
syncv
.
Ï¡
 :ğ
io
.
d


120 (
syncv
.
š™
 
z
 syncv.

).
fÜ—ch
 { (
sšk
, 
sourû
) =>

121 
sšk
 :ğ
sourû


123 
io
.
q
 :ğ
syncv
.
h—d


124 
	}
}

127 
objeù
 
SynchrÚiz”ShiáReg
 {

128 
def
 
­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gsync
: 
IÁ
 = 3, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): T = {

129 ià(
sync
 =ğ0è
š


130 
Ab¡¿ùP–šeReg
(
Ãw
 
SynchrÚiz”ShiáReg
(
š
.
g‘Width
, 
sync
), in, 
Çme
)

134 
şass
 
	$SyncRe£tSynchrÚiz”ShiáReg
(
w
: 
IÁ
 = 1, 
sync
: IÁ = 3, 
š™
: IÁ = 0è
ex‹nds
 
	$Ab¡¿ùP–šeReg
(
w
) {

135 
	`»quœe
 (
sync
 >= 0, "Sync must be greaterhan orƒqualo 0")

137 
ov”ride
 
def
 
desœedName
 = 
s
"SyncResetSynchronizerShiftReg_w${w}_d${sync}_i${init}"

139 
io
.
q
 :ğ
	`ShiáRegIn™
(io.
d
, 
n
 = 
sync
, 
š™
 = in™.
U
, 
Çme
 = 
	`Some
("sync"))

141 
	}
}

143 
objeù
 
	gSyncRe£tSynchrÚiz”ShiáReg
 {

144 
def
 
	g­¶y
 [
T
 <: 
Chi£l
.
D©a
](
š
: T, 
	gsync
: 
IÁ
 = 3, 
	gš™
: T, 
	gÇme
: 
O±iÚ
[
SŒšg
] = 
NÚe
): T =

145 
Ab¡¿ùP–šeReg
(
Ãw
 
SyncRe£tSynchrÚiz”ShiáReg
(
š
.
g‘Width
, 
sync
, 
š™
.
l™V®ue
.
toIÁ
), in, 
Çme
)

	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Timer.scala

4 
·ckage
 
	gä“chs
.
	grock‘ch
.
ut


6 
impÜt
 
	gChi£l
.
_


12 
şass
 
	$Tim”
(
š™CouÁ
: 
IÁ
, 
maxInæight
: IÁè
ex‹nds
 
ModuË
 {

13 
v®
 
io
 = 
Ãw
 
BundË
 {

14 
v®
 
¡¬t
 = 
	`V®id
(
	`UIÁ
(
width
 = 
	`log2Up
(
maxInæight
))).
æ


15 
v®
 
¡İ
 = 
	`V®id
(
	`UIÁ
(
width
 = 
	`log2Up
(
maxInæight
))).
æ


16 
v®
 
timeout
 = 
	`V®id
(
	`UIÁ
(
width
 = 
	`log2Up
(
maxInæight
)))

19 
v®
 
šæight
 = 
	`Reg
(
š™
 = 
Vec
.
	`fl
(
maxInæight
è{ 
	`BoŞ
(
çl£
) })

20 
v®
 
couÁdown
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	`log2Up
(
š™CouÁ
)))

21 
v®
 
aùive
 = 
šæight
.
	`»duû
(
_
 || _)

23 
	`wh’
 (
aùive
è{ 
couÁdown
 :ğcouÁdowÀ- 
	`UIÁ
(1) }

25 
	`wh’
 (
io
.
¡¬t
.
v®id
) {

26 
	`šæight
(
io
.
¡¬t
.
b™s
è:ğ
	`BoŞ
(
Œue
)

27 
couÁdown
 :ğ
	`UIÁ
(
š™CouÁ
 - 1)

30 
	`wh’
 (
io
.
¡İ
.
v®id
è{ 
	`šæight
(io.¡İ.
b™s
è:ğ
	`BoŞ
(
çl£
) }

32 
io
.
timeout
.
v®id
 :ğ
couÁdown
 ==ğ
	`UIÁ
(0è&& 
aùive


33 
io
.
timeout
.
b™s
 :ğ
	`PriÜ™yEncod”
(
šæight
)

35 
	`as£¹
(!
io
.
¡İ
.
v®id
 || 
	`šæight
(io.¡İ.
b™s
),

37 
	}
}

42 şas 
	cSim¶eTim”
(
š™CouÁ
: 
IÁ
è
ex‹nds
 
ModuË
 {

43 
v®
 
io
 = 
Ãw
 
BundË
 {

44 
v®
 
¡¬t
 = 
	`BoŞ
(
INPUT
)

45 
v®
 
¡İ
 = 
	`BoŞ
(
INPUT
)

46 
v®
 
timeout
 = 
	`BoŞ
(
OUTPUT
)

49 
v®
 
couÁdown
 = 
	`Reg
(
	`UIÁ
(
width
 = 
	$log2Up
(
š™CouÁ
)))

50 
v®
 
aùive
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

52 
	$wh’
 (
aùive
è{ 
couÁdown
 :ğcouÁdowÀ- 
	`UIÁ
(1è
	}
}

54 
	$wh’
 (
io
.
¡¬t
) {

55 
aùive
 :ğ
	`BoŞ
(
Œue
)

56 
couÁdown
 :ğ
	`UIÁ
(
š™CouÁ
 - 1)

57 
	}
}

59 
	$wh’
 (
io
.
¡İ
è{ 
aùive
 :ğ
	`BoŞ
(
çl£
è
	}
}

61 
io
.
timeout
 :ğ
couÁdown
 ==ğ
UIÁ
(0è&& 
aùive


64 
objeù
 
Sim¶eTim”
 {

65 
def
 
­¶y
(
š™CouÁ
: 
IÁ
, 
¡¬t
: 
BoŞ
, 
¡İ
: Bool): Bool = {

66 
v®
 
tim”
 = 
ModuË
(
Ãw
 
Sim¶eTim”
(
š™CouÁ
))

67 
tim”
.
io
.
¡¬t
 := start

68 
tim”
.
io
.
¡İ
 := stop

69 
tim”
.
io
.
timeout


74 şas 
	cDyÇmicTim”
(
w
: 
IÁ
è
ex‹nds
 
ModuË
 {

75 
v®
 
io
 = 
Ãw
 
BundË
 {

76 
v®
 
¡¬t
 = 
	`BoŞ
(
INPUT
)

77 
v®
 
³riod
 = 
	`UIÁ
(
INPUT
, 
w
)

78 
v®
 
¡İ
 = 
	`BoŞ
(
INPUT
)

79 
v®
 
timeout
 = 
	`BoŞ
(
OUTPUT
)

82 
v®
 
couÁdown
 = 
	`Reg
(
š™
 = 
	$UIÁ
(0, 
w
))

83 
v®
 
aùive
 = 
	`Reg
(
š™
 = 
	$BoŞ
(
çl£
))

85 
	$wh’
 (
io
.
¡¬t
) {

86 
couÁdown
 :ğ
io
.
³riod


87 
aùive
 :ğ
	`BoŞ
(
Œue
)

88 
	}
} .
–£wh’
 (
io
.
¡İ
 || 
couÁdown
 ==ğ
	$UIÁ
(0)) {

89 
aùive
 :ğ
	`BoŞ
(
çl£
)

90 
	}
} .
	$–£wh’
 (
aùive
) {

91 
couÁdown
 :ğcouÁdowÀ- 
	`UIÁ
(1)

92 
	}
}

94 
io
.
timeout
 :ğ
couÁdown
 ==ğ
UIÁ
(0è&& 
aùive


	@/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/package.scala

3 
·ckage
 
	gä“chs
.
rock‘ch


5 
impÜt
 
	gChi£l
.
_


6 
impÜt
 
	gsÿÏ
.
	gm©h
.
mš


8 
·ckage
 
objeù
 
	gut
 {

9 
im¶ic™
 
şass
 
	gUnz·bËO±iÚ
[
S
, 
T
](
v®
 
	gx
: 
O±iÚ
[(S, T)]) {

10 
def
 
	gunz
 = (
x
.
m­
(
_
.
_1
), 
	gx
.m­(_.
_2
))

13 
im¶ic™
 cÏs 
	cUIÁIsOÃOf
(
v®
 
x
: 
UIÁ
è
ex‹nds
 
AnyV®
 {

14 
def
 
	`isOÃOf
(
s
: 
Seq
[
UIÁ
]): 
BoŞ
 = s.
	`m­
(
x
 ==ğ
_
).
	`»duû
(_||_)

16 
def
 
	`isOÃOf
(
u1
: 
UIÁ
, 
u2
: UIÁ*): 
BoŞ
 = isOÃOf(u1 +: u2.
toSeq
)

17 
	}
}

19 
im¶ic™
 
şass
 
SeqToAugm’‹dSeq
[
T
 <: 
D©a
](
v®
 
x
: 
Seq
[T]è
ex‹nds
 
AnyV®
 {

20 
def
 
­¶y
(
idx
: 
UIÁ
): 
T
 = {

21 ià(
x
.
size
 <= 1) {

22 
x
.
h—d


23 } ià(!
isPow2
(
x
.
size
)) {

25 (
x
 ++ x.
keRight
(x.
size
 & -x.size)).
toSeq
(
idx
)

28 
v®
 
ŒuncIdx
 =

29 ià(
idx
.
isWidthKnown
 && idx.
g‘Width
 <ğ
log2Ce
(
x
.
size
)) idx

30 (
idx
 | 
UIÁ
(0, 
log2Ce
(
x
.
size
)))(log2Ceil(x.size)-1, 0)

31 (
	gx
.
	gh—d
 /: 
x
.
zW™hIndex
.

è{ (
´ev
, (
	gcur
, 
	gi
)è=> 
Mux
(
ŒuncIdx
 ==ğ
i
.
U
, 
cur
,…rev) }

35 
def
 
asUIÁ
(): 
UIÁ
 = 
C©
(
x
.
m­
(
_
.asUIÁ).
»v”£
)

37 
def
 
rÙ©e
(
n
: 
IÁ
): 
Seq
[
T
] = 
x
.
drİ
Òè++ x.
ke
(n)

39 
def
 
rÙ©e
(
n
: 
UIÁ
): 
Seq
[
T
] = {

40 
»quœe
(
isPow2
(
x
.
size
))

41 
v®
 
amt
 = 
n
.
·dTo
(
log2Ce
(
x
.
size
))

42 (
x
 /: (0 
uÁ
 
log2Ce
(x.
size
)))((
r
, 
	gi
è=> (r.
rÙ©e
(1 << 
i
è
z
„).
m­
 { (
s
, 
a
è=> 
Mux
(
amt
(i), s,‡) })

45 
def
 
rÙ©eRight
(
n
: 
IÁ
): 
Seq
[
T
] = 
x
.
keRight
Òè++ x.
drİRight
(n)

47 
def
 
rÙ©eRight
(
n
: 
UIÁ
): 
Seq
[
T
] = {

48 
»quœe
(
isPow2
(
x
.
size
))

49 
v®
 
amt
 = 
n
.
·dTo
(
log2Ce
(
x
.
size
))

50 (
x
 /: (0 
uÁ
 
log2Ce
(x.
size
)))((
r
, 
	gi
è=> (r.
rÙ©eRight
(1 << 
i
è
z
„).
m­
 { (
s
, 
a
è=> 
Mux
(
amt
(i), s,‡) })

55 
im¶ic™
 
şass
 
	$SeqBoŞB™wi£Ops
(
v®
 
x
: 
Seq
[
BoŞ
]è
ex‹nds
 
AnyV®
 {

56 
def
 & (
y
: 
Seq
[
BoŞ
]): Seq[BoŞ] = (
x
 
z
 y).
m­
 { (
a
, 
b
) =>‡ && b }

57 
def
 | (
y
: 
Seq
[
BoŞ
]): Seq[BoŞ] = 
	`·dZ
(
x
, y).
m­
 { (
a
, 
b
) =>‡ || b }

58 
def
 ^ (
y
: 
Seq
[
BoŞ
]): Seq[BoŞ] = 
	`·dZ
(
x
, y).
m­
 { (
a
, 
b
) =>‡ ^ b }

59 
def
 << (
n
: 
IÁ
): 
Seq
[
BoŞ
] = Seq.
	`fl
Ò)(
çl£
.
B
è++ 
x


60 
def
 >> (
n
: 
IÁ
): 
Seq
[
BoŞ
] = 
x
 
drİ
‚

61 
def
 
uÇry_
~(): 
Seq
[
BoŞ
] = 
x
.
	`m­
(!
_
)

62 
def
 
ªdR
: 
BoŞ
 = ià(
x
.
isEm±y
è
Œue
.
B
 x.
	`»duû
(
_
&&_)

63 
def
 
ÜR
: 
BoŞ
 = ià(
x
.
isEm±y
è
çl£
.
B
 x.
	`»duû
(
_
||_)

64 
def
 
xÜR
: 
BoŞ
 = ià(
x
.
isEm±y
è
çl£
.
B
 x.
	`»duû
(
_
^_)

66 
´iv©e
 
def
 
	`·dZ
(
y
: 
Seq
[
BoŞ
], 
z
: Seq[BoŞ]): Seq[(BoŞ, BoŞ)] = y.
	`·dTo
(z.
size
, 
çl£
.
B
è
z
 z.padTo(y.size, false.B)

67 
	}
}

69 
im¶ic™
 
şass
 
	gD©aToAugm’‹dD©a
[
T
 <: 
D©a
](
v®
 
x
: Tè
ex‹nds
 
AnyV®
 {

70 
def
 
hŞdUÆess
(
’abË
: 
BoŞ
): 
T
 = 
Mux
ÓÇbË, 
x
, 
RegEÇbË
(x,ƒnable))

73 
im¶ic™
 
şass
 
	gSeqMemToAugm’‹dSeqMem
[
T
 <: 
D©a
](
v®
 
x
: 
SeqMem
[T]è
ex‹nds
 
AnyV®
 {

74 
def
 
»adAndHŞd
(
addr
: 
UIÁ
, 
’abË
: 
BoŞ
): 
T
 = 
x
.
»ad
×ddr,ƒÇbËè
hŞdUÆess
 
RegNext
(enable)

77 
im¶ic™
 cÏs 
	cSŒšgToAugm’‹dSŒšg
(
v®
 
x
: 
SŒšg
è
ex‹nds
 
AnyV®
 {

79 
def
 
und”scÜe
: 
SŒšg
 = 
x
.

.
	`fŞdLeá
(x.
h—dO±iÚ
.
	`m­
(
_
.
toLow”
 + ""è
g‘OrEl£
 "") {

80 (
acc
, 
c
èc.
isUµ”
 =>‡cø+ "_" + c.
toLow”


81 (
acc
, 
c
) c == ' ' =>‡cc

82 (
acc
, 
c
) =>‡cc + c

86 
def
 
kebab
: 
SŒšg
 = 
x
.
toLow”Ca£
 
m­
 {

89 
c
 => c

92 
def
 
	`Çmed
(
Çme
: 
O±iÚ
[
SŒšg
]): String = {

93 
x
 + 
Çme
.
	`m­
("_Çmed_" + 
_
 ).
	`g‘OrEl£
("_with_no_name")

96 
def
 
	`Çmed
(
Çme
: 
SŒšg
): SŒšg =‚amed(
	`Some
(name))

97 
	}
}

99 
im¶ic™
 
def
 
	$uštToB™P©
(
x
: 
UIÁ
): 
B™P©
 = 
	$B™P©
(
x
)

100 
im¶ic™
 
def
 
	$wcToUIÁ
(
c
: 
WideCouÁ”
): 
UIÁ
 = c.
v®ue


102 
im¶ic™
 cÏs 
	cUIÁToAugm’‹dUIÁ
(
v®
 
x
: 
UIÁ
è
ex‹nds
 
AnyV®
 {

103 
def
 
	`£xtTo
(
n
: 
IÁ
): 
UIÁ
 = {

104 
	`»quœe
(
x
.
g‘Width
 <ğ
n
)

105 ià(
x
.
g‘Width
 =ğ
n
) x

106 
	`C©
(
	`Fl
(
n
 - 
x
.
g‘Width
, 
	`x
(x.getWidth-1)), x)

109 
def
 
	`·dTo
(
n
: 
IÁ
): 
UIÁ
 = {

110 
	`»quœe
(
x
.
g‘Width
 <ğ
n
)

111 ià(
x
.
g‘Width
 =ğ
n
) x

112 
	`C©
(
	`UIÁ
(0, 
n
 - 
x
.
g‘Width
), x)

116 
def
 
	`exŒaù
(
hi
: 
IÁ
, 
lo
: IÁ): 
UIÁ
 = {

117 
	`»quœe
(
hi
 >ğ
lo
-1)

118 ià(
hi
 =ğ
lo
-1è
	`UIÁ
(0)

119 
	`x
(
hi
, 
lo
)

123 
def
 
	`exŒaùO±iÚ
(
hi
: 
IÁ
, 
lo
: IÁ): 
O±iÚ
[
UIÁ
] = {

124 
	`»quœe
(
hi
 >ğ
lo
-1)

125 ià(
hi
 =ğ
lo
-1è
NÚe


126 
	`Some
(
	`x
(
hi
, 
lo
))

129 
def
 
	`rÙ©eRight
(
n
: 
IÁ
): 
UIÁ
 = iàÒ =ğ0è
x
 
	`C©
(
	`x
(n-1, 0), x >>‚)

131 
def
 
	`rÙ©eRight
(
n
: 
UIÁ
): UInt = {

132 
v®
 
amt
 = 
n
.
	`·dTo
(
	`log2Ce
(
x
.
g‘Width
))

133 (
x
 /: (0 
uÁ
 
	`log2Ce
(x.
g‘Width
)))((
r
, 
i
è=> 
	`Mux
(
	`amt
(i),„.
	`rÙ©eRight
(1 << i),„))

136 
def
 
	`rÙ©eLeá
(
n
: 
IÁ
): 
UIÁ
 = iàÒ =ğ0è
x
 
	`C©
(
	`x
(x.
g‘Width
-1-n,0), x(x.getWidth-1,x.getWidth-n))

138 
def
 
	`rÙ©eLeá
(
n
: 
UIÁ
): UInt = {

139 
v®
 
amt
 = 
n
.
	`·dTo
(
	`log2Ce
(
x
.
g‘Width
))

140 (
x
 /: (0 
uÁ
 
	`log2Ce
(x.
g‘Width
)))((
r
, 
i
è=> 
	`Mux
(
	`amt
(i),„.
	`rÙ©eLeá
(1 << i),„))

144 
def
 
	`addW¿p
(
y
: 
UIÁ
, 
n
: 
IÁ
): UInt = {

145 
v®
 
z
 = 
x
 +& 
y


146 ià(
	`isPow2
(
n
)è
	`z
Ò.
log2
-1, 0è
	`Mux
(
z
 >ğn.
U
, z -‚.U, z)(
	`log2Ce
(n)-1, 0)

150 
def
 
	`subW¿p
(
y
: 
UIÁ
, 
n
: 
IÁ
): UInt = {

151 
v®
 
z
 = 
x
 -& 
y


152 ià(
	`isPow2
(
n
)è
	`z
Ò.
log2
-1, 0è
	`Mux
(z(
z
.
g‘Width
-1), z +‚.
U
, z)(
	`log2Ce
(n)-1, 0)

155 
def
 
	`grou³d
(
width
: 
IÁ
): 
Seq
[
UIÁ
] =

156 (0 
uÁ
 
x
.
g‘Width
 
by
 
width
).
	`m­
(
ba£
 => 
	`x
(base + width - 1, base))

158 
def
 
	`šRªge
(
ba£
: 
UIÁ
, 
bounds
: UIÁèğ
x
 >= base && x < bounds

160 
def
 ## (
y
: 
O±iÚ
[
UIÁ
]): UIÁ = y.
	`m­
(
x
 ## 
_
).
	`g‘OrEl£
(x)

161 
	}
}

163 
im¶ic™
 
şass
 
	$O±iÚUIÁToAugm’‹dO±iÚUIÁ
(
v®
 
x
: 
O±iÚ
[
UIÁ
]è
ex‹nds
 
AnyV®
 {

164 
def
 ## (
y
: 
UIÁ
): UIÁ = 
x
.
	`m­
(
_
 ## y).
	`g‘OrEl£
(y)

165 
def
 ## (
y
: 
O±iÚ
[
UIÁ
]): O±iÚ[UIÁ] = 
x
.
	`m­
(
_
 ## y)

166 
	}
}

168 
im¶ic™
 cÏs 
	cBoŞ—nToAugm’‹dBoŞ—n
(
v®
 
x
: 
BoŞ—n
è
ex‹nds
 
AnyV®
 {

169 
def
 
toIÁ
: 
IÁ
 = ià(
x
) 1 0

172 
def
 
İtiÚ
[
T
](
z
: => T): 
O±iÚ
[T] = ià(
x
è
	`Some
(zè
NÚe


173 
	}
}

175 
im¶ic™
 cÏs 
	cIÁToAugm’‹dIÁ
(
v®
 
x
: 
IÁ
è
ex‹nds
 
AnyV®
 {

177 
def
 
log2
: 
IÁ
 = {

178 
	`»quœe
(
	`isPow2
(
x
))

179 
	`log2Ce
(
x
)

181 
	}
}

183 
def
 
	$OH1ToOH
(
x
: 
UIÁ
): UIÁ = (x << 1 | 
	`UIÁ
(1)è& ~
	`C©
(UIÁ(0, 
width
=1), x)

184 
def
 
	$OH1ToUIÁ
(
x
: 
UIÁ
): UIÁ = 
	`OHToUIÁ
(
	$OH1ToOH
(
x
))

185 
def
 
	$UIÁToOH1
(
x
: 
UIÁ
, 
width
: 
IÁ
): UIÁ = ~(
	`SIÁ
(-1, width=width).
asUIÁ
 << x)(width-1, 0)

187 
def
 
	$ŒašgZ”os
(
x
: 
IÁ
): 
O±iÚ
[IÁ] = ià(x > 0è
	`Some
(
	`log2Ce
(x & -x)è
NÚe


190 
def
 
	$ËáOR
(
x
: 
UIÁ
): UIÁ = 
	$ËáOR
(
x
, x.
g‘Width
, x.getWidth)

191 
def
 
	$ËáOR
(
x
: 
UIÁ
, 
width
: 
IÁeg”
, 
ÿp
: Integer = 999999): UInt = {

192 
v®
 
¡İ
 = 
	`mš
(
width
, 
ÿp
)

193 
def
 
	`h–³r
(
s
: 
IÁ
, 
x
: 
UIÁ
): UInt =

194 ià(
s
 >ğ
¡İ
è
x
 
	`h–³r
(s+s, x | (x << s)(
width
-1,0))

195 
	`h–³r
(1, 
x
)(
width
-1, 0)

196 
	}
}

199 
def
 
	$rightOR
(
x
: 
UIÁ
): UIÁ = 
	$rightOR
(
x
, x.
g‘Width
, x.getWidth)

200 
def
 
	$rightOR
(
x
: 
UIÁ
, 
width
: 
IÁeg”
, 
ÿp
: Integer = 999999): UInt = {

201 
v®
 
¡İ
 = 
	`mš
(
width
, 
ÿp
)

202 
def
 
	`h–³r
(
s
: 
IÁ
, 
x
: 
UIÁ
): UInt =

203 ià(
s
 >ğ
¡İ
è
x
 
	`h–³r
(s+s, x | (x >> s))

204 
	`h–³r
(1, 
x
)(
width
-1, 0)

205 
	}
}

207 
def
 
	$O±imiz©iÚB¬r›r
(
x
: 
UIÁ
): UInt = ~(~x)

208 
def
 
O±imiz©iÚB¬r›r
[
T
 <: 
D©a
](
x
: T): T = 
	`O±imiz©iÚB¬r›r
(x.
asUIÁ
).
	`asTy³Of
(x)

209 
	}
}

	@
1
.
1
/usr/include
253
21713
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Protocol.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Test.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/ToTL.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/ahb/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Protocol.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Test.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/apb/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/AsyncCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Buffer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/CrossingHelper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Deinterleaver.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Delayer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Filter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Fragmenter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/IdIndexer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Protocol.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Test.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/ToTL.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/UserYanker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/amba/axi4/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/config/Config.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Custom.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DMI.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Debug.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugRomContents.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/DebugTransport.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/Periphery.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/SBA.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/abstract_commands.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/debug/dm_registers.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BootROM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBlocker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/BusBypass.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/CLINT.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Deadlock.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/DevNull.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Error.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MaskROM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/MasterMux.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/PhysicalFilter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Plic.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/TestRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/devices/tilelink/Zero.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressDecoder.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/AddressRange.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/BundleBridge.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ClockDomain.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Clone.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/CloneModule.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/DeviceTree.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/FixedClockResource.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/JSON.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/LazyModule.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/Resources.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/ValName.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/diplomacy/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/DummyPTW.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Generator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/GroundTestSubsystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Status.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TestHarness.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/Tile.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/groundtest/TraceGen.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Crossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/CrossingHelper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/NullIntSource.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/interrupts/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagShifter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagStateMachine.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagTap.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/JtagUtils.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/Utils.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/jtag/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/Annotation.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/DescribedReg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegField.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegMapper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/regmapper/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ALU.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/AMOALU.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BTB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Breakpoint.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/BusErrorUnit.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/CSR.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Consts.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/DCache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Decode.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Events.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Frontend.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/HellaCacheArbiter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IBuf.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ICache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/IDecode.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Instructions.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/Multiplier.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/NBDcache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PMP.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/PTW.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RVC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/RocketCore.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/ScratchpadSlavePort.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/SimpleHellaCacheIF.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/TLBPermissions.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/rocket/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/scie/SCIE.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/BaseSubsystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/CrossingWrapper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/FrontBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/HasTiles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/InterruptBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/MemoryBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/PeripheryBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/Ports.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RTC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/ResetVector.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/RocketSubsystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/subsystem/SystemBus.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/ExampleRocketSystem.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/Generator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/RocketTestSuite.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/system/TestHarness.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/BaseTile.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Core.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/CustomCSRs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/FPU.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/Interrupts.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/L1Cache.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/LazyRoCC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tile/RocketTile.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AddressAdjuster.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Arbiter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AsyncCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/AtomicAutomata.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Atomics.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BankBinder.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Broadcast.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Buffer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Bundles.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/BusWrapper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CacheCork.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/CrossingHelper.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Delayer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Edges.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ErrorEvaluator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Example.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/FIFOFixer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Filter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fragmenter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Fuzzer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/HintHandler.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Isolation.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Map.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Metadata.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Monitor.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/NodeNumberer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Nodes.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Parameters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/PatternPusher.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ProbePicker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RAMModel.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RationalCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegionReplication.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/RegisterRouterTest.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/SourceShrinker.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Splitter.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAHB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAPB.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/ToAXI4.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/WidthWidget.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/Xbar.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/tilelink/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Configs.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/Generator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestGenerator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/TestHarness.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/UnitTest.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/unittest/package.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Annotations.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Arbiters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/AsyncResetReg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Broadcaster.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/BundleMonitorKey.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/CRC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockDivider.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ClockGate.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Counters.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Crossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/DescribedSRAM.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ECC.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Frequency.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GeneratorUtils.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/GenericParameterizedBundle.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HellaQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/HeterogeneousBag.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IDPool.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/IdentityModule.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LCG.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/LatencyPipe.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Misc.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MultiWidthFifo.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/MuxLiteral.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PSDTestMode.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PlusArg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/PositionalMultiQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Property.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ROMGenerator.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/RationalCrossing.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReduceOthers.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ReorderQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Repeater.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Replacement.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ResetCatchAndSync.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/SeededRandom.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftQueue.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/ShiftReg.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/Timer.scala
/home/seon/priv-code-lock/freedom/rocket-chip/src/main/scala/util/package.scala
